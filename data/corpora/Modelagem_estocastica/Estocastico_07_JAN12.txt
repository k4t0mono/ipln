O teste estatístico utilizando modelos de uso é uma técnica de teste de software largamente reconhecida pela comunidade de engenharia de software.

Estes modelos de uso representam os possíveis usos do sistema por parte do usuário, encerrando em si os estados do sistema e as ações do usuário que disparam transições entre estes estados, às quais se agregam taxas ou probabilidades de transição.

Um formalismo de modelagem é empregado para representar este modelo de uso, sendo que as cadeias de Markov constituem uma espécie de referência nos trabalhos desenvolvidos na área.

O objetivo deste trabalho é apresentar o formalismo de Redes de Autômatos Estocásticos (SAN) como uma poderosa alternativa de modelagem de uso.

As atividades desenvolvidas, que envolvem estudos de caso de modelagem aplicando ambos os formalismos, além de geração de casos de teste a partir dos modelos criados, visam demonstrar os diversos aspectos do formalismo proposto aplicado ao teste estatístico baseado em modelos de uso, mostrando suas vantagens, limitações e características relevantes.

Como contribuição deste trabalho deseja-se disponibilizar o formalismo SAN como uma poderosa alternativa de modelagem de uso através dos subsídios fornecidos pelo processo investigativo, apontando para diversos trabalhos futuros.

A complexidade do desenvolvimento de software acaba por demandar o uso de métodos formais sofisticados para descrevê-lo.

Esta descrição formal do software apresenta benefícios para todas as fases do ciclo de vida do desenvolvimento de software.

Em uma destas fases, o teste de software, utiliza-se de várias técnicas para a geração de casos de teste1 visando encontrar falhas no programa que levem à correção de erros em sua codificação.

As principais técnicas, advindas da década de 70, são o teste funcional, que testa os comportamentos do sistema tendo por base documentos de especificação.
O teste estrutural, que que visa testar a aplicação com base em seu código-fonte, o teste baseado em máquinas de estado finitos, que se utiliza de uma descrição da aplicação por meio de máquinas de estados como base para a geração dos testes, e a análise de mutantes ou teste de mutações, que baseia-se na inserção de erros como forma de descobrir outros erros.

Estas técnicas, através da análise de entradas do programa, caminhos percorridos, saídas, dentre outros, visam analisar o máximo de situações de falha possíveis.

No entanto, tal exaustividade torna-se impraticável, devido ao alto custo e até mesmo à quantidade infinita de possibilidades que apresenta.

Há alguns anos a comunidade de Engenharia de Software tem direcionado sua atenção ao teste estatístico utilizando modelos de uso.

O teste estatístico associa a ciência estatística à solução de problemas inerentes à dificuldade em inferir-se a respeito do grau de confiabilidade dos testes aplicados ao software e a certas lacunas deixadas pelas técnicas tradicionais de teste.

O benefício advindo da utilização do teste estatístico de maneira conjunta com as técnicas tradicionais de teste de software é a computação de aspectos probabilísticos do processo, como a confiabilidade, tempo médio para falha (MTTF), tempo médio entre falhas (MTBF) dentre outras métricas.

Os modelos de uso empregados no teste estatístico tratam da descrição dos possíveis usos de um sistema e suas interações com o usuário através do emprego de um modelo de estados discretos, logo, as cadeias de Markov tornam-se a maneira mais simples e direta de representá-los.

Uma cadeia de Markov, um dos mais antigos formalismos de descrição de modelos de estados discretos, representa o sistema como um conjunto de estados juntamente com as transições entre estes estados.

A cada transição é atribuída uma taxa ou probabilidade de transição, diferenciando-se assim de formalismos de descrição não probabilística de sistemas, como os diagramas de estados (DE), máquinas de estado finitas (FSM), dentre outros.

Os diversos trabalhos relacionados ao uso de cadeias de Markov no teste estatístico acabam por mostrar este formalismo uma espécie de referência na descrição dos modelos de uso.

Ainda no capítulo 2 são apresentadas as Redes de Autômatos Estocásticos (SAN), um formalismo de descrição de modelos de estados discretos mais sofisticado e com o mesmo poder de descrição das cadeias de Markov.

Em SAN o sistema é apresentado não mais como um conjunto de estados e transições simplesmente, mas sim através de uma coleção de subsistemas descritos por estados locais e transições entre estes estados, podendo haver interação entre os diferentes subsistemas, chamados de autômatos.

O presente trabalho tem por objetivo geral investigar o uso de Redes de Autômatos Estocásticos (SAN) no Teste Estatístico de Software.

Durante a sua realização buscou-se apurar as vantagens e desvantagens das SAN em termos de construção de modelos de uso para teste estatístico, evidenciando as características da SAN que superariam as limitações das cadeias de Markov, apresentadas como uma espécie de referência.

A metodologia adotada para atingir os objetivos propostos foi a realização de estudos de caso de modelagem de uso empregando ambos os formalismos destacados, como meio prático de observação de seus comportamentos.

Nesta dissertação, apresenta-se a descrição dos estudos de caso realizados com base em duas aplicações distintas, pormenorizando os detalhes de sua execução, atividades realizadas e resultados obtidos.

Os modelos gerados foram tomados como base para a geração de casos de teste, finalidade principal destes modelos no que tange o teste estatístico, cujo processo, atividades de apoio e resultados são igualmente descritos.

Vários estudos na área de avaliação de desempenho demonstram vantagens do uso de SAN com relação às cadeias de Markov.

Logo, o presente trabalho visa dar uma base do estado da arte do Teste Estatístico de Software baseado em modelos de uso e apresentar o formalismo SAN como uma poderosa alternativa para este tipo de modelagem.

As limitações apresentadas pelo formalismo dominante nos trabalhos estudados, analisados frente às características do formalismo SAN acabam por sugerir vantagens do seu emprego na construção de modelos de uso para o teste estatístico de software.

A metodologia adotada no intuito de verificar tais indícios foi o desenvolvimento de dois estudos de caso de modelagem de uso envolvendo as ferramentas DocsEditor, um editor de documentos baseados em formulários genéricos desenvolvido no projeto CPTS, e a ferramenta BTS, um sistema de acompanhamento de defeitos (Bug Tracking System).

Nestes estudos de caso, realizou-se o processo de modelagem de uso envolvendo os dois formalismos abordados, cadeias de Markov e SAN, procedendo uma análise do processo de modelagem e do resultado obtido.

Foi realizado também o processo de geração de casos de teste a partir dos modelos criados, dando prosseguimento ao processo de teste estatístico, e servindo de fonte de comparação entre os formalismos e modelos.

Os estudos de caso realizados subsidiam as conclusões apresentadas no capítulo 4 e apontam os trabalhos futuros na área.

Temos como contribuição esperada deste trabalho a confirmação das vantagens empíricas das SAN no nicho específico do Teste Estatístico de Software, possibilitando uma forma mais eficiente de armazenar as características estatísticas comportamentais de um sistema, tanto em termos de representação quanto em termos de computação de suas informações.

Como base de sustentação teórica para a realização deste trabalho, foi realizado um levantamento bibliográfico dos conteúdos básicos envolvidos no escopo do trabalho, como Cadeias de Markov, Redes de Autômatos Estocásticos e as bases do Teste Estatístico de Software.

Além disso, foi realizada uma pesquisa retratando o estado da arte em termos de teste estatístico de software, especialmente o que utiliza modelos de uso, descrevendo alguns dos trabalhos relacionados que motivaram o trabalho.

Este capítulo apresenta os elementos básicos do Teste Estatístico, abordando as características dos Modelos de Uso empregados no processo, além da caracterização dos formalismos de modelagem de sistemas estudados, as cadeias de Markov e as Redes de Autômatos Estocásticos.

Dentro da área de teste de software, existem várias técnicas de geração de casos de teste que visam encontrar falhas no programa que levem à correção de erros em sua codificação.

As principais técnicas são o teste funcional e o teste estrutural.

O teste funcional, também chamado de teste black-box ou data-driven, consiste na visualização da aplicação em termos de seus valores de entrada e saída.

O termo black-box se deve ao fato de a aplicação ser vista como uma caixa fechada, ou seja, uma caixa a que não se tenha acesso ao seu conteúdo, onde o usuário não possui informações a respeito de sua estrutura e comportamento interno.

Nesta técnica de teste, o interesse reside em verificar circunstâncias em que a aplicação não se comporta de acordo com o que fora especificado.

Outra técnica para geração de casos de teste é o teste estrutural, também chamado de whitebox ou glass-box.

Esta metáfora é utilizada para representar que o teste estrutural, como o próprio nome sugere, examina a estrutura da aplicação, ou seja, o conteúdo da "caixa" que no teste funcional era "caixa-preta".

Assim, através da análise da lógica e código da aplicação, chega-se a testes que avaliam as funcionalidades da aplicação conforme elas estão atualmente implementadas, e não de acordo com uma especificação prévia.

Estas técnicas, através da análise das entradas do programa, caminhos percorridos e saídas, visam cobrir o máximo de aspectos diferentes das entradas.

No entanto, tal exaustividade acaba tornando-se impraticável, devido ao alto custo e até mesmo à quantidade virtualmente infinita de possibilidades que apresenta.

Diante desta situação, a questão de selecionar as prioridades e até mesmo "o que testar" acaba não encontrando um apoio confiável nestas técnicas.

Neste contexto, não é possível inferir a respeito do grau de confiabilidade dos testes.

Assim, o teste estatístico de software associa a ciência estatística à solução destes problemas.

O seu principal benefício é permitir o uso de técnicas de inferência estatística para computar aspectos probabilísticos do processo de teste, como a sua confiabilidade, tempo médio para falha (MTTF), tempo médio entre falhas (MTBF), etc.

O Teste Estatístico, no entanto, não deve ser encarado como uma técnica de teste de software que venha a substituir o teste funcional ou o estrutural.

Na verdade, o teste estatístico visa empregar princípios estatísticos e probabilísticos, através de modelos de uso, profiles, etc, no processo de teste de software, utilizando-se das técnicas tradicionais abordadas, no nosso caso, em especial, do teste funcional.

Assim, as inovações do teste estatístico se apresentam mais em termos de processo de teste do que efetivamente em termos de técnicas.

É apresentado o processo típico do teste estatístico, que é dividido em análise da especificação, o modelo de uso deve ser desenvolvido partindo-se da especificação do comportamento correto do sistema.

Este pode ser definido através de especificação formal, documentação dos requisitos, manual do usuário, protótipo, etc.

Desenvolvimento da Estrutura do Modelo, são identificados os estados e arcos de transi ção entre eles, através de um processo manual.

Atribuição de Probabilidades, as probabilidades de transição entre os estados do modelo são atribuídas manualmente ou calculadas automaticamente a partir de análise do uso.

Verificação e Análise do Modelo, nesta etapa são realizados cálculos sobre o modelo no intuito de apoiar o planejamento dos testes, validar o modelo e assim por diante.

Execução de Testes Não-Aleatórios, são gerados casos de teste para cobrir todos os arcos do modelo, seguindo a ordem das probabilidades de ocorrência.

Execução de Testes Pseudo-Aleatórios (Random Testing), são gerados testes pseudoaleatórios a partir do modelo, podendo ser executados de maneira automática ou manual1.

Estimação da Confiabilidade, é realizada a análise dos registros do teste aleatório, no intuito de estimar a confiabilidade a partir do registro das falhas ocorridas e dos estados em que ocorreram.

Um exemplo deste registro são as cadeias de teste.

Decisão de Parada do Teste, consiste na avaliação do registro de teste, decidindo quando o teste deve parar ou prosseguir.

Relato dos Resultados, após encerrados os testes, seus resultados podem ser utilizados para decidir sobre a liberação de um produto, avaliar o grau de controle do processo de desenvolvimento, avaliar o desempenho de novos elementos integrados ao sistema, e uma série de outros usos.

Um modelo de uso caracteriza o uso operacional de um sistema.

Na construção destes modelos são levados em conta o uso do software, sessão de trabalho, transação ou outra unidade de serviço limitada por um evento de início e fim, o usuário, pessoa, periférico ou outro sistema, o ambiente de uso, plataforma, quantidade de usuários, aplicação concorrente (paralela, distribuída, etc), e demais aspectos que interferem no comportamento do sistema.

A estrutura do modelo de uso é composta por um conjunto de estados e transições entre estes estados, constituindo um grafo.

Os nodos do grafo representam os estados do modelo, e os arcos do grafo representam as transições entre os estados.

Esta estrutura descreve os usos possíveis do software.

Ao associar uma distribuição de probabilidade à estrutura do modelo, este passa a descrever o uso esperado do software.

Os modelos de uso, portanto, podem ser representados por formalismos de modelagem de sistemas baseados em estados discretos, sendo usualmente empregadas as cadeias de Markov.

Assim, temos os estados de uso do software mapeados em estados da cadeia, além das ações do usuário mapeadas em transições entre estes estados.

As probabilidades de transição representam a expectativa de uso deste sistema, configurando o padrão de uso esperado do software modelado.

A peculiaridade dos modelos utilizando cadeias de Markov é a necessidade de dois estados adicionais representando o início e o fim do uso do software, sendo estes os únicos estados inicial e final da cadeia, respectivamente.

Devido ao fato de constituir um modelo formal do software modelado, o modelo de uso pode ser aplicado a diversas fases do ciclo de vida do software.

Ele pode ser utilizado para validar os requisitos do sistema, avaliar complexidade, apoiar o processo de verificação do software, gerar automaticamente casos de teste, direcionar testes (não-aleatórios), identificar freqüência de eventos, projetar custo e recursos para os testes, definir critérios quantitativos do teste, critérios de parada, confiabilidade do software, dentre outras aplicações.

No âmbito do teste estatístico, tais modelos permitem ao engenheiro de teste, pessoa responsável pela criação dos testes e gerência de sua execução, visualizar caminhos críticos, mais suscetíveis a falha, direcionando os esforços de teste neste sentido.

Tal vantagem advém da análise das probabilidades de ocorrência associadas a cada uso do software.

Através da análise da informação de uso contida nestes modelos, torna-se possível extrair propriedades importantes do sistema, como número de caminhos de uso típicos do software, ocupação de longo prazo, como por exemplo o percentual de utilização do tempo para cada estado, número médio de eventos por caso de teste, número médio de eventos entre dois estados.

Um processo estocástico é definido como uma família de variáveis aleatórias definidas em um espaço de probabilidades e indexadas por um parâmetro.

Este parâmetro, usualmente, refere-se a um conjunto de índices do tempo do processo, ou intervalo de tempo.

Se tivermos tempo discreto temos um processo estocástico discreto, enquanto no caso de tempo contínuo temos um processo estocástico contínuo.

Este processo estocástico é definido como processo markoviano quando caracteriza-se por não possuir memória em relação ao passado do sistema.

Isso significa que apenas o estado atual do sistema influencia o próximo passo.

É possível representarmos o comportamento de um sistema descrevendo todos os diferentes estados que este venha a apresentar e indicando as transições possíveis de um estado para outro durante a sua execução.

Este sistema pode ser representado como um processo markoviano quando o tempo gasto em cada estado apresenta-se exponencialmente distribuido.

A este processo markoviano está associado um conjunto de estados, sendo que este sistema pode assumir apenas um estado em qualquer momento.

A evolução do sistema é representada por transições do processo de um estado para outro, transições estas que, assume-se, ocorrem de maneira instantânea (sem consumir tempo).

Quando o espaço de estados de um processo markoviano é discreto, apresentando um número finito de estados enumeráveis, nos referimos a ele como uma Cadeia de Markov.

Estas cadeias dividem-se, de acordo com a escala de tempo, em Cadeias de Markov de Tempo Discreto (DTMC) e Cadeias de Markov de Tempo Contínuo (CTMC).

Nas cadeias de tempo discreto (DTMC), temos probabilidades condicionais de ocorrerem transi ções de um estado para o outro.

Estas probabilidades de transição da Cadeia de Markov podem ser representadas como Pij probabilidade de transição do estado i para o estado j nas cadeias homogêneas, cujas transições independem do tempo, ou como Pij(n) probabilidade de transição do estado i para o estado j em um tempo nas cadeias não-homogêneas, cujas transições dependem do tempo.

Estas probabilidades são representadas por um número real entre 0 e 1, sendo que a soma de todas as probabilidades de transição de um estado para cada um dos demais deve resultar em 1.

As probabilidades de transição das cadeias de Markov são representadas através de matrizes de dimensões n x n, sendo n o número de estados desta cadeia.

Estas matrizes são chamadas estocásticas devido ao fato de que cada linha que as compõe é uma distribuição (soma das probabilidades igual a 1).

No caso das cadeias de tempo discreto, esta matriz é chamada de matriz de probabilidades de transição, e no caso das cadeias de tempo contínuo ela é chamada de matriz de taxas de transição.

No caso das matrizes das cadeias de tempo contínuo, devido aos valores das taxas representarem a freqüência com que as transições ocorrem, a soma dos valores das linhas da matriz não somam a unidade (igual a um).

Para solucionar esta diferença, a diagonal principal da matriz é composta por valores negativos, fazendo com que as linhas somem zero.

Estas matrizes estocásticas apresentam correspondência de um para um com o diagrama que representa uma mesma cadeia de Markov.

A análise do processo estocástico é dita estacionária quando analisa as características estatísticas do modelo de maneira independente do tempo t em que sua observação é iniciada, ou seja, quando o processo não varia, julgando-se um tempo próximo ao infinito.

Já a análise transitória realiza a análise de um estado em função de outro estado prévio, ou seja, a análise probabilística de uma trajetória no espaço de estados.

Através da modelagem do sistema sob a forma de uma cadeia de Markov, apesar do fato desta não possuir memória com relação a estados anteriores da cadeia, pode-se conhecer as probabilidades de se estar em determinado estado, ou conjunto destes, em determinado momento posterior ao início do processo, estimar quanto tempo é necessário para atingir-se determinado estado pela primeira vez, e uma série de outras métricas relativas ao sistema e sua evolução.

Temos um modelo de uso simples, utilizando cadeia de Markov, para parte de uma aplicação de operações bancárias, onde o usuário precisa digitar uma senha válida para acessar o menu de opções.

Os modelos de uso operacionais constituem um formalismo que permite a aplicação de diversos princípios estatísticos ao teste de software, além de formar uma base de apoio a decisão para um teste eficiente.

O argumento em favor de um processo estocástico para representá-lo é o de refletir o fato de que um sistema se desenvolve em razão do tempo.

Já o argumento em favor das cadeias de Markov como representação destes modelos de uso advém de sua simplicidade e familiaridade.

As cadeias de Markov apresentam uma alta versatilidade, podendo ser representadas por matrizes estocásticas, gramáticas estocásticas, grafos direcionados e sistemas de equações.

Cada uma destas representações agrega benefícios materiais distintos ao teste estatístico.

Atualmente, os referidos modelos têm provado sua funcionalidade e importância na prática, e demonstrado melhorias e benefícios frente a práticas de teste menos formais.

Um modelo de uso que observa a lei de probabilidades de uma cadeia de Markov não apresenta precisão e complexidade capazes de representar o comportamento interno de um sistema.

No entanto, sua vantagem principal advém do fato de que descrever e analisar o uso de uma determinada aplicação é muito mais simples do que analisar todo o seu comportamento.

A habilidade em construir modelos de uso codificados em cadeias de Markov em vários níveis de abstração tem sido demonstrada para diversos tipos de aplicações, como sistemas embutidos, sistemas em tempo real, compiladores, sistemas de gerência de bancos de dados, interfaces gráficas com o usuário, aplicações de comércio eletrônico, entre outras.

Estatísticas de longo prazo obtidas por estes modelos de uso em cadeias de Markov tem representado de maneira satisfatória o uso de longo prazo esperado para estas aplicações.

Além disso, a inclusão de restrições no modelo acabam por qualificar ainda mais a validação da aplicação a partir destes modelos.

Na medida em que os referidos modelos aumentam em tamanho e complexidade de seus componentes, bem como com o aumento da complexidade das estatísticas incorporadas ao modelo, as cadeias de Markov acabam por sentir carência de uma maior robustez3, como forma de comportar este crescimento.

No entanto, tal fator de maneira alguma ofusca os benefícios agregados ao processo por este formalismo.

Neste ponto, o formalismo SAN (como veremos adiante) pode utilizar-se de todo o poderio representativo das cadeias de Markov, oferecendo a robustez desejada e necessária.

Juntamente do estudo dos aspectos teóricos relacionados aos formalismos tratados neste trabalho, buscou-se identificar trabalhos relacionados que ilustrassem a prática aplicada de tais conceitos na pesquisa atual.

Alguns trabalhos, como a Tese de Doutorado de Kirk Sayre e o trabalho de James Whittaker e Michael Thomason constituiram uma espécie de ponto de partida para a pesquisa desenvolvida no decorrer deste trabalho.

O trabalho de James Whittaker e Michael Thomason propõe a utilização das cadeias de Markov como formalismo para a modelagem de uso de aplicações para teste estatístico de software.

A utilização do teste estatístico e dos modelos de uso empregando cadeias de Markov é embasada na necessidade de métodos estatísticos e modelos de confiabilidade na aplicação do teste funcional, ou black-box testing.

Para tal, é proposto o uso de duas cadeias de Markov diferentes neste processo, a cadeia de uso e a cadeia de teste.

A cadeia de uso consiste no modelo de uso em si, ou seja, a representação dos estados e transições do sistema, juntamente com suas probabilidades de ocorrência.

O objetivo desta cadeia é o de apoiar o processo de geração dos casos de teste a serem executados, possibilitando a aplicação de critérios de cobertura diversos.

Tanto o processo de geração quanto o de execução dos casos de teste pode se processar de maneira manual ou automática.

Já a cadeia de teste é montada a partir dos dados obtidos no processo de teste.

A cadeia é alimentada pelos registros de teste, constituindo uma espécie de histórico do processo.

Até mesmo as situações de falha passam a fazer parte da cadeia (um diferencial em relação à cadeia de uso), possibilitando inferir a respeito da confiabilidade da aplicação de acordo com a evolução da cadeia a medida em que novas versões da aplicação são testadas, incorporando-se à cadeia.

Assim, o trabalho aborda exemplos de aplicação das cadeias de uso e teste, mostrando um critério de parada desenvolvido para tais exemplos.

Este critério de parada, chamado log-likelihood ratio ou discriminante de Kullback, também tratado na Tese de Sayre, constitui um importante instrumento de análise do processo de teste estatístico e da confiabilidade da aplicação.

Em seguida ao trabalho de Whittaker, Bruno Marre e outros, apresentam uma espécie de comparativo entre o Teste Estatístico de Software e o Teste Formal.

O Teste Formal consiste na verificação formal das propriedades do sistema, especificadas através de fórmulas.

Estas propriedades são verificadas através de dados de teste gerados a partir de hipóteses definidas pelo usuário.

Assim, é executado o teste formal através da geração de testes funcionais a partir de uma especificação formal.

Os resultados obtidos, que exprimem a conformidade, ou não, da implementação atual para com o que foi formalmente especificado, são comparados com o teste estatístico, tanto funcional quanto estrutural.

A comparação é realizada levando-se em conta os conjuntos de dados de teste gerados e o processo em si.

Este trabalho apresenta como conclusões vantagens do teste estatístico frente ao formal, justamente pela flexibilidade e facilidade de construção de seus modelos.

Os modelos estatísticos apresentam-se como um modelo formal de especificação, podendo estabelecerse processos automáticos de geração de informações a partir destes modelos.

Seguindo os passos da pesquisa de Whittaker e Thomason, a tese de doutorado de Kirk Sayre, da Universidade do Tennessee, Knoxville, constituiu uma espécie de base teórica para o nosso trabalho, em termos de teste estatístico, devido ao grau de cobertura do assunto.

O texto aborda os conceitos do teste estatístico, seu processo típico empregado em problemas do mundo real, análise quantitativa dos modelos de uso para planejamento de testes, modelos de confiabilidade, técnicas de teste por particionamento a partir de modelos de uso, e critérios de parada para o processo de teste.

A parte da tese que trata de análise quantitativa e planejamento de teste aborda exemplos obtidos a partir da indústria, mostrando informações padronizadas obtidas a partir destes modelos.

Tais informações vão desde características explícitas do modelo, como número de estados e número de arcos, por exemplo, até estimativas quanto ao tamanho médio e variância dos casos de teste, custos estimados de simulação e estimativas de cobertura.

Além disso, é apresentado um exemplo detalhado e estatísticas a serem utilizadas no planejamento dos testes, como número de casos de teste necessários para cobrir todos os arcos, probabilidade de um arco aparecer em um caso de teste, e assim por diante.

Em seguida, a tese de Sayre aborda modelos de confiabilidade baseados em arcos.

Nele são destacados o modelo de confiabilidade de Miller, que contém o conhecimento prévio do sistema em teste, a estratégia de particionamento do arco terminal, os estimadores de confiabilidade de uso único e de ação única e a utilização de informações de confiabilidade de testes anteriores.

Em seu capítulo 4, Sayre aborda o teste por particionamento, caracterizando estratégias de particionamento baseadas em modelos e estimativas referentes à alocação de testes.

São tratadas as estratégias analítica e baseada em simulação.

A parte referente à critérios de parada do processo de teste trata da discussão de métodos efetivos de comparação da experiência adquirida no processo de teste com relação ao uso esperado da aplicação.

São abordadas duas maneiras de analisar tal situação, que são a distância Euclideana e o discriminante de Kullback.

A partir delas é possível averiguar a convergência das cadeias de teste para as cadeias de uso da aplicação, possibilitando inferir a respeito da confiabilidade da aplicação, qualidade dos testes gerados, dentre outras possibilidades.

Dentre estes métodos analíticos, o discriminante de Kullback recebe atenção especial, sendo descrito em maior detalhe.

Este discriminante é calculado tendo por base as probabilidades do modelo de uso da aplicação e as probabilidades obtidas no processo de teste, aplicando os casos de teste gerados a partir do modelo de uso.

Logo, o discriminante de Kullback procura calcular as discrepâncias entre os valores esperados e obtidos, servindo de indicador de convergência ou não dos dados de teste para com os valores esperados.

Desta maneira, este método provê um critério qualitativo de parada que ferramenta o processo de tomada de decisão do Engenheiro de Teste.

Em abordagem semelhante a de Sayre, Gwendolyn Walton e Jesse Poore apresentam as diretrizes do teste estatístico baseado em modelos de uso, descrevendo as características dos modelos de uso empregando cadeias de Markov e as principais dificuldades encontradas na sua prática atual, em especial em termos de consistência e atualização efetivas de suas probabilidades de transição.

O diferencial apresentado por este trabalho frente ao de Sayre é uma nova abordagem para a definição dos modelos de uso, o uso de restrições, ou constraints de teste.

Estas constraints podem ser estruturais ou de uso.

As constraints estruturais são aquelas que definem a estrutura da matriz de transição, ou seja, definem quais transições são certas (probabilidade igual a 1), impossíveis (probabilidade igual a zero) ou variáveis (probabilidade entre no intervalo).

Já as constraints de uso definem os valores de transições particulares ou então a relação entre transições.

Isso se dá através de limitações numéricas impostas, ou seja, a definição dos valores mínimos e máximos para uma transição.

A proporcionalidade definida para transições de igual probabilidade, mas cujo valor não é conhecido, ou a relação funcional entre valores de diferentes transições.

A partir do momento em que a estrutura do modelo e suas constraints estão definidos, parte-se então para a obtenção dos valores para as transições a partir da solução de sistemas de equações.

No intuito de manter o modelo com alta flexibilidade e manutenibilidade, é proposto um método de desenvolvimento e otimização iterativo para as probabilidades de transição, método este descrito no texto e ilustrado através de exemplos.

OS detalhes avançados deste processo com o acréscimo de resultados experimentais são apresentados.

O último trabalho relacionado, trata da utilização da estratégia de teste estatístico para o contexto específico do teste de aplicações WEB.

Ainda são apresentadas as UMM, como formalismo hierárquico definido para o teste estatístico de aplicações WEB e análise de confiabilidade.

No decorrer do trabalho são apresentadas as principais características das aplicações WEB, enfatizando sua complexidade e a necessidade de estratégias de domínio específico para proceder um teste de maior qualidade e confiabilidade.

As técnicas tradicionais encontradas no mercado são citadas, como o teste de funcionalidade, carga, navegador, dentre outros, destacando-se os pontos em que estas técnicas mostram-se não suficientes ou pouco confiáveis.

Assim como os demais trabalhos em teste estatístico de software, este destaca duas etapas fundamentais, a criação de um modelo, seja ele um modelo de uso markovianos ou os chamados Operational Profiles, e utilização deste guia para o processo de teste.

O diferencial evidenciado neste trabalho é a proposição de uso de um formalismo próprio, as UMM, ditas como mais especializadas para a modelagem de uso de aplicações WEB, por capturarem informações referentes ao fluxo de controle, fluxo de informações, processamento de transações, informações críticas e do uso em si.

Outra idéia apresentada é a da criação automática das UMM através dos logs dos servidores WEB.

Ainda são apresentados os elementos referentes à análise de uso e confiabilidade das aplicações empregando modelos de uso em UMM, com a descrição de um site utilizado como exemplo para todos os passos do processo.

Assim, os referidos trabalhos apresentaram o teste estatístico e seus modelos de uso, indicando diferentes formas de construção dos modelos, estabelecimento de seus dados probabilísticos, áreas de aplicação e inferências a respeito de confiabilidade, análises e demais métricas.

As cadeias de Markov são o formalismo de modelagem mais utilizado para modelos de uso devido aos benefícios que trazem ao teste estatístico de software.

As cadeias são intuitivas no sentido em que as pessoas reconhecem os caminhos do sistema no diagrama de maneira direta.

Apesar de tais benefícios, as cadeias de Markov apresentam algumas limitações que tornam-se críticas à medida que a cadeia cresce em tamanho.

Em primeiro lugar, a matriz estocástica usada pelo formalismo para armazenar as probabilidades de transição dos modelos, à medida que o modelo cresce em tamanho, apresenta o problema da "explosão" do espaço de estados.

Este problema, algumas vezes, torna a computação do modelo impossível.

O crescimento do número de estados e transições entre eles impacta a legibilidade do diagrama.

Algumas vezes torna-se impossível a visualização de um modelo devido ao seu tamanho.

Outro problema encontrado no uso de cadeias de Markov para modelagem diz respeito à manutenibilidade.

Ao adicionar estados ao modelo, é difícil encontrar todas as transições que devem ser criadas de forma a manter sua consistência, dependendo de seu tamanho.

A complexidade das aplicações WEB, por exemplo, tornam a modelagem de sistemas utilizando cadeias de Markov uma tarefa difícil.

Se temos uma aplicação sendo executada em um navegador (browser), todos os estados do modelo que não bloqueiam o navegador são candidatos a estado final.

Logo, no modelo de uso utilizando cadeia de Markov, estes candidatos devem possuir uma transição para o estado Terminate cada um.

A utilização de frames de menu na aplicação funciona da mesma maneira.

Este tipo de menu permite que todos os estados do modelo que não bloqueiam o navegador executem suas ações, resultando em múltiplas transições a serem incluídas para cada estado.

Esta multiplicidade de transições necessárias para a representação da complexidade do sistema tornam a visualização do modelo, muitas vezes, impraticável.

Uma rede de autômatos estocásticos (SAN) consiste em um conjunto de autômatos estocásticos individuais que operam de maneira quase independente.

Cada autômato é representado por um determinado número de estados, juntamente com regras ou funções de probabilidade que regem os movimentos de um estado para outro do autômato.

O estado local de um autômato em um determinado tempo t é o estado que este autômato ocupa no tempo t.

Já o estado global da rede de autômatos estocásticos é dado pelo estado local que cada um dos autômatos constituintes ocupa neste mesmo tempo t.

As taxas de transição de um estado para outro nas Redes de Autômatos Estocásticos são representadas nos próprios arcos do modelo, sendo exponencialmente (no caso de tempo contínuo) ou geometricamente (no caso de tempo discreto) distribuídas.

As redes de autômatos estocásticos podem possuir certo grau de interação entre seus autômatos, sendo estas interações representadas pelas taxas funcionais e pelos eventos sincronizantes (descritas em maior detalhe no decorrer do capítulo).

Estes podem apresentar os dois tipos de taxas de transição.

No caso de taxas funcionais, que representam uma taxa que varia de acordo com o estado global da rede, devem ser avaliadas (calculadas) a cada ocorrência, através da sua fórmula de definição.

Os eventos sincronizantes afetam a rede como um todo, fazendo com que uma transição em um autômato dispare simultaneamente uma transição em outros autômatos, sincronizando a interatividade entre eles.

O estado global de uma SAN pode ser mudado por eventos locais ou eventos sincronizantes.

Os eventos locais, como o próprio nome sugere, alteram o estado individual de determinado autômato da rede, alterando o seu estado local.

Logo, passa-se a um novo estado global cuja diferença em relação ao anterior se dá em apenas um autômato.

Já os eventos sincronizantes podem alterar simultaneamente mais de um estado local, ou seja, promovendo alteração de estado em mais de um autômato ao mesmo tempo.

Ilustra estes dois tipos de eventos.

Nela podemos ver os eventos locais l1, l2 e l3 (autômato A), e o evento local l4 (autômato B), representando as transições que ocorrem unicamente no seu próprio autômato, representando uma alteração no estado local do autômato.

Já o evento sincronizante S representa transições disparadas simultaneamente nos autômatos A e B, significando uma alteração no estado global da SAN através da alteração dos estados locais de ambos os autômatos.

No autômato A, cabe ressaltar que apenas uma das transições do evento S é disparada por vez, conforme a probabilidade de ocorrência, cuja conceituação é dada a seguir.

Assim, um evento sincronizante faz com que todos os autômatos afetados por ele disparem uma transição correspondente a este evento.

Uma informação importante acerca dos eventos sincronizantes é que, a condição principal para a ocorrência destes eventos é que eles possam ser disparados em todos os autômatos que os contêm.

No caso, por exemplo, de um autômato estar presente em 3 autômatos, caso em um deles a transição relativa ao evento seja impossível, não é possível a ocorrência do evento em toda a SAN.

Os eventos locais são representados por um identificador e a respectiva taxa do evento.

Já as transições representando eventos sincronizantes são identificadas por um nome ou identificador, uma taxa de disparo e a probabilidade de ocorrência do evento.

Nome do Evento, todas as transições relativas a um mesmo evento sincronizante são identificadas pelo mesmo nome.

Taxa de disparo, descreve a taxa em que o evento ocorre, sendo indicada em apenas um autômato.

Nos demais autômatos em cujas transições ocorre o evento, a taxa de disparo é omitida.

A taxa de disparo é mostrada como o segundo item na tripla do evento S.

Probabilidade de ocorrência, caso um evento sincronizante possua mais de uma transição partindo de um mesmo estado local, cada uma dessas transições recebe uma probabilidade de ocorrência, dado que não podem ocorrer simultaneamente.

A soma das probabilidades de ocorrência dos arcos de um mesmo evento sincronizante em cada autômato é sempre igual a 1.

No caso de um evento possuir apenas uma transição em determinado autômato, a probabilidade de ocorrência é igual a 1, e pode ser emitida.

A probabilidade de ocorrência é mostrada como terceiro item da tripla do evento S.

As taxas relativas aos tipos de evento acima citados podem ser de dois tipos, fixa ou funcional.

As taxas constantes, como o próprio nome sugere, são representadas por um número real nãonegativo, não apresentando variação.

Já as taxas funcionais representam, juntamente com os eventos sincronizantes, os dois modos de interação entre autômatos de uma SAN.

Estas taxas não são mais representadas por um número real não-negativo unicamente, mas por uma função discreta dos estados locais de alguns autômatos sobre estes números.

Logo, os estados locais da SAN é que indicam qual será a taxa utilizada no momento da transição.

Temos, no autômato B, o evento local l4 apresentando taxa funcional f.

Assim, o valor da taxa será definido pela avaliação da função f, ou seja, em função do estado local atual do autômato A.

As taxas funcionais não se apresentam apenas em eventos locais, podendo ser utilizadas até mesmo em eventos sincronizantes, inclusive para representar sua probabilidade de ocorrência.

A taxa é indicada através da avaliação da função no momento de seu disparo.

A vantagem do uso de taxas funcionais frente às taxas constantes é a possibilidade de representação compacta de estruturas complexas.

O recente desenvolvimento de algoritmos para produto tensorial generalizado acabou por minimizar os custos computacionais da avaliação de taxas funcionais, tornando o seu uso ainda mais atraente.

Um modelo SAN pode ser representado graficamente de maneira integral.

No entanto, esta representação gráfica detalhada, devido ao excesso de informações que comporta, pode acabar por prejudicar o entendimento do modelo.

Em alguns modelos é possível a utilização de uma representação gráfica simplificada, descrevendo unicamente a estrutura de cada autômato componente da SAN e suas interdependências (eventos sincronizantes e taxas funcionais).

Esta representação simplificada indica os eventos nos arcos do modelo da seguinte forma.

Apenas eventos locais com taxa constantenenhuma indicação.

Apenas eventos locais com taxa funcional, indica o nome da função em itálico.

Apenas eventos sincronizantes com taxa constante, indica o nome dos eventos.

Eventos sincronizantes e locais com taxa constante, indica o nome dos eventos sincronizantes e o símbolo asterisco para indicar presença de evento local.

Eventos sincronizantes e locais com taxa funcional, indica o nome dos eventos sincronizantes com o nome da função entre parênteses, e indica o nome da função dos eventos locais.

Apenas eventos sincronizantes com taxa funcional, indica o nome dos eventos sincronizantes com o nome da função entre parênteses.

Eventos sincronizantes com taxa funcional e eventos locais com taxa constante, indica o nome do evento sincronizante com o nome da função entre parênteses, e o símbolo asterisco para indicar a presença de evento local.

Utiliza a representação simplificada para descrever o modelo SAN.

Temos um modelo de uso simples, utilizando SAN, para a mesma aplicação de operações bancárias.

Nela podemos ver de maneira modular as operações de tentativa de senha (autômato Senha), a navegação entre as janelas da aplicação (autômato Navegação) e o mecanismo de controle de execução (autômato Aplicação).

Este modelo SAN é equivalente a cadeia de Markov, pois cada estado global da SAN equivale a um estado da cadeia de Markov.

Para ilustrar, temos o estado Start da cadeia representado pelo autômato Navegação no estado Start, o autômato Aplicação no estado Start e o autômato Senha no estado Waiting.

Já o estado Passwd da cadeia, equivale aos estados Passwd, Run e Waiting, na mesma ordem de autômatos citada anteriormente.

O estado PNotOK da cadeia é representado pelo estado global Passwd, Run e PNotOK, e o estado Menu equivale ao estado global Menu, Run e POK.

Da mesma forma, cada transição do modelo em cadeia de Markov equivale a um evento no modelo SAN.

Assim, temos a transição do estado Start para o estado Passwd representada pelo evento sincronizante ST.

A transição do estado Passwd para o estado PNotOK equivale ao evento local com taxa funcional f (evento local do estado Waiting para o estado PNotOK, do autômato Senha).

Já a transição do estado PNotOK para o estado Passwd refere-se a outro evento local com taxa funcional f (evento local do estado PNotOK para o estado Waiting, do autômato Senha).

A transição entre os estados Passwd e Menu na cadeia de Markov, é equivalente ao evento sincronizante S.

Por fim, todas as transições da cadeia de Markov que levam ao estado Start são representadas pelo evento sincronizante QT, que leva todos os autômatos do modelo SAN de volta ao seu estado inicial, que é justamente o estado global equivalente ao estado Start da cadeia de Markov.

Assim, todos os demais estados globais da SAN são inatingíveis, não encontrando correspondência em nenhum estado da cadeia de Markov equivalente.

Redes de autômatos estocásticos disponibilizam uma importante metodologia de modelagem de sistemas que permite a combinação de propriedades encontradas em várias técnicas de modelagem, como redes de Petri, redes de fila de espera, entre outras.

A principal vantagem da utilização de SAN está relacionada ao fato de que este formalismo gera automaticamente a sua matriz de transição de maneira implícita através do uso da álgebra tensorial.

A geração não-explícita da matriz de transição constitui um ganho com relação a utilização de memória.

Como visto, o aumento da complexidade dos sistemas tem tornado o espaço de estados dos modelos (em especial empregando-se cadeias de Markov) tão grande, que a sua análise acaba por ser inviável.

O fato de sistemas paralelos e distribuídos serem geralmente vistos como coleções de componentes que operam com certa independência acaba aproximando o problema do formalismo das SAN.

O problema da explosão do espaço de estados é minimizado em modelos utilizando Redes de Autômatos Estocásticos, pois ao invés da criação de uma única matriz de transição (usualmente grande), são criadas matrizes menores (para cada autômato), buscando as informações relevantes a partir destas matrizes.

O aspecto modular agregado aos modelos SAN, juntamente à maior eficiência computacional, proporcionada tanto pelo formato de armazenamento dos dados do modelo, matrizes de transição, quanto pelos recursos analíticos que disponibiliza, descrita através de algebra tensorial generalizada, funções de integração que agregam índices a respeito da rede, mostra as vantagens deste formalismo frente às cadeias de Markov.

Além disso, todo modelo SAN possui uma cadeia de Markov equivalente, mantendo igual poder de descrição e mesmo escopo de aplicação.

O formato compacto de seus diagramas sugere vantagens em termos de legibilidade do modelo, apesar dos arcos do modelo poderem apresentar certa complexidade com relação ao número de eventos que os compõem.

O formato compacto de sua representação interna (matrizes e operações tensoriais) permite vantagens computacionais no que diz respeito a armazenamento e solução numérica.

O formalismo SAN ainda conta com uma ferramenta de análise de modelos chamada PEPS2002, empregada neste trabalho.

Esta ferramenta usa como dados de entrada uma definição de modelo SAN descrito com uma sintaxe própria (ver apêndices), permitindo compilação, resolução do modelo através de métodos computacionais iterativos, e a partir daí uma série de análises, como espaço de atingibilidade de estados entre outros.

A ferramenta ainda permite a geração da matriz estocástica da cadeia de Markov equivalente ao modelo SAN no formato HBF.

O referencial teórico, apresentado no capítulo anterior, abordou os conceitos básicos do teste estatístico de software utilizando modelos de uso, mostrando suas principais características e peculiaridades.

Também foram caracterizados os dois formalismos estatísticos de modelagem de sistemas abordados neste trabalho, cadeias de Markov e Redes de Autômatos Estocásticos.

As características principais, vantagens e desvantagens de utilização foram apresentadas, além de mostrar os trabalhos realizados na área de teste estatístico com o seu emprego.

As cadeias de Markov apresentam uma série de limitações tanto em termos de modelagem quanto em termos computacionais.

A modelagem de sistemas através do uso de Redes de Autômatos Estocásticos, área carente de aplicações e cujo estudo é recente, apresenta uma série de características que acabam por suprir certas limitações do modelo de cadeias de Markov.

Agrega-se a isso o fato de a modelagem em SAN apresentar total compatibilidade para com as cadeias de Markov.

Tais indícios, motivaram uma investigação mais abrangente.

Um resumo extendido do trabalho desenvolvido foi publicado, no VII Workshop de Teses em Engenharia de Software (WTES), realizado em outubro de 2002 em Gramado, Brasil.

As redes de autômatos estocásticos tem mostrado inúmeras vantagens em relação às cadeias de Markov em termos de modelagem de sistemas complexos.

Acreditamos que este também é o caso em se tratando do teste estatístico utilizando modelos de uso.

De fato, a utilização de SAN ao invés de seguir utilizando cadeias de Markov não representa perda alguma de generalidade, devido ao fato de ambos os formalismos representarem a mesma classe de sistemas.

O conhecimento do formalismo SAN nos permite acreditar que modelos de uso descritos com SAN apresenta algumas características interessantes, Requisitos de ambiente (uma questão crítica para o teste) podem ser explicitados no modelo através da incorporação de autômatos para cada requisito.

A representação é modular, melhorando a manutenibilidade e legibilidade do modelo.

Um uso individual é uma seqüência de estados globais na SAN, logo, sua descrição é mais detalhada, o que pemite um mapeamento facilitado dos padrões de uso em casos de teste.

Em sistemas WEB, todos os estados do sistema que não bloqueiem o browser podem ser ligados ao estado final do modelo.

No caso do uso de SAN para a modelagem destes sistemas, um único evento sincronizante representaria esta característica.

A partir da análise destas características de SAN e das limitações apresentadas pelas cadeias de Markov, juntamente do estudo dos trabalhos relacionadas na área de teste estatístico com modelos de uso, firma-se como questão de pesquisa deste trabalho o uso de Redes de Autômatos Estocástico como formalismo de modelagem de uso a ser usado no processo de Teste Estatístico de Software.

O objetivo geral deste trabalho é mostrar a viabilidade do uso de SAN para representação de modelos de uso, sem perda de generalidade frente às cadeias de Markov, mostrando os benefícios agregados ao processo do teste estatístico.

Deseja-se mostrar também as características de SAN que trazem vantagens à modelagem de uso, tanto em termos de criação do modelo como também sua exploração pelo processo de teste.

A seguir é caracterizada a metodologia definida visando atingir os objetivos propostos.

Embasados nas características citadas anteriormente e nos conceitos teóricos apresentados no capítulo anterior, foram desenvolvidos dois estudos de caso no intuito de investigar as vantagens e desvantagens do uso do formalismo SAN na criação de modelos de uso para teste estatístico de software, frente ao formalismo de cadeias de Markov, o qual apresenta-se atualmente como padrão para a área.

Os estudos de caso desenvolvidos buscaram seguir o processo de teste estatístico apresentado anteriormente, envolvendo as etapas de análise da especificação, desenvolvimento da estrutura do modelo, atribuição de probabilidades e verificação e análise do modelo em uma primeira fase.

Esta fase, após concluída, gera como produto os modelos de uso de cada aplicação-alvo utilizando SAN e cadeias de Markov.

A partir destes modelos inicia-se a segunda fase do estudo de caso, envolvendo as etapas de execução de testes não-aleatórios e de testes pseudo-aleatórios (random testing) do processo.

Cabe ressaltar que as estapas de estimativa de confiabilidade, critérios de parada e análise final dos resultados de teste não fazem parte do foco deste trabalho, ainda que considerações detalhadas sejam apresentadas ao final do capítulo.

Assim, foram selecionadas duas aplicações com o intuito de observar aspectos relativos ao processo de modelagem empregando os formalismos estudados (cadeias de Markov e SAN), bem como os modelos produzidos.

O primeiro estudo de caso utilizou uma ferramenta de edição de documentos genéricos baseada em formulários hierárquicos chamada DocsEditor como aplicaçãoalvo.

Já o segundo estudo de caso utiliza uma ferramenta de acompanhamento de estado de defeitos (bug tracking system ou apenas BTS).

A aplicação selecionada para este primeiro estudo de caso, o DocsEditor, é um editor de documentos baseado em formulários genéricos desenvolvido dentro do projeto CPTS, no qual esta dissertação se insere.

Sua utilização atual está relacionada à criação e manutenção de informações relativas a teste de software, como planos de teste, relatórios de defeito, etc.

Foi acordado que a referida aplicação apresentava um nível de complexidade compatível com o trabalho proposto, definindo assim a sua utilização no estudo de caso.

O fato do desenvolvimento da aplicação ser realizado dentro de nosso projeto acabou por facilitar as tarefas de preparação da ferramenta para o processo de modelagem.

Este primeiro estudo de caso realizado a partir da ferramenta DocsEditor, descrevendo a proposta de aplicação de SAN na representação de modelos de uso para o Teste Estatístico e apresentando resultados preliminares foi publicado, tendo sido apresentado na 14th International Conference on Software Engineering and Knowledge Engineering (SEKE), realizado em julho de 2002.

O trabalho individual que contemplou partes deste estudo de caso foi publicado.

O Editor de Documentos Baseado em Formulários Genéricos, chamado DocsEditor, é uma ferramenta que permite a edição de documentos baseados em formulários, estruturados e orientados a objetos.

No DocsEditor, um documento é composto por um conjunto de formulários, os quais permitem ao usuário manter a informação e o texto em um estilo e formato pré-definidos.

Ilustra a interface da aplicação.

Nela podemos perceber um frame lateral correspondente à árvore de objetos da aplicação, além das barras de menus e ferramentas.

A interface ainda contém a área de formulário e um exemplo dos diálogos mostrados pela aplicação.

Um documento, para o Editor de Documentos, é uma instância de um tipo de documento.

Um tipo de documento descreve os tipos de formulários que um documento de determinada classe deve conter, e as relações hierárquicas entre estes formulários (estrutura de árvore).

A estrutura de um documento é sempre hierárquica, permitindo subseções aninhadas dentro de seções em tantos níveis quantos forem necessários.

Uma instância de documento é composta por uma instância da estrutura de árvore (que inclui a lista de todos os formulários utilizados) e o conteúdo dos formulários.

Quando o documento é carregado, o editor é capaz de carregar todos os formulários utilizados de maneira a permitir a edição do documento.

O DocsEditor, como é chamada a aplicação, é uma aplicação cliente-servidor composta por dois módulos, o módulo servidor e o módulo editor.

O modulo servidor é responsável por salvar, restaurar e controlar a propriedade dos documentos editados pelas instâncias do módulo editor.

O módulo editor permite ao usuário escolher o tipo de documento desejado para trabalhar, editar um documento e enviar ou recuperar documentos a partir de uma instância ativa do módulo servidor.

Uma vez escolhida a aplicação-alvo do estudo de caso, partiu-se para a criação da estrutura do modelo de uso, como forma de apoiar a fase de instrumentação de código.

Esta etapa foi iniciada pela identificação dos estados da aplicação que passam a compor a estrutura do modelo.

A identificação destes estados, e suas respectivas transições associadas, acaba por determinar os trechos do código-fonte, implementado na linguagem Java, onde devem ser inseridos os comandos de geração de informação para o log.

Um ponto relevante desta fase é a questão da delimitação do modelo.

Os modelos de uso construídos neste estudo de caso não levam em consideração os itens da árvore de objetos, e por conseguinte, dos formulários instanciados.

Os elementos considerados para fins de modelagem neste estudo de caso dizem respeito às seguintes características do software, Janelas de diálogo a serem mostradas durante a execução do DocsEditor (8 diferentes tipos possíveis).

Janela de seleção da estrutura hierárquica dos formulários (árvore).

Estado do documento (nenhum documento ativo, documento ativo sem nome e documento ativo com nome).

Disponibilidade do módulo servidor.

Disponibilidade de navegador internet.

Uma vez estruturado o modelo de uso, partiu-se para a adequação da mesma, de forma a prover informações relativas ao seu uso.

O primeiro passo foi a instrumentação da ferramenta escolhida através da criação de um log das ações do usuário.

O arquivo de log foi gerado localmente na estação que rodava o módulo cliente da aplicação, sendo gerado um arquivo para cada usuário diferente que utilizava a aplicação.

Cada arquivo contém uma seqüência de ações do usuário, sendo que os identificadores invoke e terminate delimitam as sessões de usuário.

Cada linha do arquivo de log é do formato Estado Atual, Ação do Usuário, indicando o estado em que a aplicação se encontra e a ação que disparou a transição para o estado seguinte (que corresponde ao estado atual da linha seguinte do log).

Após devidamente instrumentada, a ferramenta foi colocada em ambiente de produção, para que a sua utilização por diversos usuários em ambiente real gerasse informações de uso mais completas e próximas da realidade possível.

A estrutura do modelo empregando Cadeia de Markov foi retirada da descrição da aplicação através de uma máquina de estados finita, cujas informações foram extraídas da especificação do sistema.

Esta máquina de estados descreve a evolução do sistema partindo da carga da aplicação, até a finalização da mesma.

São descritas todas as possibilidades de interação do usuário com a aplicação, mapeando todos os caminhos possíveis de serem percorridos no sistema.

A partir desta estrutura, e utilizando-se da informação de uso da aplicação contida nos arquivo de log de cada usuário, procedeu-se à apuração das taxas de transição da então constituída cadeia de Markov.

Através do caminhamento realizado na cadeia, direcionado pelas informações do registro de eventos, foi contabilizado o número de vezes que cada caminho, transição entre estados, foi percorrido.

Tomando por base estes valores, e levando-se em conta o número de vezes que foi executada a aplicação na amostra do log, foram estabelecidas as taxas de transição, como número de transições por execução.

Para as transições cujo número de passagens foi nulo, foi atribuída uma taxa de transição baixa, indicando a possibilidade de ocorrerem, e levando-se em conta que o experimento utilizou apenas uma amostra do uso típico do software (para este exemplo foram realizadas 28 execuções).

Apresenta o modelo de uso utilizando cadeia de Markov, apresentando classes de estados distintas.

Em primeiro lugar podemos citar os estados que refletem o tipo de documento atual, apresentando nenhum documento (estado No Doc), um documento ainda não nomeado (estado Untitled Doc) ou ainda um documento já nomeado estado Titled Doc.

Além desta classe de estados, o modelo ainda apresenta estados "diálogo".

Estes estados representam as janelas de mensagem e seleção que são apresentadas ao usuário durante a execução da aplicação.

Cada diálogo (dialog 1, dialog 2, etc) representa um tipo de janela diferente, sendo que a letra no final do nome do estado (a, b, c, e assim por diante) representa diferentes situações em que esta janela é mostrada.

Completam o modelo os estados inicial e final, que representam a carga e finalização da aplicação respectivamente, além do estado de login, que refere-se à janela em que o usuário entra com o seu código de usuário e senha para que lhe seja liberado o uso, ou não, da ferramenta.

Algumas transições levam em consideração o tipo de nodo selecionado na árvore de objetos da aplicação (nodo raiz, nodo folha ou nodo intermediário), assim como a existência ou não de navegador internet (browser) ou servidor da aplicação ativo.

O modelo final é composto por 53 estados e 136 arcos representando as transições entre estes estados.

O processo usado na construção do modelo de uso utilizando o formalismo SAN difere do utilizado no modelo 1.

Ao invés de partir da análise da especificação e arquivos de log, o modelo SAN foi criado a partir da tradução do modelo 1 para o formalismo SAN.

Para tal, foram definidos autômatos para diferentes aspectos do software, através da observação de classes de estados distintas no modelo 1.

Assim, foram definidos 5 autômatos.

O autômato "Tipo de Documento", representando nenhum documento ativo (No Doc), documento ativo com nome (Titled) e documento ativo sem nome (Untitled).

O autômato "Diálogos", representando as 8 diferentes janelas de diálogo (de Dialog 1 a Dialog 8) e a ausência de janelas de diálogo (ND, de No Dialog).

O autômato "Árvore", representando o tipo de nodo selecionado na árvore de objetos da aplicação, nodo raiz (Root), nodo folha (Leaf) e nodos intermediários (Other).

O autômato "Servidor", representando a presença (Server) ou ausência (No Server) de módulo servidor da aplicação ativo.

O autômato "Navegador", representando a presença (Browser) ou ausência (No Browser) de navegador internet instalado.

Temos a representação gráfica dos 5 autômatos descritos no modelo de uso SAN do DocsEditor.

Os eventos que constituem as transições locais dos autômatos representados foram suprimidas por questões de espaço, sendo apenas representados os eventos sincronizantes.

Todas as transições locais dos autômatos (arcos) possuem eventos locais.

Os eventos sincronizantes S, T, U, V e W representam mudanças no estado do documento confirmadas por determinadas respostas dadas nas janelas de diálogo 1, 2, 3 e 4.

Já o evento sincronizante R representa o reinício da aplicação, implicando no retorno do primeiro autômato ao estado No Doc e a possíveis mudanças no estado local dos autômatos de ambiente, como é o caso dos autômatos "Servidor" e "Navegador".

Devido ao fato de várias transições locais possuírem taxas funcionais, a interatividade entre os autômatos não se limita aos eventos sincronizantes.

O modelo final possui 324 estados globais, combinação dos estados locais dos 5 autômatos constituintes do modelo (3 x 9 x 3 x 2 x 2), e devido ao fato de ser equivalente à cadeia de Markov do modelo 1, apenas 53 destes estados globais são atingíveis.

A aplicação selecionada para este segundo estudo de caso é um sistema de acompanhamento de defeitos (Bug Tracking System ou BTS).

Sua utilização atual está relacionada à manutenção de uma base de dados de defeitos encontrados em aplicações submetidas a fases de testes.

O relato deste segundo estudo de caso desenvolvido a partir da ferramenta BTS, além de conclusões e reavaliações feitas com relação ao estudo de caso anterior, foi submetido a XXV International Conference on Software Engineering (ICSE), a realizar-se em maio de 2003 em Portland, Estados Unidos.

A partir da escolha da aplicação-alvo deste segundo estudo de caso, procedeu-se a estruturação do modelo de uso.

Este processo deu-se de maneira análoga ao do estudo de caso anterior.

No entanto, realizou-se a modelagem de uso primeiramente através do uso do formalismo SAN.

Isso foi feito visando a obtenção de mais um parâmetro de comparação entre os processos de modelagem.

Ainda na etapa de estruturação do modelo, houve a delimitação do mesmo.

O modelo de uso construído neste estudo de caso, empregando o formalismo SAN, não diferencia os formulários utilizados pela aplicação, tratando-os de maneira genérica.

Os elementos considerados para fins de modelagem neste estudo de caso dizem respeito às seguintes características do software, diferentes status atribuídos aos defeitos e a sua inter-relação.

Estado do sistema, em termos de objetos selecionados (produto não selecionado, produto selecionado ou versão de produto selecionada).

Navegação do sistema, através de disversos tipos de páginas (diálogos, telas, formulários, listas).

Presença de registros de produtos, módulos de produto e versões de produtos.

O estado da aplicação (running ou starting), representando a carga (invocation ou encerramento (termination) da sessão de uso.

Após estruturado o modelo de uso, partiu-se para a instrumentação da mesma tendo em vista a obtenção das informações relativas ao seu uso.

Assim como no primeiro estudo de caso, criou-se um log das ações do usuário.

A diferença fundamental deste processo em relação ao anterior é que, devido à natureza da ferramenta, aplicação WEB desenvolvida em linguagem ASP e JavaScript com uso de banco de dados Access, o log foi criado em uma tabela do banco de dados da própria aplicação.

A estrutura do log também difere do estudo de caso anterior, contendo o identi ficador da sessão de usuário (número que diferencia os múltiplos usuários que podem utilizar a aplicação simultaneamente), o estado atual de cada um dos 8 autômatos definidos e a ação do usuário.

As sessões de uso são delimitadas pela ação inicial de um determinado identificador de sessão e pela ação Terminate inserida no log quando o usuário encerra a sessão, seja por tempo de espera excedido ou por ter fechado o browser.

Após devidamente instrumentada, a ferramenta foi publicada em um servidor IIS (Internet Information Services) de acesso restrito para ser utilizada por um conjunto de usuários em ambiente de produção com o uso de dados reais, procurando obter o máximo de realismo possível nos dados coletados.

A estrutura do modelo SAN da ferramenta BTS foi criada a partir da observação do comportamento do sistema e da definição de diferentes módulos (abstratos ou não), que apresentavam certo grau de interação entre si.

O modelo constituído possui 8 autômatos.

O autômato Bug Status, que representa as transições possíveis entre os diferentes estados que os defeitos podem apresentar durante o seu ciclo de vida.

Além dos diferentes estados de defeito utilizados, possui um estado adicional representando o fato de não haver estado (no status).

O autômato System Status, que apresenta o estado do sistema em termos do tipo de objeto selecionado (produto, versão de produto, módulo de sistema, revisão de módulo) ou nenhum objeto selecionado.

O autômato Browsing, que representa os tipos de página WEB em que o sistema se encontra e a sua interação (navegação de janelas), podendo ser a página inicial (main screen), formulário (form), lista de itens (list), janelas de diálogo (dialog) ou telas de sucesso (success screen).

Os autômatos Product, Product Version, Module e Module Revision, que representam a existência ou não de elementos deste tipo cadastrados.

O autômato Aplicação, que representa a inicialização e término da sessão de usuário.

O modelo possui 10 eventos sincronizantes, 3 eventos locais (apenas no autômato browsing) e 5 eventos locais com taxas funcionais, representando a interação entre os diferentes autômatos que compõem a SAN.

Os eventos ST e QT referem-se à inicialização (invocation) e finalização (termination) da sessão de usuário, que significa uma execução da aplicação BTS.

Os eventos C e A significam a representação de um estado de defeito quando entrando ou saindo do devido formulário (Bug form), respectivamente.

O evento X gerencia as transições entre os diferentes estados de defeito.

O evento B representa as ações de retorno back e cancelque desfazem a seleção representada no autômato System Status, alterando seu estado local.

Os eventos R, S, T e U representam a submissão com sucesso de um novo objeto (produto, versão de produto, módulo e revisão de módulo, respectivamente).

As funções f, g, h e i significam que apenas é possível selecionar um objeto quando existe uma instância cadastrada na base de dados (ele existe), e a função w significa que apenas é possível apagar registros das tabelas da base de dados quando a aplicação não está rodando (em execução).

Uma vez definidos os autômatos componentes da SAN e seus eventos sincronizantes, locais e taxas funcionais, o próximo passo é atribuir as taxas de transição à estrutura do modelo, utilizando a informação constante no log de eventos.

Para este experimento, foram considerados os dados de 3 semanas de uso da aplicação por 4 usuários, computando um total de 15 execuções da aplicação.

Para cada evento (local ou sincronizante) no modelo, a taxa de transição foi computada como o número médio de ocorrências desta transição por execução da aplicação (sessão de usuário).

As transições não disparadas na amostra tiveram sua taxa de transição ajustada para um valor mínimo, de forma a mostrar que tais transições, apesar de não estarem presentes na amostra, podem ocorrer.

O estado local dos autômatos deve mudar através do disparo de apenas um dos eventos que compõem o arco correspondente (local ou sincronizante).

Este modelo possui 9600 estados globais, obtidos através da combinação dos estados locais de todos os 8 autômatos que compõem a rede (12 x 5 x 5 x 2 x 2 x 2 x 2 x 2).

Após submeter o modelo para análise pela ferramenta PEPS2002 1para checar a consistência do modelo, foram obtidos 1517 estados globais atingíveis.

Após a criação do modelo de uso SAN para a aplicação BTS e a checagem de sua consistência, a aplicação PEPS2002 pôde gerar a cadeia de Markov equivalente automaticamente.

A matriz de transição gerada pelo PEPS2002 possui tamanho 1517 x 1517, e seus valores não negativos representam as 8990 transições entre os 1517 estados da cadeia.

Logo, devido à dificuldade de representar diagramaticamente esta cadeia de maneira clara, o modelo BTS utilizando cadeia de Markov não foi desenhado.

Uma vez criados os modelos de uso das aplicações abordadas nos estudos de caso descritos, passou-se à fase seguinte do processo do Teste Estatístico caracterizado no Capítulo 2.

Esta fase compreende a geração de conjuntos de casos de teste a partir dos modelos de uso criados, seguida de um processo de análise dos dados gerados conforme critérios de parada estabelecidos.

A seguir é realizada a descrição do processo de geração e análise dos casos de teste através da caracterização do gerador automático de casos de teste utilizado, estrutura dos casos de teste gerados, preparação e análise dos dados coletados.

O processo de geração de casos de teste baseado em modelos de uso é apoiado pela ferramenta Markov Bluej, desenvolvida pela equipe de pesquisa e desenvolvimento do projeto CPTS.

A ferramenta em questão gera conjuntos de casos de teste baseada nos modelos descritos na ferramenta de edição de diagramas de estado SCE (State Chart Editor, também desenvolvida pelo projeto CPTS), um editor de modelos utilizando os formalismos de cadeias de Markov, SAN, máquinas de estado finitas (FSM) e máquinas de estado finitas com variáveis (VFSM).

Já os casos de teste baseados nos modelos SAN são gerados por um protótipo desenvolvido por alunos de graduação da Faculdade de Informática da PUCRS em seu Trabalho de Conclusão de curso.

Na ferramenta Markov Bluej, seleciona-se o modelo de referência para geração de casos de teste, seguido do modo de geração de testes (no caso deste trabalho, random testing), do tamanho do conjunto de casos de teste e tamanho máximo desejado para o caso de teste, e da saída desejada para os dados a serem gerados (na tela, em arquivo, ou ambos).

Já no protótipo para geração de casos de teste para modelos SAN, o modelo de uso criado na ferramenta SCE funciona como entrada de dados para a aplicação, que posteriormente gera as seqüências de testes solicitadas.

Para ambas as ferramentas e formalismos foram gerados 17 conjuntos de casos de teste, com número de casos de teste variando entre 10 e 10000 casos.

No caso da geração de casos de teste para o modelo em cadeia de Markov do BTS, houve um processo de importação da matriz estocastica da cadeia de Markov equivalente ao modelo SAN, gerada pela ferramenta PEPS2002.

Além disso, procedeu-se manualmente a adição dos estados únicos inicial e final e respectivas transições complementares.

Uma vez importado e adaptado o modelo, foram gerados os casos de teste de maneira análoga aos do modelo DocsEditor.

Em termos de geração dos casos de teste para os modelos de uso em cadeia de Markov, a ferramenta de geração percorre o modelo realizando sorteios sucessivos, partindo do estado inicial da cadeia, como forma de decidir quais transições serão disparadas.

Este sorteio é realizado através da definição de slots de sorteio para cada uma das transições possíveis.

No caso de modelos com probabilidades de transição, já que os valores já se encontram no intervalo entre 0 a 1, a definição dos slots é direta.

No caso de modelos com taxas de transição, os valores são proporcionalizados, de forma a enquadrarem-se no intervalo entre 0 e 1.

Uma vez definidos os slots de sorteio, é gerado um número (através de uma função de geração de números randômicos) entre 0 e 1 composto de 6 casas decimais.

O slot correspondente a este número indica a transição a ser disparada.

O caso de teste é encerrado quando o estado final da cadeia é atingido ou o tamanho máximo da seqüência é alcançado.

A estrutura dos casos de teste criados é muito semelhante à estrutura do log empregado na coleta de taxas da ferramenta DocsEditor.

O caso de teste possui um cabeçalho indicando o número da seqüência (caso de teste), seguido por linhas indicando cada passo do caso de teste.

Cada linha possui o estado atual do sistema, seguido da transição disparada e do estado destino.

A geração de casos de teste para os modelos de uso em SAN funcionam de maneira diferente dos modelos em cadeia de Markov.

Segundo os modelos desenvolvidos e convencionados, todo caso de teste deve iniciar pelo evento ST, e terminado pelo evento QT.

A partir desta convenção, a aplicação de geração analisa o estado global atual da SAN, enumerando quais os eventos candidatos a serem disparados, conforme o estado local de cada autômato.

A partir desta lista de eventos candidatos, juntamente de suas taxas de disparo, são definidos slots de sorteio para cada evento, seguido da geração do sorteio e análise de qual o slot agraciado, indicando o evento a ser disparado e alterando o estado da SAN.

Os casos de teste são gerados na mesma base de dados da aplicação SCE, referenciando o autômato, estados de origem e destino, transição e evento que constituem cada passo dos casos de teste.

Os parâmetros de entrada do gerador são o modelo e a quantidade de casos de teste desejados.

Após gerados os casos de teste, estes foram importados para tabelas do Access e processados como forma de apurar as taxas de transição das amostras de casos de teste.

A partir desse processamento tornou-se possível apurar o número de transições do modelo cobertas por cada amostra de casos de teste, além de estabelecer uma comparação entre as taxas do modelo e as taxas apuradas em cada amostra, possibilitando um apoio à decisão do número de casos de teste a serem executados.

O Discriminante de Kullback constitui o valor esperado da razão de probabilidade logarítmica para dois processos estocásticos.

No caso da análise das amostras de casos de teste gerados frente ao modelo de uso de referência, este discriminante é calculado.

Sendo a taxa de ocupação de longo prazo do estado i, e ui e ti as taxas das transições do estado i para o estado j no modelo de uso e na amostra de casos de teste, respectivamente.

Para as transições não disparadas nas amostras de casos de teste, foi associada uma taxa mínima de transição (0,00001), como forma de evitar erros de computação decorrentes de divisor nulo.

Devido ao fato de os valores das transições serem expressos em termos de taxas (ocorrências da transição por execução da aplicação) e não em termos de probabilidades de transição2, o discriminante foi adaptado à realidade do trabalho retirando-se a taxa de ocupação de longo prazo dos estados, cujo intuito era de ponderar as probabilidades de transição de acordo com a taxa de ocupação de cada estado.

Isso foi feito pois as taxas de transição geradas nos modelos já são ponderadas.

A partir da obtenção do Discriminante de Kullback para cada amostra de casos de teste gerada, foi possível proceder a análise do gráfico de variação do discriminante em relação ao tamanho da amostra de casos de teste.

O Discriminante de Kullback não checa diretamente a convergência de uma amostra de casos de teste para um modelo de uso.

No entanto, o seu cálculo provê ao engenheiro de teste, aquele que é responsável pela gerência do processo de teste, subsídios de comparação que possibilitem decidir acerca da proximidade dos valores analisados.

O comportamento do discriminante através de uma série de amostras é utilizado como heurística na decisão de critério de parada do processo de teste.

Assume-se que uma determinada amostra de casos de teste converge ao modelo quando o valor do discriminante apresenta uma variação pequena em relação às amostras anteriores.

Mostram o comportamento do discriminante de Kullback para os modelos de uso em cadeia de Markov da aplicação DocsEditor, sendo que a segunda gerada pela aplicação PEPS2002 em equivalência ao modelo SAN.

Mostra o comportamento do modelo em cadeia de Markov gerado em equivalência ao modelo SAN da aplicação BTS, visto que para esta aplicação, devido ao excessivo número de estados e transições, não foi criado o modelo em cadeia de Markov manualmente.

Em termos dos modelos SAN, foi realizada a análise do discriminante de Kullback tendo em vista dois diferentes critérios.

No primeiro foi utilizado como critério a taxa de ocorrência dos eventos da SAN.

O critério seguinte, constituiu-se da taxa de ocorrência das transições do modelo.

Para o modelo em cadeia de Markov da aplicação BTS, bem como o modelo representando a cadeia de Markov equivalente da aplicação DocsEditor, devido ao fato destes terem sido gerado automaticamente pela ferramenta PEPS2002, a ponderação tornou-se necessária, passando-se a utilizar o discriminante original, que leva em conta o grau de utilização de cada estado da cadeia.

Assim, além da apuração de taxas relativas a cada transição do modelo, já realizada nos modelos em cadeia de Markov, os modelos SAN permitiram a aplicação de um enfoque de análise diferente, a apuração de taxas dos eventos do modelo, tanto locais quanto sincronizantes.

A diferença entre os dois enfoques se dá devido ao fato de analisarmos os eventos de maneira independente das transições onde estes eventos ocorrem, o que se enquadra melhor na natureza dos modelos SAN, que são orientadas a eventos.

Um evento local ocorre necessariamente em uma determinada transição entre estados locais do modelo.

Já um evento sincronizante pode ocorrer em diversas transições entre estados locais de autômatos distintos do modelo, sendo que ocorre em no mínimo duas transições de autômatos distintos.

Neste contexto, a migração do discriminante de Kullback para modelos SAN, em especial para análise de eventos, sugere a necessidade de adaptações em sua fórmula, conforme demonstrado nos gráficos apresentados.

A partir dos gráficos, é possível observar que a medida em que o grau de cobertura das transições aumenta, ocorre uma estabilização no valor do discriminante de Kullback.

No caso em que houve cobertura total das transições do modelo, os valores do discriminante estabilizaram mais próximos de zero que nos demais casos onde as transições do modelo não foram integralmente cobertas.

Isso se deve ao fato de a ausência de transições provocar uma diferença maior entre a taxa prevista no modelo e a taxa obtida na amostra (fixada em um valor mínimo de forma a impedir erros de divisão por zero), aumentando o valor do discriminante.

A observação da evolução do discriminante nos diferentes casos mostrou que, apesar das diferentes faixas de valores mostradas na estabilização do discriminante, a semelhança nos contornos do gráfico mostra a tendência forte à convergência dos dois modelos, que é a informação principal deste critério de parada.

No entanto, percebe-se que a estabilização do valor do discriminante, para modelos em cadeia de Makrov, se dá em patamares distintos, bastante superiores ao intervalo entre 0 e 1.

Já nos modelos SAN, apesar da geração de curvas supostamente similares, não foi possível chegar a nada conclusivo.

No entanto, tal comportamento revela dois importantes indícios.

O primeiro é de que o cálculo do discriminante de Kullback necessitaria de adaptações em sua fórmula para aplicação aos modelos SAN.

Na segunda hipótese levantada, o gerador de casos de teste para modelos SAN estaria apresentando erros de geração, invalidando os conjuntos de dados analisados.

O desenvolvimento do presente trabalho, que teve por objetivo verificar os benefícios da utilização de SAN na representação de modelos de uso para o Teste Estatístico, permitiu a observação e levantamento de indícios acerca tanto do processo quanto dos modelos em si.

As atividades desenvolvidas buscaram explorar as múltiplas dimensões dos modelos de uso SAN, mostrando a sua compatibilidade com o processo em que se insere, além de sua adequação a diversas classes de problemas com eficácia.

A seguir são apresentadas as conclusões e considerações feitas a partir das observações coletadas no desenvolvimento deste trabalho, distribuídas conforme o contexto em que se inserem.

Ao final são apresentados os trabalhos futuros que surgem a partir deste estudo.

Nos aspectos que tangem a modelagem de uso, o presente trabalho possibilitou a confirmação das vantagens do formalismo SAN, com relação às cadeias de Markov, no contexto específico do Teste Estatístico de Software.

A questão da descrição explícita de requisitos de ambiente e demais elementos condicionais no modelo possibilitada pelas SAN mostrou benefícios ao processo, tanto em termos de interpretação visual do modelo criado quanto na possibilidade de composições personalizadas do modelo (seleção ou omissão de autômatos visando um foco específico) visando a geração de testes direcionados.

A modularidade e número reduzido de estados, comparativamente aos modelos em cadeias de Markov, mostrou impactos diretos na legibilidade e manutenibilidade dos modelos SAN.

As mudanças e alterações, tanto em termos de adição ou subtração de estados e arcos quanto de autômatos, mostraram-se plenamente facilitadas pelo formalismo.

A detecção de incorreções no modelo, bem como a verificação da adequação das correções realizadas, tornou-se possível devido ao escopo reduzido de elementos no modelo, mesmo este sendo de complexidade relevante.

O poder de modelagem ou robustez do formalismo foi outra característica que tornou-se bastante evidente durante os estudos de caso.

No caso da ferramenta DocsEditor, foi possível a sua representação por meio das cadeias de Markov, apesar de o modelo SAN mostrar-se mais enxuto.

No entanto, para a ferramenta BTS, seria impraticável a sua modelagem diretamente em cadeias de Markov utilizando o mesmo grau de detalhe do modelo SAN composto.

Para exemplos utilizando-se aplicações de maior porte, estas características devem ser ainda mais evidentes.

É imperioso relatar que o processo de definição da estrutura do modelo SAN, tanto em termos de definição dos autômatos com seus estados e transições quanto a composição dos eventos que o compõem apresenta um grau relevante de complexidade com relação às cadeias de Markov.

No entanto, a experiência adquirida na construção de diferentes modelos SAN deu indícios de que tal complexidade deve-se a uma mudança de visão, por parte do modelador, incorporando a modularidade no seu modo de interpretar a realidade.

A medida em que a experiência de modelagem em SAN aumenta, o modelador acaba por definir um estilo próprio, criando modelos que seguem um mesmo padrão.

Um dos pontos em que os modelos SAN mostraram de forma mais latente seus benefícios foi na modelagem de aplicações WEB.

Este tipo de aplicação, que utiliza um navegador como ambiente de execução, apresenta uma grande multiplicidade de situações de encerramento de sessão de usuário, que em termos de modelagem de uso corresponderia a um elevado número de estados finais.

O impacto desta característica nos modelos em cadeia de Markov é imenso.

Já nos modelos SAN, foi possível minimizar o impacto através da criação de um autômato especial.

Este autômato, que tornou-se padrão em todos os modelos de uso desenvolvidos neste trabalho, possui dois estados, Start e Running.

Estes estados indicam se a aplicação está em execução ou não, e seus eventos sincronizantes ST e QT indicam a início e fim das sessões de usuário, respectivamente, fazendo o mesmo papel dos estados Invoke e Terminate nos modelos em cadeia de Markov.

Esta solução evita a criação de inúmeras transições, tornando mais fácil o acompanhamento da execução do modelo e mais eficiente o seu controle.

A ferramenta PEPS2002 mostrou-se de fundamental importância para a realização deste trabalho.

Ela própria constitui um benefício do formalismo, por disponibilizar uma série de funcionalidades que agregam valor ao processo de modelagem e tomada de decisão baseada nos modelos.

Neste trabalho foram explorados os processos de geração automática da cadeia de Markov equivalente ao modelo SAN (através da geração da sua representação sob a forma de matriz estocástica de transição), análise de atingibilidade para obter o número de estados atingíveis do modelo, além da obtenção do vetor de probabilidades, que indica o percentual de utilização de cada estado da SAN, utilizado no cálculo do discriminante de Kullback.

Outra observação relevante refere-se ao processo de estruturação do modelo de uso SAN.

Primariamente foi criada a estrutura do modelo de uso SAN da ferramenta BTS apenas definindose os estados e arcos ligando estes estados.

Assim, a definição dos eventos sincronizantes seria realizada após a análise dos dados constantes do log da aplicação.

O estudo de caso mostrou ser mais correto e eficiente a definição dos eventos na fase de estruturação do modelo, apurando-se as taxas dos eventos diretamente a partir do log.

Já em termos da geração de casos de teste a partir dos modelos, bem como a sua análise, os benefícios deste processo foram bastante evidentes.

Os algoritmos implementados pelos geradores automáticos de casos de teste mostraram-se bastante eficientes e flexíveis.

Foi possível observar características qualitativas e quantitativas acerca das amostras de casos de teste geradas (ou Test Suites) através da análise de cobertura e do cálculo do discriminante de Kullback.

Estas análises ferramentam o processo de tomada de decisão do Engenheiro de Teste, tornando-se parâmetros para a definição do conjunto de testes mais adequado aos seus objetivos.

Além disso, os casos de teste gerados podem ser convertidos em scripts que proporcionem a execução automática destes casos de teste, através de ferramentas específicas e execução de scripts.

O gerador de casos de teste para modelos SAN, apesar de não ter sido possível utilizá-lo na plenitude de suas funcionalidades, deu indícios de possíveis vantagens da geração de casos de teste para seus modelos, frente aos modelos em cadeia de Markov.

Ao analisarmos um evento, seja ele local ou sincronizante, em uma SAN, é possível notar que este impacta em múltiplas transições em seus estados globais atingíveis.

Este seria um indício de que o processo de geração de casos de teste para SAN atingiria uma maior cobertura de transições para um mesmo número de passos de caso de teste.

Este mesmo indício deixado pela relação dos eventos com as transições equivalentes permite vislumbrar uma rapidez maior na convergência dos casos de teste gerados para SAN com o modelo.

Isso se deve a relação encontrada entre esta convergência, ou seja, estabilização dos valores do discriminante de Kullback próximo a zero, e a cobertura das transições do modelo.

Os exemplos trabalhados mostraram uma tendência a convergência após a cobertura total das transições, sendo que os que não apresentavam cobertura total das transições estabilizavam os valores em patamares superiores ao valor 1.

Este discriminante, aplicado a SAN, também confirmou a possibilidade de adaptação deste tipo de critério de parada aos modelos SAN, aumentando a compatibilidade do formalismo ao foco proposto no trabalho.

Tendo como ponto de partida o trabalho desenvolvido, surgem diversos trabalhos futuros visando a complementação das observações realizadas e a expansão de seu enfoque.

Em primeiro lugar, espera-se concluir o processo de geração e análise dos casos de teste baseados nos modelos SAN, a partir da conclusão do gerador de casos de teste SAN.

A conclusão desta etapa possibilitará a investigação das evidências levantadas neste trabalho.

A questão da definição do tamanho dos casos de teste gerados, que não faz parte do foco deste trabalho, é um trabalho futuro que agregaria qualidade ao processo de geração de casos de teste.

Outro ponto a ser trabalhado é a geração de scripts a partir dos casos de teste gerados e sua execução (automática ou semi-automática).

Este processo consiste na escolha de uma ferramenta de execução de scripts, como por exemplo as ferramenta Robot e RobotJ da Rational Software, e a adaptação e implementação dos casos de teste na sintaxe desta ferramenta.

A sistematização do processo de Teste Estatístico adaptado neste trabalho, visando torná-lo aplicável constitui outro trabalho futuro.

Para tal, uma caracterização mais prática e fundamentada de suas etapas, elementos envolvidos, ferramentas, dentre outros, se faz necessária.

Outro campo de trabalho futuro que pode utilizar-se deste trabalho é a adaptação de métricas, critérios de parada, e demais análises associadas aos modelos de uso utilizando cadeias de Markov, aos modelos de uso empregando SAN.

Esta abordagem agregaria funcionalidades e recursos ao processo estudado neste trabalho, maximizando os benefícios do uso de modelos de uso SAN.

A área de confiabilidade e aplicabilidade de seus modelos é um campo de intersecção do teste estatístico e da qualidade de software que poderia ser explorado em trabalhos futuros, utilizando-se das informações armazenadas nos modelos de uso empregando SAN.

Neste contexto, a influência de erros de modelagem, perfil operacional incorreto e questões mais aprofundadas de validação do modelo poderiam ser exploradas.

A gramática para o PEPS2002 é um formato para representação do formalismo SAN, através de arquivo texto.

Esta é apenas apenas uma visão superficial da gramática para o PEPS2002, sem entrar no domínio de cada termo.

O formato de arquivo reconhecido por PEPS2002 pode ser dividido em alguns blocos, como é apresentado a seguir.

Este primeiro bloco contém as declarações e a inicialização dos identificadores (constantes ou funções) que serão utilizados pelo modelo SAN.

Caso não necessite definir num identifidor para uso no modelo, este bloco pode ser omitido.

Estes identificadores podem ser utilizados para representar as taxas de ocorrência e as probabilidades de rotação.

Neste bloco é modelada a função de atingibilidae que definirá qual é o espaço de estados ating íveis no modelo SAN.

A função de alcançabilidade é um função booleana que retorna true caso o estado possa ser atingido e false caso não possa.

A parte de definição do modelo propriamente dito, é feito no bloco de Descrição do Modelo.

Este bloco tem uma estrutura hierarquizada onde são descritos os autômatos pertencentes à rede.

Além disto é definido também o nome do modelo e a escala de tempo utilizada (tipo do modelo).

Os tipos de modelos aceitos pela gramática são discrete e continuous, porém a ferramenta PEPS2002 resolve apenas modelos à escala de tempo contínua.

Para cada autômato é especificado o nome do autômato e o número de replicas (caso não haja replica do autômato, não é necessário informar este parâmetro) dentro da rede.

São descritos também os estados em que o autômato pode estar.

A Descrição dos Estados descreve cada estado dentro do autômato.

Deve definir-se o nome do estado e, caso existe, a recompensa e o número de replicações do estado, dentro do autômato.

Descreve-se também as transições deste estado para outro.

A Descrição das Transições define a transição entre os estados do autômato.

Define-se para cada transição, o estado destino e os eventos associados a ela.

São descritos neste nível os eventos relacionados a cada transição.

Dois tipos de eventos (local e sincronizante) são aceitos em SAN, com visto no Capítulo Para eventos locais define-se o nome do evento local, a taxa de ocorrência e a probabilidade de rotação associada ao evento.

Para o caso de eventos sincronizantes, usa-se duas descrições.

Uma para o autômato mestre e outro para os autômatos escravos.

No caso do autômato mestre define-se o nome de evento sincronizante, a taxa de ocorrência e a probabilidade de rotação.

Para os autômatos escravos, omite-se a taxa de ocorrência.

Para todos os tipos de eventos pode-se omitir a probabilidade de rotação quando está for igual a 1.

É interessante ressaltar que nem todos os tipos de eventos precisam aparecer em todas as transições, mas cada transição de ter pelo menos um evento associado.

Neste bloco são definidas as funções para obtenção dos índices de desempenho interessantes ao modelo.

Estes índices são descritos através de um nome e de uma expressão matemática.

A gramática utilizada pelo PEPS2002 define vários operadores matemáticos, lógicos e relacionais.

O PEPS2002 não define ordem de precedencia entre os operadores e a avaliação das expressões é feita da esquerda para a direita, para definir precedencia nas operações usa-se parênteses.

Além dos operadores matemáticos, lógicos e relacionais já conhecidos, o PEPS2002 define primitivas para operação com autômatos.

A definição e semântica deste operadores é a seguinte.

St <id_aut>, retorna o estado corrente do autômato id_aut, onde id_aut é o identificador do autômato.

Nb <id_stt>, retorna o número total de autômatos do modelo SAN que se encontram no estado <id_stt>, onde <id_stt> é o identificador de um estado.

Nb <id_stt> (<id_aut>,<id_aut>), retorna o número de autômatos no estado <id_stt> no intervalo (<id_aut>,<id_aut>).

Rw <id_aut>, retorna a recompensa associada ao estado do autômato <id_aut>, caso não haja recompensa associada a funcão rw <id_aut> é idêntica a função st <id_aut>.

Sum_rw (<id_aut>, <id_aut>), retorna o somatório das recompensa associadas aos estados correntes dos autômatos do intervalo (<id_aut>, <id_aut>).

Sum_rw <id_stt> (<id_aut>, <id_aut>), retorna o somatório das recompensa associadas aos autômatos do intervalo (<id_aut>, <id_aut>) que se encontram no estado <id_stt>.

Prod_rw (<id_aut>, <id_aut>) ou prod_rw <id_stt> (<id_aut>, <id_aut>), funcionam de maneira semelhante ao sum_rw, porém retornam o produtório invés do sumátorio.

