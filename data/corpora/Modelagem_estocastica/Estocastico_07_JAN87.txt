No mundo globalizado, o uso de computadores se tornou popular, tomando grandes proporções, estando presente nas mais diversas áreas.

Essa popularização se deve a dois fatores, o baixo custo do hardware e o surgimento de linguagens e técnicas de programação, dentre elas a UML (Unified Language of Modeling) e a OOP (programing oriented a object), que facilitaram o desenvolvimento de sistemas mais robustos e complexos.

Essa complexidade exigiu dos desenvolvedores um maior rigor no processo de construção de sistemas.

Para auxiliar nesse processo surge a Engenharia de Software, como a área da computação que visa disciplinar o processo de desenvolvimento de sistemas através do uso de técnicas de padronização do referido processo.

A padronização do processo de desenvolvimento, proporcionada pela Engenharia de Software através de seus paradigmas, abrange todas as fases do desenvolvimento, dentre elas a de testes.

O teste do software é uma das fases do processo de desenvolvimento que demandam mais tempo e consomem mais recursos.

O processo de testes pode ser executado de duas formas.

Para a identificar se o sistema atende aos requisitos exigidos pelo usuário, a partir do código escrito em uma determinada linguagem.

Tal metodologia é denominada de teste estrutural ou de caixa branca.

Para a identificar se o sistema atende aos requisitos exigidos pelo usuário, a partir das funções que o sistema desempenha.

Tal metodologia é denominada de teste de funcional ou caixa preta.

O uso de formalismo, dentre eles as SAN (Stochastic Automata Networks), que pode ser usada para modelagem de softwares e a geração de testes estatisticamente relevantes que possibilitam avaliar o grau de cobertura de um conjunto de testes.

A aplicação de formalismos no processo de testes pode ser visto em vários trabalhos.

Apresentamos ainda a proposta de pesquisa para a elaboração da dissertação, que abrange o uso de SAN (Stochastic Automata Networks) para a geração de cenários de teste de software, a partir do uso do diagrama de estado da UML.

Finalmente, os objetivos e as atividades para o ano de 2008 e 2009 são apresentados juntamente com o cronograma das mesmas.

Ao longo deste plano de estudos será apresentada, como forma de contextualização, alguns conceitos básicos sobre temas relevantes ao desenvolvimento desta pesquisa.

Assim apresentaremos alguns conceitos sobre engenharia de software, abordaremos a UML e a metodologia da orientação a objetos, apresentará o diagrama de estados e seus componentes, discutimos as principais metodologias para teste de software.

Ainda dentro da abordagem de teste de software, descreve o TMM, que é o modelo de validação de testes baseado no CMM.

Apresentamos algumas das ferramentas automáticas utilizadas no processo de teste de software.

Aborda-se ainda o uso de modelos matemáticos para teste de software.

Com o aumento do custo de processamento e armazenamento de dados, tornou-se evidente a necessidade de desenvolvimento de hardwares e softwares que reduzissem o custo desse processo.

A Engenharia de Software surgiu como área durante a conferência da OTAN (Organização do Tratado do Atlântico Norte) em 1968 com a finalidade de solucionar a "crise do software", seu objetivo era disciplinar o processo de produção de software e tinha como principal desafio melhorar a qualidade dos softwares, sem aumentar seus custos, o que não era fácil, já que segundo Pressman o hardware sofria continuas mudanças.
A programação de computadores era vista como uma arte secundária e o desenvolvimento de softwares era feito virtualmente.

Segundo Pressman, a primeira definição para Engenharia de Software foi proposta por Fritz Bauer, o qual afirmava que a mesma era "O estabelecimento e uso de sólidos princípios de engenharia para que se possa obter economicamente um software que seja confiável e que funcione eficientemente em máquinas reais".

Pressman apud Bauer.

A engenharia pode ser definida ser definida como um conjunto de atividades associadas, que incluem a descrição e preparação de esquemas que identifiquem a estrutura dos dados e elmentos de controle de um sistema, através da codificação, verificação e implantação do software.

A engenharia de software é caracterizada pela aplicação dos principios científicos, métodos, modelos, padrões e teorias que possibilitam gerenciar, planejar, modelar, projetar, medir, analisar, manter e aprimorar um sistema de sofwrare visando a uma produção economica e de qualidade.

Atualmente a engenharia de software foca-se no desenvolvimento de componentes e frameworks.

Um componente é uma unidade de sofware testada para fins especiais, que seja útil, adaptável, portável e reutilizável, já um framework é um combinação de componentes que simplifica a construção de aplicações.

O uso dessas duas tecnicas na engenharia de softwre tem reduzido significativamente o tempo de desenvolvimento de sistemas, uma vez que é possivel aplicar a técnica de reuso seja de componentes ou de frameworks, testados anteriormente, na elaboração de novos sistemas.

Tais avançõs foram proporcionados principalmente pelo uso da programação e a análise orientada a objetos.

Segundo, os primeiros conceitos sobre orientação a objeto surgiram através de uma linguagem de programação simulada, anterior a dos métodos estruturados.

Esses conceitos surgiram na Noruega, e foram desenvolvidos por Olé Johan e Kirten Neygaard.

A linguaem simula 67 deu origem a primeira linguagem totamente orientada a objeto, chamada de Smalltalk, desenvolvida nos anos 70 por Alan Kay, porém só apresentada ao público em nos anos 80.

Essa linguagem aprimorou os conceitos anteriomente definidos de classe (atributos e métodos) encapsulamento e heranç.

Um objeto pode ser definido como "um pacote de software que contém uma coleção de procedimentos e dados relacionados", esses procedimentos são denominados métodos para distingui-los das "procedures"convencionais que não estão relacionadoas com o conceito de objetos.

Todo objeto, também chamado de classe, possui atributos que são definidos como sendo uma propriedade de uma classe que possui um nome e descreve um intervalo de valores que as instancias daquela classe podem conter.

Uma classe pode conter qualquer número de atributos, inclusive a possibilidade de nenhum.

Um objeto combina procedimentos e dados em um só elemento permitindo que os objetos possam ser manipulados independentemente.

Essa manipulação envolve métodos e variáveis de modo que tudo que o objeto "conhece"é o que está armazenado em suas variáveis e tudo que ele pode fazer está armazenado em seus métodos.

Entre os anos de 1989 e 1994 mais de 50 métodos de orientação a objeto foram desenvolvidos destacando-se o OOSE (Engineer Software Oriented Object) criado por Ivar Jacobson, que baseava-se no suporte a captura de requisitos através de UseCases, o Grady Booch, que permitia a especificação de classes, objetos e interações e o OMTTechnic Modelling Object OMT (Technic Modelling Object) Jim Rumbaugh, focado na análise.

Em 1994, Rumbaugh se uniu a Booch na Rational e no ano seguinte Jacobson se uniu ao grupo, o que possibilitou em 1996, a criação a primeira versão da UML (Unified language of Modeling), que era a fusão das três principais metodologias existentes para a especificação de projetos.

Diversas empresas se juntaram e deram origem a um consórcio formado por DEC, HP, i-Logix, IntelliCorp, IBM, ICON Computing, MCI, Systemhouse, Microsoft, Oracle, Rational Software, TI, and Unisys, possibiltando o lançãmento de mais versões da UML, que atualmente está na versão 2,0 e tem por objetivo descrever modelos de sistema, do mundo real e de software, baseado em conceitos de objetos.

Fornecer uma linguagem de modelagem Orientada a Objeto visual fácil, pronta para uso, permitindo amplas facilidades de modelagem.

Fornecer mecanismos de extensibilidade e especialização de conceitos de base.

Independência de processos e linguagens de programação, abranger todo o ciclo de vida.

Diferentes tecnologias de implementação, integrar melhores práticas em desenvolvimento orientado a Objeto de sistemas A UML (Unified Language of Modeling) é uma linguagem de diagramação ou notação para especificar, visualizar e documentar modelos de sistemas de software orientados a objeto.

A UML não é um método de desenvolvimento, o que significa que ela não determina o que o desenvolvedor deve fazer primeiro e em seguida ou como desenhar seu sistema, mas ela auxilia a visualizar o desenho e a comunicação entre objetos.

A UML é controlada pelo OMG (Group Manager Object) e é um padrão da indústria para descrever graficamente softwares.

A UML é voltada para o desenho de software orientado a objeto e tem um uso limitado para outros paradigmas de programação, sendo composta por muitos elementos de modelo que representam as diferentes partes de um sistema de software.

Os elementos UML são usados para criar diagramas, que representam uma determinada parte, ou um ponto de vista do sistema.

Um diagrama é uma apresentação gráfica de uma coleção de elementos do modelo, conectado de arcos (relacionamentos) e vértices (outros elementos do modelo), podendo ser estruturais ou comportamentais.

A UML apresenta os seguintes tipos de diagramas.

Diagrama de Caso de Uso mostra atores (pessoas ou outros usuários do sistema), casos de uso (os cenários onde eles usam o sistema), e seus relacionamentos.

Diagrama de Classe mostra classes e os relacionamentos entre elas.

Diagrama de Seqüência mostra objetos e uma seqüência das chamadas do método feitas para outros objetos.

Diagrama de Colaboração mostra objetos e seus relacionamentos, colocando ênfase nos objetos que participam na troca de mensagens Diagrama de Estado, mostra estados, mudanças de estado e eventos num objeto ou uma parte do sistema.

Diagrama de Atividade mostra atividades e as mudanças de uma atividade para outra com os eventos ocorridos em alguma parte do sistema.

Diagrama de Componente mostra os componentes de programação de alto nível (como KParts ou Java Beans).

Diagrama de Distribuição mostra as instâncias dos componentes e seus relacionamentos.

Comportamento de uma classe de objetos é representado através de um Diagrama de Transição de Estado, que descreve o ciclo de vida de uma dada classe, os eventos que causam a transição de um estado para outro e as ações resultantes da mudança de estado.

O espaço amostral dos estados de uma dada classe corresponde a enumeração de todos os estados possíveis de um objeto.

O estado de um objeto é uma das possíveis condições na qual o objeto pode existir.

O estado compreende todas as propriedades dos objetos (estáticas) associadas aos valores correntes (dinâmico) de cada uma dessas propriedades.

A notação UML para representar o estado de uma classe, corresponde a um retângulo com as bordas abauladas.

Um estado, em sua notação, pode conter três compartimentos.

O primeiro mostra o nome do estado.

O segundo é opcional e mostra a variável do estado, onde os atributos do objeto em questão podem ser listados e atualizados.

Os atributos são aqueles mostrados na representação da classe, e em algumas vezes, podem ser mostradas também as variáveis temporárias, que são muito úteis em diagramas de estado, já que através da observância de seus valores podemos perceber a sua influência na mudançã de estados de um objeto.

O terceiro compartimento é opcional e é chamado de compartimento de atividade, onde eventos e ações podem ser listados.

Três eventos padrões podem ser mostrados no compartimento de atividades de um estado, entrar, sair e fazer.

O evento entrar pode ser usado para definir atividades no momento em que o objeto entra naquele estado.

O evento sair, define atividades que o objeto executa antes de passar para o próximo estado e o evento fazer define as atividades do objeto enquanto se encontra naquele estado.

Todos os objetos possuem um estado que significa o resultado de atividades executadas pelo objeto, e é normalmente determinada pelos valores de seus atributos e ligações com outros objetos.

Um objeto muda de estado quando acontece algo, o fato de acontecer alguma coisa com o objeto é chamado de evento.

Através da análise da mudança de estados dos tipos de objetos de um sistema, podemos prever todos os possíveis comportamentos de um objeto de acordo com os eventos que o mesmo possa sofrer.

Estados também podem ser distinguidos pela existência de certas ligações.

Estado Inicial é o estado atribuído a um objeto quando é criado.

O estado Inicial tem as seguintes características, é mandatório, ssomente um estado inicial é permitido.

O estado Inicial é representado por um círculo preenchido.

O estado incial é descrito.

Estado Final é o estado que indica o fim do ciclo de vida de um objeto.

O estado Final tem as seguintes características, é opcional, pode existir mais de um estado final.

O estado Final é representado por um circulo semi-preenchido.

O estado incial é descrito.

O diagrama de estado é tipicamente um complemento para a descrição das classes.

Este diagrama mostra todos os estados possíveis que objetos de uma certa classe podem se encontrar e mostra também quais são os eventos do sistemas que provocam tais mudanças.

Os diagramas de estado não são escritos para todas as classes de um sistema, mas apenas para aquelas que possuem um número definido de estados conhecidos e onde o comportamento das classes é afetado e modificado pelos diferentes estados.

Diagramas de estado capturam o ciclo de vida dos objetos, subsistemas e sistemas, eles mostram os estados que um objeto pode possuir e como os eventos (mensagens recebidas, timer, erros, e condições são satisfeitas) afetam estes estados ao passar do tempo.

Diagramas de estado possuem um ponto de início e vários pontos de finalização.

Um ponto de início (estado inicial) é mostrado como um círculo todo preenchido, e um ponto de finalização (estado final) é mostrado como um círculo em volta de um outro círculo menor preenchido.

Um estado é mostrado como um retângulo com cantos arredondados.

Entre os estados estão as transições, mostradas como uma linha com uma seta no final de um dos estados.

A transição pode ser nomeada com o seu evento causador.

Quando o evento acontece, a transição de um estado para outro é executada ou disparada.

Uma transição de estado normalmente possui um evento ligado a ela.

Se um evento é anexado a uma transição, esta será executada quando o evento ocorrer.

Se uma transição não possuir um evento ligado a ela, a mesma ocorrerá quando a ação interna do código do estado for executada (se existir ações internas como entrar, sair, fazer ou outras ações definidas pelo desenvolvedor).

Então quando todas as ações forem executadas pelo estado, a transição será disparada e serão iniciadas as atividades do próximo estado no diagrama de estados.

Os diagramas de estados são compostos por eventos, um evento é uma ocorrência de algum fenômeno, que é reconhecido pelo objeto, em algum ponto no tempo e que pode modificar o estado de um objeto, podendo gerar uma resposta.

Os eventos podem ser eventos externos, que são aqueles trocados entre o sistema e seus atores.

Eventos internos são aqueles trocados entre os objetos do sistema.

Transição é a mudança do estado atual para o estado subseqüente como resultado de algum estímulo.

O estado subseqüente pode ser igual ao estado original e uma transição pode ocorrer em resposta a um evento.

As transições são rotuladas com o nome dos eventos.

Ação, execução de um processamento atômico que resulta em uma mudança de estado ou o retorno de um valor.

Uma ação é atômica por não poder ser interrompida por um evento, devendo ser executado até a sua conclusão.

Atividade, execução de um processamento não atômico que consome tempo para ser completado, podendo ser interrompido pela ocorrência de um evento.

Uma atividade pode envolver a execução de um conjunto de ações.

Uma atividade (ou ação) é representada por uma operação na classe correspondente.

Transição Automática, algumas vezes, o único propósito da existência de um estado é desenvolver uma atividade.

Uma transição automática ocorre quando a atividade é completada.

Se múltiplas transições automáticas existem, uma condição de guarda é necessária para cada transição e as condições de guarda devem ser mutuamente exclusivas.

Condição de Guarda, a condição de guarda é uma expressão boleana de valores de atributo que permitem que a transição ocorra somente se a condição assumida pela expressão é verdadeira.

O teste de software é definido como o processo de avaliar um sistema de software ou componente durante, ou ao término do seu ciclo de desenvolvimento para determinar se satisfaz as exigências especificadas pelo usuário.

O Teste geralmente é descrito como um grupo de procedimentos executados para avaliar algum aspecto de um software ou de parte dele.

Os testes podem ser descritos como um processo usado para identificar defeitos em software, e por garantir que o software atingiu um grau especificado de qualidade respeitando os atributos estabelecidos.

O processo de desenvolvimento de software requer um alto padrão de qualidade, o que depende dos "stakeholders"envolvidos no processo.

A baixa qualidade dos softwares são a principal causa da curta vida do mesmo e da baixa aceitação por parte dos usuários.

A qualidade do software perpassa pelo bom entendimento dos requisitos do usuário e o processo de desenvolvimento deve obedecer a disciplina da engenharia, além do planejamento detalhado das atividades a serem desenvolvidas.

Uma das formas de diminuir os problemas relativos ao processo de desenvolvimento é a execução de testes.

Em qualquer ambiente de programação, a atividade de teste é de extrema importância para gerar produtos de qualidade e de alta confiabilidade.

Testar um software envolve executar o programa com um conjunto de dados e comparar os resultados obtidos com os esperados.

O objetivo do teste de software é executar o programa com a intenção de encontrar erros.

Qualquer produto trabalhado por engenharia pode ser testado de duas maneiras, conhecendo-se a função específica que um produto projetado deve executar.

Os testes podem ser realizados para demonstrar que cada função é totalmente operacional.

Essa metodologia de testes é denominada de black box.

Conhecendo-se o funcionamento interno de um produto.

Os testes podem ser realizados para garantir que todas as rotinas do sistema são executadas, ou seja, que a operação interna do produto tem um desempenho de acordo com as especificações e que os componentes internos foram adequadamente postos à prova.

Essa metodologia de testes é denominada de White box.

Um importante modelo de gerência de teste de software tem sido bastante discutido, esse modelo é denominado TMM (Test Maturity Model), que é parte do CMM (Capability Maturity Model) para software, e trata-se de um modelo desenvovido para software e difundido pela industria nos Estados Unidos.

O CMM tem cinco níveis ou fases que descrevem uma forma de maturidade de processo de desenvolvimento de software e serve como um guia para melhoria do mesmo.

Cada nível tem um KPA (Key Process Areas) que define as necessidades da organização focalizar e alcançar maturidade naquele nível.

Também há práticas fundamentais associadas a cada nível que provêm apoio para implementar melhorias em cada nível.

O CMM também possui um procedimento de avaliação que permite a uma organização avaliar o estado atual de seu software, identificando os pontos fortes e fracos.

Baseado nessa metodologia surgiu o TMM (Testing Maturuty Model) que permite o gerenciamento do processo de teste de software.

Assim como no CMM o TMM possui niveis, no total 5, também chamados de estágio que permitem o gerenciamento, a definição e a melhoria dos processos de teste.

Cada nível com exeção do nível 1 apresenta a seguinte estrutura.

Maturidade das metas e objetivos.

A maturidade das metas são definidas para que se possa melhorar cada vez mais o processo, evoluindo-se ao proximo nível desde que os objetivos sejam satisfeitos.

Suporte a Maturidade de Subojetivos, eles definem o escopo, os limites e necessidades elaboradas para um nivel em particular.

Atividades, Tarefas e Responsabilidade (ATR), as ATR destinam-se a implementação e adaptação organizacional emitidos em cada nível do TMM.

Atividades de apoio e tarefas são identificadas e responsabilidades são confiadas a grupos apropiados.

Os niveis do TMM são, Objetivos sem Maturidade.

Fase de Definição.

Integração.

Medidas de gerenciamento.

Prevenção de defeitos e controle de qualidade.

Os objetivos do TMM podem ser definidos por níveis, com exeção do nível 1.

Nível 2, institucionalização básica de técnicas de teste e métodos.

Inicialização de um processo de plano de teste.

Desenvolvimento de testes e objetivos de eliminação de erros.

Nível 3, controle e monitoramento de processo de teste.

Teste de integridade em ciclo de vida de software.

Estabelecer um programa de treinamento técnico.

Estabelecer uma organização para o teste de software.

Nível 4, avaliação da qualidade de software.

Estalecimento de medidas para o teste de software.

Estabelecimento e organização de um programa de revisão.

Nível 5, melhoria do processo de teste, controle de qualidade, aplicação de dados de processo para prevenção de defeito.

Para automatizar os testes pode reduzir o esforço requerido para certos tipos de testes, ou aumentar o número de testes que podem ser feitos em tempo limitado.

Os testes automatizados são passíveis de repetição, usando exatamente as mesmas entradas, com o mesmo tempo de repetição, algo que não pode ser garantido com o teste manual, alem de eliminar grande parte do trabalho braçal.

Para reduzir o tempo de teste, sem reduzir a eficácia, é claro, pesquisadores e profissionais desenvolveram uma primeira geração de ferramentas automatizadas de teste, dentre elas destacam-se as ferramentas de Gerência de Teste, que incluem ferramentas para ajudar no planejamento do teste, mantendo-se a par de quais testes foram executados.

Esta categoria inclui também ferramentas para ajudar a mapear os testes em relação aos requisitos, modelos, e código, assim como ferramentas de rastreamento de defeitos.

Ferramentas de Análise Estática, analisam o código sem executá-lo.

Este tipo de ferramenta detecta determinados tipos de defeito de maneira muito mais eficaz e barata do que quando se utiliza outros meios.

Ferramentas de Análise Dinâmica analisam a resposta do sistema quando o mesmo é exercitado por alguma ferramenta de execução.

Esse tipo de ferramenta se subdivide em dois grandes grupos.

Ferramentas de Testes Estruturais são ferramentas utilizadas em teste que precisam instrumentar de alguma maneira o código.

Ferramentas de Cobertura são ferramentas que avaliam quanto do software sob teste foi exercitado por um conjunto de testes.

As ferramentas de cobertura são mais usadas geralmente no nível de teste de unidade.

Ferramentas de Testes Funcionais são ferramentas que exercitam as funcionalidades do sistema.

Ferramentas de Simulação são ferramentas dessa categoria que permitem que partes de um sistema sejam testadas de maneiras que não seriam possíveis no mundo real.

Ferramentas de capacidade são ferramentas que testam a capacidade de resposta do sistema na execução de determinada tarefa.

Ferramentas de Teste de Performance são ferramentas que medem o tempo utilizado por vários eventos.

Ferramentas de Teste de Carga são ferramentas que criam um tráfego intenso no sistema.

Este tipo de ferramenta pode ser usado para testar volumes de dados e também um número grande de transações concorrentes.

Ferramentas da Execução e de Comparação de Teste são ferramentas que permitem que os testes sejam executados automaticamente e seus resultados sejam comparados com resultados previstos.

Estas ferramentas são aplicáveis à execução do teste em qualquer nível, unidade, integração, sistema, ou teste de aceitação.

Ferramentas de Repetição de Captura são ferramentas de execução e comparação do teste.

Um modelo matemático é uma descrição de um sistema por meio de equações e relações matemáticas, bem como de representações gráficas baseadas em leis ou princípios físicos que governam o sistema, os seja, o modelo é uma abstração do sistema original.

Os modelos matemáticos podem ser analíticos ou discretos.

Os modelos do tipo analítico são formados por uma série de equações matemáticas usadas para prever o comportamento do sistema pela atribuição de valores aos parâmetros do modelo e a solução repetida das equações para cada conjunto de valores.

Os modelos do tipo discreto são representados por uma estrutura matemática ou lógica que pode ser exercitada utilizando-se um computador, para simular o comportamento do sistema.

Dentre os modelos matemáticos destacam-se as CM (Markov Chains), propostas pelo matemático russo Andrey Andrevic Markov em 1889, as QN (Quering Network) desenvolvido a partir da teoria das filas, as SANs (Stochastich Automata Network) proposta por Brigitte Plateau nos anos 80, e as PN (Nets Petri) propostas por Carl Adam Petri em 1962.

SAN (Stochastic Automata Networks) é um formalismo que foi proposto por Plateau na década de 80.

A idéia básica das SAN é a de representar um sistema inteiro como uma coleção de subsistemas com comportamento independente, através de transições denominadas locais, e interdependentes através de taxas funcionais ou eventos sincronizantes.

O formalismo SAN tem a mesma equivalência de escopo da MC (Markov Chains), porém não apresenta o problema de explosão de estados proveniente do tamanho elevado da matriz infinitiesimal gerada pelas MC, ainda que a SAN guarde o mesmo espaço de estados de uma MC.

As transições entre os estados de cada autômato são modeladas por um processo estocástico de tempo contínuo ou discreto definidos por distribuições exponenciais ou geométricas respectivamente.

O estado do modelo SAN, chamado de estado global do sistema é definido pela combinação dos estados locais de todos os autômatos que compõem o sistema e o estado local por sua vez é o estado individual de cada autômato do modelo.

A mudança do estado global do sistema dá-se pela mudança do estado local de qualquer autômato do modelo.

As mudanças de estado de um ou mais autômatos está sempre associada a uma taxa de ocorrencia e pode disparada por um evento local, um evento sincronizante ou por uma função.

O uso de formalismos para geração de caso de teste de software tem sido objeto de pequisas em inúmeras universidades, nos mais diversos países e dentre os formalismos utilizados, as cadeias de Markov (MC) são as mais comuns, apesar de apresentaram o clássico problema da explosão de estados.

Além das cadeias de Markov, outros formalismo como SAN, (Stochastic Automata Networks) e SPN (Stochastic Petri Net) também são usados em pesquisas para avaliar o desempenho de sistemas.

Descrevemos aqui o uso de cada um deles.

Cadeias de Markov, o argumento em favor das cadeias de Markov como representação destes modelos de uso para testes de software advém de sua simplicidade e familiaridade.

As cadeias de Markov apresentam uma alta versatilidade, podendo ser representadas por matrizes estocásticas, gramáticas estocásticas, grafos direcionados e sistemas de equações onde cada uma destas aplicações agrega benefícios materiais distintos ao teste estatístico.

As cadeias são intuitivas no sentido de proporcionarem maior facilidade as pessoas em reconhecer os caminhos do sistema no diagrama de maneira direta, porém apresentam algumas limitações que tornam-se críticas à medida que a cadeia cresce em tamanho.

Quando o espaço de estados é discreto, este processo markoviano é representado por uma cadeia de Markov onde as probabilidades de transição são demonstradas através de matrizes de dimensões n x n, sendo n o número de estados desta cadeia.

Nas cadeias de Markov de tempo discreto, esta matriz é chamada de matriz de probabilidades de transição, sendo que nas cadeias Markov de tempo contínuo ela é chamada de matriz de taxas de transição ou gerador infiniesimal.

Formalismos de modelagem de sistemas como o acima são utilizados pelo teste estatístico baseado em modelos de uso, apud Sayre, para determinar o mapeamento das possíveis interações do usuário com o sistema.

Nestes modelos, chamados modelos de uso, os estados de uso do software são representados por estados da cadeia de Markov.

O uso de cadeia de Markov possibilita a modelagem de dois estados especiais, que são o Invoke que representa o início da execução e o Terminate que representa o término da execução, sendo que estes são os únicos estados inicial e final da cadeia, respectivamente.

As probabilidades de transição representam a probabilidade de ação do usuário, configurando os usos típicos do software e estes modelos de uso permitem a obtenção de métricas a respeito da correção do sistema, métricas diversas e o estabelecimento de critérios de parada para o processo de teste.

Rede de Autômatos Estocásticos, SAN, é um formalismo para modelagem de sistemas com um grande espaço de estados, equivalente a cadeia de Markov, podendo ser divididos em subsistemas "quase independentes".

Cada subsistema é definido por transições entre os estados de um ou mais autômatos, as transições entre os estados em uma SAN são modelados por um processo estocástico na escala de tempo continua ou discreta, segundo distribuições exponenciais ou geométricas.

Por serem isomórficas as cadeias de Markov, as SAN tem sido largamente utilizadas na modelagem de sistemas computacionais, especialmente no processo de teste de software.

Apesar de sua equivalencia com as cadeias de Markov as SAN não apresentam o problema da explosão de estados, caracteristicos do formalismos com o qual tem equivalência.

Dentre os exemplos de aplicação de SAN ao processo de teste de software, cabe destacar a feita por Barros que buscou integrar o formalismo a UML especificamente ao diagrama de atividades, gerando assim, após uma simplicação do modelo, um cenário para a execução dos testes.

Outro exemplo de aplicação que cabe destacar foi o feito por Farina que utilizou-se do formalismo SAN para a geração de teste estatistico de software, a partir da utilização do software utilizandos os softwares DocsEditor e BTS.

Outro exemplo de aplicação de formalismo é o demonstrado, onde o uso de UML para teste de software possibilita a implementação de uma estratégia para a seleção e geração automática de casos de teste a partir de diagramas de estados comportamentais da UML 2, a partir do algoritmo "Chinese Postman"visando fazer a seleção dos casos de teste de software verificando se o código gerado está em conformidade com o framework JUnit.

O presente trabalho tem por objetivo propor o uso do formalismo SAN (Stochastich Automata Network) para a geração de cenários de teste de software, gerados a partir do diagrama de estado da UML (Unified Modeling Language).

Tais cenários seram obtidos a partir das funções que o sistema deverá desempenhar, onde cada ação executada pelo usuário, bem como as ações desencadeadas pelo sistema, em cumprimento daquela executada inicialmente, será caracterizada como uma mudança de estado, no sistema e conseqüentemente na SAN resultante.

As funções que o sistema deve desempenhar serão definidas a partir da análise dos requisitos funcionais e não funcionais identificado na fase de análise, componente do processo de desenvolvimento do sistema.

A partir da identificação das funções que o mesmo deva desempenhar, sejam elas executadas pelo usuário ou resultande das ações dos mesmo.

Cada função do sistema do sistema será identificada e classificada em 2 grupos denominados de 1 funções primárias, aquelas executas pelo usuário, funções secundárias, aquelas executas em resposta as ações do usuário.

Com base nessa classificação serão gerados os diagramas de estado do sistema que darão origem ao modelo SAN.

A SAN será utilizada como um modelo de uso do sistema, para a extração de casos de teste de software.

O modelo SAN resultante desta pesquisa tem por finalidade, gerar cenários de teste de software que considere qual a probabilidade de todas as funções de um sistema serem desempenhadas em um determinado espaço de tempo e se cada função que o sistema desempenha corresponde ao que foi definido na fase de especificação de requisitos do sistema.

Revisão bibliográfica, esta fase compreende as revisões bibliográficas, necessárias para a execução da pesquisa, pois durante a o desenvolvimentos dos trabalhos, novas referências podem ser publicadas.

Análise do software a ser testado, nesta fase serão identificadas e classificas as funções que o sofwtare deve desempenhar e que serão utilizadas para a geração do diagrama de estados da UML.

Geração dos diagramas da UML, criar os diagramas de estado da UML que serão utilizados para a geração da SAN resultante do modelo a ser desenvolvido.

Geração preliminar do modelo SAN, geração do modelo preliminar SAN, a partir do diagrama de estado, que será utilizado nos testes de software.

Elaboração de um test suite, ou seja, de um conjunto de testes a serem aplicados com o uso da SAN gerada.

Redação de artigo científico.

Redação de um artigo cientifico visando apresentar os resultados parciais da pesquisa em desenvolvimento, em um evento cientifico.

Escrita e apresentação do Seminário de andamento, nesta fase será elaborado o seminário de andamento, com o objetivo de apresentar os resultados parciais da pesquisa e em cumprimento as exigencias do PPGCC.

Redação da dissertação de mestrado, elaboração da disertação a com base nos resultdos da pesquisa.

Apresentação da dissertação.

Apresentação da disertação a banca, em cumprimento as exigencias do PPGCC.

