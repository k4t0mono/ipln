Os estudos na área de Avaliação de Desempenho de Sistemas têm evoluído nos últimos anos, em especial com a definição do formalismo de Redes de Autômatos Estocásticos (SAN) e com a implementação do algoritmo Shuffle, o qual implementa um método eficiente para a execução da multiplicação vetor-descritor, necessária para a resolução de modelos SAN.

Mais recentemente, foi proposto um novo método para a multiplicação vetor-descritor, o método Slice, que introduzindo novos conceitos, prometia na teoria ser mais eficiente que o tradicional método Shuffle.

Pois neste estudo, este recém definido e até então pouco explorado método, foi estudado em detalhes e realizada uma implementação incluindo algumas otimizações no seu algoritmo original.

Ainda, durante este estudo, foram realizadas algumas modificações no algoritmo do método Slice com o intuito de resolver modelos SAN funcionais, uma vez que as versões anteriores não eram capaz de tratar funções.

Para demonstrar a eficiência do método Slice e das otimizações propostas, diversos experimentos foram conduzidos utilizando dois modelos SAN.

Os resultados de tempo e custo computacional foram analisados e discutidos durante este estudo, comparando-os inclusive com resultados do tradicional método Shuffle.

Desta forma, verificou-se o quanto o método Slice pode ser útil na resolução de sistemas, uma vez que os resultados práticos mostram que o método Slice é mais eficiente que a solução tradicional (Shuffle) na maioria dos casos.

A avaliação de desempenho de sistemas tem se tornado cada vez mais difícil, pois os sistemas em geral envolvem a cada dia que passa mais detalhes, tornando-se cada vez mais complexos.

O alto nível de detalhes dos sistemas encontrados no mundo real geram diversos problemas para a avaliação de desempenho.

Estes problemas vão desde a dificuldade na modelagem do sistema em um certo formalismo, até problemas relacionados ao custo computacional necessário para o cálculo da solução do sistema.

Um dos principais problemas encontrados na avaliação de desempenho de sistemas é a explosão do número de estados do sistema.

Muitos estudos vem sendo realizados nesta área com o intuito de encontrar técnicas para solucionar, ou ao menos minimizar este problema.

Algumas abordagens, como o formalismo de Redes de Autômatos Estocásticos (SAN), apresentam uma modelagem que visa reduzir o impacto da explosão do espaço de estados.

Porém, ainda assim, este problema persiste e tem se tornado uma grande barreira para a evolução da área de Avaliação de Desempenho de Sistemas.

Atualmente, existem diversas técnicas para avaliação de desempenho de sistemas, porém nenhuma delas apresenta resultados satisfatórios para todo e qualquer sistema.

O que ocorre, é que algumas técnicas são melhores para alguns sistemas específicos, enquanto outras se mostram mais adequadas para os demais tipos de sistemas.

Portanto, estudos nesta área ainda são realizados com grandes expectativas de bons resultados, não pensando em encontrar uma única técnica para cobrir todos os sistemas possíveis, mas principalmente para buscar melhores resultados em termos de desempenho.

Com o surgimento do formalismo de Redes de Autômatos Estocásticos (SAN, Stochastic Automata Networks), muitos estudos voltaram-se para o cálculo da resolução de sistemas modelados por este formalismo, uma vez que em termos de armazenamento, SAN apresenta uma forma bastante compacta e eficiente.

Sendo assim, o que se espera dos estudos nesta área é uma forma eficiente de resolver sistemas descritos por este formalismo, de maneira a exigir o menor custo computacional possível.

Com este objetivo, duas técnicas podem ser citadas, a técnica Shuffle, tradicional e já bastante explorada e divulgada mundialmente, e a técnica Slice, mais recente e ainda pouco divulgada, uma vez que seus estudos até então eram apenas teóricos.

A forma mais adequada de resolver modelos SAN é utilizando-se métodos iterativos, os quais possuem como operação fundamental a multiplicação de um vetor de probabilidades p pelo gerador infinitesimal Q (denominada Multiplicação Vetor-Descritor).

O objetivo principal deste trabalho é estudar em detalhes a técnica Slice de multiplicação vetor-descritor e provar na prática o seu bom desempenho na resolução de sistemas.

Além disso, a medida que cada parte do algoritmo desta técnica seja completamente entendida, são descobertas e propostas algumas otimizações, demonstrando tanto na teoria como na prática o ganho de desempenho que cada otimização resultaria.

Como um objetivo secundário, mas também bastante importante para a evolução dos estudos nesta área, pretende-se extender a técnica Slice com o intuito de resolver não apenas modelos com taxas exclusivamente constantes, mas também sistemas que apresentem modelagens contendo taxas funcionais.

De fato, isto seria fundamental para que a técnica Slice seja reconhecida globalmente como uma boa alternativa para resolução de modelos SAN, uma vez que a maioria dos sistemas requerem taxas funcionais em suas modelagens.

Enfim, ao final deste estudo, será possível conhecer melhor a técnica Slice e saber o quanto esta técnica realmente contribuirá para a evolução da resolução de sistemas, não apenas na teoria, mas também na prática através de exemplos de modelos SAN.

Este trabalho é formado por cinco capítulos incluindo esta introdução e as considerações finais.

O estudo é dividido basicamente em três partes principais, os conceitos básicos, a técnica Slice na teoria e a análise do desempenho desta técnica.

No Capítulo 2 são apresentados todos os conceitos básicos necessários para o completo entendimento do estudo que segue.

Inicialmente é descrito o formalismo de Redes de Autômatos Estocásticos, seguido pela explicação de como é realizada a resolução de modelosSANe também definição do descritor Markoviano das SAN.

Ao final, o capítulo 2 ainda apresenta a tradicional técnica de multiplicação vetor-descritor, conhecida como Shuffle, a qual é atualmente o parâmetro de comparação para qualquer nova técnica desta área.

O Capítulo 3 apresenta em detalhes a técnica Slice, a qual é o tema principal deste estudo.

Nas páginas deste capítulo é possível entender como esta técnica realiza a multiplicação vetordescritor, passando por cada etapa deste processo, conhecendo assim o conceito de Fator Normal Unitário Aditivo, que é a principal inovação da técnica Slice.

No capítulo seguinte, o Capítulo 4, é apresentada uma análise numérica do desempenho da técnica Slice, comparando-a eventualmente com o desempenho da técnica Shuffle.

Esta análise é dividida em duas partes, uma parte teórica, em que é estimado o custo computacional para ambas as técnicas através das fórmulas de custo computacional, e uma parte prática, a qual apresenta resultados práticos da implementação da técnica Slice, incluindo memória e tempo necessários para a execução de alguns exemplos de modelos SAN.

Finalmente, nas considerações finais são apresentadas as conclusões em relação ao desempenho da técnica Slice para resolução de modelos SAN, demonstrando assim a sua real contribuição para a área de avaliação de desempenho de sistemas, bem como os possíveis trabalhos futuros relacionados a este estudo.

Neste capítulo são apresentados alguns conceitos básicos importantes para o entendimento do trabalho desenvolvido.

Primeiramente, o formalismo Redes de Autômatos Estocásticos é descrito de forma a esclarecer os seus principais conceitos, o seu propósito e como é realizada a solução de sistemas neste formalismo.

Em seguida, é apresentado o método Shuffle, uma técnica tradicional utilizada para resolução de sistemas modelados através do formalismo SAN.

Estes conceitos são importantes para facilitar a compreensão da técnica Slice, a qual é o foco deste trabalho.

Redes de Autômatos Estocásticos (SAN) é um formalismo, baseado em Cadeias de Markov, para modelagem de sistemas.

Seu surgimento ocorreu nos anos 80 com Plateau.

A idéia central deste formalismo é modelar um sistema através de diversos subsistemas, chamados de autômatos, que podem ou não interagir entre si.

Através do uso de SAN a modelagem se apresenta mais compacta e modular, tornando-se muito interessante em sistemas com grandes espaços de estados.

A grande diferença e principal vantagem de Redes de Autômatos Estocásticos (SAN) em relação a Cadeias de Markov é exatamente a modularização, pois esta permite uma forma mais eficiente de armazenamento dos dados do sistema, evitando em muitos casos a explosão do espaço de estados, algo muito comum em Cadeias de Markov.

Desta forma, é possível encontrar soluções para sistemas maiores, com grande quantidade de dados.

É interessante ressaltar que toda SAN pode ser representada por um único autômato estocástico, o qual contém todos os estados possíveis do sistema.

Esse único autômato corresponde à Cadeia de Markov equivalente ao modelo SAN.

Logo, este formalismo é capaz de manter o poder de modelagem que se tinha com a utilização de Cadeias de Markov.

A seguir, são apresentados cada um dos conceitos relacionados às SAN e ainda uma breve introdução dos métodos numéricos mais utilizados nas soluções estacionárias e transiente dasSAN.

Imagine um sistema com um conjunto finito de estados e finitas transições entre eles, onde o sistema passa de um estado para outro por meio de eventos.

Esta é uma definição simplificada de um autômato estocástico.

O sistema pode encontrar-se em qualquer um de seus estados, os quais sintetizam as informações relativas às entradas anteriores e informam ainda os possíveis comportamentos do sistema diante das entradas seguintes.

A denominação de estocásticos atribuída a esses autômatos dá-se pela razão do tempo ser tratado como uma variável aleatória, a qual obedece uma distribuição exponencial na escala de tempo contínua, ou geométrica no caso de escala de tempo discreta.

Neste estudo utiliza-se a escala de tempo contínua.

Existem duas formas de observar estados em um modelo SAN.

Uma forma é observar o estado individual de cada autômato pertencente ao modelo, chamado este de estado local.

Outra, é considerar a combinação dos estados de todos os autômatos envolvidos no modelo, o qual denomina-se de estado global do sistema.

Portanto, a mudança do estado de qualquer autômato do modelo, necessariamente acarretará na mudança do estado global do sistema.

As mudanças de estados locais nos autômatos ocorrem através de transições, que por sua vez são disparadas pela ocorrência de eventos ao longo do tempo.

Cada transição deve ter ao menos um evento associado a ela, podendo este ser um evento local ou sincronizante.

Pode-se definir um evento como uma ação relevante que modifica o estado global do sistema.

Os eventos estão diretamente associados às transições do modelo, isto é, sempre que um evento ocorre, uma ou mais transições são realizadas.

Em SAN, os eventos podem ser de dois tipos, locais ou sincronizantes.

Eventos locais são aqueles que modificam o estado local de um único autômato sem interferir no estado local dos demais autômatos do modelo.

Estes eventos são normalmente utilizados quando se quer modelar comportamentos independentes entre autômatos.

Por outro lado, é possível modelar sincronismo entre dois ou mais autômatos através de eventos sincronizantes.

Estes eventos disparam transições em mais de um autômato, modificando assim os estados locais dos autômatos envolvidos.

Todo modelo SAN para estar completo deve apresentar uma tabela de eventos.

Esta tabela contém os identificadores dos eventos, as taxas de ocorrências e ainda o tipo de cada evento pertencente ao modelo.

Deve-se consultar essa tabela para distinguir os eventos locais dos sincronizantes, uma vez que a representação gráfica não apresenta tal informação.

Apresenta um modelo SAN formado por dois autômatos com três eventos locais e um evento sincronizante.

Modelo SAN com 2 autômatos com evento sincronizante.

Taxa de ocorrência e tipo dos eventos do modelo SAN apresentado.

Neste exemplo, o autômato A(1) possui três estados 0(1), 1(1) e 2(1), enquanto que o autômato A(2) do modelo possui apenas dois estados 0(2) e 1(2).

O modelo apresenta ainda quatro eventos, sendo três eventos locais (e1, e2 e e4) e um sincronizante (e3).

Quando o evento sincronizante (e3) ocorre, o autômato A(1) passa do estado local 2(1) para 0(1) ao mesmo passo que o autômato A(2) sai do estado 0(2) e vai para o estado 1(2).

Todo evento em um modelo SAN deve ter associado a si uma taxa de ocorrência e uma probabilidade de rotação.

Tanto a taxa de ocorrência como a probabilidade de rotação podem ser definidas como valores constantes ou valores funcionais.

Quando as taxas e/ou probabilidades são definidas como valores funcionais, estas são então ditas taxas e/ou probabilidades funcionais.

Neste caso, os valores assumidos por estas taxas e probabilidades dependem dos estados locais dos demais autômatos do modelo.

A utilização de taxas e probabilidades funcionais proporciona uma segunda possibilidade de interação entre autômatos nos modelos SAN, a outra possibilidade é a utilização de eventos sincronizantes1 como visto anteriormente.

As funções associadas com as taxas e/ou probabilidades permitem atribuir a um mesmo evento diferentes valores conforme o estado global do sistema.

Modelo SAN com dois autômatos, um evento sincronizante e uma taxa funcional.

Apresenta um exemplo de modelo SAN com 2 autômatos, o primeiro com 3 estados e o segundo com 2 estados.

Neste exemplo, pode-se observar no autômato A(1) a utilização de probabilidades para as diferentes transições do evento sincronizante e4.

Nota-se que o evento e5 do autômato A(2) possui uma função f1 associada a sua taxa de ocorrência.

Dessa forma, a taxa de ocorrência deste evento será determinada pela função f1.

Isto significa que a transição do estado 0(2) para o estado 1(2) ocorre com uma taxa de ocorrência 1, caso o autômato A(1) esteja no estado 0(1), ocorre com uma taxa 2, caso o autômato A(1) esteja no estado 2(1), e não ocorre caso o autômato A(1) esteja no estado 1(1).

Função de atingibilidade nada mais é do que uma função booleana que determina os estados atingíveis em um modelo SAN.

Esta função deve ser utilizada sempre que for identificado que um ou mais estados do sistema nunca serão alcançados.

Por outro lado, a função de atingibilidade deve assumir o valor 1 caso todos os estados do modelo SAN sejam atingíveis.

Podemos supor, por exemplo, que o autômato A(1) não pode se encontrar no estado 2(1) se o autômato A(2) estiver no estado 1(2), e vice-versa.

Para isto deve-se definir a seguinte função de atingibilidade.

Dessa forma, os possíveis estados globais desta SAN seriam 0(1)0(2), 0(1)1(2), 1(1)0(2), 1(1)1(2) e 2(1)0(2).

As funções de integração podem ser definidas em qualquer modelo SAN.

A proposta destas funções é obter a probabilidade do modelo encontrar-se em um determinado estado.

As funções de integração3 podem ser definidas de forma a avaliarem a probabilidade do modelo estar em um conjunto de estados, podendo obter assim índices de desempenho e confiabilidade do modelo.

A avaliação dessas funções é realizada sobre o vetor de probabilidades que contém a probabilidade do modelo se encontrar em cada um de seus possíveis estados.

Por exemplo, considerando a SAN apresentada, a função de integração f, avaliaria a probabilidade do autômato A(1) estar no estado 2(1).

Existem alguns métodos iterativos que podem ser aplicados à resolução dasSAN, entre estes, destaca-se o método de Arnoldi, GMRES e o método da Potência implementados na ferramenta PEPS.

Nestes métodos, a operação básica é a multiplicação de um vetor de probabilidades por uma matriz, ou seja, a cada iteração é gerada uma seqüência p(k) de valores aproximados do vetor de probabilidades estacionárias que devem convergir para a solução p.

Logo o número de iterações torna-se um fator relevante na verificação do custo total de aplicação destes métodos.

O Método da Potência em especial será o foco do estudo comparativo deste trabalho, uma vez que serão estudados algoritmos de resolução de SAN que se utilizam deste método.

O princípio básico deste método é, através da multiplicação de um vetor de probabilidades pi(0) por uma matriz de probabilidades P, obter o vetor solução ou auto-vetor pi, isto se considerarmos que a matriz P estará elevada no 8, ou seja, pi = pi(0) P.

Normalmente, as soluções dos métodos iterativos, como é o caso do método da Potência, são obtidas através de aproximações constantes, onde uma solução é considerada satisfatória somente se obedece a algum critério de tolerância estabelecido.

Este critério pode ser observado através da diferença entre as iterações anteriores e a atual iteração.

Desta forma, a solução esperada é pi(n), e para sabermos seu valor é necessário conhecer o valor de pi(n-1), e assim sucessivamente.

Portanto, para o cálculo do vetor de probabilidades estacionárias pi(n), considera-se o esquema iterativo descrito genericamente por pi(n) = pi(n1) P.

No âmbito da multiplicação vetor-descritor necessária para solução de modelos SAN, considera-se P uma dada matriz de transição Q, que deve estar normalizada, somada a uma matriz identidade I.

Além disto, pi(0) pode ser um vetor de probabilidades inicialmente equiprovável, ou um vetor inicializado com probabilidades pré-definidas segundo algum critério.

A solução que buscamos neste caso é um vetor de probabilidades normalizado, onde a soma de seus elementos é igual a 1.

Considerando que um descritor SAN é um gerador infinitesimal dado por (Q +I), a solução estacionária de uma SAN é simplesmente a resolução deste sistema linear.

Neste caso, com matrizes de transição.

Neste esquema de iterações demonstrado na Equação, tem-se o termo (Q + I) que representa uma matriz de probabilidade (denominada matriz P anteriormente).

Para entender o Descritor Markoviano das SAN, primeiramente é necessário compreender o conceito de matriz de transição de um autômato estocástico.

A matriz de transição de um autômato estocástico nada mais é que uma representação matricial das possíveis trocas de estados do autômato, levando-se em conta também as taxas das transições.

Para entender como pode-se obter a matriz de transição correspondente a um determinado autômato estocástico, consideremos a cadeia de Markov descrita.

A matriz de transição Q desta cadeia de Markov é uma matriz quadrada de ordem nQ igual ao número de estados pertencentes a esta cadeia, neste caso, nQ = 4 (estados A, B, C e D respectivamente).

Cada linha e cada coluna da matriz de transição Q é associada a um estado da cadeia de Markov segundo a ordem lexicográfica dos mesmos.

Logo, considerando o exemplo dado, a primeira linha e a primeira coluna de Q correspondem ao estado A, a segunda linha e a segunda coluna correspondem ao estado B, assim como a terceira linha e a terceira coluna correspondem ao estado C, e a quarta linha e quarta coluna ao estado D.

Os elementos qij de uma matriz Q correspondem as taxas de disparo das transições do autômato estocástico que se está sendo representando, considerando o estado associado à linha i como o estado de partida da transição e o estado associado à coluna j o estado de chegada desta mesma transição.

Dessa forma, obtém-se os elementos não-diagonais da matriz Q, os elementos da diagonal principal desta matriz são definidos de forma a ser nula a soma dos elementos em cada uma das linhas da matriz.

Assim, a diagonal expressará o ajuste necessário para que a soma de todos os elementos de cada linha seja igual a zero.

Portanto, os elementos da diagonal principal serão necessariamente negativos ou nulos.

O formalismoSANfornece uma descrição compacta da matriz de transição (gerador infinitesimal) correspondente à Cadeia de Markov associada ao modelo completo, a qual é chamada de Descritor Markoviano.

Essa é mais uma vantagem do formalismo SAN em relação aos demais formalismos.

O descritor Markoviano, considerando as matrizes de transição de cada autômato do modelo, descreve de forma algébrica o gerador infinitesimal da cadeia de Markov associada à SAN.

Cada autômato estocástico A de uma modelo SAN possui uma matriz de transição local Ql, que agrupa todas as taxas correspondentes as transições locais, e 2E matrizes de transição sincronizantes, as quais agrupam todas as taxas de transições dos eventos sincronizantes e do conjunto e, chamadas Qe+ e Qe, onde E é o total de eventos sincronizantes do modelo SAN e e é o conjunto de identificadores destes eventos.

Estas matrizes de transição, locais e sincronizantes, são utilizadas para expressar o descritor Markoviano de uma rede de autômatos estocásticos, como apresentado nas seções subseqüentes.

OdescritorMarkoviano deuma redede autômatos estocásticosédescritoatravésde operações tensoriais entre as matrizes de transição do modelo.

Este descritor é expresso em duas partes, a parte local, que corresponde às transições locais de cada autômato do modelo, e a parte sincronizante, que corresponde às transições disparadas pelos eventos sincronizantes pertencentes ao modelo SAN.

Parte Local do Descritor Markoviano.

A parte local do descritor Markoviano é definida por uma soma tensorial das matrizes locais de cada autômato do modelo.

Considerando o exemplo de modelo SAN apresentado, vejamos como seriam descritos os seus eventos locais.

Para cada autômato A do modelo, existe uma matriz de transição local Ql associada.

Logo, tem-se duas matrizes locais, Q(1)l e Q(2)l.

A matriz de transição local Ql do autômato equivalente à esta rede de autômatos estocásticos corresponde a soma tensorial das matrizes de transições locais.

Portanto, uma matrizde transiçãolocalagrupa todas astaxas dos eventos locaisdoautômato.

Se o modelo SAN apresentasse somente eventos locais, o gerador infinitesimal Q do autômato equivalente a este modelo seria simplesmente à soma tensorial4 das matrizes de transição locais do modelo.

A parte sincronizante do descritor Markoviano é composta pelas matrizes de transição dos eventos sincronizantes do modelo SAN.

Para cada evento sincronizante e para cada autômato do modelo são descritas duas matrizes, uma descrevendo as ocorrências do evento sincronizante (matriz positiva), e a outra (matriz negativa) descrevendo o ajuste diagonal correspondente a cada taxa descrita na matriz de ocorrência.

Para cada evento sincronizante do modeloSANé definido um autômato mestre e um ou mais autômatos escravos, dentre os autômatos que sofrem influência destes eventos.

Podem ainda existir autômatos que não são influenciados por determinados eventos sincronizantes.

Neste caso, as matrizes positivas e negativas destes eventos para estes autômatos serão matrizes identidade, uma vez que não ocorrerá nenhuma mudança de estado nestes autômatos em decorrência de tal evento.

A matriz positiva correspondente ao autômato mestre contém a taxa de disparo de um dado evento sincronizante e, enquanto que as matrizes positivas dos autômatos escravos contêm uma taxa de disparo igual a um, ou igual a probabilidade da transição relacionada ao evento ocorrer.

Vejamos a parte sincronizante positiva do modelo SAN considerando o autômato A(1) mestre para o evento sincronizante e3.

As matrizes de ajuste diagonal, ou matrizes negativas, possuem apenas elementos na diagonal principal, os quais correspondem aos ajustes correspondentes as taxas apresentadas nas matrizes positivas.

Na matriz do autômato mestre, a taxa é igual a da matriz positiva, porém negativa, ao passo que nas matrizes dos autômatos escravos, as taxas são sempre iguais a um.

Sendo assim, para o exemplo teríamos matrizes negativas, considerando o autômato A(1) como mestre.

Portanto, para cada evento sincronizante do modelo SAN são descritos dois produtos tensoriais, um produto das matrizes positivas e outro das matrizes negativas.

Como dito anteriormente, o descritor Markoviano é composto de duas partes, a parte correspondente as matrizes de transição locais e a parte contendo as matrizes sincronizantes (positivas e negativas).

Portanto, considerando que o descritor Markoviano completo é a soma da parte local com a parte sincronizante de cada autômato do modelo SAN, pode-se descrevê-lo genericamente.

Considerando ainda que uma soma tensorial entre matrizes é decomposta na soma convencional de produtos tensoriais destas matrizes 5, o descritor Markoviano pode ser descrito de outra forma, a qual apresenta todas as matrizes de transição necessárias para descrever uma rede de autômatos estocásticos.

Técnica Shuffle Também conhecida como Técnica de Embaralhamento, a técnica Shuffle6 implementa uma técnica tradicional utilizada em uma das operações fundamentais realizadas pelos métodos iterativos, a multiplicação de um vetor de probabilidades v, pelo gerador infinitesimal Q.

Em especial, são tratadas as particularidades envolvidas na seguinte operação de multiplicação.

A seguir, serão estabelecidas algumas definições sobre seqüências finitas de matrizes, importantes para a apresentação do algoritmo utilizado no método Shuffle.

Sejam ni dimensão da i-ésima matriz de uma seqüência, nlefti produto das dimensões de todas as matrizes à esquerda da i-ésima matriz de uma seqüência, ie, nrighti produto das dimensões de todas as matrizes à direita da i-ésima matriz de uma seqüência, ie, ¯ni produto dasdimensões de todas as matrizes exceto a i-ésima matriz de uma seqüência.

Veremos na próxima seção que através da propriedade de decomposição de produtos tensoriais a multiplicação de um vetor v pelo termo pode ser reescrita de uma forma mais modular utilizando-se fatores normais.

Fator normal é um caso especial de produto tensorial entre uma matriz Q e uma matriz identidade I, sendo dois fatores normais possíveis.

Assim, a implementação desta operação torna-se mais flexível.

Com o intuito de decompor o termo e assim facilitar a operação de multiplicação do vetor pelo termo, faz-se uso da propriedade de decomposição de produtos tensoriais mostrada.

Essa nova forma de calcular o produto tensorial entre as matrizes daSANsimplifica bastante a multiplicação do vetor v pelo descritor infinitesimal Q.

Pois agora, é possível multiplicar o vetor por cada fator normal individualmente, podendo-se criar fases bem distintas.

Assim, o cálculo como um todo se torna mais modular e o custo com memória diminui consideravelmente, uma vez que não é mais necessário gerar todo o descritor Markoviano antes de efetuar a multiplicação com o vetor.

Vale salientar que tudo isso é possível graças à propriedade de associatividade da multiplicação (convencional) de matrizes.

Além disto, a propriedade da comutatividade entre fatores normais permite a multiplicação de fatores normais em qualquer ordem, se necessário.

Sendo assim, para calcular o produto vetor-descritor, basta multiplicar o vetor v pelo primeiro fator normal, multiplicar então o resultado pelo segundo fator normal, e assim por diante, até o último dos fatores normais.

Claramente nota-se que agora é possível realizar a multiplicação do vetor por cada matriz individualmente, não sendo mais necessário trabalhar com todas as matrizes em um mesmo momento.

Nas próximas seções veremos como funciona e como foi implementado o algoritmo de Deslocamento para a multiplicação do vetor v por cada tipo de fator normal.

Sabe-se que o produto tensorial de uma matriz identidade por uma matriz M qualquer sempre resulta em uma matriz de blocos diagonais, onde cada bloco é a própria matriz M.

Logo, a matriz resultante do produto tensorial InleftN Q(N) é uma matriz de nleftN blocos diagonais, onde cada bloco é simplesmente a matriz Q(N).

Dessa forma, podemos dividir o vetor v em nleftN vetores (chamados de zin) com nN elementos e multiplicar cada um destes com a matriz Q(N) que corresponde ao bloco diagonal da matriz resultante.

Ilustra como seria este procedimento.

O Algoritmo 21 mostra os passos da multiplicação.

Este algoritmo possui um loop principal que realiza cada multiplicação do vetor zin pela matriz Q(N).

Internamente, existem ainda dois outros laços que servem para gerar o vetor zin extraindo valores do vetor v, e para acumular os resultados da multiplicação no vetor v.

Na linha 8 ocorre a multiplicação propriamente dita do vetor zin pela matriz Q(N) e o resultado armazenado em outro vetor denominado zout de mesmo tamanho do vetor zin.

Note que todo o procedimento é realizado apenas com a utilização do vetor v e da matriz Q(N), não sendo necessário gerar a matriz InleftN Q(N) em nenhum momento.

A multiplicação do vetor v pelo primeiro fator normal é semelhante a do último fator normal, a única diferença está no processo de extração dos valores do vetor v para gerar cada vetor zin.

Essa diferença se dá pelo fato da matriz Q(1) Inright1 possuir uma forma distinta em relação a matriz envolvida na outra multiplicação.

Dessa forma, para gerar o vetor zin não basta extrair nN elementos consecutivos do vetor v, é preciso extrair os elementos alternadamente.

Isto é, tem-se que buscar um elemento a cada nright1 elementos do vetor v.

O algoritmo 22 apresenta a multiplicação do vetor v pela matriz Q(1) Inright.

Este algoritmo forma nright1 vetores zin buscando os elementos alternadamente no vetor v.

Realiza a multiplicação do vetor zin pela matriz Q(1) e acumula o resultado no vetor auxiliar zout.

Este vetor então é atribuído ao vetor v que ao final conterá o resultado de toda a operação.

A multiplicação do vetor v pelos demais fatores normais (do segundo fator normal ao penúltimo fator normal)é realizada com a combinação das duas outras.

A técnica básica consiste em aplicar a propriedade da pseudo-comutatividade do fator normal.

Isto nos leva a sempre multiplicar os fatores normais, inclusive o primeiro e o último.

As multiplicações são realizadas sempre de acordo com a posição da matriz Q.

O Algoritmo 23 resume os passos implementados para multiplicar um vetor v por um produto tensorial Ni=1Q.

Neste algoritmo os fatores normais são tratados do primeiro ao último.

Entretanto, de acordo com a propriedade da comutatividade dos fatores normais, outra ordem pode também ser aplicada.

Note que as multiplicações pelo primeiro e pelo último fator normal também são cobertos por este algoritmo, logo os algoritmos 21 e 22 não precisam serem implementados, são usados apenas para o entendimento.

O Algoritmo 23 forma nlefti× nrighti vetores zin buscando os elementos nas posições corretas do vetor v, conforme o nrighti.

Em seguida, realiza a multiplicação do vetor zin pela matriz Q e acumula o resultado no vetor auxiliar zout.

Este vetor então é atribuído, de forma análoga a extração, ao vetor v que ao final terá o resultado de toda a multiplicação.

Esta seção apresenta através de um exemplo todas as etapas que constituem o procedimento de multiplicação vetor-descritor.

Considere um modelo SAN definido por três autômatos A(1), A(2) e A(3).

A multiplicação do vetor v pela parte local do descritor passa pelos seguintes termos, sendo Ql o descritor correspondente à descrição das transições locais de cada autômato i.

Cada termo é multiplicado pelo vetor v previamente inicializado.

O resultado de cada multiplicação é então acumulado em um vetor auxiliar w.

Após realizar as multiplicações com cada um dos três termos, o valor resultante acumulado no vetor w é então atribuído novamente às posições de v.

Deve-se multiplicar o vetor v pelo descritor de cada evento sincronizante ei.

Supondo que a SAN possua três eventos sincronizantes (e1, e2 e e3).

Resultados em z são então acumulados no vetor w.

É importante salientar que a multiplicação pela parte sincronizante deve ser realizada tanto para a parte positiva quanto para a parte negativa, portanto o procedimento acima deve ser realizado duas vezes.

Ao final, o vetor auxiliar w contém o resultado da multiplicação do vetor v pelo descritor Markoviano do modelo.

O custo computacional do algoritmo Shuffe, segundo seus criadores, para realizar o produto de um vetor por um termo tensorial é obtido pelo número de multiplicações vetor-matriz executadas.

Para cada iteração i do algoritmo são executadas nlefti × nrighti multiplicações vetor-matriz com matrizes de tamanho ni.

Supondo que as matrizes Q não possuem elementos nulos, o número de multiplicações para cada produto vetor-matriz é igual a (ni)2.

Lembrando que ¯ni ×ni = nlefti × nrighti ×ni =1 ni.

Porém, normalmente as matrizes Q possuem um número considerável de elementos nulos, os quais são desconsiderados pelo algoritmo.

Logo, o número de multiplicações para cada produto vetor-matriz será, freqüentemente, inferior a (ni)2.

Assim, sendo nzi o número de elementos não nulos de uma dada matriz Q.

Na prática, considerando que para obter as soluções estacionárias dos modelos SAN é necessário multiplicar um vetor de probabilidades pelo Descritor Markoviano completo do modelo.

O capítulo seguinte apresenta uma descrição detalhada da técnica Slice, bem como os principais trechos de seu algoritmo.

O principal problema para a resolução de Redes de Autômatos Estocásticos (SAN) vem sendo ao longo do tempo a explosão do espaço de estados.

Isso se deve ao fato de que para resolver umaSANé necessário realizar a multiplicação de um vetor de probabilidades pelo gerador infinitesimal, operação que normalmente envolve uma grande quantidade de dados, exigindo um alto processamento e uso de memória.

Com o intuito de minimizar a utilização de recursos computacionais, diferentes técnicas vêm sendo estudadas, entre elas destacam-se a técnica Shuffle e a técnica Slice.

A técnica Slice é uma técnica recentemente descoberta que implementa a resolução de Redes de Autômatos Estocásticos (SAN).

A operação fundamental realizada nesta técnica, assim como na maioria das outras técnicas semelhantes, é a multiplicação de um vetor de probabilidades v pelo gerador infinitesimal Q.

Em especial, serão tratadas as particularidades envolvidas na execução e na implementação da operação de multiplicação apresentada a seguir, visto que esta é a operação fundamental para a resolução de modelos SAN.

Todas as definições estabelecidas na seção 24 do capítulo 2 sobre seqüências finitas de matrizes serão da mesma forma utilizadas neste capítulo na definição do algoritmo da técnica Slice.

Para realizar a multiplicação vetor-descritor, a técnica Slice, utilizando-se de propriedades da álgebra tensorial, introduz uma nova forma de decompor esta operação, chamada de Decomposição Aditiva em Fatores Normais Unitários Aditivos, a qual é abordada nas seções subseqüentes.

Fatores Normais Unitários Aditivos é uma nova maneira de decompor um produto tensorial qualquer.

O objetivo é reduzir as operações necessárias para executar a multiplicação de um dado vetor p por um produto tensorial entre matrizes.

Os fatores normais unitários aditivos levam em consideração as primeiras (N1) matrizes componentes do produto tensorial, onde N é o número total de matrizes envolvidas na operação.

Cada fator normal unitário aditivo (AUNF) é constituído pelo produto tensorial da matriz resultante do produto tensorial entre as primeiras (N1) matrizes contendo apenas um elemento não-nulo por vez, pela última matriz N.

Esta decomposição é chamada de Decomposição Aditiva em Fatores Normais Unitários Aditivos, uma vez que os termos são somados.

Ao multiplicarmos cada AUNF pi pelo vetor de probabilidades pi, cada resultado é somado em um vetor acumulador ii, que ao final das multiplicações conterá a solução do modelo.

Segundo Webber, para diversos modelos tem-se um ganho significativo em termos do número de multiplicações realizadas.

Essa seção apresenta as etapas que constituem a multiplicação vetor-descritor utilizando a decomposição em fatores normais unitários aditivos.

A multiplicação vetor-descritor é composta pela multiplicação do vetor de probabilidades pela parte local e pela parte sincronizante do descritor Markoviano, como veremos a seguir.

Considerando o exemplo anterior, a multiplicação do vetor v pela parte local do descritor passa pelos seguintes termos, sendo Ql o descritor correspondente à descrição das transições locais de cada autômato i.

Cada termo é multiplicado pelo vetor v previamente inicializado.

O resultado de cada multiplicação é então acumulado em um vetor auxiliar w.

Após realizar as multiplicações com cada um dos três termos, o valor resultante acumulado no vetor w é então atribuído novamente às posições de v.

Na prática, o algoritmo da técnica Slice realiza a multiplicação da parte local do descritor fatiando cada um destes termos, como detalhado a seguir.

A multiplicação do vetor de probabilidades pelo gerador infinitesimal é dividida em duas partes da mesma forma como o descritor Markoviano, conforme exposto na seção 23 do capítulo 2.

A primeira parte corresponde a multiplicação do vetor de probabilidades pela parte local do modelo SAN e a segunda a multiplicação do mesmo vetor de probabilidades pela parte sincronizante do modelo.

Ao final, soma-se os vetores resultantes de cada uma destas operações encontrando-se então o vetor com o resultado final da multiplicação do vetor de probabilidades pelo descritor Markoviano.

Apresenta a parte local do descritor Markoviano, a qual contém apenas as matrizes de transição dos eventos locais do modelo SAN.

Observa-se nesta tabela que a parte local do gerador infinitesimal é formado pelo somatório de N produtos tensoriais de N matrizes.

Sendo assim, a multiplicação do vetor de probabilidades pela parte local do gerador infinitesimal pode ser dividida em N partes, onde cada uma corresponde a multiplicação do vetor de probabilidades pelo produto tensorial apresentado em cada linha.

Parte Local do Descritor Markoviano.

Percebe-se ainda que cada produto tensorial é composto por N1 matrizes identidades e apenas uma matriz Ql, a qual pode conter qualquer valor em seus elementos, onde i é o índice do autômato no modelo SAN.

Sabe-se que em um produto tensorial, as matrizes identidades não modificam os elementos das demais matrizes, apenas replicam e reposicionam estes valores na matriz resultante.

Dessa forma, a matriz resultante do produto tensorial de cada linha será sempre uma matriz contendo os mesmos elementos da matriz Ql, porém replicados e reposicionados.

Portanto, a operação de multiplicação do vetor de probabilidades por cada um destes produtos tensoriais resume-se em descobrir onde cada um dos elementos não-nulos da matriz Ql seria posicionado na matriz resultante, pois assim basta multiplicar estes valores pelos elementos correspondentes no vetor de probabilidades.

Na prática, o algoritmo da técnica Slice descobre apenas onde apareceriaaprimeiraocorrência de cada valor não-nulo da matriz Ql na matriz resultante do produto tensorial.

Sabendo-se onde estaria posicionada a primeira ocorrência do elemento e considerando a posição da matriz Ql no produto tensorial, é possível descobrir quais valores do vetor de probabilidades devem ser multiplicados por este elemento não-nulo.

O Algoritmo mostra como é realizada a multiplicação de um valor não-nulo da matriz Ql pelos elementos correspondentes no vetor de probabilidades.

Onde bi e bj são inicializados respectivamente com a linha e a coluna da primeira ocorrência de uma elemento não-nulo da matriz Ql na matriz resultante, nv é o tamanho do vetor de probabilidades, ni a dimensão da matriz Ql, nRight é o produto das dimensões de todas as matrizes à direita da matriz Ql, Prob o vetor de probabilidades, dElem o elemento não-nulo da matriz Ql e vRes o vetor acumulador resultante.

É importante salientar que em momento algum os produtos tensoriais entre as matrizes identidades e as matrizes Ql são realizados, reduzindo assim consideravelmente o custo computacional de toda operação.

Para realizar a multiplicação do vetor de probabilidades por cada um dos N produtos tensoriais descritos, o algoritmo da técnica Slice executa nzi vezes o código apresentado no Algoritmo 31, onde nzi é o número de elementos não-nulos da matriz Ql.

Portanto, para realizar a multiplicação completa do vetor de probabilidades pela parte local do descritor Markoviano, basta executar repetidas vezes o código apresentado no Algoritmo 31.

Multiplicação de um elemento não-nulo de uma matriz Ql pelo vetor de probabilidades É na multiplicação do vetor de probabilidades pela parte sincronizante do descritor Markoviano que se encontra a principal diferença entre a técnica Slice e as demais, vejamos um exemplo.

Considerando três matrizes de ordem ni = 2 e um vetor de probabilidades p(0) de tamanho n = 8 (n1 × n2 × n3), tem-se para este exemplo a definição de (n12 × n22) fatores normais unitários aditivos, um para cada elemento não-nulo do produto tensorial A B.

Vejamos então as etapas da multiplicação vetor-descritor para o termo A B C supondo as seguintes matrizes, Multiplicação de pi(0) pelo Fator Normal Unitário Aditivo (p1).

Este AUNF é decomposto em dois fatores normais tradicionais, o vetor pi(1) terá dois elementos não-nulos (ordem nN da última matriz).

O resultado em pi(2) é evntão acumulado em um vetor acumulador ii.

Multiplicação de p(0) pelo 2 Fator Normal Unitário Aditivo (2).

Novamente o AUNF é decomposto em dois fatores normais tradicionais, o vetor pi(1) terá dois elementos não-nulos (ordem nN da última matriz).

O resultado em pi(2) é então acumulado em um vetor acumulador ii.

E assim por diante, chegando neste exemplo em um total de 16 fatores normais unitários aditivos.

Todos são multiplicados pelo vetor pi(0) seguindo as mesmas etapas demonstradas acima.

Ao final de todas essas etapas, o vetor de probabilidades ii conterá a solução do produto tensorial.

Temos então basicamente duas operações que devem ser realizadas para cada AUNF com o intuito de obter o vetor de probabilidades ii.

Essas operações são a multiplicação do vetor p(0) pelo primeiro termo do AUNF e a multiplicação do vetor p(1) pelo segundo termo deste mesmo AUNF.

Para entender como o algoritmo da técnica Slice realiza a multiplicação do vetor de probabilidades pela parte sincronizante do descritor Markoviano, vejamos a parte sincronizante do gerador infinitesimal, que corresponde apenas as matrizes de transição dos eventos sincronizantes do modelo SAN.

Parte Sincronizante do Descritor Markoviano A parte sincronizante do descritor Markoviano é dividida em duas partes, uma correspondendo as matrizes positivas dos eventos sincronizantes e a outra referente as matrizes negativas destes mesmos eventos.

Nota-se que a parte das matrizes sincronizantes positiva é exatamente igual a correspondente as matrizes negativas, podendo se diferenciar apenas no conteúdo das matrizes.

Por este motivo, são apresentados a seguir apenas os detalhes do algoritmo da técnica Slice referentes a multiplicação do vetor de probabilidades pela parte positiva do gerador infinitesimal, uma vez que a operação envolvendo a parte negativa dos eventos sincronizantes é realizada da mesma maneira.

Percebe-se que diferentemente da parte local, a parte sincronizante do descritor Markoviano é composto por produtos tensoriais de matrizes que não são necessariamente identidades, o que torna o cálculo da multiplicação um pouco mais complicado.

Assim como na multiplicação pela parte local do gerador infinitesimal, é possível modularizar o cálculo da parte sincronizante em multiplicações mais simples.

Estas correspondem as multiplicações do vetor de probabilidades por cada produto tensorial das N matrizes de cada evento sincronizante do modelo SAN, representados por cada linha.

Além disso, como apresentado na seção 31, o produto tensorial entre as matrizes sincronizantes é decomposto em diversos Fatores Normais Unitários Aditivos, que por sua vez são decompostos em Fatores Normais Tradicionais, tornando o cálculo ainda mais modularizado.

Dessa forma, a multiplicação do vetor de probabilidades pela parte sincronizante do descritor Markoviano resume-se a um somatório do resultado da multiplicação do vetor de probabilidades pelo primeiro Fator Normal Tradicional do AUNF, multiplicado pelo segundo Fator Normal Tradicional do mesmo AUNF.

O Algoritmo 32 apresenta em linhas gerais os passos implementados para realizar a multiplicação do vetor de probabilidades vProb pela parte sincronizante do descritor Markoviano.

Algoritmo 32, multiplicação do vetor de probabilidades pela parte sincronizante do descritor Markoviano O Algoritmo 32 percorre todos os eventos sincronizantes através do laço na linha 1, onde nE é o total de eventos sincronizantes do modelo SAN.

Para cada evento, um novo laço percorre todos os Fatores Normais Unitários Aditivos que compõem o produto tensorial entre as matrizes sincronizantes deste evento.

Enfim, para cada AUNF multiplica-se o vetor de probabilidades vProb pelo primeiro Fator Normal Tradicional do AUNF, e em seguida, o resultado armazenado em vAux é multiplicado pelo segundo Fator Normal Tradicional do AUNF e o resultadoé acumulado no vetor vRes, que ao final conterá o vetor resultado de toda a operação.

Para descobrir cada um dos Fatores Normais Unitários Aditivos dos eventos sincronizantes de um modelo SAN, basta na verdade descobrir a linha, a coluna e o valor de cada um dos elementos da matriz resultante do produto tensorial das N1 primeiras matrizes sincronizantes do evento.

O Algoritmo 33 apresenta o código necessário para descobrir cada um destes valores com suas respectivas linhas e colunas nesta matriz resultante, sem realizar de fato o produto tensorial entre as matrizes.

O Algoritmo 33 mostra como foi implementada a rotina que descobre o elemento não-nulo de cada AUNF.

Primeiramente, verifica-se se é o primeiro AUNF para calcular, se for, é necessário percorrer todas as matrizes para pegar um elemento de cada para calcular o elemento não-nulo do AUNF.

Apresenta o laço que percorre as matrizes para pegar seus elementos.

Para otimizar este processo, as multiplicações entre os elementos das matrizes a medida que estão sendo realizadas são armazenadas em um vetor vFator, com o intuito de serem reutilizadas quando necessário.

Dessa forma, não é necessário percorrer todas as matrizes sempre que o elemento não-nulo de um AUNF for calculado, nem mesmo realizar todas as multiplicações novamente.

A função nextElem retorna um elemento não-nulo de uma determinada matriz, ou zero caso já tenha retornado todos.

Se todos os elementos de uma matriz já foram utilizados, o algoritmo verifica se esta é a primeira matriz, caso seja, retorna zero sinalizando que não existe mais AUNF.

Caso não seja a primeira matriz, o algoritmo retorna para a matriz anterior para pegar o próximo elemento desta matriz e então prossegue o cálculo normalmente.

Calcula o elemento não-nulo de cada AUNF.

Nota-se que o Algoritmo 33 não apresenta de que forma a linha e a coluna do elemento são descobertas, isto porque estas são facilmente obtidas através do uso de uma classe que transforma umíndice composto (que contém oíndice de cada matriz envolvida na operação) noíndice da matriz resultante.

Por exemplo, considerando três matrizes de ordem 2, o índice -010-, que corresponde ao índice -0- na primeira matriz, -1- na segunda e -0- na terceira, equivaleria ao índice -2- na matriz resultante do produto tensorial destas matrizes.

Sendo assim, o algoritmo apenas atualiza o índice composto com as linhas e as colunas dos elementos de cada uma das matrizes envolvidas no cálculo.

Uma vez calculado o elemento não-nulo do AUNF, realiza-se a multiplicação do vetor de probabilidades vProb pelo primeiro Fator Normal Tradicional do AUNF, como mostra a linha 3 do Algoritmo 32.

A implementação desta operação é apresentada pelo Algoritmo 34.

Conforme apresentado na seção 31, o primeiro Fator Normal Tradicional de um AUNF é composto pelo produto tensorial de uma matriz unitária, que contém o elemento não-nulo calculado pelo Algoritmo 33, por uma matriz identidade de ordem nN, onde nN é a ordem da matriz do último evento sincronizante do modelo.

Sendo assim, basta multiplicar nN elementos consecutivos do vetor de probabilidades pelo elemento não-nulo do AUNF, conforme mostra o Algoritmo 34, onde i e j são respectivamente o índice da linha e da coluna do elemento nãonulo da matriz unitária.

Ao final desta operação, o vetor resultante vAux conterá nN elementos não-nulos.

Multiplicação do vetor de probabilidades pelo primeiro Fator Normal Tradicionaldo AUNF Por fim, a última operação que compõe a multiplicação do vetor de probabilidades pela parte sincronizante do gerador infinitesimal é a multiplicação do vetor resultante vAux da operação anterior pelo segundo Fator Normal Tradicional doAUNF, conforme a linha 4 do Algoritmo 32.

O segundo Fator Normal Tradicional de cada AUNF, conforme a seção 31, é composto pelo produto tensorial entre uma matriz identidade de ordem nleftN e a última matriz, onde nleftN é o produto das dimensões de todas as matrizes à esquerda da última matriz do cálculo.

Sabe-se que o produto tensorial de uma matriz identidade por uma matriz M qualquer sempre resulta em uma matriz de blocos diagonais, onde cada bloco é a própria matriz M.

Logo, a matriz resultante do produto tensorial InleftN Q(N) é uma matriz de nleftN blocos diagonais, onde cada bloco é exatamente a matriz Q(N).

Considerando que o vetor vAux possui apenas nN elementos não-nulos e que estes elementos estão posicionados de forma a coincidir exatamente com um bloco diagonal da matriz resultante, basta multiplicarmos estes elementos pela matriz Q(N).

O Algoritmo 35 apresenta os passos necessários para realizar esta operação.

Multiplicação v ×InleftN Q(N).

Primeiramente, o Algoritmo 35 extrai os nN elementos não-nulos do vetor vAux e coloca-os em um vetor menor chamado de zin, onde index é inicializado pelo índice da coluna j correspondente ao elemento não-nulo da matriz unitária do primeiro Fator Normal Tradicional do AUNF.

Em seguida, multiplica-se o vetor zin pela última matriz e por fim acumula os resultados no vetor vRes, que contém previamente os resultados acumulados de todas as operações anteriores.

Note que todo o procedimento é realizado apenas com a utilização do vetor vAux e da matriz Q(N), não sendo necessário gerar a matriz InleftN Q(N) em nenhum momento.

Após realizar cada uma das operações descritas nesta seção, tem-se então o vetor resultado da multiplicação do vetor de probabilidades pela parte sincronizante do descritor Markoviano.

Basta então somar este vetor com o vetor resultado da parte local para enfim encontrar-se o vetor contendo o resultado final da multiplicação vetor-descritor.

A utilização de taxas funcionais é muito comum no formalismo de redes de autômatos estocásticos.

Muitos modelos SANapresentam taxas funcionais com intuito de facilitar e compactar a descrição do sistema no formalismo, uma vez que algumas peculiaridades do sistema podem ser mais facilmente modelados utilizando-se este importante recurso.

Até então, os poucos estudos realizados sobre o algoritmo da técnica Slice não levaram em consideração a utilização de taxas funcionais em modelos SAN.

Acreditando ser fundamental que o algoritmo Slice funcione também para modelos envolvendo taxas funcionais, foi realizada uma análise do algoritmo da técnica Slice com o intuito de descobrir quais partes deveriam ser modificadas ou até mesmo reescritas para suportar o uso de taxas funcionas nos modelos.

Porém, após análise do algoritmo original da técnica Slice, chegou-se a conclusão que o uso de taxas funcionais não modificaria a estrutura geral do algoritmo.

A única parte do algoritmo que necessitaria de uma pequena modificação é a parte responsável por gerar os elementos não-nulos de cada AUNF.

Isto porque as taxas funcionais, como visto na seção 214 do capítulo 2, assumem valores que dependem do estado local dos demais autômatos do modelo, sendo assim necessário sempre reavaliar todos os elementos.

Com isso, a otimização proposta e implementada para o cálculo dos elementos não-nulos de cadaAUNF apresentado no Algoritmo 33 nãoé mais válida.

Pois com o uso de taxas funcionais, é necessário sempre percorrer todas as matrizes para avaliar as possíveis funções, uma vez que a cada mudança de um estado local, todas as outras taxas funcionais do modelo podem ser afetadas.

Portanto, a otimização proposta na seção 322, a qual armazena resultados parciais de multiplicações entre elementos de matrizes de transições sincronizantes, não pode ser utilizada quando o modelo SAN apresentar taxas funcionais.

O Algoritmo 36 apresenta comoé realizado o cálculo dos elementos não-nulos de cada AUNF para modelos SAN que incluem taxas funcionais na sua definição.

Na linha 1, a função nextElemIndex descobre o próximo índice composto (índice de cada matriz envolvida no cálculo) para o elemento a ser calculado.

Em seguida, é atribuída a variável nFator o valor do elemento da primeira matriz.

Depois, este valor é multiplicado pelo elemento da segunda matriz, da terceira e assim sucessivamente até a penúltima matriz do modelo.

Enfim, a variável nFator conterá o próximo fator da AUNF que é então Algoritmo 36.

Calcula o elemento não-nulo de cada AUNF para modelos SAN com taxas funcionais retornado.

Novas alternativas de otimização para o algoritmo da técnica Slice precisam ser estudados no caso do uso de taxas funcionais nos modelosSAN.

Em especial, seria interessante estudar em detalhes o cálculo dos elementos não-nulos dos fatores normais unitários aditivos (AUNF) quando do uso de taxas funcionais, tentando-se encontrar uma forma de otimizar este cálculo, visto que a otimização proposta neste estudo só é válida para modelos com taxas exclusivamente constantes.

O custo computacional da técnica Slice para a parte local de um modelo SAN é igual ao custo da técnica Shuffle para esta mesma parte, uma vez que o número de multiplicações em ponto-flutuante é o mesmo, o que difere uma da outra é apenas a forma como o cálculo é realizado.

Portanto, considerando N o número de autômatos do modelo SAN, ni a dimensão da i-ésima matriz e nzi o número de elementos não-nulos da matriz i.

O custo computacional para a parte sincronizante do modelo depende do custo necessário para multiplicar um vetor de probabilidades p por um fator normal unitário aditivo, o qual é representado pela expressão 32, onde nN e nzN são respectivamente a dimensão e o número de elementos não-nulos da última matriz do termo.

Na expressão acima temos (N2) multiplicações entre elementos das N1 matrizes envolvidas.

Além disto, como para cada AUNF são gerados dois fatores normais tradicionais, para o primeiro fator normal temos nN multiplicações pelo vetor p, e para o segundo, nzN multiplicações.

Sabendo-se que o número de fatores normais unitários aditivos a tratar é dado por todas as combinações de elementos não-nulos das N1 matrizes iniciais, tem-se como custo computacional total para a parte sincronizante.

Portanto, o custo computacional total da técnica Slice é a soma dos custos da parte local e sincronizante do modelo SAN.

Para demonstrar o quanto a técnica Slice pode contribuir para a resolução de modelos SAN, este capítulo apresenta uma análise do custo computacional e de resultados práticos obtidos de dois exemplos de modelos SAN.

Com intuito de fazer uma análise completa do desempenho do algoritmo da técnica Slice, dois exemplos de modelos SAN com diferentes características foram criados.

Além disso, para os testes práticos, diferentes valores foram atribuídos para as taxas dos eventos locais e sincronizantes dos modelos.

Primeiramente, todas as taxas dos eventos dos modelos foram definidas com valores constantes, em seguida, a maioria das taxas receberam valores funcionais, possibilitando assim uma análise do comportamento da técnica Slice com e sem taxas funcionais, uma vez que a avaliação das taxas funcionais pode gerar um custo relevante em termos de tempo de execução.

Apresentam os autômatos referentes aos exemplos de modelo SAN utilizados na análise numérica, ao passo que descrevem respectivamente os eventos destes modelos.

Observa-se nestas tabelas que as taxas são definidas por variáveis, pois como dito anteriormente, estas taxas recebem diferentes valores para cada caso de teste.

Como resultado da análise apresentada neste capítulo pretende-se obter o desempenho da técnica Slice sem e com otimizações.

Em especial duas otimizações foram testadas, a otimização da diagonal, já estudada detalhadamente em trabalhos anteriores, e a otimização na geração dos fatores, a qual é proposta neste trabalho para modelos com taxas exclusivamente constantes.

Além disso, é realizada uma comparação entre os resultados da técnica Slice e os resultados da tradicional técnica Shuffle.

Afinal, um dos objetivos da técnica Slice é apresentar uma forma mais eficiente de resolver modelos SAN em relação as demais técnicas existentes.

Antes mesmo de qualquer implementação do algoritmo da técnica Slice, é possível verificar na teoria qual seria o seu custo computacional.

Utilizando-se da fórmula do custo computacional da técnica Slice, facilmente pode-se calcular o número de multiplicações em ponto-flutuante necessárias para realizar uma iteração da resolução de modelos SAN.

Essa informação é determinante para avaliar na teoria o desempenho de uma técnica, uma vez que as multiplicações em ponto-flutuante são as principais operações realizadas neste processo.

Portanto, sabendo-se o número de multiplicações em ponto-flutuante necessárias para resolver um modelo SAN, tem-se então uma noção do tempo de processamento necessário para a resolução do modelo.

Nesta seção, serão considerados o custo computacional da técnica Shuffle, da técnica Slice, e também do algoritmo da técnica Slice com a otimização na geração dos fatores.

Além disso, estes custos serão calculados de duas formas, a primeira sem considerar uma otimização de pré-cálculo da diagonal e a segunda considerando esta otimização.

A otimização do pré-cálculo da diagonal, ou simplesmente otimização da diagonal, consiste em calcular e armazenar previamente todos os elementos da diagonal principal do descritor do modelo SAN, desconsiderando assim os elementos da diagonal principal das matrizes locais e todas as matrizes negativas dos eventos sincronizantes do modelo.

Com isso, diminui-se o número de multiplicações em cada iteração da resolução do modelo SAN.

Por outro lado, o custo em memória para armazenar a diagonal principal do descritor pode ser bastante considerável dependendo do tamanho do modelo SAN em questão, o qual será abordado na análise dos resultados práticos.

Observando as fórmulas do custo computacional da técnica Shuffle e Slice, percebe-se que o custo para realizar os cálculos da parte local de um modelo SAN é igual para as duas técnicas.

Isto ocorre pois a parte local dos modelos é representada através de uma soma tensorial, a qual é reescrita em um somatório de produtos tensoriais envolvendo inúmeras matrizes identidades.

Por conseqüência, a grande quantidade de matrizes identidades envolvidas no cálculo, acaba anulando a vantagem em utilizar-se a técnica Slice, uma vez que diversas multiplicações se tornam desnecessárias.

Analisando-se mais detalhadamente o cálculo da parte local, percebe-se que este nada mais é do que a multiplicação de elementos de uma dada matriz do modelo por diversos elementos do vetor de probabilidades, os quais dependem da localização da matriz do modelo no produto tensorial com as matrizes identidades.

Ou seja, a multiplicação do vetor de probabilidades por um fator normal.

Este processo é exatamente o foco da técnica Shuffle, como visto na seção 241.

Por isso, pode-se concluir que na teoria, o cálculo da parte local é realizado de forma mais eficiente pela técnica Shuffle, pois ao contrário desta, a técnica Slice não se preocupa com o custo necessário para descobrir os elementos do vetor ao qual cada elemento das matrizes do modelo devem ser multiplicados.

Por outro lado, a parte local do algoritmo da técnica Slice, assim como a parte sincronizante, é mais flexível a implementações paralelas, pois a multiplicação do vetor de probabilidades pelas matrizes do modelo é realizada separadamente para cada elemento das matrizes, enquanto que na técnica Shuffle esta operação é realizada utilizando-se de uma vez só todos os elementos de cada matriz do modelo SAN.

Sendo assim, quando se tratar de uma implementação seqüencial, sugere-se utilizar a técnica Shuffle para o cálculo da parte local do modelo, enquanto que para implementações paralelas, a técnica Slice mostra-se mais adequada.

Nesta seção serão apresentados o custo computacional para as técnicas Shuffle e Slice sem considerar a otimização da diagonal.

Ou seja, fazem parte do cálculo todos os elementos diagonais das matrizes locais dos modelos, assim como todas as matrizes negativas dos eventos sincronizantes.

Sabendo-se que N é o número total de autômatos do modelo, E é o número de eventos sincronizantes, ni é o número de estados do autômato i e que nzi é o número de transições que o autômato i possui para cada evento local e sincronizante do modelo, pode-se facilmente calcular o custo computacional para cada uma das técnicas.

Primeiramente, vejamos para o exemplo apresentado quais seriam os valores para cada uma das variáveis das fórmulas do custo computacional das técnicas, considerando a parte local e sincronizante do modelo SAN.

Sabe-se que para este exemplo, o número de autômatos N é 6 e o total de eventos sincronizantes E é 9.

Apresenta ainda a definição das variáveis ni e nzi para a parte local do primeiro exemplo de modelo SAN.

Definição das variáveis para a parte local do primeiro modelo SAN.

São apresentadas as definições das variáveis ni e nzi para cada evento sincronizante do modelo, referindo-se a parte sincronizante do primeiro exemplo de modelo SAN.

Como nenhum autômato deste modelo apresenta duas ou mais transições saindo de um único estado para outros utilizando o mesmo evento sincronizante, pode-se considerar os valores apresentados para as matrizes positivas e negativas do modelo.

Considerando a fórmula do custo computacional para a técnica Shuffle, o primeiro exemplo de modelo SAN apresenta o seguinte custo computacional.

Definição das variáveis para a parte sincronizante positiva e negativa do primeiro modelo SAN.

Portanto, utilizando-se a técnica Shuffle são necessárias 171992 multiplicações em ponto-flutuante para cada iteração da resolução deste primeiro exemplo de modelo SAN.

Desta forma, tem-se uma noção do tempo de processamento necessário para realizar este cálculo.

Sabendo que nN e nzN são respectivamente a ordem e o número de elementos não-nulos da matriz do último autômato do modelo SAN, no caso o autômato A(6).

Portanto, se a técnica Slice for utilizada para resolver este exemplo de modelo SAN, serão necessárias apenas 20160 multiplicações em ponto-flutuante para cada iteração, ao passo que para a técnica Shuffle seriam necessárias 171992 destas operações.

Observa-se que para este segundo exemplo de modelo SAN, o número de autômatos N é 6 e o total de eventos sincronizantes E é 8.

Apresentam ainda as definições das variáveis ni e nzi para a parte local, sincronizante positiva e sincronizante negativa respectivamente para este modelo SAN.

Portanto, utilizando-se a técnica Shuffle para resolver o segundo exemplo de modelo SAN, são necessárias 187968 multiplicações em ponto-flutuante para cada iteração da resolução deste modelo.

Para este mesmo exemplo, pode-se calcular também o provável custo computacional para a técnica Slice, o qual seria.

Portanto, se utilizarmos a técnica Slice para resolver este mesmo exemplo de modelo SAN, serão necessárias 49344 multiplicações em ponto-flutuante para cada iteração da resolução deste modelo.

Como visto anteriormente, no capítulo 3, para modelos com taxas exclusivamente constantes é possível realizar uma otimização no cálculo da parte sincronizante dos modelos SAN.

A idéia é otimizar o processo de descoberta dos fatores normais unitários aditivos, reaproveitando as multiplicações já realizadas entre os elementos das matrizes do termo calculado.

A fórmula do custo computacional original para a parte sincronizante da técnica Slice considera que as multiplicações entre os elementos das matrizes são realizas toda vez para cada fator normal unitário aditivo.

Analisando novamente esta equação, nota-se que para cada AUNF, representadas pelo termo, são contabilizadas N2 multiplicações.

Custo computacional original para parte sincronizante.

Implementando-se a otimização proposta, não se fazem necessárias tantas multiplicações para descobrir os fatores normais unitários aditivos.

A lógica é simples, se é preciso realizar diversas multiplicações entre três ou mais números, variando-se um número de cada vez, pode-se armazenar uma parte do cálculo para ser reaproveitada, evitando assim repetições de multiplicações já realizadas.

Sem otimização seriam necessária 12 multiplicações.

Com otimização seriam necessária apenas 7 multiplicações.

Neste pequeno exemplo já pode-se ter uma noção da quantidade de multiplicações que seriam evitadas pela otimização do cálculo.

Percebe-se que os resultados intermediários 12, 24 e 72 são armazenados e reutilizados para os próximos cálculos, evitando assim uma série de multiplicações desnecessárias.

Logo, considerando essa otimização, pode-se reescrever a fórmula do custo computacional para a parte sincronizante da técnica Slice da seguinte forma.

O custo computacional para as técnicas Shuffle e Slice apresentado nesta seção leva em consideração a otimização da diagonal.

Ou seja, são eliminados do cálculo todos os elementos diagonais das matrizes locais dos modelos, assim como todas as matrizes negativas dos eventos sincronizantes.

Dessa forma, o número de multiplicações em ponto-flutuante certamente será reduzido.

Vejamos a seguir como seriam os custos computacionais para os dois exemplos estudados.

Tendo realizado o cálculo do custo computacional sem a otimização da diagonal, torna-se fácil de descobrir o custo considerando esta otimização.

Basta refazer os cálculos da parte local do modelo, uma vez que os valores de nzi para as matrizes locais sofrem modificações, somar com o resultado da parte sincronizante positiva obtido anteriormente, e por fim desconsiderar o cálculo da parte sincronizante negativa do modelo SAN.

Definição das variáveis para a parte local do primeiro modelo SAN.

Que apresenta a definição das variáveis ni e nzi para a parte local do primeiro exemplo de modelo SAN com a otimização da diagonal.

Portanto, observa-se que com a otimização da diagonal, o número de multiplicações em ponto-flutuante para cada iteração é reduzido de forma significativa, tanto para a técnica Shuffle quanto para a técnica Slice.

Assim como realizado para o exemplo anterior, para descobrir o custo computacional considerando a otimização da diagonal, deve-se recalcular apenas a parte local do segundo modelo SAN de exemplo.

Definição das variáveis para a parte local do segundo modelo SAN Considerando que apresenta as definições das variáveis ni e nzi para a parte local do modelo com a otimização da diagonal.

Portanto, mais uma vez verifica-se que com a otimização da diagonal, o número de multiplicações em ponto-flutuante para cada iteração diminui significativamente para ambas as técnicas.

Considerando que a otimização dos fatores proposta para o algoritmo da técnica Slice refere-se somente à parte sincronizante do modelo, e que a otimização da diagonal não modifica o cálculo da parte sincronizante positiva, pode-se utilizar estas duas otimizações em conjunto, obtendo um custo computacional de 8926 e 18800 para o primeiro e segundo exemplos de modelo SAN respectivamente.

Após calcular o custo computacional das técnicas Shuffle e Slice para os dois exemplos de modelo SAN apresentados, é possível fazer uma análise sobre os resultados obtidos.

Apresenta os resultados do custo computacional para calcular uma iteração da resolução dos exemplos 1 e 2 através das técnicas Shuffle e Slice.

O custo computacional é representado pelo número de multiplicações em ponto-flutuante necessárias para realizar o cálculo.

Custo Computacional para os modelos SAN de exemplo.

Analisando os custos computacionais das técnicas Slice e Shuffle para os dois modelos SAN apresentados nesta seção, percebe-se claramente na teoria que a técnica Slice apresenta um desempenho bastante superior a técnica Shuffle na resolução destes modelos, seja utilizando-se a otimização da diagonal ou não.

Sem a otimização da diagonal a técnica Slice obteve um custo computacional mais de 8,5 vezes menor para o exemplo 1 e de aproximadamente 3,8 vezes menor para o exemplo 2.

Considerando a otimização da diagonal, a técnica Slice mantém uma boa vantagem em relação a Shuffle, porém diminui um pouco.

Para o exemplo 1, a técnica Slice apresenta um custo computacional quase 8,4 vezes melhor que a Shuffle, enquanto que para o exemplo 2 essa relação é de aproximadamente 3,56.

Pode-se atribuir esta pequena diferença da vantagem da técnica Slice sobre a Shuffle, quando utiliza-se a otimização da diagonal, ao fato de que com esta otimização não são contabilizadas as multiplicações da parte sincronizante negativa do modelo, a qual a técnica Slice levaria vantagem em relação a técnica Shuffle.

Porém, percebe-se que para ambas as técnicas a otimização da diagonal reduz consideravelmente o custo computacional, demonstrando assim que a otimização da diagonal também é válida para a técnica Slice.

Além disso, utilizando-se a otimização na geração dos fatores para modelos com taxas exclusivamente constantes, observa-se que o custo computacional da técnica Slice tornou-se ainda melhor, apresentando uma redução no número de multiplicações de aproximadamente 13% e 29% para os exemplos 1 e 2 respectivamente.

O que aumenta ainda mais a vantagem da técnica Slice em relação a Shuffle, chegando a apresentar um custo computacional quase 10 vezes menor para o primeiro exemplo e acima de 5 vezes menor para o segundo exemplo.

Comprovando-se assim, que a otimização proposta para a técnica Slice reduz significativamente o número de multiplicações em ponto-flutuante necessárias para realizar o cálculo de cada iteração da resolução do modelo SAN.

Considerando que para resolver um modelo SAN normalmente são necessárias inúmeras iterações e que os custos computacionais apresentados são para o cálculo de apenas uma iteração da resolução dos modelos SAN, pode-se imaginar o quanto seria o ganho total no desempenho para a resolução completa de um modelo SAN.

A análise do custo computacional é importante para fundamentar os estudos realizados e também para encorajar os pesquisadores a continuar os estudos caso estes resultados teóricos sejam positivos.

Assim, considerando que os resultados da análise do custo computacional da técnica Slice foram muito significativos, torna-se válida a realização de uma análise sobre resultados práticos desta técnica.

Realizando essa análise será possível verificar se os resultados teóricos se confirmam na prática, provando assim o bom desempenho da técnica Slice.

Para realizar uma análise sobre resultados práticos foi preciso implementar o algoritmo da técnica Slice, uma vez que nenhuma implementação deste algoritmo havia sido realizada até então.

Logo, uma nova versão da ferramenta PEPS foi desenvolvida incluindo o algoritmo da técnica Slice.

Dessa forma, foi possível realizar testes práticos com as duas técnicas, pois o algoritmo Shuffle já havia sido implementado nesta ferramenta.

É importante salientar que a análise realizada neste trabalho é exclusivamente numérica e baseou-se apenas em algoritmos seqüenciais para ambas técnicas.

Ou seja, não foram realizadas implementações paralelas e nem otimizações algorítmicas, como a utilização de pacotes de softwares para otimizar determinadas funções.

A implementação da técnica Slice foi realizada utilizando-se o algoritmo Slice para a parte sincronizante e o algoritmo Shuffle para o cálculo da parte local dos modelos SAN, uma vez que na teoria para implementações seqüenciais este apresenta-se mais adequado para esta parte.

Porém, em momento algum houve influência nos resultados dos testes realizados, pois a principal diferença entre estas duas técnicas está exatamente na parte sincronizante dos modelos SAN.

Para obter resultados práticos através da ferramenta PEPS, utilizou-se novamente os dois exemplos de modelos SAN apresentados.

Os cálculos foram realizados sobre o sistema operacional Linux em um computador Pentium IV Xeon 2,2 GHz com 512 MB de memória cache e 4 GB de memória principal.

Além disso, com o intuito de obter resultados de tempo mais precisos, foram executadas dez vezes cada caso do teste, com aproximadamente 1000 iterações, e considerado como resultado final a média dos tempos obtidos.

Logo, todos resultados apresentados nas tabelas e gráficos das próximas seções são referentes ao tempo de execução de 1000 iterações da resolução do modelo SAN.

Para distinguir os resultados da técnica Slice sem e com a otimização da diagonal nas tabelas e gráficos apresentados nesta seção, estabeleceu-se que a legenda Slice-SD representa resultados da técnica Slice sem a otimização da diagonal, ao passo que a legenda Slice-CD representa os resultados com esta otimização.

Nesta seção serão apresentados e analisados alguns resultados práticos para a técnica Slice sem considerar a otimização da diagonal.

Além disso, são apresentados os resultados para a técnica Shuffle, porém esta utilizando a otimização da diagonal, uma vez que não existe a implementação desta técnica sem esta otimização.

Sendo assim, torna-se necessário apresentar também o total de memória exigida por cada uma das técnicas, para então possibilitar uma análise do custo/benefício de cada técnica.

Primeiramente foram realizados testes com os dois exemplos de modelos SAN contendo apenas taxas constantes, ou seja, nenhuma taxa dos modelos foi definida através de função.

Dessa forma, será possível analisar com maior precisão o desempenho das técnicas, uma vez que o tempo que se gastaria para avaliar funções não é contabilizado.

Apresenta o gráfico com os tempos de execução obtidos através da ferramenta PEPS para as técnicas Shuffle e Slice para os dois exemplos SAN com taxas exclusivamente constantes, além da memória consumida por cada uma das técnicas.

Tempo e memória para a execução de modelos com taxas constantes.

Percebe-se que a técnica Slice mesmo sem utilizar a otimização da diagonal apresenta um melhor desempenho que a técnica Shuffle, tanto para o exemplo 1 quanto para o exemplo 2.

Além disso, o consumo de memória foi bastante inferior na técnica Slice, o que já se previa pelo fato de esta não estar utilizando a otimização da diagonal.

Nota-se também, que a técnica Slice obteve um desempenho melhor para o segundo exemplo, o que nos leva a crer que as características deste exemplo sejam mais favoráveis ao algoritmo da técnica Slice.

Ainda, é possível verificar o desempenho da técnica Slice quando utilizada a otimização na geração dos fatores normais unitários aditivos.

Percebe-se que para ambos os exemplos esta otimização se mostra válida, uma vez que obteve-se uma redução no tempo de execução de aproximadamente 27% e 18% para os exemplos 1 e 2 respectivamente.

Uma vez analisados os desempenhos das técnicas para modelos SAN com taxas exclusivamente constantes, é importante verificar também o comportamento destas técnicas quando os modelosSANpossuem taxas funcionais.

Isto porque a maioria dos sistemas modelados emSAN exige esse tipo de taxa de transição.

Apresenta o gráfico com o tempo e a memória exigida para a execução das técnicas Shuffle e Slice para os exemplos de modelos SAN com diversas taxas funcionais.

Tempo e memória para a execução de modelos com taxas funcionais.

Os resultados apresentados demonstram que o custo para avaliar taxas funcionais ainda é bastante elevado, principalmente para a técnica Slice.

Percebe-se claramente isto, pois para modelos com taxas funcionais o seu desempenho diminuiu significativamente, tornou-se menos eficiente que a técnica Shuffle.

De qualquer forma, os resultados para a técnica Slice são ainda assim bastante interessantes, uma vez que esta não fez uso da otimização da diagonal e também por se tratar da sua primeira implementação.

Além disso, o estudo da otimização dos fatores pode ser aprofundado, de forma a abranger também modelos com taxas funcionais, o que certamente iria melhorar consideravelmente o desempenho da técnica nestas situações.

Nesta seção serão apresentados e analisados alguns resultados práticos para as técnicas Shuffle e Slice para os modelos SAN de exemplo, considerando-se a utilização da otimização da diagonal para ambas as técnicas.

Apresenta o gráfico com os tempos de execução obtidos através da ferramenta PEPS para as técnicas Shuffle e Slice para os dois exemplos SAN com taxas exclusivamente constantes.

Tempo de execução para modelos com taxas constantes.

É possível analisar o desempenho das técnicas Shuffle e Slice quando utilizada a otimização da diagonal.

Percebe-se que para os dois exemplos a técnica Slice apresenta um menor tempo de execução, chegando a ser menos da metade do tempo gasto pela técnica Shuffle para ambos exemplos.

Isso demonstra que para resolver estes exemplos a técnica Slice certamente seria a melhor opção.

Além disso, mais uma vez a otimização proposta para o processo de geração dos fatores apresentou resultados significativos.

Apresenta o gráfico com os tempos de execução das técnicas Shuffle e Slice para os exemplos de modelos SAN com diversas taxas funcionais.

Tempo de execução para modelos com taxas funcionais Apresenta resultados bastante animadores em relação a resolução de modelos SAN com taxas funcionais através da técnica Slice, uma vez que mesmo sendo a primeira implementação desta técnica, os resultados foram consideravelmente melhores do que os obtidos pela tradicional técnica Shuffle.

Aotimizaçãoda diagonalérealmentebastante interessante quando setem disponívelmemória suficiente para armazenar a diagonal do modelo sem a necessidade de realizar swap.

Porém, se isso não ocorrer, a otimização perde sua validade, podendo até piorar o desempenho da técnica utilizada.

Considerando que a técnica Slice apresenta um custo computacional significativamente menor que o custo apresentado pela técnica Shuffle e que os resultados práticos comprovam um melhor desempenho para a técnica Slice, pode-se não ser interessante utilizar a otimização da diagonal para esta técnica, pois mesmo aumentando um pouco o custo computacional, o ganho na utilização da memória seria compensador.

Esta decisão deveria ser tomada caso a caso, dependendo do tamanho do sistema modelado.

Com intuito de demonstrar que para modelos maiores a otimização da diagonal pode não ser interessante, criou-se um exemplo de modelo SAN com 12 autômatos com o número de estados variando entre 2 a 6, totalizando em 10616832 o espaço de estados do modelo.

Calculou-se então o tempo necessário para executar cada iteração deste modelo utilizando-se a técnica Shuffle com a otimização da diagonal e a técnica Slice sem esta otimização.

Para os cálculos foi utilizado um computador com um processador Pentium IV 2,8 GHz, 256 MB de memória cache e 512 MB de memória principal, sobre o sistema operacional Linux.

Apresenta uma tabela com o tempo de execução para apenas uma iteração da resolução deste modelo, assim como a memória consumida por cada técnica.

Além disso, esta figura apresenta também um gráfico comparando os tempos de execução.

Percebe-se que para este modelo SAN, a implementação da técnica Shuffle com a otimização da diagonal necessitou de um grande volume de memória, tornando necessário a realização de swap, o que acabou influenciando diretamente no seu desempenho.

Por este motivo, a técnica Slice sem a otimização da diagonal apresentou um desempenho bastante superior.

Percebe-se ainda que utilizando a versão otimizada da técnica Slice, a qual realiza menos multiplicações para calcular cada fator normal unitário aditivo, o desempenho é ainda melhor, chegando a reduzir em aproximadamente 58% o tempo de execução de cada iteração.

Alguns estudos já demonstravam que a ordem dos autômatos do modelo SAN influencia o desempenho da técnica Slice.

Na verdade, o que realmente influencia a técnica Slice, assim como a própria técnica Shuffle, é a ordem das matrizes de cada termo do cálculo da iteração da resolução do modelo SAN.

A técnica Shuffle, por existir a mais tempo e por já ter sido bastante estudada, apresenta uma implementação onde as matrizes são permutadas de forma a realizar o cálculo de cada termo com a melhor disposição possível destas matrizes.

O algoritmo desta técnica foi implementado pela primeira vez em 1987 por Plateau, e revisado três vezes desde então.

Em 1990, Atif realizou a primeira revisão, em 1994 e 1997 foi a vez de Fernandes dar a sua contribuição revisando novamente o algoritmo da técnica Shuffle.

Isso demonstra o quanto a técnica Shuffle já foi melhorada ao longo do tempo.

Por outro lado, a técnica Slice está apenas na sua primeira versão, implementada durante a execução deste trabalho.

Apesar da implementação do algoritmo desta técnica ter sido realizada de forma cuidadosa, buscando sempre o melhor desempenho, certamente novas versões deste algoritmo serão implementadas no futuro.

Até porque, esta primeira versão da técnica Slice não inclui permutações entre matrizes o que resultaria em um melhor desempenho da técnica.

Isso nem poderia ser realizado, pois o estudo da melhor ordem das matrizes para a técnica Slice ainda precisa ser concluído.

Com o intuito de demonstrar como a ordem dos autômatos ou das matrizes do modelo influenciam diretamente no desempenho da técnica Slice, foram testados diversas variações da ordem dos autômatos dos exemplos 1 e 2.

Para estes testes considerou-se apenas o algoritmo da técnica Slice utilizando-se a otimização da diagonal, mas sem levar em consideração a otimização dos fatores normais unitários aditivos.

Apresentam diversas variações na ordem dos autômatos dos dois modelos SAN de exemplo, assim como o tempo necessário para executar 1000 iterações para cada nova seqüência.

Percebe-se que a ordem dos autômatos nos modelos SAN realmente influencia o desempenho da técnica Slice.

Isso já era esperado, uma vez que o número de fatores normais unitários aditivos depende diretamente da ordem das matrizes nos termos do cálculo.

Ou seja, uma determinada seqüência de autômatos pode gerar mais fatores do que outra, e conseqüentemente exigir mais multiplicações em ponto-flutuante, o que certamente consumiria mais tempo para execução.

Nota-se que os resultados são muito semelhantes para as seqüências que apresentam o mesmo autômato no final.

Isso se deve pois a ordem dos N1 primeiros autômatos do modelo não influencia o número de fatores normais unitários aditivos.

Por outro lado, a troca do último autômato do modelo modifica as matrizes envolvidas no cálculo dos fatores, o que pode gerar mais ou menos fatores.

Dessa forma, parece correto dizer que para a técnica Slice o que importa é qual será o último autômato do modelo.

Porém, se considerarmos a otimização na geração dos fatores, passa a ser importante também a ordem dos N1 primeiros autômatos, pois dependendo desta ordem a otimização dos fatores pode ser mais efetiva.

Além disso, se pensarmos na ordem das matrizes de cada termo individualmente e não simplesmente na ordem dos autômatos do modelo SAN, imagina-se que resultados ainda melhores poderão ser alcançados.

Portanto, torna-se bastante interessante a realização de um estudo detalhado para descobrir a melhor ordem das matrizes para cada termo do cálculo da técnica Slice.

Assim, como realizado para a técnica Shuffle, será possível implementar uma nova versão da técnica Slice incorporando mais esta otimização, o que certamente resultará em um desempenho ainda melhor.

Reúne os principais resultados apresentados ao longo deste capítulo, facilitando assim uma análise completa do desempenho da técnica Slice.

Percebe-se que mesmo sem a otimização da diagonal a técnica Slice apresenta melhores resultados que a tradicional técnica Shuffle.

Ou seja, com a técnica Slice é possível resolver modelos SAN em menos tempo e consumindo menos memória.

Além disso, comparando os resultados obtidos, fica claro que a otimização na geração dos fatores obteve sucesso, diminuindo consideravelmente o tempo necessário para a execução de cada iteração da resolução do modelo SAN.

Resultados finais de tempo e memória.

Infelizmente muitos sistemas em funcionamento hoje em dia nunca tiveram o seu desempenho avaliado de forma consistente, entenda-se por sistemas não só programas de computador, mas toda e qualquer atividade que envolva dados de entrada e de saída.

Por exemplo, o funcionamento de um posto de gasolina pode ser considerado um sistema, onde os clientes e o lucro seriam os principais dados deste sistema.

Neste caso, diversas avaliações sobre o seu desempenho poderiam ser realizadas, desde a melhor forma de disponibilizar as bombas de gasolina, até o número de funcionários necessário e a capacidade dos tanques de combustível, tudo isso dependendo do número de clientes do posto e visando sempre a satisfação dos clientes e o lucro do proprietário.

A precária forma de avaliação de sistemas ou mesmo a falta desta prática vem prejudicando inúmeras empresas no mercado acirrado dos negócios de hoje em dia.

Diversas empresas têm apresentado prejuízos e até mesmo encerrando suas atividades muitas vezes por falta de um planejamento e avaliação adequados do seu negócio.

Isso se deve pois até então não existe uma forma consistente e de baixo custo para realizar uma boa avaliação dos sistemas.

Atualmente, para realizar uma completa avaliação de um sistema razoavelmente grande, ao qual envolve diversos fatores e peculiaridades, exigiria-se um enorme custo computacional, muitas vezes tornando-se inviável de ser realizada.

Por este motivo, os estudos na área de avaliação de desempenho de sistemas não podem parar, pelo contrário, deve-se investir cada vez mais nesta área, pois tende a ser uma área bastante promissora.

Com a definição do formalismo de Redes de Autômatos Estocásticos (SAN), a modelagem de sistemas tornou-se mais compacta e modular, facilitando assim a modelagem de sistemas maiores e com um maior nível de detalhes.

Porém, mesmo com o formalismo SAN, a resolução de alguns sistemas ainda exige um alto custo computacional, uma vez que o espaço de estados destes modelos pode ser muito grande.

Diversas técnicas para resolução de modelos SAN vêm sendo estudadas ao longo do tempo, e muitos resultados positivos já foram encontrados, como a criação e aperfeiçoamento da tradicional técnica Shuffle, a qual tornou-se inclusive uma referência mundial no assunto.

Porém, novas técnicas têm se mostrado muito interessantes e apresentado ótimos resultados, como é o caso da técnica Slice estudada em detalhes neste trabalho.

No decorrer deste estudo foi realizada uma análise profunda da técnica Slice, com o intuito de explorar mais os seus pontos fortes e buscar melhorias para os seus pontos que apresentavam um menor desempenho.

Para tanto, implementou-se a primeira versão desta técnica, tirando-a definitivamente do papel, e possibilitando pela primeira vez uma análise de resultados práticos do seu desempenho para resolução de modelos SAN.

Além disso, estendeu-se o algoritmo da técnica Slice para abranger também modelos com taxas funcionais, o que até então não tinha sido estudado nem mesmo na teoria.

Por fim, ainda foi proposta e implementada uma otimização em um dos principais pontos do algoritmo desta técnica, a geração dos fatores normais unitários aditivos.

Após implementar a técnica Slice, realizou-se então uma série de testes em diversas situações, visando analisar o desempenho da técnica na resolução de modelos SAN.

Com os resultados dos testes realizados foi possível constatar que a técnica Slice é realmente uma ótima alternativa para a resolução de sistemas modelados pelo formalismo SAN, uma vez que seus resultados superaram na maior parte das vezes a tradicional técnica Shuffle.

Além disso, o fato da técnica Slice apresentar uma maior flexibilidade para implementações paralelas certamente contribuirá para o seu reconhecimento nesta área de pesquisa.

Ainda como resultados adicionais deste estudo, surgem ao menos cinco possibilidades de trabalhos futuros.

Considerando que a análise realizada neste estudo teve como foco principal o número de multiplicações em ponto-flutuante necessárias para os cálculos e não a forma com que o algoritmo foi implementado, pode-se imaginar como um trabalho futuro uma análise algorítmica desta técnica, visando melhorar sua implementação.

Seguindo a otimização realizada neste trabalho para a geração dos fatores, poderia-se estudar no futuro uma forma de estender esta otimização para modelos com taxas funcionais, uma vez que neste estudo esta foi limitada a modelos com taxas exclusivamente constantes.

Ainda, um estudo profundo para descobrir a melhor ordem das matrizes dos termos do cálculo poderia contribuir muito para o desempenho da técnica Slice, como visto na análise de resultados práticos apresentados neste trabalho.

Além disso, um outro trabalho futuro poderia estudar e propor um algoritmo híbrido, o qual utilizaria de forma eficiente as técnicas Shuffle e Slice para cada termo do cálculo da resolução do modelo SAN, levando-se em consideração as melhores situações para cada técnica.

Por fim, ainda seria muito interessante a implementação de uma versão paralela do algoritmo da técnica Slice, pois dessa forma certamente seria possível resolver sistemas com maiores espaços de estados.

Enfim, pode-se afirmar que este trabalho contribuiu muito para a evolução da técnica Slice e conseqüentemente para a área de avaliação de desempenho de sistemas.

Pois, a partir de agora será possível resolver inúmeros sistemas com esta técnica e assim seguir os estudos para quem sabe um dia a técnica Slice tornar-se a nova referência mundial para resolução de modelos SAN.

São apresentados nas seções a seguir os conceitos de álgebra Tensorial Clássica e de álgebra Tensorial Generalizada, necessários para o entendimento das SAN.

A primeira seção introduz os conceitos de álgebra Tensorial Clássica (ATC) e cita suas principais propriedades.

Na segunda seção introduz-se a álgebra Tensorial Generalizada (ATG) e cita as propriedades de interesse para o formalismo de SAN1.

A álgebra Tensorial Clássica é definida por dois operadores matriciais, produto tensorial (também chamado de Produto de Kronecker), soma tensorial.

A notação utilizada na definição dos operadores da ATC e de suas propriedades é introduzida à medida em que se tornar necessária.

Sejam N conjunto dos números naturais, R conjunto dos números reais, [ab] subconjunto de N que contém todos os valores de a até b (a e b incluídos), [a,b] subconjunto de R que contém todos os valores de a até b (a e b incluídos), ]a,b] subconjunto de R que contém todos os valores de a até b (a excluído, b incluído).

O produto tensorial de duas matrizes A e B, de dimensões (a1 × a2) e (ß1 × ß2), respectivamente, é uma matriz de dimensões (a1ß1 × a2ß2).

Essa matriz pode ser vista como uma matriz constituída de a1 × a2 blocos, cada um de dimensão ß1 × ß2.

A definição de cada um 1 Uma discussão mais abrangente sobre ATC e ATG, com demonstração das propriedades não-triviais.

Dos elementos da matriz resultante é feita levando-se em conta a qual bloco o referido elemento pertence e a sua posição interna dentro desse bloco.

Sejam A matriz A, A B produto tensorial das matrizes A e B, A × B produto (convencional) das matrizes A e B, aij elemento da i-ésima linha e j-ésima coluna da matriz A, a[ik][jl] elemento da k-ésima linha do i-ésimo bloco horizontal e da l-ésima coluna do j-ésimo bloco vertical da matriz A.

Neste exemplo, o elemento c47 (c47 = a22b13) encontra-se dentro do bloco (2,2) e sua posição interna neste bloco é (1,3).

O produto tensorial C = A B é definido algebricamente pela atribuição do valor aijbkl ao elemento de posição (k,l) do bloco (i,j).

Essa representação dos elementos da matriz correspondente ao produto tensorial induz uma relação de ordem sobre os elementos c[ik][jl], que é a ordem lexicográfica das duplas de índice ([ik][jl]).

Um caso particular de produto tensorial é o produto tensorial de uma matriz quadrada por uma matriz identidade.

Esse produto tensorial é denominado fator normal.

Com uma matriz quadrada A e uma matriz identidade (de dimensão n) In, dois fatores normais são possíveis (A In) e (In A).

Um caso ainda mais particular de produto tensorial é o produto tensorial de duas matrizes identidade.

O resultadoé uma matriz identidade cuja dimensãoé igual ao produto das dimensões das duas matrizes.

Diferentemente do produto tensorial, queé definido para matrizes quaisquer, a soma tensorial é definida somente para matrizes quadradas.

Sejam A B soma tensorial das matrizes quadradas A e B, A+B soma (convencional) das matrizes A e B, nA dimensão (número de linhas e de colunas) da matriz quadrada A, dij elemento da i-ésima linha e da j-ésima coluna de uma matriz identidade (dij = 1 se i = j e dij = 0 se i negationslash= j).

A soma tensorial de duas matrizes quadradas A e B é definida como a soma (convencional) dos fatores normais das duas matrizes.

A soma tensorial C = A B é definida algebricamente pela atribuição do valor aijdkl+dijbkl ao elemento de posição (k,l) do bloco (i,j).

O operador produto tensorial tem prioridade sobre o operador soma tensorial e os dois operadores tensoriais têm prioridade sobre os operadores tradicionais de multiplicação e adição de matrizes (× e +).

As propriedades da ATC de interesse para as SAN são listadas a seguir.

Associatividade.

Distributividade com relação à soma.

Compatibilidade com a multiplicação.

Compatibilidade com a transposição de matrizes.

Compatibilidade com a inversão de matrizes (se A e B são matrizes inversíveis).

Decomposição em fatores normais.

Distributividade com relação à multiplicação pela matriz identidade.

Comutatividade dos fatores normais.

A álgebra tensorial generalizada é uma extensão da álgebra tensorial clássica.

A diferença fundamental da ATG com relação à ATC é a introdução do conceito de elementos funcionais.

Doravante, uma matriz pode ser composta de elementos constantes (pertencentes a R) ou de elementos funcionais.

Um elemento funcional é uma função real dosíndices de linha de uma ou mais matrizes 2.

Um elemento funcional b é dito dependente da matriz A se algum índice de linha da matriz A pertencer ao conjunto de parâmetros desse elemento funcional.

Por abuso de linguagem, denomina-se parâmetro de um elemento funcional toda matriz da qual o elemento funcional é dependente.

Uma matriz que contém ao menos um elemento funcional dependente da matriz A é dita dependente da matriz A.

Os parâmetros de uma matriz são a união dos parâmetros de todos seus elementos funcionais.

Assim como a ATC, a ATG é definida por dois operadores matriciais, produto tensorial generalizado, soma tensorial generalizada.

A notação definida na seção A1 continua sendo válida para as matrizes constantes (matrizes sem elementos funcionais).

As matrizes com elementos funcionais, denominadas matrizes funcionais, são descritas com o uso da notação seguinte.

Sejam ak índice de linha k da matriz A, A(B,C) matriz funcional A que possui como parâmetros as matrizes B e C, aij(B,C) elemento funcional (i,j) da matriz A(B,C), A(bk,C) matriz funcional A(B,C) na qual oíndice de linha da matriz B já é conhecido e igual a k (essa matriz pode ser considerada dependente da matriz C somente).

O domínio dessa função é Rn e seu contra-domínio é R aij(bk,C) elemento funcional (i,j) da matriz A(bk,C), A(bk,cl) matriz funcional A(B,C) na qual os índices de linha das matrizes B e C já são conhecidos e iguais a k e l respectivamente (uma vez que todos os parâmetros da matriz são conhecidos, pode ser considerada uma matriz constante), aij(bk,cl) elementoconstante (elemento funcional de valordeterminado) (i,j)da matrizA(bk,cl).

O produto tensorial generalizado C = A(B)g B(A) é definido algebricamente pela atribuição do valor aij(bk)bkl(ai) ao elemento c[ik][jl].

A soma tensorial generalizada é definida utilizando-se o produto tensorial generalizado na equação.

Sejam as matrizes A(B) e B(A) utilizadas para descrever o produto tensorial generalizado.

Distributividade do produto tensorial generalizado com relação à soma convencional de matrizes.

Associatividade do produto tensorial generalizado e da soma tensorial generalizada.

Distributividade com relação à multiplicação pela matriz identidade.

Decomposição em fatores normais I.

Decomposição em fatores normais II.

Decomposição em produto tensorial clássico.

Veja a seguir o cálculo completo do Custo Computacional das técnicas Shuffle e Slice, com e sem as otimizações estudadas, para os dois exemplos de modelos SAN apresentados neste trabalho.

Esta seção apresenta os cálculos do Custo Computacional das técnicas Shuffle e Slice desconsiderando a otimização da diagonal.

Para realizar o cálculo do Custo Computacional para o primeiro exemplo de modelo SAN, além das fórmulas do custo computacional da técnica Shuffle e Slice.

Fórmula do custo computacional da técnica Shuffle.

Custo computacional total para a parte local do modelo.

Custo computacional para a parte sincronizante positiva do modelo.

Sabendo que a parte sincronizante negativa deste modelo tem o mesmo custo da parte positiva.

Fórmula do custo computacional da técnica Slice.

Custo computacional total para a parte local do modelo (igual ao Shuffle).

Cálculo do termo (N2) + nN + nzN para o evento sincronizante e8.

Cálculo do termo (N2) + nN + nzN para o evento sincronizante e9.

Cálculo do termo (N2) + nN + nzN para o evento sincronizante e10.

Cálculo do termo (N2) + nN + nzN para o evento sincronizante e11.

Cálculo do termo (N2) + nN + nzN para o evento sincronizante e12.

Cálculo do termo (N2) + nN + nzN para o evento sincronizante e13.

Cálculo do termo (N2) + nN + nzN para o evento sincronizante e14.

Cálculo do termo (N2) + nN + nzN para o evento sincronizante e15.

Cálculo do termo (N2) + nN + nzN para o evento sincronizante e16.

Custo computacional para a parte sincronizante positiva do modelo.

Lembrando que a parte sincronizante positiva e negativa deste modelo possuem o mesmo custo computacional.

Para realizar o cálculo do Custo Computacional para o segundo exemplo de modelo SAN.

Apenas os eventos e7 e e8 possuem valores diferentes para as suas matrizes positivas e negativas, pois nos autômatos A(1) e A(3) existem transições que partem do mesmo estado para outros, tendo estes eventos associados.

Dessa forma, as matrizes negativas destes eventos possuirão menos elementos não-nulos, uma vez que na matriz negativa as taxas destes eventos são somadas e posicionadas na diagonal principal da matriz com sinal negativo, realizando assim o ajuste necessário ao modelo SAN.

Por este motivo, é preciso recalcular o termo para as matrizes negativas destes eventos.

Custo computacional para a parte sincronizante positiva do modelo.

Custo computacional para a parte sincronizante negativa do modelo.

Custo computacional total para a parte sincronizante do modelo.

Fórmula do custo computacional da técnica Slice.

Custo computacional total para a parte local do modelo (igual ao Shuffle).

Cálculo do termo (N2) + nN + nzN para o evento sincronizante e7 (matriz positiva).

Cálculo do termo (N2) + nN + nzN para o evento sincronizante e8 (matriz positiva).

Cálculo do termo (N2) + nN + nzN para o evento sincronizante e9.

Cálculo do termo (N2) + nN + nzN para o evento sincronizante e11.

Cálculo do termo (N2) + nN + nzN para o evento sincronizante e12.

Cálculo do termo (N2) + nN + nzN para o evento sincronizante e13.

Cálculo do termo (N2) + nN + nzN para o evento sincronizante e14.

Mais uma vez deve-se recalcular os termos (N2)+nN +nzN pois os eventos e7 e e8 possuem valores diferentes para as suas matrizes positivas e negativas.

Sendo assim, o cálculo destes termos para as matrizes negativas dos eventos e7 e e8 são realizados da seguinte maneira.

Cálculo do termo (N2) + nN + nzN para o evento sincronizante e7 (matriz negativa).

Cálculo do termo (N2) + nN + nzN para o evento sincronizante e8 (matriz negativa).

Custo computacional para a parte sincronizante positiva do modelo.

Custo computacional para a parte sincronizante negativa do modelo.

Custo computacional total para a parte sincronizante do modelo.

Considerando a otimização dos Fatores Normais Unitários Aditivos (AUNF) proposta para a técnica Slice, o custo computacional desta técnica para os dois exemplos estudados é calculado conforme apresentado nas seções seguintes.

Custo computacional otimizado da parte sincronizante positiva do modelo.

Custo computacional da parte sincronizante positiva do modelo.

Sabendo-se que o custo da parte sincronizante negativa é igual a positiva para este modelo.

Adicionando o custo da parte local, tem-se então o custo computacional total do Slice otimizado para o exemplo 1.

Considerando a otimização dos Fatores da técnica Slice.

Custo computacional otimizado da parte sincronizante positiva do modelo.

Custo computacional da parte sincronizante positiva do modelo.

Custo computacional total para a parte sincronizante do modelo.

Adicionando o custo da parte local, tem-se então o custo computacional total do Slice otimizado para o exemplo 2.

Esta seção apresenta os cálculos do Custo Computacional das técnicas Shuffle e Slice considerando a otimização da diagonal.

Ou seja, são eliminados do cálculo todos os elementos diagonais das matrizes locais dos modelos SAN, assim como todas as matrizes negativas dos eventos sincronizantes.

Portanto, é necessário refazer apenas os cálculos da parte local dos modelos SAN, pois da parte sincronizante basta descartar a parte negativa.

Para realizar o cálculo do Custo Computacional para o primeiro exemplo de modelo SAN, foram considerados os novos valores para a parte local, assim como o cálculo da parte sincronizante positiva que já havia sido realizado.

Fórmula do custo computacional para a parte local do modelo.

Custo computacional total para a parte local do modelo.

Custo computacional da técnica Shuffle para este modelo SAN.

Considerando que o cálculo da parte local é igual para ambas as técnicas.

Custo computacional da técnica Slice para este modelo SAN.

Para realizar o cálculo do Custo Computacional para o segundo exemplo de modelo SAN, bem como o cálculo da parte sincronizante positiva já realizado anteriormente.

Fórmula do custo computacional para a parte local do modelo.

Custo computacional total para a parte local do modelo.

Custo computacional da técnica Shuffle para este modelo SAN.

Considerando que a otimização dos fatores para o algoritmo da técnica Slice refere-se somente à parte sincronizante do modelo, e que a otimização da diagonal não modifica o cálculo da parte sincronizante positiva, basta somar para cada exemplo o custo da parte local calculado na seção B2 com o custo otimizado da parte sincronizante positiva calculado na seção B13, como apresentado a seguir.

