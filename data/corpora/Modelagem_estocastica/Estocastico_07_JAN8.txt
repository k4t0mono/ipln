Este trabalho aborda a qualidade da geração estatística de casos de teste no teste estatístico através da descrição formal de programas.

A principal contribuição consiste na proposta de uma métrica para o cálculo de índice de cobertura baseado em trajetórias, ou seja, é formalizada uma métrica que verifica a relevância de conjuntos de casos de teste.

São utilizadas Cadeias de Markov (MC) e Redes de Autômatos Estocásticos (SAN) como métodos formais de descrição de modelos de uso, no sentido de verificar vantagens e desvantagens no processo de teste estatístico utilizado.

No decorrer do trabalho, discute-se uma análise quantitativa da geração de casos de teste, bem como sua eficiência para os formalismos MC e SAN.

Como resultado, são apresentadas uma análise quantitativa da geração de casos de teste e a evolução de resultados numéricos para a métrica proposta.

Verificou-se com a análise quantitativa que a implementação em SAN apresentou uma pequena vantagem na geração de casos de teste.

Com a métrica proposta pode-se avaliar tanto para SAN quanto para MC o índice de cobertura de uma determinada amostra de casos de teste.

Com a crescente demanda por sistemas de computação mais robustos, estes tornam-se cada vez mais complexos e requerem um maior grau de precisão, por exemplo, sistemas web onde performance e confiabilidade são requisitos necessários para o sucesso desses sistemas e satisfação dos usuários.

Há uma crescente necessidade de software com alta confiabilidade e qualidade, como aplicações críticas, Web, médicas e outros sistemas de controle.

Neste sentido, muitas formas de melhoria dos processos de desenvolvimento de software são utilizadas e diversos artefatos e ferramentas buscam melhorar o desenvolvimento, como a utilização de métodos formais para descrever requerimentos, especificações, designs e testes.

As inovações e melhorias dos processos de desenvolvimento de software ajudam a ter software com alta qualidade e de alta confiabilidade, mas continua a necessidade deles serem testados, o que significa que os métodos utilizados para testes devem ser eficientes para que problemas possam ser detectados e corrigidos antes de chegaram ao usuário final.

Assim, métodos formais tornam-se uma boa abordagem a ser utilizada, podendo ser utilizados desde a fase de requisitos até a fase de teste.

Muitos sistemas atuais são expostos a uma quantidade exaustiva de testes na tentativa de minimizar possíveis falhas e, mesmo assim, a confiabilidade não é garantida na maioria dos casos.

No entanto, nem sempre é possível realizar testes de forma exaustiva devido ao alto custo e tempo gasto, assim, necessitamos de técnicas que tornem a prática de testar viável e com bons resultados.

Muitas técnicas, conceitos e estilos de teste são descritos na literatura devido à popularização da orientação a objetos e modelos em engenharia de software.

Assim, tem sido grande a utilização de teste de software baseado em modelos (model-based testing), que possui como base um modelo formal da aplicação onde torna-se possível a geração de casos de teste.

Considerando sistemas complexos, sistemas que necessitam de confiabilidade, ou sistemas que necessitam de uma quantidade de testes mais apurados, então existe a necessidade de uma geração de casos de teste automática.

Entre os benefícios da geração automática de testes pode-se citar a economia de tempo e recursos (pessoas).

Adicionalmente, através da geração estatística de casos de teste, pode-se estimar a confiabilidade de um determinado sistema.

Apoiado em técnicas tradicionais de teste de software, como o teste funcional e o teste estrutural, o teste estatístico compreende a aplicação da ciência estatística para a solução de problemas de teste de software.

A utilização de teste estatístico usualmente requer a utilização de procedimentos randômicos como procedimentos de amostragem, algoritmos randômicos ou construções randômicas.

Neste contexto, a utilização do teste estatístico deve-se apoiar em ferramentas que suportem todo este processo de teste.

Outro fator importante na automatização do processo de teste estatístico é a forma como a aplicação é representada.

Desta forma, são construídos modelos que buscam expressar a realidade de um sistema.

Estes modelos além de representarem características do sistema podem ser utilizados na geração de casos de teste.

Os formalismos para a construção de modelos adotados neste trabalho são as Cadeias de Markov (MC), pela grande utilização na construção de modelos de uso, e as Redes de Autômatos Estocásticos (SAN) que representam um formalismo mais sofisticado, onde os modelos são representados de forma modular e com isso torna-se mais fácil e viável a construção de modelos maiores.

Tais formalismos utilizam a noção de "estado do sistema"e as transições levam a um novo estado do sistema.

É apresentada a primeira utilização das SAN no teste estatístico, assim, essa dissertação busca dar continuação a este trabalho focando em questões como métricas de qualidade no teste estatístico, visto que o trabalho, anteriormente realizado, apenas introduzia a utilização de SAN no contexto de teste estatístico.

Para a consolidação do referencial teórico sobre os modelos de uso utilizando métodos formais (MC e SAN), três estudos de caso foram realizados.

Nos estudos de caso buscou-se explorar a sua equivalência com as Cadeias de Markov através da construção da Cadeia de Markov correspondente a SAN, e a sua verificação através da ferramenta PEPS.

O intuito foi avaliar quantitativamente os casos de teste e verificar através de experimentos a eficiência da geração automática.

A avaliação mostrou a eficiência na geração através da análise de tempo dos algoritmos de geração e a qualidade na geração através da diversidade de casos de teste gerados, ou seja, a cada novo conjunto de casos de teste gerados, casos de teste únicos eram gerados.

Um dos pontos de investigação deste trabalho compreende a análise de métricas para o teste estatístico.

Algumas métricas são propostas na literatura como técnicas de comparação de vetores para MC.

No entanto, como essas técnicas correspondem a comparação das freqüências das transições dos modelos em MC, para SAN elas não se aplicam da mesma forma devido à semântica dada às transições através dos eventos.

Desta forma, também é proposta uma métrica de cálculo do índice de cobertura baseado em trajetórias, que é aplicada tanto para MC quanto para SAN.

Os objetivos gerais desse trabalho são de consolidar a utilização de SAN para a construção de modelos de uso e propor uma métrica de análise de cobertura da geração de casos de teste baseada nas probabilidades dos estados do modelo.

Os objetivos específicos correspondem a análise dos casos de teste gerados, traçando um comparativo entre MC e SAN.

Descrição do processo de teste utilizado na geração de casos de teste.

Cálculo do índice de cobertura de cada caso de teste.

Cabe ressaltar que o comparativo realizado teve como base uma ferramenta de geração estatística chamada STAGE que será apresentada no decorrer do trabalho.

Este trabalho está estruturado da seguinte forma.

O Capítulo 2 apresenta o referencial teórico sobre teste estatístico de software utilizando modelos de uso, bem como alguns formalismos existentes e utilizados no decorrer do trabalho.

O Capítulo 3 apresenta os estudos de caso realizados.

No Capítulo 4 é apresentado o processo de teste estatístico utilizado e as ferramentas de automação.

No Capítulo 5 são apresentados os resultados numéricos para a análise quantitativa da geração de casos de teste.

O Capítulo 6 apresenta a métrica de cálculo do índice de cobertura dos casos de teste.

Por fim, são apresentados as conclusões e o referencial bibliográfico utilizado.

Este capítulo apresenta um embasamento teórico e um panorama histórico do uso de teste de software, enfocando no teste estatístico de software com a utilização de modelos de uso.

Para tanto, divide-se em uma abordagem sobre teste de software em geral partindo para a definição de teste estatístico apoiado em modelos de uso.

Logo após, são descritos alguns formalismos utilizados no teste estatístico de software para a geração de casos de teste.

Em um processo de desenvolvimento de sistemas, o ciclo de testes é responsável por garantir que o produto tenha sido construído com qualidade e para que sejam corrigidos erros de execução e especificação.

A alta qualidade gerada é uma das principais motivações para se ter processos de teste de software bem definidos e eficientes.

Alguns importantes conceitos que estão presentes nesta seção são confiabilidade e falhas.

Confiabilidade em software pode ser definida como a probabilidade que o software não irá falhar durante o uso operacional.

São apresentados definições diferentes para erro, falha e defeito.

Falha (Fault), corresponde a uma condição anômala, causada por erros de projeto, problemas de fabricação ou distúrbios externos.

Uma falha em um sistema ocorre quando o comportamento deste sistema foge de sua normalidade, a qual é especificada na fase de projeto.

Erro (Error), corresponde à manifestação de uma falha no sistema, causando disparidade nas respostas apresentadas, que diferem do valor previsto.

Defeito (Defect),corresponde à incapacidade de algum componente em realizar a função para o qual foi projetado.

No entanto para fins de entendimento deste trabalho e por conveniência, assumese que erro, falha e defeito são sinônimos e ocorrem quando o software não é executado de acordo com sua especificação.

Assim, segundo Myers teste é o processo de executar um programa com a intenção de encontrar erros, isto é, aplicar processos de validação e verificação através da análise do software, buscando encontrar falhas de execução e funcionalidade.

As atividades de testes podem compreender um esforço grande no desenvolvimento de um software, e muitas vezes não contemplam todas as funcionalidades e rotinas de execução.

Várias estratégias podem ser empregadas para assegurar a correta execução do software.

São apresentadas três fases de teste.

Teste de unidade (Unit testing), nesta fase cada unidade que compõe o sistema é testada separadamente, desde que as unidades sejam pequenas (e possam ser testadas separadamente), buscando encontrar erros de especificação e implementação em cada unidade.

Teste de integração (Integration testing), nesta fase as unidades são agrupadas formando subsistemas, por exemplo, interfaces.

Os módulos são testados adicionando as unidades de forma incremental ao subsistema.

Assim a unidade responsável por uma falha é mais facilmente identificada.

Teste de sistema (System testing), nesta fase o objetivo é identificar erros de funções e características de desempenho que não estejam de acordo com a especificação.

Além dessas fases, em duas outras fases são apresentadas, o teste de aceitação e o teste de regressão.

O teste de aceitação tem por objetivo avaliar a confiabilidade e performance do sistema em um comportamento operacional, requer então uma coleção de informações sobre como o usuário gostaria de usar o sistema, o que é chamado de alfa teste, e muitas vezes seguido pelo beta teste que envolve a utilização do software pelos usuários.

O teste de regressão é feito em uma nova versão para assegurar que não houve perda de confiabilidade, quando importantes adições ou modificações são feitas para uma versão existente.

As técnicas de teste são classificadas de acordo com a origem da informação que é utilizada para estabelecer os requisitos de testes, e têm por objetivo encontrar falhas no software.

As principais técnicas de teste são o teste funcional, o teste estrutural e o teste estatístico.

O teste funcional, conhecido também como caixa-preta (black-box), enxerga o sistema como uma caixa fechada onde não se tem conhecimento sobre sua implementação ou seu comportamento interno.

No teste funcional os testes são gerados somente considerando os valores de entrada e saída do sistema utilizando como base a sua especificação.

O teste estrutural, também conhecido como caixa branca (white-box), estabelece os requisitos do software baseados na sua implementação.

Sendo assim, a geração dos testes leva em conta as estruturas lógicas e funcionais implementadas, verificando se as funcionalidades e resultados gerados estão de acordo com a especificação.

Estas duas primeiras técnicas de teste são usualmente as mais utilizadas.

Os testes funcionais são aplicados geralmente em testes de unidades, enquanto os testes estruturais são aplicados geralmente em testes de integração e testes de sistema.

O teste estatístico é visto como um excelente complemento para as técnicas de teste existentes podendo ser utilizado não como uma diferente técnica de testes, mas como uma técnica que visa somar confiabilidade às demais técnicas.

Portanto, o teste estatístico pode ser definido como a aplicação da ciência estatística para a solução de problemas de teste de software e é desenvolvido para caracterizar a população que utiliza o software.

Os modelos de uso caracterizam-se pelo uso operacional do software e são baseados em especificações funcionais e no uso das especificações para o desenvolvimento do software.

Assim todas as informações necessárias para desenvolver o modelo devem ser disponíveis antes do começo da implementação, o que torna os modelos de uso artefatos importantes para o desenvolvimento, por exemplo, de funções em termos de probabilidade de uso.

Também é apresentada uma metodologia para a criação de modelos de uso dividida em oito etapas.

Revisar a especificação do software.

Nesta etapa a especificação do software é revisada e compreendida, para que o modelo de uso possa refletir o uso do software partindo de uma especificação funcional completa.

Identificar o uso do software, usuário e ambiente de uso, nesta etapa é definido o ambiente operacional o qual o software vai ser aplicado.

Usuário compreende a entidade que interage com o software, e pode ser uma pessoa, um periférico ou outro sistema.

Uso, compreende a maneira como o software é processado, e pode ser uma seção de trabalho, transações ou qualquer outra unidade de serviço.

Ambiente, compreende os fatores externos ao software que podem interferir no seu funcionamento, e pode ser interações com outros sistemas (banco de dados, dispositivos de E / S), plataforma, integridade de dados, necessidade de acessos simultâneos, etc.

Definir parâmetros de ambiente, existe uma grande quantidade de combinações de valores para os parâmetros utilizados por um software, incluindo múltiplos estímulos aplicados simultaneamente.

Nesta etapa são definidos os parâmetros que serão suficientes e que satisfaçam o sistema e contribuem para o desenvolvimento de modelos de uso de forma que estes se tornem simples e eficazes.

Determinar o nível de granularidade, a granularidade dos modelos de uso tendem a aumentar com seu custo de desenvolvimento e manutenção.

Nesta etapa, para determinar os níveis de granularidade deve-se periodicamente analisar o custo de desenvolvimento e manutenção do modelo e os benefícios de se ter um teste de melhor qualidade.

Desenvolver a estrutura do modelo de uso, os modelos de uso são compostos por eventos e transições entre os eventos, sendo que os eventos partem de um estado para outro.

Nesta etapa o modelo de uso pode ser representado por um grafo, gramática formal, MC ou SAN.

Verificar se a estrutura do modelo de uso está de acordo com a especificação,nesta etapa todos os parâmetros que afetam a estrutura dos modelos devem ser verificados, como classes de usuários e funções críticas do sistema, entre outros.

Desenvolver a distribuição da probabilidade para o modelo, nesta etapa, para cada transição é definida uma probabilidade, e um conjunto de transições que definem a distribuição da probabilidade.

Essa distribuição é a base para que o teste estatístico de software possa ser executado.

Verificar a distribuição da probabilidade, nesta etapa é feita uma verificação da distribuição da probabilidade na tentativa de minimizar erros.

Estas etapas incluem todos os passos necessários para a construção de um modelo de uso.

No entanto, cabe ressaltar que um modelo de uso define apenas aspectos funcionais de um software, não considerando aspectos não funcionais ou estruturais do software modelado.

É notório que o teste estatístico baseado nos modelos de uso possui muitos benefícios, mas por outro lado, também possui algumas limitações.

Como a modelagem é feita baseada em estados surge o problema da explosão dos estados, ou seja, modelos muito complexos que necessitam de uma modelagem com muitos estados pode tornar a sua construção impraticável.

Este problema pode ser contornado adicionando uma maior abstração ao modelo, no entanto outro problema é gerado, a perda de informações.

Uma alternativa é a utilização de redes de autômatos estocásticos (SAN) que será discutida adiante.

Há muitos benefícios no teste estatístico de software com modelos de uso.

Fonte para estimativas de planejamento, os resultados obtidos podem ser utilizados para estimar custo e tempo no desenvolvimento de novos software.

Geração de testes automática.

A utilização de modelos de uso torna-se ideal para a geração automática de testes, por exemplo, utilizando cadeias de Markov para a execução de testes estatísticos de software.

Testes eficientes, os testes tornam-se bem estruturados e contribuem para a obtenção de resultados mais eficientes.

Gerenciamento quantitativo dos testes, os resultados quantitativos dos testes acabam ajudando no gerenciamento e tomadas de decisão.

Verificação de confiabilidade, com a utilização dos modelos de uso as métricas de confiabilidade têm melhorado e, portanto, tornado as aplicações mais confiáveis.

Cabe ressaltar que a utilização dos modelos de uso não garante todos os benefícios, algumas vezes alguns são mais enfatizados ou priorizados.

Neste sentido, nesta dissertação os benefícios dos modelos de uso que buscou-se explorar foram a geração de testes automática, gerenciamento quantitativo dos casos de teste e verificação de confiabilidade.

Modelos são usados para compreender, especificar e desenvolver sistemas em muitas áreas.

No desenvolvimento de casos de teste e análise de confiabilidade estes modelos tornam-se muito interessantes, principalmente em sistemas complexos e difíceis de serem testados exaustivamente.

O teste baseado em modelos significa representar as informações de um determinado sistema em um modelo.

Há uma grande quantidade de modelos atualmente e cada um descreve diferentes aspectos do comportamento do software, como controle de fluxo, fluxo de dados, grafos, máquinas de estado, entre outros.

Atualmente os formalismos mais populares para a geração de casos de teste são baseados em estados, ou seja, os modelos utilizam-se de um conjunto de estados para a representação de um comportamento do sistema.

Dentre os formalismos utilizados, é crescente a utilização dos modelos da UML, que substituem a simples representação de estilo gráfico por uma poderosa estrutura de linguagem.

Portanto, UML é uma linguagem para construção de modelos de software dos mais simples até os mais complexos e vem sendo utilizada com muitos fins.

Além da UML ser utilizada em diversas fases do desenvolvimento de sistemas, também podemos encontrar diversos trabalhos sobre teste baseado em UML, como, por exemplo, é proposto uma geração estatística de casos de teste baseada na utilização do diagrama de estados da UML.

Como este trabalho representa uma continuação ao trabalho desenvolvido, os modelos formais utilizados são as Cadeias de Markov (MC) e Redes de Autômatos Estocásticos (SAN).

As MC são muito utilizadas na construção de modelos de uso para o teste estatístico, e as SAN possuem o mesmo poder de representação das MC, no entanto, de forma modular.

Com isso, este trabalho não visa discutir outras formas de representação formal dos modelos de uso, mas busca explorar as MC e SAN no sentido de avaliar métricas e resultados na geração de casos de teste.

A seguir, é apresentada uma descrição formal e informal dos modelos utilizados nesta dissertação, ou seja, as Cadeias de Markov e as Redes de Autômatos Estocásticos.

Uma máquina de estados finita (FSM) é representada por arcos que correspondem a transições que interligam estados.

Cada transição contém o estado origem, um evento de entrada, saída ou uma ação e o próximo estado.

Máquina de estados finitos também são conhecidas como autômatos finitos e são aplicadas para qualquer modelo que possa ser descrito com precisão por um número finito de estados e geralmente pequeno.

As FSM também são empregadas no teste de software.

Grafos são equivalentes a máquinas de estados finitos e modelam sistemas complexos e de tempo-real.

Grafos fornecem um framework para especificar máquinas de estados em uma hierarquia, ou seja, um simples estado pode ser expandido em outra máquina de estados e eles também agregam características especiais para máquinas de estados concorrentes.

As Cadeias de Markov (MC) são por sua vez uma extensão das máquinas de estados e grafos onde as transições possuem taxas ou probabilidades.

Considera-se a formalização de um modelo em Cadeias de Markov a Escala de Tempo Contínuo1 (CTMC, Continuous Time Markov Chain) compreendendo um conjunto finito de estados e transições.

Dado um conjunto finito E de estados, uma MC é definida, onde representa um conjunto de estados, onde n é um número inteiro, positivo e finito.

Tx,y representa uma taxa (não nula) de ocorrência de uma transição do estado Ex para o estado Ey.

Outra definição formal das MC pode ser encontrada.

Um processo estocástico é definido como um conjunto de variáveis randômicas definidas em um espaço de probabilidade e indexadas por um parâmetro t, onde t representa um intervalo de tempo que pode variar.

Os valores assumidos pelo conjunto de variáveis randômicas são chamados de estados.

O processo estocástico é discreto quando o intervalo de tempo é discreto e, portanto chamado de processo estocástico discreto.

O processo estocástico é contínuo quando o intervalo de tempo é contínuo, e chamado de processo estocástico contínuo.

O processo estocástico é definido como estacionário quando independe de mudanças do tempo inicial.

Portanto, processo Markoviano é um processo estocástico quando é caracterizado por não possuir memória em relação ao passado do sistema, isto é, somente o estado atual do sistema pode influenciar no próximo estado.

Os estados em um processo Markoviano representam o estado do software.

As ações executadas pelos usuários do sistema são definidas como transições entre os estados (representadas por arcos).

Assim, as MC são definidas como modelos matemáticos para a resolução de fenômenos randômicos em um tempo.

Esse tempo é considerado discreto e possui um número de estados finitos e enumeráveis.

As MC no contexto de modelos de uso podem ser descritas em duas fases de construção, a fase estrutural onde os estados e arcos da cadeia são definidos, e a fase estatística onde são atribuídas as probabilidades de transições.

O modelo pode ser descrito em um alto nível de abstração.

Por exemplo, em uma aplicação o modelo possui um estado inicial (Invocation) e um estado final (Termination).

O estado de uso (Usage) representa um conjunto de estados que determina as ações executadas no software em questão.

Exemplo de MC.

A utilização das MC como um modelo para a geração de casos de teste é bastante difundida na literatura, podendo ser encontrados diversos trabalhos.

As SAN foram propostas por Plateau e consistem em um conjunto de subsistemas representados por autômatos estocásticos e a interação entre os subsistemas é feita através de regras estabelecidas entre os estados internos de cada autômato.

As SAN são muito apropriadas para a modelagem de sistemas paralelos e distribuídos que podem, muitas vezes, ser vistos como coleções de componentes que atuam de forma independente, requerendo somente eventuais interações como ações sincronizadas.

A descrição formal aqui apresentada é dada de forma diferente da descrição formal apresentada nos trabalhos de Fernandes e Plateau.

Dados n conjuntos Si de estados (estados locais), uma SAN é definido a partir de A = {A1,A2,An} sendo um conjunto de autômatos, onde cada autômato Ai é composto por estados de Si.

Em outras palavras, cada estado global é uma combinação de estados locais de um autômato.

Quando um evento é disparado, a SAN pode ir para qualquer elemento do conjunto especificado por uma função, dependendo das probabilidades associadas ao evento.

Assumindo que um estado global é uma lista de estados locais, a função descreve para cada autômato Ai em uma rede, o que acontece no autômato quando o evento é disparado.

Eventos podem ser classificados como locais e sincronizantes.

Um evento local muda o estado de somente um autômato e um evento sincronizante muda o estado de dois ou mais autômatos.

É um conjunto de funções de probabilidade de transição (possivelmente vazio), um para cada tupla (evento, estado global).

Como definido acima, para um evento i, quando a SAN está em um estado global Gi e o evento é disparado, a SAN vai para o estado Gj o qual deve ser um elemento de Ei(Gi).

A função de probabilidade de transição descreve a probabilidade de diferentes elementos de Ei(Gi) estarem selecionados.

Usualmente, Ei(Gi) tem somente um estado, então a definição dessa probabilidade é opcional.

Na definição original SAN não possui um estado inicial, mas um conjunto de estados atingíveis.

A definição de estados iniciais é útil em modelos de uso, e não muda o formalismo SAN.

Qualquer SAN pode ser convertida em uma MC correspondente.

Os estados da MC correspondem aos estados globais da SAN.

As SAN têm demonstrado um grande número de vantagens para a modelagem de sistemas complexos em comparação com as MC.

Para o teste estatístico baseado em modelos de uso as vantagens também são evidentes e os modelos SAN são construídos sem perda de informações.

Modelos de uso descritos com SAN têm algumas características interessantes.

Requisitos do ambiente podem ser explicitamente modelados, por exemplo, servidores, comunicação entre ambientes diferentes, etc.

A representação é modular, melhorando a manutenção e leitura do modelo.

Um uso individual é uma seqüência de estados globais em uma SAN, assim, sua descrição é mais detalhada, o que torna simples o mapeamento de uso em casos de teste.

Como mencionado, no formalismo SAN os estados globais são definidos como a combinação de estados de cada autômato, chamados estados locais.

Pode ser visto um exemplo de um modelo SAN com dois autômatos completamente independentes.

Exemplo SAN com dois autômatos independentes.

O autômato A(1) possui três estados locais (x(1), y(1), z(1)).

O autômato A(2) possui dois estados locais (u(2), w(2)).

Os eventos nesse exemplo são considerados locais, pois cada evento altera apenas o estado de um autômato.

Por exemplo, caso o autômato A(1) encontre-se no estado x(1) e o autômato A(2) encontre-se no estado u(2), o autômato A(1) pode passar do estado x(1) para y(1), conforme o evento e1, independente em que estado o autômato A(2) se encontre.

O estado local de um autômato em um tempo t é justamente o estado em que ele ocupa no tempo t, e o estado global em um tempo t é dado pelo estado local em cada um dos autômatos da SAN ocupa neste mesmo tempo t.

Seguindo o exemplo alguns estados globais são x(1)u(2), y(1)u(2), y(1)w(2), z(1)w(2), y(1)u(2).

Há basicamente duas formas que as SAN interagem, a taxa em que uma transição pode ocorrer em um autômato pode ser uma função de um estado de outro autômato.

Assim transições são chamadas de taxas funcionais.

Transições que não são funcionais são chamadas de constantes.

Uma transição em um autômato pode forçar a ocorrência de uma transição em um ou mais autômatos.

Este tipo de transição é dita como transições sincronizantes.

Uma transição sincronizante também pode ser representada por uma taxa funcional ou constante.

Em uma rede de autômatos estocásticos os estados dos autômatos podem sofrer mudanças.

Quando um evento local muda de estado sem interferir no estado dos demais autômatos, o evento é chamado de evento local.

Quando um evento muda não somente o seu estado, mas também o estado de outros autômatos simultaneamente, então é chamado de evento sincronizante.

Observamos o evento sincronizante s que representa transições disparadas simultaneamente nos autômatos A(1) e A(2), onde uma alteração no estado global do modelo ocorre através de uma alteração nos estados locais de ambos os autômatos.

Também podemos observar no exemplo os eventos locais e1, e2, e3 do autômato A(1), e e4 do autômato A(2) que representam as transições que ocorrem no seu autômato através da alteração no estado local do autômato.

Exemplo SAN de um evento sincronizante.

Um evento sincronizante é associado a um conjunto de no mínimo duas transições.

As transições sincronizantes possuem estruturas chamadas tripla de sincronização que é definida por um identificador do evento sincronizante, uma taxa de disparo e uma probabilidade de ocorrência.

Nome do evento sincronizante é o identificador do evento, onde cada evento sincronizante possui um nome único identificando que a transição ocorre simultaneamente.

Taxa de disparo, é a taxa em que o evento ocorre.

A taxa é apresentada apenas em um autômato, sendo omitida dos demais.

Probabilidade de ocorrência, cada transição que sai de um mesmo estado local recebe uma probabilidade de ocorrência, sendo que essas transições não ocorrem simultaneamente e a soma das probabilidades é igual a um.

Considerando os tipos de eventos, locais e sincronizantes, podemos ter taxas constantes apresentadas como números reais não negativos, e taxas funcionais representadas por uma função para um único número real não negativo.

As taxas funcionais e os eventos sincronizantes representam as duas formas de interação entre autômatos em uma SAN.

Os estados da SAN indicam qual é a taxa utilizada no momento da transição.

O autômato A(2) apresenta, além do evento local l4, a taxa funcional f.

Assim, a transição do estado u(2) para o estado w(2) irá ocorrer com a taxa de 1 se o autômato A(1) estiver no estado x(1).

Se o se o autômato A(1) estiver em z(1) a taxa de transição será de 2.

Caso o autômato A(1) esteja no estado y(1), a transição u(2) para w(2) não irá ocorrer, portanto com taxa igual a zero.

Neste exemplo, a taxa funcional está sendo utilizada com um evento local, porém ela não está limitada a apenas eventos locais, podendo ser utilizada com eventos sincronizantes.

As SAN representam uma importante ferramenta de modelagem que se torna muito útil principalmente para sistemas paralelos e distribuídos.

Estes sistemas podem dispor de muitos estados e, portanto, a sua representação utilizando MC pode resultar no problema de explosão de estados.

Além disso, tais sistemas freqüentemente podem ser vistos como módulos ou coleções de componentes e, portanto, o aspecto modular que as SAN agregam acaba sendo uma importante vantagem frente às MC.

Exemplo SAN utilizando taxa funcional.

Este capítulo descreve os estudos de caso realizados com a finalidade de evoluir alguns resultados numéricos na geração estatística de casos de teste.

Um pequeno exemplo de um sistema de login é apresentado por completo, demonstrando todo o processo de construção de um modelo de uso.

O primeiro estudo de caso referese à aplicação Simple Counter Navigation, que corresponde a uma aplicação de navegação entre páginas Web.

Para o segundo estudo de caso utilizou-se a aplicação Calendar Manager, que se caracteriza por um sistema de gerenciamento do calendário acadêmico, com funcionalidades de edição de calendários e seus respectivos eventos.

No terceiro estudo de caso, modelou-se a aplicação Docs Editor que consiste em um editor de planos de teste.

Considere um simples sistema de login com dois diálogos, o primeiro é o diálogo de login, onde o usuário entra com seu nome e senha, se o nome e senha estiverem incorretos, a aplicação apresenta uma mensagem de erro, o segundo diálogo apresenta um menu onde o usuário pode simplesmente sair da aplicação.

A Cadeia de Markov (MC) equivalente descreve a aplicação com 4 estados e 7 transições.

Cada estado corresponde a Estado Start, representa o estado inicial da aplicação.

Quando a transição com taxa t1 é executada a aplicação é iniciada.

Estado Password,representa a tela de validação do nome e senha.

Estando neste estado a aplicação pode passar para o estado PNotOK com uma taxa de transição t5 ou para o estado menu executando a taxa de t3.

Se a transição com taxa t2 é executada a aplicação é finalizada voltando para o estado inicial.

Estado PNotOK, representa a mensagem de erro.

Executando a transição com taxa t4 a aplicação volta para o estado Password.

Se a transição com taxa t2 é executada a aplicação é finalizada voltando para o estado inicial.

Estado Menu,representa o menu da aplicação.

Quando a transição com taxa t2 é executada a aplicação é finalizada voltando para o estado inicial.

Modelo MC, Sistema de Login.

Esta mesma aplicação é descrita por uma SAN com dois autômatos representando em que tela estamos e qual o status da tela.

Neste modelo temos cinco eventos possíveis.

Evento ST, representa o início da execução, ou seja, a alteração do estado inicial [Start, Waiting] para o estado global [Password, Waiting].

Evento QT, representa o fim da execução por interrupção ou término normal, ou seja, a alteração do estado [Password, Waiting] para [Start, Waiting] ou estado [Menu, Waiting] para [Start, Waiting] ou estado [Menu, POK] para [Start, Waiting].

Evento S, representa a entrada de um usuário no sistema, ou seja, a alteração do estado [Password, Waiting] para [POK, Menu].

Evento l1, representa um usuário inválido, ou seja, a alteração do estado [Password, Waiting] para [Password, PNotOk].

Evento l2, representa a saída da mensagem de erro e retorno para a tela de login, ou seja, a alteração do estado [Password, PNotOk] para [Password, Waiting].

Modelo SAN, Sistema de Login.

ST, QT e S são eventos sincronizantes, enquanto l1 e l2 são locais.

O evento local l1 tem uma taxa funcional f.

Segundo a definição de f, este evento só poderá ocorrer quando o autômato Windows estiver no estado Password.

Observa-se que o modelo SAN possui nove estados globais onde apenas quatro são atingíveis.

Neste sentido, o modelo SAN acaba não se tornando mais compacto que seu modelo equivalente MC.

Mesmo assim, o objetivo em apresentar esse modelo é o entendimento de como as aplicações são modeladas.

As taxas reais para os modelos de uso são obtidas por logs de usuários, ou seja, a aplicação é monitorada por um determinado período de tempo e os logs gerados são convertidos em taxas.

Desta forma, a aplicação é utilizada por um tempo arbitrário e então logs contendo informações de uso (links visitados, formulários preenchidos, etc) são gerados.

O percentual de ocorrência de transições (MC) ou eventos (SAN) é interpretado como taxa de ocorrência.

Por exemplo, se o evento S ocorre dez vezes em um total de vinte vezes, logo, sua taxa é igual à 05.

Correspondência dos estados da MC, Sistema de Login.

Para o primeiro estudo de caso utilizou-se uma aplicação chamada Simple Counter Navigation a qual foi desenvolvida pelo CPTS.

Primeiramente é apresentada uma descrição da aplicação, e logo após seu modelo MC seguido pelo modelo SAN equivalente.

A aplicação consiste em páginas HTML e JavaScript.

A aplicação é apresentada da seguinte forma.

Tela Inicial (estado Start), apresenta o início da aplicação e possui dois links, link NEXT1 que vai para a próxima janela e link CLOSE que fecha a aplicação.

Janela 1 (estado main), apresenta uma única opção disponível e o link NEXT2 para a janela 2.

Janela 2 (estado win01), apresenta dois links para caminhos diferentes.

No link CAMINHO1 a aplicação retorna a tela inicial, e no link CAMINHO2 a aplicação passa para a janela 3.

Janela 3 (estados win0301, win0101, win0302, win0402, win0303), apresenta um contador com valor inicial igual a 0 e cada vez que o link NEXT5 é acionado, a aplicação passa para a janela 4, onde o contador é incrementado.

Quando o contador tiver o valor 2 a próxima vez em que o link NEXT5 for acionado a aplicação retorna a tela inicial.

Janela 4 (estado win02),apresenta a última tela da aplicação onde é possível voltar para a tela inicial através do link NEXT7 ou retornar a tela anterior através do link BACK.

O modelo MC para a aplicação Simple Counter Navigation possui nove estados.

Modelo MC, Simple Counter Navigation.

O modelo de uso da aplicação considera os seguintes elementos, a aplicação ativa e não ativa.

A navegabilidade da aplicação, ou seja, as telas e as opções (links) de navegação disponíveis ao usuário.

O contador existente na janela 3.

Sendo assim, foram definidos três autômatos para a aplicação.

Autômato Application, representa o início da aplicação (estado run) e o fechamento da aplicação, fazendo a aplicação voltar a um estado inicial start.

Autômato Navigation, representa as possibilidades de navegação entre as telas da aplicação.

Autômato Count, representa o contador da aplicação.

O modelo SAN possui cinco eventos sincronizantes e sete eventos locais, possuindo um total de 60 estados, sendo que apenas 9 são atingíveis.

Na situação inicial da aplicação (tela inicial), ela encontra-se no estado run do autômato Aplication, estado main do autômato Navigation e no estado start do autômato Cont.

Eventos sincronizantes.

Evento ST, ocorre quando a aplicação é iniciada passando do estado start, start, start para o estado run,main,start.

Evento QT, ocorre quando a aplicação é encerrada, ou seja quando o usuário acionar o link CLOSE na tela inicial.

Evento S, ocorre quando a aplicação passa para a tela onde possui o contador.

Evento V e T, Ocorrem quando o usuário volta para a tela inicial.

Os eventos locais são Evento L1, ocorre quando a aplicação passa do estado main para o estado win01 do autômato Navigation.

Evento L2, ocorre quando a aplicação passa do estado win01 para o estado win02 do autômato Navigation.

Evento L3, ocorre quando a aplicação passa do estado win03_01 para o estado win04_01 do autômato Cont.

Evento L4, ocorre quando a aplicação passa do estado win04_01 para o estado win03_02 do autômato Cont.

Evento L5, ocorre quando a aplicação passa do estado win03_02 para o estado win04_02 do autômato Cont.

Modelo SAN, Simple Counter Navigation.

Evento L6, ocorre quando a aplicação passa do estado win04_02 para o estado win03_03 do autômato Cont.

Evento LV, ocorre quando a aplicação passa do estado win02 para o estado main do autômato Navigation.

Logo após, foi gerada a descrição textual do modelo SAN conforme apresentada no Apêndice C.

Tal descrição é utilizada para a obtenção das probabilidades dos estados que serão utilizadas para o cálculo da métrica.

O modelo SAN corresponde a MC, onde observa-se a equivalência dos estados da MC para o formalismo SAN.

Correspondência dos estados da MC, Simple Counter Navigation.

Note que mesmo o modelo SAN possuindo uma complexidade maior e o modelo Markov ser relativamente simples, ambos são equivalentes e representam exatamente as mesmas funcionalidades do modelo.

Para o segundo estudo de caso utilizou-se uma aplicação Web que cria calendários acadêmicos e organiza as datas de eventos, feriados, inicio e fim de semestre, etc.

Baseado nas funcionalidades da aplicação procurou-se construir o modelo SAN.

Assim, foi modelada a MC correspondente identificando os estados da cadeia com seu estado global correspondente do modelo SAN.

Fazendo uso da ferramenta PEPS, descreveu-se o modelo SAN em uma linguagem textual conforme pode ser visto no Apêndice D.

A aplicação é acessada através de um browser e é composta por páginas JSP.

A sua principal funcionalidade é a manutenção de calendários através da inclusão e edição de eventos.

A aplicação é apresentada da seguinte forma.

Tela Inicial corresponde à tela de entrada da aplicação, onde possui dois links.

O primeiro link "ADM"refere-se a uma área restrita a usuários cadastrados onde são acessadas as funções administrativas da aplicação.

O segundo link "CONSULTAR"refere-se a uma área publica onde qualquer usuário pode consultar o calendário.

Tela Login, nesta tela é acessada através do link "ADM"e possui um formulário para a identificação de usuários devendo ser informados o nome e a senha.

O usuário pode também cancelar e voltar para a tela inicial.

Tela Menu Inicial, nesta tela o usuário autorizado encontra as opções de visualizar calendário, criar eventos, pesquisar eventos e criar novo calendário são apresentadas em um menu esquerdo.

Tela Criar Eventos, representa a tela onde os eventos são criados.

Quando o botão (link) OK é acionado e os campos do formulário são validados.

Também possui a possibilidade de cancelar essa ação.

Tela Pesquisar, representa a tela de pesquisa que possibilita a localização dos eventos do calendário.

Caso seja requisitado uma consulta com o campo de texto em branco todas as ocorrências serão listadas.

Tela Lista Pesquisa, representa o resultado de uma pesquisa dos eventos.

Observa-se que cada evento possui dois links.

O link "APAGAR"que apaga o evento e o link "ALTERAR"direciona a outra página para a realização de uma possível alteração.

Tela Altera, representa a tela de alteração da descrição de um evento.

Possuindo o botão (link) de "GRAVAR"o qual confirma a alteração, e o botão (link) de "CANCELAR"que cancela a alteração.

Tela Cria novo Calendário, representa a inserção de um novo calendário, por exemplo, a inserção do calendário acadêmico para o próximo ano.

Caso o botão (link) "GRAVAR"é acionado, efetua-se a validação do formulário e um novo calendário é criado.

Possui também a opção de cancelar a ação através do botão (link) "CANCELAR".

O modelo equivalente, que constitui na combinação de todos os autômatos, possui 336 estados globais (2×3×4×2×7) onde apenas 16 desses estados são atingíveis.

Este modelo não mostra os eventos por uma questão de visualização.

Modelo MC, Calendar Manager.

Para a construção do modelo SAN foram considerados os seguintes elementos da aplicação.

Disponibilidade da aplicação.

Autenticação de usuário.

Validação dos formulários.

As ações dos objetos da aplicação como criação, exclusão e alteração de eventos do calendário.

A partir da delimitação do modelo de uso, os autômatos do modelo correspondem a diferentes visões da aplicação.

Assim, foram identificados cinco autômatos.

O autômato Application representa o estado inicial (start) e estado final (run) da aplicação.

O autômato Navigation representa as possibilidades de navegação na aplicação, ou seja, o usuário pode apenas consultar o calendário ou entrar em uma área restrita onde poderá realizar alterações nos calendários.

O autômato Password representa a validação de usuários.

Partindo de um estado inicial (waiting).

Se algum erro de autenticação ocorrer o autômato passará para o estado (passwdNOK).

Se o usuário for validado com sucesso o autômato passará para o estado (passwdOK).

O autômato Validation representa as validações de formulários (exceto de usuário) realizadas pela aplicação.

Por default definiu-se que a aplicação encontra-se no estado (testOK), e se ocorrer algum erro de validação, então o autômato passa para o estado (testNOK).

O autômato Menu representa todas as possibilidades de manutenção dos calendários, e também a criação de novos calendários.

Temos a representação do modelo SAN da aplicação.

O modelo é composto de três eventos locais e 13 eventos sincronizantes.

O estado inicial (tela inicial) do modelo é representado pelos estados start do autômato AA, start do autômato AN, testOK do autômato AV, waiting do autômato AP e start do autômato AM.

Os eventos locais são representados por Evento LA, que ocorre quando o usuário encontra-se na tela de pesquisa e efetua a pesquisa de um ou mais eventos.

Evento LB, ocorre quando o usuário encontra-se na tela com os resultados da pesquisa e aciona o link ALTERAR.

Evento LD, ocorre quando um evento é excluído do calendário acadêmico.

Os eventos sincronizantes são representados por Evento ST, representa o início da aplicação, ou seja, quando o usuário inicia o acesso às funcionalidades da aplicação.

Evento QT, este evento leva os estados dos autômatos para o estado inicial.

Evento C, este evento leva os estados do autômato para o estado inicial quando a senha do usuário não é válida, ou quando ao entrar na tela de login o usuário aciona o botão (link) "CANCELAR".

Modelo SAN, Calendar Manager.

Evento S, representa a transação onde os usuários já validados entram em uma área restrita.

Possui uma taxa funcional f.

Evento V, ocorre quando o usuário após efetuado o login aciona em uma das opções do menu (Criar Eventos, Pesquisar Eventos, Cria Novo Calendário).

Possui uma taxa funcional f.

Evento NE, ocorre quando o usuário encontra-se em Criar Evento e aciona uma das funcionalidades.

Pesquisar Eventos ou Cria Novo Calendário.

Possui uma taxa funcional f.

Evento OK, ocorre quando uma alteração em um evento do calendário é efetuada.

Possui uma taxa funcional f.

Evento SE, ocorre quando o usuário encontra-se em Pesquisar Eventos e aciona a funcionalidade de Criar Evento ou Cria Novo Calendário.

Possui uma taxa funcional f.

Evento CA,ocorre sempre quando alguma ação é cancelada.

Possui uma taxa funcional f.

Evento CI, ocorre quando um novo calendário é inserido.

Possui uma taxa funcional f.

Evento NI, ocorre quando um novo evento do calendário é incluído.

Possui uma taxa funcional f.

Evento NC, ocorre quando o usuário encontra-se em Cria Novo Calendário e aciona a funcionalidade de Pesquisar Eventos ou Criar Evento.

Possui uma taxa funcional f.

Evento R, este evento ocorre quando o login não é validado pela ocorrência de alguma inconsistência informada pelo usuário.

Para compilação na ferramenta PEPS, gera-se uma descrição textual do modelo, apresentada no Apêndice D.

Utilizando a ferramenta PEPS é possível resolver o modelo, ou seja, encontrar a distribuição estacionária dos estados globais.

Cada um dos estados da MC corresponde a um estado global da SAN.

O mapeamento dos estados globais apresenta para cada estado da MC a combinação dos estados locais correspondente a um estado global da SAN.

Correspondência dos estados da MC, Calendar Manager.

Observe que este modelo não apresenta muitos estados atingíveis, no entanto a quantidade de transições é significativa o que torna o modelo em SAN muito mais claro.

Docs Editor é um editor de documentos baseado em formulários genéricos para ser usado na criação e manutenção de informações sobre teste.

O modelo MC do Docs Editor é composto por 417 estados e 2593 transições.

Cabe ressaltar que o modelo MC não é apresentado graficamente pelo fato de possuir uma grande quantidade de estados.

Desta forma a visualização do modelo MC torna-se difícil, e a manutenção do modelo requer cautela e atenção.

O modelo SAN é composto por seis autômatos com 720 (2×2×2× 3×3×10×) estados, tendo 417 estados atingíveis.

Os 6 autômatos que compõem o modelo SAN são Autômato Server (AS), representa a ativação ou não do servidor.

Autômato Application (AA), representa o início e o fim da aplicação.

Autômato Browser (AB), representa a visualização ativa ou não do browser.

Autômato Tree (AT), representa a árvore de navegação utilizada para qualquer mudança efetuada em um documento.

Autômato Document (ADoc), representa um documento aberto, salvo ou não aberto.

Autômato Dialogs (AD), representa todos os diálogos da aplicação.

Algumas considerações sobre os estudos de caso são interessantes de serem observadas.

Primeiramente observa-se que dos estudos de caso realizados apenas o último (Docs Editor) apresenta uma quantidade de estados grande tornando-se inviável a sua representação em MC.

Desta forma para todos os demais estudos de caso são apresentados o modelo SAN e MC correspondente.

Observa-se também que com as SAN aplicações maiores tornam-se mais fáceis de serem usadas, no entanto uma serie de estados inatingíveis são inseridos no modelo.

Além de conceitos mais elaborados como estados globais e locais e taxas funcionais, mesmo assim, o formalismo é mais poderoso pois aplicações mais complexas podem ser modeladas de forma mais fácil.

Este capítulo apresenta um processo de desenvolvimento de teste estatístico de software utilizado no Centro de Pesquisa em Teste de Software (CPTS) e as ferramentas utilizadas na automatização de todo o processo.

O processo de teste estatístico utilizado no CPTS pode ser dividido em seis etapas.

Identificação de funcionalidades, corresponde em identificar funcionalidades da aplicação e aspectos que se pretende agregar confiabilidade e minimizar ao máximo eventuais falhas.

Construção do modelo, corresponde em descrever formalmente o modelo da aplicação, ou as funcionalidades que se pretende testar, em MC ou SAN.

Cabe ressaltar que aspectos com ambiente também podem ser considerados na modelagem da aplicação (como por exemplo sistema operacional, browser, etc).

Assim, é importante que a modelagem descreva exatamente tudo que se pretende testar.

Atribuição de probabilidades, corresponde em definir os aspectos estatísticos do modelo, ou seja, as probabilidades de ocorrência das transições (MC) ou eventos (SAN).

Estas probabilidades são extraídas de logs de usuários, versões beta ou mesmo versões anteriores.

Geração dos casos de teste, corresponde em utilizar o modelo formal (MC ou SAN) da aplicação para a execução de algoritmos estatísticos, ou seja, gerar os casos de teste que correspondem a um conjunto de execuções a serem realizadas na aplicação.

Descrição dos objetos da aplicação, corresponde em mapear no modelo formal os objetos da aplicação, ou seja, os componentes visuais como botões, menus, janelas.

Geração de scripts de teste, corresponde em utilizar os casos de teste gerados e traduzi-los para um script que possa ser utilizado por uma ferramenta que leia e automatize uma seqüência de execuções (por exemplo, um robô).

Basicamente, o processo de automatização na área de Teste de Software requer a geração de casos de teste e scripts que executem estes casos de teste em uma aplicação para a sua validação.

Foi desenvolvido pelo CPTS um framework de automatização do processo de teste estatístico chamado State Based Test Generator, STAGE.

Apresenta uma visão geral das ferramentas que compõem o STAGE para a automatização do processo de teste estatístico.

Assim, para que seja possível gerar os scripts de teste é necessário que uma aplicação seja modelada utilizando-se algum método formal através da ferramenta STAGE-Model que será apresentada na próxima seção.

Para fazer esta modelagem não é necessário ter-se a aplicação concluída, ou seja, é possível fazer esta modelagem através da especificação da aplicação, pois é nela onde devemos encontrar todas as informações relevantes para o conhecimento da aplicação.

No entanto a extração das taxas ou probabilidades de ocorrências poderão não corresponder a realidade, caso essa informação não esteja descrita na especificação, ou não se possa extrair as taxas através de logs.

Observa-se que o STAGE está integrado com a ferramenta PEPS possibilitando a exportação e importação da matriz esparsa1 e modelo SAN.

Além disso, ele possui um módulo responsável por mapear os estados do modelo nos objetos da aplicação.

Esse mapeamento é feito através de arquivos XML e possibilita a geração automática dos scripts.

Como está sendo proposto nesta dissertação a utilização de uma métrica que terá como objetivo verificar a relevância dos casos de teste gerados, pode-se incorporar no processo de teste estatístico mais duas etapas.

Resolução do modelo, corresponde em descrever o modelo MC ou SAN em formato textual que servirá de entrada para o PEPS e compilá-lo e executá-lo.

O intuito dessa etapa é obter um arquivo com os estados atingíveis e suas respectivas probabilidades e um arquivo com a matrix de taxas (ou transições) do modelo.

Execução da métrica, corresponde em executar o cálculo da métrica de índice de cobertura baseado em trajetórias e, assim, saber o percentual de relevância de um determinado conjunto de casos de teste.

Uma matriz esparsa é uma matriz onde a maioria de seus elementos são nulos.

STAGE Framework.

Os arquivos de saída da ferramenta PEPS podem ser utilizados como entrada para as ferramentas do framework.

A saída compreende em dois arquivos.

Arquivo HBF, corresponde ao arquivo que possui a matriz correspondente a MC.

Este arquivo é gerado a partir do modelo SAN através da ferramenta PEPS.

Arquivo REA, corresponde ao arquivo que possui o vetor de probabilidades dos estados atingíveis.

Apresenta os estados globais atingíveis e a probabilidade de cada estado.

Observa-se que a soma das probabilidades do modelo é igual a 1 e foi calculada a partir do software PEPS.

A seguir são apresentadas as duas principais ferramentas de geração estatística utilizadas.

No contexto deste trabalho, não é avaliado a geração e execução dos scripts.

Assim, as ferramentas utilizadas compreendem a ferramenta de modelagem dos casos de uso (STAGE-Model) e a ferramenta de geração de casos de teste (STAGE-Test).

O STAGE-Model é uma ferramenta que permite modelar aplicações em conjuntos de estados e transições que correspondem à um modelo da aplicação, ou seja, é possível modelar utilizando qualquer um dos seguintes formalismos, Máquinas de Estado Finitas, Máquinas de Estado Finitas com Variáveis, SAN ou MC.

Nos modelos de casos de uso, por exemplo, temos estados que representam as telas da aplicação e transições que representam as ações do usuário sobre o sistema.

O STAGE-Model apresenta-se como um editor gráfico para representar formalmente uma aplicação.

STAGE-Model.

Para a correta geração dos casos de teste, deve-se observar que para modelagem na ferramenta STAGE-Model alguns aspectos são importantes.

O modelo de estados deve estar completamente especificado.

Todos os estados devem possuir um conjunto de entradas (inputs) que os identifiquem.

Todos os estados devem possuir uma saída associada, ou seja, uma tela que os identifiquem.

Não pode-se ter estados isolados, ou seja, sem transições que cheguem ou saiam dele.

Devemos ter um estado inicial (Start), a partir do qual se inicia a modelagem.

Precisa-se definir eventos do tipo mestre (master) e escravos (quit) para cada um dos eventos do modelo.

Os eventos do tipo master correspondem ao inicio do modelo eu os do tipo quit representam os estados finais do modelo.

Com o objetivo de prover maior confiabilidade e agilidade na criação de casos de teste e scripts, a ferramenta denominada STAGE-Test é responsável por gerar os casos de teste e scripts.

Esta ferramenta tem como entrada de dados para a geração de casos de teste a modelagem da aplicação utilizando a ferramenta A saída da aplicação STAGE-Test, corresponde a uma test suite que pode ser salva em uma base de dados ou em arquivo.

As test suites geradas são arquivos base para a geração dos scripts usados na execução automática dos casos de teste.

Além da geração baseada em SAN também é possível gerar casos de teste utilizando outros formalismos como Máquina de estados finitos, máquina de estados finito com variável, MC.

Cabe ressaltar que a ferramenta STAGE-Test apenas gera os casos de teste e os scripts, sendo que a execução dos scripts é realizada na ferramenta RoboJ da Rational para execução automática de testes.

A ferramenta STAGE-Test é capaz de criar os seguintes tipos de scripts de teste para o aplicativo RobotJ da Rational.

Script de Performance, este tipo de script é utilizado para testar o tempo de resposta de um servidor, simulando múltiplos usuários realizando múltiplas requisições.

Script de Duração, este script é utilizado para executar casos de teste sobre uma aplicação durante um longo período de tempo.

Script de Navegação, este script é utilizado para navegar sobre a aplicação verificando a ligação entre as janelas da aplicação.

Então, logo após termos modelado na ferramenta STAGE-Model, faz-se o uso da ferramenta STAGE-test, que irá ler o modelo de estados e gerar os casos de teste.

Porém é importante observar que esta ferramenta possui alguns métodos de geração de casos de teste.

Assim, os métodos utilizados pela ferramenta de acordo com o formalismo são FSM, Máquina de estados finitos, Wp Method.

Este método gera casos de teste concisos e abrangentes para interfaces de software.

Graph Tracker, este método gera o conjunto dos menores caminhos do grafo em questão, ou seja, caminhos que passam por todos os estados do autômato o mínimo possível de vezes.

VFCM, máquina de estados finitos com variável, Automaton Converter, método utilizado para converter uma VFSM para FSM.

Este método de transformação funciona parcialmente.

MC, Cadeias de Markov, Random Test, este método utiliza a geração de números aleatórios para a criação dos casos de teste.

Assim, de acordo com a probabilidade gerada os casos de teste são criado.

SAN, Rede de Autômatos Estocásticos, San Test, este método gera casos de teste sobre SAN, baseado em uma geração aleatória de casos de teste supondo distribuição uniforme (equiprovável) de todos os eventos.

Portanto, com os casos de teste modelados e gerados é possível criar qualquer um dos scripts que a ferramenta suporta.

Logo após, este script deverá ser inserido no RobotJ como um novo projeto a fim de testar a aplicação.

No sentido de avaliar a geração automática de test suites esta seção demonstra as técnicas utilizadas como medidas de qualidade e uma análise quantitativa dos resultados, para ambos os formalismos, cadeias de Markov (MC) e Redes de Autômatos Estocásticos (SAN).

Dois pontos são considerados importantes na geração estatística de casos de teste, eficiência na geração, pelo fato de se trabalhar com amostras estatísticas e uma grande quantidade de casos de teste, os algoritmos de geração de casos de teste devem ser rápidos e eficientes.

Diversidade de Casos de teste, como um dos objetivos do teste estatístico é prover confiabilidade nas aplicações, quanto maior a quantidade de casos de teste novos, maior serão as situações testadas, e como conseqüência, maior a confiabilidade.

Nas primeiras análises realizadas verificamos a diversidade de geração dos modelos computada pelos casos de teste únicos gerados em test suites, tempo de geração dos algoritmos.

Entretanto, medidas de qualidade mais precisas são necessárias para comparar o modelo com as test suites geradas.

Desta forma, são apresentadas medidas de comparação de test suites geradas e uma descrição formal do cálculo do índice de cobertura de uma test suite.

A diversidade de geração dos casos de teste é estimada pela geração de um conjunto satisfatório de casos de teste, ou seja, uma test suite que forneça um bom conjunto de casos de teste distintos sobre o total de casos de teste gerados.

Assim, verificamos quantos casos de testes únicos são adicionados a cada test suite gerado para um modelo.

Desta forma foram geradas 10 test suite com 500 casos de teste, totalizando 5000 casos de teste.

As test suite gerada são limitadas a casos de teste de tamanho 10, 20, 30 e 40 passos.

Cada passo corresponde a mudança de um estado possuindo a seguinte estrutura estado-transição-estado.

Por exemplo, se uma test suite está limitada a 10 passos significa que somente casos de teste com até 10 passos serão gerados.

Apresentam o número absoluto de novos casos de teste gerados para os modelos em SAN e MC das aplicações Calendar Manager e Docs Editor.

A partir dessas curvas pode-se observar uma melhor qualidade na geração para os modelos em SAN.

Nesse sentido, entende-se que quanto mais casos de teste novos forem gerados, melhor será a qualidade da test suite.

Para a aplicação Calendar Manager, a complexidade do modelo SAN é provavelmente a causa para a irregularidade das curvas.

Para a aplicação Docs Editor, o tamanho do modelo (417 estados) deve ser responsável pelos melhores resultados obtidos para o modelo descrito em SAN.

Observa-se que os resultados obtidos correspondem a geração de casos de teste utilizando uma ferramenta específica, STAGE-Test, com algoritmos de geração específicos descritos no capítulo anterior.

Análise de diversidade, Calendar Manager.

Nos gráficos, observa-se uma considerável flutuação dos valores devido a natureza randômica do processo de geração.

Uma simples comparação mostra o alto número de casos de teste distintos, apontando para uma melhor qualidade das test suites geradas pelos modelos SAN.

É importante ressaltar que os modelos não são equivalentes em termos de estrutura, mas são equivalentes no sentido de representarem a mesma realidade.

Para estimar a diversidade dos casos de teste gerados, assume-se que quanto mais alto o percentual de novos casos de teste melhor é a sua cobertura, ou seja, se um número maior de casos de teste é gerado, um número maior de funcionalidades da aplicação são testadas ou pode-se dizer que a aplicação é testada de forma mais exaustiva.

Foram geradas sete test suites a partir dos modelos SAN e MC para as aplicações Simple Counter Navigation, Calendar Manager e Docs Editor.

Cada test suite corresponde a um conjunto de casos de teste e foram geradas com 100, 500, 1000, 2000, 3000, 4000 e 5000 casos de teste, também limitadas com tamanho de 10, 20, 30 e 40 passos.

Mostram o tempo de processamento (em segundos) para as test suites geradas.

O experimento foi gerado em um Pentium III 550MHz com 256 MB de RAM acessando uma base de dados SQL Server.

A partir desses resultados observa-se o pequeno tempo necessário para a geração de casos de teste para modelos pequenos (Simple Counter Navigation e Calendar Manager).

Para a geração de 5000 casos de teste limitados em 40 passos o tempo é inferior a 8 segundos.

Para o modelo Docs Editor os tempos gerados também são pequenos (inferiores a 210 segundos), se considerarmos o seu tamanho (417 estados).

Observa-se um comportamento quase linear do tempo de geração para modelos MC.

Este fenômeno ocorre devido à forma simplista de descrição dos modelos em MC, o qual descrevem todos os estados possíveis por um único autômato.

Os modelos em SAN possuem uma representação mais complexa, baseada em eventos locais e sincronizantes, assim, devido a sua estrutura mais elaborada acabam ocasionando um maior tempo de geração.

Desta forma, observa-se que para os modelos Calendar Manager e Docs Editor os tempos de geração de MC são maiores e para o modelo Simple Counter Navigation os tempos acabam sendo menores devido a simplicidade do modelo.

Cabe ressaltar que a comparação considera apenas uma ferramenta específica de geração de casos de teste, desta forma os resultados demonstram uma análise quantitativa baseada na ferramenta STAGE-Test.

Este capítulo descreve as métricas de qualidade no teste estatístico utilizadas em MC e a métrica proposta para estimar a cobertura de uma determinada test suite, desta forma poderemos saber o quanto significativa é a test suite gerada.

Assim, no decorrer deste capítulo a métrica será apresentada, bem como um exemplo de como a métrica é calculada.

Também são apresentados os resultados para os estudos de caso propostos.

Os casos de teste correspondem a uma execução de um software e, por sempre representarem o início e fim de um software, assumimos que a execução de um caso de teste não herda erros e nem os propaga.

Considerando isso, pode-se dizer que os casos de teste não possuem memória, e estamos considerando apenas as características modeladas.

Desta forma, o índice de cobertura diz respeito somente aos aspectos modelados, e apenas corresponderá à aplicação como um todo se a mesma estiver toda descrita formalmente através de um modelo em MC ou SAN.

A geração de uma test suite para um software pode não ser suficiente para um teste eficiente.

Portanto, pode-se comparar a distribuição de probabilidades do modelo, também chamado de cadeia de uso (usage chain), com a distribuição de probabilidades de uma test suite gerada, também conhecida como cadeia de teste (testing chain).

A comparação entre as distribuições de uso e teste nos mostra a diferença entre o uso esperado e o atual.

Desta forma, quanto menor a diferença entre as distribuições mais representativa é a test suite gerada, ou seja, uma melhor qualidade de geração.

A qualidade de geração de uma test suite corresponde à menor diferença entre a descrição formal de um programa (modelo MC ou SAN) e o conjunto de casos de teste gerados.

Essas métricas baseadas em comparações de vetores são utilizadas principalmente como critério de parada no processo de teste.

Baseado na geração de casos de teste a comparação de vetores objetiva determinar o número de casos de teste suficientes para uma determinada aplicação.

Assim, os dois vetores correspondem às taxas do modelo e às taxas apuradas em cada test suite.

Em Farina pode-se encontrar uma análise mais detalhada do discriminante de Kullback bem como alguns resultados numéricos.

Em Sayre além do discriminante de Kullback também é utilizada a distância Euclidiana.

No contexto desse trabalho as métricas também serão descritas e discutidas.

A distância Euclidiana corresponde a verificar a similaridade de dois vetores.

Desta forma, quando o vetor de freqüências da cadeia de uso aproxima-se do vetor da cadeia de teste, maior é a convergência com relação às transições do modelo.

A distância Euclidiana pode ser computada, onde ui,j e ti,j correspondem à probabilidade de ir do estado i para o estado j da cadeia de uso e da cadeia de teste, respectivamente.

O discriminante de Kullback corresponde ao valor esperado da razão de probabilidade logarítmica para dois processos estocásticos e é calculado.

Em MC tradicionalmente dois métodos são utilizados para verificar a similaridade entre uma distribuição de uso e de teste, a distância Euclidiana e o discriminante de Kullback.

A verificação é realizada com base em comparações que são feitas a partir das freqüências das transições descritas no modelo e a freqüência da ocorrência das transições na test suite gerada.

Quando um ou mais arcos da cadeia de uso não acontecem na cadeia de teste (test suite gerada), então existem transições possíveis na cadeia de uso e impossíveis na cadeia de teste.

Logo, quanto maior for a quantidade de transições que não apareçam na cadeia de teste, maior será a diferença entre as cadeias, ou seja, a qualidade da test suite será inferior se comparado com uma cadeia de teste onde apareçam mais transições.

Diferente de uma MC, a mudança do estado global de uma SAN pode ocorrer através de eventos.

Desta forma, em uma MC cada transição está associada a um valor, ou seja a um único evento.

Em SAN as transições estão associadas a eventos, ou seja, cada transição pode possuir vários eventos.

Considerando que cada evento em uma SAN corresponde a pelo menos uma transição em MC, pode-se utilizar as métricas empregadas em MC (distância Euclidiana e discriminante de Kullback), realizando uma comparação baseada em eventos.

Nesta seção a métrica de cálculo do índice de cobertura baseado em trajetórias é formalizada.

Ela compreende a resolução do modelo SAN ou MC e, com base no vetor de probabilidades dos estados do modelo, são calculadas as probabilidades de cada caso de teste.

Um caso de teste compreende um conjunto de passos, os quais para cada um dos passos é calculada a sua probabilidade.

Desta forma, com à probabilidades de todos os casos de teste de uma test suite, obtemos um índice que indica o percentual de cobertura.

Cabe ressaltar que a resolução do modelo SAN ou MC nos dá um vetor de probabilidades estacionário para o cálculo da métrica, ou seja, onde o tempo tende ao infinito.

Uma das alternativas estudadas no decorrer desse trabalho foi a utilização da análise transiente, no entanto verificou-se que tal abordagem não seria adequada para o teste estatístico.

Mesmo assim, a análise transiente mostrou-se útil como índice de desempenho de sistemas tolerantes a falhas, onde o tempo é um fator extremamente relevante.

A métrica proposta tem como base as probabilidades dos estados atingíveis do modelo, ou seja, quando se está em um estado e calcula-se a probabilidade de se chegar a outro estado, tem-se a probabilidade de um passo, ou trajeto, com relação ao funcionamento do sistema, já que consideramos as probabilidades dos estados.

Considere U = {T1,T2,TM} como um test suite composto de M casos de teste, onde Ti é o caso de teste de índice i.

Um caso de teste é uma seqüência composta de N transições de estados do modelo, ou seja, é uma seqüência de uso do software modelado.

Casos de teste (ou trajetórias) são basicamente representados por uma seqüência de estado-transição-estado (passo).

A partir do estado inicial de um passo é possível encontrar seus estados finais através da execução dos eventos.

Formalmente um caso de teste é uma estrutura (S,E), onde S = {S1,S2,SN+1} corresponde a um conjunto ordenado de estados globais (SAN) ou estados (MC).

E = {E1,E2,EN} corresponde a um conjunto de eventos (SAN) ou transições (MC).

Considera-se que uma trajetória é composta por uma quantidade de passos finita e conhecida, onde assume-se os seguintes axiomas.

Cada passo é composto por um estado inicial i e um estado final k.

Estando no estado i é possível ir para qualquer um dos seus estados sucessores.

Para a probabilidade do passo considera-se que estando no estado i então um evento (ou transição) é executado para o estado k.

Assim, como mencionado, uma trajetória é composta por passos e cada passo tem uma probabilidade s.

Tal probabilidade é a ocorrência de uma transição do iesimo para iesimo + 1 estado e é dada.

A probabilidade de um caso de teste é o produtório de todas as probabilidades dos passos si (i = 1N) do caso de teste, o qual compreende uma trajetória T.

Assim, a probabilidade de um caso de teste PT é dada por uma test suite pode conter muitos casos de teste replicados.

Entretanto é necessário considerar apenas casos de teste distintos para avaliar a cobertura de uma test suite.

O número de casos de teste distintos D pode ser menor ou igual ao número total de casos de teste M.

Desta forma, o percentual de cobertura C de uma test suite U é calculada pela soma da probabilidade de todos os casos distintos.

Observa-se que a partir de um modelo pode-se gerar infinitos casos de teste, logo o cálculo da cobertura C de um test suite é assintótico, ou seja, o índice de cobertura pode ser perto mas nunca igual a 1.

Para verificar a qualidade da geração de casos de teste, utiliza-se a distância Euclidiana e o discriminante de Kullback, ou seja, dois vetores são comparados, vetor de probabilidades F e o vetor de freqüências dos casos de teste s.

O vetor de probabilidades F é obtido a partir de uma test suite e contém apenas as probabilidades dos casos de teste distintos, ou seja, o vetor de probabilidades F é composto por D probabilidades, onde a cardinalidade do vetor de probabilidades é dada por |F| = D e D = M.

O vetor de freqüências s é também composto por D probabilidades.

Estas probabilidades são computadas a partir da freqüência dos casos de teste replicados do test suite.

Após a normalização, que é dada pela contagem de casos de teste replicados sobre o total de casos de teste gerados, obtém-se o vetor de freqüência T (summationtextDi=1Ti = 1).

O vetor de freqüência pode ser utilizado para a verificação dos casos de teste replicados.

No entanto, justifica-se gerar casos de teste replicados somente se aspectos do ambiente (sistema operacional, browser, etc) são considerados.

A análise dos casos de teste replicados não será considerada nesta dissertação, ou seja, o trabalho realizado procura avaliar e calcular a probabilidade de um conjunto de casos de teste.

O cálculo do índice de cobertura pode ser visto no Algoritmo 1.

Basicamente o algoritmo percorre todos os casos de teste, para cada um são calculados todos os passos resultando na probabilidade de um caso de teste.

A soma da probabilidade de todos os casos de teste corresponde ao índice do percentual de cobertura baseado em trajetórias.

Seguindo o exemplo do Sistema de Login, esta seção demonstra o cálculo da métrica a fim de exemplificar como a mesma é calculada.

Cabe ressaltar que as taxas para esse modelo foram atribuídas de maneira arbitrária por se tratar de apenas um exemplo utilizado para demonstrar o processo de construção de um modelo de uso e a aplicação da métrica de cálculo do índice de cobertura.

O exemplo do cálculo da métrica será apresentado com base no modelo SAN da aplicação login.

No entanto, pode-se aplicar a métrica da mesma forma para o modelo MC sem qualquer perda de informação ou alteração no resultado final.

Baseado nas taxas da aplicação, o modelo é descrito em formato textual o qual será a entrada para o software PEPS.

Probabilidade dos estados atingíveis, Sistema de Login.

Cada um dos estados globais da SAN equivale a um estado da MC correspondente, ou seja, tendo a descrição formal da aplicação em SAN ou MC pode-se calcular a métrica.

Observa-se também que as probabilidades somam 1 e elas dependem das transições e taxas associadas aos eventos.

As probabilidades de cada estado e a matriz HBF são utilizadas para automatizar e calcular o índice de cobertura.

Além destes arquivos são necessários os casos de teste gerados, os quais possuem a estrutura mínima (estado global, evento, estado global).

O primeiro passo a ser realizado é calcular a probabilidade de cada caso de teste, e para isso calculamos a probabilidade de todos os passos do caso de teste, ou seja, o conjunto de estados globais (SAN) ou estados (MC).

Seguindo o exemplo do sistema de Login, vamos assumir o caso de teste seguindo a estrutura estado global-evento-estado global (Start,Waiting)st(Password,Waiting)s(Menu,POK)qt(Start,Waiting).

Tendo o caso de teste o qual se deseja saber a probabilidade, a proxima etapa corresponde a determinar a probabilidade de cada um dos passos do caso de teste, ou seja, precisamos saber a probabilidade de estando no estado (Start, Waiting) ir para o estado (Password, Waiting), do estado (Password, Waiting) para o estado (Menu, POK), e do estado (Menu, POK) para o estado (Start, Waiting).

Estado global (Start, Waiting) executando o evento st para o estado global (Password, Waiting).

Estado global (Password, Waiting) executando o evento s para o estado global (Menu, POK).

Estado global (Menu, POK) executando o evento qt para o estado global (Start, Waiting).

Após o cálculo de cada passo que compõe o caso de teste, a probabilidade do caso de teste é dada pelo produto de cada passo.

Assim, são calculada todas as probabilidades dos casos de teste que compõem uma test suite.

Apresenta a test suite com dez casos de teste e suas respectivas probabilidades.

Portanto o índice de cobertura baseado nas trajetórias é dado pelo somatório de todas as probabilidades dos casos de teste, que neste caso corresponde a 09970, ou seja, pode-se dizer o conjunto de casos de teste gerados cobrem 99,70% da aplicação modelada.

Probabilidade dos casos de teste, Sistema de Login.

Observa-se o índice de cobertura convertido em percentual para a test suite gerada.

Nota-se que os casos de teste onde o usuário da aplicação login erra muitas vezes ao logar, acabam tendo uma probabilidade muito pequena.

Índice de cobertura, Sistema de Login.

Com o objetivo de validar a métrica foram gerados test suites para os estudos de caso realizados.

Desta forma, procurou-se verificar o índice de cobertura dos casos de teste gerados.

O índice é expresso em percentual e para a aplicação Simple Counter Navigation gerou-se test suites de 100, 500 e 1000 casos de teste.

Para as outras duas aplicações, Calendar Manager e Docs Editor, foram gerados test suites de 100, 500, 1000 e 5000 casos de teste.

Cada caso de teste possui no máximo 40 passos, ou seja 40 conjuntos de estados globais e eventos.

É importante ressaltar que são computados a probabilidade apenas dos casos de teste únicos, ou seja em um conjunto de 100 casos de teste apenas as probabilidades dos casos de teste únicos são calculadas considerando que muitos dos casos de teste gerados são replicados.

Foram utilizados para o cálculo da métrica vetores com probabilidades estacionárias dos estados atingíveis do modelo, ou seja, as probabilidades dos estados são dadas em um tempo não determinado.

Para a aplicação Simple Counter Navigation, o Gráfico 62 apresenta o resultado para as test suites geradas.

Observa-se que foram gerados apenas três conjuntos de casos de teste, pelo fato de ser uma aplicação simples e desta forma os conjuntos gerados mostraram-se com uma cobertura superior a 99%.

São apresentados os valores do gráfico.

Observa-se que a diferença entre a geração de 100 e 500 casos de teste para a aplicação Simple Counter Navigation é pequena, menor que 1%.

Assim, podemos observar que mais casos de teste com probabilidades muito pequenas são gerados.

Para esta aplicação uma amostra com 100 casos de teste já corresponde a um índice superior a 84%, o que pode ser considerado uma amostra relevante para um conjunto pequeno de casos de teste.

Índice de cobertura, Simple Counter Navigation.

Para a aplicação Calendar Manager, o Gráfico 63 apresenta o resultado para as test suites geradas, e são apresentados os valores do gráfico.

Diferentemente da aplicação Simple Counter Navigation, a aplicação Calendar Manager possui um modelo um pouco maior e uma quantidade elevada de eventos em seu modelo.

Desta forma precisa-se gerar uma quantidade maior de casos de teste para se obter um índice de cobertura satisfatório.

Entende-se por índice satisfatório um valor acima de 99%, que indica que todos os casos de teste com probabilidades maiores foram gerados.

Observa-se também, que a grande quantidade de eventos do modelo acaba criando a necessidade de se gerar mais casos de teste para se obter um índice de cobertura elevado.

Desta forma, pode-se concluir que não somente o acréscimo de estados no modelo como também o acréscimo de eventos, exigem a geração de um maior número de casos de teste.

Índice de cobertura, Calendar Manager.

Para a aplicação Docs editor, o Gráfico 64 apresenta o resultado para as test suites geradas.

Para esta aplicação, como se tem um modelo consideravelmente maior que os demais apresentados, gerou-se um conjunto de 5000 casos de teste para se conseguir um índice de cobertura superior a 99%.

Cabe ressaltar que a geração é feita de forma automática e, conforme apresentado no capítulo anterior, a geração é eficiente e a diferença de tempo de geração é mínimo para um conjunto de 100 e 5000 casos de teste.

Valores, Docs Editor.

Índice de cobertura, Docs Editor.

Para os resultados obtidos com a aplicação da métrica proposta, observa-se que os valores correspondem ao índice de cobertura e são apresentados em percentual.

Assim, os resultados mostraram que a eficiência do gerador de casos de teste e a qualidade dos casos de teste, ou seja, casos de teste muito pequenos, como por exemplo entrar e sair da aplicação, e casos de teste muito grandes, onde o usuário fica inúmeras vezes entrando e saindo em uma mesma tela, possuem uma probabilidade pequena.

Através da métrica proposta podemos estimar facilmente a cobertura de uma test suite.

Desta forma, podemos gerar apenas um conjunto de casos de teste que corresponda a uma probabilidade de cobertura desejável.

Uma outra vantagem é a economia de tempo e a execução de melhores testes, ou seja, sabendo o índice de cobertura de uma determinada test suite precisaremos apenas executar uma vez.

Desta forma estaremos executando uma amostra estatisticamente relevante.

O presente trabalho apresentou uma análise quantitativa da geração de casos de teste baseado nos estudos de caso realizados, assim, pode-se evidenciar vantagens e desvantagens de ambos os formalismos (Cadeias de Markov (MC) e Redes de Autômatos Estocásticos (SAN)) tanto na construção dos modelos de uso quanto na geração dos casos de teste para a ferramenta STAGE-Test.

Desta forma, surgiu a necessidade de estimar com maior precisão a qualidade da geração de casos de teste.

Como principal contribuição desse trabalho é proposta uma métrica que visa verificar a relevância de um determinado conjunto de casos de teste, determinando assim, a probabilidade de cobertura de uma test suite.

Neste capítulo são apresentadas as conclusões referentes ao trabalho desenvolvido, abordando o desenvolvimento dos modelos de uso com MC e SAN, a geração dos casos de teste e a métrica de cálculo do índice de cobertura.

Por fim, são apresentados alguns possíveis trabalhos futuros.

A construção dos modelos de uso utilizando MC é bastante difundida na literatura, no entanto, apresenta algumas limitações por descrever uma aplicação como um único conjunto de estados e transições.

Desta forma, a medida que estados e transições são inseridas, além de aumentar a complexidade do modelo, a visualização e manutenção dos estados e transições torna-se cada vez mais oneroso.

Como as SAN são equivalentes às MC e tudo que se pode definir formalmente com MC pode-se definir com SAN, as SAN representam uma excelente alternativa para a construção de modelos de uso com uma grande quantidade de estados.

Um dos pontos a serem observados, é visto nos estudos de caso, onde para a aplicação Docs Editor a utilização de SAN possibilita uma melhor manutenção e visualização do modelo, considerando que a MC correspondente possui 417 estados.

No segundo estudo de caso, a aplicação Calendar Manager, apesar de possuir uma quantidade pequena de estados, possui uma grande quantidade de transições, o que torna o modelo SAN mais legível e de fácil manutenção.

No entanto quando os modelos possuem uma quantidade de estados e transições pequena, ambos os formalismos podem ser utilizados sem um apresentar vantagens consideráveis em relação ao outro.

Portanto, podemos perceber com os estudos de caso realizados que, a medida que a complexidade e tamanho das aplicações aumentam, a utilização das SAN acrescenta qualidade aos modelos, e torna-se uma melhor opção com relação às MC.

O processo automatizado de teste estatístico descrito neste trabalho consiste na construção de casos de uso e geração de casos de teste e scripts.

Assim, um dos trabalhos realizados nessa dissertação consistiu em realizar uma avaliação quantitativa dos casos de teste gerados com a finalidade de verificar a qualidade do gerador de casos de teste e a qualidade da geração.

Observou-se que o gerador de casos de teste (STAGE-Test) é eficiente, gerando casos de teste de forma rápida conforme visto nos gráficos de tempo de geração.

Eficiência na geração de casos de teste é uma característica desejável no teste estatístico, considerando que às vezes torna-se necessário gerar uma grande quantidade de casos de teste.

Podemos concluir que o gerador de casos de teste atende perfeitamente às expectativas do teste estatístico quanto à eficiência.

Nesse sentido, observou-se também que o tempo de geração em MC tende a ser mais rápido devido ao fato das MC possuírem uma estrutura mais simples do que as SAN.

Outra característica importante a ser observada na geração dos casos de teste consiste na diversidade de geração, ou seja, quanto mais casos de teste diferentes forem gerados, maior será a possibilidade de encontrar falhas.

A diversidade de geração influencia diretamente na qualidade do teste e por conseqüência do produto final.

Portanto, constatou-se que os dois algoritmos de geração de casos de teste, baseado em MC e em SAN, possuem qualidade na geração, sendo que a implementação em SAN consegue-se gerar mais casos de teste distintos do que a partir da MC.

As métricas de qualidade utilizadas em MC, como as métricas de comparação de vetores, acabam não se aplicando da mesma forma em SAN, mesmo os formalismos sendo equivalentes.

Isto ocorre pelo fato que essas técnicas são baseadas na freqüência de transições das MC, e em SAN as transições não são associadas a taxas, mas a eventos que por sua vez agregam uma semântica diferente às transições.

A métrica proposta baseou-se na probabilidade dos estados do modelo, ou seja, considera-se que o modelo tenha sido resolvido e por sua vez os passos em uma MC ou SAN podem ser calculados com base na probabilidade do estado que se deseja chegar e todos as suas alternativas (estados alcançáveis).

Desta forma, foi formalizada uma métrica chamada de Índice de Cobertura Baseada em Trajetórias.

Assim, assumindo uma determinada test suite, a métrica fornece a probabilidade de cobertura dos casos de teste.

Observou-se nos resultados para os estudos de caso realizados, que as test suites geram um índice de cobertura satisfatório, ou seja, com uma probabilidade maior que 99%.

O que observou-se é que casos de teste muito grandes, ou muito pequenos, possuem uma probabilidade muito pequena, o que corresponde à realidade.

Assim, podemos concluir que a geração de casos de teste pode ter uma cobertura satisfatória se levarmos em conta a probabilidade calculada pela métrica de índice de cobertura baseada em trajetórias.

Um dos pontos a serem observados é tendo uma métrica que nos possibilita saber o índice de cobertura de uma determinada test suite, podemos facilmente definir um critério de parada, ou seja, definir um número de casos de teste par uma determinada aplicação que seja suficiente para garantir qualidade e confiabilidade.

Por exemplo, podemos admitir que nosso critério de parada é de 90%, desta forma, quando uma test suite possuir um índice de cobertura igual ou superior a 09, isso nos indica que podemos parar de gerar casos de teste.

A métrica de índice de cobertura baseada em trajetórias foi utilizada primeiramente para a avaliação de test suites, no entanto, os algoritmos estatísticos de geração de casos de teste poderiam incorporá-la no sentido de melhorarem sua qualidade de geração.

Os resultados da métrica de qualidade foram obtidos utilizando um vetor de probabilidades estacionário, ou seja, considera-se as probabilidades dos estados como se o sistema estivesse em funcionamento por um período indeterminado de tempo.

No entanto, pode-se facilmente obter os resultados da métrica utilizando um vetor de probabilidades transientes, ou seja, considerando as probabilidades dos estados do sistema como se ele estivesse em funcionamento por um período de tempo determinado.

Desta forma, para sistemas críticos ou tolerantes a falhas que necessitem estar em funcionamento sem falhas por um determinado período de tempo, poderia-se gerar conjuntos de casos de teste com índices de cobertura mais reais ao funcionamento do sistema.

Outro fator importante a se destacar são as métricas e critérios de parada utilizadas na literatura, que no geral avaliam apenas a execução dos scripts e não a geração dos casos de teste, como o que está sendo proposto.

Assim, podemos concluir que a métrica proposta poderia ser utilizada também como indicativo de eficiência na execução dos scripts e confiabilidade.

Através desta dissertação surgem vários trabalhos futuros no sentido de complementar e dar continuidade ao trabalho realizado.

Primeiramente, surge a necessidade de execução dos scripts no sentido de verificar a relação entre a eficiência do índice de cobertura e as falhas encontradas.

A aplicação de novas métricas para o cálculo do índice de cobertura, por exemplo, a utilização de Cadeias de Markov Embutidas (EMC).

As EMC consistem em transformar uma CTMC para uma Cadeia de Markov de Tempo Discreto1 (DTMC, Discrete Time Markov Chains).

Desta forma, poderiam ser utilizadas apenas as taxas do modelo para o cálculo de uma nova métrica.

Neste sentido, teoricamente a métrica apresentada nesta dissertação tende a ser melhor por considerar as trajetórias de um estado até outro baseado no funcionamento de todo o sistema (probabilidades do modelo).

As ferramentas de suporte ao teste estatístico utilizadas poderiam fazer uso da métrica.

O gerador de casos de teste STAGE-Test poderia utilizar a métrica como uma opção para estimar se a test suite gerada é suficiente.

Como sabemos estimar a cobertura de uma determinada test suite, então, poderia-se utilizar a métrica como base para a construção de uma nova ferramenta, ou seja, novos algoritmos de geração de casos de teste estatísticos.

Desta forma, a geração não seria mais randômica, mas os algoritmos poderiam incorporar a métrica tanto na geração quanto como um critério de parada.

Por fim, poderia-se formalizar todo o processo de teste estatístico desde a construção dos modelos de uso até a execução dos scripts em sistemas de missão crítica.

Com relação aos modelos MC e SAN, poderíamos considerar futuramente a inclusão de pontos de dados.

Ou seja, estados que poderiam assumir diferentes valores.

Por exemplo, se considerarmos uma tela com um campo text-box onde o usuário pode entrar com qualquer tipo de caracter (string, números, caracteres especiais, etc).

Cada tipo de caracter também poderia estar sendo validado se considerarmos este estado como um ponto de dados.

Outras formas de verificação também podem ser utilizadas no teste de software.

Um importante trabalho futuro que também pode se tornar útil na verificação de erros em aplicações seria utilizar verificação formal através de técnicas de model checking.

Assim, como trabalho futuro pode-se pesquisar técnicas de model checking em SAN.

