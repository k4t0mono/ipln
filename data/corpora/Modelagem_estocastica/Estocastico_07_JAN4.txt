No presente trabalho, direcionamos nossos estudos à questão de se encontrar evidências estatísticas na detecção de ritmos em textos escritos, apresentando para isso ferramentas probabilísticas que nos permitam discriminar textos brasileiros e portugueses.

Para alcançarmos tais objetivos, abordamos alguns resultados teóricos e práticos em modelagem, reamostragem e estimação das cadeias de Markov de alcance variável.

Sendo que na parte de reamostragem, propomos um novo método para conjuntos de dados com um ponto de renovação.

Existem muitos estudos na área da Lingüística que tem como interesse analisar as diferenças entre o Português Brasileiro e o Português Europeu (abreviados aqui por PB e PE respectivamente).

A língua portuguesa moderna é uma língua particularmente interessante para ser estudada pois tanto o PB quanto o PE, apresentam o mesmo conjunto de palavras em sua estrutura (léxico).

No entanto, estas línguas apresentam diferentes sintaxes e diferentes prosódias, isto é, não só ordenam as suas palavras de maneiras diferentes como também implementam sentenças com ritmos diferenciados.

O objetivo principal deste trabalho, está relacionado à questão de se encontrar evidências estatísticas na detecção de ritmos em textos escritos, apresentando para isso ferramentas probabilísticas que permitam discriminar textos brasileiros e portugueses modernos, com base na codificação das sílabas em relação às suas propriedades prosódicas.

Serão analisadas 80 reportagens de jornais contemporâneos, 40 reportagens do jornal brasileiro Folha de São Paulo, e 40 reportagens do jornal português Público, dos anos 1994 e 1995.

Mais especificamente, dada uma seqüência de variáveis aleatórias definidas como função dos textos escritos, tomando valores em um alfabeto finito A, tentamos predizer cada novo símbolo Xn como função do passado.

Dentro deste contexto teórico, pode-se assumir que o passado relevante tem um tamanho finito e fixo k (k 2 N), para qualquer nv.

Os processos que apresentam esta propriedade são denominados cadeias Markov de ordem k.

Um aspecto inerente a este modelo, porém desvantajoso, é que o número de parâmetros a serem estimados cresce exponencialmente com a ordem da cadeia.

Utilizando do fato de que a ordem da cadeia pode não ser um valor fixo k, Rissanen propôs então um modelo cuja a ordem da cadeia varia de acordo com o passado (contexto), isto é, as cadeias de Markov de alcance variável.

O nome contexto se refere à porção do passado que influencia a probabilidade de transição do próximo símbolo.

Um procedimento de estimação para as cadeias de Markov de alcance variável, chamado de algoritmo Contexto, foi proposto inicialmente por Rissanen.

Posteriormente, trabalhos abordando a convergência de tal algoritmo, popularizaram tal procedimento na literatura estatística.

Recentemente, deram uma majoração para a velocidade de convergência do algoritmo Contexto para cadeias de alcance variável não limitadas.

O interessante desta classe de modelos, é que para se decidir sobre o próximo estado da cadeia, em vez de considerarmos todo o passado, consideramos apenas a parte do passado que é relevante, chamado por Rissanen de contexto.

A teoria e resultados que serão apresentados neste trabalho, foram organizados e serão relatados a seguir.

Iniciamos o Capítulo 2 introduzindo os conceitos básicos de cadeia de Markov de alcance variável, ressaltando o modelo probabilístico e abordando algumas definições importantes.

O problema mais interessante desta parte, é relacionado à estimação das árvores de contexto.

Existem basicamente dois tipos de algoritmos locais para se solucionar tal problema, sendo eles o algoritmo Contexto e o PST.

Apresentaremos também os critérios -AIC- e -BIC-, que são importantes e bem conhecidos na literatura estatística e utilizados na seleção de modelos, ou seja, uma ferramenta de estimação global.

Finalizaremos este capítulo, simulando ambos os algoritmos buscando obter o melhor método para a estimação dos contextos relevantes em nosso conjunto de dados.

Em seguida, no Capítulo 3, apresentamos algumas maneiras presentes na literatura para se fazer reamostragem para Cadeias de Markov.

Abordaremos também o método que está sendo proposto neste trabalho, para reamostragem de um conjunto de dados que apresenta um ponto de renovação.

Trabalharemos com algumas estimações estatísticas, afim de estudar o comportamento de nosso método de reamostragem perante a alguns métodos já conhecidos.

Logo após, já no Capítulo 4, mostramos toda a parte de coleta dados, abordando a maneira com a qual estes foram coletados.

Apresentamos também as árvores estimadas pelo algoritmo Contexto com critérios de seleção AIC e BIC, referentes ao nosso conjunto de dados.

Ainda neste capítulo, abordamos o teste proposto por Busch, Ferrari, Flesia, Fraiman, Grynberg e Leonardi, no qual a estrutura média que caracteriza duas amostras de populações distintas de árvores de PB e PE, são comparadas buscando-se testar se a diferença entre essas estruturas são estatisticamente significantes para rejeitarse uma igualdade de distribuição.

Prosseguimos, abordando os resultados obtidos no teste de hipótese realizado em nosso conjunto de dados, quando ajustamos as árvores utilizando o algoritmo Contexto com critérios de seleção AIC e BIC.

Finalizamos este capítulo apresentando um teste de hipótese para uma cadeia de Markov de alcance variável sob reamostragem, utilizando o método proposto neste trabalho.

Finalmente, reservamos para o Capítulo 5 algumas conclusões importantes obtidas na realização desse estudo.

A noção de cadeia de Markov de alcance variável, foi introduzido por Rissanen para referir-se a cadeias de Markov de ordem finita, onde a memória da cadeia é uma função dos valores passados.

No entanto, não há necessidade de restringir a ordem da cadeia, pois as definições tomam sentido perfeito para cadeias de ordem ilimitada, chamadas por -cadeia de ordem infinita-.

Neste capítulo, para melhor compreensão deste contexto teórico, abordaremos alguns conceitos básicos sobre cadeias de Markov de alcance variável, bem como alguns métodos de estimação.

Primeiramente, consideraremos aqui um alfabeto A como sendo qualquer conjunto finito formado por símbolos.

Por exemplo, A pode ser um espaço de estado discreto e finito de um processo estocástico.

Quando k = 1 teremos uma cadeia de ordem infinita, mais precisamente, o símbolo -1- indica a não possibilidade de se limitar a ordem cadeia.

Considere uma cadeia de Markov estacionária (Xt)t2Z de ordem k com valores em um alfabeto A com jAj < 1.

Nós denotaremos as variáveis aleatórias por letras maiúsculas, os valores determinísticos fixados por letra minúscula.

Para introduzir a idéia de memória de tamanho variável, para uma cadeia de Markov de alcance k.

A interpretação é representar o número de passos anteriores que devemos observar para escolher o próximo símbolo.

Esta definição exclue o caso independente.

A função C é denominada função contexto e o vetor resultante é chamado contexto.

Note que a ordem em que são escritos os símbolos no contexto é inversa a ordem em que aparecem na expressão.

O nome contexto se refere à porção do passado que influencia a probabilidade de transição do próximo símbolo.

De agora em diante, k denotara também a ordem da função contexto.

Nós formalizaremos a seguir, o conceito de uma cadeia de Markov de alcance variável.

Seja uma cadeia de Markov estacionária, tomando valores A, sua função contexto correspondente definida por (2,1,4).

Então será denominada cadeia de Markov de alcance variável de ordem k.

Claramente, uma cadeia de Markov de alcance variável de ordem k é uma cadeia de Markov estacionária de ordem k.

Para efeito de notação, vamos denotar o conjunto de todas as probabilidades de transição de um símbolo xt 2 A por P, onde os valores obtidos pela função contexto C representam todos os estados que determinam estas probabilidades.

Pela exigência de estacionariedade, a distribuição de probabilidade P de uma cadeia de Markov de alcance variável é completamente especificada pelas probabilidades de transição.

Desta forma, um modo conveniente de representar estes estados, o espaço de estado minimal, é a representação por árvores (árvores de contexto).

Note que a função contexto satisfaz a propriedade do sufixo, isto é, nenhum contexto é um sufixo de outro contexto.

Portanto, se é um contexto então nenhuma das subseqüências é um contexto.

Sendo assim, devido a esta propriedade, a função contexto pode ser representada por uma árvore construída da seguinte maneira.

Raízes no topo.

Ramos crescem para baixo.

Todo nó interno tem no máximo j A j descendentes.

O contexto u é representado por um ramo, cujo o sub-ramo do topo é determinado, o próximo sub-ramo é determinado e assim sucessivamente.

O último pedaço de cada ramo é chamado terminal.

Ressaltamos ainda que as árvores de contexto não necessitam ser completas, isto é, seus nódulos internos não necessitam ter necessariamente j A j sub-ramos.

De maneira mais formal, definiremos a seguir o que será uma árvore no contexto em que estamos trabalhando, bem como algumas de suas propriedades.

Uma árvore com finitos galhos será definida como um subconjunto contável, que satisfaça a propriedade do sufixo, isto é, para nenhum ws.

O tamanho de uma árvore será dada por j.

Uma árvore com número finitos de galhos será dita completa se define uma partição.

Cada elemento da partição coincide com o conjunto das seqüências tendo wk 1 como sufixo, para algum wk.

Dizemos que uma árvore é ilimitada se o conjunto é contável e infinito, portanto teremos que a função alcance é ilimitada.

Esta seção tem como objetivo a descrição do algoritmo Contexto.

Dada uma amostra de uma cadeia de Markov de alcance variável, a intenção aqui é a de estimar a função contexto, assim como as probabilidades de transição correspondentes.

Cabe lembrar que provaram a consistência de uma versão do algoritmo Contexto (versão que será exemplificada nesta seção e utilizada neste trabalho), e que este resultado foi posteriormente generalizado, para o caso de cadeias de memória ilimitada.

A estratégia do algoritmo é a seguinte.

Primeiro, uma árvore maximal (completa) é produzida, cuja construção considera todos os ramos que possuem um comprimento pré-estabelecido e que aparecem um número mínimo de vezes na amostra (uma condição inicial a ser determinada para execução do algoritmo).

A árvore obtida nesse primeiro processo representa um modelo de cadeia de Markov de alcance variável super dimensionada.

Como o espaço A é finito, não há nenhum problema sofisticado em construir tal árvore, tornandose assim em um problema simples e computacionalmente rápido.

Em segundo lugar, o algoritmo utiliza um procedimento passo a trás (-backward-, de baixo para cima) na poda da árvore, usando para isso um critério de decisão de poda.

Esse procedimento de poda é efetuado em cada coordenada do contexto testado.

Seja C uma função contexto de uma cadeia de Markov de alcance variável tomando valores em um alfabeto A, a árvore de contexto e a árvore de contexto de nó terminal serão definidas.

De modo geral, a definição acima diz que somente nós terminais da árvore representada por serão considerados elementos da árvore de contexto de nó terminal T e os estados w 2 não necessitam ser nós terminais.

Considere uma cadeia de Markov estacionária de ordem 2, tomando valores no alfabeto.

Apresentaremos aqui a função contexto de uma árvore esparsa de nó terminal, tomando valores em um alfabeto A.

Como poderemos notar, a árvore esparsa é um exemplo de uma cadeia de Markov de alcance variável de ordem infinita.

Se é uma amostra consistente com a distribuição de probabilidade de um processo estocástico, diremos então que esta é um realização de tal processo.

Consideremos agora uma realização de uma cadeia de Markov de alcance variável, ou seja, uma seqüência tomando valores no alfabeto A.

A seguir descreveremos o método através de quatro passos, e em seguida observaremos alguns aspectos inerentes ao método que julgamos serem importantes.

Passo(1).

Dado o conjunto de dados A, ajustamos uma árvore de contexto maximal T max, que consiste da maior árvore tal que todo elemento (um nó terminal) foi observado no mínimo um número s de vezes nos dados (no modelo proposto originalmente temos que s = 2).

Sendo assim, considere então a função contexto correspondente a esta árvore de contexto maximal.

Uma propriedade interessante desse operador é que ele é sempre não negativo e é zero.

Denote agora a função de verossimilhança estimada (condicionada no primeiro estado), baseada em uma função contexto C, onde k é a ordem de C.

Considere ainda C a função contexto de uma árvore de contexto não podada e a função contexto de uma sub-árvore, podada em um nó terminal, substituído por wr.

Pela estrutura multiplicativa, alguns termos se cancelam na estatística de razão de verossimilhança restando somente os que são considerados nós terminais pela poda.

Portanto, a formula nos diz que o nosso critério de poda é nada mais que um teste de razão de verossimilhança, com região de aceitação para a poda da sub-árvore dada.

O valor da interrupção Dn no passo(2), que é o ponto escolhido para a decisão da poda, é escolhido com base em uma consideração assintótica.

Para toda árvore , a ordem na qual são testados os nós terminais nos passos (2) e (3) é irrelevante.

Se nós interpretarmos o passo (2), visto anteriormente, como um teste de razão de verossimilhança, teremos claramente que pontos de corte pequenos resultarão em árvores de contexto maiores e a ocorrência de um ajuste superestimado.

Como este é um parâmetro unidimensional, a otimização com relação a interrupção (do corte) é um problema relativamente fácil.

Com o objetivo de resolver tal problema, indicaremos dois métodos de seleção de modelos muito conhecidos na literatura.

Os critérios AIC e BIC serão utilizados com o intuito de escolher o modelo que melhor se ajusta aos dados.

Os critérios podem ser descritos para o problema de seleção de árvores de contexto pela função, onde j é o número de parâmetros livres (probabilidades de transição) da árvore estimada, e finalmente log-verossimilhança(Dn) é o valor da verossimilhança estimada dada, quando o ponto de corte é igual a Dn.

O objetivo destes critérios ao estimar o ponto de corte é minimizar a divergência de Kullback-Leibler, portanto, o melhor modelo a ser considerado é aquele que apresentar menor valor na função AIC ou BIC conforme a escolha do critério a ser utilizado.

Cabe ressaltar ainda, que no critério BIC a penalização não é uma constante, mas variável de acordo com o tamanho da amostra.

Temos também, que utilizando o BIC no conjunto de todas as árvores possíveis, obtemos um estimador consistente para a ordem da cadeia.

Trabalharemos com algumas simulações do algoritmo de contexto, apresentado alguns fatos importantes inerentes ao mesmo.

Maiores detalhes e motivações a respeito do algoritmo Contexto.

Nesta seção descreveremos o método PST (do inglês Probabilistc suffix trees) de estimação de árvores introduzido, que mesmo tendo os mesmos traços do algoritmo de contexto (quando utilizamos um alfabeto finito e contendo elementos uni-dimensionais), pode ser diferenciado por dois fatos importantes.

O primeiro é que o algoritmo PST constrói a árvore e vai realiza os testes entre as distribuições de maneira simultânea.

Porém essa diferença não é muito relevante, já que ambas as maneiras, utilizando uma mesma decisão de corte, devolvem a mesma árvore estimada.

A outra diferença, é que o critério utilizado na comparação das distribuições está baseado em uma razão entre medidas e um critério suavizador, e não em um divergente (Kullback-Leibler) ou no teste da razão de verossimilhança como era feito anteriormente.

O algoritmo PST é composto por cinco parâmetros externos que devem ser definidos pelo usuário.

O comprimento da memoria (isto é, o tamanho máximo de um vetor na árvore).

A probabilidade mínima em que uma seqüência de dados deve ocorrer na amostra, que será uma simples medida de diferença entre o candidato predito e seu -Pai-, que é um fator suavizante do corte e que junto com o fator suavizante definem um ponto inicial para a condição de aparecimento do símbolo.

Considere que denote uma árvore de contexto constituída somente da raiz e o conjunto de todos os vetores possíveis que devemos testar (vetores que começam com comprimento 1 e variam até o comprimento L).

O procedimento de construção da árvore de contexto estimada consiste na seguinte rotina.

Enquanto S, tomamos w (começando pelos de comprimento 1 e aumentando o tamanho gradualmente), e diremos que w será considerado elemento da árvore gerada pelo algoritmo se existir um A.

Assim vamos sobrepondo os vetores e construindo a árvore de contexto estimada.

O objetivo principal desta seção, é estudar através de simulações o comportamento dos dois algoritmos apresentados neste capítulo para estimação de árvores de contexto.

Para tal análise utilizaremos basicamente dois tipos de conjuntos de dados.

O primeiro tipo de conjunto de dados, que chamaremos de Conjunto 1, é uma parte da amostra a ser considerada no Capítulo 4, com alfabeto dado pelo conjunto A.

O interessante de tal conjunto de dados é que nem todas as transições são possíveis, como por exemplo a do símbolo 4 para o 1.

O outro tipo de conjunto de dados utilizado refere-se a dados gerados de uma cadeia esparsa.

Considere uma cadeia de alcance variável tomando valores no alfabeto uma cadeia esparsa, se suas probabilidades de transição são dadas.

O processo perde memória cada vez que alcança o símbolo 1 e recomeça novamente, assim esta cadeia é composta por blocos independentes de zeros delimitados por 1s.

O interessante desse conjunto de dados, é que todas as transições são possíveis e que sabemos qual é a estrutura da árvore gerada.

Começaremos nosso estudo analisando as árvores estimadas pelo algoritmo Contexto, quando aplicamos os critérios de seleção de modelos (AIC e BIC).

O uso desses critérios procederá da seguinte maneira.

Variamos de 0,01 em 0,01 um dos parâmetros de corte, começando pelo valor Â2 e encerrando quando este atingir um acréscimo de vinte unidades, isto é, para cada novo valor de D uma árvore é estimada pelo algoritmo de contexto e o valor do critério de seleção é calculado.

Ao final deste processo foram estimadas 2000 árvores, e conseqüentemente, a escolhida será aquela que apresentar o menor valor no critério de seleção (AIC ou BIC).

No decorrer das simulações que realizaremos, temos que no algoritmo de contexto, a quantidade mínima de vezes em que uma seqüência de dados deve aparecer (para ser testada quanto ao fato de ser um contexto), será dada pelo valor 5.

Esse valor será tomado para todas as realizações do algoritmo Contexto nesta seção.

Apresentamos a árvore estimada pelo algoritmo de contexto em um conjunto de dados do -Conjunto 1- (tamanho n=2500), utilizando ambos os critérios de seleção de modelos.

Ou seja, obtivemos a mesma árvore estimada na adoção dos critérios.

Cabe ressaltar, que ao estimarmos todo o Conjunto1, obtivemos algumas poucas situações em que as árvores estimadas variavam de acordo com o critério utilizado.

Sendo que, o critério AIC acaba por construir árvores maiores, este fato pode ser presenciado com maior clareza na estimação de todo o nosso conjunto de dados.

Seguindo ainda nesta análise, utilizaremos agora dois conjuntos de dados simulados de uma cadeia esparsa, um de tamanho n = 3469 e o outro n = 2586.

Como poderemos ver, no caso em que a amostra é de tamanho n = 3469 obtivemos duas árvores de mesma profundidade, ambas tendo como raiz somente o símbolo 0, porém com o critério AIC, o símbolo 1 se ramificou, o que não deveria ocorrer em nossas estimativas.

Árvore estimada pelo algoritmo Contexto (critérios AIC e BIC).

Com o conjunto de dados esparsa de tamanho n = 2586, obtivemos o mesmo problema encontrado anteriormente, ou seja, o símbolo 1 se ramifica quando usamos o critério AIC.

Além disso, a profundidade da árvore estimada pelo critério AIC é maior em uma unidade (o que não é um problema).

Portanto, com os dados esparsa, os resultados obtidos com o critério de seleção BIC se mostraram melhores, devido ao fato de conhecermos a verdadeira estrutura da árvore esparsa, isto é, o símbolo 1 não se ramifica.

Nossa próxima análise se dará, de maneira geral, da seguinte forma.

Tomamos primeiramente uma árvore qualquer, juntamente com seu alfabeto e o conjunto de todas suas probabilidades de transição.

Utilizando da função -simulate- já estabelecida no pacote -VLMC- do programa -R-, simulamos através da árvore e de suas probabilidades de transição, um conjunto de dados (dados simulados) referente a esta.

Desta forma, podemos comparar os algoritmo propostos, já que sabemos qual será a -verdadeira- árvore referente aos dados utilizados.

Na prática, as variáveis geradas pela função -simulate-, não são nada mais que uma reamostra de uma cadeia de Markov de alcance variável ajusta.

A partir do Conjunto 1, ajustaremos cerca de 240 árvores com suas respectivas probabilidades de transição.

Utilizando do processo descrito acima que utiliza da função -simulate-, simularemos os conjuntos de dados referentes a estas 240 árvores, com tamanho igual ao do conjunto de dados que gerou a árvore na qual os dados foram simulados.

Contexto, utilizando os critérios AIC e BIC, nos dados simulados.

Para efeito de notação, iremos utilizar as seguintes situações.

Situação A, a árvore estimada com o critério AIC foi idêntica a árvore -verdadeira-.

Situação B, a árvore estimada com o critério BIC foi idêntica a árvore -verdadeira-.

Situação C, ambos os ajustes (critérios AIC e BIC) foram idênticos a árvore -verdadeira-.

Situação D, ambos os ajustes erraram, porém estimaram árvores idênticas.

Situação E, ambos os ajustes erraram, porém a estimativa do critério AIC foi melhor, onde -ser melhor- implica que o ajuste se aproximou mais da árvore -verdadeira-.

Situação F, ambos os ajustes erraram, porém a estimativa do critério BIC foi melhor.

Ajuste com o algoritmo Contexto utilizando AIC e BIC.

Um fato importante que observamos durante a construção dos ajuste da tabela, foi que critério AIC se mostrou um pouco melhor, principalmente quando trata-se de árvores maiores (grande número de parâmetro a serem estimados).

Esse fato pode ser justificado pois o critério BIC devido a sua estrutura, acaba penalizando -muito- árvores maiores que provém de amostras pequenas.

Porém, temos a grande vantagem que este é consistente para a ordem da cadeia, quando trabalhos sobre o espaço de todas as árvores possíveis.

Por outro lado, devido ao fato da penalização do critério AIC ser sempre constante, teremos então uma tendência a superestimar as árvores.

Ou seja, o melhor critério depende do tamanho da árvore se a amostra for pequena.

Abordaremos a seguir as estimativas obtidas pelo algoritmo Contexto (critérios AIC e BIC) e PST, referente ao conjunto de dados simulado proveniente e de suas probabilidades de transição, gerado pela função -simulate-.

Com relação ao algoritmo PST, várias simulações foram realizadas variando os valores dos parâmetros, para chegar ao melhor ajuste.

Os parâmetros (L, Pmin) foram escolhidos (em toda seção) de modo a obtermos equivalência ao algoritmo de contexto usado aqui, são eles Pmin = 5=n onde n é o tamanho da amostra e L = logjAjn.

A árvore estimada pelo algoritmo Contexto (critérios AIC e BIC) foi a mesma.

O algoritmo PST, estimou a árvore apresentada.

As escolhas dos parâmetros se deu pela escolha da árvore estimada pelo algoritmo PST que mais se aproximou da árvore "verdadeira".

Árvore estimada pelo algoritmo PST (dados simulados).

Como podemos notar, dentre os métodos utilizados nesta situação, o que obteve melhor estimativa foi o algoritmo de contexto.

Ressaltamos, que para diferentes conjuntos de dados, os parâmetros que otimizam as simulações no PST podem variar.

Temos ainda, que na estimativa L teve que tomar o valor 3, pois para L = 4 (quando n = 2500) não obtivemos bons resultados.

Além do resultado apresentado acima, outras simulações em conjuntos de dados do -Conjunto 1- foram realizadas.

Porém, em todas elas o PST se mostrou pior.

Utilizando novamente o conjunto de dados simulado, iremos introduzir uma pequena pertubação neste conjunto e verificar o desempenho e robustez de ambos os algoritmos.

Esta pertubação será feita através do acréscimo, de forma aleatória, de cinco seqüências no conjunto de dados simulados, lembrando que esta é uma seqüência que não acontece nos dados.

O interessante dessa análise e ver como se comporta a medida de corte quando inserimos esses erros, já que nesse caso a Pmin ou a quantidade mínima (dependendo do algoritmo utilizado), esta sendo verificada.

Vale lembrar, que estas seqüências foram inseridas em qualquer parte do conjunto de dados, independentemente de quem será o seu antecessor ou sucessor.

As árvores ajustadas com os dados simulados e perturbados, foram exatamente as mesmas que obtivemos sem as pertubações.

Ou seja, tanto as estimações do algoritmo Contexto (critérios AIC e BIC) e PST, não detectaram a inserção de um erro no conjunto de dados.

Esse fato é muito importante, pois temos agora um pequeno indício que tais algoritmos são robustos a erros que possam vir a ocorrer, como por exemplo em um processo de digitação ou transposição de dados.

Os resultados que apresentaremos seguir são referentes as estimações obtidas pelo algoritmo PST, quando aplicado aos conjuntos de dados da árvore esparsa.

O conjunto de parâmetros no qual obtivemos melhor resultado foi r (exatamente os mesmos que no exemplo anterior).

A escolha destes parâmetros foi baseada no fato em que o símbolo 1 não se ramifica, isto é, buscamos a árvore em que houve menos ramificações deste símbolo.

Porém, ainda nestas estimativas que apresentaremos, por diversas vezes o símbolo 1 se ramificou, mostrando novamente que as estimativas obtidas pelo algoritmo de contexto são melhores.

Como a dimensão da árvore estimada é muito grande, não é possível desenhar as árvores estimadas pelo PST.

Apresentam os conjuntos de contextos estimados (a raiz nessas estimativas pode assumir os valores 0 ou 1).

Agregando todos resultados obtidos nessa seção, ao fato de que não conhecemos a verdadeira estrutura das árvores do conjunto de dados que iremos utilizar, daqui por diante iremos adotar o algoritmo Contexto com critério AIC como sendo o nosso principal algoritmo de ajuste de árvores.

Porém, para efeito de completude, iremos realizar um estudo conjunto com o algoritmo de contexto utizando ambos os critérios (AIC e BIC).

A idéia principal deste capítulo é a de sugerir um método de reamostragem para cadeias de Markov de alcance variável.

Para tanto, iniciaremos com uma breve introdução do primeiro método de reamostragem, especificando algumas utilidades e maneiras nas quais este é mais utilizado.

Depois descreveremos também alguns métodos apresentados na literatura de se fazer reamostragem para uma cadeia de Markov e para uma cadeia de Markov de alcance variável.

Finalizaremos sugerindo um método de reamostragem que será adequado à análise de dados reais a ser feita no O método de reamostragem independente foi introduzido primeiramente por Efron, tendo como intuito apresentar técnicas para se estimar quantidades desconhecidas associadas à modelos estatísticos.

Dentre suas utilidades, as mais freqüentes são os cálculos de erro padrão para estimadores, intervalos de confiança para parâmetros desconhecidos e ainda valores descritivios para estatísticas de teste sob a hipótese nula.

Portanto, este método é tipicamente usado para estimar quantidades associadas com a distribuição amostral de estimadores e estatísticas de teste.

A respeito de um modelo estatístico, podemos relembrar que este é essencialmente um conjunto de distribuição de probabilidade que tenta descrever o verdadeiro estado natural, tendo a inferência estatística a meta de inferir algo sobre uma população desconhecida baseado nos dados recolhidos da mesma.

O reamostragem é uma ferramenta importante para se fazer tal inferência, especialmente quando tratamos de exemplos mais complicados.

Para exemplificar o que sugere o método, iremos supor uma situação hipotética de estimação de erro padrão com supostos dados analíticos.

Para tanto, considere uma amostra aleatória observada x de uma distribuição de probabilidade desconhecida F.

Seja F a distribuição empírica, atribuindo probabilidade 1 em cada um dos valores xi observados.

Assim, para A evento do espaço amostral temos P(A), isto é, a freqüência relativa que elementos da amostra xi ocorre em A.

Uma reamostra é definida como sendo uma amostra aleatória de tamanho n extraída de F, onde a notação estrela indica que x não é o conjunto atual de dados, mas uma aleatorização, ou reamostragem, da versão x.

Esta amostra consiste de elementos do conjunto de dados original, onde alguns não aparecem, alguns aparecem uma vez, outros duas e assim por diante.

Isto é, um número aleatório projeta inteiros selecionados, cada qual igual a qualquer valor entre 1 e n com probabilidade 1.

O algoritmo acaba por extrair diversas amostras independentes.

Assim, o erro padrão da estatística, é calculado a partir da função de distribuição empírica F no lugar da distribuição F desconhecida.

Portanto a estimativa dada pela reamostragem é se F.

Temos então, que a estimativa do erro padrão será dada, onde B é o número de reamostragens feitas.

Finalmente, o limite de seB quando B tende para o finito será o nosso estimador ideal.

O fato que seB aproxima de se F quando B tende para o infinito quer dizer que o desvio padrão empírico se aproxima do desvio padrão populacional com um número grande de aplicações por reamostragem.

Isso pode ser explicado, pois quando consideramos amostras independentes, a distribuição empírica dos dados converge para a distribuição verdadeira.

A estimador ideal se F e sua aproximação seB são às vezes chamados de reamostragem não-paramétrica porque eles são baseados em F, que é a estimativa não paramétrica da função de distribuição acumulada F.

Descreveremos aqui a reamostragem para cadeias de Markov com espaço de estado finito, proposto por Kulperger, e que tem como intuito estimar de modo consistente, para uma cadeia de Markov ergódica homogênea, a distribuição de alguns estimadores, que definiremos posteriormente.

Consideremos então que seja uma cadeia de Markov ergódica homogênea, com matriz de transição dada por P = (pij) e espaço de estado A.

Assumimos ainda que pij > 0 para todo i, isto é, todos os estados se comunicam.

Esta suposição pode ser dispensada para cadeias de Markov regulares pela ampliação do espaço de estado se necessário, desde que exista um inteiro N tal que PN = P(N) (matriz de transição a N passos) são todas estritamente positivas.

Sabe-se que em distribuição, onde Zij, tem distribuição conjunta normal multivariada com média 0 e covariância que é contínua em P.

Temos ainda que a taxa de convergência é uniforme em uma vizinhança de P.

Para esse processo, sem perda de generalidade, assumiremos que o estado inicial da cadeia de Markov é 1, isto é, x0 = 1.

Denotaremos a variável -primeiro tempo de parada ao estado-.

Denote por P, ou seja, a probabilidade de que T · t, para uma cadeia de Markov com matriz de transição Q e valor inicial X0 = 1.

O método de reamostragem para estimação da distribuição do primeiro tempo de parada T, pode ser explicado como segue.

Quando é P é conhecida, a distribuição pode ser obtida.

Um método de Monte Carlo pode ser usado, se a distribuição for uma função complicada de P.

Por outro lado, quando P é desconhecida, um procedimento de reamostragem pode aproximar a distribuição, onde Qn é dada pela formula, estimada através de uma sub-amostra gerada por uma cadeia de Markov (realização observada) com matriz de transição Pn, e Q é a matriz de transição próxima de P, Q = Pn.

A distribuição pode ser calculada, desde que Pn seja uma matriz conhecida, por exemplo, através do método de Monte Carlo.

O problema constituiu em justificar que as distribuições são próximas, isto é, obter um método consistente.

Adaptando o mesmo tipo de análise, é possível estimar m1(P), que é a esperança do primeiro tempo de chegada, ou estudar também a estimação, onde é a distribuição estacionária do processo.

O método que apresentaremos nesta seção foi proposto por Künsch.

De modo geral, Temos ainda, que de um modo geral, este método é utilizado para processos estacionários arbitrários com pequeno domínio de dependência expressado.

Künsch ressalta também, que se a estatística utilizada sobre os dados de reamostragem gerados por blocos, que veremos nesta seção, não for função simétrica das observações, observações no meio ou até mesmo blocos selecionados aleatoriamente que forem deixados de fora, podem causar problemas.

Outro fato importante é que deve ser tomado cuidados com a junção dos blocos selecionados aleatoriamente.

Uma maneira de cuidar destes problemas, é restringir a classe de estatísticas a funcionais de uma distribuição marginal empírica, com dimensão fixada.

Cabe notar ainda que este procedimento é consistente no caso do estimador ser a média aritmética, onde podemos obter assintoticamente o viés e a variância.

Nesta seção, sempre serão consideradas estatíticas Tn da forma Tn = T, com algum m fixado e algum funcional T com valores em R, definido no conjunto de todas as medidas de probabilidade em Rm (ou ainda um subconjunto próprio deste).

Para efeito de notação, considere blocos de observações Yt como sendo e o valor q = n¡l+1.

Em analogia ao caso de amostras, seleciona-se blocos de tamanho l aleatoriamente.

Assumindo que q = kl com l 2 N.

A partir dos dados gerados tem-se então, para efeitos de estudos estatísticos, uma estatística e aproximamos a distribuição que é desconhecida, pela distribuição, onde Fm é a verdadeira distribuição dos blocos de tamanho m, sendo que S1 Sk variam.

Similarmente podem ser estimados quantis e ordens quantílicas de interesse.

Usando independência, o estimador obtido pela reamostragem de Efron estima Fn, onde denota o produto de medidas.

Para m = 1 a proposta apresentada aqui, estima Fn, e portanto coincide com o modelo de Efron.

Entretanto, será deixado 1 quando q, pois desta maneira, assintoticamente, obtêm-se todas distribuições marginais corretamente.

Podemos notar que a proposta não nos conduz a um estimador de Fn.

Enquanto reescrevemos reamostras em termos de observações originais de (Xt), nós obtemos dados pontuais.

A razão para este método é que não deseja-se usar observações de diferentes blocos independentes no cálculo de n, pois desta forma é possível reduzir o efeito de independência conjunta de blocos juntos.

Abordaremos brevemente nesta seção o método de reamostragem para uma cadeia de Markov de alcance variável.

Para alcançar tal objetivo, é necessário a introdução de alguns conceitos e definições.

Consideremos uma seqüência de cadeias de Markov de alcance variável (Pn)n2N, Pn 2 P, com árvore de contexto n = cn e funções contexto Cn, onde P é o conjunto de todas as cadeias de Markov de alcance variável de ordem k.

Seja também, realizações finitas de Pn, sendo que as probabilidades de transição correspondente a Pn, serão denotadas aqui por pn.

Com o intuito de comparar medidas de probabilidade, defina a métrica para duas medidas.

O teorema que enunciaremos a seguir é um dos principais resultados para este tipo de reamostragem, ele mostra porque o estimador Pn de Pn pode ser utilizado para construir uma amostra.

Cabe ressaltar aqui, que a proposta apresentada nesta seção é utilizada em séries temporais categóricas estacionária, porém este método de reamostragem ainda pode ser utilizado de maneira bem mais geral.

Descreveremos a seguir o método nos seguintes passos.

Passo 1, tomando valores em A ajustamos uma cadeia de Markov de alcance variável, criamos então uma medida estacionária de probabilidade Pn em AN.

Passo 2, crie uma realização finita.

Para entendermos um pouco melhor o processo realizado por esse procedimento, temos que a reamostragem de uma cadeia de Markov de alcance variável de ordem -k- é dada através do conjunto de todas as suas probabilidades de transição que pode ser denotado por fP, começando com um vetor inicial Xk, onde k é a ordem da cadeia de Markov de alcance variável.

Sob condições de regularidade, o fato de termos que inicializar com k valores, torna-se esquecido exponecialmente rápido no decorrer da simulação.

Portanto, para simular uma amostra n-dimensional de uma distribuição estacionária de uma cadeia de Markov de alcance variável, nós simulamos e escolhemos Xm+1 como sendo a nossa amostra de tamanho n.

Aqui m é um número maior que 103 ou 104, e é dado por 64card.

Cabe ressaltar, que sob certas condições de regularidade, Bühlmann eWyner provaram que esta reamostragem para cadeia de Markov de alcance variável é consistente sobre dimensionalidade crescente.

Nesta seção estamos propondo um método de realização de reamostragem por blocos para cadeias de Markov de alcance variável que possuem um ponto de renovação.

Como veremos, na aplicação em dados lingüísticos temos a presença de um ponto de renovação em todas as árvores estimadas do nosso conjunto de dados.

Considere então (Xn)n2Z uma cadeia de Markov de alcance variável estacionária de ordem k, tomando valores em um alfabeto finito A.

Denote por -a- o nosso ponto de renovação.

O método de reamostragem proposto procederá da seguinte maneira.

Primeiramente, a partir do conjunto de dados, montamos uma lista que contém todas as seqüências encontradas, que terminam no ponto de renovação -a-.

De maneira mais geral, o algoritmo que constrói a lista, começa lendo a amostra de nossa cadeia de Markov de alcance variável e vai construindo a primeira seqüência, terminando essa no primeiro aparecimento do símbolo de renovação.

A partir daí, começa-se a construir a próxima seqüência terminando-a no aparecimento do segundo ponto de renovação.

Este procedimento acaba ao final da leitura de todo o conjunto de dados.

Vale lembrar que uma mesma seqüência pode aparecer mais de uma vez em nossa lista.

Para efeito de notação, considere a i-ésima seqüência encontrada na lista, e número total de seqüências.

Dando seguimento, geramos uma variável aleatória (ui) uniformemente distribuída em W, e a cada valor encontrado a seqüência é inserida na nossa reamostragem.

Esse processo é efetuado para i 2 N variando de 1 até q 2 W, onde q determina o número de seqüências na reamostra.

Assim montamos a nossa reamostra.

A seguir, com o intuito de apresentar uma breve análise a respeito do método que acabamos de descrever, iremos propor o estudo da variância (estimada) da seguinte estatística Tn = P(1j0), utilizando o método de reamostragem proposto e apresentado na Seção(aqui chamaremos de método I), e o método de reamostragem proposto neste trabalho que foi mostrado nesta secção (que chamaremos por método II).

Cabe ressaltar que já é conhecido que o método I é consistente para este caso.

A amostra que será utilizada para esta análise será uma cadeia esparsa (a mesma utilizada no Capítulo 1 na seção -Simulações-, de tamanho 3469), com reamostras contendo o mesmo número de seqüências da amostra original.

A variância estimada será baseada em 500 reamostras.

Os momentos da variância obtida por reamostragem n serão estimados com 200 reamostragens sob diferentes modelos (modelos simulados de uma mesma cadeia esparsa), já o verdadeiro valor de n foi estimado sob 1000 modelos diferentes.

Ambos os métodos se comportaram de maneira similar, porém com uma pequena vantagem para o método I por apresentar menor EQMR.

Vale lembrar que o EQMR é o erro quadrático médio relativo.

Utilizando ainda do mesmo conjunto de dados esparsa, realizaremos o mesmo estudo efetuado acima, porém utilizando agora a estatística Tn, que nesse conjunto de dados retrata a freqüência relativa do símbolo 1.

Nesta segunda análise, ambos os métodos se mostraram novamente muito parecidos, e novamente o método I se mostrou um pouco melhor devido ao seu menor EQMR.

Cabe salientar ainda, que se trabalharmos em um processo onde as estimativas das probabilidades de transição apresentarem algum erro, o método II tende a ser mais robusto, pelo fato de não trabalhar com as estimativas.

O português moderno é uma língua particulamente interessante para ser estudada na nossa abordagem, sendo que tanto o português do Brasil quanto o português Europeu (abreviados aqui por PB e PE respectivamente), apresentam o mesmo conjunto de palavras em sua estrutura (léxico).

No entanto estas linguas apresentam diferentes sintaxes e diferentes prosódias, isto é, não só ordenam as suas palvras de maneiras diferentes como também implementam sentenças com ritmos diferenciados.

Neste trabalho, analisamos textos jornalísticos de ambas as línguas usando o algoritmo Contexto.

Nesta seção detalharemos de que forma os dados foram obtidos e codificados, para que estes retratassem evidências estatísticas na detecção de ritmos nos textos escritos.

A amostra na qual trabalharemos, foi selecionada aleatoriamente de todas as reportagens dos jornais -Folha de São Paulo- (PB) e -Público- (PE) nos anos de 1994 e 1995, Sendo 40 textos de PB e 40 textos PE (20 de cada língua por ano).

Os textos foram amostrados através de um processo de amostragem aleatória simples, que consiste em fazer um sorteio dentre todos os jornais com a mesma probabilidade de serem selecionados.

Dentro de cada edição, foram selecionados textos com mais de 1000 palavras (visto que essa era uma condição para estimar árvores com ordem 3) e escolhido apenas 1 texto dentre todos.

Após a escolha dos textos, foi analisado o tipo do texto (reportagem) que se tratava.

Devido ao objetivo ser o de construir um modelo que retrate como é falado o português através de textos escritos, certos tipos de reportagens não foram utilizadas.

Por exemplo, entrevistas, sinopses de filmes, peças de teatros, ou promulgação de leis e coletâneas de textos.

Desta forma eles foram retirados da amostra, e só permaneceram reportagens gerais, das diversas seções dos jornais.

Na codificação dos textos escritos, tentou-se retratar a idéia de que as conjecturas das classes rítmicas são caracterizadas pelo fato de que elas designam relevância para diferentes domínios prosódicos.

A questão então é como reaver em termos estatísticos domínios relevantes para a codificação de uma amostra de um texto escrito.

A codificação virá pela atribuição de dois símbolos para cada sílaba do texto, de acordo com o seguinte regra.

Se esta é tônica ou não.

Se é início de palavra prosódica ou não, onde a palavra prosódica é definida como sendo uma palavra léxica juntamente com as palavras não acentuadas que a precedem.

Usaremos inicialmente o conjunto f0.

Como o conjunto de símbolos adotados, onde o primeiro símbolo indicará início ou não de palavra prosódica e o segundo símbolo indicará se a sílaba é tônica ou não.

Como um método de simplificação nós usaremos uma expansão binária.

Adicionalmente nós iremos atribuir um símbolo extra (4) para o final de cada sentença, marcado por ponto final, ponto interrogação, ponto exclamação etc.

Portanto, obtemos para o nosso processo o alfabeto, A.

Para melhor compreensão da codificação considere a sentença -O menino já comeu o doce-.

Esta sentença é divida em quatro palavras prosódicas.

Podemos notar que os elementos formados pelos dígitos binários 0 e 1 indicam se as condições -início de palavra prosódica- ou - silaba tônica- são satisfeitos ou não, sendo que na linha código temos o par binário de maneira sintetizada.

O símbolo 4 indica final de sentença.

As palavras prosódicas, formam um conjunto finito e seu número de sílabas é limitado por uma constante M, que para propósitos práticos pode ser tomada como M = 15.

Temos ainda que de acordo com a definição por nós adotada, qualquer palavra prosódica deve conter uma e somente uma sílaba tônica (codificada por 1 ou 3).

Além disso, o português somente permite que uma sílaba tônica possa ser seguida, no máximo, por três sílabas atônas dentro da palavra prosódica.

Finalmente, podemos ressaltar ainda que as sentenças são formadas pelas concatenações das palavras prosódicas, e pelos símbolos que seguem aos finais de sentenças (codificado pelo símbolo 4), que podem somente ser seguido pelos símbolos (2 ou 3).

O programa utilizado para a codificação dos dados, é sensível com relação a alguns símbolos, por exemplo, é preciso retirar aspas, escrever todos os numerais por extenso, escrever -como se lê- as siglas, e retirar frases com palavras estrangeiras.

O programa segue a norma gramatical da língua portuguesa e os códigos poderiam simbolizar sinais errados.

Os nomes próprios não foram alterados.

Foram também retirados os hifens de todas as palavras, com exceção de verbos como -falaram-se-.

Palavras com o prefixo -ex- como -exdeputado- foram reescritas como -exdeputado-, reticências foram substituídas por apenas um ponto, assim como o ponto de exclamação e interrogação.

Foram também retirados todos os parênteses nos textos e o símbolo % foi escrito como -porcento-.

Todas estas questões referentes a marcas lingüísticas foram supervisionadas por profissionais da área que revisaram todos os textos que geraram posteriormente as árvores.

Um último aspecto importante, é que a nossa sugestão para a reamostragem de uma cadeia de Markov de alcance variável deve conter, devido ao nosso método de codificação, certas condições algébricas.

Os símbolos 1 e 3 devem ser seguidos por no máximo três 0-s e os símbolos 2, 3 ou 4.

O símbolo 2 deve ser seguido por qualquer números de 0-s e o símbolo 1.

O símbolo 4 deve ser seguido pelos símbolos 2 ou 3.

Apresentaremos nesta seção, o conjunto das 80 árvores obtidas na simulação pelo algoritmo Contexto (critérios AIC e BIC).

Visando ainda obter algum conhecimento a respeito do comportamento do conjunto de dados, realizaremos uma breve análise descritiva.

Cabe ressaltar, que a escolha do algoritmo Contexto se deu pelos resultados apresentados na Seção.

Temos também que, para efeito de notação, iremos classificar as árvores obtidas por Árvore1, Árvore2 e assim por diante.

Usando primeiramente o algoritmo Contexto com critério BIC, foram observados em ambos os idiomas basicamente 6 tipos de árvores.

Expressa a freqüência dessas árvores para cada um dos idiomas em estudo.

Em todas as 80 árvores que foram geradas pelo critério BIC, apenas os contextos 0 e (0,0) apresentaram alguma ramificação.

Todas as árvores também apresentam profundidade 3, ou seja, no máximo deve-se voltar 2 passos no passado para predizer o próximo símbolo.

Em geral a estrutura das árvores é semelhante, as diferenças apareceram apenas na terceira geração de ramos.

Não há nenhuma informação que as diferem, de certo modo seguem um padrão.

Freqüência das árvores geradas pelo algoritmo Contexto via -BIC-.

Apresentam respectivamente as 18 árvores estimadas pelo algoritmo Contexto usando o critério AIC.

Aapresenta as freqüências relativas das árvores obtidas pelo algoritmo Contexto, utilizando o critério AIC.

Como podemos obervar, com critério AIC obtivemos árvores maiores, algumas com profundidade 4, bem como uma maior discrepância entre os ajustes.

Porém, as estimadas em ambos os processos continuam concentradas em árvores com a mesma estrutura (Árvore-1 à Árvore-6).

Finalizaremos esta seção, apresentando alguns aspectos interessantes com relação a freqüência dos contextos, em ambos os processos.

Nas árvores do português brasileiro e do português europeu, os contextos (1,0,0), (1,0), (2,0), (3,0), 1, 2, 3 e 4 aparecem em 100% dos ajustes.

Nesta seção, apresentaremos o teste de hipótese proposto por Busch, Ferrari, Flesia, Fraiman, Grynberg e Leonardi para testar a hipótese da igualdade das distribuições de árvores aleatórias, que evoluem no tempo com gerações discretas.

O teste é baseado na comparação entre as estruturas médias que caracterizam duas amostras de populações distintas de árvores.

Busca-se então testar se a diferença (distância) entre essas estruturas são estatisticamente significantes para rejeitar uma igualdade de distribuições.

Considere um alfabeto finito A, com m, representando o número máximo de descendentes que um nó pode ter.

Denote também o conjunto das finitas seqüências de elementos em A por V, representando todos os contextos possíveis de uma árvore.

Dado w um contexto da árvore, diremos que este fará parte da geração k+1, que será denotada por gen(w) = k+1.

Desta forma, somente a raiz será considerada da geração 1.

Para efeito de notação denotaremos por função identificadora.

Temos portanto que t(v) = 1 se v 2 e zero caso contrário.

Podemos notar ainda que os contextos de uma árvore estarão bem caracterizados por esta função.

Considere agora, Á como sendo uma função estritamente positiva, onde t1 e t2 são as respectivas funções identificadoras de 1 e 2.

A Á pode ser por exemplo a função, que não penaliza muito a primeira geração.

Com esta distância têm-se então que é um espaço métrico compacto.

Denote B como sendo a sigma-álgebra de Borel formada pelos subconjuntos.

Dado T uma amostra aleatória de T (árvores independentes com a mesma lei de T).

A distância média empírica da amostra para a árvore é definida.

A objetivo então é testar usando amostras aleatórias.

Na prática, como a distribuição da estatística de teste sob a hipótese nula é desconhecida, utiliza-se dos seguintes passos para obter o quantil sob a hipótese nula.

Usa-se da reordenação da amostra agrupada para obter cada novo par de amostra, isto é, desta forma reamostramos árvores de ambas as leis.

Em seguida, utiliza-se deste par de amostra para se calcular a estatística de teste.

O passo relatado acima é repetido um número fixo de vezes N, e os valores obtidos das estatísticas são ordenados de forma crescente.

Defina o quantil como sendo o valor que ocupa a posição no vetor formado pelas estatísticas ordenadas.

Como podemos notar, no cálculo do quantil sob a hipótese nula, o teste supõe que a variedade de árvores encontrada na cadeia de Markov de alcance variável (sob a hipótese nula) é a mesma que obtivemos na estimação do nosso conjunto de dados (PB e PE).

Isso se deve ao fato de que a reamostragem é feita a partir da reordenação dos textos (árvores).

Para o cálculo do valor descritivo (empírico), definimos primeiramente L como sendo um vetor contendo todas os valores obtidos pelo teste nas amostras reordenadas, que para efeito de notação diremos que é de tamanho N.

Considere também l como sendo o valor do teste nas amostras originais.

Quando o teste foi aplicado nos ajustes obtidos pelo algoritmo Contexto com critério BIC, obtivemos um valor descritivo de aproximadamente 0,35, ou seja, não temos indícios estatísticos para rejeitar a hipótese nula.

Assim, segundo o resultado do teste, ambas as línguas (PB e PE) apresentam a mesma distribuição.

Esse resultado era esperado, já que as árvores ajustadas em ambas as amostras com o critério BIC, são muito parecidas.

Enfim, provavelmente a grande diferença apresentada nestes ajustes está relacionada às probabilidades de transição (o que não é detectado neste teste).

Realizando agora o mesmo teste nos ajustes obtidos pelo algoritmo Contexto com critério AIC, o valor descritivo obtido foi de aproximadamente 0,37, isto é, aqui também não rejeitamos a hipótese nula.

Portanto, segundo o teste realizado nestas amostras (critério AIC) o PB e PE também provém da mesma distribuição que atribui massa a árvores com um número finito de nós.

Esse resultado pode ser interligado com o fato ressaltado, isto é, apesar desse critério fornecer uma maior variedade de árvores, ambas as amostras (PB e PE) continuam concentrando suas estimativas em árvores idênticas.

Nesta seção, abordaremos um estudo de teste de hipótese utilizando da estatística de teste BFFS apresentada na Seção, e do método de reamostragem proposto neste trabalho.

Ressaltamos que os ajustes realizados aqui, serão efetuados através do algoritmo Contexto com critérios de seleção AIC e BIC.

Esta análise procederá da seguinte maneira.

Primeiramente, supomos que ambas as línguas PB e PE provenham de uma mesma cadeia de Markov de alcance variável, isto é, trabalhamos sobre a hipótese nula.

Utilizando de cada conjunto de dados (PB e PE), cria-se uma única lista contendo todas as seqüências encontradas nos 80 textos codificados.

Vale lembrar que seqüências que ocorrem por mais de uma vez nesses textos, aparecem de forma repetida na lista.

Após esse passo, temos então uma lista de seqüências.

Realizaremos 500 reamostragens do nosso conjunto de dados (textos de PB e PE), isto é, cada texto (de PB e PE) foi reamostrado (respeitando o número de seqüências do texto original), por 500 vezes utilizando a técnica proposta neste trabalho.

Portanto após esta reamostragem, obtivemos então 500 conjuntos de dados de PB e 500 de PE, contendo 40 textos em cada conjunto.

A partir dessas reamostragens a estatística BFFS do teste foi executada, e o valor descritivo (empírico) foi calculado.

Apresentam respectivamente o histograma, a densidade (estimada) e o diagrama de dispersão dos resultados obtidos nos testes realizados nas reamostras, quando utilizamos do critério AIC no ajuste das árvores.

A curva da densidade que aparece representa uma estimativa não paramétrica da densidade obtida pelo método Kernel (Kernel Gaussiano), utilizando -software R-.

Como podemos notar, quando trabalhamos com o critério AIC os valores obtidos pelo teste são mais freqüêntes entre 0,015 e 0,02, com mediana de aproximadamente 0,018, e alguns valores extremos acima de 0,035.

O valor descritivo obtido com esse ajuste (AIC) foi de aproximadamente 0,039.

A grande diferença encontrada aqui, é que na nossa reamostragem obtivemos cerca de 250 árvores distintas, diferentemente das 18 que o teste anterior utiliza na reordenação dos dados para o cálculo do seu valor descritivo.

Com relação aos ajustes realizados com o critério BIC, apresentam respectivamente o histograma, a densidade (estimada) e o diagrama de dispersão dos resultados obtidos nos testes realizados nas reamostras.

Neste caso (critério BIC), os valores obtidos pelo teste são mais freqüêntes entre 0,005 e 0,01, com mediana de aproximadamente 0,008, e alguns valores extremos acima de 0,02.

Diferentemente do resultado apresentado com o critério AIC, o valor descritivo obtido com esse ajuste (BIC) foi de aproximadamente 0,37.

Lebramos que neste caso, nas reamostras, obtivemos aproximadamente 18 tipos de árvores distintas.

Neste capítulo apresentaremos alguns aspectos interessantes inerentes ao estudo realizado neste trabalho.

Com relação aos algoritmos de estimação de árvores adotados neste estudo, algoritmo de contexto com critérios de seleção AIC e BIC, obtivemos as seguintes características apresentadas em nossas estimações.

Quando trabalhamos com os conjuntos de dados esparsa, fica bem claro que o algoritmo Contexto com critério BIC estima melhor as árvores.

Essa característica pode ser justificada pelo fato de que nestas árvores estimadas o símbolo 1 nunca se ramifica, o que não ocorreu com a estimação utilizando o critério AIC.

Por outro lado, obtivemos em simulações realizadas em dados -simulados- (através das probabilidades de transição) de árvores do conjunto de dados, que na maioria das vezes o critério AIC (neste caso) acaba por ajustar melhor as árvores estimadas.

Esse fato pode ser explicado seguindo do princípio de que para amostras pequenas com grande número de parâmetros a ser estimado, o critério AIC penaliza menos os ajustes, isto é, tende a estimar menores valores de ponto de corte.

Como não temos indícios de como é a distribuição das árvores que provém tanto de PB quanto de PE, acabamos optando então pelo algoritmo Contexto com critério AIC.

A respeito do nosso método de reamostragem, quando aplicado na estimação da variância de alguns estimadores, vimos que este tem um comportamento bem próximo ao encontrado por um método de reamostragem consistente para esses estimadores, ou seja, para aquele caso (que é um conjunto de dados com ponto de renovação) obtivemos um bom resultado.

Tratando agora dos resultados obtidos pelo teste de hipótese para cadeias de Makov de alcance variável sob reamostragem, vimos que para o caso em que o critério AIC é utilizando nos ajustes das árvores, o valor descritivo obtido nos leva a concluir que existe evidências estatísticas que para se rejeitar a hipótese nula.

Esse fato pode ser explicado, pois quando utilizamos este critério, a quantidade de árvores geradas nas reamostras é absurdamente maior que as 18 apresentadas nos ajustes das amostras.

Ou seja, para o cálculo do valor descritivo com as reamostras utilizamos uma maior variedade de árvores, que acabaram resgatando a diferença entre as cadeias de Markov de alcance variável.

Já com o critério BIC obtivemos valor que nos leva a concluir que as línguas provém de uma mesma cadeia de Markov de alcance variável, isto é, não existe evidências estatísticas que nos leve a rejeitar a hipótese nula.

O fato de que o algoritmo Contexto com esse critério penaliza muito os ajustes, pôde também ser observada aqui, pois em todo nosso conjunto de reamostras obtivemos apenas 18 tipos de árvores distintas.

Enfim, como acabamos optando pelo algoritmo Contexto com o critério AIC, temos então que com o valor descritivo (0,039) obtido neste caso rejeitamos a hipótese nula, isto é, segundo nosso método de reamostragem temos evidências estatísticas de que PB e PE provém de cadeias de Markov de alcance variável distintas.

Apresentaremos nos Apêndices a seguir os códigos fonte do programas executados, bem como algumas características dos conjuntos de dados utilizados neste trabalho.

Vale lembrar que tais códigos são executáveis no software -R-.

Apresentaremos primeiramente os dois códigos fonte dos programas que ajustam as árvores (conjunto de dados em um mesmo diretório) utilizando o pacote VLMC, com critérios de seleção AIC e BIC respectivamente.

Estes programas tem como saída as árvores ajustadas e plotadas em formato -ps-.

O código fonte que apresentaremos agora foi utilizado na reamostragem feita sob a hipótese nula.

Isto é, dado o nosso conjunto de dados (PB e PE) ele cria pastas -bootstrap- que contém as reamostras.

Nesta seção abordaremos o código fonte que ajusta os dados gerados pela reamostragem, utilizando do pacote VLMC, do critério de seleção BIC.

A saída do programa são árvores ajustadas e organizadas em pastas, juntamente com um arquivo (Quantidades) que fornece as quantidades de cada tipo de árvore encontrada em cada pasta -bootstrap-.

