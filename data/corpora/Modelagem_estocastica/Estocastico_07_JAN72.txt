Este trabalho investiga a utilização de uma especificação formal de alto nível, os Statecharts, com o objetivo de propiciar uma melhor compreensão de um determinado sistema, quando se pretende avaliar o seu desempenho.

Além da especificação, é feita uma associação dos Statecharts com soluções analíticas e por simulação, para viabilizar o processo de modelagem como um todo.

Algumas vantagens provenientes da utilização dessa nova abordagem (como hierarquia, paralelismo explícito e mecanismos de comunicação) são discutidas ao longo do artigo, assim como certas implicações da adoção dos Statecharts para avaliar desempenho.

Duas abordagens formais para avaliação de desempenho são apresentadas.

Statecharts Estocásticos (especificação para sistemas de filas puramente baseada em Statecharts) e Queuing Statecharts (uma aglutinação entre as representações de redes de filas e Statecharts).

Um estudo de caso é apresentado ao final do trabalho para aplicar a formalização proposta.

O processo de modelagem com o enfoque de desempenho, na maioria de suas abordagens, não apresenta um equilíbrio entre uma boa especificação e uma solução viável para o sistema em estudo, sendo que a preocupação precípua se atem apenas ao método de solução.

Essa certa "negligência" em relação à especificação pode estar associada ao perfil dos utilizadores da avaliação de desempenho, que, geralmente, possuem um conhecimento matemático apropriado.

Dessa forma, para esse tipo de usuário, um conjunto de equações de um sistema linear pode ser tão claro quanto uma especificação gráfica em alto nível.

Se, entretanto, no processo de modelagem, há outras pessoas menos especializadas envolvidas (as quais são, em algum nível, usuários do sistema a ser modelado), poderia ser interessante dispor-se de uma forma de representação clara e abstrata o bastante, a ponto de apresentar o sistema, escondendo a complexidade que pode estar associada às soluções matemáticas que alicerçam a modelagem.

Algumas das técnicas de especificação utilizadas em avaliação de desempenho, como redes de Petri, já possuem um grau de abstração e algumas características convenientes para a representação de sistemas complexos.

Entretanto, este aqui examina-se a viabilidade de que características específicas providas pela notação Statecharts sejam utilizadas de maneira eficiente na avaliação de desempenho.

Com o objetivo de investigar os benefícios provenientes da especificação Statechart e sua correspondência com alguns métodos de solução, este trabalho realiza um estudo sobre as possíveis vantagens e implicações obtidas por uma abordagem baseada na adoção de uma descrição visual de alto nível, com um teor matemático associado.

A escolha dos Statecharts é justificada por algumas características adicionais, tais como paralelismo explícito, hierarquia de estados, entrada por condição ou por história e mecanismos de comunicação.

Essas características associadas à visão estocástica permitem que seja feita uma análise de como está o desempenho de um determinado sistema.

Sistemas complexoscaracterizados por uma forte demanda de atividades paralelas/concorrentes, requisitos críticos quanto aos tempos de resposta, sincronismo entre seus componentes, entre outras nuançassão, via de regra, sensíveis a observações promovidas de maneira empírica.

Paradoxalmente, esses sistemas precisam ser avaliados, de forma que se tenha uma idéia de como se apresenta o seu desempenho.

Sob esse ponto de vista, é importante que se tenha algum mecanismo que propicie uma investigação minuciosa do desempenho, sem que haja uma influência da própria aferição no resultado final da avaliação.

Para esses casos, usualmente, toma-se uma abstração do sistema, denominada de modelo, a partir da qual são realizadas certas inferências, sem a necessidade de realizar-se uma efetiva experimentação.

Assim, uma modelagem, no contexto de avaliação de desempenho, é um processo com um relativo teor matemático, composto por fases que são, ao mesmo tempo, independentes e harmônicas entre si.

De uma maneira concisa, as etapas da modelagem são descritas a seguir.

Na fase inicial da modelagem, deve-se criar uma especificação condizente com o sistema real, na qual devem estar contidos os componentes do sistema relevantes à avaliação, além do relacionamento entre eles.

Algumas técnicas usadas para especificação são redes de filas, redes de Petri e Statecharts.

Após a confecção do modelo com uma das técnicas citadas, devese parametrizá-lo com elementos que serão dados de entrada para a fase da solução.

Na parametrização, são comuns taxas e tempos médios e probabilidades.

A solução do modelo aplica um método matemático (estocástico), automatizado ou não, para adquirir medidas de desempenho a partir das entradas.

Alguns métodos analíticos (cadeias de Markov, por exemplo) ou simulação são usados nessa fase.

Por fim, a modelagem deve apresentar seus resultados através de uma maneira conveniente.

Gráficos e arquivos-texto são geralmente utilizado nessa fase.

Para fins de avaliação de desempenho, as técnicas de especificação devem ser baseadas em espaços de estados e eventos (interferências que causam mudanças de estados no sistema).

Essa restrição é devida à relação que há com os métodos de solução, os quais são fortemente baseados em estados e suas transições.

As técnicas mais referenciadas na literatura especializada são redes de filas, redes de Petri (principalmente em suas versões estocásticas) e Statecharts.

Cada uma delas possui vantagens e -deficiências-, quando analisadas sob a ótica do desempenho.

Algumas dessas peculiaridades são discutidas a seguir.

As redes de filas (RF) possuem uma base matemática bastante sólida, contudo sua representação gráfica oferece apenas os elementos fila e servidor, o que em muitos casos pode ser o suficiente.

Entretanto, em alguns sistemas, desejam-se representar situações que não constituem necessariamente uma fila ou um servidor.

Por exemplo, um processo em um computador pode se encontrar em três possíveis situações, Processando, Bloqueado ou Pronto.

Essas situações são estados abstratos que são facilmente representados em técnicas como redes de Petri e Statecharts, mas por não consistirem em filas ou servidores, não são tratadas apropriadamente em redes de filas.

E mesmo filas e servidores necessitam de uma representação mais minuciosa, através da qual possam ser especificadas as várias situações que tanto fila (uma fila pode estar vazia ou não) quanto servidor (um servidor pode estar livre ou ocupado) podem se encontrar em um determinado instante.

A despeito dessas limitações, a representação do caminho linear que os clientes traçam através do sistema é descrita com bastante propriedade, noção que na maioria das técnicas é perdida com facilidade.

Redes de Petri (RP) possuem características bastante interessantes em sua representação.

Uma das mais interessantes é a possibilidade da individualização de clientes, recurso que não é usual na maioria das técnicas.

Há situações em que essa característica é primordial, por exemplo, na migração de processos para balanceamento de carga entre máquinas, onde se pode desejar migrar exatamente um determinado processo, e por isso devese saber exatamente onde ele se encontra.

Entretanto, há uma certa dificuldade na representação de processos paralelos, mesmo utilizando-se da rede distribuição (rede elementar para representar criação de processos paralelos).

Esse aspecto piora à medida que o modelo cresce, o que aliás é outro aspecto a ser ponderado.

As redes originais, por não possuírem nenhum mecanismo de hierarquia, tendem a fazer com que os modelos cresçam substancialmente, quando a complexidade dos mesmos aumenta.

Há algumas extensões que tentam minimizar esse efeito, como as RP Hierárquicas, que são baseadas em um elemento denominado superpágina.

O "inconveniente" dessa extensão é que as superpáginas são caixas-pretas, ou seja, são retângulos que escondem uma complexidade que, em certos casos, é necessária para a compreensão do modelo.

Além disso, algumas extensões desfiguram a notação original, o que, às vezes, parece ser outra técnica à parte, e não uma derivação das redes de Petri.

Na representação Statecharts (SC), a forma explícita de algumas características (como o paralelismo e a hierarquia entre estados) é um atrativo considerável.

Essa peculiaridade permite que relacionamentos complexos entre componentes de um determinado sistema sejam mostrados de maneira mais efetiva, o que não é contemplado na maioria das técnicas.

Estados default também acrescentam a idéia de passo inicial do sistema, o que nas redes de Petri é realizado através da presença dos tokens (marcação inicial).

Entretanto, uma possibilidade que os statecharts não contemplam é, quando há a presença de estados ortogonais, a descrição explícita do caminho linear seguido por um determinado cliente (que é claro em RF e RP), pois pode haver vários subestados ativos em um determinado momento, o que não significa que todos os clientes (ou um cliente em particular) tenham seguido por aquela trajetória.

Além disso, a individualização de clientes como feito com a utilização dos tokens, fundamental em certas situações (tal como em escalonamento de processos, onde se pode decidir por migrar um processo em particular) , não é implementada em statecharts.

As principais características da representação gráfica de cada técnica é sintetizada na Tabela.

As técnicas de especificação redes de filas, redes de Petri e statecharts, apresentadas superficialmente nesta seção, são abordadas.

Pela relevância para o trabalho, os Statecharts são apresentados com mais detalhes a seguir.

Apesar de não especificado explicitamente, subentende-se que os centros de serviços possuem um funcionamento autônomo, como componentes paralelos.

Apesar de haver a possibilidade de criarem-se atividades paralelas (rede -distribuição-), não há uma representação orientada a componentes (conjunto de estados) paralelos.

Stochastic Petri Nets (SPN) são apresentadas.

Generalized Stochastic Petri Nets (GSPN) são abordadas.

Statecharts é uma extensão do diagrama tradicional de estados-transições, aos quais foram adicionadas algumas características peculiares.

Os principais conceitos adicionados são hierarquia entre estados (depth), ortogonalidade (representação de atividades paralelas) e interdependência entre estados (mecanismos de comunicação).

Além disso, statecharts são fundamentados nos seguintes elementos básicos Estados, Eventos, Condições, Ações, Expressões, Variáveis, Rótulos e Transições.

Sucintamente, cada elemento básico é apresentado a seguir.

Estados são usados para descrever componentes (e suas possíveis situações) de um determinado sistema.

Os estados de um statechart (que representam os valores das variáveis do sistema em um determinado instante) podem ser classificados em dois grupos, básicos e não-básicos.

Os estados básicos são aqueles que não possuem subestados.

Já os não-básicos são decompostos em subestados.

Essa decomposição pode ser de dois tipos, OR ou AND.

Se a decomposição é do tipo OR, então o sistema sempre estará em um único subestado em um certo instante.

Entretanto, se a decomposição é do tipo AND, o estado estará em mais de um subestado, simultaneamente.

Eventos são considerados a entidade que causa uma interferência no comportamento atual do sistema, levando esse sistema a outro comportamento.

Opcionalmente, a um evento pode ser anexada uma condição (entre parênteses), também chamada de condição-guarda, de maneira que o evento só ocorrerá se satisfeita aquela determinada condição.

Os statecharts proporcionam alguns eventos especiais como true (condição) e false (condição), abreviados na notação statecharts para tr (condição), fs (condição), respectivamente.

O elemento ação é considerado para representar os efeitos do paralelismo em statecharts (a influência de um estado paralelo em outro, também ortogonal).

Ações podem ser uma mudança de uma expressão, uma mudança de uma variável ou eventos que são disparados em outros componentes paralelos.

As transições são a representação gráfica para denotar uma mudança de estado dentro do sistema.

Rótulos podem ser acrescentados às setas para prover algum significado adicional.

Para efeito de caracterização do problema, será especificado o funcionamento básico de um sistema de filas, através de eventos que acontecem indistintamente em um sistema de filas genérico.

Em um sistema de filas, há quatro eventos-padrão que caracterizam bem a dinâmica do sistema.

O primeiro é o ato da geração dos clientes em uma determinada fonte, com um determinado ritmo.

O segundo evento se constitui na chegada dos clientes à fila.

O terceiro,na tomada do servidor por um determinado cliente, obedecendo a um determinado algoritmo de escalonamento.

O último evento, pela saída do cliente do interior do servidor.

É importante observar que todos esses eventos são tomados em um determinado instante, através de uma observação contínua do tempo.

Assim, um evento fica bem caracterizado como uma função de estados de origem e de destino e do instante em que ele ocorre.

S é o conjunto discreto de estados, T é o conjunto contínuo dos tempos.

Com relação ao conjunto T, há um subconjunto dos instantes em que os eventos ocorrem.

G é o instante da geração, cf é o instante de chegada à fila, ps é o instante em que o cliente toma posse do servidor, ss é o instante de saída do servidor.

As diferenças entre os elementos descrevem as variáveis aleatórios tempo entre chegadas e tempo de serviço, respectivamente.

As quais devem ser valores conhecidos a priori em qualquer avaliação de desempenho pretendida em sistemas de filas.

Pelas definições anteriores, pode-se observar que há sempre um tempo entre ocorrências de eventos, apesar de a ocorrência dos eventos, por definição, não demandar tempo, isto é, os eventos ocorrem de maneira imediata.

O que há é um tempo entre as gerações e para o atendimento dos clientes, tarefas que acontecem em um determinado componente do sistema (por exemplo, um processador), o qual é representado em Statecharts ou em algum outro diagrama orientado a estados por um estado (ou um agrupamento deles).

Assim, da idéia de que tarefas são realizadas dentro de determinados estados, consumindo um certo tempo gera a proposição de estados que possuem tempos de permanência associados, mesmo que esse tempo seja igual a zero (caso dos estados que transicionam de maneira imediata).

A notação gráfica, assumida neste trabalho, para diferenciar os estados com retardos e os estados imediatos é apresentada a seguir.

Apesar de utilizar a representação idêntica à sugerida por D.

Harel para estados com delays e timeouts, a semântica aqui é ligeiramente modificada, com o intuito de obter uma melhor adequação às necessidades das situações de sistemas de filas.

Na semântica original, a partir da ocorrência de um evento, o estado dispara um temporizador implícito, que conta o número de unidade de tempo apresentado na inequação.

Apenas após decorrido esse tempo, o sistema abandona o estado, funcionando como um timeout para uma determinada atividade.

Já na representação sugerida neste trabalho, o sentido é que tempo ou é uma média dos tempos entre chegadas (para o caso dos estados-fonte) ou ele é um tempo médio de serviço (para os casos de servidores), ambos assumidos como exponencialmente distribuídos.

Assim, o tempo que o temporizador conta, a partir da entrada no estado, é uma das variáveis aleatórias que devem ser conhecidas previamente, como comentado anteriormente.

Essa nova abordagem dada ao delay traz em seu cerne uma complexidade que, à primeira vista, pode não estar muito aparente, a determinação da próxima configuração, levando-se em consideração que o passo não é mais uma única unidade de tempo relacionada à execução dos Statecharts.

A seção apresenta as funções que determinam a próxima configuração a ser tomada pelo modelo, a partir da observação dos tempos nos estados não imediatos.

Em sistemas de filas, é necessário atribuir um valor probabilístico a cada possível caminho a ser seguido por um cliente.

Essa circunstância leva à situação na qual a escolha dentre os vários caminhos possíveis está atrelada a uma probabilidade, o que introduz a idéia de uma escolha realizada através desse parâmetro.

Apresenta uma notação semelhante àquela utilizada para entrada por condição, substituindo-se apenas a letra C pela letra P (de probabilidade).

A interpretação dada à Figura é que uma vez abandonado o estado A2, e2 pode estar condicionado à probabilidade {p} ou à {1-p}, e a partir do caminho escolhido, será disparada ou a ação a1 ou a ação a2, em algum componente paralelo não especificado na Figura.

Formalmente, a condição probabilística é definida.

Por extensão, se c e pi, então ev e ev(pi) são evento atrelado a uma condição c e evento condicionado a uma probabilidade pi, respectivamente.

Com o intuito de diferenciar a condição probabilística das demais, usa-se a notação particular ev{pi}, em lugar da notação original ev.

Redefinição de Passos e Configurações para Statecharts Estocásticos.

Neste ponto, volta à tona a discussão a respeito do caráter temporal dos passos e configurações, que, se neglicenciado, poderá gerar um caráter de não-determinismo entre as sucessivas configurações do sistema.

Pela definição de Harel, um sistema é não determinístico em SC se há duas reações possíveis.

Assim, uma configuração e um passo têm uma interpretação se todos os seus estados são considerados imediatos, e têm outra interpretação diante da presença de estados com retardos associados.

Um estado é considerado com retardo quando existe uma variável i, a qual quando avaliada determina o tempo médio entre chegadas de clientes, caso o estado seja a fonte geradora desses clientes (Source), admitindo-se que os tempos entre chegadas são exponencialmente distribuídos, o tempo médio de serviço destinado aos clientes, caso o estado seja um servidor (em seu estado Busy), admitindo-se que os tempos de serviço são exponencialmente distribuídos.

Um estado é considerado imediato quando seu retardo é considerado zero.

Se, em um Statechart, as suas configurações e o tempo de seus passos são determinados pelas definições então esse Statecharts é Estocástico.

Pelas definições acima e, utilizando o exemplo de um servidor de arquivos, agora na notação estendida para a visão estocástica, com os valores hipotéticos, pode-se traçar uma linha do tempo para determinar o tempo de cada passo, que são o início e o fim de cada configuração.

Além disso, pode-se determinar a ordem em que as configurações ocorrem.

Servidor de Arquivos e seus Estados com Retardos Associados.

Seja SC1 a configuração dos estados default que apresenta o ingresso do sistema no estado Source (um estado com retardo de 5 ut), e seja SC2 a configuração sucessora, que é função da primeira, em relação ao tempo.

Uma vez alcançado Source, o sistema -espera- por 5 ut até gerar o primeiro cliente (evento jg).

Após decorridas as 5 ut, o passo 1 é completado com a execução da ação.

Na configuração seguinte, SC3 habilita de maneira imediata as transições dos eventos jg, e alcança simultaneamente Source e BusyProc.

O tempo do passo e a próxima configuração serão determinados pelas funções descritas anteriormente (de acordo com a visão estocástica).

O tempo que extrapola o tempo do passo 2 para os estados diferentes daquele que possui o tempo mínimo, isto é, o tempo que extrapola do passo 2 para o passo 3 é de 2 ut no estado Source.

Quando o passo 2 completar 8 ut (ao seu término), significando que os estados que não completaram o seu retardo em um determinado passo, começam o próximo com os seus tempos iguais ao restante do passo anterior.

Apresenta a linha do tempo, com os tempos de cada passo, de acordo com os valores obtidos anteriormente.

Linha do Tempo com suas Configurações e Passos.

O tempo que extrapola o tempo do passo 3 para os estados diferentes daquele que possui o tempo mínimo, isto é, o tempo que extrapola do passo 3 para o passo 4 é de 2 ut no estado BusyDisc.

Para proceder-se se admitindo as premissas anteriores, devem-se estabelecer algumas considerações.

Primeiramente, é importante esclarecer onde se encontra o caráter aleatório da especificação e das funções admitidas.

A aleatoriedade é intrínseca às distribuições de geração e de atendimento ao cliente, pois são essas distribuições que geram os ritmos de chegada e de serviço (variáveis aleatórias que servem de entrada para a solução do sistema).

As funções definidas como premissas garantem que os eventos possam manter a ordem esperada para um sistema de filas genérico, o que não prejudica em nada a abordagem estocástica.

Outro ponto a ser considerado é o fato de haver um certo padrão de eventos e de estados que representam os sistemas de filas, de um modo geral.

Na verdade, há um padrão referente aos estados e eventos para representar sistemas de filas, apesar das possíveis variações de nomenclatura.

A próxima seção apresenta um conjunto de templates que visam à representação mais uniforme desses sistemas característicos.

Templates e Eventos-Padrão para Sistemas de Filas.

Esta seção se destina a apresentar um conjunto de quatro templates e seus eventospadrão para especificação de sistemas de filas.

No contexto deste trabalho, template é um conjunto de estados (possivelmente unitário) que define o funcionamento básico de um determinado componente do sistema.

A idéia é que, à exceção de algum parâmetro variável (por exemplo, valores dos tempos de serviço em um servidor), o template seja aplicável para um determinado componente, com o mínimo possível de modificação.

No template, não há uma geração imediata do primeiro cliente, pois o estado default já é um estado com retardo, que uma vez alcançado, deve-se esperar transcorer retardo associado a ele.

Já no template, há a geração de um cliente no instante zero, em virtude do estado default ser um estado imediato, o que não demanda tempo.

Em ambos, o evento jg (jobgeneration) é responsável pela geração de um cliente, e a ação inc_s acrescenta o cliente gerado na fila de um servidor s.

A escolha entre os dois depende exclusivamente das características do sistema em estudo.

O template fila é composto por dois subestados, Idle e Busy.

Por default, a fila se encontra vazia (Idle), e a cada geração de cliente, há um acréscimo unitário na fila, levando o estado para Busy.

Ocorrências reiteradas do evento inc_s mantêm a fila em Busy, assim como reiterações de dec_s decrementam a fila até o valor limite unitário, a partir do qual, a fila muda para Idle, indicando a ausência de clientes.

Vale ressaltar que um decréscimo na fila indica que um cliente alcançou o servidor.

O template para servidores é composto por dois subestados, Idle e Busy, com os significados de certa forma óbvios, ressaltando-se que em Busy há um retardo, que significa um valor médio de uma distribuição de probabilidade.

Se houver algum cliente na fila, o evento tr pode ser executado e sua transição é habilitada e a fila decrementada, em virtude de ter ido um cliente para o servidor.

Após o atendimento em Busy,eos pode ser executado através de uma de suas condições probabilísticas.

A ida a outro servidor implica envio de um cliente para a fila desse servidor, e, caso contrário, o cliente abandona o sistema.

É importante observar que pode haver mais de duas escolhas possíveis, cada uma com a sua respectiva probabilidade, assim como pode existir apenas uma escolha possível, onde se faz desnecessária a utilização da escolha por probabilidade.

O template de sorvedouro (Destination) é composto por dois subestados, que indicam que o sorvedouro está à espera de alguma resposta (Idle) ou que ele recebeu a resposta, podendo então abandonar o sistema.

De maneira a uniformizar também os eventos interessantes à avaliação de desempenho, alguns eventos são padronizados na especificação baseada nos templates sugeridos anteriormente, o que não impede que se criem outros eventos que aumentem a clareza da especificação, quando isso for necessário.

Apresenta o rótulo dos eventos, além da semântica atribuída a cada um deles.

Job Generation.
Geração de um cliente obedecendo a uma determinada distribuição de probabilidade.

Increment of Server Queue Incrementa a fila de um determinado servidor S.

Decrease of Server Queue Decrementa a fila de um determinado servidor S.

Assegura que a fila do servidor não está vazia, e que próximo cliente pode ir ao servidor.

End of ServiceIndica o término do atendimento a um cliente, e uma escolha probabilística para determinar o caminho a ser seguido pelo cliente.

Indica que o cliente sai do sistema que o provê de um determinado serviço e vai até um sorvedouro.

Esta seção se destina a apresentar uma alternativa a uma deficiência da especificação dos Statecharts, a dificuldade de se representar o caminho linear que um determinado cliente traça durante a sua passagem pelo sistema.

Essa representação é suficientemente coberta pela especificação de redes de filas, através da ligação seqüencial estabelecida entre os componentes do modelo.

Não obstante, redes de filas não representam adequadamente a complexidade que os servidores necessitam para que suas descrições se tornem esclarecedoras, o que pode ser feito de forma bastante natural em Statecharts.

Assim, para representar sistemas de filas, redes de filas e Statecharts possuem representações complementares.

Partindo-se dessa premissa, propõe-se uma aglutinação entre a especificação de redes de filas e a de Statecharts, visando a prover uma especificação mais completa para sistemas de filas.

Queuing Statecharts (QS) são definidos, através de seus componentes.

Possui uma variável que representa a variável aleatória tempo entre geração de clientes, obedecendo a uma distribuição de probabilidade exponencial.

Assim como nos Statecharts estocásticos, para Queuing Statecharts também há um conjunto de eventos-padrão, usado para definir o comportamento básico de um sistema de filas.

Há a manutenção de todos as definições apresentadas anteriormente, tanto aquelas definidas, quanto as definidas na seção 4, na qual são especificadas as diretrizes para os Statecharts Estocásticos.

Desta forma, as definições de escolha por probabilidade, estados com retardos associados, além das redefinições de Passos e Configurações para Statecharts Estocásticos são aqui também assumidas.

Com a especificação de Queuing Statecharts há uma aglutinação entre características interessantes tanto de redes de filas quanto de Statecharts.

Queuing Statecharts é um meiotermo entre a especificidade das redes de filas e o caráter generalista dos Statecharts.

A solução aqui adotada é baseada em redes de Jackson para modelos abertos (há geração externa de clientes, assim como há saída do sistema).

A solução de Jackson assume algumas restrições não discutidas aqui, mas que são perfeitamente aceitáveis para o exemplo em estudo.

A solução por simulação adota a extensão à linguagem C, denominada smpl - SiMulation Programming Language.

Pelo fato do smpl ter sido proposto com uma orientação a eventos, há uma correlação direta com os eventos Statecharts dos templates que descrevem o funcionamento básico de um sistema de filas.

Essa correlação é sintetizada na tabela, onde os eventos padrão dos templates são associados às funções smpl.

A correlação eventos Statecharts e funções smpl é mostrada, na qual cada evento dos templates (e conseqüentemente de um sistema de filas) tem uma correspondência unívoca com as funções smpl.

As medidas obtidas para o exemplo, utilizando-se a solução por simulação, são apresentadas admitindo-se os mesmos parâmetros de entrada.

Medidas Obtidas pela Solução por Simulação smpl.

A escolha entre as soluções mencionadas na seção anterior está mais atrelada a critérios subjetivos, que às restrições que cada abordagem possui.

Esse assunto não é consensual, havendo duas correntes distintas de pensamento.

Algumas das restrições das soluções analíticas descritas são dificuldade no tempos de serviços não-exponenciais (serviços descritos de maneira mais realista, com distribuições como a hiperexponencial, têm um tratamento menos trivial).

Dificuldade na análise do estado transiente do sistema (via de regra, admite-se, na solução analítica, que o sistema se encontra em equilíbrio), dificuldade no tratamento da posse simultânea de recursos (um mesmo cliente não consegue deter mais de um recurso simultaneamente), dificuldade no tratamento de recursos passivos (como memória de computador).

Para a solução por simulação, algumas das restrições listadas, os resultados são sempre uma aproximação (por melhores que elas sejam), dependência do tratamento estatístico para os validar os resultados obtidos (cálculo do intervalo de confiança e de outras medidas estatísticas para garantir a validade dos resultados), dificuldade de lidarse com algumas linguagens e ferramentas de simulação.

A despeito da solução adotada, as especificações apresentadas são genéricas o bastante para permitir que se utilize a abordagem de preferência do modelador.

Este artigo apresenta uma alternativa a algumas deficiências nas especificações mais usuais de sistemas complexos, inserindo características da representação Statecharts, tais como de hierarquização do molelo, representação explícita de componentes paralelos, mecanismos de comunicação entre esses componentes e estados default.

A despeito do potencial dos Statecharts em representar sistemas dessa categoria, os mesmos não possuem uma abordagem voltada à avaliação de desempenho formalmente definida, apesar de já ter sido sugerido pelo seu próprio criador D.

Harel, denominado à época de Markovcharts.

Para viabilizar a abordagem baseada em Statecharts foi idealizado um conjunto de templates para representar os componentes básicos de um sistema de filas (o ponto chave da avaliação de desempenho).

A esses templates é sempre associado um método de solução, tanto analiticamente como por simulação.

A idéia é que a especificação seja genérica a ponto de independer da solução adotada.

Dessa forma, o processo de modelagem pode contar com uma especificação mais adequada às características de sistemas complexos.

Além disso, usuários menos especializados em soluções matemáticas, certas vezes não triviais, podem ter uma visão em alto nível do problema modelado.

Algumas das definições apresentadas neste artigo proporcionam um estudo passo a passo do sistema, em contrapartida à visão do estado de equilíbrio adotado em técnicas como redes de filas.

Com o objetivo de representar sistemas no estado transiente, são redefinidos os conceitos de passo e configuração, através de funções que estabelecem o tempo de duração dos passos e o algoritmo para a determinação da configuração sucessora.

Algumas outras peculiaridades não foram tratadas neste formalismo, mas estão sendo tratadas como possíveis extensões.

Algumas das restrições não abordadas são geração de clientes em "lote" (diferente da geração de Poisson, apresentada neste trabalho), além de templates para sistemas de filas fechados (sem geração externa de clientes).

Há um interesse implícito em trazer a contribuição de potenciais usuários da especificação Statecharts para a área de avaliação de desempenho, o que otimizaria o processo de modelagem, tornando-o mais abrangente e mais bem definido.

