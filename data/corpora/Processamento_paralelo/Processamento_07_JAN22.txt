Sistemas distribuídos oferecem uma alta capacidade teórica de processamento.

No entanto, para se tirar proveito dessa capacidade, deve-se ser capaz de se designar tarefas aos processadores componentes desses sistemas de modo que o tempo de execução da aplicação como um todo seja o menor possível.

Tendo isso em mente, um escalonador distribuído é um componente gerenciador de recursos cujo foco é distribuir a carga do sistema entre seus componentes de modo que seu desempenho geral seja maximizado.

Porque redes WAN têm atrasos de comunicação muito altos, escalonamento distribuído é mais adequado a redes locais.

Escalonamento distribuído é um dos problemas mais desafiadores na computação paralela e distribuída.

É sabido ser esse problema NP-completo em sua forma geral e em diversos casos restritos, sendo que algoritmos ótimos são encontrados em apenas poucas situações.

Por esse motivo, para se resolver o problema geral em um tempo razoável são necessários métodos heurísticos, baseados em parâmetros que afetam o comportamento do sistema, que garantem apenas uma solução próxima à ótima.

Os algoritmos de escalonamento partem do princípio de que o programa paralelo é uma coleção de tarefas que podem ser executadas fora de ordem, dadas as restrições de precedência entre as mesmas.

Caso não existam essas restrições, o problema de escalonamento é conhecido como problema de alocação de tarefas.

Uma apresentação dos componentes de um escalonador distribuído pode ser vista na seção 2.

Apresenta uma proposta de classificação dos diferentes tipos de algoritmos desenvolvidos para se tratar esse problema.

São apresentados os casos onde pelo menos uma solução ótima para o escalonamento distribuído é conhecida.

Começará a ser considerado o tempo gasto com a comunicação entre os processos na abordagem do problema, que era ignorada até agora e é um dos pontos-chave no escalonamento em um sistema real.

Alguns sistemas de heurística utilizados em algoritmos são apresentados.

Todos os algoritmos discutidos executam sobre uma representação estática das tarefas componentes do programa em um grafo, na seção 6, são apresentadas situações onde uma abordagem dinâmica para problema de escalonamento obtém melhores resultados.

Um algoritmo distribuído tem quatro componentes, a saber, Política de transferência, determina se um nodo está em um estado propício para participar do escalonamento.

Geralmente, é implementada como um monitor da fila de tarefas designadas ao processador, caso seu tamanho ultrapasse um limiar T, a política decide que ele é um emissor de tarefas, caso seja inferior a que T, ele é um receptor de tarefas.

Política de seleção, determina quais tarefas serão escalonadas pelo sistema.

Política de alocação, determina para qual nodo uma tarefa selecionada para transferência será designada, baseando-se comumente na política de polling, onde os nodos são consultados pelo escalonador para verificar se eles estão aptos para fazer a distribuição de carga ou não.

Política de coleta de informações, determina como, quando e de que forma as informações correspondentes ao estado do sistema serão coletadas, sendo implementada comumente tanto como periódica quanto como orientada à demanda (isto é, quando um nodo se torna emissor ou receptor).

Baseado nos dados informados por cada uma das políticas descritas acima, o algoritmo de escalonamento toma suas decisões.

Além disso, também segundo, um escalonador distribuído deve ser escalável, produzindo resultados em tempos próximos para pouca e muita carga de trabalho, transparente, no sentido de que deve mascarar a localização das tarefas para o usuário.
Determinista, produzindo os mesmos resultados independentemente de onde as tarefas se encontram e da política de escalonamento utilizada, não-degradante, no sentido de que não deve sobrecarregar processadores de trabalho quando houver processadores com pouca ou nenhuma carga.
Heterogêneos, no sentido de que devem ser capazes de distinguir entre diferentes tipos de hardware e tomar as decisões ótimas para cada tipo.

O requerimento heterogeneidade é o mais difícil de ser obtido, pois acrescenta complicações nas decisões a serem tomadas pelo escalonador.
Como, segundo, por exemplo, a restrição de que uma determinada tarefa t só possa ser executada no ambiente que contenha o conjunto de instruções de t, ou ainda, a exigência de que o escalonador deve levar em conta a capacidade de processamento de cada nodo para estimar individualmente o tempo de execução da tarefa nesse nodo e decidir se ele é a melhor opção para executar uma dada tarefa.

Por estes motivos, as pesquisas estão focadas primariamente em modelos de sistemas homogêneos.

Como mencionado anteriormente, o problema irrestrito de escalonamento distribuído é NP-completo.

Na busca por meios de se explorar da melhor maneira possível os recursos de um sistema distribuído em um tempo viável, um grande número de técnicas e metodologias foi desenvolvido e, juntamente com elas, diversas tentativas de classificá-las e organizá-las.

Considerando isso, propuseram uma taxonomia que tenta particionar o universo de algoritmos da melhor maneira possível, sendo referenciada também por.

Essa taxonomia consiste de uma representação em árvore da hierarquia de algoritmos distribuídos e de uma série de complementações à mesma.

Aqui é apresentada a taxonomia principal e alguns dos critérios de complemento de, bem como alguns critérios complementares propostos por outros autores.

A diferenciação entre local e global é trivial.

A divisão mais significativa é a em estática e dinâmica, e diz respeito a quando as decisões de escalonamento serão tomadas.

Diz-se a mais importante porque há casos onde algoritmos dinâmicos são muito mais efetivos do que estáticos.

Em ambos os casos, o processo a ser executado é dividido em tarefas, e a precedência entre essas tarefas é representada por um grafo.
No entanto, nos algoritmos estáticos, assume-se que todas as informações sobre as tarefas são conhecidas antes do tempo de execução, enquanto que nos algoritmos dinâmicos é assumido que pouco a priori se sabe sobre as necessidades da tarefa, como desvios condicionais, iterações em um laço de execução ou até mesmo o ambiente em que ela será executada.

No caso da divisão entre ótimo e subótimo, no primeiro caso se considera que todo o conhecimento relacionado ao estado do sistema e às necessidades do processo são conhecidos quando do momento do escalonamento, enquanto que, quando algum destes problemas é computacionalmente intratável ou não pode ser medido com certa precisão, uma abordagem subótima é estimada.

Seguindo-se por este caminho, chega-se à divisão entre aproximada e heurística.

Numa solução aproximada, utiliza-se o modelo formal padrão do processo e se busca a primeira solução considerada razoável no espaço de soluções possíveis, enquanto que uma solução heurística faz assunções realistas sobre o conhecimento a priori das tarefas baseadas em parâmetros que afetam o sistema como um todo, obtendo em um tempo menor do que o exponencial uma solução próxima à ótima.

Em seguida, podem-se ver as categorias básicas de algoritmos usados nesses tipos de escalonamento, isto é, algoritmos baseados em teoria dos grafos ou teoria das filas, em programação matemática e em enumeração no espaço de soluções, que são comuns tanto à abordagem ótima quanto à subótima aproximada.

Voltando-se na hierarquia, chega-se à divisão entre distribuído e não-distribuído, que basicamente indica se a responsabilidade pelo escalonamento reside em um único processador, que escalona as tarefas e direciona-as para os demais processadores, ou se essa decisão é fisicamente distribuída entre os processadores componentes do sistema.

A última divisão diz respeito a trabalho cooperativo ou não-cooperativo.

No primeiro, as decisões são tomadas cooperativamente entre os processadores, no último, cada processador toma uma decisão independentemente dos demais, baseado apenas em parâmetros locais, ou seja, a melhor decisão local.

Note que o nodo cooperativo da árvore também se subdivide em ótimo e subótimo, tratados anteriormente.

Juntamente com essa taxonomia, os algoritmos ainda podem ser classificados de acordo com mais uma série de critérios, sendo aqui apresentados dois exemplos de acordo com, Se os parâmetros usados para se implementar o escalonamento mudam dinamicamente de acordo com o comportamento do sistema, o algoritmo é dito adaptativo, caso contrário, é dito não-adaptativo.

Se, ao designar uma tarefa a um processador, essa tarefa não possa migrar para outros processadores no escalonamento, diz-se que o algoritmo é uma-vez designante, caso a tarefa possa migrar entre processadores, é dito dinamicamente designante.

Aqui é importante notar que, se o algoritmo for dinamicamente designante, além da tarefa deverá ser realocado também todo seu contexto, e todos os dados em cache referentes a essa tarefa serão perdidos, gerando uma alta taxa de cache miss sempre que um processo for migrado entre processadores.

Além disso, explicitam melhor a diferenciação entre outras duas classes de algoritmos, a saber, Se o algoritmo tenta compartilhar a carga de trabalho entre os processadores, transferindo tarefas de um nodo sobrecarregado para outro com pouco ou nenhum trabalho, ele é chamado de compartilhador de carga.

Se ele tenta antecipar estes estados de processamento concentrado em alguns nodos, tentando distribuir as tarefas igualmente entre os processadores, ele é chamado de balanceador de carga.

Ainda, recentemente, uma nova área de pesquisa, chamada de Teoria da Carga Divisível, está sendo desenvolvida.

Foi constatado que, em tarefas computacionalmente intensivas e que consistem em grandes volumes de dados sendo processados independentemente podem ser divididas dinamicamente em tempo de escalonamento para melhor aproveitar esse paralelismo de dados.

Pesquisas nessa área estão voltadas em como identificar as relações entre os dados sendo processados em uma tarefa e, usando esse conhecimento, juntamente com informações paramétricas do sistema, particionar essas tarefas em segmentos de tamanho ótimo para cada processador.

Sendo assim, os algoritmos ainda podem ser Não se considerando a comunicação entre as tarefas, algoritmos polinomiais podem ser encontrados em apenas três casos, quando o grafo de tarefas é uma árvore, quando o grafo é uma ordem de intervalos, ou quando há apenas dois processadores disponíveis.

Em todos os casos, é assumido que todas as tarefas têm o mesmo tempo de execução, unitário.

Outros pontos comuns entre os algoritmos são que todos incluem algum tipo de designação de prioridade às tarefas.

O escalonamento é feito sobre uma lista de tarefas ordenadas em uma ordem decrescente de prioridade, e uma tarefa é considerada pronta para ser executada quando todas as suas predecessoras no grafo de tarefas já tiverem sido executadas.

Para todos os algoritmos apresentados nessa seção, pode-se referir a para provas de que os mesmos produzem resultados ótimos.

Caso o grafo seja uma árvore, ele ainda deve ter a propriedade de que ou cada tarefa tem no máximo um predecessor imediato ou no máximo um sucessor imediato.

Para essas limitações, pode ser obtido um algoritmo que executa em tempo linear em relação ao número de tarefas, cuja estratégia geral é encontrar o caminho entre o nodo de prioridade mais alta (a última folha da árvore) e o de prioridade mais baixa (a raiz da árvore), garantidamente único.

Esse algoritmo é apresentado abaixo.

A distância entre cada nodo da árvore e a raiz é calculada e usada como a prioridade da tarefa.

Insira na lista de tarefas aptas a executar todas as tarefas sem predecessores ou cujos predecessores terminaram sua execução.

Sempre que um processador se tornar disponível, retire a tarefa de maior prioridade da lista e designe-a a esse processador.


Pode-se ver claramente que esse algoritmo tem uma complexidade linear em função do número de nodos da árvore, já que cada nodo é visitado uma única vez.

Pode-se ver pela estrutura do algoritmo que um caso ótimo também pode ser encontrado quando cada tarefa executa em um período arbitrário de tempo, sendo sua complexidade igual a O, onde m é o número de processadores, Tl é o tempo de execução da tarefa mais longa e Tt é o tempo total de execução das tarefas.

A idéia desse algoritmo é dividir as tarefas com tempo de execução não unitário em tarefas de tempo unitário.

Um grafo é dito uma ordem intervalar quando todos os seus elementos podem ser mapeados para intervalos na reta real, e dois elementos só estão relacionados se os intervalos correspondentes não se sobrepõem.

Caso o grafo de tarefas seja uma ordem intervalar, ele apresenta a propriedade de que, dados um par de tarefas intervalarmente ordenadas u e v, ou os sucessores de u são também sucessores de v ou os sucessores de v são sucessores de u.

Essa propriedade, aliada à restrição de que todas as tarefas têm o mesmo tempo de execução, torna possível o uso de um simples algoritmo guloso de complexidade O(n + e) para que se possa criar uma lista ótima de escalonamento.
Onde n é o número de tarefas e e é o número de arestas na ordem intervalar (desde que o grafo seja direcionado e acíclico), podendo-se utilizar o mesmo algoritmo da seção 4 1 1 para se resolver de maneira ótima o problema do escalonamento.

Quando a restrição de tempo unitário de tarefas é relaxada, o problema torna-se NP-completo.

Por último, caso o grafo de tarefas seja arbitrário, direcionado e acíclico, todas as tarefas tenham o mesmo tempo de execução e haja apenas dois processadores disponíveis, um algoritmo de tempo polinomial pode ser obtido.

Defina a prioridade do nodo de saída de grafo como sendo igual a 1.

Assuma que as prioridades 1, 2,j-1 já tenham sido atribuídas.

Seja S o conjunto de tarefas ainda sem prioridades definidas cujos sucessores já tenham prioridades definidas.

Selecione um elemento de S para ser designada a prioridade j da seguinte maneira.
Defina l(x) como a seqüência decrescente de inteiros formados ordenando-se o conjunto das prioridades dos sucessores imediatos de x.

Assuma x como um elemento de S tal que para todos os demais x' em S, l(x) <= l(x'), lexicograficamente.

Defina a prioridade j à tarefa x.

Depois de a todas as tarefas terem sido designadas prioridades, use a lista de tarefas ordenada de forma decrescente com relação à prioridade no escalonamento.

Partindo da primeira tarefa na lista, designe cada tarefa para o processador que permite o menor tempo de início para a execução da tarefa entre os dois processadores disponíveis.

Basicamente, o algoritmo funciona designando prioridades aos nodos do grafo de tarefas partindo do nodo de saída do grafo e subindo em direção aos nodos de entrada, considerando como candidato para a designação da próxima prioridade como um nodo que já tenha tido todos os seus sucessores rotulados.

Depois que todos os nodos já têm uma prioridade, a lista mencionada é criada, e o escalonamento ótimo é obtido escalonando-se as tarefas dessa lista aos processadores ociosos.

A complexidade do algoritmo é O(n) porque os processos de construção da lista e de 2 escalonamento são executados com esse tempo.

Uma prova de que esse algoritmo computa o escalonamento ótimo pode ser vista.

Mencionam um algoritmo com complexidade menor para tratar desse problema.

Essa diminuição de complexidade se dá a partir da observação de que os rótulos de um conjunto de nodos de mesma altura no grafo dependem apenas de seus sucessores.

Assim, ao invés de se construir a informação de ordenação desde o primeiro nodo, o processo de rotulação pode inferir tal informação visitando seus sucessores diretos.

Em sistemas reais, a comunicação entre as tarefas é um fator determinante para o desempenho da aplicação, e, portanto, não pode ser desprezada pelo escalonador distribuído.

De fato, para se obter o maior desempenho desses sistemas, o escalonador deve buscar o melhor comprometimento entre paralelismo e atrasos devidos à comunicação.

O problema da comunicação já se mostra presente no momento na divisão da aplicação em tarefas, uma tarefa pode ser tão pequena quanto uma única instrução ou tão grande quanto um programa inteiro.
No entanto, se a tarefa for grande demais, o paralelismo é reduzido, porque tarefas potencialmente paralelas estariam agrupadas, executando seqüencialmente em um único processador, e, se a tarefa é muito pequena, mais overhead na forma de comunicação entre essas tarefas é adicionado ao tempo de execução total.

Além disso, se a abordagem de estiver sendo usada, isto é, se o escalonador particiona dinamicamente uma tarefa para aumentar seu paralelismo, designando cada parte a processadores diferentes.
Deve-se verificar se o paralelismo ganho com o particionamento dinâmico da tarefa supera em desempenho o atraso de comunicação que pode potencialmente existir entre as partes e que será somado ao tempo de execução total, o que aumenta a complexidade desse tipo de escalonador.

Além disso, uma escolha crítica quando se trata a comunicação em escalonadores distribuídos é a do modelo a ser escolhido para se computar o custo da comunicação entre as tarefas.

Segundo, apenas dois casos de algoritmos ótimos são conhecidos, também para situações extremamente restritas, o primeiro caso é quando o grafo é uma árvore com as mesmas propriedades da árvore tratada.
Há apenas dois processadores disponíveis, gerando um algoritmo de complexidade O(n), onde n é o número de tarefas, ou quando o grafo é uma ordem intervalar com as mesmas propriedades mencionadas, onde se consegue um algoritmo de complexidade O(e + nm), sendo e o número de arcos na relação de ordem, n o mesmo mencionado anteriormente e m o número de processadores.

As provas de que esses algoritmos produzem soluções ótimas e mais detalhes referentes a eles podem ser obtidas.

Em ambos os casos, são assumidos que o tempo de execução da tarefa é uma unidade de tempo, que a comunicação entre tarefas no mesmo processador é nula, que a comunicação entre tarefas em processadores diferentes é uma unidade de tempo, e que uma tarefa pode ser designada a um processador para execução enquanto esse processador está realizando comunicação.

Pode-se notar que as restrições necessárias para que o problema seja tratável são muito severas, e não condizem com características de sistemas reais.

No entanto, se tais restrições são relaxadas, o problema foge do escopo ótimo devido a sua alta complexidade.

Por esse motivo, uma abordagem subótima do problema é necessária, e pesquisas recentes têm dado ênfase a técnicas heurísticas para tanto, que produzem soluções em tempo menor do que exponencial, mas não garantidamente ótimas.

A efetividade dessas heurísticas depende de diversos parâmetros da aplicação e do sistema distribuído, significando que uma heurística que funciona razoavelmente bem em um sistema pode não funcionar tão bem em outro.

Por esse motivo, um grande número de heurísticas tem sido proposto, cada um para trabalhar em sistemas de características diferentes.

Entre as heurísticas propostas, a que encontra maior aceitação nos algoritmos de escalonamento distribuído é chamada de heurística de escalonamento em lista, e recebeu vários melhoramentos desde que foi proposta.

Esta técnica consiste em designar prioridades às tarefas e colocá-las em uma lista ordenada de forma decrescente em relação a essas prioridades, sendo sempre a tarefa de maior prioridade escalonada primeiro.

Uma vez que uma tarefa seja selecionada para escalonamento, um critério de seleção de processadores deve se seguir, para se identificar para qual processador dentro do grupo de trabalho a tarefa será designada.

Algoritmos diferem em como atribuir prioridades às tarefas e/ou em qual critério é utilizado na seleção do processador.

A cada nodo do grafo de tarefas é designada uma prioridade.

Uma lista de tarefas aptas à execução é criada inserindo-se nela cada tarefa do grafo que não tem predecessores imediatos (isto é, é um nodo de entrada do grafo e, portanto, sua execução não depende da execução prévia de outras tarefas).

Essa lista é organizada de forma decrescente em relação ao número de prioridade das tarefas.

Enquanto essa lista não está vazia, faça o seguinte, 21) Retire a tarefa de maior prioridade do topo da lista.

Selecione um processador para o qual será designada a tarefa e designe-a para esse processador.

Insira um sucessor na lista de tarefas aptas depois de todos os seus predecessores imediatos terem terminado sua execução.

Esse algoritmo tenta minimizar o tempo total gasto para se executar todas as tarefas minimizando o tempo de finalização de cada tarefa designada.

Como dito anteriormente, várias derivações deste algoritmo são obtidas modificando-se a forma de como as prioridades são designadas às tarefas e/ou a forma de seleção do processador em que a tarefa será executada.

Por exemplo, uma derivação dessa heurística pode designar prioridades baseada no comprimento do mais longo caminho a um nodo de saída do grafo de tarefas, enquanto que outra pode utilizar o número de sucessores de um nodo para tanto.

Similarmente, o melhor tempo de início de uma tarefa e o melhor tempo de término podem ser usados como critério de seleção do processador.

A escolha é dependente das especificações do sistema e das necessidades da aplicação.

Para uma descrição mais detalhada do algoritmo, verifique.

Nesta subseção serão citados alguns melhoramentos propostos para o caso genérico da heurística tratada anteriormente, baseando-se em e em.

O melhoramento proposto aqui é uma modificação da rotina que designa uma tarefa a um processador, que faz uso do tempo ocioso desse processador tentando designar tarefas prontas a essas fatias de tempo ociosas, otimizando seu uso e diminuindo o tempo total necessário à execução da aplicação como um todo.

Essa heurística propõe executar múltiplas instâncias de uma tarefa para reduzir o custo de comunicação, executando-se, por exemplo, tarefas emissoras de mensagens e tarefas receptoras de mensagens em um mesmo processador, transferindo o problema de comunicação interprocessador para um problema intraprocessador, com um atraso muito menor.

Conseqüentemente, também age diminuindo o tempo de início de tarefas sucessoras de um nodo único, quando as instâncias dessa tarefa multiplicada terminam, todos os seus sucessores diretos já estão aptos a executar.

O melhoramento dessa heurística consiste em considerar diversos parâmetros do sistema para o qual é projetado para guiar as decisões do escalonamento.

É, portanto, uma versão adaptativa do algoritmo de escalonamento em lista.

Entre as diversas propostas de heurísticas alternativas à de escalonamento em lista, a mais aceita é a de heurísticas de clustering.

A idéia por trás desse tipo de heurística é dividir o processo de escalonamento em duas fases, designação de processadores, que é o processo de alocar um conjunto de tarefas a cada processador do sistema, e ordenamento de tarefas, que é o processo de escalonar as tarefas alocadas em cada processador.

Clustering pode ser definido como o processo de mapear nodos do grafo de tarefas em clusteres rotulados, sendo que todas as tarefas pertencentes ao mesmo cluster devem executar no mesmo processador.

O algoritmo geral é executado sobre diversas sementes, representado os clusteres iniciais, sobre estas sementes são executadas operações de melhoramento que visam o crescimento ótimo do cluster.

Infelizmente, o problema de se obter um clustering ótimo é NP-completo, sendo necessárias, portanto, heurísticas que orientem o processo.

Essas heurísticas diferem em onde as sementes iniciais se localizam e em quais operações de melhoramento e expansão do cluster são aplicadas.

Apresentam várias opções de heurísticas de clustering.

É importante salientar que, sendo as técnicas heurísticas dependentes do sistema e da aplicação, não se pode afirmar com certeza que uma heurística é superior a outra no caso geral, apenas em sistemas e aplicações específicas.

A idéia básica dos algoritmos dinâmicos é realizar o escalonamento de aplicações representadas como grafos não-determinísticos, isto é, onde há parâmetros no grafo que não podem ser estimados antes do início da execução da tarefa, sendo necessário se coletar esses dados durante a execução das tarefas para guiar o escalonador.

Nesse contexto, há quatro casos a considerar.
Grafos com desvios condicionais, modelam um programa contendo desvios condicionais, que só podem ser avaliados durante a execução do programa, fazendo com que subprogramas inteiros (possivelmente vários nodos do grafo de tarefas) não sejam executados.

Grafos com ciclos, ocorrem sempre que há um laço no programa, não sendo possível se saber a priori quantas vezes o corpo do laço será executado (note que este é um caso específico de grafos com desvios condicionais).

Tempo de execução variável, ocorre sempre que o tempo de execução da tarefa depende de dados fornecidos na entrada do programa ou de predicados calculados durante sua execução.

Tempo de comunicação variável, ocorre sempre que mensagens de tamanho variável são trocadas, ou quando a comunicação entre os diversos pares de processadores tem durações diferentes.

Em todos esses casos, métodos estáticos também podem ser aplicados, tentando-se prever o comportamento da aplicação antes de sua execução, no entanto, essa abordagem pode prejudicar a qualidade do escalonamento produzido caso um erro de predição ocorra.

Apesar de serem os mais adequados para os casos de grafos não-determinísticos, algoritmos dinâmicos consomem muito tempo e recursos, o que leva a um overhead no tempo de execução do programa, alem do que podem gerar task trashing, quando uma tarefa é movida continuamente entre processadores, desperdiçando ainda mais tempo.

Por esses motivos, o uso de técnicas dinâmicas deve ser usado com precaução.

A abordagem mais elementar ao escalonamento dinâmico assume nenhum conhecimento prévio sobre o programa paralelo.

Nesta abordagem, um dos processadores é dedicado à execução do escalonamento, mantendo uma fila FIFO de tarefas aptas à execução e designando tarefas às filas FIFO locais dos demais processadores.

Então, cada processador executa as tarefas de sua fila de espera, fazendo requisições de novas tarefas ao processador escalonador sempre que necessário.

Essas requisições são enfileiradas e usadas no próximo ciclo de escalonamento.

A maior desvantagem da proposta baseada em listas FIFO é sua simplicidade, que resulta em um escalonamento distante do ótimo.

Uma melhora neste algoritmo é obtida quando se tenta balancear a carga entre os processadores do sistema, adicionando-se constantes de carga à heurística básica.

Essas constantes requerem esforço adicional, mas podem reduzir o overhead no sistema.

Uma heurística com constantes de balanceamento tenta balancear a carga dos processadores periodicamente migrando tarefas de uma fila local de espera para outra.

Para evitar a ocorrência de task trashing, a heurística de rebalanceamento aplicada é dada pelo algoritmo a seguir.

Inicialmente, as tarefas são distribuídas a todos os processadores possíveis até que todas as tarefas estejam disseminadas pelo sistema ou que não haja mais requisições a processar.

Em seguida, se computa a carga média do tamanho em unidades de tempo das filas de trabalho da vizinhança direta de processadores topologicamente interconectados, baseando-se nos tempos de execução das tarefas dessa vizinhança.

Tenta-se mover tarefas de uma fila à outra dentro da vizinhança de tal modo que a carga de cada fila é tornada a mais próxima possível da média da vizinhança.

As tarefas não são movidas a menos que as cargas de trabalho individuais dos processadores sejam tornadas mais próximas dessa média.

As médias das vizinhanças são feitas ao mesmo tempo de forma distribuída no sistema de processadores e, mesmo que o balanceamento de carga seja feito em vizinhos locais, caracterizando um algoritmo não-cooperativo de acordo com a taxonomia proposta, como as vizinhanças são sobrepostas, a revisão da carga se propaga por todo o sistema.

Outras vantagens desta heurística sobre a original FIFO são ela ser distribuída, e, portanto, mais escalável, ser adaptativa em relação à carga do sistema, corrigindo-se caso uma decisão errada seja tomada (novamente devido à sobreposição das vizinhanças), e realizar periodicamente o realinhamento de carga, reduzindo, assim, o overhead do sistema.

Uma abordagem híbrida, combinando-se métodos estáticos e dinâmicos, também pode ser aplicada.

Essa técnica funciona escalonando-se estaticamente o máximo possível do grafo de tarefas, executando "correções" dinâmicas durante sua execução, como, por exemplo, fazer com que as tarefas garantidamente executáveis sejam escalonadas estaticamente, e, as demais, dinamicamente.

Pesquisas nesta área têm se focado em escalonamento de grafos não-determinísticos em relação a desvios condicionais.

Este artigo objetivava fornecer uma visão geral sobre o estado da arte em escalonamento distribuído, partindo do caso mais simples até heurísticas relativamente avançadas e algoritmos dinâmicos.

Ao término da leitura deste, espera-se que o leitor tenha adquirido um conhecimento básico dos conceitos principais referentes ao assunto, bem como tenha adquirido noções referentes às diferenças entre os algoritmos estáticos e dinâmicos, e tenha compreendido a necessidade de heurísticas no tratamento computacional do problema.

Para se exemplificar cada uma das classes apresentadas, sempre que possível foram apresentados e discutidos algoritmos que tentam solucionar o problema, quando não era possível se transcrever um algoritmo seja pela sua complexidade, seja pela sua extensão, uma referência ao algoritmo é indicada.

