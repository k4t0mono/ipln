Os requisitos de tolerância a falhas devem ser incluídos no projeto inicial de sistemas de tempo real, contemplando a integração de software, hardware e restrições de tempo.

Existem muitos casos em que o projeto de tolerância a falhas deve ser incluído estaticamente, devido às altas taxas de dados e severas restrições de tempo.

Sistemas que exigem alta segurança necessitam de técnicas formais de prova para garantir que os requisitos de tolerância a falhas serão cumpridos.

Novas abordagens onde os sistemas podem prever que as restrições de tempo serão violadas permitem que decisões sejam tomadas antes que uma pane ocorra.

Priorizar tarefas em sistema de tempo real é um problema pertencente à classe NP-Hard.

Várias alternativas para resolver este problema já foram propostas.

Neste trabalho, investiga-se a possibilidade de se obter um nível mais alto de tolerância à falhas com a integração de alguns trabalhos correlatos.

Este trabalho apresenta técnicas para melhorar a capacidade de tolerância a falhas de sistemas de tempo real incorporando redundância de tempo, redundância de processadores e protocolos de comunicação em tempo real e tolerantes a falhas.

A principal meta é garantir os requisitos de tolerância a falhas para sistemas de tempo real multiprocessados.

As ferramentas utilizadas para otimizar estes requisitos de tolerância a falhas são a escalonabilidade de tarefas e a redundância de tempo.

Este trabalho, em complemento a uma abordagem teórica, foi desenvolvido utilizando uma implementação composta de um sistema multiprocessado com CPUs DSP interconectadas por um barramento CAN.

A pesquisa leva em consideração o overhead introduzido pelo protocolo de comunicação de tempo real tolerante a falhas.

Sistemas de tempo real são sistemas cuja correta execução depende não só do resultado correto da computação, mas também do instante de tempo em que este resultado é alcançado.

Exemplos de sistemas de tempo real incluem os processadores de sinais, controladores de vôos e de processos, aplicações em telecomunicações, sistemas automotivos e sistemas médicos de suporte à vida.

Sistemas de tempo real críticos (HRTSs), mais especificamente, possuem restrições de tempo rígidas, e o não cumprimento dos prazos das tarefas pode ser catastrófico.

Estes sistemas têm como premissas a confiabilidade, disponibilidade, segurança, desempenho, entre outas características.

Falhas em tais sistemas podem ocasionar perdas humanas, ecológicas e econômicas.

Escalonamento e alocação de recursos em sistemas de tempo real são problemas difíceis em função das restrições de tempo das tarefas envolvidas.

Tolerância a falhas é um requisito vital no desenvolvimento de sistemas de tempo real críticos.

Políticas de escalonamento nestes sistemas devem garantir que as tarefas cumprirão seus prazos finais sob quaisquer circunstâncias, mesmo na presença de falhas transientes e permanentes.

Uma característica de sistemas de tempo real está no fato de que estes sistemas devem ser capazes de prever que um prazo não será atendido e tomar as ações necessárias antes que uma pane ocorra.

Os requisitos de tempo e o modelo de falhas dependem do conhecimento preciso da aplicações e do ambiente na qual esta está inserida.

A base de todas as técnicas de tolerância a falhas está relacionada ao conceito de redundância.

Este conceito era implementado, inicialmente, através da simples replicação de componentes.

Ao longo do tempo notou-se que outros tipos de redundância levam ao mesmo resultado e, muitas vezes, de forma mais eficiente.

Neste trabalho, uma análise de técnicas de tolerância a falhas no contexto de sistemas de tempo real multiprocessados é apresentada, incluindo escalonamento e protocolos de comunicação.

Uma nova técnica baseada em escalonabilidade de tarefas e incorporando redundância de tempo foi proposta, podendo esta ser utilizada em conjunto com redundâncias de hardware e software.

O trabalho foi desenvolvido sobre o protocolo CAN (Controller Area Network) por se tratar de um protocolo que está presente em mais de 90% das aplicações envolvendo microcontroladores e DSPs que incorporam protocolos de tempo real.

Um problema conhecido do barramento CAN está na entrega de mensagens de baixa prioridade, a qual pode ser comprometida caso mensagens de mais alta prioridade ocupem todo o bandwidth.

Foi proposta assim uma extensão ao protocolo CAN através da aplicação de técnicas que buscam melhorar a confiabilidade do protocolo.

A extensão proposta, denominada RMCAN, provê garantias de falhas no barramento CAN serão toleradas.

Para tanto, é definida uma taxa máxima de transmissão para cada nó, ao invés de utilizarmos slots de tempo pré-definidos (como é feito no TTP/C).

Com esta condição de contorno, as transmissões de um nó não ficam restritas a um slot de tempo, mas podem ocorrer até que a taxa máxima de transmissão seja atingida.

Outra importante contribuição deste trabalho está na definição de uma arquitetura tolerante à falhas de tempo real baseada em DSPs, onde um conjunto de processadores executando em paralelo troca informações através de um barramento CAN.

Um algoritmo de escalonamento consiste em um conjunto de regras que determinam a tarefa a ser executada em um momento em particular.

A abordagem tradicionalmente adotada é aquela onde o escalonamento é preemptivo e baseado em prioridades.

Nesta abordagem, as tarefas possuem prioridades que lhes são atribuídas dinâmica ou estaticamente.

Em um determinado momento, se uma tarefa de mais baixa prioridade está sendo executada e uma tarefa de maior prioridade entra na fila, a tarefa de menor prioridade é colocada em espera enquanto o processador é liberado para a execução da tarefa de maior prioridade.

Desta forma, a especificação de algoritmos de escalonamento preemptivos baseados em prioridades está diretamente relacionado à especificação de algoritmos de atribuição de prioridades.

Um algoritmo é dito estático se as prioridades são atribuídas uma única vez, da mesma forma, um algoritmo é dito dinâmico se as prioridades são alteradas entre uma requisição e outra.

Existem ainda algoritmos mixtos onde algumas tarefas têm suas prioridades definidas estaticamente enquanto outras têm suas prioridades definidas dinamicamente.

Caso tenhamos as prioridades definidas sistematicamente, utilizando a abordagem rate-monotonic, por exemplo, limites de utilização podem ser determinados.

Nesta situação, se um conjunto de tarefas não exceder os limites, podemos dizer que as tarefas poderão ser executadas sem que os prazos finais sejam perdidos.

O termo "análise rate-monotonic" surgiu em 1973 através da publicação de um artigo denominado "Scheduling Algorithms for Multiprogramming in a Hard Real Time Environment" por Liu e Layland.

Este artigo propôs o que seria a base para um teste simples a ser aplicado em sistemas de tempo real para se determinar se um conjunto de tarefas seria executado antes de seus prazos finais.

Foram considerados prazos finais das tarefas o final de seus períodos, e nenhuma tarefa poderia bloquear o sistema enquanto tivesse sendo executada.

Além disto, foram atribuídas única e monotonicamente prioridades a cada tarefa do conjunto.

O algoritmo rate-monotonic (RMA) consiste em um algoritmo de escalonamento de tarefas que atribui mais altas prioridades a tarefas com menor período, é ótimo se o conjunto de tarefas for independente.

Assume-se que todas as tarefas no sistema são periódicas, têm seus prazos finais no final de seus períodos e são totalmente independentes umas das outras.

Vários trabalhos foram desenvolvidos baseados na teoria RMA, Joseph and Pandya demonstraram o Completion Time Test (CTT) para verificar a escalonabilidade de um conjunto fixo de tarefas periódicas em um processador.

Bertossi e Mancine  propuseram o Faut-Tolerant Rate-Monotonic First-Fit (FTRMFF) para prover tolerância a falhas a um HRTS utilizando um sistema multiprocessado onde cada tarefa tem uma cópia ativa ou passiva em outro processador e todo o conjunto de tarefas é escalonado pelo RMFF, suportando falhas fail-stop de um ou mais processadores.

Em função da natureza crítica das tarefas em sistemas de tempo real, é essencial que falhas sejam toleradas.

Uma falha em um sistema pode se manifestar de várias formas, tornando seu diagnóstico muitas vezes complicado.

Buscando reduzir este problema, um sistema pode ser projetado de forma a seguir um modelo de falhas, tornando o problema de diagnosticá-las simplificado.

Nem todas as falhas que ocorrem em um sistema são tratadas pelo modelo de falhas, sendo que existem modelos de falhas que cobrem um grande percentual das falhas possíveis.

Falhas transientes são toleradas, geralmente, utilizando-se redundância de tempo, a qual involve a re-execução das tarefas que estavam executando durante a falha transiente.

Ghosh propôs em  um algoritmo onde a execução de tarefas de tempo real é garantida mesmo na ocorrência de falhas transientes e intermitentes.

A abordagem geral para se tolerar falhas consiste em reservar tempo suficiente no escalonamento de forma que qualquer instância de uma tarefa possa ser re-executada caso uma falha ocorra durante sua execução.

Se nenhuma falha ocorrer, as tarefas serão executadas seguindo o esquema usual do rate-monotonic.

Ghosh propôs ainda um algoritmo para escalonamento de tarefas tolerante a falhas em sistemas multiprocessados.

O algoritmo garante a execução de uma tarefa antes do prazo final mesmo na presença de falhas no processador.

Protocolos de comunicação de tempo real tolerantes à falhas.

Um serviço essencial provido por arquiteturas distribuídas de tempo real tolerantes à falhas é a troca de informação entre os componentes distribuídos.

Estas arquiteturas têm como importante componente o barramento de comunicação e protocolos utilizados no controle e comunicação estão entre seus principais mecanismos.

Em sistemas distribuídos de tempo real, a comunicação entre diferentes processadores deve ocorrer em um tempo pré-determinado.

Barramentos redundantes são utilizados com frequência em ambientes críticos para lidar com as falhas nos dispositivos.

Existem vários protocolos de comunicação utilizados em sistemas de tempo real, cada qual apresentando uma complexidade.

Exemplos mais representativos são o protocolo TTP/C (Time-Triggered Protocol), CAN (Controller Area Network).

Estes protocolos têm sido utilizados na indústria da aviação (Airbus e Boeing), na indústria automotiva (BMW e a Audi), entre outras.

Alguns protocolos citados acima são basicamente "time-triggered", como por exemplo o TTP/C.

Isto significa que todas as atividades envolvendo o barramento e os componentes anexados a ele são baseadas na passagem do tempo.

Outros protocolos são basicamente "event-triggered", como por exemplo o CAN, nestes protocolos as atividades envolvendo o barramento são baseadas na ocorrência de eventos, respondendo a estímulos externos e interagindo com o ambiente.

Existem ainda protocolos mistos, como o TTCAN e o FlexRay, onde os dois conceitos se misturam.

Sempre que um sistema tolerante à falhas é projetado, uma forma de redundância deve ser incorporada.

Escalonabilidade de tarefas e redundância de tempo são ferramentas importantes para se garantir que os requisitos de tolerãncia a falhas sejam atendidos para um determinado sistema.

Com o custo de processadores reduzindo gradativamente e o desenvolvimento de inúmeros protocolos de comunicação de tempo real, tais como CAN, TTP/C, tornou-se importante pesquisar aspectos relacionados a sistemas de tempo real multiprocessados, onde testes de escalonabilidade devem garantir a execução de todas as tarefas do conjunto antes de seus prazos finais e considerando um modelo de falhas.

O principal objetivo deste trabalho é garantir requisitos de tolerância a falhas em sistemas multiprocessados de tempo real crítico.

Os recursos utilizados para otimizar estes requisitos são a escalonabilidade de tarefas e redundância de tempo.

Este trabalho apresenta técnicas para se melhorar a capacidade de tolerar falhas de tais sistemas incorporando ainda redundância de processadores e protocolos de comunicação de tempo real.

A abordagem utilizada consiste em prover tolerância à falhas através do escalonamento de tarefas e da adição de slacks de tempo no processamento.

Se uma falha for detectada pelo sistema operacional durante a execução de uma tarefa, esta tarefa deverá ser re-executada dentro deste slack de tempo ou uma tarefa backup deve ser ativada para recuperação da falha.

A implementação de um sistema multiprocessado baseado em DSPs interconectado por um barramento CAN é apresentada.

Cada processador executa aplicações de tempo real periódicas escalonadas através do RMA com tempo máximo de execução e período de execução pré-definidos.

Por se tratarem de tarefas de controle, consistem em um conjunto de tarefas independentes, onde o início de uma tarefa não depende da execução de nenhuma outra tarefa.

O modelo de falhas foi definido considerando as seguintes características do sistema, (F1) Falhas transientes e permanentes podem ocorrer na execução de uma tarefa ou até mesmo em um processador.

Apenas falhas transientes do barramento de comunicação são toleradas.

Processadores livre de falhas podem comunicar entre si.

O hardware provê isolamento das falhas no sentido de que uma falha em um processador não provocará falhas em outros processadores.
A falha de um processador é detectada pelos demais através da não execução de alguma tarefa alocada para o processador que falhou, e é sinalizada pela ausência de mensagem no barramento CAN.

O modelo inclui falhas que podem ocorrer no barramento ou no protocolo de comunicação, uma vez que estes influenciam o funcionamento do sistema como um todo.

Considerando o barramento CAN, é necessário garantirmos que um pacote será entregue dentro do seu prazo final ou, no pior caso, que o remetente saberá que o envio foi sem sucesso e que nova transmissão deverá ser feita.

Uma mensagem deve ser retransmitida um número de vezes no caso de falha na transmissão e ainda assim cumprir seu prazo final.

No barramento CAN, uma falha é sinalizada através da ausência de mensagens, isto é, se uma mensagem não for recebida pelos processadores dentro de um intervalo de tempo, uma falha no processador primário é assumida e a recuperação desta falha é feita através de uma tarefa backup.

Quaisquer erros nas mensagens podem indicar que uma falha ocorreu, e uma tarefa alternativa será executada consequentemente, evitando assim uma pane no sistema.

Falhas permanentes no barramento CAN não são toleradas, causando uma interrupção no processo de comunicação.

O algoritmo de escalonamento dinâmico utilizado pelo protocolo CAN é praticamente idêntico aos algoritmos de escalonamento comumente utilizados em sistemas de tempo real para escalonar tarefas em processadores.

A análise do comportamento destes sistemas pode ser aplicada quase que sem modificações na solução do problema de se determinar o pior caso do tempo de transmissão de uma dada mensagem no barramento CAN.

Tindell desenvolveu uma análise sobre o barramento CAN baseada na análise rate-monotonic, mostrando como calcular o pior tempo de resposta para mensagens transmitidas pelo barramento.

A ocorrência de erros de transmissão também deve ser considerada.

Em um barramento CAN, um erro detectado tanto pelo emissor quanto pelo receptor da mensagem é sinalizado ao emissor, o qual deve retransmitir a mensagem.

Um problema conhecido do protocolo CAN é o fato de não se poder garantir que mensagens de mais baixa prioridades serão entregues antes do seu prazo final em caso de sobrecarga.

Enquanto o protocolo CAN é muito eficiente na transmissão de dados mais urgentes, estas mensagens podem sobrecarregar o barramento de tal forma que as mensagens de mais baixa prioridade não conseguirão cumprir seus prazos de transmissão.

Neste sentido, é necessário garantirmos que a sobrecarga não ocorrerá, para que todos os prazos finais sejam cumpridos.

Falhas no barramento CAN implicam na re-transmissão de mensagens ou até mesmo na execução de ações alternativas para a reconfiguração do barramento.

Ghosh  desenvolveu um esquema para recuperação de uma ou mais falhas que garante a re-execução de qualquer tarefa assim que uma falha for detectada.

Os mesmos conceitos apresentados por Ghosh foram aplicados ao protocolo CAN, buscando garantir que uma mensagem seja re-transmitida quando uma falha na transmissão for detectada.

Estes conceitos, utilizados em escalonamento rate-monotonic, foram aplicados ao barramento CAN uma vez que, As mensagens são independentes ou assíncronas.

As mensagens têm suas prioridades definidas pelo RMA.

Uma mensagem de mais alta prioridade não deve ocupar todo o bandwidth do barramento impedindo que mensagens de mais baixa prioridade executem Segundo a abordagem apresentada por Ghosh, deve ser mantido um intervalo de tempo suficiente para que uma mensagem seja re-transmitida.

Caso nenhuma falha ocorra, as mensagens são transmitidas normalmente, seguindo o escalonamento rate-monotonic e este slack não é utilizado.

Caso ocorra algum erro no processo de transmissão da mensagem, esta deve ser re-transmitida antes do fim do seu período de transmissão.

Para que os conceitos apresentados por Ghosh pudessem ser aplicados ao protocolo CAN, as seguintes condições devem ser satisfeitas, Deve ser reservado um intervalo de tempo suficiente para que cada instância de cada mensagem possa ser re-transmitida.

Quando uma instância de uma mensagem é transmitida, uma quantidade suficiente do slack disponível dentro do seu período deve estar disponível para que esta mensagem possa ser re-transmitida antes do prazo final, caso uma falha seja detectada.

Quando uma mensagem é re-transmitida, esta não deve interferir na transmissão de nenhuma outra mensagem, ou seja, a re-transmissão de uma mensagem de mais alta prioridade não interferirá no cumprimento dos prazos finais de outras mensagens.

Considerando os resultados obtidos por Tindell em, onde mostrou-se ser possível determinar o tempo máximo de transmissão para o barramento CAN no pior caso, foi demonstrado no Capítulo 6 que as três premissas podem ser atendidas.

Foi proposta assim uma extensão ao protocolo CAN, denominada Rate Monotonic CAN (RMCAN), onde foram definidos slacks de tempo de tamanho suficiente para que, mesmo no pior caso, todas as mensagens possam ser transmitidas ou até mesmo re-transmitidas se necessário.

Cada mensagem tem sua transmissão limitada a um tempo máximo e um período pré-definido, sendo definido um limite para a taxa máxima de transmissão para um nó do barramento CAN.

Podemos assim garantir que é possível re-transmitir uma mensagem que apresentou falha e ainda cumprir o prazo final.

Desta forma, ao invés de limitar a transmissão a um período pré-definido, como é feito pelo TTP/C, um nó pode distribuir sua transmissão durante vários intervalos de tempo até que seu limite seja atingido.

A independência das mensagens é garantida pelo fato de se tratarem de mensagens geradas por tarefas de controle que são independentes.

Uma visão geral da arquitetura, considerando todos os conceitos apresentados.

Comparação de protocolos de tempo real tolerantes à falhas Podemos dizer que o protocolo TTP/C provê o projeto estático assegurando um tempo máximo de transmissão para todas as mensagens, mas ao mesmo tempo ele apresenta baixa flexibilidade uma vez que a largura de banda é distribuída em tempo de projeto através da atribuição de frames de tamanho específico a cada nó.

Em um barramento CAN, por outro lado, as prioridades podem ser determinadas em tempo de execução através da atribuição de identificadores únicos e um controle completo da aplicação sobre a distribuição da largura de banda disponível.

O protocolo CAN é um protocolo altamente flexível e largamente disponível, apesar de que algumas extensões devem ser feitas para se garantir um mecanismo confiável para se construir sistemas tolerante à falhas confiáveis.

TTCAN é um compromisso e representa a necessidade de evolução do CAN, para que sobrecargas no barramento possam ser tratadas corretamente sem prejudicar a transmissão de mensagens.

Por outro lado, a sincronização de nós exigida pelo TTCAN não é uma tarefa simples, exigindo hardware adicional.

RMCAN foi desenvolvido com o objetivo de se obter a eficiência do TTCAN, mas sem incorporar nenhum hardware adicional ou outras restrições.

Tanto o TTCAN quanto o RMCAN podem ser implementados utilizando controladores CAN.

No caso do RMCAN, o controle da taxa de transmissão é feito por software, simplificando a implementação do protocolo.

O protocolo FlexRay pode ser considerado o estado da arte em se tratando de protocolos de tempo real tolerantes a falhas, apesar de ainda não ter sido lançado no mercado.

É um protocolo que promete uma taxa de transmissão maior do que o TTCAN e maior flexibilidade se comparado ao TTP/C.

Um no-break é um exemplo de sistema de tempo real crítico onde mecanismos de tolerância à falhas são essenciais.

A função primária de um no-break é garantir continuidade de operação especialmente durante falhas de energia ou perturbações no fornecimento de energia elétrica.

Uma aplicação onde o protocolo RMCAN foi utilizado consiste em um no-break trifásico de 80 kVA, o qual deve fornecer energia sem interrupções às suas cargas mesmo quando uma falha no fornecimento de energia pela companhia de energia elétrica ocorrer.

A operação do no-break é controlada por lógica microprocessada, todas as tarefas são executadas por três CPUs independentes (retificador, inversor e chave estática), cada qual consistindo de um DSP.

A escolha de DSPs para esta aplicação foi feita em função de características da própria aplicação.

Um número maior de CPUs poderia ser utilizado considerando, por exemplo, redundância de hardware.

Apesar das CPUs operarem de forma autônoma, estas trocam informações entre si através de uma interface CAN, permitindo assim a monitoração e controle das informações.

O protocolo RMCAN foi utilizado internamente para comunicação entre os processadores.

Falhas de leitura de parâmetros em um dos processadores são repassadas aos outros, que tomam as ações devidas.

Representa o processo de tratamento de uma falha no barramento CAN.

Como as CPUs do retificador e inversor trocam informações periodicamente, o não recebimento de uma mensagem indica uma falha no barramento.

Caso a re-execução indique que a falha permanece, é executado um algoritmo alternativo de forma que seja possível tolerar determinada falha.

Falhas permanentes no barramento não são toleradas.

A colocação de duas ou mais unidades de fontes de alimentação em paralelo fornece ao sistema uma maior tolerância a falhas aumentando substancialmente a confiabilidade.

Entretanto, como os módulos de potência não são idênticos, as correntes fornecidas por cada módulo são diferentes.

Alguns dos fatores que contribuem para este desequilíbrio são a tolerância dos componentes e a impedância dos circuitos de distribuição da corrente de saída de cada módulo.

O circuito de controle das fontes de alimentação deve ser capaz de regular a tensão de saída das fontes de alimentação e simultaneamente distribuir uniformemente a corrente de carga entre os diversos módulo de potência.

Uma aplicação do método de paralelismo de conversores utilizando a técnica de controle do tipo mescre-escravo com comunicação através de interface CAN foi simulada, mostrando que é possível utilizarmos o RMCAN como protocolo de comunicação entre dois no-breaks em paralelo que utilizam o barramento CAN para sincronização.

Foram simuladas situações onde ocorriam falhas no no-break mestre e no escravo, bem com falhas no barramento CAN.

Tarefas em sistemas de tempo real devem cumprir seus prazos sob quaisquer circunstâncias, mesmo na presença de falhas transientes e permanentes.

Neste trabalho utilizou-se conceitos como redundância de tempo e escalonamento de tarefas ao lidarmos com falhas em sistemas de tempo real.

Foram analisados ainda protocolos de comunicação de tempo real, sendo considerado o protocolo CAN por estar disponível em mais de 90% das aplicações envolvendo protocolos de tempo real.

O protocolo CAN possui, muitas vezes, tempo de resposta não-determinístico para mensagens de baixa prioridade.

O protocolo RMCAN foi proposto neste trabalho como uma extensão ao protocolo CAN, buscando assim resolver os problemas de não determinismo do protocolo bem com garantir que todas as mensagens serão entregues dentro de seus prazos finais ou até mesmo que não serão entregues, caso alguma falha ocorra.

Limitou-se a taxa de transmissão de cada nó no barramento CAN tornando assim determinístico o tempo de transmissão de uma mensagem, mesmo para mensagens de baixa prioridade.

Vale ressaltar que a transmissão de mensagens por um nó não ficou restrita a um intervalo de tempo, e sim a uma taxa máxima de transmissão.

É possível assim garantir que haverá tempo suficiente para que uma mensagem seja transmitida, ou até mesmo re-transmitida, se necessário.

Caso uma mensagem não chegue ao seu destino, o destinatário saberá que uma falha ocorreu e que uma ação será executada de acordo com o modelo de falhas definido para a aplicação, como por exemplo, reconfiguração do barramento CAN.

As extensões ao protocolo CAN propostas aumentam a confiabilidade do protocolo bem como permitem que seja explorada sua grande presença no mercado.

Foi feita ainda a verificação formal do RMCAN, garantindo assim que a transmissão das mensagens ocorrerá dentro do seu período, mesmo considerando que falhas ocorrerão no sistema.

