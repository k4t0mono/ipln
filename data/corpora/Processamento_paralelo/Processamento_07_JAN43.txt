É inegável a crescente importância dos ambientes paralelos e distribuídos tanto no meio acadêmico com comercial.

O uso de redes locais e da Internet está amplamente difundido mesmo para uso doméstico.

Mas para que tais recursos físicos sejam aproveitados da melhor forma possível é preciso fornecer suporte adequado de software.

Nesse texto serão discutidos diversos aspectos relacionados ao controle em ambientes distribuídos.

Por ambiente distribuído entende-se um conjunto de processadores interligados por uma rede de interconexão e sem memória compartilhada.

A ausência de memória compartilhada obriga a uma interação entre processadores de uma forma distinta do ambiente centralizado, ao invés de variáveis ou arquivos compartilhados utiliza-se troca de mensagens.

Esse texto apresentará diversos aspectos dos sistemas operacionais distribuídos e de rede, bem como algoritmos distribuídos mais importantes e alguns estudos de caso.

Antes de iniciarmos a discussão sobre sistemas operacionais direcionados a ambiente distribuídos, apresentaremos algumas definições possíveis para sistema operacional.

As informações apresentadas nesse texto foram compiladas a partir das referências bibliográficas indicadas.

Em especial, grande parte dos conceitos podem ser encontrados nos livros do Tanembaum.

Essa compilação não substitui a consulta aos textos originais.

Ela serve para apresentar de uma forma mais simples e direta servindo como um roteiro para os alunos da disciplina INF01018 - Sistemas Operacionais Distribuídos e de Redes.

Não existe uma definição de consenso e incontestável que defina o significado e o objetivo de um sistema operacional.

Cada autor apresenta uma definição própria mas das quais pode-se abstrair, se não uma definição de consenso, pelo menos uma aproximação.

Apresenta-se abaixo a tradução de algumas definições de importantes autores da área, O S O provê meios para o uso apropriado dos recursos de hardware, software e dados durante a operação do sistema computacional.

O S O não realiza por si só nenhuma função útil.

Ele simplesmente provê um no qual cada um dos outros programas pode realizar trabalho útil.

Mas o que se caracteriza por um trabalho útil?

Note que essa definição está relacionada com a visão de usuário.

Talvez um forma melhor de expressar essa idéia seja dizer que o S O realiza funções básicas a partir das quais outros programas podem realizar tarefas mais complexas.

Um S O provê um ambiente para a execução de programas.

Um S O provê certos serviços para programas e para os usuários desses programas.

Os serviços específicos providos irão, logicamente, variar de um S O para outro, mas existem algumas classes comuns de serviços que podem ser identificas, o sistema deve ser capaz de carregar um programa na memória e executá-lo.

O programa deve ser capaz de terminar, tanto normalmente quanto em uma situação não normal (erro).

Uma operação de E/S pode envolver um arquivo ou um dispositivo de E/S.

Para dispositivos específicos, funções especiais são requeridas.

Por eficiência e proteção, usualmente os usuários não podem realizar operações de E/S diretamente.

Esse serviço permite que programas leiam e escrevam em arquivos e arquivos sejam criados e removidos.

Serviço implementado para permitir que um processo troque informações com outro(s) processo(s).

A interação pode ocorrer entre processos da mesma máquina ou entre processos em máquinas distintas ligadas em rede.

Essa comunicação pode ser implementada através de memória compartilhada (quando na mesma máquina ou em processadores distintos com memória compartilhada) ou através de troca de mensagens.

Possíveis erros na CPU, dispositivos de E/S, etc, devem ser de alguma forma tratados pelo S O para garantir uma computação correta e consistente.

Note que o sistema não precisa necessariamente garantir tolerância a falhas, mas no mínimo detecção.

Necessário quando há múltiplos usuários ou múltiplos processos.

Manutenção do controle de quais usuários usam quanto e quais recursos computacionais.

Tais informações podem ser utilizadas para cobrar os serviços do usuário (p ex um provedor de acesso a Internet) e/ou para acumular estatísticas de uso (p ex para planejamento de compra de novos equipamentos).

Envolve a garantia de que todos os acessos aos recursos do sistema sejam controlados pelo S O Os primeiros serviços estão diretamente ligados ao usuário enquanto as três últimas classes de serviços garantem a execução eficiente do S O.

Os S O modernos normalmente são baseados em uma arquitetura formada por um kernel (núcleo) e por serviços.

Assim, as funções providas pelo S O são então estruturadas em duas categorias serviços do sistema, funções de alto nível tal como são vistas pelas aplicações (visão para o usuário de uma máquina estendida), kernel (núcleo), funções essenciais que são dependentes da arquitetura sob a qual o S O vai executar (visão do administrador do sistema de um gerenciador de recursos).
Em outras palavras, os serviços é o objetivo principal a ser atingido enquanto o kernel é a forma de atingir tal objetivo Um S O normalmente tem dois objetivos que são contraditórios, conveniência para o usuário e eficiência.

No passado, a eficiência era o aspecto mias importante devido aos altos custos de hardware.

Devido a isso, boa parte das teorias de S O concentram-se no uso ótimo dos recursos computacionais.

É importante porém notar a tendência atual em priorizar a facilidade de uso e a transparência.

Essa definição implica hardware formado por máquinas autônomas e software fornecendo a abstração de uma máquina única.

Vantagens, Econômicas, aproveitar máquinas potencialmente ociosas, mais barato vários processadores interconectados do que um supercomputador.

Distribuição inerente, algumas aplicações são distribuídas por natureza.

Tolerância a falhas, em caso de falha de uma máquina, o sistema como um todo pode sobreviver, apresentando apenas uma degradação de desempenho.

Crescimento incremental, o poder computacional pode ser aumentado através da inclusão de novos equipamentos.

Flexibilidade, sistemas distribuídos são mais flexíveis do que máquinas isoladas, por isso muitas vezes são utilizados até mesmo que não se esteja buscando desempenho.

É essa flexibilidade que permite que vários usuários compartilhem dados e periféricos.

Desvantagens, Pouco software de alto nível disponível para sistemas distribuídos.

Dificuldades para evitar acesso indevido (segurança).

A rede de interconexão pode causar problemas ou não dar vazão a demanda de Localização, os usuários não sabem onde os recursos estão localizados.

Demanda de Migração, os recursos podem se mover sem alterar seus nomes.

Demanda de Replicação, os usuários não sabem quantas cópias de um recurso existem.

Demanda de Concorrência, múltiplos usuários podem compartilhar um recurso automaticamente.

Demanda de Paralelismo, atividades podem ocorrer em paralelo sem que o usuário saiba (falta muito ainda para ser atingido).

Para obter isso, hoje a tendência é construir S O baseados em um micro kernel (ao invés de um sistema monolítico com mais performance mas menos flexibilidade).

Um microkernel implementa poucas funções, fornecendo em princípio quatro serviços básicos, Mecanismo de comunicação entre processos Algum tipo de gerência de memória Uma pequena parte do escalonamento e gerência de baixo nível de processos Estrada e saída de baixo nível Outros serviços providos por serviços em nível de usuário.

Na teoria, a idéia é que se alguma máquina parar de funcionar, alguma outra máquina pode pegar o trabalho dela.

Na prática, existem alguns servidores em diferentes máquinas que precisam estar no ar para que o sistema como um todo funcione.

Existem vários aspectos relacionados a confiabilidade, Disponibilidade se refere a fração de tempo que o sistema está funcionando/usável.

Pode-se melhorar a disponibilidade através de um projeto que não exija o funcionamento simultâneo de um número substancial de componentes críticos, ou, ainda, através de redundância, isto é, componentes chaves de hardware e software devem ser replicados, de modo que se um deles falhar, os outros estarão aptos a tomar conta da tarefa.

Tolerância a falhas, o que fazer em caso de falha de um servidor?

Em geral, sistemas distribuídos podem ser projetados para mascarar falhas, isto é, escondê-las do usuário.

Por exemplo, um serviço de arquivos (ou outros serviços quaisquer) pode ser construído com um grupo de servidores cooperantes de tal modo que o usuário não perceba a perda de um ou mais servidores (a não ser, talvez, por perda de desempenho).

Todos os itens anteriores não devem ser atingidos sacrificando o desempenho.

Quando rodar uma determinada aplicação em um sistema distribuído, ele não pode ser pior do que rodar a mesma aplicação em um único processador.

Métricas para medir desempenho, Tempo de resposta (número de tarefas / tempo) Utilização do sistema Quantidade consumida da capacidade da rede Principal problema é o Custo de Comunicação.

Para otimizar o desempenho, otimiza-se o número de mensagens.

Porém, a melhor forma de obter desempenho é ter várias atividades rodando em paralelo em diferentes processadores, o que implica em enviar muitas mensagens.

Para minimizar o problema, considerar a granulosidade, Tamanho do grão, tempo execução de uma tarefa (grão fino - e grão grosso).

Executar tarefas pequenas remotamente não é válido porque o custo adicional de comunicação não compensa o ganho de CPU.

Executar tarefas que envolvam grandes computações e baixas taxas de interações e poucos dados pode ser mais apropriado.

Os sistemas distribuídos precisariam se adaptar a possibilidade de termos ambientes com centenas ou milhares de processadores.

Para isso, deve-se evitar, Componentes centralizados.

Por exemplo, um único servidor de email para todos os usuários.

Por exemplo, uma única relação on-line de telefones.

Por exemplo, roteamento de mensagens baseado em informações completas.

Deve-se usar algoritmos descentralizados, que possuem as seguintes características, Nenhuma máquina possui informações completas sobre o estado do sistema.

Máquinas tomam decisões baseadas apenas nas informações disponíveis localmente.

Falha de uma das máquinas não impede o funcionamento do algoritmo.

Não há suposições implícitas de que existe um relógio global.

Sistemas distribuídos consistem de várias CPUs interconectadas.

No entanto, há várias formas diferentes no qual esse hardware pode estar organizado.

Dentre as várias classificações existentes, Flynn propõe uma taxonomia considerando o número de fluxo de instruções e o número de fluxo de dados.

SISD - fluxo de instruções e dados único é a característica dos uniprocessadores tradicionais MIMD - caracteriza-se por vários processadores interconectados.

Tanembaum apresenta a seguinte subclassificação, onde os dois primeiros são definidos em relação a organização da memória e os dois últimos em relação a forma de interconexão, Multiprocessador - máquinas MIMD com memória compartilhada (um único espaço de endereçamento virtual compartilhado por todas as CPUs).

Multicomputador - máquinas que não possuem memória compartilhada, isto é, cada processador possui sua memória privada.

Barramento - um único cabo, rede, barramento ou outro meio que conecte todas as máquinas.

Analogia, TV a cabo.

Com a criação de novas arquiteturas de computadores, surgiram novas demandas de software e, em especial, novas funções exigidas ao S O Pode-se considerar como uma boa classificação da evolução dos Sistemas Operacionais.

Apresenta uma comparação entre as características dos S O modernos, Características dos SO modernos.

Note que as classificações de sistemas operacionais apresentadas acima também são apresentadas em, com exceção do último tipo, que pode ou não ser considerado como um sistema operacional.

Entre as diversas gerações dos S O existe uma diferença com relação ao acoplamento.

Por nível de acoplamento considera-se a medida de quão centralizado ou descentralizado o sistema.

Nessa categoria enquadram-se os S O tradicionais para arquiteturas monoprocessadas que evoluíram de um simples sistema de controle para um sistema multitarefa e multiusário.

Alguns autores incluem nessa classificação também o suporte para arquitetura multiprocessada enquanto outros consideram esse tipo de suporte como um tipo especial de sistema operacional (sistema operacional multiprocessado) O MOS é definido como um sistema com compartilhamento de tempo em multiprocessador.

Nessa classe de sistemas operacionais, a comunicação e compartilhamento de recursos é feita via memória compartilhada ou interrupções.

Como características principais destaca-se, Sistema altamente acoplado, com todos os recursos compartilhados internamente.

Comunicação entre processos via memória compartilhada.

As principais funções exigidas nesse tipo de sistema estão sumarizadas.

Dentre os possíveis aprimoramentos na arquitetura cita-se duas abordagens, Gerenciamento dos módulos, uso de orientação a objetos para facilitar extensões e portabilidade.

Separação dos códigos dependentes de hardware do restante do sistema, uso de kernel mínimo (microkernel), reduzindo a complexidade do porte de uma arquitetura de máquina para outro.

Normalmente o código do kernel é monolítico por ser centrado na eficiência.

Sistema operacional de rede é uma coleção de S O de computadores conectados a uma rede incorporando módulos para prover acesso a recursos remotos.

Com isso tem-se uma implementação barata, porém, exige que o usuário conheça a localização dos recursos requisitados.

Um exemplo típico é um conjunto de estações de trabalho interconectados por uma LAN usando UNIX.

Pode-se considerar como uma extensão do S O centralizado para facilitar o compartilhamento de recursos e a troca de informações apresentando as seguintes características, cada computador possui seu S O privado, usuários normalmente estão a par da localização dos seus arquivos e movem eles através de transferências explícitas, sistema possui pouco ou nenhum recurso de tolerância a falhas.

Para facilitar a comunicação e uso dos recursos, pode-se prover um sistema de arquivos globalmente compartilhado acessível a todas as máquinas.

O sistema é suportado por uma ou mais máquinas denominadas servidores de arquivos.

Assim um N O S típico é uma coleção de S O centralizados locais juntamente com servidores de arquivos e impressão comuns.

Os recursos são vistos como pertencentes localmente a computadores específicos.

A maior parte dos N O S apresentam uma API de alto nível como RPC ou socket no serviço de transporte para suportar a comunicação entre os S O nos diferentes domínios da rede.

Com a inclusão dessa camada de transporte, diversas aplicações de rede são suportadas.

Os principais tipos são, login remoto, transferência de arquivos, mensagens, navegação na rede e execução remota.

A implementação de um sistema verdadeiramente distribuído tem como objetivo a obtenção de um conjunto de máquinas ligadas em rede que funcionem como um uniprocessador virtual.

Um SO Distribuído parece ao usuário como um sistema centralizado comum, mas executa em múltiplas unidades de processamento independentes onde, o uso de múltiplos processadores deve ser invisível (transparente) para o usuário, o usuário vê o sistema como um uniprocessador virtual, não como uma coleção de máquinas distintas conectadas por um subsistema de comunicação.

Como principais características tem-se um mecanismo de comunicação global único entre processos, proteção global e gerenciamento homogêneo de processos.

O objetivo é fornecer transparência no acesso aos recursos, mas, de fato, não existe um sistema 100% transparente.

Assim, o SO Distribuído deve, controlar a alocação de recursos da rede para permitir seu uso no modo mais eficiente, prover ao usuário com um computador virtual conveniente que serve como um ambiente de programação de alto nível, esconder a distribuição dos recursos, prover mecanismos para proteção dos recursos do sistema contra acesso por usuários não autorizados.
Um sisFema autônomo cooperativo é um sistema de software orientado a serviço de alto nível que requer o suporte de mecanismos de comunicação no qual protocolos de comunicação de alto nível são construídos.

Chow classifica como um tipo de S O mas isso não é um conceito sedimentado na literatura.

Por ser um tipo de sistema com crescente aumento em importância ele será estudado independente de ser ou não um S O de fato.

