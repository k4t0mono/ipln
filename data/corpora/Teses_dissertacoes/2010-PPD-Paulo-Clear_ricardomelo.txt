Os formalismos estruturados foram definidos ao longo de os anos com o objetivo de aumentar o nível de abstração e oferecer uma alternativa de modelagem mais sofisticada do que a proporcionada por as tradicionais Cadeias de Markov.
Exemplos de formalismos estruturados que utilizam álgebra tensorial para o armazenamento de seus descritores são as Redes de Autômatos Estocásticos, as Redes de Petri Estocásticas Generalizadas Superpostas e as Álgebras de Processo.
Tais descrições utilizam primitivas de modelagem entre seus componentes capturando sua semântica operacional e permitindo a sua análise ao retornarem índices quantitativos de desempenho quando são resolvidos numericamente.
Os mecanismos atuais de solução usam propriedades da Álgebra Tensorial (clássica ou generalizada) para multiplicar termos tensoriais de eventos entre os estados dos modelos (i.
e, um descritor Markoviano) por um vetor de probabilidade, que contém a solução estacionária ou transiente.
Esta operação é chamada de Multiplicação Vetor--Descritor (MVD) e é realizada de três maneiras básicas:
De forma esparsa (ineficiente em memória, eficiente em tempo), utilizando o Algoritmo Shuffle (eficiente em memória, ineficiente em tempo para algumas classes de modelos) ou através do Algoritmo Split, que é uma combinação das duas primeiras abordagens.
A principal contribuição deste último foi a proposição de um método híbrido onde incrementa- se a memória (de forma razoável) para acelerar o cálculo efetuado por iteração.
Entretanto, o principal desafio do Algoritmo Split é relativo à determinação de cortes de cada termo tensorial e em como re-estruturar- lo para reduzir o custo computacional por iteração, acelerando a convergência de modelos estruturados.
Este trabalho aborda estes problemas, baseando- se em três eixos:
I) na discussão das primitivas de modelagem para composição de sistemas através de formas mais abstratas de descrição, ii) nas diferentes formas de tratamento de termos tensoriais de descritores Markovianos para execução mais otimizada da MVD a partir de re-estruturações das ordens originais, e iii) na execução do Algoritmo Split com taxas constantes ou funcionais demonstrando os resultados obtidos para diversas classes de modelos.
Para os casos observados, foi demonstrado através de experimentos que o melhor ganho, balanceando- se tempo e memória, é verificado quando as matrizes dos termos tensoriais são reordenadas, tratando as do tipo identidade na parte estruturada e avaliando- se os elementos funcionais uma única vez na parte esparsa.
A o avaliar as funções somente uma vez em todo o processo de MVD, converte- se os descritores generalizados para clássicos em tempo de execução e promove- se ganhos consideráveis em tempo para determinadas classes de modelos.
Observou- se também que as atividades de sincronização ou comunicação entre os módulos ou partições envolvidas bem como o total de parâmetros das dependências funcionais realizam um papel crucial no desempenho obtido.
A presente tese é finalizada identificando as classes de modelos mais adequadas para a utilização do Algoritmo Split, propondo formas de re-estruturação de descritores Markovianos que privilegiem a esparsidade e a existência de matrizes do tipo identidade para balancear os custos em memória e tempo de execução.
Palavras-chave: Modelagem computacional;
Formalismos estruturados;
Soluções numéricas;
Cadeias de Markov; Redes de Autômatos Estocásticos;
Descritores Markovianos; Ferramentas computacionais;
Álgebra Tensorial. Um dos objetivos ao se mapear realidades em modelos consiste na verificação de medidas de desempenho que atestam a semântica operacional dos sistemas sob análise.
Este mapeamento envolve diferentes etapas, onde a qualidade associada ao modelo varia de acordo com o tempo investido na sua caracterização.
As etapas consideradas para um estudo computacional de desempenho através de modelagem analítica podem ser descritas das seguintes formas:
A) descrição, através da utilização de abstrações, b) parametrização, que reflete as variáveis envolvidas e c) avaliação, resultando na extração e análise de índices quantitativos de desempenho.
A parte de descrição do sistema é realizada através da utilização de formalismos os quais definem cada funcionalidade com diferentes primitivas de modelagem.
Um exemplo de formalismo são as Cadeias de Markov (Markov Chains, ou MC) que trabalham com a descrição dos estados e transições que um sistema assume.
As transições conectam os estados e informam tanto as comunicações envolvidas quanto a frequência das mudanças.
Tais frequências são mapeadas através da parametrização do modelo que envolve o estabelecimento das taxas observadas entre os estados adotados.
Esta parte da modelagem é crucial pois corresponde à associação de valores às transições, podendo ser obtidas a partir de medidas realizadas previamente ou através de monitoramentos.
A parte da avaliação trata da extração, interpretação e análise dos índices de desempenho do sistema sob estudo, onde caracteriza- se seu comportamento e operação.
O mapeamento de sistemas para modelos analíticos permite que sejam inferidos índices de desempenho que atestam a sua operação e o seu comportamento.
Estas características auxiliam o processo de tomada de decisões ao usar abstrações para os problemas existentes.
Em este sentido, a área de Avaliação de Desempenho e Modelagem Estocástica de sistemas torna possível a realização de análises com base nos resultados numéricos produzidos na solução dos modelos computacionais descritos por os modelos.
Estes mecanismos são utilizados na descoberta de eventuais gargalos antes que estes sejam colocados fisicamente em produção, ou seja, antes de se precisar comprar máquinas para um cluster ou aumentar o número de servidores numa empresa.
Apesar de a simplicidade de MC para modelar diferentes realidades e avaliar sistemas para extração de probabilidades de permanência em cada estado, observa- se que mesmo sistemas reais de tamanho restrito podem vir a possuir um conjunto de estados total elevado.
Os problemas relacionados às representações do espaço de estados torna igualmente difícil a modelagem de realidades de grande porte.
Este fator, conhecido por explosão do espaço de estados é recorrente modelagens puramente baseadas em MC e motiva pesquisas para amenizar- lo.
Com o passar do tempo constatou- se que uma das formas de mitigar- lo ocorreu através da descrição de formalismos com um maior grau de estruturação, i.
e, abstrações para decompor um sistema em partes mais gerenciáveis.
Exemplos de tais formalismos são as Redes de Autômatos Estocásticos (Stochastic Automata Networks SAN), as Redes de Petri e as Álgebras de Processos, entre outros.
Uma vez que o sistema é modelado com um determinado formalismo, escolhido a partir de o conjunto de primitivas disponíveis, a próxima etapa consiste na determinação da existência ou não de suas características estacionárias.
O objetivo é detectar se o equilíbrio foi atingido ou, caso contrário, analisar sua solução transiente, i.
e, quando o processo é executado numa quantidade de tempo pré-determinada.
Este processo é realizado através do mapeamento das taxas de ocorrência contidas nas transições considerando escala de tempo contínua ou das probabilidades de ocorrência, no caso de escala de tempo discreta.
Os valores são colocados numa matriz que mapeia um sistema linear de equações contendo um número de variáveis correspondente ao total do número de estados.
A solução do sistema é realizada através de métodos diretos ou iterativos.
A determinação da solução computacional de modelos trata de uma parte importante da análise de desempenho de realidades complexas, responsável por o cálculo de índices que atestam de forma numérica e quantitativa, o desempenho e a operação dos sistemas modelados.
Um exemplo que pode ser expresso através de modelagens analíticas são, entre outros, problemas de alocação, disponibilidade e utilização de recursos.
Sistemas paralelos e distribuídos estão sujeitos às aplicações de tais mecanismos, permitindo, por exemplo, a detecção de gargalos, questões sobre validação de modelos e análises que visem a otimização ou o estudo dos estados que o sistema assume.
Em modelagem Markoviana, um dos principais eixos de pesquisa em Avaliação de Desempenho alinha- se à solução otimizada do sistema linear que descreve o modelo quando este é transposto para representações matriciais que capturam a mudança dos estados.
Em este sentido, deve ser cuidadosamente observada a quantidade de memória exigida tanto para armazenar tais matrizes quanto os mecanismos que provêem a determinação do regime estacionário ou transiente dos modelos.
Técnicas tradicionais de armazenamento e solução através de abstrações tensoriais, tais como as presentes no formalismo das SAN são consideradas um avanço significativo, pois a maneira de representação utilizada nunca armazena a matriz de transição completamente (como as MC).
O formalismo de SAN utiliza representações tensoriais para os modelos, compostas por um conjunto finito e restrito de matrizes que compõem o denominado descritor Markoviano ou Kronecker.
Este formalismo é, portanto, eficiente em termos de memória necessária para armazenar o modelo pois salva apenas matrizes esparsas de baixa dimensão, dependendo das transições de cada autômato1.
A solução numérica de tais descritores Markovianos é igualmente foco de novas pesquisas e os algoritmos especializados para efetuar tal processo são chamados de algoritmos para a Multiplicação Vetor--Descritor (MVD).
As operações complexas de multiplicação que devem ser efetuadas no nível do descritor Markoviano podem ser otimizadas de diferentes maneiras.
Os descritores são formados de matrizes com elementos constantes ou funcionais, que são tipos mais complexos para o tratamento computacional apesar de serem simples primitivas de modelagem.
Logo, dada a formação das matrizes que compõem o descritor, este pode ser classificado respectivamente como clássico ou generalizado.
Em este último, as matrizes contêm elementos funcionais e são melhor explicados ao longo de o trabalho.
As formas de MVD tratam cada termo tensorial (i.
e, uma representação para cada evento do modelo) de forma independente e permitem a permutação das suas matrizes internas, alterando a sua ordem original, para promover ganhos em termos de tempo para efetuar cada iteração.
Um termo tensorial é composto por matrizes de diferentes tipos, tais como identidades, matrizes contendo um elemento ou matrizes com elementos funcionais, entre outros.
Estas matrizes estão sujeitas a serem trocadas de posição entre si, entretanto, desconhece- se os efeitos de se fazer esta re-estruturação dos termos de descritores tensoriais.
Esta tese analisará especificamente os algoritmos clássicos de MVD tais como o Algoritmo Esparso e o Algoritmo Shuffle em perspectiva com o Algoritmo Split.
Uma maior atenção será direcionada para este último pois, apesar de propor uma divisão dos termos tensoriais para aplicar uma solução híbrida, não se conhece ainda a melhor forma de realização destas divisões assim como suas consequências quando aplicadas a descritores generalizados.
A tese está direcionada para a descoberta das implicações das avaliações de taxas funcionais e a presença de matrizes do tipo identidade de cada termo tensorial para operar com menos operações de multiplicações em ponto-flutuante (relacionadas diretamente à complexidade envolvida para a MVD).
O objetivo destes estudos aliado ao fato de serem permitidos reordenamentos dos termos é flexibilizar ao máximo o Algoritmo Split para trabalhar com descritores Markovianos com taxas funcionais, comparando com a abordagem atual do Algoritmo Shuffle.
Como será mostrado ao longo de a tese, a adoção de uma estratégia para dividir os termos tensoriais impacta no tempo gasto para descoberta do regime estacionário ou transiente.
Motivação Os métodos de MVD dividem- se em duas classes distintas, conforme o custo em memória.
De um lado, o Algoritmo Esparso é frequentemente inviabilizado por os gastos em memória necessários para armazenamento da matriz de transição.
Já o Algoritmo Shuffle é eficiente em memória e otimizado para tratar de elementos funcionais realizando ou não permutações na ordem lexicográfica2 das matrizes para otimizar as avaliações e demais mecanismos para ganho de desempenho pesquisados em outros trabalhos.
Em este sentido, o Algoritmo Split surgiu como uma alternativa viável ao proporcionar uma maneira balanceada em termos de tempo e memória de realização do processo de MVD.
Esta abordagem mostrou- se ser bastante flexível, armazenando e agregando partes do descritor Markoviano.
Entretanto, desconhece- se as implicações das re-estruturações dos termos tensoriais dos descritores quando o Algoritmo Split é utilizado para realizar a MVD.
Dadas as limitações impostas por os descritores generalizados, aliadas à estrutura interna dos descritores clássicos e os tipos de matrizes envolvidas, observa- se a importância de se mapear tais consequências e antever potenciais problemas na solução dos modelos.
Estes estudos devem proporcionar um maior entendimento sobre como o algoritmo pode executar para fazer uso das reordens, parâmetros de elementos funcionais e tipos de 2 Em a ordem original das matrizes descritas por os autômatos.
Objetivo O principal objetivo deste trabalho é propor um algoritmo de re-estruturação de termos tensoriais que, dadas as características de termos clássicos ou generalizados de sistemas representados através de descritores Markovianos, forneça uma solução mais acelerada em termos de tempo face a os métodos de MVD presentes atualmente.
Em resumo, a memória a ser gasta não deve constituir- se num impedimento para utilização do Algoritmo Split.
Para a proposição deste algoritmo é necessário definir as características que mais influenciam os termos tensoriais, bem como as formas de permutação que podem ser adotadas, a quantidade de matrizes do tipo identidade e o total de parâmetros para avaliação de cada função presente num modelo.
A partir de estas informações será possível determinar as classes de modelos que o Algoritmo Split é melhor aplicado e questões relativas às limitações da sua flexibilidade.
Contribuição A o alcançar o objetivo, são esperados resultados relevantes no contexto da solução numérica de sistemas baseados em representações tensoriais presentes em formalismos estruturados para avaliação quantitativa de sistemas.
Em um primeiro momento, a pesquisa auxiliará na determinação das classes de modelos melhor adaptadas para utilização do Algoritmo Split quando comparado com as abordagens clássicas de MVD.
A partir destes resultados será construído um algoritmo que observe as características dos termos tensoriais de descritores clássicos e generalizados bem como suas matrizes internas e informe o quanto de memória será gasto para a busca dos índices de desempenho.
Em um segundo momento, ao se conhecer a estrutura interna de descritores Markovianos e os detalhes de execução do processo de MVD e seus principais algoritmos poderá ser definido um conjunto de regras de mapeamento para que diferentes formalismos estruturados que possuam uma representação tensorial sejam beneficiados com uma solução MVD otimizada.
Isto ampliará as maneiras de se analisar o desempenho de sistemas já que será possível modelar- lo utilizando- se as primitivas existentes num determinado formalismo e resolver- lo com métodos que encontram- se no estado-da-arte de MVD com representação tensorial, dado que uma conversão para este formato exista e seja válida.
Este formato descritivo fornecerá o conhecimento necessário para a proposta da implementação de uma ferramenta que resolva descritores Markovianos re-estruturando seus termos tensoriais para utilizar o Algoritmo Split.
Organização A tese está organizada da seguinte forma:
O Capítulo 2 aborda diferentes formalismos presentes na literatura, seguido por o Capítulo 3 que demonstra formas mais abstratas de descrição de sistemas.
As definições são usadas no Capítulo 4, que trata sobre as formas de MVD e a operação dos seus algoritmos principais.
Após abordar a MVD, demonstram- se as estratégias para divisão de termos tensoriais clássicos e generalizados no Capítulo 5, considerando- se as implicações teóricas e as características mais importantes.
A seguir, explicam- se as funcionalidades da ferramenta GTAexpress no Captítulo 6 para, no Capítulo 7 apresentar os resultados obtidos de diferentes experimentos.
A tese é finalizada por o Capítulo 8 com um resumo das contribuições e as perspectivas futuras.
Uma das maneiras de se descrever realidades complexas é através da sua representação com um formalismo.
Um formalismo é um conjunto de regras que mapeiam propriedades e características de sistemas a modelos e definem, de forma não ambígua, as entidades relacionadas e o funcionamento das suas interações.
Pode- se, por exemplo, observar como os elementos de cada modelo transitam de condição em condição, trocando ou não de estado, de acordo com taxas ou frequências de ocorrência.
O objetivo final de se realizar tais mapeamentos é permitir que sejam extraídos índices computacionais de desempenho tais como indicadores correspondentes à utilização dos recursos ou informações para inferir a capacidade média de um buffer 1, entre outros exemplos.
Os formalismos para avaliação de desempenho são compostos por diferentes primitivas de modelagem que auxiliam na descrição das realidades estudadas.
Para o caso dos formalismos de descrição com vistas a a análise de sistemas complexos e estudo da solução analítica é comum constatar a existência de duas entidades principais:
Estados e transições.
Os formalismos definidos na literatura distinguem- se entre si de diversas formas, entretanto, todos são fundamentalmente baseados no formalismo das Cadeias de Markov.
Este capítulo discutirá diferentes maneiras para abstração de sistemas em representações analíticas através da aplicação das primitivas de modelagem presentes em alguns dos formalismos Markovianos da atualidade.
Em o contexto deste trabalho assume- se que o objetivo da descrição com formalismos é encontrar uma solução estacionária ou transiente para um dado sistema sem recorrer a outras práticas igualmente importantes porém menos precisas, dependendo do caso, tais como simulação.
O capítulo é iniciado com considerações preliminares sobre abstração e modelagem de sistemas em geral na Seção 2.1, seguido da definição de Cadeias de Markov na Seção 2.2, Redes de Petri e uma de suas variantes, as Redes de Petri Coloridas na Seção 2.3.
A seguir, o capítulo aborda as Redes de Autômatos Estocásticos na Seção 2.4, Álgebra de Processos na Seção 2.5 e é finalizado com uma breve análise comparativa com as vantagens e desvantagens de cada formalismo na Seção 2.6.
Modelagem de sistemas A modelagem computacional de realidades com múltiplos estados e transições é uma parte im-portante da avaliação analítica pois transforma descrições alto nível e primitivas em informações que atestam a operação e a qualidade dos sistemas sob estudo.
A necessidade de métodos formais para avaliação computacional de desempenho foi melhor investigada com o objetivo de prover raciocínios (reasoning) em sistemas e auxiliar na descoberta de gargalos, erros e eventuais problemas antes da sua disponibilidade física.
O objetivo inicial da análise de sistemas foi o de adicionar determinismo e enumerar meios de descrever realidades com transições intrincadas matematicamente, ou seja, de forma não ambígua.
A ideia era aplicar os conceitos formais presentes e permitir a construção de 1 Uma região auxiliar de memória.
As observações iniciais indicaram que simples modelos poderiam ser analiticamente resolvidos numa quantidade finita e razoável de tempo e mesmo assim continuariam capturando as características primordiais do sistema mesmo quando estes fossem ampliados em escala.
Tratou- se de um resultado importante apesar de esta ser, à primeira vista, uma maneira não-trivial de atacar o problema da modelagem computacional de sistemas pois provou que era suficientemente simples adicionar estados e transições num dado modelo e este, mesmo assim, retornaria respostas consistentes.
Os resultados demonstrariam, por exemplo, se uma dada realidade estaria degradada e até mesmo quando começaria a desempenhar suas atividades de forma insatisfatória.
Estes números, quando devidamente interpretados, indicariam a necessidade de se comprar mais máquinas ou outros componentes físicos de sistemas antes que recursos financeiros fossem utilizados.
Estas constatações demonstraram que a análise de desempenho de sistemas é, de fato, uma maneira crucial de se evitar o desperdício de recursos pois trata da modelagem analítica em alto nível e solução computacional antes do sistema físico estar operacional.
Sistemas para extração de relações de causa e efeito podem beneficiar- se das vantagens da modelagem estocástica.
Técnicas de análise baseadas em &quot;força bruta «devem ser postas de lado e darem lugar a enfoques probabilísticos, baseados em abstrações da realidade (através da modelagem estocástica dos sistemas).
O mapeamento de diferentes realidades para modelos permite a determinação precisa das interconexões das entidades envolvidas, capturando as suas nuances e respondendo questões críticas, analisadas a partir de os índices de desempenho calculados.
O objetivo é, dado um contexto de aplicação, abstrair a realidade num modelo e calcular seus índices, extraindo informações dos grandes volumes de dados e apresentando as descobertas de forma organizada.
Os passos para inspecionar sistemas envolvem as suas operações fundamentais, ou seja, capturase a essência das tarefas realizadas por o sistema e as trocas de estados existentes.
Quando apropriadamente definidos, estes passos aumentarão as chances de se produzirem resultados relevantes.
Antes de modelar uma realidade complexa é importante definir sua operação principal num modelo restrito, ou seja, o mais simples possível, definindo quais estados este possui e como transita de estado para estado.
A seguir, é realizada uma análise mais minuciosa descartando estados que não são importantes para a operação do sistema como um todo.
A partir de abstrações ou refinamentos dos modelos é possível caracterizar a operação fundamental do sistema.
Este processo está normalmente associado ao esforço dos modeladores ao representar o sistema através de modelos.
Estas melhorias também são utilizadas para a otimização do sistema como um todo.
A o proporcionar a alteração de estados e transições, pode- se potencialmente descobrir uma melhor configuração para sua operação ou formas simplificadas que onerem menos recursos.
Após verificar os cenários a serem modelados, estuda- se qual formalismo pode ser usado e qual oferece a melhor maneira de descrever a realidade, dadas as suas características e as formas por as quais evolui e interage com as suas partes constituintes (seus componentes).
A escolha de um formalismo que apresente o melhor conjunto de ferramentas computacionais para solução e verificação é igualmente importante, pois não basta um formalismo ser eficaz em termos de descrição mas ineficaz ao calcular os índices de desempenho.
Dando seguimento ao processo, o próximo estágio trata de buscar o equilíbrio do sistema onde este é analiticamente resolvido através de cálculos sobre os quais é possível inferir os índices de desempenho para o modelo.
Para resolver um modelo, calcula- se o vetor de probabilidades correspondente à estacionariedade do sistema, i.
e, supõe- se que este foi` simulado' até um ponto onde suas mudanças não mais afetam o seu estado inicial.
Pode- se dizer que o sistema chegou num momento onde não mais evolui atingindo um equilíbrio, dadas as taxas de ocorrência definidas para as transições.
Assim, extraemse os índices computacionais de desempenho comparando- os com outras modelagens do mesmo problema, adicionando ou excluindo componentes e estados, inspecionando o reflexo das mudanças nos índices.
A descrição do processo de modelagem, abstração e mapeamento de informações de sistemas é mostrada por a Figura 2.1.
Uma dada realidade pode ser pensada como um conjunto de entidades dentro de um certo domínio que interagem através de um conjunto de regras.
Estas entidades possuem estados e transitam entre estes com uma certa frequência com o disparo de eventos, que podem ser considerados operações sobre um estado do sistema que deslocam- se para outros estados.
Após a consideração destes aspectos, inicia- se a formalização propriamente dita através da criação de um modelo com primitivas não-ambíguas de modelagem, compreendendo o processo que resultará no cálculo e descoberta dos índices de desempenho.
Ressalta- se a importância de abstrair detalhes e capturar apenas os aspectos mais relevantes do sistema sob análise.
Estas abstrações serão determinantes para a obtenção dos índices calculados na fase de solução.
Após esta fase, os índices são inspecionados e interpretados no estágio de análise, seguida por etapas de modificações do modelo, utilizando a retro-alimentação (feedback) obtida nos estágios anteriores.
Para determinar que uma dada modelagem é válida podem ser utilizadas, entre outros mecanismos, técnicas de simulação de eventos discretos.
Todo o processo de modelagem computacional é iterativo, ou seja, apenas para quando o modelador determina que o modelo construído mapeou a realidade satisfatoriamente.
A análise dos modelos ajuda a prevenir inconsistências e comportamentos indesejados bem como detecta condições de disparo de transições.
A Tabela 2.1 lista, de forma ampla, os principais formalismos existentes na literatura e as datas dos primeiros trabalhos onde foram aplicados bem como algumas de suas extensões.
A seguir, serão discutidos num maior nível de detalhe os seguintes formalismos:
Cadeias de Markov, Redes de Petri, Redes de Autômatos Estocásticos e Álgebra de Processos.
Cadeias de Markov Cadeias de Markov (MC ou Markov Chains) são processos estocásticos2 em tempo discreto ou contínuo com entidades bastante simples:
Estados e transições associadas.
O formalismo foi proposto com um interesse particular, baseado em textos literários.
Esta aplicação não usual demonstra a versatilidade do formalismo, podendo ser utilizado para mapear inúmeras realidades.
O objetivo da aplicação original de MC foi, dado um texto e uma determinada posição, inferir a probabilidade de uma próxima letra ser uma vogal dado que a letra atual é uma consoante.
Trata- se de uma propriedade primordial de MC, a chamada memoryless property.
Esta propriedade estabelece que toda a informação relevante está contida no estado atual, não interessando os estados anteriores.
MC é utilizado devido a a sua simplicidade e ao fato de possibilitar inferências de raciocínios e inspeções de desempenho para realidades variadas através de primitivas básicas de modelagem.
Hoje em dia, as MC são utilizadas em inúmeros contextos tais como simulação ou análises de riscos no mercado de ações, para citar algumas aplicações.
Um outro exemplo da utilidade deste formalismo são os sistemas de indexação e procura da Internet, onde o conjunto de informações existentes é amplamente desorganizado e de proporções massivas.
A dificuldade desta classe de problema é a de encontrar páginas com conteúdo relevante para o que se esteja procurando, às vezes, observando contexto, ou seja, também retornando outras páginas com conteúdo similar.
O principal conceito pode ser modelado como cada página na Internet sendo um estado e construir uma abstração onde considera- se uma entidade que` salta' de página em página, visitando- as de forma aleatória e simulando uma caminhada randômica (random walking).
O processo de visitação das páginas é realizada de forma aleatória onde, a partir de uma página inicial, deseja- se visitar as outras páginas conectadas à esta (em terminologia da Internet, cada página possui diversos links, ou seja, transições para outras páginas).
A o modelar este problema como sendo uma MC e resolver o sistema de equações que o representa onde as variáveis são as páginas, o resultado prático é a probabilidade (a relevância) de páginas similares.
A o descobrir e ordenar estas probabilidades de ocorrência em ordem decrescente (as com maiores probabilidades primeiro), são retornadas as páginas mais prováveis para o usuário.
Esse conceito é utilizado por o sistema de buscas da empresa Google e o processo neste contexto é descrito de forma superficial 3.
Em o contexto de MC, é possível representar um sistema usando tempo contínuo (também chamadas de Cadeias de Markov em escala de tempo contínuo ­ Continuous Time Markov Chains, ou CTMC) ou tempo discreto (Cadeias de Markov em escala de tempo discreto ­ Discrete Time Markov Chains, ou DTMC).
A Figura 2.2 mostra um exemplo de Cadeia de Markov em escala de tempo contínuo com N $= 9 estados e uma taxa para cada transição, definidas como µ ou, dependendo do estado observado.
Os índices de desempenho são computados da distribuição estacionária ou transiente da Cadeia de Markov, resolvendo- se as equações de balanço global do sistema através da ferramenta 3 Esta descrição encontra- se bastante simplificada neste trabalho, pois são utilizados algoritmos complexos de mapeamento, indexação e associação de ranks a páginas, normalmente através de implementações proprietárias inacessíveis à comunidade externa por questões mercadológicas.
Marca (Markov Chain Analyzer), entre outras.
As principais distinções versam sobre a duração deste processo a partir de um determinado tempo t sobre o tempo total T.
São chamadas de probabilidades estacionárias quando atingiram o equilíbrio em T e transientes quando interrompe- se o processo em t e analisam- se os índices de desempenho.
Estas variáveis de entrada são extraídas da matriz de transição P da MC, onde a probabilidade pij significa a probabilidade condicional para sair do estado i e ir para o estado j, onde i $= j.
Para o caso da solução estacionária do sistema, a equação pode ser escrita para DTMC como:~ $=
0 onde Q~ $= T+ I e T (maxi(| pij|) 1.
Esta P $= ou para o caso de CTMC como:
Q operação irá converter a representação em tempo contínuo representado por as taxas de transição de a~ para uma representação baseada em tempo discreto com as probabilidades de transição matriz Q da matriz P.
Em este sistema discreto, as transições acontecem em intervalos de tempo T.
Este parâmetro é normalmente escolhido para que a probabilidade existente entre duas transições seja negligenciável.
Logo, uma MC pode ser vista como um sistema de transição de estados onde o modelador define quais estados são acessíveis a partir de outros estados e configura uma taxa ou probabilidade das transições do sistema.
Existem diversos métodos para resolver o sistema linear de equações, tais como métodos diretos (eliminação Gaussiana, decomposição Lu), iterativos (Método da Potência, Jacobi ou Gauss-Seidel), de bloco (Gauss-Seidel de bloco) ou de projeção (como Generalized Minimal Residual Algorithm ­ GMRES), para citar alguns exemplos.
Métodos de solução direta deste sistema de equações tais como eliminação Gaussiana não são eficientemente aplicáveis em modelos com número de estados elevado, pois requerem igualmente elevadas quantidades de memória para armazenar a matriz de transição.
Já técnicas iterativas de~ de forma esparsa, solução são melhor aproveitadas, principalmente as que armazenam a matriz Q entretanto, existem limites quanto a os modelos que podem ser resolvidos desta forma.
O resultado da multiplicação de uma matriz por um vetor traduz a probabilidade de estar num estado num certo tempo, depois que o sistema está operacional.
A Figura 2.3 mostra como é gerada a matriz Q da Figura 2.2.
Para este caso, cada estado da cadeia leva a um ou mais estados de acordo com uma taxa (µ ou).
Para transformar essa matriz num Gerador Infinitesimal correspondente a a~ é necessário que a soma de cada linha resulte em zero.
Para tanto, precisa- se corrigir a matriz Q diagonal principal para refletir essa exigência.
A seguir é mostrada esta correção, preparando a matriz para posterior multiplicação por um vetor de probabilidades:
Para a CTMC desta matriz, calcula- se Q resolve- se o sistema de equações lineares.
O resultado informa as probabilidades de permanência de cada estado do sistema.
A partir destes resultados, extraem- se os índices de desempenho.
Um critério de parada utilizado nos métodos iterativos clássicos é verificar que a variação entre duas iterações elemento a elemento seja menor que 1E 10.
Supondo que sejam escolhidos os valores~ $= 0) corresponde a a:
Gerador Infinitesimal Uma alternativa é utilizar métodos diretos, definindo o sistema linear de equações com nove incógnitas, onde busca- se encontrar o conjunto de valores que satisfaçam:
Outro meio de solução é utilizar, por exemplo, o Método da Potência.
A o utilizar esta técnica, para este modelo e para os valores de taxas de transição escolhidos, são necessárias 118 iterações para obtenção da solução estacionária, resultando em valores da probabilidade da permanência em cada estado.
Por exemplo, a Tabela 2.2 mostra que o estado AY tem 30 52% de probabilidade de permanência enquanto que o estado Az tem 26 25%.
Caso os estados desta MC significassem, por exemplo, processadores e a métrica observada fosse processamento, os de` rótulo' AY e Az estariam ocupados 56% do tempo na operação desse sistema.
A tabela também mostra, na coluna, o índice do vetor de probabilidades para cada estado global do sistema.
É igualmente possível modificar as taxas do modelo trocando- as para os seguintes valores:
µ $= 1 $= 5 $= 8.
Estas mudanças alteram a convergência do método fazendo com que sejam necessários 186 passos.
Os resultados obtidos são mostrados na parte direita da Tabela 2.2, que mostra que as maiores probabilidades de permanência estão concentradas nos estados AY Az CY e CZ.
Como mencionado anteriormente, a modelagem mapeia os estados que um sistema adota, constituindo o chamado Espaço de Estados da realidade.
Entretanto, quando são necessários muitos estados para compor um determinado sistema, diz- se que ocorre uma explosão do espaço de estados.
Dependendo do número de estados, não é possível resolver o sistema de equações num tempo razoável por falta de recursos computacionais tais como memória ou poder de processamento.
Esta limitação de modelagem e consequentemente de solução numérica foi a responsável por a pesquisa de mapeamentos mais estruturados das cadeias, como será abordado a seguir.
Apesar de amplamente utilizadas, as MC possuem problemas fundamentais, sendo o principal quando um modelo possui um elevado número de estados tornando- o de difícil análise.
Esta explosão do espaço de estados também torna impraticável a solução do sistema de equações via métodos diretos e, às vezes, até mesmo métodos iterativos num tempo razoável.
Este problema foi constatado desde a definição inicial de MC, onde verificou- se que mesmo simples descrições criavam muitos estados gerando desafios relacionados tanto às questões de armazenamento da matriz de transição quanto a os mecanismos de solução envolvidos.
Para reduzir os efeitos problemáticos da explosão do espaço de estados foram consideradas outras formas de representação dos sistemas, mas permanecendo com a visão das Cadeias de Markov como alternativa válida de modelagem.
A alternativa encontrada foi a definição de formalismos estruturados, usados para representar um sistema num nível superior de abstração, através de uma Cadeia de Markov correspondente de forma implícita ou subjacente.
Este novo tipo de visão criou novas definições, tais como modelar partes do sistema como entidades ou componentes autônomos mas que eventualmente sincronizavam atividades.
A o efetuar o produto cartesiano dos espaços de estados de cada subsistema, ou seja, ao combinar todos os estados passíveis de serem compostos dos componentes de um dado formalismo estruturado, por exemplo, autômatos em Redes de Autômatos Estocásticos (Seção 2.4) ou processos em PEPA (Seção 2.5.1), trabalha- se, na verdade, com uma Cadeia de Markov correspondente.
Este produto cartesiano também é chamado de Espaço de Estados Produto X (Product State Space, ou PSS) e dita a quantidade de estados total no sistema.
Cabe ressaltar que os formalismos estruturados reduzem significativamente o problema da explosão do espaço de estados, mas não o eliminam completamente.
Alguns formalismos estruturados apresentam também a problemática relacionada à existência de estados inatingíveis, pois, ao combinar os estados entre si e usar as transições definidas no modelo, são gerados estados que não podem ser alcançados dependendo do estado inicial escolhido.
Este problema é melhor evidenciado na modelagem Markoviana, bastando verificar a existência de estados sem saídas (estados absorventes) ou chegadas (estados inatingíveis).
Dependendo do caso, o Espaço de Estados Atingível X R (Reachable State Space, ou RSS) é um subconjunto do PSS, i.
e, X R X, entretanto, ainda permanece um problema em aberto a solução eficiente de modelos complexos onde todos, ou quase todos, os estados são atingíveis.
Entretanto, estes problemas podem ser mitigados utilizando- se estruturas de dados sofisticadas de manipulação simbólica tais como Diagramas de Decisão Multi--valorados (Multivalued Decision Diagrams ou MDD) ou através do uso de vetores reduzidos.
Redes de Autômatos Estocásticos ou até mesmo descrições modulares e composicionais como PEPA.
O princípio geral de utilizar tensores para representação implícita desta matriz existe desde os primórdios da definição das Redes de Autômatos Estocásticos, mas recentemente observou- se a aplicação com êxito em outros formalismos estocásticos.
As vantagens e desvantagens ao se adotar um formalismo variam de caso para caso e é necessário saber previamente as funcionalidades presentes em cada definição, maximizando- se, assim, as análises que são permitidas.
O objetivo do restante deste capítulo é introduzir outras importantes descrições para modelagem de sistemas.
O próximo formalismo a ser descrito refere- se às Redes de Petri, seguido por Redes de Autômatos Estocásticos e Álgebra de Processos.
Redes de Petri, (PN ou Petri Nets) são representações gráficas de modelagem para descrição de sistemas através do uso de anotações.
Estruturas comuns de Redes de Petri são nodos que correspondem a lugares (place nodes), nodos que correspondem a transições (transition nodes) e arcos dirigidos que representam conexões entre lugares e transições.
Dentro de cada lugar, existem marcas (tokens) e a distribuição de tais marcas dentro de uma rede é conhecida como uma marcação (marking).
A maior vantagem da adoção de PN para modelagem está no fato de possibilitar uma visão clara de causalidade e conflito nas regiões que compõem a rede, devido a a maneira utilizada para representar o sistema.
Uma extensão de PN são as chamadas Redes de Petri Estocásticas (SPN ou Stochastic Petri Nets), definidas por a introdução de tempo de disparo não-determinístico entre transições.
A Figura 2.4 mostra um exemplo de uma PN.
A rede descrita por a figura contém quatro lugares e três transições mostrando como as marcas podem se movimentar de um lugar ao outro dentro de a rede.
Uma importante vantagem de uma PN é sua característica ao descrever como funciona o fluxo de informações na rede e como operam as estruturas de controle e restrição de movimentação dos tokens entre os lugares.
A rede possui uma estrutura e um sistema de marcação.
A estrutura representa a parte estática do sistema.
Os dois tipos de nodos são representados por componentes gráficos, círculos para os lugares e retângulos para as transições.
Os lugares correspondem aos estados do sistema e as transições a ações que forçam a mudança entre os estados.
Os arcos conectam lugares a transições e transições a lugares, sendo chamados, respectivamente, de arcos de entrada e arcos de saída.
Cabe ressaltar que, com o tempo, as SPN foram estendidas para modelar apenas algumas transições de um sistema com tempo de disparo não-determinístico.
Essa extensão foi chamada de Redes de Petri Estocásticas Generalizadas (GSPN ou Generalized Stochastic Petri Net)[ CHI93a, AJM95, BAL07] e permite a modelagem de realidades que possuem atividades de durações variáveis e que podem trocar de estado muitas vezes.
Uma GSPN permite duas classes diferentes de transições:
Entretanto, observou- se a necessidade de se compartimentalizar (ou modularizar) os modelos definidos com PN, onde existem interações entre esses componentes.
As Redes de Petri Estocásticas Generalizadas Superpostas (SGSPN ou Superposed Generalized Stochastic Petri Net)[ DON93, DON94] foram definidas permitindo a interação entre os componentes através da superposição de transições.
A solução de modelos desta classe de redes pode ser tratada pois deriva uma expressão tensorial similar à adotada por as Redes de Autômatos Estocásticos (maiores detalhes na Seção 2.4, a seguir, ou no Capítulo 4) para o seu Gerador Infinitesimal.
A modelagem em SGSPN é feita através do uso de módulos com transições locais e que também interagem através de sincronizações.
As fórmulas tensoriais (melhor explicadas na Seção 4.3) são bastante similares às obtidas através das manipulações tensoriais presentes em Redes de Autômatos Estocásticos.
Um modelo descrito em SGSPN é mostrado na Figura 2.5.
Este modelo possui dois componentes chamados C 1) e C 2) (mostrado na figura com uma separação &quot;abstrata «conforme as linhas sendo que os dois componentes estão sendo sincronizados por o evento t3.
Esta rede possui duas marcas, uma em p1 e a outra em p6.
A marcação de uma Rede de Petri é a associação de marcas a lugares.
Para uma definição formal de uma PN é necessário especificar a estrutura da rede e a marcação inicial, i.
e, onde as marcas serão inicialmente colocadas dentro de a rede.
A dinâmica do sistema segue um conjunto básico de regras sendo que uma transição ocorre quando o lugar de entrada cumpre as condições expressas por as inscrições dos arcos.
O objetivo deste trabalho não é especificar formalmente PN, apenas oferecer uma breve descrição deste formalismo.
A solução de PN pode ser realizada através do uso da ferramenta SMART.
Para maiores informações sobre PN e suas extensões indica- se[ PET77, MOL82, AJM84, MUR89, BAL07], que mostram o funcionamento e explicam PN com um maior nível de detalhe.
PN possuem extensões para capturar outros tipos de comportamento de sistemas.
Uma extensão bastante conhecida são as Redes de Petri Coloridas (CPN ou Coloured Petri Nets).
A principal distinção entre uma Rede de Petri tradicional e uma Rede de Petri Colorida reside nas informações contidas nas marcas.
Em PN elas são indistinguíveis (possuem uma mesma cor), enquanto que em CPN, cada marca pode possuir uma característica distinta associada tal como, por exemplo, uma cor.
Uma CPN é um formalismo estruturado usado em realidades onde sincronizações e comunicações são necessárias, combinando as vantagens de Redes de Petri com conceitos de linguagens de programação de alto nível.
CPN utilizam as ideias que descrevem como as entidades cooperam entre si e proveem mecanismos para manipulação de estruturas de dados e associação a variáveis, ou seja, conceitos de linguagens de programação.
Tais redes, como PN tradicionais, possuem lugares, transições e arcos.
Adicionalmente, possuem um outro componente chamado páginas, que podem potencialmente conter lugares.
O conjunto destes elementos formam uma rede que, quando usados em conjunto e mostrados graficamente, permitem a manipulação de estruturas complexas fornecendo auxílios visuais para reconhecer como as entidades estão conectadas entre si e como interagem.
CPN podem ser usadas para verificação formal, pois oferecem um conjunto de ferramentas desenvolvidas para este propósito específico.
Existem dois tipos de métodos de verificação em CPN:
Análise do espaço de estados e análise de invariantes.
O objetivo da verificação formal é provar matematicamente que um sistema possui um conjunto de propriedades comportamentais.
À medida que sistemas atingem uma escala industrial, também torna- se difícil sua análise.
As CPN podem ser usadas para estes propósitos, aliadas a outros mecanismos de validação utilizando- se simulação.
De entre as vantagens de se adotar CPN para modelar sistemas, destaca- se:
Primitivas para estabelecer e realizar inferências sobre a interação de componentes dentro de um sistema, modelagem de sub-componentes (também conhecida por modelagem hierárquica), descrição gráfica de sistemas e ferramentas para solução do sistema em questão (através de um software chamado CPN Tools).
Para outras informações sobre CPN, sugere- se os seguintes trabalhos e mais recentemente.
Redes de Autômatos Estocásticos Redes de Autômatos Estocásticos (SAN ou Stochastic Automata Networks) é um formalismo estruturado utilizado para o cálculo de índices de desempenho na área da avaliação quantitativa de sistemas.
Este formalismo baseia- se em entidades semi-autônomas chamadas autômatos e como estes componentes se relacionam para sincronizar transições ou trocar de estados.
O conjunto destes autômatos forma uma rede, onde é permitido que sejam analisadas diferentes realidades.
O formalismo foi originalmente construído para visar o mapeamento de atividades de paralelismo e distribuição onde elementos tem comportamentos independentes mas eventualmente necessitam sincronizar tarefas entre si.
Em SAN, descrevem- se os sistemas de maneira estruturada, implicitamente gerando- se a MC correspondente.
Essa estruturação implica no armazenamento eficiente das estruturas de dados, facilitando a representação de sistemas com múltiplas transições e produzindo índices de desempenho para posterior análise e interpretação.
Mais especificamente, SAN é um formalismo estruturado que descreve interações entre entidades conhecidas por autômatos.
Cada autômato apresenta transições específicas na sua estrutura, trocando de estados através de transições que, por sua vez, são regidas por um ou mais eventos.
Um autômato altera seu comportamento local através de eventos locais ou interage com outros autômatos através de eventos sincronizantes.
Um evento sincronizante envolve, no mínimo, dois autômatos e representa uma mudança de estado que acontece de forma concomitante.
Um evento é disparado de acordo com a definição de uma taxa de ocorrência ou taxa de transição.
A taxa de ocorrência de um determinado evento é classificada de duas maneiras distintas:
Constante ou funcional.
Uma taxa constante é uma frequência média com a qual a transição ocorre.
Uma taxa funcional tem seu valor médio determinado segundo o estado de outros autômatos, de acordo com fórmulas de consulta a estados pré-estabelecidas por os usuários quando modelam a abstração do sistema.
A vantagem em se utilizar taxas funcionais consiste, entre diversos fatores, em simplificar a modelagem e, dependendo do caso, reduzir o número de eventos ou, até mesmo de autômatos, para representar uma realidade.
A Figura 2.6 mostra um exemplo de uma SAN simples com eventos locais (loc) e sincronizantes (syn), contendo taxas constantes e funcionais.
A figura mostra uma rede composta por dois autômatos, cooperando sobre um espaço de estados produto de tamanho| X| $= 3 × 3 $= 9.
O exemplo define cinco eventos locais e dois eventos sincronizantes.
Uma das taxas é funcional (f) sendo as demais taxas constantes.
A taxa funcional é avaliada para r6 quando o estado do autômato 1) for igual a A ou igual a C, ou avaliada para zero (i.
e, não ocorrendo), caso contrário (nesse caso, igual a B) 4.
Um modelo em SAN é transformado num descritor Markoviano (uma representação tensorial~ também chamado de descritor Kronecker), para o Gerador Infinitesimal Q, i.
e, um conjunto de matrizes responsáveis por definir a ocorrência dos eventos locais e sincronizantes de forma tensorial, melhor descritas na Seção 4.3.
Após a definição do descritor, é utilizado um método especializado para multiplicar- lo por um vetor de probabilidade, ou seja, efetuar a Multiplicação Vetor--Descritor (MVD, maiores informações na Seção 4.4).
Apesar de as suas diferenças algorítmicas, o processo de multiplicar um vetor por um descritor pode ser resumido em encontrar uma forma adequada de multiplicar uma estrutura usualmente grande (o vetor) por outra reduzida mas com estruturação complexa (o descritor Markoviano).
Algumas soluções para SPN traduzem a representação dos modelos numa única matriz esparsa.
Naturalmente, esta proposta esparsa é difícil de ser utilizada para modelos com muitos símbolo`|' na função f representa um teste lógico &quot;Ou «e o símbolo` $ ' representa um teste lógico que retorna verdadeiro caso o estado seja igual à parte da direita da fórmula.
MVD com o Algoritmo Split usando- se a ferramenta GTAexpress e técnicas de Simulação Perfeita.
Maiores informações sobre métodos de solução de MVD encontram- se no Capítulo 4 e sobre a GTAexpress no Capítulo 6.
Álgebras de Processos Com o passar dos anos constatou- se um crescente aumento na adoção de Álgebras de Processos Markovianas (MPA ou Markovian Process Algebras) voltadas para a construção de modelos que representem sistemas complexos.
Exemplos incluem Performance Evaluation Process Algebra (PEPA) e Extended Markovian Process Algebra (Empa), ou seja, formalismos desenvolvidos para capturar o comportamento de sistemas e permitir análise funcional através da solução da CTMC associada.
Uma das principais atrações para o uso de álgebras de processos é a habilidade de se construir um modelo composicional baseado numa definição em alto-nível.
Tais álgebras permitem que sejam usadas em diversas aplicações, onde são facilmente modeladas através de sim-ples primitivas que mostram como o sistema evolui de acordo com seu comportamento interno e de acordo com as interações existentes entre os componentes modelados.
Como em todas as álgebras de processos, sistemas são representados em PEPA como a composição de componentes que realizam ações.
Em PEPA, as ações ocorrem conforme uma duração, logo, a expressão (r).
P denota um componente que realizou uma ação com taxa r e evoluiu para um componente P.
Aqui, onde é o conjunto de tipos de ações e P C, onde C é o conjunto de tipos de componentes.
PEPA possui um conjunto restrito de &quot;combinadores», e as descrições dos sistemas são construídas a partir de a execução concorrente e interação simples de componentes sequenciais.
A sintaxe destes combinadores está informalmente descrita abaixo, entretanto, maiores detalhes são encontrados em.
Prefix: O combinador prefix marca uma parada completa, dando ao componente a sua primeira ação designada.
Como explicado anteriormente, (r).
P executa uma ação com taxa r, e subsequentemente começa a se comportar como P;
Choice: O componente P+ Q representa um sistema que pode se comportar tanto como P ou como Q. As atividades de ambos P e Q estão autorizadas (enabled).
A primeira atividade a acabar distingue- se (ou seja, é autorizada), a outra é descartada;
Constant: É conveniente associar nomes a padrões comportamentais de componentes e consdef tantes realizam essa tarefa definindo uma equação, i.
e, X $= E. O nome X está no escopo def da expressão do lado direito, significando que, por exemplo, X $= (r).
X desempenha com taxa r para sempre;
Hiding: A possibilidade de abstrair alguns aspectos do comportamento de componentes é realizado por o operador hiding, denotado por P/ L. O conjunto L identifica aquelas atividades as quais são consideradas internas ou privadas ao componente e quais irão aparecer como o tipo desconhecido chamado;
Q para descrever cooperação entre P e Q sobre L. O conjunto Cooperation:
Escreve- se P L é o conjunto de cooperação e determina as atividades com as quais os componentes devem sincronizar atividades.
Para tipos de ação fora de L, os componentes procedem independentemente e concorrentemente com suas atividades autorizadas.
Escreve- se também P Q como Q quando o conjunto L está vazio.
As atividades do conjunto de cooperação definido somente realizam a atividade quando ambas estiverem autorizadas.
Os dois componentes então procedem juntos para completar esta atividade compartilhada.
A taxa da atividade compartilhada pode ser alterada para refletir o trabalho realizado por ambos os componentes envolvidos com a finalidade de acabar a atividade.
A capacidade total do componente C para realizar tarefas do tipo é definida por a taxa aparente de em P, denotada por r (P).
PEPA assume bounded capacity, ou seja, a taxa de uma atividade compartilhada é igual ao valor mínimo entre as taxas das atividades dos componentes que estão cooperando.
Em alguns casos a taxa de uma atividade é deixada sem especificação (denotada por) e é determinada por a taxa da atividade do outro componente quando existe uma cooperação.
Estas ações passivas devem ser sincronizadas no modelo final (forçando a ocorrência de uma taxa para a cooperação).
A sintaxe de PEPA pode ser formalmente introduzida a partir de a seguinte gramática:
Onde S denota um componente sequencial e P denota um componente de modelo o qual é executado em paralelo.
C é uma constante que denota tanto um componente sequencial quando um componente de modelo.
Cs são constantes que denotam componentes sequenciais.
O efeito desta separação sintática entre estes tipos de constantes serve para restringir componentes PEPA para configurarem cooperações de processos sequenciais, uma condição necessária para existência de processos Markovianos bem definidos5.
O significado de uma expressão PEPA é dado por a semântica operacional estrutural que define as formas por as quais ocorrem a evolução de um determinado modelo, podendo ser aplicado exaustivamente para formar um sistema de rótulos denominado Grafo de Derivação (Gd) representando em última análise o espaço de estados do modelo (somente os atingíveis).
Trata- se de um grafo o qual cada nodo é uma forma sintática distinta, definida como derivativo (derivative) e cada arco representa uma atividade possível causando uma mudança de estado.
O estado muda em conjunção com a Matriz de Transição (MT), que guarda o nome do evento e a sua taxa de ocorrência para cada dois estados.
É importante notar que em PEPA a representação de estados é de fato um sistema de rótulos com multi-transições, pois guarda a multiplicidade de arcos, particularmente quando componentes repetidos estão envolvidos.
O Gd pode ser considerado como um diagrama de transição de estados de uma CTMC;
Q (P Q) então denota a taxa de transição entre o derivativo P e o derivativo Q. Análises de desempenho são feitas em termos de a procura da distribuição estacionária de probabilidades entre os estados da PEPA.
O Gd também deve ser fortemente conectado para geração da CTMC correspondente.
A seguir, um exemplo de um único componente com três derivativos, P 1, P 2 e P 3, cada um com uma ação distinta (start ou início, run ou execução e stop ou parada) e mesma taxa de ocorrência r para todas as ações.
S denota a Equação do Sistema (System Equation), responsável por a instanciação dos processos e marcação do estado inicial, utilizado para percorrer os derivativos em 5 Ou seja, a Cadeia de Markov deve ser ergódica.
P1 $= (start r).
P2 def P2 $= (run r).
P3 def P3 $= (stop r).
P1 def A MC gerada a partir deste modelo está mostrada na Figura 2.7.
A combinação dos três componentes do modelo gerou nove estados e o sistema de transições de acordo com as regras predefinidas.
Apesar de o fato das álgebras de processos possuírem as vantagens expressas acima, sua modelagem é puramente textual e não fornece um atrativo visual de modelagem como verificado em outros formalismos como Redes de Petri Coloridas ou SAN, por exemplo.
Esse fato, entre outros, instigou a definição do formalismo das PEPA nets, discutido a seguir.
Com o objetivo de se criar um formalismo com representações gráficas e outros recursos, foram definidas as PEPA nets em 2001.
PEPA nets é uma combinação entre Redes de Petri Coloridas e PEPA.
Os modelos são construídos como redes possuindo lugares que contém tanto componentes PEPA estáticos quanto móveis (melhor explicados a seguir).
Este formalismo combina a composicionalidade de PEPA com a notação gráfica das Redes de Petri.
PEPA nets oferecem mais expressividade para os modeladores, mas deve ser vista como complementar à PEPA, pois alguns comportamentos são melhor definidos num formalismo ou em outro.
PEPA nets foi desenhada para capturar sistemas que possuam dois tipos distintos de mudança de estados, em particular, sistemas computacionais onde verifica- se a existência de mobilidade (sejam componentes que alteram sua posição num plano ou entidades que deslocam- se de maneiras diferentes).
Esse tipo de modelagem é a principal motivação para definição de PEPA nets.
Para atingir esse objetivo, foi descrita uma combinação de formalismos com componentes PEPA representando as transições locais e os disparos das Redes de Petri capturando as reconfigurações globais do sistema (a mobilidade).
PEPA nets são Redes de Petri Coloridas onde as cores das marcas são componentes PEPA.
Cada lugar da CPN é um contexto de PEPA o qual pode conter componentes estáticos e conjuntos de cooperação restringindo a movimentação das marcas dentro de os lugares.
As marcas podem se mover para um determinado lugar apenas se existe espaço para um componente do seu próprio tipo, ou seja, o estado não possui nenhuma marca até o momento da movimentação (utiliza- se o símbolo para esse propósito).
PEPA nets são modelagens PEPA com maior dimensionalidade, ou seja, associam cores (na forma de componentes PEPA) a cada estado do sistema.
As formas de realizar a conversão de uma PEPA net para PEPA foram pesquisadas em, o qual demonstra as regras a serem seguidas para efetuar a traduação de forma consistente.
Existem dois tipos de mudança de estados numa PEPA net, que podem ser vistas como mudanças microscópicas ou macroscópicas.
As mudanças microscópicas são locais, afetando componentes dentro de os seus contextos e são representadas usando- se transições governadas por a semântica usual de PEPA.
Em contraste, as mudanças macroscópicas são globais e capturam o disparo de eventos no nível da rede.
Estes disparos fazem com que as marcas sejam transferidas de um lugar para outro.
Cada lugar, ou contexto de PEPA, contém células especificamente definidas, que só podem ser ocupadas por o tipo apropriado.
Esta definição é fortemente tipada, ou seja, uma célula ou nodo não pode ter uma marca que não seja a marca definida para esta célula.
Uma PEPA net distingue dois tipos de componentes:
Marcas e componentes estáticos.
As marcas podem se movimentar entre os lugares (assim como ocorre em PN), enquanto que os componentes estáticos não permitem movimentação na rede com alterações globais de estado, representando o ambiente dentro de aquele lugar.
Estes componentes estáticos podem ser de dois tipos:
Stateless ou stateful.
Um componente stateless não possui derivações e simplesmente oferece uma ou mais ações para interação.
Os componentes stateful em contraste, possuem um conjunto mais rico de comportamentos incluindo a possibilidade de definir derivativos ou estados.
Um exemplo simples de PEPA net pode ser verificado através do modelo MobileAgents.
Tratamse de entidades, denominadas neste contexto de agentes, que visitam diferentes lugares de uma rede.
A Figura 2.8 mostra uma visualização gráfica deste sistema.
Existem três lugares na rede chamados P1, P2 e P3, onde agentes podem se movimentar entre estes lugares de acordo com uma taxa.
As transições locais acontecem dentro de cada lugar e os movimentos nas transições da rede causam mudanças globais ao sistema, na figura representadas por os eventos go (com taxas l e r) e return (com taxas µl e µr).
A marcação inicial da rede encontra- se em P2 numa marca chamada A, representando um agente, chamado Agent conforme os derivativos do modelo descritos a seguir.
A ideia básica do modelo MobileAgents é considerar agentes que inspecionam diferentes lugares e retornam para um servidor chamado Mestre (Master) para depositar os resultados coletados.
A classificação do lugar Master é estático do tipo stateful, ou seja, pode alterar seu estado para Master1 com a atividade de depósito (dump).
Este fato provocará a criação de um autômato adicional para relacionar esta problemática para uma tradução correspondente.
A seguir, são definidos os componentes e lugares do sistema (em linguagem de PEPA nets):
Agent $= (go).
Agent1 def Agent1 $= (interrogate ri).
Agent2 def Agent3 $= (dump rd).
Agent def Master $= (dump).
Master1 def Master1 $= (analyse).
Master def Probe $= (monitor rm).
Probe+ (interrogate).
Probe def Probe P $= Agent def Master P2 $= Agent def Probe P3 $= Agent PEPA nets podem ser naturalmente utilizadas no caso de existirem componentes que precisem se movimentar numa rede ou alterar sua posição entre os lugares, comunicar com outros eventuais componentes que existam no lugar e retornar para seu lugar de origem.
Este tipo de comportamento é mais facilmente perceptível na maneira gráfica que as PEPA nets utilizam para mostrar as interações envolvidas entre as diferentes entidades de um sistema e como estas cooperam para realizar atividades.
Um outro exemplo válido são processos numa rede de computadores, ou grid, que podem ser enviados para outros lugares de execução onde alteram seus estados locais, mas também ocorre uma movimentação global na rede.
Existem situações mais adaptadas para a utilização de PEPA nets, especialmente casos onde estejam presentes comportamentos locais e sincronizações globais.
Como todo formalismo estruturado, uma PEPA net possui uma Cadeia de Markov correspondente, composta basicamente por a combinação das informações contidas na Matriz de Transição e no Grafo de Derivação, utilizando a Equação do Sistema para gerar os estados globais, assim como em PEPA.
Tanto modelos PEPA quanto modelos PEPA nets são analisados através da ferramenta computacional PEPA Workbench (pwb).
Este ambiente completo de análise oferece ferramentas para lidar com a compilação de modelos que geram tanto o Gd quanto a MT incluindo opções de agregação de estados (reduzindo o seu espaço de estados).
Este ambiente também gera arquivos para entrada em outras ferramentas de uso matemático, como Maple ou Mathematica com vistas a a solução via métodos diretos dos modelos criados.
PEPA nets já foi utilizada para modelar mobilidade, modelagem de conceitos de Engenharia de Software, Role--Playing Games e um ambiente para aplicações móveis usando UML -- Unified Modeling Language, apenas para citar algumas aplicações.
A variedade de formas de modelagem evidenciam a versatilidade do formalismo e como este pode ser utilizado para descrever sistemas complexos.
Para uma completa definição de PEPA nets sugere- se a leitura de, onde descrições detalhadas sobre o formalismo são definidas e conceitualizadas.
A seguir é apresentada uma breve discussão entre os formalismos expostos neste trabalho e uma comparação sobre as vantagens e desvantagens dos seu usos.
Discussão As Cadeias de Markov foram o primeiro formalismo diretamente aplicado à avaliação de desempenho de sistemas computacionais.
Seus conceitos podem ser aplicados a outras áreas tais como economia ou onde exista a necessidade de se descobrir probabilidades associadas a estados da realidade.
Desde a sua adoção, o problema da explosão do espaço de estados emergiu como um grave impedimento ao seu uso, fato mitigado por as definições dos formalismos estruturados para análise de sistemas complexos em termos de modelagem.
As MC demonstram uma grande aplicabilidade devido a as suas primitivas simples e facilidade do seu uso.
Entretanto, dependendo do modelo criado constata- se que é fácil definir um espaço de estados massivo e, usualmente, intratável.
A o estruturar um determinado sistema é mais fácil entender o que foi modelado para então utilizar métodos específicos de solução que tratem de tais representações estruturadas.
O objetivo é não apenas modelar sistemas mas inferir índices computacionais sobre sua operação, num tempo razoável, facilitando a tomada de decisões antes do sistema estar fisicamente disponível.
Todos os formalismos possuem em comum comportamentos locais que importam a apenas cada entidade bem como comportamentos sincronizantes onde está presente a necessidade de trabalharem cooperativamente.
Estes tipos de interações são adaptáveis para problemas distribuídos e paralelos de diversas aplicações.
A escolha de um formalismo para avaliar um sistema implica em decidir as vantagens e desvantagens observando- se a composicionalidade, a localidade, o sincronismo, a evolução, a interação, a abstração e a percepção visual (sistemas com representações gráficas).
Cada formalismo propõe um conjunto de ferramentas e diferentes metodologias para tratar da modelagem e solução de sistemas.
Pesquisas atuais centram seus esforços no aumento do poder de representação dos sistemas para lidar com novas primitivas de modelagem.
Outro importante foco de atenção é direcionado ao aperfeiçoamento dos mecanismos de análise e simulação oferecidos aos usuários.
Estas análises permitem que sejam descobertos os fatores mais importantes que melhoram ou degradam o desempenho de sistemas, fornecendo informações adicionais para ajudar os modeladores a decidir sobre as melhores condições para uma operação otimizada com um uso racional dos recursos.
Estas melhorias são direcionadas à concepção de novas primitivas de modelagem de sistemas, aumentando a oferta de diferentes possibilidades de mapear as realidades para modelos analíticos.
Mais especificamente, ao se comparar dois formalismos tais como SAN e PEPA nets, observa- se o compartilhamento de similaridades.
Uma constatação inicial, por exemplo, é que ambos descrevem sistemas através de representações gráficas e, no caso de PEPA nets, são baseadas em formalismos clássicos (Redes de Petri Coloridas) facilitando o entendimento.
O mesmo acontece para o caso das Redes de Petri e Redes de Petri Coloridas.
Esses recursos visuais auxiliam e simplificam a análise e inspeção de modelos.
Uma vantagem de PEPA e PEPA nets sobre SAN diz respeito ao produto do espaço de estados (a combinação de todos os estados).
Em SAN, pode- se ter que trabalhar com um espaço de estados atingível muito menor que o espaço de estados produto necessário para a solução do modelo.
Em contraposição, em PEPA, apenas os estados atingíveis são considerados.
Entretanto, em termos de solução, SAN, por trabalhar com descritores Markovianos, emprega melhor os recursos disponíveis, principalmente os de memória, para calcular o vetor de probabilidades.
Em PEPA, precisa- se incorporar a MT com as taxas dos eventos numa ferramenta computacional com recursos matemáticos, como por exemplo, o Maple ou Mathematica.
Dependendo do tamanho do modelo são necessários muitos recursos em termos de memória e processamento para que uma solução seja obtida.
Dadas as opções de formalismos Markovianos verifica- se que existem diversas formas de representar e descrever sistemas com diferentes primitivas e abstrações.
Cada formalismo captura aspectos particulares de realidades incorporando variadas análises.
Alguns formalismos oferecem opções sofisticadas para representar a interação entre os componentes enquanto que outros se preocupam com facilidades de prover as abstrações.
É comum adaptar ideias de diferentes formalismos e combinar- las entre si, ampliando as definições com o intuito de aumentar as funcionalidades ofertadas.
O próximo capítulo trata sobre abstrações de modelagem que podem ser usadas para decompor sistemas e sobre correspondência entre formalismos estruturados de solução.
Aborda- se também um estudo de caso de mapeamento entre formalismos para obtenção de um descritor Markoviano.
Este capítulo trata de formas mais gerais para mapeamento de realidades, regras de descrição, correspondência entre formalismos estruturados e as dificuldades existentes nestas conversões.
A Seção 3.1 introduz o assunto para, na Seção 3.2, descrever as definições de base.
A Seção 3.3 demonstra as correspondências entre alguns formalismos da literatura para na Seção 3.4, apresentar um estudo de caso para conversão de modelos PEPA nets em SAN.
A Seção 3.5 descreve as primitivas de comunicação e interação entre os formalismos com um exemplo, conforme é mostrado na Seção 3.6.
O capítulo é finalizado com uma discussão sobre as traduções entre as formas de representação de sistemas através de formalismos para análise de desempenho, na Seção 3.7.
Introdução Os formalismos estruturados existentes para mapeamento de realidades definem seus próprios conjuntos de primitivas de modelagem.
A principal característica que os distingue é o grau de abstração disponível e o funcionamento do seu mapeamento em alto nível para uma descrição mais formal e não ambígua.
Antes de prosseguir com a discussão de modelos mais abstratos para tratar com formalismos estruturados é necessário realizar a distinção entre uma Cadeia de Markov e um Processo Markoviano.
A forma usual de separar estes conceitos é através da observação da escala de tempo adotada.
Enquanto que a primeira é uma definição em escala de tempo discreto, os Processos Markovianos tratam apenas de escala de tempo contínuo.
Um Processo Markoviano se refere a um modelo matemático de um sistema dotado da propriedade Markoviana, ou seja, um sistema onde a propensão para se estar num estado futuro depende somente das informações contidas no estado atual, sem precisar nenhuma outra informação sobre o histórico do passado.
Como mencionado na Seção 2.2, esta propriedade é central para o estudo deste formalismo e é referenciada na literatura através de memoryless property.
Entretanto, apesar de a existência das duas escalas terem sido definidas originalmente, a maneira mais usual de se trabalhar com processos estocásticos para análise quantitativa de sistemas é definir um Processo Markoviano, em alguns casos mais natural que trabalhar com escala discreta e consequentemente com Cadeias de Markov (este tópico será mais discutido a seguir, na Seção 3.2).
Conforme mencionado no Capítulo 2, o objetivo é analisar a estacionariedade de modelos observando o comportamento dos sistemas em longas trajetórias, como se fosse` simulado' até atingir um estágio onde não mais importa seu estado inicial.
A o atingir um regime estacionário, o sistema produz probabilidades no regime estacionário que atestam valores quantitativos para serem analisados por os modeladores, os quais interpretam os dados para extração de índices de desempenho.
O que se observa mais frequentemente é o uso de ambas nomenclaturas, ou seja, tanto Processos Markovianos quanto Cadeias de Markov para querer referenciar sistemas com um total de estados enumerável e finito possuidor de transições.
Em o contexto desta tese, particularmente na Seção 2.2, escolheu- se descrever Cadeias de Markov e introduzir os conceitos relativos a Processos Markovianos neste capítulo, já que existe tal distinção entre ambos.
Uma forma mais abstrata de se estudar Processos Markovianos com estruturação está baseada no conceito de como as partes ou subsistemas se relacionam, ou seja, como sincronizam atividades e desempenham papéis independentes.
Este conceito, ao considerar- se os módulos como um todo, também pode ser visto como se cada parte fosse um processo e estes interagem através de comunicações ou troca de mensagens de forma sincronizada.
Tais processos foram denominados Processos Markovianos com Comunicação (PMC).
A definição de PMC para avaliação de desempenho não é nova, sendo já utilizada por outros autores em outros contextos, até mesmo em outros formalismos[ DON94, HIL96, KEM96].
Esta classe de processos é estudada há bastante tempo mas só recentemente teve sua utilização realçada por o problema da explosão do espaço de estados e complexidade das operações tensoriais envolvidas.
Outro importante fator que impulsionou a pesquisa em PMC foi a definição de múltiplos formalismos estruturados de modelagem e a percepção de diversas características em comum entre estes.
Exemplos de formalismos com propriedades em comum, destacam- se as Redes de Filas de Espera, Redes de Autômatos Estocásticos, Redes de Petri Estocásticas e Álgebras de Processos, todos definindo e trabalhando com descritores Markovianos para representação implícita da matriz de transição da Cadeia de Markov correspondente.
Conceitos preliminares A descrição de um sistema através de Processos Markovianos com Comunicação é uma maneira versátil de modelagem de realidades com transições complexas e com grande número de sincronizações entre suas entidades.
A solução eficiente desta classe de processos aplicada às transições generalizadas (componentes que realizam transições em função de os estados de outros componentes), ainda é um problema em aberto, alvo de pesquisas que apontem maneiras de se tratar com tais estruturas de forma eficaz.
Esta seção discutirá as principais formas de definição de PMC e calcular as probabilidades estacionárias ou transientes e suas implicações na memória necessária e seus efeitos no descritor Markoviano correspondente.
A ideia de se utilizar PMC para descrição de modelos é pensar que um sistema é composto por um conjunto de componentes com uma organização interna e verificar como estes componentes (ou módulos) interagem entre si, ou seja, onde existe pelo menos uma comunicação para sincronização de atividades.
Este conceito de comunicação está presente em MC, pois pode- se pensar que os estados com transições definidas estão em processo de comunicação.
A motivação para o uso de PMC está centrada no fato de que é mais fácil entender um sistema abstraindo os detalhes menos importantes e pensar na sua semântica operacional como um todo.
Depois desta descrição composicional (onde descrevem- se os componentes) do sistema, parte- se para o próximo estágio, que é determinar computacionalmente a existência ou não de estacionariedade e estabelecer a fase de análise e refinamento do modelo para refletir a realidade.
A própria ideia de se decompor um sistema em partes menores para serem melhor entendidas foi estudada no contexto da Engenharia de Software na década de 70, usando o conceito de` módulos'.
Dando seguimento a estes conceitos pode- se inferir sua utilização no contexto de avaliação quantitativa de desempenho de sistemas, tal como o formalismo de PEPA.
A definição original de PEPA estabelece que cada componente sequencial do modelo é visto como um` autômato', ou seja, estes relacionamentos estão presentes nas definições originais de alguns formalismos estruturados.
Estes conceitos implicam na necessidade da área de avaliação de desempenho de definir formatos intercambiáveis pois, na verdade, a maioria dos formalismos possui primitivas em comum.
É nesse cenário que são introduzidos os Processos Markovianos com Comunicação, responsáveis por a definição dos componentes existentes e de suas sincronizações de transições.
O uso de mecanismos estruturados potencializa a descoberta de propriedades da Cadeia de Markov correspondente.
A o compartimentalizar os elementos do sistema, abre- se a possibilidade de se descobrir partições mais facilmente, utilizadas para efeitos de agregação e redução do modelo.
Esta composição do sistema promove, também, um maior entendimento do sistema, pois divide o problema em partes mais gerenciáveis e menos suscetíveis a erros.
Outro importante fato que contribui para a disseminação de PMC é a aplicação de técnicas do tipo divisão-e-conquista para atacar um problema.
Tais métodos são utilizados para a detecção de gargalos e características indesejadas em sistemas usualmente com grandes espaços de estados e possuidores de transições complexas.
A seguir, na próxima seção, serão mostrados exemplos de correspondência entre os formalismos estruturados e PMC bem como um estudo de caso compreendendo a transformação de uma PEPA net (explicado anteriormente na Seção 2.5.2) numa SAN (conforme a Seção 2.4), mostrando a sua correspondência.
Correspondência entre formalismos Estabelece- se que uma correspondência entre os formalismos existe ao ser obtida a mesma ma triz de transição da Cadeia de Markov subjacente.
O vetor solução calculado para um determinado modelo é idêntico ao da solução do mesmo modelo num formalismo estruturado e na MC, dada a existência da correspondência.
Como explicado anteriormente, uma das principais motivações para o uso de PMC (e as SAN são uma classe deste tipo de formalismo) deve- se ao fato de nunca ser necessário armazenar a matriz de transição da MC correspondente mas acessar a estrutura através da utilização de propriedades da Álgebra Tensorial, onde são compilados os descritores Markovianos.
Toda a fundamentação teórica envolvida para PMC envolve a definição de tais descritores, bem como as formas de se multiplicar o vetor de probabilidades por essa estrutura, para então usar um método iterativo de solução.
A utilização de descritores tensoriais mitiga o problema de armazenamento relacionado à explosão do espaço de estados associado às Cadeias de Markov.
Portanto, os formalismos estruturados de solução podem ser classificados como Processos Markovianos com Comunicação.
No caso de SAN, a principal unidade criada é um autômato, em PEPA é um processo e nas SGSPN é um módulo.
PMC é então utilizado para definir como estas unidades se comunicam, através da definição das transições existentes e suas taxas.
Uma extensão das PMC são os chamados Processos Markovianos com Comunicação Generalizados (PMCG) que definem o funcionamento das transições no sistema através da utilização de taxas funcionais (usando preceitos da Álgebra Tensorial Generalizada).
A seguir, estuda- se um modelo baseado numa Rede de Filas de Espera Aberta a ser transposto para uma Rede de Autômatos Estocásticos, uma Rede de Petri Estocástica e para um modelo em Álgebra de Processos (escrito no formalismo de PEPA), conforme a Figura 3.1.
O objetivo é o de demonstrar a correspondência entre alguns exemplos de diferentes formalismos estruturados.
Em este exemplo, observa- se uma rede composta por três filas definidas por Q1ou seja, encontram- se na sua capacidade máxima), os clientes ou são bloqueados ou são perdidos, dependendo do caso.
O exemplo da Figura 3.1 apresenta graficamente as três filas, a taxa de chegada de clientes, as taxas de saída da primeira fila para a segunda e para a terceira, definidas por µ12 e µ13 respectivamente e as de saída de clientes dadas por µ2 e µ3.
A figura mostra uma fila com comportamento bloqueante para a fila Q2) e outra fila com comportamento de perda para a fila Q3).
Este modelo estruturado de filas pode ser visto, por exemplo, como uma Rede de Autômatos, uma Rede de Petri ou descrições em Álgebra de Processos.
A seguir, discute- se este exemplo definido nestes formalismos citados, começando por Redes de Autômatos Estocásticos.
A Figura 3.2 mostra uma tradução possível da Rede de Filas de Espera da Figura 3.1 para SAN.
A Figura 3.3 mostra a mesma conversão para uma Rede de Petri Estocástica (inspirada na existente em).
Cada fila i corresponde a um par de lugares Qi) e Ai).
O lugar Ai) representa a disponibilidade dos clientes na fila Qi), ou seja, sua capacidade, e o lugar Qi) representa os clientes correntes da fila i.
A transição l1 representa uma chegada de cliente na fila Q1).
Já as transições t2 e t3 representam, respectivamente, saídas de clientes das filas Q2) e Q3) com taxas iguais a µ2 e µ3.
A transição sincronizante t12 representa o roteamento de clientes da fila Q1) para Q2).
De forma análoga, a transição t13 corresponde ao roteamento da fila Q1) para Q3).
A transição tl13 simboliza a perda de clientes de Q1) para Q3) (representado na SAN da Figura 3.2 por o disparo do evento e13 no autômato A1) e auto-transição no último estado do autômato A3).
Esta transição só é disparada caso a fila Q3) esteja cheia (conforme a condição de guarda que verifica se o total de marcas é igual à capacidade da fila).
Por fim, converte- se a Rede de Fila Aberta deste exemplo para o seu correspondente em PEPA.
A Figura 3.4 mostra a tradução através da construção de três processos, simbolizando as três filas do exemplo.
Os derivativos dos processos assumem a nomenclatura dada segundo a forma QNC onde N corresponde ao identificador da fila e C à quantidade de clientes na fila.
Os processos ditam as transições e as atividades do sistema como um todo.
Em este modelo PEPA a Equação do Sistema é definida por S e identifica as comunicações existentes entre os processos e o estado inicial.
Entre a Fila Q2 e a Q1 existe uma sincronização dada por a ação e2 enquanto que por a Fila Q1 e Q3, a sincronização é realizada por a atividade e3.
Cabe ressaltar que os modelos previamente traduzidos possuem solução correspondente, ou seja, produzem a mesma matriz para ser usada no cálculo dos índices através de métodos diretos ou iterativos de solução de sistemas, conforme explicado na Seção 2.2.
Apesar de existirem diferentes formas de visualizar e definir o problema, modelos de diferentes formalismos podem vir a produzir a mesma matriz subjacente, ou seja, existem características em comum para as classes de problemas.
Estas propriedades em comum são tratadas por os PMC, que auxiliam os usuários na definição e solução deste formalismo.
A seguir é mostrado um estudo de caso de transcrição do formalismo de PEPA nets para um descritor Markoviano baseado no formalismo de SAN.
Estudo de caso:
Tradução de PEPA nets para descritor Mecanismos de tradução entre formalismos são alternativas válidas para permitir que modelos sejam visualizados e resolvidos de diferentes maneiras.
Em este sentido, a dificuldade de se realizar um mapeamento consistente e representativo deve- se ao fato de que cada formalização apresenta um conjunto de primitivas específico, normalmente difícil de ser mapeado.
A seguir será mostrada uma tradução entre dois formalismos bastante usuais de modelagem, que são as PEPA nets (maiores informações na Seção 2.5.2) e as SAN (conforme Seção 2.4), um formalismo que gera um formato tensorial através da criação do descritor Markoviano.
Dado que as PEPA nets podem ser vistas como uma rede onde as marcas são componentes PEPA, as traduções a seguir podem ser aplicadas diretamente ao mapeamento de modelos PEPA, sem perda de generalidade.
A seguir será mostrado como realizar um mapeamento válido entre os formalismos indicados através do uso do Grafo de Derivação (Gd) e da Matriz de Transição (MT) gerada por o compilador de PEPA nets.
O objetivo deste estudo de caso é apresentar as regras de tradução que convertem um modelo descrito em PEPA nets para uma SAN de forma direta, sem precisar convertes- lo para uma representação intermediária baseada em PEPA.
A partir de as informações contidas tanto no Gd quanto no MT será possível criar transições com eventos associados de acordo com seu tipo (local ou sincronizante).
Os resultados apresentados demonstram um mapeamento válido, mostrando uma correspondência entre as matrizes de transição de ambos os formalismos.
Uma tradução válida entre PEPA nets (Seção 2.5.2) e PEPA foi proposta para facilitar e acessar o conjunto de ferramentas disponíveis para álgebras de processos.
Contudo, ao converter uma PEPA net para uma SAN observa- se que um dos objetivos é o mesmo, que é o de utilizar o software de solução e as técnicas (no caso as ferramentas já existentes para tratar com descritores deste tipo) disponíveis em ferramentas implementadas para este fim, tais como o PEPS ou o GTAexpress.
Um outro objetivo é o de obter uma representação tensorial para PEPA, já que este formalismo trabalha apenas com a matriz de transição.
Em o trabalho que mais se aproxima deste objetivo, os autores realizaram um estudo sobre como relacionar PEPA e SAN de forma conjunta, analisando as vantagens e desvangens deste mapeamento inclusive quando taxas funcionais (e, consequentemente, ATG) são usadas.
Outras traduções entre formalismos foram observadas anteriormente, tais como representação de PEPA para SPN ou através do uso do Compilador Imperial para PEPA (ipc, ou The Imperial PEPA Compiler).
Um outro trabalho importante que tratou sobre o mapeamento para descritor foi estudado em que estabeleceu os fundamentos de base necessários para representar modelos Ambos formalismos considerados nesta seção são visualmente atraentes e mostram as relações de causa e efeito de forma simples.
Esta forma permite que sejam criados mecanismos que convertem as regras semânticas e da álgebra de processo das PEPA nets para determinar como as entidades colaboram entre si num formato tensorial similar ao das SAN.
A o utilizar as informações contidas na MT e no Gd, percebe- se as ocorrências das taxas no nível da MC e como está ocorrendo a evolução de um estado para o próximo.
Estes dados são compilados por a ferramenta PEPA Workbench (pwb) restando apenas discernir as informações mais relevantes contidas nos arquivos produzidos, desta forma simplificando o mapeamento.
Devem ser guardados os rótulos das transições e os nomes e taxas dos eventos que foram previamente utilizados por o modelador, para facilitar o entendimento do modelo convertido.
A definição formal de PEPA nets considera a interação entre os processos existentes e como as entidades colaboram, entretanto, a pwb não faz distinção entre eventos locais ou sincronizantes e este dado é necessário para a construção de SAN.
A o inspecionar o Gd e a MT de uma PEPA net, reconhece- se quatro classes distintas de eventos:
Ações Individuais Individual Actions ou Ia):
Corresponde a uma mudança dentro de um lugar, significando que um componente PEPA trocou de estados de forma individual e é traduzido sob a forma de descritor para um evento local simples (LOC).
Ações individuais relacionam- se a marcas e a componentes estáticos do tipo stateful (definição na Seção 2.5.2);
Movimentação de Marca Token Movement ou TK):
Duas marcas se movem em lugares diferentes, causando duas mudanças de estado em dois autômatos diferentes.
Utiliza- se a notação presente em SAN para eventos sincronizante (SYN);
Ações de Cooperação Cooperation Action ou Ca):
O mesmo que TK, exceto que uma mudança também promove uma outra mudança no estado de um componentes estático do tipo stateful;
Ações de Cooperação Múltiplas Multi--Cooperation Action ou MCA):
Este tipo de evento é um caso particular no contexto de PEPA.
Um único evento é responsável por a mudança de estado de diversos autômatos.
A tradução é um evento sincronizante que opera sobre múltiplas entidades, alterando o estado global do sistema, igualmente chamado de sincronização do tipo multi-way na literatura de autômatos e álgebras de processos.
A o conhecer as classes de eventos possíveis, as informações da MT e Gd, calcula- se a quantidade de autômatos e o produto do espaço de estados necessário dada a existência de um modelo PEPA net com P lugares e C componentes.
Cada lugar será transformado num autômato, caso exista componentes estáticos do tipo stateful, será necessário um autômato para cada lugar definido, correspondendo a A $= P+ C × autômatos, onde f corresponde ao tipo de componente.
O conjunto de derivações possíveis com sincronizações nos lugares de cada componente ditarão o número de estados dos autômatos.
Se o componente é estático e stateless, será necessário definir um estado adicional para representar uma célula vazia (e.
g na PEPA net), diferentemente do procedimento a ser adotado para componentes estáticos do tipo stateful, onde não existem células vazias, apenas transições.
O cálculo final do PSS é o produto dos estados de todos os autômatos que foram traduzidos do modelo PEPA ou PEPA net.
Cada classe de evento descrita na Tabela 3.1 irá afetar a maneira de se construir a especificação final dos autômatos do modelo.
Para eventos locais é direto:
O rótulo para o evento é salvo e a transição é criada.
Para eventos sincronizantes é necessário descobrir todos os autômatos envolvidos no sincronismo e verificar se já não existe um evento definido previamente que realiza a mesma tarefa.
Caso não exista, o evento sincronizante é criado, observando o rótulo definido por o modelador.
O método de tradução é apresentado no Algoritmo 3.1, de acordo com três fases distintas:
Para a operação do algoritmo são necessárias as informações do Gd, da MT e duas listas auxiliares, uma contendo os lugares para cada transição gi Gd e outra para as mudanças entre os Algoritmo 3.1: Tradução de PEPA nets para SAN.
Tm Matriz de Transição DG Grafo de Derivação P Lista de Lugares para todas as transições t DG C Lista de Componentes para todas as transições t DG Automata CreateEmptyAutomatonSetP C) for all qij Tm e qij\&gt; 0) do evt GetEventqij) pc1 pc2) descobre mudanças de lugares em Pi Pj cc1) descobre mudanças de componentes em Ci Cj class DiscoverClasspc12 cc12) tf rom tto) DiscoverT ransitionpc1) AddLocaltf rom Automata evt) tf rom1 tto1) DiscoverT ransitionpc1) tf rom2 tto2) DiscoverT ransitionpc2) AddSynchtf rom1 Automata evt) AddSynchtf rom2 Automata evt) tf rom1 tto1) DiscoverT ransitionpc1) tf rom2 tto2) DiscoverT ransitioncc1) AddSynchtf rom1 Automata evt) AddSynchtf rom2 Automata evt) AddM ultiW Automata evt) classe não antecipada erro AddEventEL evt) for all gi DG) do AddIntegrationF unctionINTF Automata gi) usar El para preencher seção SAN de identifiers e seção de events usar marcação inicial PEPA na seção SAN de partial reachability usar Automata para criar seção SAN de network usar INTF para listar seção SAN de results componentes.&amp;&amp;&amp;
Ainda no início, é chamada uma função denominada CreateEmptyAutomatonSet que descobre as mudanças de componentes existentes e cria o conjunto de autômatos sem nenhuma transição ou evento.
Após descobrir os autômatos necessários, passa por a MT descobrindo todas as transições que foram efetuadas, organizando- as conforme vai operando sobre o total de linhas existentes.
Para descobrir os eventos é usada uma função chamada GetEvent que retorna o nome do evento utilizado para o mapeamento dos rótulos.
As linhas 10 e 11 do algoritmo manipulam duas transições (de Pi para Pj e de Ci para Cj) e, para cada caso, são analisadas e retornam os índices das marcas que alteraram suas posições e para o caso de componentes, os índices dos componentes que mudaram.
A função DiscoverClass usa de erro é instaurada.
Esta ocorrência é plenamente possível pois o usuário da ferramenta pwb (PEPA Workbench) pode estar usando opções de agregação (aggregate).
A seguir, em cada caso, são chamadas funções específicas, tais como DiscoverT ransition, AddLocal e AddSynch que utilizam a informação do Gd para retornar os rótulos para as transições para que os autômatos sejam criados com o mesmo nome utilizado na modelagem da PEPA net.
As funções acrescentam eventos locais e sincronizantes entre os autômatos envolvidos, detectando se cada transição é nova (apenas acrescenta as transições que ainda não estão definidas).
O final do algoritmo é marcado por funções que verificam a rede de autômatos criada, de acordo com a função correspondente entre os formalismos é criada e pode ser usada em ferramentas de compilação e solução de descritores Markovianos existentes.
A seguir é mostrado um exemplo de conversão de uma PEPA net para uma SAN.
Esta seção apresenta dois modelos PEPA net:
MobileAgents e ClassifiedAgents.
Todos os eventos estão sendo criados de acordo com o nome utilizado por o modelador sendo necessário, algumas vezes, alterar o nome internamente para refletir o fato que o um novo evento é necessário dentro de o modelo SAN (melhor explicado a partir de as figuras utilizadas nos exemplos de tradução).
O modelo MobileAgents foi explicado juntamente com o formalismo das PEPA nets e está descrito na Seção 2.5.2.
A Figura 3.5 mostra a estrutura do modelo MobileAgents e seu correspondente modelo descrito em SAN.
A o comparar os modelos percebe- se que ambos fornecem auxílios visuais para percepção dos relacionamentos e as atividades desempenhadas por cada elemento do modelo.
A única diferença é a forma com que ambos são resolvidos computacionalmente.
Em SAN, o modelo gera um descritor Markoviano e é resolvido através das formas usuais de MVD existentes enquanto que o modelo PEPA net necessita executar uma ferramenta de solução matemática como Matematica, Maple ou Octave, que podem ser utilizadas para este propósito.
O próximo exemplo considerado é baseado no anterior e chama- se ClassifiedAgents.
Este modelo possui três lugares e duas classificações para agentes:
AgentA7 and AgentA8.
O sistema representa agentes do tipo AgentA7 que podem baixar (download) ou salvar (save) informações e ainda se comportarem como AgentB7, conforme mostrado a seguir.
AgentA7 $= download r1 select) informações.
O lugar chamado MI5 é responsável por processar informações.
A figura também mostra a tradução para SAN com todos estados, eventos e transições que foram criadas bem como seus tipos correspondentes.
Os em diferentes autômatos e suas ocorrências fazem com que agregações semânticas sejam difíceis de serem aplicadas, pois sincronizam os autômatos sempre de dois em dois, simbolizando que o lugar ficou vago ou foi ocupado por outra marca (no caso, agente).
O nome escolhido para cada autômato reflete o número de componentes em cada lugar.
O lugar Remote possui dois componentes do tipo AgentA7 enquanto que Socket possui três:
Dois do tipo AgentA7 e um do tipo AgentA8.
O lugar MI5 possui apenas um agente do tipo AgentA8, fazendo com que cada autômato seja chamado de P 11, P 21, P 22, P 23 e P 31, respectivamente.
A tradução realizada transforma cada lugar num autômato representando os aspectos comportamentais dos componentes envolvidos bem como a movimentação das marcas dentro de a rede.
Os autômatos precisam guardar a informação que um lugar não possui nenhuma marca num estado chamado.
As marcas trocam de lugares de forma sincronizada através do evento move, que sincroniza a saída de um lugar com a chegada em outro lugar.
As transições locais são representadas no autômato de forma similar à modelada em PEPA nets, através de diferentes eventos (save, select, download ou process).
Uma vantagem de se traduzir de PEPA nets para SAN, ou para qualquer formato que descreve um descritor Markoviano, é não precisar armazenar a matriz de transição.
A tradução efetuada nesta seção gerou a mesma matriz correspondente sem perder informações tanto visuais quanto qualitativas (quanto a os nomes de eventos e lugares).
Os exemplos mostrados permitiram constatar que alguns eventos encontram- se entrelaçados, ou seja, disparam a movimentação das marcas de forma sincronizada simbolizando a desocupação de um lugar e a movimentação para um outro lugar na rede.
Dando seguimento à tradução, uma tarefa que pode ser realizada é aplicar formas de reduzir os estados locais, transições ou eventos de forma que permaneçam representando o mesmo comportamento e possibilitando análises quantitativas em menos tempo.
O objetivo neste contexto foi o de demonstrar através de exemplos a existência de representações correspondentes entre formalismos, apresentando um estudo de caso onde modelagens em PEPA nets são traduzidas para SAN sem perda de informação.
Com estes conhecimentos é possível dar continuidade ao capítulo discutindo meios mais alto-nível (mais abstratos) para comunicação e interação de subsistemas.
A Tabela 3.2 explica os principais elementos de decomposição dos formalismos de solução.
Percebe- se, por a tabela, a existência de elementos em comum, que desempenham as mesmas funções quando um descritor Markoviano é definido.
Se em SAN tem- se transições com eventos locais ou sincronizantes, em PEPA tem- se processos, ações locais e cooperação, e assim por diante.
Em o nível da definição do descritor, todas as matrizes que representam estas comunicações são correspondentes e realizam as mesmas atividades neste contexto.
Sem perda de generalidade, consideram- se apenas estados, transições e eventos em PMC.
Um componente possui uma lista enumerável de estados, chamados também de estados locais.
Quando observa- se a totalidade dos componentes num sistema e combina- se todos os estados entre si, gera- se o Produto do Espaço de Estados, definindo seus estados globais.
Supondo que todos, ou uma grande maioria, dos estados são atingíveis (sem considerar os estados inatingíveis que podem ser potencialmente produzidos no produto dos estados locais) e que a MC correspondente é ergódica (com estados finitos, aperiódica e irredutível), uma transição pode ocorrer de acordo com um ou mais eventos que pode ter taxa constante ou apresentar uma taxa de ocorrência ou frequência.
Esta classificação é importante para uma maior compreensão das características de PMC, onde observa- se as similaridades existentes com outros formalismos estruturados, em particular Redes de Autômatos Estocásticos, Álgebras de Processos e Redes de Petri Estocásticas.
A Figura 3.7 mostra uma representação gráfica de PMC.
O objetivo é determinar o descritor Markoviano correspondente a ser multiplicado por o vetor de probabilidades através das informações contidas nos componentes e transições do modelo.
O que potencializa o uso de PMC para a descrição de sistemas é o fato de possuir simples primitivas de descrição e outros recursos de modelagem tais como taxas funcionais e sincronizações.
Qualquer formalismo estruturado que gere um descritor Markoviano é suscetível de ser tratado com as opções de solução existentes de PMC, por exemplo, usando- se o Algoritmo Shuffle ou Split (maiores detalhes no Capítulo 4).
Esta seção apresentou um formalismo estruturado que agrega definições de outros formalismos de descrição presentes na literatura, auxiliando o processo de solução de modelagens de sistemas.
Seu ponto forte reside na modularização dos componentes, mapeando os comportamentos independentes e de sincronização de atividades.
A abstração do sistema em modelos deste tipo facilita a compreensão das operações que o sistema desempenha e permite análises de grande porte, uma vez que são utilizados mecanismos otimizados de MVD.
Para o caso de uma modelagem abstrata deste problema, considera- se cada parte do sistema como sendo um módulo, em última análise possuidor de um conjunto de classes associadas e, consequentemente, métodos associados e potencialmente instâncias de outros objetos auxiliares.
O fato importante é que existem comportamentos locais e globais neste sistema, sendo plenamente adaptável para a modelagem proposta por este capítulo.
Considera- se que o sistema possui quatro módulos, denominados Entrada, Calcula, Relatório e Publica, melhor explicados a seguir:
Este problema abstrai a parametrização, ou seja, assume que as frequências de comunicação entre os blocos estão sendo capturadas em outra parte, mas serão eventualmente usadas para compor as taxas do sistema.
Cada bloco deste software pode ser representado como um módulo, que desempenha atividades internas e que, às vezes, comunica requisições ou informa processamentos aos outros módulos.
Nota- se que os módulos possuem uma interdependência, ou seja, necessitam de informações presentes em outros módulos.
Este comportamento pode ser representado através da utilização de eventos sincronizantes e a parte que dita que o módulo desempenha atitudes independentes pode ser representada através de eventos locais simples, observando ou não o estado de outros módulos.
Este exemplo de sistema mostrou a utilização de abstração ao modelar o sistema em questão bem como foi usado para extração de índices que atestam a quantidade de comunicação existente entre os blocos do software.
Nota- se a importância de se descrever um problema utilizando- se o mínimo de propriedades e características para permitir um maior controle quando este for representado através de uma descrição de alto nível.
O sistema avaliado pode ser descrito através de uma linguagem que construirá um descritor Markoviano contendo o conjunto de informações quantitativas demonstrando o nível de comunicação entre os blocos.
Esta informação pode ser utilizada para reduzir a quantidade de comunicação entre os blocos do software significando menos defeitos e maior produtividade por parte de os programadores do sistema (uma possível interpretação).
Uma outra vantagem de se quantificar estas informações é permitir um maior reuso dos componentes de software que fazem parte de um sistema maior, promovendo um menor custo do projeto como um todo.
Discussão O uso de Álgebra Tensorial Clássica (ATC) ou Generalizada (ATG) potencializou que outros formalismos estruturados fossem definidos com a vantagem de não ser preciso gerar a matriz de transições e sim acessar- la implicitamente através da utilização das propriedades definidas por as álgebras.
Observa- se, cada vez mais, a necessidade de se centralizar os conceitos que usam tais álgebras para extração de índices de desempenho.
É através dos Processos Markovianos com Comunicação (PMC) que as principais definições serão concentradas e melhor formalizadas, especificando os próximos passos necessários para serem pesquisados.
Tais processos auxiliam na abstração de realidades, onde os detalhes são mapeados para componentes indivisíveis que operam de forma independente ou comunicando suas trocas de estados com outros componentes do mesmo sistema.
Trata- se de uma proposta mais geral de definição e concepção de sistemas Markovianos com vistas a a análise de desempenho e descoberta de propriedades quantitativas.
O presente capítulo discutiu formas de maior abstração ao se compor sistemas de forma estruturada e utilizou os conceitos de Processos Markovianos com Comunicação para este propósito.
Esta visão composicional de descrição de sistemas com primitivas simples de comunicação é observada em múltiplos formalismos estruturados com representação correspondente de descritor Markoviano.
Tais processos auxiliam na abstração para decomposição de sistemas para inferência de índices de desempenho.
A sua contribuição está baseada no fato que possibilita que conceitos chave sejam observados e definidos em sistemas, agregados numa mesma definição.
A o modelar os sistemas pensando nos seus módulos (ou partições, elementos, etc), é possível capturar sua operação principal, instanciando elementos que representam o comportamento individual e em conjunção com suas outras partes.
O objetivo da representação de sistemas através de PMC é o de permitir a construção de descritores Markovianos válidos para descreverem sistemas contendo múltiplos componentes com múltiplas interações e comunicações.
O próximo capítulo trata da solução de tais descritores tanto para Álgebra Tensorial Clássica quanto Generalizada e descreve os principais algoritmos de MVD.
Este capítulo abordará a multiplicação de um vetor de probabilidade por uma estrutura mais complexa do que uma matriz esparsa, ou seja, por um descritor Markoviano.
Quando esta estrutura é multiplicada por um vetor inicial de probabilidades inúmeras vezes, o método pode ou não convergir para um vetor solução que encontra- se na estacionariedade, ou seja, um vetor que atingiu o estado de equilíbrio.
Em todos os formalismos estruturados com representação tensorial existem operações que são efetuadas para gerar implicitamente um Gerador Infinitesimal, ou matriz de transição correspondente à MC subjacente.
A seguir serão definidos os principais conceitos de Álgebra Tensorial Clássica e Generalizada nas Seções 4.1 e 4.2, bem como suas propriedades.
O capítulo continua com a definição de descritores tensoriais na Seção 4.3 e finaliza com os principais algoritmos existentes de MVD na Seção 4.4.
Álgebra Tensorial Clássica ­ ATC Para resolver estruturas tensoriais é importante definir as principais operações existentes na Álgebra Tensorial.
Em o contexto deste trabalho, as operações mais importantes são o produto tensorial e a soma tensorial, melhor explicadas a seguir.
Por exemplo, sejam as matrizes A e B definidas como:
B b B $= b21 b22 b23 a21 a22 b31 b32 b33 O produto tensorial de C $= A B é igual a:
O produto tensorial C $= A B é definido algebricamente por a atribuição do valor aij bkl ao elemento dentro de a posição (k l) do bloco (i j), i.
e1: Esta representação de elementos de uma matriz corresponde ao produto tensorial realizado sobre os elementos c que estão em ordem lexicográfica de acordo com os seus índices (ou seja, na ordem que foram originalmente definidos).
A soma tensorial utiliza um produto tensorial para ser calculada.
Sejam duas matrizes quadradas A e B, sua soma tensorial é definida como a soma dos fatores normais de cada matriz, de acordo com a seguinte fórmula:
A B $= (A InB)+ (In B) onde In e InB correspondem a matrizes identidade de dimensões iguais às das matrizes A e B respectivamente.
Logo, um fator normal é dito um produto tensorial de uma matriz por uma ou mais identidades, dependendo do número de matrizes na soma tensorial.
Por exemplo, sejam A e B matrizes definidas como:
B $= b21 b22 b23 a21 a22 b31 b32 b33 A soma tensorial definida por C $= A B é igual a:
B21 b22 0 0 0 a11 0 0 a12 b31 b32 b33 0 0 0 a21 0 0 a22 0 0 0 b11 b12 b13 0 a21 0 0 a22 0 0 b21 b22 b23 0 a21 0 0 a22 a+ b11 b12 b21 a11+ b22 0 0 0 b31 b32 b33 b13 b23 a12 a12 b31 b32 a11+ b33 a21 a21 a22+ b11 b12 b13 b21 a22+ b22 b23 b31 b32 a22+ b33 Seja ij o elemento da linha i e coluna j de uma matriz identidade.
A soma tensorial C $= A B é definida algebricamente por a atribuição do valor aij kl+ ij bkl ao elemento da posição (k l) do bloco (i j), i.
e: As propriedades da ATC de interesse são listadas a seguir.
Suas demonstrações estão descritas em.
Associatividade da soma e do produto tensorial:
Distributividade com relação a a soma convencional:
Compatibilidade com a multiplicação convencional:
Compatibilidade com a transposição de matrizes:
Compatibilidade com a inversão de matrizes (se A e B são matrizes inversíveis):
Decomposição em fatores normais:
A B $= (A InB) × (In B) Distributividade com relação a a multiplicação por a matriz identidade:
In (A × B) $= (In A) × (In B) Comutatividade dos fatores normais:
Pseudo-comutatividade (onde é uma permutação sobre o intervalo e P):
K $= 1 Ak) $= P × k $= 1 Ak) × P T Álgebra Tensorial Generalizada ­ ATG A Álgebra Tensorial Generalizada é uma extensão da Álgebra Tensorial Clássica, e tem como principal objetivo permitir a utilização de objetos que são funções discretas sobre linhas de uma matriz.
Trabalha- se nas matrizes com elementos passíveis de avaliações diferentes, ou seja, tem- se uma matriz que pode ter diferentes instâncias de acordo com uma avaliação.
A diferença fundamental da ATG com relação a a ATC é a introdução do conceito de elementos funcionais.
Entretanto, uma matriz pode ser composta de elementos constantes (pertencentes a) ou de elementos funcionais.
Um elemento funcional é uma função real dos índices de linha de uma ou mais matrizes, i.
e, o domínio dessa função é n e seu contra­domínio é.
Assim como a ATC, a ATG é definida por dois operadores matriciais:
Produto tensorial generalizado;
Soma tensorial generalizada.
A notação definida na Seção 4.1 continua sendo válida para as matrizes constantes (i.
e, matrizes sem elementos funcionais).
As matrizes com elementos funcionais, denominadas matrizes funcionais, são descritas com o uso da notação seguinte:
Sejam: Índice de linha k da matriz A;
A (B C) matriz funcional A que possui como parâmetros as matrizes B e C;
Aij (B C) elemento funcional (i j) da matriz A (B C);
A (bk C) matriz funcional A (B C) em a qual o índice de linha da matriz B já é conhecido e igual a k (essa matriz é considerada dependente da matriz C somente);
A (bk cl) matriz funcional A (B C) em a qual os índices de linha das matrizes B e C já são conhecidos e iguais a k e l respectivamente (uma vez que todos os parâmetros da matriz são conhecidos, ela é considerada uma matriz constante);
A11 (b3) b31 (a1) a11 (b3) b32 (a1) a11 (b3) b33 (a1) a21 b11 (a2) a21 (b1) b12 (a2) a21 (b1) b13 (a2) a21 (b2) b21 (a2) a21 (b2) b22 (a2) a21 (b2) b23 (a2) a12 (b3) b31 (a1) a12 (b3) b32 (a1) a12 (b3) b33 (a1) a22 b11 (a2) a22 (b1) b12 (a2) a22 (b1) b13 (a2) a22 (b2) b21 (a2) a22 (b2) b22 (a2) a22 (b2) b23 (a2) a21 (b3) b31 (a2) a21 (b3) b32 (a2) a21 (b3) b33 (a2) a22 (b3) b31 (a2) a22 (b3) b32 (a2) a22 (b3) b33 (a2) Os elementos da matriz A variam em função de os elementos da matriz B por isso a denominação A (B), ocorrendo o mesmo para a matriz B, onde seus elementos variam em função de a matriz A, atribuição do valor aij (bk) bkl (ai) ao elemento c, i.
e:&amp;&amp;&amp; A soma tensorial generalizada é definida utilizando- se o conceito de matriz identidade com o produto tensorial generalizado da Equação 4.16: Em ATG, são definidas as seguintes propriedades fundamentais:
Distributividade do produto tensorial generalizado e relação à soma convencional de matrizes:
Associatividade do produto tensorial generalizado e da soma tensorial generalizada:
Distributividade com relação a a multiplicação por a matriz identidade:
Decomposição em fatores normais I:
Decomposição em fatores normais II:
A (B) B $= A (B) InB × In B Pseudo--comutatividade:
Decomposição em produto tensorial clássico:
K $= 1 k (A) B (ak) Uma vez descritas as operações existentes em Álgebra Tensorial Clássica e Generalizada, segue- se o capítulo com uma discussão sobre os descritores Markovianos.
Descritores Markovianos Sistemas representados por Redes de Autômatos Estocásticos ou outros formalismos estruturados, permitem uma visão modular onde as interações entre os diferentes subsistemas são modeladas através de transições e eventos.
As transições conectam os estados e os eventos, por sua vez, são locais ou sincronizantes e mapeiam taxas constantes ou funcionais.
O descritor Markoviano é o~ da Cadeia de Markov quando as matrizes que capturam as transições entre Gerador Infinitesimal Q os estados são expressas no formato tensorial, de acordo com a Equação 4.27.
As operações que podem ser efetuadas (por exemplo, soma tensorial ou produto tensorial) reproduzem as interações e igualmente como os diferentes autômatos sincronizam o disparo de eventos.
I) i) Ql+ Qe+ Qe-i $= 1 eE i $= 1 número total de autômatos na rede;
Qe+ são matrizes que representam a ocorrência e o ajuste da diagonal de eventos locais;
Somas tensoriais são na verdade fatores normais (produtos tensoriais efetuados com matrizes do tipo identidade) conforme discutido nas propriedades da Álgebra Tensorial.
Com isso, simplifica- se a Equação 4.27 em termos de notação do descritor Markoviano para:
I) Qj A seguir, discute- se o efeito de cada tipo de evento num descritor Markoviano e assinalam- se as implicações em se definir um modelo com eventos locais ou sincronizantes, com taxas constantes ou funcionais.
A análise será iniciada por os eventos locais (com taxas constantes e funcionais) e depois tratará dos eventos sincronizantes.
O modelo de exemplo da Figura 4.1 possui cinco eventos locais, l0, l1, l2, l3 e l4.
Em o descritor Markoviano eles correspondem a duas matrizes (devido a a existência de dois autômatos) de dimensão três (pois ambos autômatos possuem três estados).
A Figura 4.2 mostra a matriz de transição resultante que corresponde ao Gerador Infinitesimal Q da MC.
Cabe ressaltar que esta matriz encontra- se vazia (sem indicação dos seus elementos) para efeitos de explicação do método.
A forma correta de representar- la é preenchendo- se as células com as taxas que mostram a frequência com a qual troca- se de estado na MC.
Cada linha e coluna da matriz corresponde a um estado global do modelo contido no conjunto X.
A seguir, inicia- se a análise por os eventos locais desta rede de autômatos estocásticos.
Parte local correspondente aos autômatos 1) e 2):
Ql $= Q B r2 r2 0 r3 r3 (r5+ r4) r5 r4 r6.
Segundo a Equação 4.2, A B $= (A InB)+ (In B).
É e B $= Q Seja A $= Q necessário calcular cada parte individualmente, começando por A InB:
A InB r2 r2 0 r2 0 r2 0 0 r2 0 r3 0 0 r3 0 r3 0 0 r3 0 0 r3 r3 Uma vez calculado A InB, é necessário calcular In B utilizando as propriedades da ATG para esse evento em particular, pois deve- se avaliar a função f:
In A B $= r5+ r4 como seria a taxa de ocorrência normal para o caso da f retornar verdadeiro).
Somando- se os dois termos que foram previamente calculados, tem- se que:
r5+ r4) r2 r5 r6 r2 r4 r6 r2 r5+ r4+ r2) r5 r2 r3 r4 r2 r3 r5+ r4+ r3) r5 r3 r6 r4 r3+ r6) A seguir, calculam- se os termos tensoriais correspondentes aos eventos sincronizantes (também chamados de parte positiva) e ao ajuste da diagonal dos mesmos (ou parte negativa):
Parte sincronizante positiva da ocorrência do evento s:
Qs0+ $= Q s0+ Qs0+ 0 r0 0 0 r0 Parte sincronizante negativa relativa ao ajuste diagonal do evento s:
Qs0- $= s 0-r0 0 0 0 r0 0 Parte sincronizante positiva da ocorrência do evento s1:
Qs1+ $= Q s1+ Qs1+ B 0 0 r1 Y 0 0 0 r1 Parte sincronizante negativa relativa ao ajuste diagonal do evento s1:
Qs1- $= Q s 1-Qs1-B 0 r1 0 Y 0 0 r1 0 O Gerador Infinitesimal é dado por:
A Figura 4.3 mostra o Gerador Infinitesimal produzido a partir deste exemplo de conversão de uma SAN numa Cadeia de Markov.
Nota- se que esta matriz final já conta com os ajustes diagonais necessários (devido a os eventos sincronizantes negativos dos termos que foram criados) e a soma de cada linha resulta em zero.
r5+ r4) r2 r5 r0 r6 r2 r4 r6 r2 r0 r5+ r4+ r2) r3 r5 r2 r3 r4 r2+ r1) r1 r5+ r4+ r3) r3 r5 r3 r6 r4 r3+ r6)~ do mapeamento de uma SAN para MC.
A Figura 4.4 mostra que para obter a MC correspondente a uma SAN é necessário iterar sobre o produto do espaço dos estados locais dos autômatos, produzindo todas as combinações possíveis.
Isso evidência o fato da modelagem por SAN ser mais compacta e compartimentalizada, como mencionado anteriormente.
Entretanto, ao realizar essa combinação, pode- se potencialmente gerar estados que nunca serão atingidos.
Esta figura mostra, na parte direita, diferentes tipos de linha (algumas pontilhadas, outras maiores, etc) para cada evento correspondente à SAN.
Ressalta- se que em MC não existem diferenças quanto a o tipo de uma transição, i.
e, todas são indistinguíveis.
Decidiu- se mostrar a cadeia desta forma para que fosse entendido o mapeamento de cada tipo de evento da SAN e sua transição correspondente na MC.
Nota- se que, para a solução de SAN, é suficiente guardar em memória apenas as pequenas matri~ correspondente zes que compõem o descritor, sendo desnecessário salvar o Gerador Infinitesimal Q à Cadeia de Markov.
Essa é a principal vantagem de SAN sobre outros formalismos estruturados, pois baseia- se no uso da Álgebra Tensorial para armazenar implicitamente a matriz de transição e calcular o vetor de probabilidade estacionário ou transiente de o qual são extraídos posteriormente os índices de desempenho.
A obtenção deste vetor será melhor detalhada da Seção 4.4.
Logo, considerando- se as matrizes que representam os eventos locais, os eventos sincronizantes positivos e os seus ajustes diagonais, é necessário um termo com somas tensoriais (correspondendo aos eventos locais) e oito termos com produtos tensoriais (por sua vez equivalendo- se aos eventos sincronizantes).
Estes termos estão descritos a seguir:
Parte local2 correspondente aos autômatos MN 1) e MN 2):
Ql $= QN Parte sincronizante positiva da ocorrência do evento t3:
Qt3+ $= QN t3+ t3+ t3+ Parte sincronizante negativa relativa ao ajuste diagonal do evento t3:
Qt3- $= QN t 3-t 3-t 3-Parte sincronizante positiva da ocorrência do evento g12:
Qg12+ $= QN g12+ g12+ g12+ Parte sincronizante negativa relativa ao ajuste diagonal do evento g12:
Qg12- $= QN g 12-g 12-g 12- ressaltar que os autômatos MN 3) e MN 4) não possuem eventos locais, logo estes não tem relevância no cálculo do Gerador Infinitesimal final.
Por este motivo as matrizes correspondentes a estes autômatos encontram- se zeradas em Ql.
Parte sincronizante positiva da ocorrência do evento g23:
Qg23+ $= QN g23+ g23+ g23+ Parte sincronizante negativa relativa ao ajuste diagonal do evento g23:
Qg23- $= QN g 23-g 23-g 23-Parte sincronizante positiva da ocorrência do evento g34:
Qg34+ $= QN g34+ g34+ g34+ Parte sincronizante negativa relativa ao ajuste diagonal do evento g34:
Qg34- $= QN g 34-g 34-g 34-O Gerador Infinitesimal é dado por:
O Gerador Infinitesimal deste exemplo corresponde a uma matriz quadrada de dimensão 36 e está fora de o escopo desta seção mostrar- lo por completo.
No entanto, observa- se que o descritor Markoviano apresenta características marcantes tais como matrizes esparsas e diversas matrizes do tipo identidade, as quais marcam que um determinado evento não ocorre num autômato.
A seguir, na próxima seção, descrevem- se os mecanismos de cálculo computacional do vetor de probabilidade estacionário ou transiente utilizando- se maneiras sofisticadas para multiplicação entre vetores e descritores Markovianos.
Multiplicação Vetor--Descritor As Cadeias de Markov são resolvidas, em última análise, através de multiplicações entre um vetor e uma matriz, conforme explicado na Seção 2.2.
Entretanto, formalismos estruturados com descritores Markovianos nunca geram a matriz de transição correspondente à MC subjacente e sim sua representação tensorial, ou seja, um descritor Markoviano.
Para resolver um modelo descrito desta forma não é mais possível utilizar a mesma abordagem de MC, ou seja, uma multiplicação vetormatriz, mas sim uma Multiplicação Vetor--Descritor (MVD).
Graficamente, usando- se o descritor do exemplo anterior (Seção 4.3.2), a MVD pode ser explicada da seguinte forma (seja n o número total de estados dado por| X|):
Qt3+ Qt Qg Qg12-g23+ g 23-Qg34+ g 34-Descritor Markoviano Ql Ql Qt3+ Qt3+ t 3-t 3-Qg12+ Qg12+ g 12-g 12-Qg23+ Qg23+ Qg23-Qg23-Qg23-g34+ g34+ Qg34-Qg34-Qg34-Esta seção tratará das formas de multiplicar um vetor de probabilidade por um descritor.
Um dos ramos de pesquisa em SAN foca- se em formas de melhorar o desempenho desta forma não trivial de multiplicação.
Existem atualmente três algoritmos distintos para operar com o produto de um vetor por um descritor:
Algoritmo Esparso, Algoritmo Shuffle e uma combinação destas duas abordagens denominado Algoritmo Split.
Estas três maneiras serão mais detalhadas a seguir.
Definindo- se mais formalmente, a MVD pode ser vista como a multiplicação de um vetor de probabilidade por| L| $= N+ 2E termos tensoriais compostos por N matrizes, onde L é um j $= 1 3 Conforme i $= 1 i) Qj Seção 4.1.2, uma soma tensorial é um produto tensorial com matrizes identidade.
Antes de explicar detalhadamente os algoritmos de MVD, são apresentadas as notações utilizadas.
Sejam: O Algoritmo Esparso é o mais intuitivo dos métodos de MVD.
A ideia principal do algoritmo é considerar o termo tensorial como uma única e potencialmente grande matriz esparsa a ser multiplicada por o vetor de probabilidade.
Este algoritmo assemelha- se ao método utilizado para a multiplicação de um vetor por o Gerador Infinitesimal, a única diferença é que se considera apenas cada termo tensorial como uma grande matriz.
Para um termo tensorial composto por N matrizes Qi), cada uma de dimensão ni com nzi elementos não-nulos, o Algoritmo Esparso gerará todos os elementos numa matriz Q resultando em Q $= N Qi), com dimensão g i $= 1 ni.
Uma possível implementação do Algoritmo Esparso é apresentada no Algoritmo 4.1.
Cabe ressaltar que a linha 6 mostra que antes de realizar as multiplicações, dependendo do evento e das funções associadas no modelo, serão necessárias avaliações de função através da chamada evaluate.
O número de multiplicações em ponto flutuante para essa implementação é dada por a Equação 4.30: I) Algoritmo 4.1: Esparso ­ $= × N g i $= 1 Q.
K) k basein $= basein+ × nrightk) baseout $= baseout+ × nrightk) $ + × s Entretanto, nesta versão, todos os elementos não-nulos de Q são, descrevendo- se o problema computacionalmente, gerados em tempo de execução do algoritmo.
Tal geração representa fosse criada para guardar estes N i $= 1 nzi elementos não-nulos.
Esse procedimento eliminaria as linhas 3 e 7 do Algoritmo 4.1 (o escalar s seria buscado de uma estrutura de dados auxiliar em memória) e reduziria o número de multiplicações em ponto flutuante como definido por a Equação 4.31: Esta opção, ao utilizar mais memória, reduz o número de cálculo de índices (que são normalmente efetuadas em outros algoritmos, por exemplo, no Shuffle, visto a seguir) e permite que o Algoritmo Esparso seja eficiente em termos de tempo gasto de execução.
Entretanto, a memória gasta para salvar essa estrutura de dados (além de os vetores de probabilidade necessários) torna alguns modelos intratáveis, fazendo com que essa opção seja descartada para modelos que contém um espaço produto de estados alto.
O total de chamadas à diretiva de avaliação de funções varia de modelo para modelo e não faz parte da equação de complexidade apresentada.
A seguir, explica- se o Algoritmo Shuffle, que é eficiente em termos de memória gasta~ ou mesmo uma parte de ela, para armazenar o descritor, pois nunca gera explicitamente a matriz Q apenas as informações contidas nas matrizes de cada termo tensorial.
A seguir, aplica eficazmente operações de Álgebra Tensorial para o cálculo das informações necessárias.
O princípio básico deste algoritmo é a aplicação da decomposição de um termo tensorial na propriedade do produto ordinário de fatores normais:
InN 1 InN) × InN) × O Algoritmo Shuffle consiste em multiplicar sucessivamente o vetor de probabilidade por cada fator normal.
Mais precisamente, o vetor é multiplicado por o primeiro fator normal e o vetor resultante é multiplicado por o próximo e assim por diante, até o último fator normal.
Internamente, para cada fator normal, as multiplicações são feitas usando- se pequenos vetores chamados zin e zout como descrito no Algoritmo 4.2.
Estes vetores pequenos em termos de dimensão igual à ordem da matriz sendo multiplicada guardam os valores de para multiplicação por a iésima matriz do fator normal zin e guardar o resultado em zout.
I) Algoritmo 4.2: Shuffle ­ $= × N g i $= 1 Q.
A linha 5 do algoritmo corresponde a uma avaliação de função (caso seja necessária para o modelo e de acordo com a definição da função) através da diretiva evaluate.
A multiplicação por o vetor por o iésimo fator normal consiste, generalizadamente, em embaralhar4 os elementos de para montar nlef ti × nrighti vetores de tamanho ni e multiplicar- los por a matriz Qi).
Assumindo- se que a matriz Qi) é guardada de forma esparsa, o número de operações necessárias para multiplicar um vetor por o iésimo fator normal é:
Nlef ti × nrighti × nzi, onde nzi corresponde ao número de elementos não-nulos da iésima matriz do termo tensorial Qi).
Considerando- se o número de multiplicações por todos os fatores normais de um termo tensorial, o custo computacional do Algoritmo Shuffle para efetuar a operação de multiplicação de um vetor por um descritor é dada por a Equação 4.32:
Uma outra vantagem de uso do Algoritmo Shuffle consiste no fato de possuir otimizações para modelos com taxas funcionais, ou seja, modelos que utilizam propriedades da Álgebra Tensorial Generalizada e também no que diz respeito ao uso de reordenamentos da estrutura tensorial (também chamadas de permutações).
Como no Algoritmo Esparso as chamadas para avaliações de funções variam em cada modelo e não estão sendo contabilizadas no cálculo da complexidade final.
Eventos locais em SAN são normalmente esparsos, indicando um comportamento que independe de outros autômatos de um sistema.
O mesmo não ocorre com eventos sincronizantes, pois podem potencialmente afetar todos os autômatos de um modelo.
Entretanto, dependendo do modelo que está sendo analisado, essa condição é inexistente, i.
e, um número substancial de ocorrências dizem respeito à entre pelo menos dois autômatos e um número que raramente compreende o total de autômatos.
Esse é um dos motivos por os quais iniciou- se a pesquisa de algoritmos para execução do processo de MVD de forma híbrida tirando vantagem da propriedade da Decomposição Aditiva combinada à decomposição de produtos tensoriais clássicos em fatores normais.
A propriedade da Decomposição Aditiva dita que qualquer produto tensorial pode ser decomposto numa soma ordinária de matrizes compostas por um único elemento não-nulo.
Seja i $= 1 ni composta por apenas um elemento não-nulo o sição Aditiva pode ser definida como:
K) k $= 1 qik jk.
A propriedade da Decompo-n1 j1 $= 1^ iN jN) k) iN $= 1 nN jN $= 1 k) onde q^ ij) é uma matriz de dimensão nk a qual o elemento na linha i e coluna j é qij.
O Algoritmo Split[ CZE07] propõe uma solução combinada usando fundamentalmente a propriedade da Decomposição Aditiva para um dado conjunto de matrizes num produto tensorial seguido da aplicação da operação de embaralhamento para as matrizes restantes do termo.
Cada fator é chamado de Fator Normal Aditivo Unitário (Additive Unitary Normal Factor ­ AUNF).
Esse conceito é central para o Algoritmo Split e internamente trata- se de uma estrutura de dados que armazena os índices dos vetores de entrada (basein) e saída (baseout), um escalar s e um vetor de tamanho contendo os índices de linha e coluna de cada matriz que foram usados para calcular s (esse vetor será usado para avaliação de funções com parâmetros que estejam na parte esparsa posteriormente).
Agora tem- se então uma divisão do termo tensorial em dois grupos distintos:
O primeiro contendo matrizes que serão unidas sob a forma de uma lista de fatores normais aditivos unitários e o segundo grupo, contendo o restante das matrizes.
Em termos de solução, o primeiro grupo será manipulado com uma solução esparsa, multiplicando tensorialmente cada AUNF por o segundo grupo usando a solução Shuffle.
A ideia principal é dividir o termo tensorial em dois conjuntos e tratar- los de forma distinta em termos de multiplicação vetor-descritor.
A Tabela 4.1 apresenta estes conceitos do Algoritmo Split de forma gráfica.
O índice da matriz escolhida para delimitar o fim do tratamento com a parte esparsa (e subsequentemente, o início da parte Shuffle) é denominado parâmetro de corte, ou simplesmente corte.
Casos especiais do Algoritmo Split são os casos onde o corte possui valores extremos, i.
e, quando $= N significa que a abordagem Esparsa pura está sendo utilizada e quando $= 0 não existem matrizes no lado esparso do termo tensorial e apenas o Algoritmo Shuffle será executado.
Estes são casos particulares do Algoritmo Split.
Parte- se a seguir para a definição formal da operação do método em si, de acordo com o Algoritmo 4.3.
A ideia principal do método consiste em computar o elemento escalar s de cada AUNF em multiplicando cada elemento não-nulo s de cada matriz do primeiro conjunto de matrizes (parte esparsa) de Q1) até Q) (linhas 5 a 9).
De acordo com os elementos de produto das dimensões das matrizes após o parâmetro de corte do termo tensorial) é multiplicado por o escalar s.
Em as linhas 10 e 11 são realizadas as multiplicações de s para cada posição em, de entrada para a parte Shuffle por o produto tensorial das matrizes do segundo conjunto até QN).
A o término da parte Shuffle o vetor obtido é acumulado no vetor final (linhas 33 a 35).
O algoritmo possui três blocos distintos, um bloco onde para cada AUNF calculado (de zero a), um vetor auxiliar de tamanho nright (i.
e, nright de zero até o valor do corte) é multiplicado em posições chave originadas durante o cálculo do AUNF em questão.
Um segundo bloco, onde o método Shuffle é chamado para um sub-espaço à esquerda que desconta as matrizes da parte esparsa e finalmente, uma seção onde este vetor auxiliar que foi modificado no bloco anterior é acumulado no vetor final.
A linha 17 do algoritmo mostra uma diretiva chamada evaluate, utilizada para a avaliação de elementos funcionais.
Cabe ressaltar que o Algoritmo Split original foi estendido para tratar de descritores generalizados, ou seja, modelos com taxas funcionais.
Essa é basicamente a diferença fundamental entre as alternativas existentes até o momento de MVD que utilizem soluções híbridas de armazenamento.
Os impactos desta diretiva serão melhor analisados nos Capítulos 5 e 7 referentes às estratégias de modificação dos descritores e aos resultados obtidos, respectivamente.
O custo computacional do Algoritmo Split em termos de multiplicações é descrito por a Equação 4.34.
Em (a), encontra- se o total de AUNFs, (b) o custo para criar um AUNF, em (c) o subespaço à direita da ser multiplicado por cada AUNF e, por fim, (d) a parte que adiciona a complexidade do Algoritmo Shuffle, o qual é operado da N. A) d) c) Existem algumas otimizações que podem ser implementadas em algoritmos para MVD.
Estas modificações em termos de implementação alteram significativamente o custo computacional teórico apresentado na Equação 4.34.
Para o caso do Algoritmo Shuffle, pode- se otimizar a maneira por a qual o método lida com matrizes do tipo identidade.
Estas matrizes fazem com que seja desnecessário gerar fatores normais para o cálculo do vetor solução, pois, sendo identidades, as matrizes restantes também o são, logo todo o termo tensorial i) considerando ponto de corte.
Algoritmo 4.3: Split ­ $= × N g i $= 1 Q s $= 1 basein $= baseout $= 0 k nrighti × ni) é uma identidade.
É natural que, em se tratando deste caso particular, nenhum fator normal seja criado, reduzindo o custo computacional de execução.
Este custo corresponde a transformar a Equação 4.32 na Equação 4.35: Entretanto, dada a flexilidade do Algoritmo Split e dependendo do evento que esteja sendo considerado, o número de AUNFs gerados pode onerar a memória a ser gasta para armazenamento dos escalares necessários.
Em esse caso, uma análise prévia minuciosa de cada termo tensorial deve ser realizada, detectando casos onde um grande bloco composto unicamente por identidades está definido (após o termo ser permutado), detectando onde o método esparso obterá um ganho significativo de desempenho frente as demais modalidades de MVD existentes.
Esta melhoria sugere que o mesmo pode ser aplicado na parte do método Shuffle no Algorimo 4.3 referente a o Algoritmo Split nas matrizes Q+ 1) a QN).
Caso a matriz indexada por i no algoritmo (Qi)) não seja uma matriz identidade, o custo de nz ni multiplicações é adicionado.
Analogamente ao Algoritmo Shuffle, a Equação 4.34 pode ser reescrita alterando- se o custo para o cálculo a partir de.
O número de multiplicações resultantes para o Algoritmo Split seguirá a Equação 4.36: Qi) $= Id nzi ni Usualmente, em SAN, os termos tensoriais são esparsos, uma vez que indicam a ocorrência dos eventos em cada autômato (exceto em casos onde existam diversos eventos ocorrendo em diversos autômatos, indicando matrizes quase plenas no termo).
Uma outra otimização que pode ser realizada trata dos pré-cálculos dos elementos não-nulos, salvando- os em estruturas de dados que serão acessadas em todas as iterações, mas computados apenas na primeira vez que o método iterativo é chamado.
Estas otimizações foram melhor estudadas por e causam uma redução significativa no custo computacional do Algoritmo Split, similar ao apresentado na Seção 4.4.1 no que diz respeito ao cálculo dos elementos nãonulos.
Logo, o valor final da definição do número de multiplicações em ponto flutuante necessárias para a execução do Algoritmo Split não é mais o valor definido por a Equação 4.36, e sim dado por a Equação 4.37: Mas, se, por exemplo, só existirem matrizes do tipo identidade na parte estruturada, toda a complexidade envolvida por o Algoritmo Shuffle não é mais necessária, fazendo com que a Equação 4.37 seja convertida na Equação 4.38: Permutações dos termos tensoriais Uma das operações mais custosas efetuadas na MVD é a avaliação de funções.
Em o contexto deste trabalho, estas avaliações estão presentes nos algoritmos que foram explicados nas Seções 4.4.1, de avaliações estão presentes nos subespaços à esquerda e à direita da matriz sendo multiplicada por o vetor, ou seja, são executadas diversas vezes ao longo de o método, dependendo do tamanho.
Para diminuir os efeitos destas execuções, são apresentadas técnicas de reordenamento ou permutação dos termos tensoriais.
Estas técnicas servem para reorganizar as matrizes dos termos tensoriais detectando uma forma para avaliar menos funções, colocando a diretiva de avaliação dentro de apenas um laço e não em dois laços como é feito originalmente no Algoritmo Shuffle.
A definição inicial do Algoritmo Split não previa a realização de permutações.
A inclusão de solução para tensores em ATG é uma contribuição que foi introduzida neste trabalho bem como o estudo e implementação adicional para contemplar tal necessidade.
Como será melhor explicado nos próximos capítulos, o uso de permutações no Algoritmo Split será necessário para uma solução adequada.
A o observar os casos particulares de produtos tensoriais generalizados, pode- se compreender melhor o interesse em realizar estas otimizações.
Por exemplo, no produto tensorial generalizado dado por i $= 1 os fatores normais da decomposição devem ser tratados de acordo com a seguinte ordem:
InrightN para o seguinte produto tensorial generalizado:
Os fatores normais da decomposição devem ser tratados de acordo com a seguinte ordem:
× Inlef tN 1 Q ou seja, logo abaixo de a linha 3) e no caso de o Algoritmo 4.3, a linha 17 seria colocada logo abaixo de a linha 15, por o mesmo motivo.
Ainda encontram- se em aberto estudos de como realizar esse reordenamento de autômatos para se encontrar os casos onde esse procedimento é passível de ser realizado visando a redução do número de avaliações de elementos funcionais.
Para isso, informalmente, são poucos os casos onde as funções definidas dependem do estado de todos os outros autômatos.
Normalmente, os parâmetros das funções (i.
e, estados de autômatos) possuem um tamanho restrito.
Caso uma função dependesse do estado de todos os autômatos, este seria o pior caso para o processo de permutação, inclusive tornaria desnecessária a realização de quaisquer reordenamentos, pois não eliminariam o número de avaliações necessárias.
Não faz parte do escopo deste trabalho explicar detalhadamente as variadas técnicas de reordenamento de termos tensoriais, pois estas já foram exaustivamente feitas em[ FER98a, FER98b, BEN03b].
Este trabalho parte do princípio que a realização de reordenamentos pode ser extremamente eficaz tanto para reduzir- se o número de avaliações como utilizar essas reordens para reduzir o tempo necessário para executar métodos híbridos de solução, neste caso, especificamente para o caso do Algoritmo Split.
A seguir, serão apresentados os princípios da permutação em termos tensoriais, seus objetivos e algumas definições de base.
Dado que os autômatos podem trocar de posição no termo tensorial, os elementos do vetor de probabilidade final devem trocar de lugar pois a ordem lexicográfica original foi alterada.
A Tabela 4.2 mostra os estados de um vetor por os autômatos ordenados de duas maneiras distintas.
Os elementos do vetor são organizados de acordo com uma ordem lexicográfica expressa por a lista de autômatos, igualmente respeitando uma ordem.
À esquerda da tabela é utilizada a ordem 1) 2) 3).
Os autômatos deste exemplo possuem tamanho n1 $= 2, n2 $= 3 e n3 $= 2.
À direita da tabela é realizada a seguinte reordem dos autômatos:
3) 1) 2).
A coluna rank equivale ao índice no vetor de probabilidade.
Como para esse exemplo o| X| $= 2 × 3 × 2 $= 12, esta coluna varia de 0 a 11.
A ideia aqui é descobrir o próximo estado dado um estado corrente.
Para simplificar as operações envolvidas, a melhor forma de se fazer esta descoberta é pensar num algoritmo que retorne o próximo estado, dada uma ordem.
Logo, observa- se os autômatos do último até o primeiro e tentase incrementar seu estado local.
Um incremento é inválido quando o estado local do autômato é o último estado (não existem mais estados).
Quando o incremento é inválido, o estado local do autômato é zerado (reset de estado) e se considera o próximo estado (de acordo com uma determinada ordem, podendo não ser a original e sim qualquer ordem).
Este procedimento acaba quando um incremento válido foi realizado.
Para exemplificar esse processo, considere- se a ordem 1) 2) 3) onde se deseja saber o próximo estado (um incremento de estado) dado que o estado atual é o (0 1 1).
O autômato 3) é o primeiro a ser considerado.
Tenta- se incrementar- lo, mas, por estar já no último estado possível, coloca- se nessa posição, o valor 0.
A seguir, tenta- se incrementar 2), e o incremento é válido, para 2.
Logo, o próximo estado global do sistema seguido do estado é o (observe essa ocorrência na Tabela 4.2, entre os ranks 3 e 4 do lado esquerdo).
Entretanto, para o caso de uma permutação das posições no termo tensorial, os incrementos não são mais tão simples, e devem seguir um cálculo mais elaborado do rank final para descoberta do próximo estado.
É necessário se calcular o novo rank a partir de o rank corrente do vetor permutado.
Seguindo- se o mesmo exemplo, o rank do estado por a nova ordem lexicográfica dada por 30 2 0) deve ser 2.
Para calcular esse novo índice, realizam- se incrementos e decrementos, zerando alguns estados locais.
Os valores destes incrementos e decrementos variam de acordo com a nova ordem lexicográ- fica.
Um incremento válido para o próximo estado de um estado local do autômato i) corresponde à adição de nrighti no rank.
Em o exemplo em questão foi feito um reset no estado do autômato 3), e sob a nova ordem lexicográfica, nright3 $= 2 × 3 $= 6.
Com isso é obtido o estado de rank 7 -- 6 $= 1.
A seguir, como ocorrido no exemplo anterior, incrementa- se o estado do autômato 2), e este incremento é válido, ou seja, obtem- se o valor 2 para o rank final, como seria normalmente retornado mas, neste caso, com o uso de permutações.
Com isso, observa- se que são feitos os mesmos procedimentos para ambos os exemplos, apenas no caso onde houve a permutação das ordens originais é que, ao invés de se incrementar, foi descontado um valor que correspondia ao nrighti, equivalendo ao salto que deve ser feito na estrutura permutada.
Trata- se de uma maneira transparente de se efetuar as permutações, incorrendo- se apenas no recálculo de índices para saltar na estrutura tensorial.
As permutações foram inicialmente utilizadas no Algoritmo Shuffle com o intuito principal de eliminar chamadas desnecessárias de avaliações de elementos funcionais.
Com isso, para alguns modelos, observou- se um ganho de desempenho, pois menos operações são efetuadas se uma per-mutação satisfatória for encontrada.
Naturalmente, não é fácil descobrir como melhor permutar cada termo tensorial para obter o máximo de desempenho, sendo esta uma questão aberta de pesquisa.
No caso de o Algoritmo Split, as permutações desempenharão um papel ainda mais importante que a verificada para o Algoritmo Shuffle e usada com êxito para alguns casos.
No caso de o Split, os reordenamentos serão cruciais para entender qual a melhor forma de dividir os termos tensoriais enviando matrizes ou para o lado estruturado (direito do parâmetro de corte) ou enviando as avaliações para a parte esparsa e vice-versa.
Somente com as permutações é possível verificar onde o método é melhor executado, pois separa cada característica dos termos tensoriais.
Algoritmo Split com permutações e identidades à direita de A Figura 4.6 mostra a operação do Algoritmo Split quando existem apenas matrizes do tipo identidade na parte à direita do parâmetro de corte (utilizada por o Algoritmo Shuffle).
Observa- se que os AUNFs (não-nulos de 0 a, i.
e, i $= 1 nzi) possuem um papel central nessa representação, pois guardam, para cada escalar s do vetor de entrada apontado por os índices de linha e coluna que foram utilizados em cada matriz (n $ | X|).
De esta maneira, um AUNF conhece a posição de entrada a ser usada e também sabe onde colocar o valor multiplicado no vetor de saída.
Essas são as únicas informações necessárias para que seja executado o método, dado que agora só matrizes do tipo identidade estão presentes na parte que compete ao Algoritmo Shuffle, não sendo necessária a geração de fatores normais, apenas a multiplicação do escalar por o vetor em posições chave.
A Figura 4.6 explica a Equação 4.38 de forma gráfica.
É necessário criar um vetor auxiliar de tamanho nright e multiplicar o escalar s de acordo com o número de AUNFs existentes.
Os acessos às posições dos vetores na implementação com permutações possuem custos computacionais associados pois, como explicado na Seção 4.5 precisam recalcular deslocamentos na estrutura tensorial de acordo com a nova ordem das matrizes nos termos.
Como será visto no indireções nos acessos aos índices dos vetores de acordo com o reordenamento escolhido.
Estas análises finalizam o capítulo sobre a solução de descritores Markovianos.
Constatou- se que o Algoritmo Split possui restrições ao delimitar a divisão dos termos tensoriais, seja em função de as identidades existentes ou das dependências funcionais.
Atualmente o algoritmo é executado nas primeiras iterações para coleta de tempos de execução para então decidir quais cortes aplicará nas iterações seguintes.
Esta escolha não segue um procedimento determinístico, baseado nas características das matrizes, trata- se de uma heurística baseada nas amostras das execuções.
O próximo capítulo tratará das estratégias de reordenação do descritor para otimizar a solução de modelos complexos.
O objetivo deste capítulo é tratar das estratégias para escolha de um ponto de corte em o qual re-estruturam- se termos tensoriais de descritores Markovianos através de permutações, objetivando a otimização da solução do Algoritmo Split.
As estratégias que serão estudadas servirão de base para a discussão dos resultados apresentados no Capítulo 7.
A Seção 5.1 apresenta análises preliminares para uma maior compreensão do problema da determinação de para, na Seção 5.2 discutir as reestruturações que podem ser aplicadas para tratar descritores clássicos e generalizados.
A Seção 5.3 mostra um estudo das características de termos tensoriais e, na Seção 5.4, apresenta uma previsão dos custos computacionais em termos de multiplicações de ponto-flutuante.
Considerações preliminares Como explicado anteriormente, o Algoritmo Split multiplica os termos tensoriais dos descritores Markovianos de forma híbrida, basicamente de duas formas distintas.
De um lado do termo (à esquerda do ponto de corte) aplica- se a solução esparsa e à direita de, efetua- se a multiplicação aplicando o Algoritmo Shuffle.
Em este trabalho, esta divisão dos termos estabelecida para os termos tensoriais será definida como parte esparsa (esquerda de) e parte estruturada (direita de), respectivamente.
Devido a as características dos termos tensoriais, o desafio encontra- se na determinação do ponto de corte e divisão de cada termo tensorial tal que haja um equilíbrio entre o tempo gasto para execução da MVD e a memória extra necessária.
Entre as principais características para a determinação do escopo destas tarefas, interessa- se por as matrizes identidade dos termos tensoriais, por as avaliações de elementos funcionais e por a quantidade de escalares não nulos em cada matriz.
Em este sentido, nota- se a importância das sincronizações descritas por os modelos, as quais encontram- se intrinsicamente relacionadas às esparsidades de cada matriz, como exemplificado nas Seções 4.3.1 e 4.3.2.
Estas cooperações ou interações influenciam diretamente na quantidade de matrizes identidade na composição dos termos tensoriais bem como na memória adicional a ser gasta.
O ponto de corte escolhido para cada termo tensorial ditará a memória extra que será gasta na parte esparsa, logo, deseja- se evitar que um termo tensorial utilize uma quantidade massiva a ponto de inviabilizar a execução do Algoritmo Split.
A melhor forma de se considerar esse aspecto é através da identificação da constituição de cada termo tensorial, verificando os tipos e esparsidades de cada matriz presente.
Cabe ressaltar que cada termo tensorial será tratado individualmente, ou seja, este será dividido de forma única com diferentes valores de para os diferentes termos.
As análises estão focadas no formalismo das SAN mas, como mencionado anteriormente, podem ser aplicadas a quaisquer outros formalismos estruturados que utilizem descrições tensoriais para mapear a matriz de transição da MC correspondente.
Esta seção utiliza os conceitos explicados anteriormente no Capítulo 4, especificamente as definições referentes à Álgebra Tensorial Clássica e Generalizada descritas na Seções 4.1 e 4.2, descrição dos métodos de MVD da Seção 4.4 e o conceito de AUNF que é descrito na Seção 4.4.3.
A re-estruturação dos termos tensoriais e a criação de escalares está fundamentada em duas propriedades da Álgebra Tensorial:
Propriedade da Pseudo--comutatividade e propriedade da Decomposição Aditiva (Equação 4.33), ambas definidas no Capítulo 4.
Por definição, cada termo tensorial de um descritor Markoviano corresponde à ocorrência de um evento.
Portanto, é necessário estudar quantos componentes este evento afeta, ou seja, deve ser determinada a esparsidade e o número de matrizes do termo tensorial que conterão informações sobre a ocorrência deste evento.
Precisa- se descobrir o grau de dependência de cada termo para facilitar a análise das estratégias.
O Grau de Dependência Constante (GDC) e o Grau de Dependência Generalizado (GDG) estão relacionados, respectivamente, aos termos tensoriais clássicos e generalizados.
Enquanto que o GDC informa a quantidade de autômatos que afetam a ocorrência de um evento, o GDG atesta o número de autômatos que são parâmetros de cada elemento funcional para a correta aplicação da função.
Mais especificamente, tem- se a seguinte classificação para os termos tensoriais de uma SAN:
Termo tensorial clássico (utiliza ATC):
Um termo clássico é um termo tensorial sem funções, contendo apenas matrizes com elementos constantes que indicam onde cada evento ocorre em cada autômato e com que taxa;
Termo tensorial generalizado (utiliza ATG):
Contém matrizes com elementos funcionais para serem avaliados.
Termos deste tipo são classificados quanto a o grau de dependência generalizado, podendo ser:
Termos tensoriais são compostos por matrizes de diferentes características.
As matrizes de um termo podem ser classificadas da seguinte forma (seja nz o número de elementos não-nulos e n a dimensão de uma matriz):
Identidade: A matriz é do tipo identidade, possuindo o valor 1 para a diagonal principal e o valor 0 para o restante das posições;
Constante: Trata- se de uma matriz com mais de um elemento não-nulo, com esparsidade até nz variável (entre n);
Elemento: Trata- se de um caso especial de matriz constante, ou seja, é uma matriz esparsa com apenas um elemento não-nulo (esparsidade n Funcional:
Indica que a matriz possui um elemento com uma função definida, e necessita de informações de outras matrizes do termo (para o escopo desta tese, de estados de outros autômatos) para sua correta avaliação.
Diferentes estratégias de corte devem ser tomadas para os diferentes tipos de termos tensoriais.
Para os termos clássicos as características mais importantes são as dimensões das matrizes, a esparsidade e a ocorrência de matrizes identidade.
Para os termos generalizados, além de estas, consideram- se também as matrizes que são parâmetros da função e o lugar onde será feito o cálculo de avaliação, se na parte esparsa ou na parte estruturada.
A quantidade de avaliações de funções que são executadas no processo da MVD é um fator determinante para uma possível degradação de desempenho.
Os custos computacionais envolvidos variam para cada modelagem, entretanto, dependendo do caso, contribuem em aumento significativo do número de operações que são efetuadas para a avaliação.
Devido a o fato de que o método iterativo será potencialmente executado muitas vezes e para os mesmos parâmetros de função, constata- se que seria mais interessante avaliar- las uma vez salvando os valores calculados em estruturas de dados auxiliares.
Contudo, é vantajoso utilizar as diretivas funcionais como primitivas de modelagem, pois aumentam- se as maneiras por as quais é possível modelar sistemas contendo transições complexas.
Em este sentido, uma prática é buscar mecanismos onde seja possível utilizar taxas funcionais ao mesmo tempo que na parte de solução seja usada a melhor maneira de se efetuar a MVD (estas discussões encontram- se mais adiante).
Quando as avaliações de funções são realizadas na parte esparsa, o descritor Markoviano generalizado é convertido em clássico, implicitamente.
Intuitivamente, avaliar as funções na parte esparsa remove a sobrecarga de se ter que avaliar- la inúmeras vezes em potencialmente inúmeras iterações.
Entretanto, uma análise mais abrangente se faz necessária para substanciar essas evidências.
Para começar esta análise mais aprofundada, é necessário definir precisamente as opções existentes ao dividir termos tensoriais.
A seguir é feita uma análise sobre como proceder através do estudo de opções para os casos clássico e generalizado.
Seja M o total de matrizes de um termo tensorial e seja V o número de matrizes envolvidas na sincronização dado que, por definição, V $= 1 não acontece, pois não é permitida a definição de um evento sincronizante envolvendo apenas um autômato:
Para termos clássicos, reordenar o termo tensorial e reconfigurar- lo, privilegiando o deslocamento das matrizes do tipo identidade para o lado estruturado:
­ caso desvantajoso:
V $= M, ou seja, não existem identidades, i.
e, o evento sincronizante envolve todas as matrizes do termo tensorial;
Também indica que os AUNFs a serem criados são iguais ao produtório dos elementos não-nulos contabilizados até a primeira matriz identidade, o qual deve ser o valor escolhido para.
Para termos generalizados, escolhe- se basicamente onde pode se avaliar as funções:
­ avaliar funções na parte esparsa:
Implica em converter implicitamente o termo tensorial generalizado para um termo tensorial clássico, uma vez que esse procedimento avalia diretamente os elementos funcionais transformando- os em elementos constantes;
Algoritmo Shuffle, ou seja, na parte estruturada, um número de vezes que depende dos valores dos deslocamentos nright e nleft calculados respectivamente para as operações desta parte.
O objetivo na escolha do corte e reordenamentos é o de minimizar o tempo gasto para realizar a MVD em cada termo.
A escolha de qual matriz será posicionada em cada parte deve estar de acordo com a classificação do termo tensorial e as características envolvidas.
De essa forma, o uso de permutações das matrizes dos termos tensoriais é mandatório uma vez que, para os termos clássicos, é desvantajoso posicionar matrizes identidade na parte esparsa (pois criam AUNFs desnecessários), devendo estas matrizes serem deslocadas para a parte estruturada.
Para os termos generalizados, precisa- se dos parâmetros das funções, ou seja, das informações contidas nas matrizes que fazem parte do conjunto de dependência da função a ser avaliada.
Se um dado termo tensorial possuir uma função numa dada matriz e escolhe- se realizar as avaliações na parte esparsa.
Todas as matrizes que a função depende, inclusive a matriz onde a função está definida, devem estar nesta mesma parte.
O resto das matrizes que não dependem da função podem ser enviadas para qualquer um dos lados do corte, sendo apenas necessário estudar qual parte será mais vantajosa dependendo da otimização a ser feita, em termos de memória ou de tempo.
Caso a matriz seja do tipo identidade que não é parâmetro para a função, esta é melhor tratada na parte estruturada, fato já constatado nos estudos realizados sobre o método Shuffle que descarta estas matrizes do cálculo.
Para o caso onde deseja- se aplicar as avaliações na parte estruturada, é necessário apenas que a função permaneça também nessa parte, sendo que as outras matrizes podem ser posicionadas na parte esparsa.
Novamente, neste caso é interessante deslocar as matrizes identidade para a parte estruturada.
Re-estruturações de descritores Markovianos A re-estruturação de descritores Markovianos (e seus termos tensoriais), clássicos ou generalizados, deve ser considerada de forma distinta, dada a natureza das matrizes que os compõem.
No caso de descritores clássicos, apenas matrizes constantes, elementos e identidades são utilizadas, enquanto que para os descritores generalizados, matrizes funcionais estão presentes.
A seguir, serão mostrados exemplos de um termo tensorial de cada tipo de descritor e a aplicação de re-estruturações das matrizes que os compõem.
Para este exemplo, será utilizado um termo tensorial composto por diversos componentes, neste caso, por seis autômatos.
Para o mapeamento do evento que corresponde a este termo, são necessárias seis matrizes que mapeiam as transições dos elementos.
Seus respectivos valores são:
Nz $= Seja o valor do parâmetro de corte do termo tensorial, com PSS dado por| X| $= 3 × 2 × 2 × 3 × 2 $= 216 estados.
As matrizes podem ser permutadas, alterando a ordem original definida no modelo e as divisões possíveis variam entre zero e seis (6).
Quando o corte é definido em 0 existe o máximo de estruturação (abordagem Shuffle) e para 6, nenhuma estruturação será feita, ou seja, o termo será tratado de forma puramente esparsa.
A seguir, é apresentado o termo tensorial exemplo:
Para este exemplo, as possibilidades de re-estruturação são restritas:
Ou as matrizes identidade são deslocadas para a direita, ou para a esquerda do ponto de corte.
Como discutido anteriormente, matrizes identidade na parte esparsa apenas ocupam memória extra desnecessariamente.
Em este sentido, o mais interessante seria mover as matrizes contantes para a parte esparsa, fixando o ponto de divisão logo a seguir, deixando matrizes identidade na parte estruturada, tal como:
Em este exemplo, o ponto de corte seria fixado em 2 sendo necessários quatro AUNFs (2 × 2 $= 4), conforme a esparsidade das matrizes do lado esparso.
As matrizes foram reordenadas para que na parte estruturada apenas matrizes do tipo identidade estejam definidas.
O subespaço criado a partir de o ponto de corte (nright) seria igual a 3 × 3 × 2 $= 54, onde o Algoritmo Split multiplicaria cada AUNF criado por este subespaço, para o evento correspondente a este termo tensorial, e não executaria o Algoritmo Shuffle na parte estruturada, aproveitando a otimização das matrizes identidade, discutida na Seção 4.4.2.
Em a próxima seção será mostrado um exemplo de um termo tensorial de um descritor Markoviano generalizado, com pelo menos uma matriz contendo um elemento funcional.
Para o seguinte termo tensorial generalizado, composto por cinco autômatos (no caso, cinco representa o autômato 3) por2:
Os valores possíveis para dividir o termo tensorial variam de acordo com os pontos de corte, de 0 a 5.
Nota- se que, ao aplicar o Algoritmo Split para 0, a abordagem escolhida será a equivalente ao Algoritmo Shuffle e, para 5, será a correspondente ao Algoritmo Esparso.
Pode- se escolher avaliar a função f na parte estruturada ou na parte esparsa do termo tensorial.
Caso fosse escolhido realizar as avaliações de funções na parte estruturada, o termo tensorial precisaria ser reordenado da seguinte maneira:
G g 2 0 g parte esparsa parte estruturada Em este caso, o conjunto das matrizes que fazem parte da dependência funcional de f é dado identidade e uma matriz constante para a parte estruturada e a outra matriz identidade, uma matriz constante e a matriz funcional para a parte esparsa, conservando as dependências necessárias para que o método Shuffle consiga avaliar apropriadamente f.
Para este caso de corte igual a 2, teriam- se três AUNFs3.
No caso de as avaliações de funções serem feitas na parte esparsa, a matriz onde a função está definida entra obrigatoriamente no conjunto de dependências funcionais, sendo igual a Dep (f) $= f 0 g parte esparsa parte estruturada Para este caso, o ponto de corte 3 foi escolhido e tem- se oito AUNFs.
Para esta reconfiguração, pode- se escolher enviar a matriz elemento) da parte estruturada para a parte esparsa, sem o aumento do número de AUNFs permanecendo apenas matrizes identidade na parte estruturada.
Contudo, não seria possível deslocar a matriz identidade de 5) para a parte estruturada, já que a função não poderia ser avaliada dado que uma das matrizes que ela depende está posicionada numa parte inacessível (não é possível avaliar a função com sucesso devido a a falta de parâmetros).
Uma alternativa válida, entretanto, com a preocupação de não aumentar o número de AUNFs que são gerados, é enviar a matriz do tipo elemento definida em 4) para a parte esparsa, deixando apenas matrizes identidade na parte estruturada.
AUNF é calculado como o produtório dos elementos não-nulos de uma matriz, de 0 a.
Maiores informações na Seção 4.4.3.
Em esta alternativa, o ponto de corte é igual a 4 e o termo tensorial seria assim reorganizado:
G g 2 0 g parte esparsa p estrut Em este exemplo nota- se que a parte estruturada não terá custo computacional associado, pois a matriz restante é do tipo identidade.
Outra constatação é que matrizes do tipo elemento sempre podem ser deslocadas para o lado esparso sem um ônus relativo ao aumento do número de AUNFs necessários.
Caso essa mesma matriz permanecesse na parte estruturada, ainda assim contribuiria para aumentar os cálculos de deslocamentos à esquerda e à direita do vetor na multiplicação, pois são mais relevantes para o Algoritmo Shuffle, em primeiro lugar, as dimensões das matrizes e, em segundo lugar, as quantidades de elementos não-nulos.
A o eliminar a restrição de permitir que funções na parte estruturada possam acessar elementos da parte esparsa, propõe- se mais uma alternativa de reordenamento, onde deixa- se apenas a matriz que contem o elemento funcional f, mais as identidades na parte estruturada e as demais matrizes na parte esparsa.
Este caso é possível, apesar de as dependências funcionais estarem em partes distintas, pois, ao se calcular os AUNFs, guardam- se os índices de linha das matrizes que o originaram.
Cabe ressaltar que o contrário seria impossível (i.
e, a matriz que contém a função f ser colocada na parte esparsa e uma ou as demais matrizes na parte estruturada) pois f necessita destes parâmetros que encontram- se na parte estruturada do termo tensorial.
Por pertencerem ao subespaço à direita do corte onde o Algoritmo Shuffle será executado, os parâmetros da função à esquerda do corte, encontram- se indisponíveis.
O próximo caso possui a vantagem de tornar desnecessário o armazenamento dos AUNFs relativos às matrizes identidade e trata- se de uma boa maneira de se reordenar os termos tensoriais.
G g 0 0 1 0 g 2 0 g parte esparsa parte estruturada Como as matrizes identidade serão desconsideradas por a parte estruturada e é possível avaliar as funções com sucesso (pois os parâmetros encontram- se obrigatoriamente à esquerda da definição da função), esta reordem oferece um baixo número de AUNFs necessários, pois a parte esparsa possui uma matriz do tipo elemento.
É importante salientar que não é necessário adotar uma solução puramente esparsa para esse termo tensorial (corte em 5), pois aumentaria o número de AUNFs e seria oneroso, pois o método Shuffle, por definição, não será executado e menos operações para cálculos de deslocamentos no vetor para a multiplicação serão feitos (estas análises serão feitas nas próximas seções).
Igualmente desnecessário é se gastar espaço de memória armazenando- se AUNFs formados a partir de a combinação de elementos de matrizes do tipo identidade.
Também verifica- se que, na prática, o aumento da memória não necessariamente implica num ganho de desempenho, ainda mais para esse caso, que armazenaria os AUNFs com mesmos valores de escalares e nunca aproveitaria os saltos na estrutura tensorial para melhorar a execução.
Os exemplos de re-estruturações aqui demonstrados evidenciaram a importância em se alterar a ordem natural das matrizes do termo tensorial para obter uma melhor organização e consequente execução do processo de MVD com o Algoritmo Split.
O custo computacional de se usar reordenamentos é baixo e realizado de forma transparente para o usuário, pois trata- se fundamentalmente de cálculos dos deslocamentos4, ou seja, novos valores para nright, nleft e njump, equivalendo respectivamente aos saltos do subespaço à direita, à esquerda e os saltos na estrutura tensorial de acordo com a dimensão da matriz não-identidade no fator normal.
Estes exemplos mostraram que devem ser adotadas diferentes estratégias para tratamento dos diferentes termos tensoriais.
Foi igualmente constatado que a flexibilidade do Algoritmo Split possibilita a definição de pontos de corte personalizados, de acordo com as características presentes nos termos tensoriais.
Uma vez que o problema foi investigado com as possibilidades de divisão de cada termo tensorial, nota- se que um conjunto finito de características afetam o desempenho da solução da MVD.
Este conjunto é dado por:
A) as dimensões das matrizes correspondente aos estados dos autômatos, b) o total de elementos não-nulos, c) o total de avaliações de funções que são feitas, e d) total de matrizes identidade nos termos tensoriais.
Estas características afetam diretamente a complexidade dos métodos escolhidos para a MVD.
A principal ideia deste capítulo é definir as principais estratégias para dividir um termo tensorial de uma maneira que não onere a memória gasta e que otimize o tempo de solução.
Como explicado anteriormente, esta divisão implicou na obrigatoriedade de reorganização do termo tensorial.
Essa reconfiguração não é custosa em termos computacionais, pois trata- se de cálculos de deslocamentos que são computados na primeira vez e depois apenas consultados na execução dos métodos.
O objetivo então é aplicar a melhor transformação ao termo tensorial e dividir- lo em partes que otimizem o tempo de resposta de modelos.
Para tanto, é necessário estudar os efeitos de cada propriedade dos termos tensoriais para determinar a melhor maneira de se fazer essa operação.
A seguir é realizado um estudo sobre estas propriedades visando a solução de descritores baseados em ATC e ATG.
Este estudo permitirá antecipar os desempenhos esperados de cada experiência a ser realizada no 4 Esses cálculos são melhor explicados na Seção 4.5.
Características de termos tensoriais Uma vez definidos os compromissos de desempenho do Algoritmo Split e as formas de divisão dos termos tensoriais para otimizar o tempo gasto na solução de modelos baseados em descritores Markovianos, a próxima etapa é estudar as implicações nos custos de execução do algoritmo.
Um termo tensorial é composto por uma lista de matrizes de diferentes dimensões, tipos e esparsidades.
Cada matriz contém informação relevante sobre como as entidades sincronizam atividades, ou seja, como estes interferem uns nos outros.
O grau desta interferência dita a formação das matrizes dos termos tensoriais, ou seja, serão criadas matrizes identidade para representar que um evento não ocorre num dado elemento (no caso de SAN, num autômato) e matrizes do tipo elemento, indicando a ocorrência de um evento de acordo com uma taxa de ocorrência.
Cabe ressaltar que a terminologia é aqui usada sem perda de generalidade para as seguintes atividades:
Envolvimento (ou envolver), interferência (ou interferir), afetação (ou afetar), i.
e, no contexto deste trabalho, serão usadas de forma a representar a mesma ideia.
A seguir, um estudo das implicações de cada tipo de característica existente em termos tensoriais e o que correspondem ao nível do algoritmo que será executado:
A seguir é feita uma análise mais aprofundada sobre estas características e seus efeitos na complexidade computacional envolvida, começando- se por o estudo do efeito das identidades nos termos tensoriais.
O efeito das matrizes do tipo identidade no termo tensorial é observado diferentemente em termos tensoriais clássicos e em termos generalizados.
Em termos clássicos, as identidades podem fazer parte do lado esquerdo do corte, executando o Algoritmo Esparso, ou na parte estruturada, que executará o Algoritmo Shuffle.
Como mencionado anteriormente, matrizes do tipo identidade na parte esparsa aumentam o número de AUNFs necessários sem guardar informação relevante.
Se estas matrizes identidade fossem deslocadas para a parte estruturada, levariam à execução de um menor número de multiplicações em ponto flutuante para o cálculo dos deslocamentos que são necessários ao Algoritmo Shuffle.
Esta redução de operações também é verificada se a parte estruturada contiver apenas matrizes do tipo identidade.
Em esse caso, somente é necessário o tempo inicial gasto para se descobrir os AUNFs de cada termo tensorial e depois multiplicar- los em índices pré-calculados para os vetores usados no método.
Este caso, para os termos tensoriais generalizados, implica que os elementos funcionais foram avaliados na parte esparsa, i.
e, este termo tensorial não precisa mais ser considerado um termo generalizado, sendo a partir desse momento um termo clássico, sem haver a necessidade de outras avaliações de função em operações posteriores envolvendo elementos funcionais.
A o não precisar mais avaliar funções na parte estruturada, descarta- se toda a complexidade envolvida para realizar esta operação.
Com isso, o termo generalizado é convertido para um termo clássico, em tempo de execução, pois as estruturas de dados auxiliares para armazenamento dos AUNFs contém os valores das funções já avaliadas.
Caso o número de AUNFs existentes não inviabilizem a execução do Algoritmo Split (passando- se dos limites disponíveis de memória, por exemplo), esta é tecnicamente uma boa relação custo/ benefício em termos de número de operações de multiplicações.
O ganho relacionado ao efeito das identidades na multiplicação dos termos tensoriais pode ser avaliado de duas formas:
Com permutação das matrizes do termo ou sem permutação e utilizando algum critério de escolha do ponto de corte.
Como estas permutações são, na verdade pré-cálculos de deslocamentos na estrutura tensorial, realizados apenas uma vez no início do método, seus custos são negligenciáveis do ponto de vista da execução do processo de MVD como um todo.
A existência de matrizes do tipo identidade está fortemente relacionada ao termo tensorial informando os autômatos que um dado evento interfere.
Dado um evento sincronizante e, se este está sincronizando uma transição com todos os autômatos, este termo não será composto por nenhuma identidade e sim por matrizes do tipo elemento ou matrizes constantes.
A abordagem flexível proposta por o Algoritmo Split auxilia na escolha de opções balanceadas para escolha do ponto de corte, baseadas na memória disponível.
Para o caso onde as identidades serão tratadas na parte estruturada, todos os cálculos necessários são desconsiderados.
O algoritmo somente calcula os AUNFs necessários, monta um vetor de tamanho nright com posições vindas dos índices de entrada de cada AUNF e após multiplicar o escalar| AUNF| vezes, salva no vetor de acordo com os índices pre-calculados e armazenados por as posições de saída.
Portanto, ao realizar somente estas operações, a complexidade em termos de multiplicações em ponto flutuante, caso garanta- se que somente existam identidades na parte estruturada, resulta em (assumindo que os AUNFs foram precalculados para cada termo tensorial):
Esta equação para complexidade é diferente da equação correspondente à versão original do Split, sem considerar que permutações possam ser usadas para o benefício crucial do método.
A Equação 5.2 da Seção 4.4.3 é re-apresentada a seguir:
Qini), computadas de+ 1 até N. A parte final corresponde à chamada do Algoritmo Shuffle tradicional.
Estas equações de complexidade demonstram o ganho do Split sobre o Shuffle quando a parte estruturada possui apenas matrizes do tipo identidade.
A avaliação de funções é uma operação que depende de diferentes fatores num modelo SAN.
O custo envolvido depende fundamentalmente das seguintes características:
A o dividir o termo tensorial de forma que as funções das matrizes sejam avaliadas na parte estruturada, aumenta- se o número de operações que são feitas, uma vez que as avaliações necessárias são realizadas em cada iteração e sempre resultam no mesmo conjunto de valores.
O oposto desta escolha é dividir o termo tensorial deslocando- se as matrizes dependentes e a matriz que contém o elemento funcional para a parte esparsa e executando- se o método de avaliação de função apenas uma vez no início do processo de solução, armazenando os AUNFs convertidos para valores escalares.
A o se fazer isso, os termos tensoriais generalizados são convertidos para termos clássicos e não existem mais avaliações de função como existia anteriormente e o método deve rodar mais rapidamente.
Existem duas maneiras de se efetuar as avaliações de funções, na parte esparsa ou na parte estruturada.
A seguir, analisam- se ambos os casos, iniciando por o caso da avaliação na parte esparsa.
O pior caso é definido quando a função depende de matrizes do tipo identidade.
A única restrição do Algoritmo Split é ter que possuir todas as matrizes que a função depende na parte esparsa, pois o método não acessa a parte estruturada.
Ter identidades na parte esparsa implica que muitos AUNFs serão potencialmente criados sem necessidade, pois os escalares que compõem o AUNF não são alterados quando multiplicados por os elementos das matrizes identidade.
Já na parte estruturada, duas opções são possíveis, manter a lista de matrizes dependentes nessa parte (essa lista é criada a partir de os parâmetros da função) ou então enviar- las para a parte esparsa que pre-computará os AUNFs necessários.
Também pode- se deixar apenas a matriz onde a função está definida e deixar apenas as identidades na parte estruturada.
Essa abordagem auxilia a execução do Algoritmo Split, sendo similar ao caso clássico onde as identidades estão na parte estruturada.
No caso de as permutações, dada a natureza de cada termo tensorial, existem muitas formas de se reordenar suas matrizes internas, compostas por diversos tipos e esparsidades.
A busca é orientada por a descoberta de uma maneira razoável de se reorganizar cada termo tensorial, minimizando o tempo a ser gasto para solução o modelo.
Para permutar um termo tensorial e obter uma ordem de posicionamento é necessário calcular novos índices referentes aos deslocamentos que serão utilizados no algoritmo de MVD para que ocorram os saltos apropriados na estrutura tensorial.
Esse reposicionamento faz com que o método seja executado como anteriormente, mas acessando os elementos da estrutura de outra forma, no caso, permutada.
Estes custos de recálculos de índices são negligenciáveis, pois são calculados apenas na primeira vez que o processo é executado e são utilizados sistematicamente para cada iteração.
O problema da reordenação é descobrir um posicionamento ideal que, quando combinado com o ponto de corte, auxilia na diminuição do tempo requerido para solucionar um modelo e retornar o vetor de probabilidade estacionário ou transiente, dependendo da análise.
Cada termo tensorial pode ser reorganizado de uma maneira diferente, devido principalmente aos elementos que o compõem.
Este reposicionamento pode levar em consideração quando será executado o Algoritmo Split, de acordo com a memória disponível do sistema, a esparsidade do termo tensorial, o número de identidades e o número de matrizes que serão vistas como os argumentos da função para termos generalizados.
Discussão A Tabela 5.1 mostra um comparativo das complexidades de cada escolha do ponto de corte de termo tensoriais para o Algoritmo Shuffle e para o Algoritmo Split.
Só multiplica a matriz se esta não é uma identidade método normal i $= 1 nz i nzi -- 1)+ ni × i $= 1 i $= 1 ni Custo para calcular um AUNF e executar Algoritmo Shuffle Complexidade Split identidades na parte estruturada i $= 1 ni nzi -- 1)+ i $= 1 Trata- se do custo para se calcular e multiplicar os AUNFs identidades na parte estruturada i $= 1 nzi ni i $= 1 Mesmo que o anterior, mas AUNFs são precalculados avaliações na parte esparsa avaliações na parte estruturada avaliações na parte esparsa, identidades na parte estruturada As avaliações de funções dependem da quantidade de parâmetros necessários, ie, o número de autômatos que são necessários para o cálculo da complexidade.&amp;&amp;&amp;
Custo de avaliação negligenciável, dependendo da definição da função, mais custo do Algoritmo Split Avaliam-se as funções na parte estruturada, mais custo do cálculo dos AUNFs Em este caso, todas as avaliações são feitas na parte esparsa e o Algoritmo Shuffle não é executado, pois só existem identidades na parte estruturada No caso de o Shuffle, tem- se a complexidade do método e a otimização das matrizes identidade.
Para a complexidade do Split, tem- se outras possibilidades, tais como execução do método avaliando- se funções na parte esparsa e na parte estruturada e, também, seu efeito direto no número de multiplicações.
Nota- se que o melhor custo computacional teórico foi obtido quando, independente do termo ser classificado como clássico ou generalizado, as avaliações de funções são feitas apenas uma vez na parte esparsa, permutando- se as matrizes identidade para a parte estruturada sempre que possível, caso a memória disponível permita.
Em esse caso, as multiplicações necessárias são apenas as que dizem respeito ao cálculo dos AUNFs e sua multiplicação por o subespaço à direita de no vetor, deixando a parte estruturada sem precisar ser executada, pois as matrizes restantes são identidades.
Observa- se ainda que o grau de dependência, ou seja, o GDC e o GDG constituem- se numa métrica relevante para inspeção das características dos termos tensoriais obser-vando- se apenas os eventos sincronizantes e as funções existentes.
Estes graus afetam diretamente no tempo de execução, pois estão relacionados a questões númericas de eficiência, devido a o número de multiplicações exigido e aos saltos que são dados quando as matrizes são do tipo identidade.
A o se avaliar as funções apenas uma vez, reordena- se o termo tensorial e deixa- se todas as identidades para a parte estruturada é que foi encontrada uma nova forma de perceber o termo tensorial e considerar- lo esparso, ou seja, de execução extremamente rápida, sem precisar chamar as operações da parte estruturada e gastando uma memória extra razoável.
Para tanto, deve- se considerar o papel que os eventos possuem nos descritores Markovianos.
São os eventos relacionados aos termos tensoriais que ditam como o Algoritmo Split irá se comportar na sua execução.
Eventos que dependem de muitos autômatos para fazer uma transição ditarão o tamanho dessa nova matriz esparsa que é implicitamente construída.
A seguir é apresentada a ferramenta GTAexpress e detalhes da sua operação.
Este capítulo descreve a ferramenta GTAexpress cujo objetivo é trabalhar com descritores Markovianos, fornecendo os mecanismos para sua descrição e solução.
Uma das vantagens de se utilizar tais representações é a possibilidade de definir sistemas com uma descrição alto-nível.
Os modelos mais adaptados são compostos por partições, componentes, módulos, processos, autômatos ou qualquer outra nomenclatura estruturada de definição de sistemas.
A GTAexpress implementa o Algoritmo Split, adicionando modificações (de acordo com a Seção 4.4.3) para tratar com descritores generalizados.
A ferramenta permite configurar as estratégias estudadas nesta tese para dividir termos tensoriais de descritores Markovianos em dois blocos distintos, esparso e estruturado.
Também possibilita a escolha de métodos iterativos de solução como, por exemplo, o Método da Potência, para efetuar a MVD.
A principal ideia da ferramenta é trabalhar genericamente com tais estruturas tensoriais, permitindo que outros formalismos estruturados, além de SAN, usem suas funcionalidades.
Para um uso efetivo da ferramenta, assume- se que os modelos construídos possuam características de composição e interação entre suas subpartes.
A implementação da GTAexpress foi realizada no ambiente de desenvolvimento PEPS[ PLA88, BEN03a, BRE07], trabalhando com análise, permutação e divisão dos termos tensorias em duas partes distintas, denominadas parte esparsa e estruturada.
O Algoritmo Split foi estendido para tratamento de taxas funcionais e suporte a permutações de matrizes como uma estratégia para melhorar o desempenho do método de MVD.
Este Capítulo está organizado da seguinte forma:
Inicialmente, na Seção 6.1 será explicada a motivação e os detalhes pertinentes da ferramenta, seguido de explicações da formação de descritores Markovianos na Seção 6.2.
Em a Seção 6.3 serão explicados como modelos advindos de diferentes formalismos estruturados podem ser definidos através de descritores Markovianos para, na Seção 6.4, exemplificar como usar a GTAexpress, alterando as configurações propostas.
O capítulo encerra- se na Seção 6.5 com uma discussão sobre a ferramenta.
Abordagem tensorial de armazenamento A ferramenta GTAexpress foi construída para solucionar descritores generalizados (com ATG) usando o Algoritmo Split, que trabalha com a divisão de cada termo tensorial, correspondendo a um evento na realidade descrita, em duas partes distintas:
Uma parte esparsa e uma parte estruturada.
Esta abordagem híbrida reune as vantagens dos algoritmos Esparso e Shuffle (de acordo com a Seção 4.4), numa única proposição.
A o separar os termos tensoriais, aproveita- se o fato que os eventos que compõem um modelo normalmente não envolvem, ou não interferem, em todas, ou na maioria, das entidades, módulos ou componentes.
A o afetar, ou sincronizar, apenas alguns módulos, propicia- se a criação de matrizes do tipo identidade no termo tensorial para representar que o evento não ocorre nos outros componentes.
Esse aspecto é explorado por o Algoritmo Split que utiliza a propriedade da pseudo-comutatividade da Àlgebra Tensorial re-estruturando os termos tensoriais, conforme explicado na Seção 5.2.
A principal vantagem de se trabalhar com descritores tensoriais é não precisar alocar a matriz de transição que descreve a evolução do sistema através das taxas de mudanças entre estados.
Dependendo do modelo sob análise, esta matriz onera substancialmente a memória necessária para representar as transições do sistema.
Um formato tensorial gera esta matriz de forma implícita usando as propriedades da Àlgebra Tensorial.
A proposição de descritores tensoriais para avaliação de desempenho existe desde as definições iniciais de Redes de Autômatos Estocásticos (SAN).
Entretanto, outros formalismos estruturados também usaram tais primitivas para descrever seus modelos.
Exemplos de tais formalismos, além de SAN, são as Redes de Petri Estocásticas Generalizadas Superpostas (e frameworks para decomposição de Redes de Petri Generalizadas para Redes de Autômatos Estocásticos), PEPA e Redes de Filas de Espera também são conhecidas na literatura em Avaliação de Desempenho.
As ferramentas que tratam destes formatos são igualmente conhecidas e exemplos são PEPS (para SAN), SMART (para Redes de Petri) ou PEPA Eclipse Plug-in (para PEPA).
Uma desvantagem das traduções entre formalismos é devida à necessidade de precisar trabalhar com formatos tensoriais específicos para cada descrição.
A ideia básica da GTAexpress é preencher esta lacuna ao auxiliar os modeladores a definir seus sistemas de forma que possam ser transcritos sob formas tensoriais e, posteriormente, ajudando a analisar e extrair índices quantitativos de desempenho ou sobre a operação do sistema.
Cabe ressaltar que o principal destaque da GTAexpress ao ser comparado com as outras ferramentas é tratar com descritores clássicos e generalizados de forma otimizada.
O uso de taxas funcionais aumenta as possibilidades de descrição de um formalismo estruturado ao mesmo tempo que simplifica o número de termos tensoriais necessários (ao reduzir o número de eventos, por exemplo), implicando diretamente no tempo envolvido para a solução.
Por exemplo, sabe- se que a ferramenta SMART só trabalha com Álgebra Tensorial Clássica e que a ferramenta PEPA Eclipse Plug-in não realiza a multiplicação vetor-descritor, existindo uma definição teórica sobre uma forma de se traduzir modelos de PEPA para descritores Markovianos.
A principal diferença entre a ferramenta PEPS e a GTAexpress é devida ao fato que a primeira não implementa o Algoritmo Split.
A implementação da ferramenta GTAexpress é baseada em dois eixos:
1) na definição e construção de descritores tensoriais válidos para a extração de índices de desempenho de sistemas através da proposição de um formato padrão simples de usar e 2) na execução dos algoritmos de MVD (para ATC e ATG) com o Algoritmo Split e re-estruturação (transparente aos usuários) dos termos tensoriais.
O formato de entrada proposto por a GTAexpress está baseado na linguagem eXtensible Markup Language (XML), já usada em Redes de Petri, através da Petri Net Markup Language (PNML).
Os modeladores dos sistemas devem se preocupar apenas em como compor um sistema (usando módulos, autômatos, ou qualquer outro nome para decomposição) e informar seus comportamentos, de forma individual ou sincronizada entre os demais módulos ou componentes.
Estas primitivas simples serão usadas para a construção do descritor Markoviano.
Como o objetivo é generalizar ao máximo a descrição que corresponde ao funcionamento de um sistema, serão utilizados ao longo de o capítulo uma nomenclatura padrão como, por exemplo, rótulos para decomposição de sistemas.
Serão utilizados os seguintes nomes:
Módulos, partições, componentes, autômatos ou processos para corresponder as formas existentes de descrever um sistema através de partes distintas e indivisíveis, capturando os comportamentos independentes e dependentes entre si.
A seguir é mostrado como se construir descritores Markovianos para posterior execução na ferramenta GTAexpress.
Descritores Markovianos Esta seção mostrará uma proposta para a composição de descritores Markovianos e seus principais elementos dentro de a Ferramenta GTAexpress.
Inicialmente serão descritas as partes constituintes de um descritor, tais como:
Todo modelo estruturado é composto por um número N de módulos, componentes, processos, autômatos, ou outra nomenclatura a ser utilizada para decompor um sistema em partes1, similar à utilização de métodos do tipo divisão-e-conquista;
I) i) Cada estado sj apresenta uma ou mais transições para outros estados, de acordo com uma taxa de ocorrência associada;
Uma transição possui uma lista de eventos que ocorrem de forma independente (L eventos locais) ou sincronizada com outros módulos (E eventos sincronizantes);
A o utilizar o mesmo nome de evento para transições pertencentes a módulos distintos, esta será internamente classificada como sendo do tipo sincronizante, caso contrário, será do tipo local (parcial ou total, explicado a seguir);
O espaço de estados de um modelo estruturado é composto por o produto cartesiano de todos os estados locais de todos os módulos, formando o Produto do Espaço de Estados (PSS);
As transições entre os estados dos módulos ocorrem de três formas distintas:
­ Transições completamente locais:
Tratam- se de transições que ocorrem num componente e não são afetadas nem afetam outros módulos;
As transições dentro de cada módulo são representadas por matrizes cuja dimensão é o número de estados e seus elementos internos são as taxas de ocorrência, afetadas ou não através do uso de diretivas funcionais.
Por exemplo, pode- se usar uma taxa funcional, que observa o estado de outro módulo, para definir (configurando um teste que retorna um valor lógico diferente de falso, ou seja, uma taxa maior que zero) ou não (valor lógico igual a falso, ou seja, zero) uma transição entre estados.
Um descritor Markoviano é composto por somas de produtos tensoriais composto por N matrizes cada.
O descritor é formado por matrizes com as taxas dos eventos locais (completa ou parcialmente) e por matrizes para representar os eventos sincronizantes, sendo necessárias operações de somas tensoriais e produtos tensoriais entre estas matrizes de transição, respectivamente.
Como a operação da soma tensorial é vista como produtos tensoriais com matrizes identidade, um descritor é composto por somas de produtos tensoriais, e o total destas somas equivale a quantidade de eventos sincronizantes e matrizes locais de autômatos com comportamentos independentes em cada modelo.
A Tabela 6.1 mostra as divisões existentes num descritor, divididas entre locais e sincronizantes, com parte positiva e a adequação da sua parte negativa (os ajustes da diagonal, conforme explicado na Seção 4.3).
A tabela mostra produtos e somas tensoriais generalizadas, ou seja, pressupõe que taxas funcionais estão sendo utilizadas.
I) A tabela mostra N matrizes Ql que representam as transições que afetam apenas um dos N elementos, i.
e, a parte local.
Cada uma destas matrizes é composta por um conjunto de N -- 1 matrizes do tipo identidade que representam que outros componentes não são afetados i) por a ocorrência das transições locais.
A Tabela 6.1 mostra 2E conjuntos de N matrizes Qek que representam E transições com sincronizações entre elementos, i.
e, a parte sincronizante do descritor.
Cabe ressaltar que cada transição sincronizante ek necessita dois conjuntos de matrizes:
O primeiro i) contendo sua ocorrência nos módulos (Qe+) e o segundo representando o ajuste da sua diagonal i) (Qe-), como mencionado anteriormente.
Dependendo do evento a ser observado, dependendo de quantos outros módulos este afeta, tem- se matrizes do tipo identidade para representar que o módulo não altera o seu estado local com este dado evento.
Esta consideração é crucial para o desempenho de algoritmos como o Split, que se aproveita deste fato para acelerar o processo de MVD, conforme Seção 4.4.3.
A seguir, são mostradas as regras para criação e definição de descritores válidos usados por a GTAexpress.
Como exemplificado ao longo deste capítulo, o uso de descritores Markovianos é incentivado devido principalmente aos ganhos de memória ao se armazenar pequenas matrizes com operações algébricas tensoriais entre si ao invés de salvar um Gerador Infinitesimal completo.
Esta vantagem fez com que outros formalismos definissem seus próprios formatos.
Entretanto, observando as etapas em comum entre as definições usadas para PN, PEPA, SAN e Redes de Filas de Espera, nota- se que existe um conjunto específico de generalidades, descrito a seguir.
Essas etapas podem ser utilizadas para definir descritores Markovianos em geral e também podem ser usadas, sem perda de generalidade, para descrição de diversas outras realidades ou traduções de outros formalismos estruturados que forneçam representação tensorial.
Estas regras nada mais representam do que a construção de descritores generalizados para inferência de índices de desempenho, confiabilidade ou outras medidas quantitativas sobre o sistema modelado.
Todos os modelos que forem compostos observando- se as etapas definidas acima serão passíveis de serem executados na ferramenta GTAexpress, ou seja, a ferramenta é especializada para tratar com descritores Markovianos.
A próxima seção descreve a arquitetura da ferramenta e os formatos de entrada e saída propostos.
Arquitetura e detalhes da ferramenta A ferramenta GTAexpress foi concebida no contexto desta tese de acordo com as seguintes premissas:
Um modelo estruturado pode ser decomposto de forma genérica e transposto para um formato que representa um descritor Markoviano;
Métodos específicos de MVD são usados para resolver computacionalmente um modelo, calculando os índices de desempenho a serem utilizados na fase de análise.
Diversos formalismos estruturados já propuseram representações tensoriais para seus modelos e possuem regras similares para o correto tratamento dos seus descritores Markovianos.
Com o propósito de estudar as maneiras de se converter um formalismo para sua representação tensorial, tradutores especializados são construídos.
Desta forma, modelagens descritas com primitivas de diferentes formalismos são traduzidos para um formato que descreva um descritor Markoviano.
A falta de regras precisas para efetuar este mapeamento de forma automática e possibilitar a modelagem analítica de sistemas reais com álgebra tensorial é uma lacuna das pesquisas atuais e objeto de inúmeras pesquisas em avaliação de desempenho.
Antes de descrever a proposição para os formatos de entrada e os passos de execução da ferramenta, são necessárias explicações de detalhes de implementação no ambiente PEPS.
Para o Algoritmo Split (com versão estendida para ATG) foi criado um novo método na classe que implementa a MVD clássica, ou seja, o Algoritmo Shuffle.
Para guardar os AUNFs (definição na Seção 4.4.3) necessários para cada modelo é criada, antes da execução e compilação, uma lista de eventos que contém a lista de todos os AUNFs.
O tempo gasto e a memória extra usada para efetuar essa tarefa é salvo internamente para efeitos de estatísticas sobre a execução do método como um todo.
Foram implementados também novos métodos para permutar a ordem lexicogrática de cada termo tensorial, movendo os índices de matrizes que correspondem a identidades para a esquerda ou para a direita, de acordo com a estratégia utilizada, entre as demais estratégias.
Por fim, foram alteradas as opções da interface para representar as opções de chamada do novo método de MVD e na opção que mostra as estatísticas da execução da ferramenta.
A versão disponível foi implementada para ser executada na plataforma Linux, entretanto, pode ser compilada num ambiente Windows sem ser necessário alterações no código-fonte.
A seguir serão explicados o funcionamento do formato de entrada proposto, compilação e execução de modelos e formato de saída da GTAexpress.
Como mencionado anteriormente, foi escolhido um formato padrão, já utilizado em outros formalismos para descrição dos seus elementos, baseado na linguagem XML.
O arquivo definido em XML é composto por as seguintes partes (para aumentar a adoção da descrição por outros pesquisadores, o formato encontra- se atualmente definido na língua inglesa):
Properties: São as propriedades do sistema e outras informações que o resolvedor irá utilizar para multiplicar o vetor por o descritor ou testar a convergência.
Exemplos desta parte do arquivo são:
Descrição do nome do modelo e sua operação, informações sobre o autor e quando foi concebido (para propósitos de histórico), tolerância do erro para teste de convergência, método iterativo a ser usado (Potência, GMRES, Arnoldi, etc), tipo de análise (transiente ou estacionária), escala de tempo (contínua ou discreta) ou modo de depuração de mensagens de texto (verbose);
Modules: Define a forma que o sistema foi estruturado, ou seja, suas partes ou subsistemas.
Em esta representação geral, chama- se de módulos mas correspondem a autômatos, processos, partições ou outra nomenclatura composicional.
Em o arquivo XML é possível definir uma lista de módulos, contendo diversos blocos do tipo estado (states);
States: São os estados que o módulo define e possuem dois blocos internos:
1. Bloco gráficos (graphics) podendo conter informações visuais (onde desenhar cada estado na tela) e 2.
Uma lista de transições (transitions) para outros estados de acordo com uma lista de taxas (rates);
Graphics: Informações visuais contendo o tipo da fonte, a cor do estado e o seu posicionamento na tela, usado para representação visual do sistema, quando existir;
Transitions: Compreende o conjunto de transições de um módulo;
Rates: Correspondem as taxas observadas para cada transição em questão;
Gcc-code: Esta parte corresponde a funções descritas na linguagem de programação C/ C+ que serão adicionadas ao executável da ferramenta GTAexpress em tempo de execução.
Este bloco é um mapeamento para uma taxa constante ou funcional definida no bloco das taxas (rates).
A vantagem de se descrever funções desta maneira é o de permitir que sejam calculadas taxas de forma complexa, tendo a linguagem C/ C+ como base;
Results: Seção que realiza a extração dos índices de desempenho.
Estas diretivas correspondem à Integração de Funções no PEPS e operam sobre o espaço de estados para retornar as probabilidades de permanência em cada estado.
A seguir, mostra- se um exemplo do arquivo XML para um sistema de teste com a definição de duas impressoras (cada módulo corresponde a uma impressora).
Observa- se que para um modelo descrito em XML estar sintaticamente correto, existem bibliotecas que validam o arquivo a partir de um esquema (XML Schema Definition, ou XSD) predefinido.
Uma vantagem de se usar XML para descrever um sistema é a possibilidade de validar arquivos sintaticamente.
Entretando, a semântica dos modelos continua sendo de responsabilidade dos usuários da ferramenta e do esforço gasto para mapear o sistema sob estudo.
Com as informações dos módulos, transições, eventos e taxas contidas no arquivo é possível criar um procedimento que verifica se as transições de cada módulo são disparadas corretamente (não existem transições para lugares indefinidos), entre outras.
A estrutura em árvore do arquivo XML facilita a definição não-ambígua do sistema e fornece uma visão modular do sistema para os modeladores.
A seguir são apresentadas as configurações de entrada, execução e saída da ferramenta.
A ferramenta GTAexpress recebe um descritor (nesta etapa, aproveita- se o fato de que SAN trabalha com descritores Markovianos) e está implementada no ambiente PEPS.
A GTAexpress permite solução estacionária para escala de tempo contínua (CTMC), com o método iterativo de solução conhecido por Método da Potência.
Para tanto, manteve- se as características originais já conhecidas e testadas do ambiente PEPS, acrescentando o Algoritmo Split para solução de descritores generalizados e possibilidades de escolhas das diferentes estratégias.
Para usar o Algoritmo Split é necessário informar previamente ao compilador da ferramenta, que tratará de criar as estruturas de dados necessárias para este fim (criação da lista de valores escalares, ou AUNFs, para cada termo tensorial do descritor do modelo), as permutações necessárias e os valores de corte personalizados (de acordo com a estratégia) para separar a parte esparsa da estruturada.
Caso o modelo seja definido com primitivas de taxas funcionais, o compilador trata de deslocar os parâmetros do termo tensorial com taxa funcional para manter a integridade da função ao retornar a sua avaliação no método (explicado na Seção 5.2.2).
Demonstra- se a seguir cinco passos (de I a V) necessários para a configuração, compilação e execução da ferramenta GTAexpress:
I -- Rodar a ferramenta e a partir de a tela principal, escolher as opções:
4) Preferences 8) Vector-Descriptor:
4) use a Split approach II -- Escolher uma das seguintes 'estratégias' para divisão dos termos tensoriais:
Choose a strategy te o'cut' tensor terms:
1 move identities to shuffle (strategy A) (strategy B) (strategy C) III -- Escolher as opções usuais de compilação do modelo IV -- Escolher a opção de Solução do modelo em questão e executar V -- Inspecionar o arquivo de saída definido em Tim (strategy E) As etapas III e IV correspondem às formas usuais de compilação e solução de SAN, a única diferença encontra- se nas etapas I e II onde escolhe- se rodar a proposta Split de acordo com uma determinada estratégia entre cinco possibilidades (chamadas de A a E).
Uma vez que o modelo foi executado, os índices de desempenho encontram- se no arquivo com terminação.
Tim, no mesmo diretório com o executável da ferramenta GTAexpress.
Para exemplificar esse arquivo de saída, mostra- se a seguir o Modelo Wireless ad hoc com 12 nós.
A letra` i'representa matrizes do tipo identidade e as esparsidades de cada matriz encontram- se à esquerda do símbolo`|':
File ad12c.
Tim ad12c User name:'
Ad' 236196 states Reachable state space:
Modules sizes:
Use a Split approach (method S) The multiplication method The strategy te o'cut' the tensor terms:
Extended (E) Probability Vectors Chosen cuts:
SYN Term: Evt.
1| i i i 1 1| i 1 1 1| i 1 1 1| i 1 1 1| i 1 1 1| i 1 1| i 1| i i i i Time needed to generate the AUNFs list:
0 seconds CPU average time per iteration:
0.0557882097437718 seconds Total CPU time:
Largest element: Smallest element:
Residue after convergence:
9.995410057229764 e-11 t_ MN_ 1_ T:
0.2952493701621532 t_ MN_ 2_ I:
0.521105375648411 A parte de resultados mostra as permutações que foram realizadas para cada termo tensorial (SYN Term:), informações sobre o corte e sobre o número de AUNFs (memória extra gasta) para a execução do método, tempo para geração da lista de AUNFs, número de iterações executadas até a convergência.
São igualmente mostradas as informações sobre a execução, tais como número de eventos, tipos de eventos, tempo médio por iteração e método iterativo utilizado.
A seção de Results do arquivo de saída mostra as probabilidades de permanência nos estados, escolhidos por o modelador.
Discussão Os primórdios da definição de SAN trataram de descrever um sistema através de módulos, os quais na época foram chamados de autômatos.
As interações entre os autômatos foram descritas através de primitivas de sincronização a partir de a atribuição de taxas constantes ou funcionais às transições entre os estados.
A proposta da ferramenta GTAexpress é a de definir uma nova abstração para a composição de sistemas para cálculo computacional de índices de desempenho.
A ferramenta baseia- se fundamentalmente na execução do Algoritmo Split, que re-estrutura os termos tensoriais para tirar proveito da otimização das matrizes identidade (dependendo do caso) e executar cada passo do método iterativo de forma mais rápida.
Quanto a a modelagem, a GTAexpress facilita a descrição de realidades, pois deixa aos modeladores a tarefa de abstrair o problema pensando apenas na estruturação do sistema e como cada parte se comunica.
Estas primitivas possibilitam a construção de descritores Markovianos para extração e análise dos índices de desempenho.
Internamente, dadas as descrições realizadas por os usuários, a ferramenta detecta o nível de interação entre os componentes e auxilia na escolha de uma estratégia para execução do Algoritmo Split.
Este, por sua vez, divide cada termo tensorial e minimiza a memória extra gasta e o tempo por iteração necessário (conforme Capítulo 5) de acordo com a estratégia.
Cabe ressaltar que os diferentes formalismos estruturados possuem conjuntos próprios de definição e solução.
O fato de não gerar a matriz de transição correspondente à MC subjacente atrai pesquisas para o mapeamento de formatos tensoriais para os diversos formalismos.
Entretanto, somente SAN trabalha com primitivas avançadas de modelagem, tais como taxas funcionais.
Com a ferramenta GTAexpress, espera- se que outros formalismos possam aproveitar as ideias aqui descritas e usar os métodos disponíveis para investigação de propriedades quantitativas de sistemas.
O objetivo da proposta de uma descrição genérica ou formato de entrada para a ferramenta GTAexpress é o de prover mecanismos que permitam que modeladores abstraiam seus sistemas estruturadamente e que usem o software para efetuar a MVD.
O presente capítulo propôs um formato padrão descrito na linguagem XML, objetivando traduções e mapeamentos para outros formalismos estruturados.
O próximo capítulo apresenta os resultados numéricos obtidos através da utilização da ferramenta GTAexpress.
Este capítulo aborda os resultados numéricos obtidos para um conjunto de experimentos e modelos.
Em a Seção 7.1 são definidos os experimentos e as considerações iniciais.
Cada modelo é apresentado seguido dos seus resultados, comparando- se os experimentos em termos de os ganhos obtidos na Seção 7.2.
A Seção 7.3 mostra um estudo de caso para o modelo das Redes Wireless ad hoc para, na Seção 7.4 discutir os ganhos obtidos para os algoritmos de MVD executados.
A Seção 7.5 mostra o algoritmo proposto para determinação de ponto de corte para descritores Markovianos.
O capítulo é finalizado com análises e questionamentos sobre os experimentos na Seção 7.6.
Experimentos O objetivo da definição dos experimentos deste capítulo é testar os efeitos das características dos termos tensoriais verificando o desempenho da solução numérica do Algoritmo Split.
Desejase descobrir os experimentos com os melhores tempos para uma iteração com a execução dos métodos de MVD, comparando- os para a mesma classe de modelos com descritores clássicos (ou generalizados) e com (ou sem) permutações das ordens originais (lexicográficas) das matrizes.
Em a Tabela 7.1 são apresentados nove experimentos mapeados para execução dos modelos.
A base de comparação é o método usual de solução baseado no Algoritmo Shuffle, de acordo com os Experimentos 2 4 e 9.
As experiências foram executadas variando- se as possibilidades de avaliação de funções e re-estruturação das matrizes identidade dentro de os termos tensoriais.
Para avaliar o custo da permutação das matrizes dos termos tensoriais foram criados os Experimentos 2 e 4 para o Algoritmo Shuffle e Experimentos 1 e 3 para o Algoritmo Split.
Para o caso do Experimento 3, o ponto de corte escolhido é na última matriz constante do termo tensorial.
O Experimento 8 calcula o custo das avaliações de funções, pois deixa apenas a matriz que contém o elemento funcional e as matrizes identidade na parte estruturada e somente as matrizes constantes na parte esparsa do termo.
Os experimentos foram mapeados a partir de a análise teórica conduzida na Seção 5.3.
Os estudos efetuados indicaram a necessidade de se testar os diferentes métodos de MVD permutando- se o termo tensorial e dividindo- o de acordo com as suas dependências funcionais e outras características, tais como os tipos das matrizes e as suas esparsidades.
Os exemplos aqui descritos possuem eventos sincronizantes com taxas funcionais para o caso generalizado onde também foram devidamente convertidos para o seu modelo correspondente clássico (ATC).
O objetivo desta conversão é o de verificar em quais casos é satisfatório traduzir descritores baseados em ATG para ATC, apesar de o aumento do número de eventos no termo tensorial. (
O3) e linking dinâmico para as funções dos descritores generalizados.
Estão sendo comparados o Algoritmo Split e o Algoritmo Shuffle com permutações para os Experimentos 1 2 5 6 7 8 e 9 e sem reordenamentos para os casos 3 e 4.
Foram computados os tempos de execução com intervalos de confiança de 95% para 50 execuções sequenciais com 25 iterações cada (para o valor do tempo coletado foi calculado o tempo médio de execução do método considerando- se este número de iterações).
Serão apresentadas tabelas contendo os resultados obtidos para os diversos modelos.
Estas tabelas de resultados mostram o nome do modelo em questão (coluna Modelo), o seu PSS (espaço de estados produto) e uma divisão entre as informações relativas aos AUNFs, informações relativas ao tempo de execução (em Tempos) e ganhos comparando- se sempre dois experimentos (no caso, o ganho será calculado da seguinte maneira, a última coluna dividida por a anterior).
Em a parte relativa aos AUNFs, tem- se ao total de escalares e índices para o experimento em questão (sempre será executado um experimento para o Algoritmo Split e outro experimento para o Algoritmo Shuffle), a sua memória extra (coluna Mem.
­ apenas para o Algoritmo Split), descrita em Kilobytes (Kb) e o tempo necessário para computar a tabela com os AUNFs, realizado apenas uma vez em todo o método de solução, na coluna Cálculo.
O tempo dos experimentos são mostrados nas colunas correspondentes, medidos em segundos (s), mostrados na tabela com o seu intervalo de confiança de 95% correspondendo à média de uma iteração do Método da Potência fornecido Compiler Collection.
Cabe ressaltar que os modelos variam o número de autômatos que os compõem, de forma incremental.
Em casos específicos, como os modelos de Redes Wireless ad hoc e Mestre-Escravo, a definição original do descritor generalizado foi explicitamente mapeada para o seu correspondente clássico em termos de solução numérica.
Modelos A existência de benchmarks para testes ainda é insuficiente em análise numérica de sistemas de avaliação de desempenho.
Em o contexto deste trabalho, todos os testes foram executados para uma lista de modelos para SAN (alguns tradicionais, como Compartilhamento de Recursos (Resource Sharing) e outros provenientes de modelagens de uma arquitetura Mestre-Escravo (master-Slave) e Redes Wireless ad hoc.
As tabelas em cada subseção comparam as diferentes estratégias de divisão dos termos tensoriais, de acordo com os experimentos.
Os demais modelos que compreendem essa seção definem o problema do Jantar dos Filósofos, First Available Server, Alternate Service Patterns, Non-Uniform Memory Access, Open Queueing Network (Rede de Filas de Espera Abertas) e duas realidades convertidas do formalismo PEPA:
Workcell e WebServer (maiores informações na Seção 2.5).
A seguir, uma breve explicação de cada modelo seguido dos resultados obtidos para todos os experimentos acima definidos.
O modelo SAN definido na Figura 7.1 refere- se à implementação paralela do Algoritmo Propagation com comunicação assíncrona através do paradigma Mestre-Escravo.
Este modelo é responsável por indicar aos desenvolvedores de aplicações paralelas os gargalos e problemas de configurações existentes antes do início da fase de implementação.
Este modelo contem três estruturas particulares:
Um autômato denominado Mestre, um autômato que representa um Buffer (uma região temporária de armazenamento) e S autômatos Escravos, aqui denominados por Slavei), O número total de autômatos para este modelo é dado por (S+ 2) (onde S é o número de Escravos no modelo), o qual possui S eventos locais e (3 S -- 3) eventos sincronizantes para o caso de descritores clássicos e o mesmo número de autômatos mas (2 S+ 3) eventos sincronizantes para o caso dos descritores generalizados.
Isso faz com que descritores baseados em ATC possuam termos tensoriais e descritores ATG (4 S+ 6) termos.
Algoritmo Shuffle executa mais rápido inclusive que sua versão com permutação, mostrando que o uso de reordenamentos está relacionado ao modelo e as suas características internas.
Modelo slaves05c slaves06c slaves07c slaves08c slaves10c Total slaves05c slaves06c slaves07c slaves08c slaves10c Mem. (
Kb) Cálculo (s) Tempos (s) ­ 1 iteração Experimento 1 Experimento 2 Experimento 3 Experimento 4 Ganho A Tabela 7.3 mostra os resultados para os Experimentos 5 6 7 8 e 9.
Esta classe de modelos mostra a escalabilidade dos algoritmos, pois a cada incremento de dois escravos, tem- se um aumento aproximadamente 10 vezes em relação a o tempo necessário e à memória adicional gasta usando o Algoritmo Split.
O melhor tempo foi verificado para o Experimento 6, que fornece uma boa relação custo/ benefício em comparação com o Experimento 7, que gasta um pouco mais de memória e tempo.
Para o caso de 10 escravos, onde o PSS é elevado, verifica- se que com 79 Mb de memória tem- se um ganho de aproximadamente três vezes em relação a a base de comparação do Experimento 9.
Constata- se que esta memória gasta é negligenciável pois a plataforma de execução tem 4 Gb de memória RAM.
Mem. (Kb) Tempos (s) ­ 1 iteração Experimento 5 Experimento 9 Modelo slaves05f slaves06f slaves07f slaves08f slaves10f Total slaves05f slaves06f slaves07f slaves08f slaves10f Experimento 6 Experimento 9 slaves05f slaves06f slaves07f slaves08f slaves10f Experimento 7 Experimento 9 slaves05f slaves06f slaves07f slaves08f slaves10f Experimento 8 Experimento 9 Cálculo (s) Ganho Pode-se comparar o mapeamento em tempo de execução do descritor baseado em ATG para descritor ATC, uma vez que as funções estão sendo avaliadas na parte esparsa para o experimento que executou mais rapidamente (Experimento 6).&amp;&amp;&amp;
Para esse caso, a tradução de ATG para ATC e utilização do Algoritmo Split não implica necessariamente num ganho substancial, pois, para o caso de 10 escravos, o tempo para o modelo clássico é de 4,18 segundos e para o modelo generalizado é de 4,25 segundos.
Comparando- se o Experimento 1 e 9 percebe- se que essa conversão já é mais interessante, pois tem- se 16,11 segundos para o caso clássico e 13,38 segundos para o caso generalizado.
O modelo SAN descrito na Figura 7.2 representa uma cadeia de nós móveis numa Rede Wireless (de forma ad hoc) executada sobre o padrão 802.11 e definida com taxas funcionais.
Este modelo é uma adaptação do experimento de uma rede ad hoc presente em.
A cadeia tem N nós que se movimentam, onde o primeiro é chamado MN 1) (autômato Source) que gera pacotes de acordo com as definições de um padrão de comunicação.
Os pacotes são enviados através desta cadeia por autômatos do tipo Relay chamados de Mn i), onde i varia entre 2 e, até chegar ao último nó que foi chamado de Mn N) (ou autômato Sink).
Os modelos SAN aqui descritos possuem genericamente (N -- 2) eventos locais e N eventos sincronizantes para descritores contantes.
Em esse caso, existem termos tensoriais.
Para o caso de descritores generalizados, tem- se (N -- 2) eventos locais e igualmente N eventos sincronizantes com N termos.
Este modelo foi aumentado para refletir um maior número de nós numa rede com 10 12 14 e 16 nós.
A Figura 7.3 mostra um modelo com um descritor Markoviano baseado em ATC de uma Rede Wireless ad hoc com quatro nós que foi traduzida da correspondente rede original que utilizava definições de descritores baseados em ATG.
Observa- se que para essa classe de modelo existem mais eventos sincronizantes no descritor clássico devido a a conversão dos elementos funcionais em sincronizações.
A Tabela 7.4 informa os resultados obtidos para os Experimentos 1 2 3 e 4.
Observa- se que Experimento 1 obteve o melhor desempenho com um ganho de aproximadamente sete vezes em relação a o Experimento 2.
A tabela também mostra que as permutações impactam de forma considerável a memória extra utilizada e, para este caso, no tempo.
Nota- se que as matrizes dos termos tensoriais foram reordenadas de forma a otimizar por completo a geração de AUNFs Cálculo (s) Tempos (s) ­ 1 iteração Experimento 1 Experimento 2 Experimento 3 Experimento 4 Ganho 16 para o maior caso, com 16 nós), refletindo no melhor tempo obtido.
Também evidenciou que não necessariamente o uso de mais memória implicará numa melhor execução do Algoritmo Split.
No caso de o Experimento 3, foram gastos 116 Mb e ainda assim o tempo foi superior ao constatado no Experimento 1.
Modelo Mem. (
Kb) Cálculo (s) Tempos (s) ­ 1 iteração Experimento 5 Experimento 9 Ganho ad10f ad12f ad14f ad16f Total ad10f ad12f ad14f ad16f Experimento 6 Experimento 9 ad10f ad12f ad14f ad16f Experimento 7 Experimento 9 ad10f ad12f ad14f ad16f Experimento 8 Experimento 9 A Tabela 7.5 exemplifica os resultados para os Experimentos 5 6 7 8 e 9 para o caso dos modelos com descritores generalizados.
Em o Experimento 5, tem- se a avaliação das funções na parte estruturada.
Nota- se, em relação a o Experimento 9, um ganho de aproximadamente 2,6 vezes.
Para este caso, foi utilizado por volta de 40 Mb de memória extra no Algoritmo Split para o caso dos 16 nós, um valor muito superior ao requerido por os demais experimentos.
No entanto, apesar de ambos os Experimentos 6 e 7 utilizarem a mesma quantidade de memória, executam em tempos completamente diferentes.
Esse fato pode ser explicado por a existência de matrizes do tipo elemento no descritor, que, como mencionado anteriormente, estas matrizes não aumentam o número de AUNFs necessários e mesmo assim, por deixar apenas identidades na parte estruturada, executam de forma otimizada.
O ganho observado foi o maior constatado em todas as variações de modelos executados, da ordem de 12 vezes mais rápido, para um PSS de tamanho considerado elevado para este caso em questão, ou seja, aproximadamente 19 milhões.
O Experimento 8 avalia as funções na parte estruturada e move as matrizes identidade da parte esparsa para a parte estruturada.
Em a parte estruturada só existem matrizes funcionais ou identidades.
Esse experimento mostra que foram gerados poucos AUNFs, mas mesmo assim, os tempos obtidos foram parecidos aos verificados no Experimento 5.
Esse fato corrobora que a avaliação de funções onera o desempenho da MVD, pois observa- se que, ao avaliar esses elementos funcionais e enviar as identidades para a parte estruturada os ganhos são superiores, como visto no Experimento 7.
Este caso generalizado para 16 nós, precisou de 6,60 segundos para uma iteração, valores ainda superiores aos 4,02 segundos necessários no caso clássico.
Para esses casos, observa- se também que é melhor converter os descritores de ATG para ATC.
No entanto, o Experimento 8 usa uma memória extra baixa, pois precisa no maior caso de apenas 16 AUNFs.
Constata- se que este caso específico das Redes Wireless ad hoc também possui uma outra característica marcante, todos os eventos possuem muitas identidades e todas as matrizes restantes possuem apenas um elemento não-nulo, fazendo com que cada termo produza apenas um AUNF.
Esse é um dos melhores casos para o Algoritmo Split, pois a memória extra gasta é desprezível e o tempo de solução é mais rápido, conforme visto por a execução dos experimentos.
Nota- se que os modelos que seguem essas características resultam num tempo mais otimizado para realizar a MVD.
Observa- se que o Algoritmo Shuffle, apesar de realizar importantes otimizações para as matrizes identidade, ainda é necessário tratar das matrizes esparsas, calculando deslocamentos na estrutura tensorial a cada iteração.
Esta seção apresenta o modelo SAN construído para analisar a disponibilidade de servidores, para N servidores (o modelo é denominado First Available Server).
Cada servidor Ai) pode ser descrito como possuidor de dois estados distintos:
Idle (em espera ­ I i) e Busy (ocupado ­ B i).
Em este exemplo, pacotes que chegam no terminal de servidores bloqueados (ou servers switch block), partem através da primeira porta de saída (ou servidor) que não está ocupada, a única restrição é a de que pelo menos um servidor não esteja bloqueado.
O modelo está definido na Figura 7.4 e pode ser visto como uma ferramenta de análise de um tipo de sistema de filas (por exemplo, ocupação de linhas de call centers).
Cada pacote que chega na fila pode avançar tão logo seja possível que um determinado servidor esteja livre, de acordo com uma prioridade pré-estabelecida, do primeiro ao último servidor (N) e PSS $= 2N estados.
Este modelo está definido apenas com taxas constantes (ATC).
A Tabela 7.6 mostra os resultados para os Experimentos 1 2 3 e 4.
A partir de a tabela observa- se que para esse modelo em particular, não importa reorganizar as matrizes dos termos tensoriais ou cortar na última matriz constante do termo (Experimento 3), pois o método realiza a iteração com uma pequena diferença em tempo.
Outra característica deste modelo é precisar de um número reduzido de AUNFs para executar o método.
Para 20 servidores são necessários 19 AUNFs.
Isso faz com que a memória extra requerida seja negligenciável.
O ganho verificado com o Algoritmo Split frente a o Algoritmo Shuffle foi da ordem de nove vezes em tempo, para a maioria dos casos e sete vezes para os casos onde os termos foram reordenados.
Este modelo está definido apenas para descritores clássicos.
Modelo fas18c fas19c fas20c Total fas18c fas19c fas20c Mem. (
Kb) Cálculo (s) Tempos (s) ­ Experimento 1 1 iteração Experimento 2 Experimento 3 Experimento 4 Ganho Os próximos modelos SAN foram traduzidos a partir de o formalismo PEPA e modelam duas problemáticas distintas:
Células industriais de produção e um servidor para a Internet.
Estes modelos foram traduzidos para redes de autômatos com o objetivo de estudar as características envolvidas na tradução entre estes dois formalismos e as propriedades a serem consideradas neste mapeamento.
O método de tradução aplicado foi o mesmo utilizado na Seção 3.4, adaptado para tratar com modelos PEPA ao invés de PEPA nets.
Para demonstrar a execução de modelos definidos em outros formalismos, foram escolhidos dois modelos em particular, gerados a partir de PEPA.
O primeiro, chamado Workcell, modela células industriais de produção e o segundo define um servidor para Internet de alta disponibilidade, chamado WebServer.
Aqui serão feitas breves explicações sobre o funcionamento geral dos sistemas modelados, maiores informações podem ser encontradas em para, respectivamente, Workcell e WebServer.
Estes modelos foram traduzidos para SAN de forma direta, gerada a partir de a composicionalidade de PEPA observando- se as movimentações nos estados da CTMC.
Esta tradução não é a melhor tradução deste tipo de modelagem, mas mesmo assim, produz os resultados de saída correspondentes à solução PEPA.
O modelo Workcell modela um sistema complexo de uma célula industrial de produção.
O objetivo desta célula é construir placas de metais numa prensa, consistindo dos seguintes componentes principais:
Cintos de alimentação, tabelas rotatórias, robôs, prensas, cintos de depósitos e artefatos de movimentação, para citar alguns componentes do sistema.
O principal objetivo desta modelagem é inferir índices que demonstrem como estes componentes trabalham em conjunto, com vistas a a avaliação de desempenho destes componentes.
Já o modelo WebServer descreve um servidor de alta disponibilidade para Internet, composta principalmente por elementos de notícias.
Este modelo prevê qualidade de serviço em disponibilidade e tempo de resposta.
O objetivo principal deste tipo de modelagem é experimentar com a engenharia de desempenho de aplicações de alta demanda com vistas a a verificação de eficiência de pico, entre outras análises.
O modelo executado aqui, possui quatro parâmetros:
S compreende o número de servidores no sistema, B, denota a capacidade do buffer de memória, R diz respeito ao número de leitores e W ao número de escritores existentes no sistema (como trata- se de um sistema de notícias, as atividades compreendem a leitura e a escrita de materiais).
Para o caso deste exemplo em particular, foi escolhido trabalhar com um modelo com um PSS da ordem de 350.000 estados, com os seguintes parâmetros:
S $= 4, B $= 3, R $= 3 e W $= 3.
Modelo workcell webserver Total workcell webserver Mem. (
Kb) Cálculo (s) Tempos (s) ­ Experimento 1 1 iteração Experimento 2 Experimento 3 Experimento 4 Ganho Estes modelos baseados em PEPA existem apenas sob a forma de um descritor clássico e os seus resultados estão sendo mostrados na Tabela 7.7.
Esta tabela informa o tempo de execução para os Experimentos 1 2 3 e 4.
Para o modelo Workcell, o tempo verificado é bastante similar nos Experimentos 1 e 3 e, quando comparados ao Experimento 2 e 4 atestam um ganho de seis e quatro vezes.
A diferença entre as execuções está na memória extra gasta em cada experimento com o Algoritmo Split.
Enquanto que no a memória é desprezível, no Experimento 3 foi necessário 364 Kb.
Para o caso do WebServer, a melhor execução foi a alcançada por o Experimento 1, sendo nove vezes mais rápido quando comparado ao Algoritmo Shuffle realizando- se permutações.
No caso de se escolher não fazer permutações (Experimentos 3 e 4), o ganho ainda assim é considerável (da ordem de três vezes), mas são necessários 18 Mb para salvar os AUNFs.
Visto que é possível reordenar as matrizes dos termos, não gastar em memória extra e ainda assim ganhar em tempo de execução, esta é uma boa alternativa para a solução deste modelo.
Esta seção apresenta um modelo clássico para avaliação de desempenho para análise de exclusão mútua em compartilhamento de recursos.
O modelo em questão é uma abstração chamada de problema do Jantar dos Filósofos e, resumidamente, pode ser descrita da seguinte forma:
K filósofos estão sentados numa mesa e a eles somente são permitidas duas ações, comer ou pensar.
Os filósofos estão sentados numa mesa circular com uma tela de comida no centro de esta (de acordo com a Figura 7.5 a).
Um garfo Fk está posicionado entre cada filósofo Pk, assim, cada um possui um garfo à sua esquerda e um garfo à sua direita.
Para comer, um filósofo necessita de dois garfos nas suas mãos, simultaneamente (o problema é que não existem recursos suficientes para todos ao mesmo tempo).
O modelo SAN da Figura 7.5b possui K autômatos do tipo P hk) representando os filósofos, cada um com três estados:
T hk) (pensando), Lf k) (pegando garfo da esquerda), Rf k) (pegando o garfo situado à direita).
O filósofo pode reservar o garfo à sua esquerda ou direita para comer utilizando necessariamente dois garfos disponíveis.
Para evitar deadlock fica estabelecida uma ordem para pegar os garfos na mesa, para cada filósofo presente no modelo.
O PSS deste modelo é dado por 3K estados.
Os resultados para o modelo do Jantar dos Filósofos estão mostrados na Tabela 7.8.
Os modelos foram definidos apenas para descritores clássicos, onde variou- se o número de filósofos entre 12 e ele é da ordem de 43 milhões de estados.
Não foi possível computar para este modelo os tempos dos Experimentos 3 e 4 uma vez que foi preciso por volta de 1,2 Gb de memória apenas para armazenar a tabela referente a os AUNFs nos cortes estabelecidos nos experimentos.
Como este modelo é possuidor de muitas identidades, o Experimento 1 mostra claramente o efeito de se passar estes elementos para a parte estruturada do termo:
Apenas 48 AUNFs são necessários para o caso com 16 filósofos.
E esse fato se reflete no tempo gasto para executar uma iteração, onde os ganhos médios calculados ficaram na ordem de quatro vezes, entre os Experimentos 1 e 2, que executaram permutações nos termos tensoriais.
Modelo phil12c phil13c phil14c phil15c phil16c phil12c phil13c phil14c phil15c phil16c Total Mem. (
Kb) Cálculo (s) Tempos (s) ­ Experimento 1 1 iteração Experimento 2 Experimento 3 Experimento 4 Ganho cional de comunicações que ocorrem e, consequentemente, de termos tensoriais.
As variações do número de filósofos do modelo foram chamadas de philK, onde K representa o número de filósofos existentes.
Para o caso de 15 filósofos, por exemplo, foi necessário 423 Mb de memória extra para o Algoritmo Split e o método executou em 9,8 segundos, enquanto que gastando- se por volta de 1 Kb, foi executado em 6,2 segundos.
O modelo do Jantar dos Filósofos, assim como o modelo das Redes Wireless ad hoc evidenciam quando a abordagem utilizada por o Algoritmo Split é mais eficaz que o Algoritmo Shuffle em termos de tempo de execução.
O modelo de Compartilhamento de Recursos (Resource Sharing) trata os casos onde N processos compartilham R recursos.
A Figura 7.6 mostra um sistema de compartilhamento de recursos onde cada processo é representado por um autômato Ai) composto por dois estados:
S i) (dormindo, ou sleeping) e U i) (usando ou using).
Um conjunto de recursos é simbolizado por o autômato AN+ 1) o qual possui R+ 1 estados indicando o número de recursos que estão sendo utilizados.
Este modelo apresenta um conjunto de autômatos em o qual os eventos sincronizantes estão relacionados a apenas dois autômatos cada um.
Isto significa que os termos tensoriais serão compostos por muitas matrizes de baixa esparsidade e igualmente muitas identidades.
Os principais resultados para o modelo do Compartilhamento de Recursos está mostrado na Tabela 7.9.
A tabela mostra as diferentes configurações de redes de autômatos, denominadas rsP_ R que indicam no nome do modelo o número de processos P existentes para R recursos compartilhados.
Verifica- se as comparações entre os tempos obtidos de uma iteração entre os Experimentos 1 2 e 3 4.
Modelo rs14.
10 c rs14.
11 c rs15.
15 c rs20.
25 c Total rs14.
10 c rs14.
11 c rs15.
15 c rs20.
25 c Mem. (
Kb) Cálculo (s) Tempos (s) ­ Experimento 1 1 iteração Experimento 2 Experimento 3 Experimento 4 Ganho A tabela mostra que para o caso onde existem 20 processos para 25 recursos (o nome do modelo é rs20.
25 c), não foi possível computar os tempos devido a o alto custo em memória para salvar os AUNFs, da ordem de 1,6 Gb.
Esta classe de modelos também possui muitas identidades e o experimento que obteve os maiores ganhos foi o Experimento 1, melhor em média três vezes que o Experimento 2, onde foram necessários 31 Kb de memória para guardar os AUNFs.
Este exemplo descreve um sistema de rede aberta composto por quatro filas, representadas por os autômatos 1) 2) 3) 4), com capacidades finitas (K1, K2, K3 e K4) respectivamente.
O padrão de roteamento de consumidores para esse caso, chegam em F1 e F2 com taxa 1 e 2, podendo sair de F1 para F3 se existir espaço (comportamento bloqueante) e também sair de F2 para F3 se existir espaço ou sair do modelo em caso contrário (comportamento de perda).
Os consumidores também podem sair de F3 para F4 com comportamento bloqueante.
Enquanto F1, F2 e F4 possuem comportamento de serviço padrão (no caso, single), i.
e, uma mesma taxa média de serviço para todos os consumidores, a fila F3 possui um comportamento alternado de padrão de serviço (Alternate Service Patterns, ou ASP).
A taxa de serviço para esta fila varia de acordo com P diferentes taxas de padrão de serviço (µ31, de um consumidor.
Isso faz com que quando um consumidor é servido por o padrão Pi, F3 pode permanecer servindo o próximo consumidor no mesmo padrão com probabilidade ii, ou pode alternar para um padrão de serviço diferente Pj com probabilidade ij (para todos os padrões de serviço Pi:
O modelo SAN descrito na Figura 7.7 é composto por um autômato usado para cada fila com serviço simples, 2) e 4) e outros dois autômatos para a fila de padrão de serviço alternado e 5).
O modelo ASP mostra que o melhor tempo encontrado foi correspondente ao Experimento 4, conforme a Tabela 7.10.
Este experimento obteve os melhores índices para uma iteração, quando não são executadas permutações nos termos tensoriais.
A tabela mostra os casos com descritores clássico onde os tempos, apesar de serem parecidos entre os Experimentos 1 e 4, mostram um ganho relativo implicando que a melhor abordagem a ser escolhida nestes casos, é provavelmente a adotada por o Algoritmo Shuffle.
Modelo asp10c asp12c asp14c Total asp10c asp12c asp14c Mem. (
Kb) Cálculo (s) Tempos (s) ­ 1 iteração Experimento 1 Experimento 2 Experimento 3 Experimento 4 Ganho Máquinas Em uma são arquiteturas utilizadas em conjunção com diversos sistemas operacionais.
O próximo exemplo descreve uma modelagem de partes do sistema operacional Linux para ser usado em máquinas Em uma.
O modelo permite uma análise compreensiva de diferentes tamanhos de processos para um número variado de processadores de uma máquina Em uma, generalizando o conceito sobre o comportamento dos processos sob a ótica de um único processo num ambiente multiprocessado.
Esta representação genérica permite que sejam analisadas as chances de um processador falhar, analisa o processo de migração de processos entre os processadores e o funcionamento do escalonador do sistema operacional Linux.
Os eventos internos do modelo Em uma envolvem sempre dois autômatos e cada termo tensorial possui duas matrizes com apenas um elemento não nulo e o resto, matrizes do tipo identidade.
Este fato é verificado por o número de AUNFs que são necessários para armazenamento deste modelo que é igual ao número de eventos existentes.
Observando- se os resultados nota- se que este modelo obteve os melhores ganhos em tempo frente a o Algoritmo Shuffle, da ordem de 17 e 28 vezes para seis e oito processadores.
Foram necessários entre cinco e nove Kilobytes de memória para armazenamento dos AUNFs.
Este adequa- se ao Algoritmo Split pois gasta pouca memória extra com ganhos expressivos.
O autômato Processo da Figura 7.8a representa os processos escalonados para R processadores.
Contém quatro estados:
IO i) (processo está esperando uma operação de entrada/ saída), Ri) (processo encontra- se na fila de &quot;pronto», ou seja, esperando para ser escalonado no iésimo processador), Exi) (representando que o processo está sendo executado no processador correspondente) e Epi) (processo está na fila de processos &quot;expirados», ou seja, terminou sua fatia de tempo e está esperando para ser movido para a fila de processos &quot;prontos&quot;).
Para cada autômato Processador sua execução e não faz mais parte do sistema.
Sendo R o número de processadores de um dado modelo, o seu PSS é dado por.
O número total de autômatos é genericamente dado por, contendo 18 eventos locais e 32 eventos sincronizantes.
O descritor, neste caso, é formado por somas tensoriais com R+ 1 matrizes locais e 64 termos tensoriais produto com R+ 1 matrizes.
Para as execuções sequenciais deste modelo considerado foram utilizados R $= 6 e R $= 8.
Modelo NUMA6c NUMA8c Total Mem. (
Kb) Cálculo (s) Tempos (s) ­ 1 iteração Experimento 1 Experimento 4 Ganho A Tabela 7.11 mostra os resultados obtidos para dois tipos de modelos:
Uma máquina Em uma que descreve seis processadores e outra, oito processadores.
A variação do PSS é de 1 milhão de estados para o caso de seis processadores até 55 milhões para oito processadores.
Este modelo alinha- se ao modelo das Redes Wireless ad hoc quanto a a afetação dos eventos sincronizantes dos descritores clássicos.
Para seis processadores foram necessários sete autômatos e 174 eventos e para o caso de oito processadores, nove autômatos e 312 eventos.
Em termos de memória auxiliar para o Algoritmo Split, gasta respectivamente 5 Kb e 9 Kb, demonstrando que os eventos existentes no modelo afetam poucos autômatos.
A solução usando o Algoritmo Split é favorecida com o uso de permutações e cortes na última matriz constante.
Redes de Filas de Espera Abertas representam filas com comportamentos independentes (do ponto de vista da chegada e saída de clientes de cada fila presente no sistema) e interações com sincronização (considerando- se as trocas de clientes entre as diferentes filas).
Um exemplo de um modelo de filas deste tipo é apresentado na Figura 7.9, contendo duas filas de capacidade três e uma fila com capacidade dois.
O modelo possui uma fila com comportamento bloqueante (para os clientes da Fila Q1) para a Fila Q2) e outra fila com comportamento de perda (para os clientes da Fila Q1) para a Fila Q3).
Modelo oqn1 oqn2 oqn3 oqn4 Total Mem. (
Kb) Cálculo (s) Tempos (s) ­ Experimento 1 1 iteração Experimento 4 Ganho A Tabela 7.12 mostra os resultados obtidos para OQN contendo três filas com capacidade variável2.
O ganho em relação a o Shuffle manteve- se em 1,7 vezes, considerando- se que o descritor possui termos tensoriais de tamanho três e termos com pelo menos uma matriz identidade, o que demonstrou ser adequado na execução do método Split.
O total de AUNFs necessários manteve- se igualmente constante, e o maior exemplo, com filas de capacidade 250 foram necessários 4 Mb para salvar a lista de AUNFs.
O tempo de criação desta lista variou entre 0,2 segundos e 0,6 segundos.
Estudo de caso:
Solução do Modelo Redes Wireless ad hoc Tendo- se em vista os resultados expressivos obtidos no modelo de Redes Wireless ad hoc con-forme explicado na Seção 7.2.2, conduz- se a seguir uma análise mais abrangente das explicações em torno de a eficácia da sua execução.
O objetivo é explicar porque essa classe de modelos executou mais rapidamente que a abordagem Shuffle ao mesmo tempo que utilizou inexpressivas quantidades de memória adicional.
A seguir, um detalhamento do modelo e a estrutura do seu descritor Markoviano clássico e generalizado.
A explicação deste modelo foi iniciada na Seção 7.2.2.
Em a presente seção, será dada uma maior ênfase aos detalhes internos do modelo e as escolhas feitas em termos de modelagem tanto para descritores clássicos como para generalizados.
Este modelo descreve uma rede wireless ad hoc com N autômatos, sendo dois autômatos de dois estados situados nos extremos (um chamado Source e o outro Sink) e N -- 2 autômatos intermediários de três estados situados entre estes (chamados de Relay).
Os estados de cada autômato representam as possibilidades possíveis de troca de estado interno.
O autômato Source somente pode estar transmitindo pacotes ou em modo de espera (idle), sendo representados por os estados T (para Transmitting) e I (para Idle), respectivamente.
O autômato Sink, pode estar em espera ou recebendo (R).
Os demais autômatos possuem três estados, podendo estar em espera, recebendo (R) ou transmitindo (T) pacotes.
O objetivo dos autômatos extremos é modelar um envio de um pacote de Source até Sink.
Para que a comunicação funcione entre as entidades que compõem o modelo, os eventos devem causar a mudança de estado dos autômatos de uma maneira coordenada e sincronizada.
A o ocorrer um evento que deseja enviar um pacote para o autômato Sink, este altera seu estado interno de I para T ao mesmo tempo que o seu autômato &quot;vizinho «do tipo Relay altera seu estado de I para R (em modo de espera para recebendoque observa os estados dos próximos dois autômatos, neste caso, MN 3 e MN 4, e aplica a taxa se ambos são diferentes do estado de transmitindo).
O processo se repete até o autômato Sink mudar seu estado interno de` em espera 'para` recebendo'.
Para escalar o modelo, criam- se mais autômatos do tipo Relay e atualizam- se os eventos para descrever as mudanças de estados coerentemente entre os autômatos.
A Tabela 7.13 mostra as características principais da classe das redes wireless, informando, para cada caso, o espaço de estados (coluna PSS), o número total de autômatos (em automatos), os totais de eventos locais e sincronizantes para descritores clássicos (ATC loc e syn) e totais para descritores generalizados (ATG loc e syn).
A seguir, a coluna (funções) mostra o total de funções para o modelo, finalizando por a última coluna (termos) que indica o total de termos para cada modelo (somando o número de eventos locais com os eventos sincronizantes positivos e negativos).
Este modelo possui a particularidade de possuir um número de eventos sincronizantes equivalentes ao número de autômatos, conforme mostra a tabela.
Note que o último modelo tratável com a ferramenta de solução implementada (GTAexpress) sem o uso de memórias auxiliares em disco (i.
eswapping) é o caso para 17 nós, atingindo um PSS de 57 milhões de estados (o limite atual da ferramenta é de 65 milhões de estados, para uma máquina com 4 Gb).
Como o modelo foi originalmente definido usando- se funções para o seu sistema de transição, a análise começará por o descritor generalizado e seguirá para a conversão das funções em eventos sincronizantes na seção posterior.
As taxas funcionais relativas às transições entre os autômatos foram definidas para reforçar, via eventos sincronizantes, a existência de uma única transferência de dados (ou seja, todos os outros autômatos não estão no estado &quot;transmitindo&quot;).
Essas definições impactam tanto a solução do modelo por MVD quanto na formação do descritor Markoviano correspondente.
A Tabela 7.14 refere- se aos Experimentos 5 a 8, equivalentes à solução de descritores generalizados.
Apenas relembrando, o Experimento 5 realiza as avaliações de funções na parte estruturada e o Experimento 6, na parte esparsa.
O Experimento 7 também avalia na parte esparsa mas, usando o Algoritmo Split, à direita do ponto de corte (parte estruturada) existem somente matrizes do tipo identidade.
O Experimento 8 possui apenas a matriz onde a definição da função propriamente dita está presente e matrizes identidade na parte estruturada.
Em a parte esquerda da Tabela 7.14, mostram- se as permutações de matrizes no descritor, variando de 0 até N, sendo N o número total de matrizes presentes em cada termo.
Em a parte direita, descrevese quantidade total de elementos não-nulos (exclusivamente para esse caso, este valor equivale- se à um) e a ocorrência de matrizes identidade (através da letra` i').
Para cada experimento, mostra- se a ordem escolhida das matrizes e o ponto de corte (aqui exemplificado por o caractere`|') refletido em ambos os lados da tabela.
Em o fim de cada experimento, informa- se o total de AUNFs necessários para o cálculo efetivo da MVD para as diferentes estratégias de corte.
1 1| i i i i i i 1 i i i i i| i 1 1 i i i i| i i 1 1 i i i i| i i i 1 i i i| i i i 1 i i i| i i i 1 i i i| i i i 1 i i i 1 i| i i i 1 i i i 1 i| i i i 1 i i i i 1| i i i 1 i i i i 1| i i 1 i i i i i 1| i 1 A tabela mostra que, para o caso das Redes Wireless ad hoc, ao utilizar descritores generalizados, matrizes do tipo identidade encontram- se na parte esparsa.
Teoricamente, o melhor jeito de se tratar cada termo tensorial é permitir apenas identidades e a matriz que contém a definição do elemento funcional na parte estruturada, gastando apenas 12 AUNFs em memória.
Em outros experimentos, o número de AUNFs necessários é maior, tais como 568 para os Experimentos 7 e 8 e 14.257 para o Experimento 5.
Descritores generalizados não privilegiam a avaliação de funções na parte esparsa, pois forçam muitas vezes que matrizes do tipo identidade permaneçam também neste lado, dado que podem ser parâmetros da função, o que onera a memória e não altera o valor dos escalares que correspondem aos AUNFs.
A o converter o descritor generalizado para clássico, os eventos com taxas funcionais viram eventos sincronizantes.
Em este caso, pode- se escolher usar a estratégia de re-estruturar o termo tensorial de forma que apenas matrizes identidade permaneçam na parte estruturada e compor AUNFs com os elementos não-nulos na parte esparsa.
Esta estratégia não prevê a existência de matrizes identidade na parte esparsa, o que não acontecia no caso de o descritor generalizado.
Logo, pode- se verificar o custo computacional necessário para avaliação de funções dentro de o modelo das Redes Wireless ad hoc e comparar com o mapeamento para descritor clássico.
A seguir, mostra- se como as funções existentes no modelo foram convertidas para eventos sincronizantes.
A definição do modelo de Redes Wireless ad hoc com descritores generalizados mostrou- se oneroso para a utilização do Algoritmo Split, principalmente quando se verificam as tabelas de resultados para ambos os casos descritas na seção anterior (Tabela 7.4 e Tabela 7.5, correspondendo respectivamente aos resultados clássicos e generalizados).
Deseja- se descobrir porque houve uma melhora considerável nos tempos de execução entre ambos os casos.
A detecção das propriedades dos descritores clássicos será fundamental para entender como o Algoritmo Split pode ser usado de forma mais adequada para as classes de modelos que seguirem este tipo de descritores.
A Tabela 7.15 mostra as re-estruturações efetuadas no descritor para os Experimentos 1 e 3 bem como o total de elementos não-nulos nas matrizes de cada termo tensorial, numerado aqui de 1 até 3 não alterou a ordem natural das matrizes (ou seja, não permutou as matrizes), escolhendo o ponto de corte como sendo a última matriz constante (no caso a última não-identidade no termo tensorial).
Este último experimento precisou de um número elevado de AUNFs enquanto que o Experimento 1 precisou de um AUNF por termo tensorial, sendo o caso que apresentou melhor desempenho em tempo para o Algoritmo Split mesmo quando este é comparado ao caso do descritor original generalizado.
A característica mais importante no descritor clássico é que todas as matrizes que não são identidades, são matrizes do tipo elemento, sendo extremamente esparsas.
E ao serem enviadas para a parte esparsa (à esquerda do ponto de corte), produzem um número ínfimo de AUNFs, evitando, na totalidade, os cálculos necessários por a parte estruturada (índices e deslocamentos na estrutura tensorial).
Para este caso específico e, consequentemente, classes de modelos que seguirem estas características, é adequado converter as taxas funcionais para elementos constantes nas matrizes, pois não implica num aumento do número de eventos sincronizantes para estes casos (como é esperado ao efetuar- se uma tradução ATG para ATC).
Esse modelo utiliza pouca quantidade de memória adicional em relação a o Algoritmo Shuffle e executa o processo da MV D6 vezes mais rápido que o modelo equivalente com mesmo tipo de descritor e 1,5 vezes melhor ao ser comparado com o modelo que tem um descritor generalizado (comparando apenas o Algoritmo Split).
O processo da MVD pode ser realizado de diferentes formas, como explicado ao longo de o trabalho.
A escolha de cada algoritmo, Esparso, Shuffle ou Split está relacionado com a memória extra a ser gasta na execução.
Cada diferente maneira implica em diferentes cálculos para determinar o número de multiplicações em ponto flutuante.
Esta seção discute estes cálculos e às influências dos descritores funcionais, dada as restrições existentes quanto a os parâmetros das funções eas relações com a memória.
O Algoritmo Shuffle é eficiente em memória e trata com descritores clássicos e generalizados de forma otimizada.
Entretanto, para o Algoritmo Split, as quantidades de memória extra necessária para guardar partes do descritor estão diretamente relacionadas à escolha do ponto de corte para cada termo tensorial.
Para o Split, a descrição de cada taxa funcional é crucial no processo de MVD pois, dependendo do número de parâmetros e da maneira por a qual foi construída, impactará num maior ou menor nível de memória extra a ser armazenada em estruturas de dados internas3.
Começando a análise por as avaliações de funções, mostradas por os Experimentos 5 6 7 e 8.
A o avaliar elementos na parte esparsa, está- se, na verdade, convertendo- se um descritor generalizado para clássico em tempo de execução do método (no caso, apenas na primeira execução do método iterativo, pois existe a fase de pré-cálculo dos AUNFs necessários).
Entretanto, ao escolher avaliar funções na parte esparsa, dependendo da função, faz com que matrizes identidade sejam movidas para esta parte.
Como é necessário multiplicar toda a listagem dos AUNFs para cada evento por um bloco potencialmente grande (nright, dependendo do ponto de corte), gasta- se um tempo adicional considerável multiplicando- se escalares desnecessariamente pois, no Algoritmo Split, matrizes identidade na parte esparsa oneram a memória (e, em alguns casos, podem inviabilizar a execução do Algoritmo Split).
O problema de se avaliar funções na parte estruturada reside no fato que estas chamadas internas são realizadas diversas vezes, dependendo do número de iterações que são realizadas.
Dependendo da função, estas avaliações são custosas do ponto de vista computacional.
Observa- se então a existência de um tradeoff em descritores generalizados quanto a o local onde serão avaliadas as funções e a memória a ser gasta a partir de esta escolha.
Considerações sobre os resultados A partir de os resultados obtidos percebeu- se as vantagens e desvantagens de cada estratégia utilizada para cada tipo de descritor, clássico ou generalizado.
Para alguns modelos, converter descritores ATC em ATG corresponde a ganhos significativos de desempenho, dependendo do caso.
As tabelas de resultados apresentadas nesta tese mostraram as execuções dos Algoritmos Shuffle e Split para uma iteração do Método da Potência.
A Tabela 7.16 mostra os ganhos observados ao se acelerar o processo de MVD.
A tabela exibe, para os modelos, o número de iterações necessárias para que o método iterativo atinja a convergência, para um conjunto de parâmetros (taxas) pré-estabelecidos.
A partir de o tempo para uma iteração obtido nas tabelas de resultados anteriores, multiplicou- se este valor por o total de iterações (coluna iter.),
obtendo- se o tempo total necessário para que se tenham índices confiáveis de desempenho.
A coluna Tempo para Solução mostra o tempo com escala variável, ou seja, em minutos (min), horas (h) ou dias) que cada método gastou para a convergência, com a escolha da estratégia que 3 Como discutido ao longo de o trabalho, um aumento de memória significativo será observado se uma função for definida com diversos parâmetros que traduzem- se em matrizes identidade no termo tensorial correspondente ao evento, ao mesmo tempo que escolhe- se a estratégia de avaliar funções na parte esparsa, por exemplo.&amp;&amp;&amp;
A coluna Memória mostra, em Kb, a memória adicional necessária para o Split.
Cabe ressaltar que este possui a mesma limitação da ferramenta em termos de memória para armazenar o PSS existente, sendo o valor equivalente a 65 milhões de estados.
Este é o limite existente para ambos os métodos em máquinas com 4 Gb de memória principal.
Em este caso, observa- se que para o caso de 10 escravos, o Split alocou por volta de 79 Mb adicionais.
Entretanto, para 13 escravos, o modelo seria composto por outros três autômatos de três estados, elevando o PSS para| X| $= 7.263.027 × 33 180 milhões de estados.
O caso dos 13 escravos não pode ser executado por nenhum dos algoritmos nesta versão da ferramenta, entretanto, existem técnicas tais como simulação para trabalhar com espaços de estados que ultrapassam a memória principal, e abordar- las está fora de o escopo deste trabalho.
O número de iterações necessárias para cada modelo é dependente das taxas que são utilizadas.
A Tabela 7.16 mostra numericamente a vantagem em se adotar a execução do Algoritmo Split em comparação com a abordagem anterior existente descrito por o Algoritmo Shuffle.
A o se acelerar a solução da MVD a cada iteração esse ganho é propagado por todas as iterações necessárias, resultando num ganho em tempo ao se avaliar a solução como um todo.
O Algoritmo Split permite obter resultados numéricos de forma mais rápida e, consequentemente, antecipando a fase de análise dos modelos estudados.
Excetuando- se o caso Mestre-Escravo, que precisou 80 Mb para 10 escravos, o restante dos modelos obteve um ganho expressivo em termos de tempo para solução dos exemplos onde a memória a ser potencialmente gasta restringiu- se a limites aceitáveis, mostrando que o Algoritmo Split é uma alternativa eficaz de MVD.
Observa- se que diferentes modelos, o método ainda permanece sendo eficaz no armazenamento de dados extra em memória, como mostrado por os dados da Tabela 7.16.
O ganho médio observado ao utilizar o Algoritmo Split foi de 12,8 vezes para os modelos escolhidos.
Para os modelos Em uma e OQN, escolheu- se um total de 10.000 iterações arbitrariamente para efeitos de cálculos, pois os modelos possuem apenas solução transiente.
Entretanto, os modelos executados dificultam a captura de resultados para determinar o custo real de se realizar as permutações.
Permutar as matrizes dos termos tensoriais é indissociável ao Algoritmo Split, mais evidente para o caso de descritores clássicos.
Entretanto, em pelo menos um caso de modelo as permutações não são necessárias e mesmo assim garante- se que apenas matrizes do tipo identidade estejam na parte estruturada, condição necessária para compor uma base de comparação entre uma versão com e sem re-estruturações.
O modelo em questão é o First Available Server (FAS), que contém eventos que não alteram a ordem original ao mesmo tempo que possibilitam cortar o termo tensorial na última matriz constante, deixando apenas matrizes identidade na outra parte.
Para calcular o custo de permutação, executou- se o modelo FAS, com a estratégia onde todas as matrizes identidade encontram- se na parte estruturada.
Os testes foram realizados com implementações com e sem permutação calculando- se o custo envolvido em termos de tempo.
Escolheu- se rodar um descritor clássico pois, para descritores generalizados, as taxas funcionais contém parâmetros que eventualmente forçam permutações, para que os elementos sejam avaliados coerentemente.
A Tabela 7.17 mostra o modelo para 18 19 20 21 22 e 23 servidores, onde cada coluna mostra a versão do Algoritmo Split executada, com ou sem reordem.
Como nos experimentos anteriores, os métodos foram executados 50 vezes onde capturou- se a média para 25 iterações e computou- se o intervalo de confiança de 95%.
Apesar de o aumento constatado da versão sem permutação para a com permutação, para este modelo, o impacto das chamadas internas diminui à medida que o modelo aumenta o número de servidores.
O modelo FAS é o único caso onde é possível realizar estes cálculos de custos computacionais.
Maiores informações sobre os cortes e a ordem de tratamento das matrizes podem ser vistas no Apêndice A. 1.3 e seu experimento equivalente (corte na última constante) no Apêndice A. 2.3.
Qualquer outro modelo, mesmo que não realize reordens nas matrizes dos termos tensoriais mas, caso a parte estruturada tenha uma matriz constante ou elemento, o Algoritmo Shuffle será executado e influenciará negativamente nos resultados.
Essas chamadas influenciarão o custo computacional envolvido na MVD, não podendo ser comparado com uma versão do Algoritmo Split sem permutações.
Determinação do ponto de corte para o Algoritmo Split Os exemplos avaliados neste capítulo mostraram as vantagens e as características dos termos tensoriais que devem ser observadas para determinar onde dividir- los e reposicionar as matrizes para obtenção de um melhor tempo de execução.
A seguir, é discutida uma proposta para a escolha deste ponto de corte, observando a memória extra que será potencialmente gasta, refletindo no tempo de solução.
As equações para o custo computacional de multiplicação dos termos tensoriais, aliado aos resultados obtidos na Seção 7.1 permitem que seja proposto um algoritmo para utilização do Algoritmo Split em descritores clássicos e generalizados.
Este algoritmo leva em consideração o custo em termos de operações de ponto flutuante requeridas por o algoritmo, bem como a memória adicional necessária para armazenamento dos AUNFs da parte esparsa.
Os resultados obtidos permitiram análises sobre o processo da MVD para descritores clássicos e generalizados como, por exemplo:
O Algoritmo 7.1 recebe como entrada um termo tensorial e decide o ponto de corte a ser utilizado a partir de as características das matrizes (dimensões, identidades, quantidade de elementos não-nulos) que o compõe cada termo tensorial.
O algoritmo funciona da seguinte forma:
A partir de a descoberta do tipo do termo tensorial, que pode ser uma de três possibilidades, constante, parcialmente dependente ou totalmente dependente, é realizado o processo de descoberta do ponto de corte.
Algoritmo 7.1: Determinação do ponto de corte do termo tensorial.
Caso o tipo de do termo for clássico, ocorre uma transformação no termo tensorial enviando as matrizes identidade para o final e armazenando- se esse índice na variável i.
Caso haja memória suficiente para essa operação, a transformação é validada e recebe o valor do índice i.
Já no caso de o termo ser parcialmente dependente, tem- se a verificação da ocorrência de matrizes elemento (ou constantes) e o envio de matrizes para a parte esparsa do termo tensorial, exceto identidades.
O valor de para esse caso é o índice da última matriz dependente depois desta transformação.
Mas se o tipo for altamente dependente seja em sincronizações ou quantidade de parâmetros de elementos funcionais, a melhor possibilidade para lidar com esse termo é adotar a abordagem totalmente estruturada, pois inclusive pode- se ter dependências cíclicas e funções especificamente que serão tratadas de forma adequada por o Algoritmo Shuffle.
Termos tensoriais com matrizes mais densas farão com que seja calculado um número de AUNFs que talvez inviabilize o método (dependendo do corte), e a melhor abordagem a seguir é dividir o termo num ponto onde a memória a ser gasta é suficientemente calculada para abrigar um número considerável de elementos.
Em casos altamente dependentes em termos de funções, a melhor alternativa é cortar em 0, ou seja, trata o termo de forma estruturada.
A experiência em modelagem SAN pressupõe poucos casos com matrizes plenas ou altamente densas num termo tensorial.
Estas análises finalizam a parte de proposição de um algoritmo para dividir um termo tensorial.
A seguir, é feita uma discussão sobre os experimentos e os resultados obtidos.
Discussão Os resultados obtidos mostraram os casos em que o Algoritmo Split é mais eficaz:
Termos tensoriais esparsos estão presentes, no melhor caso, com apenas um ou poucos elementos não-nulos, termos com alta incidência de matrizes identidade simbolizando que o evento sincroniza poucas atividades, efetuam- se permutações na ordem original e, para descritores generalizados, as avaliações de elementos funcionais são efetuadas quando os AUNFs são calculados apenas uma vez no início do método.
O melhor caso pode ser comprovado através do modelo das Redes Wireless ad hoc, onde foi preciso armazenar N escalares na tabela de AUNFs, correspondendo ao número de termos existentes, ou seja, um AUNF por termo tensorial.
Os ganhos em tempo para o caso clássico foram da ordem de 12 vezes em relação a a abordagem do Algoritmo Shuffle.
O uso de primitivas que contemplam transições funcionais é importante em modelagem estocástica de sistemas.
Entretanto, nas soluções por métodos iterativos não se justifica a avaliação frequente de elementos funcionais a cada execução do método de MVD.
Estes elementos funcionais serão avaliados segundo uma ordem específica.
Isso vai ao encontro de a proposta sugerida nesta tese de utilizar estruturas de dados auxiliares para guardar as avaliação das funções apenas uma vez no início do método iterativo, convertendo os descritores generalizados em clássicos em tempo de execução da ferramenta.
No entanto, para entender o processo interno do algoritmo na sua essência, é necessário observar os detalhes do descritor Markoviano em si.
Uma vez que os eventos locais são somas simples de matrizes, são os eventos sincronizantes, com taxas constantes ou funcionais, que determinam o comportamento do Algoritmo Split em termos de custos de memória e tempo de solução.
Cabe ressaltar ainda que o Algoritmo Split, quando permuta as identidades para a parte estruturada e trabalha apenas com os AUNFs que correspondem às taxas dos eventos sincronizantes, não são gerados fatores normais na parte estruturada.
Apenas é necessário multiplicar o escalar (s) do AUNF em posições chave (basein e baseout) por um vetor de tamanho nright (conforme Algoritmo 4.3.).
O custo gasto para reordenar o termo tensorial, calcular índices auxiliares para saltar na estrutura permutada e utilizar esses índices ao longo de o método de MVD é negligenciável ao utilizar o Algoritmo Split, como constatado em todos os experimentos da Seção 7.2.
Verificou- se que a maioria dos modelos considerados executaram mais rápido que o Algoritmo Shuffle para ATC e ATG, onde a tabela com os AUNFs ficou dentro de limites aceitáveis.
O único limitador para solução de modelos estruturados em SAN continua sendo o tamanho do vetor estacionário de probabilidade que corresponde ao PSS.
Dada a relativa memória utilizada para salvar os AUNFs requerida inclusive quando o PSS é elevado, pode- se afirmar que o método somente não executará para os mesmos limites que são impostos ao Shuffle, estimado atualmente em 65 milhões de estados.
Um aspecto que não foi estudado até o presente momento é o efeito das dimensões das matrizes (principalmente quando não correspondem à identidades) na solução do modelo.
Esta variável pode ser melhor estudada no modelo Mestre-Escravo, que possui um autômato modelado como um Buffer, ou seja, uma região temporária de memória numa determinada problemática (este tipo de modelagem é bastante utilizada em sistemas paralelos e distribuídos, sendo útil para verificar quando estas estruturas chegam aos seus limites ou quando estão subutilizadas).
Esses estudos podem alterar significativamente o algoritmo de corte de termo tensorial pois, na parte estruturada, na parte da geração dos fatores normais, um grande bloco será descartado quando a matriz em questão possuir uma dimensão elevada.
Maiores estudos nesse sentido devem ser conduzidos para um melhor entendimento sobre o comportamento do método quando matrizes deste porte estão presentes.
O tamanho da lista de AUNFs necessárias para cada modelo, levando- se em consideração todos os eventos, dita tanto a memória extra a ser gasta quanto a complexidade em termos de multiplicações em ponto flutuante requeridas (seu tamanho indica os produtos necessários no vetor nright).
Um modelo que possua eventos sincronizantes que não afetem muitos outros autômatos possuirão uma lista menor de escalares para serem multiplicados no vetor.
Estas discussões finalizam o capítulo de resultados.
A seguir, as considerações finais e as perspectivas futuras.
Esta tese descreveu os principais formalismos estruturados de solução utilizados no contexto de avaliação de desempenho de sistemas, mostrando suas principais vantagens e desvantagens ao serem adotados para diferentes problemáticas da realidade.
A partir de estas descrições, foram estudados mecanismos para composição de modelos mais abstratos, capturando as características fundamentais do funcionamento dos sistemas.
Estas descrições são utilizadas para a construção de descritores Markovianos (ou Kronecker) que ao serem avaliados os operadores da Álgebra Tensorial, representam o Gerador Infinitesimal da Cadeia de Markov correspondente ao sistema em questão.
Uma vez que o modelo foi transposto para um formato tensorial e, por conseguinte, associado a um descritor Markoviano, existem diferentes algoritmos para multiplicar um vetor de probabilidade por tais estruturas, sendo os mais importantes o Algoritmo Esparso, o Algoritmo Shuffle e o Algoritmo Split.
Tais algoritmos fornecem formas únicas de tratamento para a MVD e são documentados e utilizados para o cálculo computacional do vetor de probabilidades estacionário ou transiente que representa a probabilidade de permanência nos estados de um sistema.
O cálculo de índices de desempenho sobre este vetor de probabilidades é utilizado para analisar o sistema, prever seus comportamentos ou antecipar problemas antes que estes sejam fisicamente instalados.
Esta tese mostrou que, dados descritores decompostos em operações tensoriais que representam os eventos de um sistema, é possível alterar a ordem das matrizes e aproveitar as suas características internas para realizar menos operações de multiplicações, reduzindo o tempo gasto por iteração.
Estas escolhas foram implementadas numa ferramenta chamada de GTAexpress.
Este software foi executado para uma série de modelos de diferentes realidades, com taxas constantes ou funcionais, com o propósito de descobrir e validar maneiras por as quais fosse possível organizar as matrizes dos termos tensoriais de descritores e dividir- las de uma forma razoável, objetivando a aceleração do processo de MVD.
Em a seção de resultados foram estudados diversos modelos através de experimentos com o Algoritmo Split onde o corte foi modificado para verificar os ganhos em termos de produtos efetuados entre os elementos das matrizes.
Este capítulo discute os principais algoritmos de MVD na Seção 8.1.
A seguir a Seção 8.2 lista as contribuições efetuadas nesta tese.
O capítulo finaliza com uma discussão sobre os trabalhos futuros na Seção 8.3 e o epílogo na Seção 8.4.
Resumo A seguir apresenta- se um detalhamento das principais características dos algoritmos de MVD, os desafios da utilização da abordagem Split e um resumo dos objetivos da tese:
Esparso: Esta abordagem é custosa em termos de memória ao precisar armazenar a matriz de transição e, dependendo do modelo e da estrutura de acesso à matriz, é uma alternativa eficaz quanto a o tempo necessário para efetuar o processo de multiplicação.
Pode se tornar ineficaz em tempo e memória caso matrizes com elevadas dimensões possuam uma grande quantidade de elementos não-nulos;
Shuffle: Este algoritmo é considerado eficiente em memória ao armazenar o descritor e usar as propriedades da álgebra tensorial para efetuar a MVD, entretanto, devido a os inúmeros cálculos de índices que são necessários para acessar essa estrutura não trivial pode, dependendo do modelo, ser ineficaz em tempo para processar o descritor na sua totalidade;
Split: Esta abordagem é uma combinação das anteriores e se destaca por proporcionar uma maior flexibilidade ao considerar o processo de MVD, reordenando e dividindo cada termo tensorial de descritores clássicos e generalizados de acordo com as suas propriedades, otimizando a manipulação das matrizes para a MVD.
Matrizes do tipo identidade:
Modelagens estruturadas baseada em SAN são naturalmente esparsas e, dependendo do caso, os descritores possuem diversas matrizes identidade;
Permutação do posicionamento original das matrizes que compõem o descritor:
Salvo o caso generalizado, onde existe a limitação dos parâmetros das funções estarem situados à esquerda da definição da função, qualquer ordenação das matrizes internas é permitida;
Flexibilidade no gasto de memória:
A flexibilidade do Split permite que as matrizes sejam permutadas numa ordem que seja escolhida de forma a refletir a memória a ser gasta por o método.
Esse fator pode ser importante para a aplicação em abordagens paralelas, ao permitir o balanceamento de carga de trabalhos entre os diferentes processadores de sistemas paralelos ou distribuídos;
Operação interna em descritores generalizados:
Dadas as restrições das avaliações dos elementos funcionais deseja- se mapear as consequências de se tratar matrizes deste tipo nos descritores e o seu impacto na memória extra necessária para operação do método.
Mapeamento da problemática para determinar pontos de corte no Algoritmo Split objetivando a melhoria do tempo de execução do processo de MVD.
A o reduzir o tempo necessário para uma única iteração do método de convergência utilizado, estes ganhos são replicados de acordo com o total de iterações necessárias;
Análise das características de descritores clássicos e generalizados, observando o tipo de cada matriz e sua influência no método, apresentando a complexidade para cada re-estruturação;
Enumeração de experimentos relevantes para descoberta das propriedades existentes utilizando os modelos disponíveis na literatura (e alguns clássicos tais como o problema do Compartilhamento de Recursos ou Jantar dos Filósofos) bem como as estratégias passíveis de execução dada a flexibilidade do Algoritmo Split;
Implementação de uma ferramenta contendo o Algoritmo Split para descritores clássicos e generalizados, adaptável ao modelo estudado (o software permite a configuração da estratégia para execução);
Discussão dos principais formalismos para avaliação de desempenho e proposição de formas de tradução entre formalismos estruturados utilizando premissas para abstração e composição de sistemas.
Contribuições Um dos desafios na modelagem estocástica de sistemas é capturar as principais características e semântica operacional de problemáticas, descrevendo- as através de um modelo num formalismo.
Entretanto, apenas representar- lo através de primitivas de mapeamento que demonstrem seu sistema de transições é insuficiente para uma análise completa.
As diferentes modelagens de sistemas devem ser usadas em conjunção com a sua solução, ou seja, através da descoberta dos índices calculados a partir de o sistema de equações que é produzido.
Estas informações, quando submetidas a rigorosas análises por parte de os modeladores, fornecem índices computacionais de desempenho que atestam a operação do sistema para um determinado conjunto de taxas escolhidas.
O uso de descritores baseados em tensores é justificado por o fato de não ser necessário o armazenamento da matriz de transição que contém as taxas entre os estados de um modelo.
Através de propriedades da Álgebra Tensorial, opera- se implicitamente sobre esta matriz realizando- se a MVD sem precisar gerar esta matriz de tamanho potencialmente grande.
Os algoritmos Esparso e Shuffle presentes na literatura abordam a técnica de maneira distinta:
Enquanto o primeiro necessita muita memória e poucos cálculos para encontrar os elementos da matriz, o segundo é eficiente em memória mas são necessários muitos cálculos de índices para acesso aos elementos.
Portanto, a definição do Algoritmo Split, ao operar sobre as vantagens e desvantagens conhecidas dos algoritmos Esparso e Shuffle, apresenta um compromisso razoável para tratamento dos termos tensoriais de forma individualizada controlando a memória a ser gasta.
Dadas as características das modelagens, observou- se também que, dependendo do descritor, o Split não necessita de quantidades elevadas de memória adicional, o que amplia os casos em que acelera o processo da MVD.
A o utilizar diferentes estratégias de corte para termos tensoriais, constatou- se que algumas classes de modelos não gastavam quantidades excessivas de memória e aceleravam o processo da MVD.
A o estudar tais classes mais minuciosamente, observou- se que estas apresentavam características únicas tais como baixa densidade (poucos elementos não nulos dentro de cada matriz do termo tensorial) e fraco envolvimento entre as demais entidades do mesmo termo (o que foi definido como possuidor de baixo Grau de Dependência Constante ou Generalizado, conforme Seção 5.1).
Esta métrica mostrou ser crucial para inferir onde será fixado o corte do termo tensorial e onde as funções (caso presentes) serão avaliadas, convertendo ou não os descritores ATG em ATC em tempo de execução.
A Tabela 8.1 mostra as possibilidades de re-estruturações para descritores clássicos e generalizados.
A opção a ser escolhida depende do descritor, caso este seja clássico, a única variável a observar é o grau de interação ou interferência dos eventos do modelo.
Já descritores generalizados dependem da quantidade de parâmetros e da complexidade de cada uma das funções criadas por os usuários.
Este fator impactará na quantidade de vezes que avaliações funcionais são realizadas, tanto no Algoritmo Shuffle como no Algoritmo Split.
Como mencionado anteriormente, ao avaliar as funções na parte esparsa, estas chamadas são realizadas apenas uma vez no início do método iterativo enquanto que, na abordagem Shuffle, múltiplas avaliações são feitas (em função de o número de iterações).
Para o caso onde não existam taxas funcionais, os modelos com as características presentes acima, além de possuírem descritores com termos tensoriais esparsos, dependendo do modelo, possuem matrizes do tipo identidade que, ao serem tratadas por o algoritmo Shuffle após a fixação do ponto de corte e a descoberta dos índices de permutação, serão desconsideradas.
Para o caso funcional, é necessário observar os parâmetros das funções ou então converter o modelo baseado em ATG para ATC explicitamente1.
A o realizar esta tarefa de conversão, na maioria dos casos aumenta- se o número de eventos nos modelos, ou seja, criam- se eventos sincronizantes que forçam a verificação de estados em diferentes autômatos de acordo com os parâmetros utilizados.
A Tabela 8.2 mostra dois exemplos com descritores clássicos e generalizados baseados nos modelos de Redes Wireless ad hoc e modelo Mestre-Escravo.
A tabela está separada em duas partes, sendo que a parte de cima mostra os tempos obtidos para uma iteração, para todos os experimentos (coluna Exp.)
conduzidos no Capítulo 7 e, a parte de baixo mostra a memória adicional a ser gasta para execução de cada algoritmo.
A partir de a tabela verifica- se a necessidade (ou não) de conversão de modelos ATG para ATC, pois tem- se o tempo necessário para cada execução.
Em termos de tempo, e comparando- se apenas a abordagem Shuffle, observando- se apenas o caso de 16 nós wireless, constata- se que é interessante converter o descritor para ATC, pois o tempo por iteração é reduzido de 79,31 segundos para 22,67 segundos (Exp.
4). O mesmo não ocorre em outros modelos, como para 10 escravos, que obteve tempos similares, ou seja, 13,38 segundos e 11,34 segundos para os experimentos 4 e 9.
Entretanto, ao se comparar a abordagem Shuffle com a Split e mesmo tipo de descritor, tem- se que para ATG são necessários 79,31 segundos para rodar o método Shuffle e 6,60 segundos para o Split (Exp.
7), um ganho em tempo superior a 10 vezes.
A o se converter este caso para descritores clássicos, o ganho verificado é comparativamente menor, de 22,67 segundos (Exp.
A memória extra gasta com o Algoritmo Split para o modelo Redes Wireless ad hoc pode ser considerado desprezível (por exemplo, para uma máquina com 4 Gb de memória RAM) para os menores tempos.
Já para o modelo Mestre-Escravo, o gasto em memória também pode ser considerado baixo, da ordem de 74 Mb.
Cabe ressaltar que estes ganhos obtidos para uma única iteração são multiplicados por o número total de iterações, ou seja, mesmo pequenos valores influenciam o tempo total necessário para finalização do processo completo de MVD.
Estes exemplos evidenciam a flexibilidade presente na abordagem adotada por o Algoritmo Split, permitindo diferentes formas de se re-estruturar os termos tensoriais para aceleração do processo de MVD.
Esta característica pode também ser importante quando o algoritmo for proposto em versões paralelas, as quais tornarão necessária a descoberta de heurísticas de corte para balanceamento das tarefas atribuídas a cada unidade de processamento.
Compor um grande espaço de estados, descobrir seus estados atingíveis e armazenar- lo não é mais um problema, visto as técnicas existentes para este propósito tais como gerações simbólicas ou baseadas em diagramas de matrizes.
O problema agora é encontrar o vetor estacionário de probabilidade utilizando métodos numéricos de última geração que possibilitem e acelerem o processo de convergência a partir de diferentes estratégias, tais como aproximação da solução ou simulação perfeita.
O presente trabalho alinha- se com este propósito, ao definir formas de se reduzir as operações necessárias ao tratar cada termo tensorial propondo novas formas de estruturar- lo com permutações e divisões e tratando cada parte de forma diferenciada.
Este trabalho definiu as estratégias para a solução de descritores clássicos e generalizados ao mesmo tempo que comparou estas diferentes possibilidades para serem utilizadas por o Algoritmo Split.
Com os resultados obtidos, descreveu- se um algoritmo que calcula um ponto de corte para termos tensoriais, observando a memória gasta e o tempo ganho, reorganizando- os para efetuar menos operações numéricas.
A melhor classe de modelos possui alta esparsidade (baixa densidade) e altas quantidades de matrizes do tipo identidade.
A abordagem usada por o Algoritmo Shuffle é eficiente em memória enquanto que a do Algoritmo Esparso, dependendo do caso, necessita de um espaço de armazenamento alto.
Os dois casos tratam a problemática da memória de maneira distinta ao efetuar a MVD.
Esta tese combinou as vantagens destas duas abordagens numa alternativa híbrida, onde os gastos em memória são flexíveis.
O Algoritmo Split foi refinado para aumentar a variedade de modelos que resolve ao permitir que sejam construídos modelos com taxas constantes e generalizadas (ATC ou ATG).
As pesquisas anteriores desconheciam as implicações do algoritmo ao lidar com elementos funcionais.
Foram elencadas as principais problemáticas ao se lidar com termos tensoriais generalizados, enumerando as formas de separar conjuntos de matrizes de acordo com características que reduzissem a complexidade computacional envolvida.
Perspectivas A seguir serão detalhadas as perspectivas, classificadas da seguinte forma:
Conversão de descri- tores ATG em ATC, classes de modelos para que o Algoritmo Split seja melhor executado, métodos de paralelização e distribuição de tarefas, avanços em novas primitivas de modelagem e aplicações, criação de AUNFs com informações adicionais e aproximações da solução, melhor descritas a seguir.
A) conversão de descritores ATG em ATC Como mencionado anteriormente, os melhores resultados do Algoritmo Split para descritores baseados em ATC são verificados quando em cada módulo de um sistema as interações e sincronismos são baixos, privilegiando a formação de um descritor com termos tensoriais esparsos e com muitas identidades.
Entretanto, uma importante primitiva de modelagem é a utilização de taxas funcionais, ocorrendo em transições que verificam o estado de outros módulos de forma dinâmica.
Dada a possibilidade de se converter um modelo definido em ATG para ATC, pouco se sabe sobre os casos em que esta tradução implicará em ganhos substanciais para a execução do Algoritmo Split pois esta característica é sensível ao modelo sob análise.
A conversão de descritores ATG em ATC em tempo de execução é válida e eficaz, como constatado ao longo de o trabalho.
Entretanto, outros mecanismos de adequação podem ser construídos para auxiliar nesta tarefa.
Atualmente, o uso de taxas funcionais fica sob responsabilidade do modelador que utiliza sua experiência para definir os relacionamentos entre os componentes.
Eventualmente, a tarefa de detectar se o modelo será resolvido mais eficientemente usando- se ATG ou ATC pode ser implementado por um compilador mais` inteligente', já que este pode construir e determinar as matrizes dos termos tensoriais a partir de os parâmetros das funções do modelo, bem como regras para mapear a taxa funcional.
Esta tese evidenciou que, dependendo do caso, as funções podem ser convertidas para um formato clássico correspondente (de ATG para ATC) sem perda de informação objetivando a aceleração da convergência ou transiência.
A técnica de conversão entre tais descritores é conhecida no contexto de SAN, falta determinar as classes mais adaptadas.
B) novas classes de problemas para utilização do Algoritmo Split Um outro eixo alvo de pesquisas é o de determinar outras classes de modelos que garantirão um desempenho mais eficaz do Algoritmo Split, detectando as principais características envolvidas e a composição dos elementos descritos.
Este trabalho evidenciou bons resultados quando somente às vezes as entidades envolvidas sincronizam suas atividades com outros elementos.
Em este sentido, modelos para aplicações paralelas apresentam estas características, sendo desejável que os nodos ou núcleos de processamento desempenhem atividades internas mas comuniquem o término entre os demais componentes do modelo, sincronizando suas atividades.
Outros problemas também podem ser atacados, tais como a quantificação de comunicação em equipes distribuídas globalmente, sincronizando, por exemplo, a finalização de um módulo de um sistema, para a área da Engenharia de Software.
Quaisquer problemas onde exista esta qualidade de independência e sincronização global pode ser alvo de descrições modulares tais como as apresentadas nesta tese.
A o permitir que os modeladores pensem apenas nos problemas e informem como o sistema opera de forma local e global, torna- se transparente a forma de solução que será adotada para cálculo dos índices quantitativos de desempenho a partir de modelos analíticos.
C) métodos para paralelização e distribuição Métodos de paralelização desta técnica podem ser desenvolvidos mais facilmente do que na abordagem tradicional presente no Algoritmo Shuffle.
A o flexibilizar a MVD, reduz- se significativamente a dependência e usa- se a propriedade da Decomposição Aditiva para multiplicar os escalares em posições chave do vetor de probabilidades (dependendo da estratégia adotada).
Os resultados apresentados mostraram os pontos de corte para uma execução sequencial do algoritmo.
Entretanto, estes mesmos cortes podem ou não apresentar os mesmos desempenhos em soluções paralelas sendo necessária a realização de estudos mais aprofundados para delimitar os cortes a ser adotados para cada caso, garantindo o balanceamento de carga, por exemplo.
Outras premissas devem ser levadas em consideração tais como a quantidade de tarefas a serem realizadas por cada nodo de uma rede, se é melhor enviar cada termo tensorial para um nodo diferente e as implicações existentes ao sincronizar os resultados intermediários no vetor final de probabilidades.
O objetivo é explorar a flexibilidade do método para adequar e balancear os gastos de memória (e eventualmente de comunicação) em virtude de as arquiteturas heterogêneas em que estarão executando.
D) avanços em primitivas de modelagem e novas aplicações Sobre avanços em termos de modelagem, podem ser considerados sistemas baseados no conceito de Multi--layers e sua formalização.
Este tipo de modelo é usado para representar internamente sub-sistemas com alta independência local mas que eventualmente sincronizam atividades globalmente, em conjunção com outros sub-sistemas.
Tais modelagens podem ser usadas para descrever comportamentos de redes distribuídas, como por exemplo, redes baseadas em comunicação entre pares (Peer-to-Peer) ou até mesmo para testes estocásticos de sistemas.
Para estas modelagens será necessário ampliar a descrição dos modelos para contemplar estas novas primitivas bem como fornecer ferramentas especializadas para solução.
Para tanto, podem ser usadas as ideias apresentadas como matrizes Quase Completamente Decomponíveis (Nearly Completely Decomposable), pesquisadas anteriormente no contexto de Cadeias de Markov.
Em este sentido, a adição de outras primitivas de modelagem pode vir a ser proposta, ampliando as possibilidades de descrição e mapeamento de realidades.
A modelagem e a solução devem ser o mais transparente possíveis para os modeladores.
Enquanto que o primeiro grupo conhece o problema a ser descrito, o segundo processo explora a formação do descritor e, de acordo com a complexidade dos métodos existentes, decide a forma de dividir os termos tensoriais efetuando a MVD.
O usuário, em última análise, deseja apenas que o seu modelo seja convertido em números ou índices que possam ser interpretados para inferir as principais características dos problemas mapeados.
A solução do sistema linear que descreve as transições do sistema deve utilizar técnicas eficientes para minimização do tempo necessário descoberta ou não da estacionariedade.
Caso fosse preciso uma elevada quantidade de estados onde soluções analíticas não estivessem habilitadas2 o ideal seria que, internamente e transparentemente, primitivas de simulação fossem executadas.
Em este caso, seriam gerados índices computacionais baseados em aproximações em relação a a solução analítica.
E) AUNFs contendo os ajustes diagonais Ainda acrescenta- se a concepção de uma versão do GTAexpress que consiga criar os AUNFs necessários que guarde em memória os ajustes diagonais.
Esta funcionalidade tornará desnecessária a criação do vetor de correção da diagonal, atualmente uma otimização do PEPS mas, ao mesmo tempo, um limitador de memória, determinando que 65 milhões de estados possam ser definidos.
Caso esta implementação seja efetuada, o vetor diagonal não precisará ser mais armazenado e o limite do número de estados da ferramenta aumentará consideravelmente.
Também podem ser investigadas as relações existentes entre a criação dos AUNFs e a geração do espaço de estados atingível visando uma representação para ser usada na solução.
F) otimizações computacionais Dadas as características do Algoritmo Split e as suas estratégias, a utilização de diferentes tamanhos e hierarquias de memória pode acelerar ainda mais o processo de MVD.
Cabe ressaltar que esperam- se resultados melhores em função de o tamanho da lista de AUNFs (para modelos que utilizem muita memória para salvar a estrutura, os benefícios não serão tão aparentes).
Outras otimizações computacionais podem ser realizadas no nível do projeto da ferramenta para avaliar os ganhos das diferentes implementações.
Um exemplo são a utilização de threads na multiplicação dos AUNFs por o vetor de probabilidades.
Estes mecanismos podem ser usados para paralelizar a solução e aproveitar a característica independente do Algoritmo Split ao tratar cada termos tensorial dos descritores Markovianos.
G) aproximações da solução Por fim, outros eixos de pesquisa podem ser direcionados para o estudo de aproximações da solução, descoberta de agregações entre os termos tensoriais (e as implicações envolvidas, por exemplo, mesmos cortes e mesmas transformações em termos de permutações) e mecanismos para operar apenas com os estados atingíveis com o Split, para citar algumas possibilidades.
Esta tese desenvolveu uma nova forma de se multiplicar um vetor por um descritor Markoviano e encontrou uma forma mais otimizada de realizar esta tarefa com base em permutações das ordens originais dos termos tensoriais e em cortes definidos para criar uma matriz agregada que encontre grandes blocos com matrizes identidade.
Como observado, outras técnicas podem ser adaptadas ou utilizar o Split para acelerar ainda mais a convergência do processo, seja através da descoberta de novas classes de modelos ou através de mecanismos que aproximem os resultados.
Para todos os casos, o principal objetivo é aumentar o poder de representação, descrição e solução de sistemas fornecendo os índices de desempenho em menos tempo.
Epílogo O processo de se buscar a aceleração da MVD é relevante no contexto da avaliação de desempenho de sistemas através de representações tensoriais da matriz de transição que corresponde à Cadeia de Markov.
Ao longo de a tese foram explorados diferentes formalismos estruturados que podem possuir ou não tais representações eficientes em memória em seus modelos.
Em um substancial número de casos, os resultados obtidos demonstraram ganhos significativos para a solução de modelos criados a partir de formalismos estruturados que possuam um descritor Markoviano.
Em este sentido, constata- se que o trabalho aqui descrito contribuiu na direção de ampliar o entendimento sobre esta importante problemática dentro de a área de Avaliação de Desempenho e Modelagem Estocástica de Sistemas.
A tese enunciou as principais formas de se re-estruturar termos tensoriais de descritores Markovianos e descreveu os casos onde a flexibilidade do Algoritmo Split mostrou a existência de um equilíbrio entre o tempo e a memória extra a ser gasta.
Desta forma, aumentouse o conhecimento prévio sobre os detalhes de execução do Split quando primitivas funcionais de modelagem estão presentes nas abstrações das diferentes realidades e os impactos do seu uso no processo de solução de modelos.
Estas considerações finais e perspectivas encerram a tese.
Este capítulo apresentou um resumo do trabalho realizado, descreveu as contribuições e discutiu os avanços em termos de pesquisa em solução de modelos Markovianos para fins de avaliação de desempenho.
