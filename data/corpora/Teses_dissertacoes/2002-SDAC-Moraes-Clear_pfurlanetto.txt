Esta dissertação apresenta o desenvolvimento de um algoritmo de roteamento para dispositivos programáveis do tipo FPGAs.
A principal motivação para o desenvolvimento deste algoritmo é encontrar uma solução eficiente para o problema de roteamento dos dispositivos programáveis FPGA.
O trabalho apresenta a arquitetura de roteamento dos dispositivos programáveis da Xilinx, pois esta arquitetura é a utilizada por o algoritmo.
Os algoritmos acadêmicos de roteamento e suas características principais são apresentados em tabelas comparativas.
Uma vez apresentados os algoritmos de roteamento encontrados na literatura, é apresentado o desenvolvimento do algoritmo de roteamento, comparando- o com o estado-da-arte.
Por fim, apresenta- se uma proposta de implementação paralela do algoritmo, com o objetivo de reduzir o tempo de processamento para rotear grandes circuitos.
Palavras-chave: Algoritmo Maze, algoritmos de roteamento, arquitetura de roteamento, CAD, FPGA.
Com o avanço da tecnologia VLSI tornou- se possível desenvolver circuitos digitais com baixo custo, elevado número de transistores e alta freqüência de funcionamento.
Um dos dispositivos mais beneficiado com esta tecnologia foram os componentes programáveis do tipo FPGA.
Estes dispositivos têm auxiliado na prototipação de circuitos digitais, pois são facilmente reprogramados através da utilização de ferramentas de CAD e estão sendo também empregados em escala industrial, quando o volume de produção não é tão elevado (tipicamente um novo produto seja lançado no mercado reduziu drasticamente.
Até então, o projeto de um circuito integrado dedicado (ASIC) levava vários meses para ser concluído.
Em um projeto eletrônico, três funções custo devem ser atendidas:
Minimizar o atraso nas redes, reduzir a área ocupada e reduzir a potência consumida por o circuito.
Cabe salientar que não é possível obter uma solução que satisfaça estes três compromissos, por serem dependentes uns dos outros.
Por exemplo, ao tentarmos reduzir o atraso, a área ocupada tende a crescer, devido a a necessidade de inserirmos um maior número de buffers ou por a utilização de transistores maiores.
Para que estes problemas sejam resolvidos, os projetistas precisam desenvolver novas técnicas de mapeamento, posicionamento e roteamento eficientes, como pode ser observado em e em, onde é proposto um algoritmo de roteamento paralelo.
Em este trabalho é estudado o problema de roteamento em dispositivos FPGA, com arquitetura de canais de roteamento horizontais e verticais.
A escolha da arquitetura foi feita com base em duas observações:
É a tendência observada na indústria, como por exemplo, por os fabricantes Xilinx e Altera (e); (
ii) está sendo largamente utilizada no estudo de arquiteturas reconfiguráveis e projetos conjuntos de hardware e software (co-design).
Desenvolver um algoritmo de roteamento é uma tarefa árdua, considerando- se que os FPGAs possuem recursos de roteamento fixos e limitados.
Os recursos de roteamento, nos dispositivos programáveis FPGA, de uma forma geral, estão dispostos em linhas e colunas, formando uma matriz.
Este trabalho tem como objetivo principal o desenvolvimento de um algoritmo para o roteamento de circuitos programáveis do tipo FPGA.
Este roteador utiliza como base um algoritmo da classe Maze Router, adaptado para dispositivos FPGAs.
O algoritmo proposto por Lee e Moore é utilizado para encontrar o caminho mínimo entre dois pontos num grafo.
Finalmente, o Capítulo 6 apresenta as conclusões do presente trabalho.
2 Arquitetura de roteamento em FPGAs Xilinx Em este Capítulo é realizada uma breve apresentação das arquiteturas de roteamento dos dispositivos programáveis FPGA Xilinx das famílias 4000 e Virtex.
Os dispositivos programáveis FPGA, de uma forma geral, são compostos de blocos lógicos, matrizes de chaves (Switch
Box) e recursos de roteamento denominados de trilhas.
A Figura 1 apresenta as quatro principais arquiteturas de roteamento utilizadas em dispositivos programáveis FPGA:
Matriz simétrica, PLD hierárquico, mar de portas (Seaof-Gates) e o row-- based.
A arquitetura do tipo sea-of-gates é um dispositivo preenchido completamente por transistores ou blocos lógicas de baixa complexidade (tipicamente uma porta lógica nand).
A vantagem desta arquitetura é a alta densidade de portas lógicas implementadas por unidade de área.
Porém, como não há uma área dedicada para roteamento, é necessário que o mesmo seja feito sobre as células, muitas vezes inutilizando- as.
Os dispositivos com arquitetura do tipo row-- based possuem linhas de blocos lógicos na horizontal, sendo a área de roteamento feita entre estas linhas.
Observa- se que não há área de roteamento vertical dedicada, o que pode acarretar sacrifício de blocos lógicos para a passagem de conexão entre linhas não adjacentes.
As arquiteturas row-- based e sea-of-gates são oriundas das metodologias de projeto de ASICs, standard-cells e gate-- array.
Ambas não lograram sucesso comercial em FPGAs devido a as limitações impostas por os escassos recursos de roteamento.
O dispositivo que tem a arquitetura do tipo PLD hierárquico é constituído por uma matriz de blocos lógicos, denominados Logic Arrays Blocks, sendo os mesmos interligados por o recurso de roteamento conhecido como Matriz Programável de Interconexão (Pia).
Esse tipo de dispositivo é dito hierárquico porque os blocos lógicos podem ser agrupados entre si, criando assim as Macro3 Células, sendo esse o nível 1.
O nível 2 é formado por a conexão das Macro-Células entre si através da Pia.
Os FPGAs com arquitetura do tipo PLD Hierárquico podem ser encontrados nos dispositivos fabricados por a Altera.
O roteamento é bastante simplificado neste tipo de arquitetura, pois a cada nível de hierarquia utiliza- se basicamente uma rede do tipo cross-bar.
A arquitetura do tipo Matriz Simétrica é flexível no requisito roteamento, pois possui canais verticais e horizontais de roteamento.
Deve- se observar que, para a área do circuito não ser completamente dominada por o roteamento, a granularidade do bloco lógico deve ser alta.
Como veremos adiante, a família Xilinx 4000 possui 3 LUTs, sendo duas de 4 entradas e uma de 3 entradas, e a família VIRTEX possui 4 LUTs de 4 entradas.
O presente trabalho utiliza a arquitetura do tipo Matriz Simétrica por esta estar sendo largamente utilizada na indústria, e por apresentar desafios de implementação tanto de complexidade como de tempo de processamento.
A Seção 2.1 apresenta a arquitetura de blocos lógicos e roteamento da família Xilinx 4000 e a Seção 2.2 a família Virtex.
Família 4000 Os dispositivos FPGA Xilinx da família 4000 foram lançados em 1994.
A lógica combinacional que define a funcionalidade do circuito é armazenada em tabelasverdade implementadas em hardware, denominadas LUT, de Look-up Table.
Uma LUT de K entradas é uma combinação de uma memória de K bits e um multiplexador de K_ 1, que pode implementar qualquer função Booleana de K variáveis.
As K entradas são usadas como endereço para uma memória de 2K x 1-bit, que armazena a tabela verdade da função.
Em a Figura 2 apresentamos como a função x $= ab+ bc é implementada numa LUT de 4 entradas.
A LUT é constituída de 16 bits de memória (24 entradas) e um multiplexador 16x1.
Durante a fase de configuração do circuito, armazenamos a tabela-verdade nos 16 bits de memória.
Durante a fase de processamento, cada uma das variáveis controla uma das entradas do multiplexador (observar que a entrada d fica com valor constante zero).
O bloco lógico da família 4000 é constituído por duas LUTs de 4 entradas, denominadas de F-LUT e G-LUT respectivamente, e uma LUT de 3 entradas (H-LUT).
A Figura 3a ilustra a constituição do bloco lógico da família 4000.
As saídas das LUTs são denominadas F', H'e G', sendo que F'utiliza a saída X e G'usa a saída Y, através de multiplexadores.
O sinal H'pode utilizar tanto as saídas X e Y. Todas as saídas podem ser diretas, complementadas ou bufferizadas, característica importante para a melhora do desempenho elétrico.
As entradas C1, C2, C3 e C4 são utilizadas para controle, denominadas no interior do bloco lógico como H1, Din, S/ R e EC.
A H-LUT recebe três entradas:
F', G'e H1.
O sinal Din, faz com que as saídas passem por registradores (flip-flop tipo D) e estejam disponíveis nas saídas YQ e XQ.
O pino S/ R serve para setar ou resetar os registradores durante a inicialização ou reconfiguração ou ainda quando uma rede dedicada de reset é ativada.
Os dois registradores possuem um sinal de clock comum (K) que pode ser habilitado ou não, dependendo da entrada EC (Enable Clock).
A Figura 3 b, apresenta de forma simplificada o bloco lógico da família 4000.
Este bloco de 4 entradas;
Uma função de 5 variáveis, utilizando a F-LUT e a G-LUT para a implementação dos minitermos da função, sendo a H-LUT controlada por a quinta variável;
Algumas funções de 6 até 9 variáveis.
Cabe salientar que este bloco lógico, apesar de aceitar 9 entradas, não equivale a uma LUT com 9 entradas.
Para isto seriam necessários 512 bits para armazenar todos os minitermos possíveis, tornando inviável a área de silício necessária e o tempo de reconfiguração.
A implementação de funções com um maior número de variáveis reduz o número de blocos lógicos utilizados no circuito, em conseqüência de isso a densidade aumenta e o atraso é reduzido.
Apesar de a aparente vantagem de aumentar a complexidade dos blocos lógicos, as ferramentas de síntese lógica não utilizam plenamente estes recursos, tornando o FPGA sub-utilizado.
Estudos acadêmicos demonstram que o melhor compromisso área versus desempenho é obtido com LUTs tendo 4 entradas.
A aplicação deste estudo pode ser observado nos dispositivos comerciais, os quais contém LUTs de 4 entradas.
O número de LUTs por bloco lógico também é estudado em trabalhos acadêmicos.
Propõe que este número fique entre 8 e 10.
A família 4000 possui 3 LUTs por bloco lógico (CLB), a família VIRTEX 4 LUTs por CLB e a família VIRTEX-II 8 LUTs por CLB.
Os recursos de roteamento dos dispositivos da família 4000 possuem 4 tipos de segmentos de fio:
Linhas de propósito geral (Single-length lines), linhas de tamanho duplo (Double-length lines), linhas longas (long lines), linhas globais e matrizes de chaves.
A família XC4000EX possui além desses recursos, as linhas quádruplas.
Em a Figura 4, são apresentados os recursos de roteamento, sendo as partes com o fundo cinza pertencentes apenas ao XC4000EX.
As linhas longas percorrem todo o comprimento ou largura do dispositivo, sendo utilizadas para transmitir sinais globais do circuito, diminuindo assim o skew1 destes sinais.
Cada linha longa possui uma chave programável no centro, a qual separa a linha em duas partes independentes.
As entradas e as saídas dos blocos lógicos podem conectar- se às linhas longas.
As saídas do bloco que utilizarem este recurso podem ser realizadas através de buffers tri-state ou das linhas de propósito geral.
Diferença no tempo de propagação do sinal entre sua origem e seus destinos.
Em linhas longas o sinal pode chegar nos destinos em tempos diferentes, comprometendo o comportamento de circuitos síncronos.
Este parâmetro pode ser traduzido como &quot;escorregamento «do sinal.
Por outro lado, as linhas globais atravessam toda a extensão do dispositivo na vertical possuindo apenas chaves de conexão com as linhas de propósito geral (single length lines).
As linhas de tamanho duplo são duas linhas paralelas, tendo o dobro do tamanho das linhas de propósito geral.
Essas linhas são conectadas a matrizes de chaves alternadas, ou seja, a cada dois blocos lógicos.
Cada bloco lógico é associado a 4 linhas horizontais e 4 linhas verticais de tamanho duplo, podendo assim haver uma distribuição uniforme do sinal em distâncias intermediárias, com flexibilidade de roteamento.
As linhas de propósito geral estão distribuídas na vertical e na horizontal, utilizadas principalmente para conectar blocos lógicos adjacentes ou muito próximos.
Quando a distância entre dois blocos lógicos é grande, esse tipo de recurso não é utilizado em razão de o aumento do atraso causado por o grande número de chaves utilizadas para realizar essa conexão.
A Tabela 1 e a Figura 6 resumem os recursos de roteamento da família 4000.
Observa- se, por exemplo, que cada bloco lógico da família XC4000E pode utilizar 24 linhas de roteamento vertical e 18 linhas de roteamento horizontal.
Para definir a flexibilidade de roteamento de um FPGA são utilizados dois parâmetros:
Fc e fs.
O parâmetro fs define a flexibilidade da matriz de chaves, indicando o número total de conexões oferecidas a cada segmento de fio conectado à matriz.
A Figura 7 ilustra duas situações distintas para o parâmetro fs.
A primeira situação, fs $ , representa o máximo de flexibilidade para o roteamento, mas não uma situação real para os FPGAs atuais.
A segunda situação, fs $= 3, representa uma arquitetura real, impondo restrições aos algoritmos de roteamento.
Para a família 4000 temos fs $= 3.
A flexibilidade dos blocos de conexão é indicada por fc, representado o número total de trilhas que os pinos de um bloco lógico podem acessar.
Normalmente, este parâmetro é igual à largura do canal de roteamento.
Para a família 4000 temos fc igual à largura do canal de roteamento.
Arquitetura Virtex Os dispositivos FPGA Xilinx da família Virtex foram lançados em 1998.
Esta família possui a particularidade de possuir uma arquitetura baseada em clusters, com o objetivo de minimizar o atraso de propagação dos sinais elétricos do circuito e de diminuir a área ocupada por o circuito no dispositivo FPGA.
O cluster é um conjunto de blocos lógicos interligados localmente por elementos de conexão de alta velocidade.
A Figura 8 apresenta uma visão geral da arquitetura da família Virtex, a qual é composta por Blocos Lógicos Programáveis (CLBs), Blocos de Entrada/ Saída (IOBs) e Blocos de Memória RAM (BRAMs).
A ligação das CLBs e memórias aos blocos IOBs é feita através do VersaRing, que é composto por uma matriz de chaves de alta velocidade.
O bloco lógico da família Virtex, apresentado na Figura 9, é composto por dois slices idênticos, muito similares ao bloco lógico da família 4000.
Observa- se que a estrutura interna do slice é simplificada em relação a a CLB da família 4000, pois a LUT de 3 entradas foi suprimida.
Cada slice contém 2 LUTs de quatro entradas, 2 flip-flops e recursos de propagação rápida de carry, para implementar operadores aritméticos.
A arquitetura de roteamento da família Virtex pode ser dividida em 2 partes:
Matriz programável de roteamento, e linhas globais de distribuição de sinal de clock.
Matriz Programável de Roteamento A matriz programável de roteamento provê a conexão entre os CLBs, interligando o roteamento local com o roteamento de propósito geral.
A Figura 10 mostra as conexões possíveis desse recurso de roteamento.
Além de o roteamento local e do roteamento de propósito geral, temos ainda o roteamento de entrada/ saída e roteamento dedicado.
O roteamento de propósito geral, apresentado na Figura 11 é composto por 24 linhas de comprimento simples que interligam as GRMs (matriz geral de roteamento) adjacentes em quatro direções lembrar que na família 4000 havia linhas de comprimento 2 e 4, e que nesta família temos comprimento 6) e 12 linhas longas horizontais e verticais que percorrem todo o dispositivo.
As hex lines conectam CLBs a intervalos de 3 em 3 CLBs.
A Figura 12 ilustra 3 CLBs conectadas por a mesma hex line.
O roteamento local, também denominado como VersaBlock, realiza as conexões entre os blocos lógicos e a matriz geral de roteamento (GRM).
O objetivo deste roteamento é realizar conexões de alta velocidade entre os slices, evitando que essas conexões passem por a matriz geral de roteamento eliminando o atraso produzido por a mesma, diminuindo assim o atraso de propagação do sinal.
Há também um certo número de segmentos de fio que conectam diretamente CLBs vizinhas.
A Figura 13 ilustra parcialmente um roteamento feito num dispositivo Virtex.
O roteamento local, ou VersaBlock, é feito por os multiplexadores de entrada e saída.
A matriz geral de roteamento, GRM, é representada por o retângulo switch box.
A área cinza contém o roteamento de propósito geral.
Há 13 multiplexadores de entrada por CLB, os quais incluem as entradas F 1-F4, G 1-G4, CLK, Sr, etc..
Cada entrada possui um multiplexador associado, o que determina qual sinal proveniente da GRM irá alimentar os circuitos do slice.
Há também 8 multiplexadores de saída por O roteamento de entrada/ saída, como já comentado, é feito por a estrutura denominada VersaRing.
O roteamento dedicado refere- se ao roteamento de buffers tri-state, propagação de carry e conexão dos DLLs.
Distribuição Global de Clock A Figura 14 representa como é realizada a distribuição global dos sinais de clock.
Este tipo de distribuição se assemelha a uma espinha de peixe e também é utilizada em microprocessadores.
Há 4 entradas externas que podem ser utilizadas para sinal de clock, assim como 4 circuitos dedicados para sincronismo de clock (DLLs).
Este sistema garante uma distribuição uniforme de sinais de sincronismo no interior do FPGA, evitando assim atrasos relativos (skew) em decorrência dos segmentos de fio longos que devem ser utilizados para que o sinal seja distribuído.
Simétrica de Blocos Lógicos O objetivo deste Capítulo é fornecer ao leitor uma visão geral dos algoritmos utilizados para a realização do roteamento detalhado para FPGAs.
O algoritmo de base utilizado nos atuais sistemas de roteamento é o Maze, descrito na Seção 3.1.
Após o detalhamento desse algoritmo de roteamento, serão apresentados alguns roteadores acadêmicos (Seção 3.2).
Em a Seção 3.3 é apresentada a comparação de desempenho entre os mesmos.
Algoritmo Maze Lee e Moore propuseram um algoritmo para realizar o roteamento de redes com dois terminais, visando obter o menor caminho entre os mesmos.
Desde então, o algoritmo básico vem sendo incrementado de forma a otimizar a execução (velocidade) e otimizar a quantidade de memória utilizada por o mesmo.
O algoritmo proposto por Lee e Moore e as versões derivadas desta implementação compõem a classe dos algoritmos Maze.
O exemplo de uma rede sendo roteada através do algoritmo do Lee é ilustrada na Figura 15.
Destino (a) grafo que representa o FPGA.
A classe dos algoritmos Maze é utilizada para encontrar o menor caminho entre um par de pontos, chamados de origem (source) e destino (s) (target (s)), numa matriz retangular ou quadrada.
O processo de procura ocorre a partir de a propagação de uma frente de onda da origem até que o destino seja encontrado.
Esta frente de onda possui níveis distintos, que indicam a distância que a origem se encontra do destino.
O nível inicial (origem) é 0, todos os pontos que fazem fronteira com a origem recebem o nível 1, e assim sucessivamente, até o destino.
O objetivo principal de colocar níveis nas frentes de onda é garantir que o menor caminho seja o escolhido entre a origem e o destino.
Quando o destino é atingido por a frente de onda inicia- se então o processo de retropropagação, ou seja, o caminho encontrado na primeira fase é realizado de forma inversa, do destino para a origem, procurando sempre um nível inferior (frente de onda da propagação) até que o nível 0 seja encontrado.
Assim é possível garantir que o menor caminho entre os dois pontos foi encontrado.
O algoritmo procura o destino simetricamente em todas as direções, usando a técnica de procura breadth-first search.
Se o caminho entre a origem e o destino existir, é possível garantir que o caminho encontrado é o menor caminho entre os dois pontos.
O pior caso que pode acontecer é da origem estar no centro da grade e o destino estar localizado na borda.
Para que o destino seja atingido todos os pontos da grade terão de ser visitados.
Supondo que o algoritmo não conseguiu rotear todas as redes do circuito, é utilizada a técnica de &quot;rip-up&amp; re-route».
Essa técnica consiste em re-incializar toda a estrutura de dados que representa o FPGA, re-ordenar as redes e executar uma nova tentativa de roteamento.
A ordenação das redes segue a seguinte norma:
As redes que não foram roteadas são colocadas no topo da lista de redes para que se obtenha sucesso no roteamento das mesmas numa nova tentativa, e as redes que foram roteadas com sucesso na iteração anterior completam a lista.
O algoritmo do tipo Maze proposto por Lee, possui algumas variações.
Hadlock propõe limitar o espaço de busca na grade por a definição da área que envolve todos os vértices da rede.
A propagação só ocorrerá nos vértices que estão contidos nessa região.
Consequentemente, quando a frente de onda encontrar uma borda qualquer dessa região não será mais propagada.
Em o pior caso a complexidade em relação a o tempo de roteamento e o espaço utilizado é O (h.
W), onde h e w são as dimensões do FPGA.
Soukup propõe diminuir o tempo de procura do destino, que no algoritmo original é muito alto.
Este algoritmo consiste em propagar frente de onda em apenas uma direção até que o destino seja encontrado ou encontre um obstáculo, ou seja, um canal já roteado.
Supondo que o destino tenha sido encontrado é feita a retropropagação para que a conexão seja realizada, se o destino não tiver sido encontrado.
Então, a frente de onda continua a sua propagação numa nova direção.
Essa estratégia diminui o tempo de procura do destino, em compensação não consegue garantir que o menor caminho entre a origem e o destino seja encontrado.
Em o pior caso a complexidade em relação a o tempo de roteamento e o espaço utilizado é O (h.
W), onde h e w são as dimensões do FPGA.
Mais recentemente foi apresentada uma nova versão para o algoritmo Maze.
O objetivo principal deste algoritmo é minimizar os componentes RC das redes, alcançando com isto um melhor desempenho elétrico.
O autor relata que o desempenho do algoritmo é até 300 vezes superior ao algoritmo Maze clássico, por sua operação se basear em princípios de roteamento global.
Algoritmos e softwares de roteamento acadêmicos O algoritmo básico do CGE (Coarse Graph Expansion) é dividido em duas fases:
Observa- se que a rede parte de um bloco lógico (L), passa por duas regiões de roteamento (C) e uma switch box, chegando ao seu destino, em outro bloco lógico (L).
O roteamento detalhado é dividido em duas partes, expansão do grafo e realização da conexão.
A primeira etapa expande o grafo gerado por o roteamento global e armazena o número de caminhos possíveis para cada rede.
A Figura 17a mostra o grafo expandido.
Em esta figura observa- se que a região de roteamento conectada ao bloco lógico L (2,2) possui apenas três trilhas livres, enquanto que e a região de roteamento conectada ao bloco lógico L (4,4) possui quatro trilhas livres.
Início Lê o roteamento global de cada conexão Apaga as conexões bloqueadas e incrementa os parâmetros de corte Cria o modelo do FPGA Expande as conexões não roteadas Seleciona segmentos de trilhas para conexões não roteadas atualiza Não Tudo Roteado?
O software Sega é uma variação do software CGE.
A diferença está na função custo, que leva em consideração os segmentos de fio longos para minimizar o atraso.
Para a utilização deste software foi criado um método de roteamento global de dois estágios, seguido por o roteamento detalhado.
Os parâmetros de entrada do Sega compreendem uma lista de redes do circuito a ser roteado (netlist), e um arquivo que descreve a arquitetura do dispositivo.
A partir destes dois arquivos é criado um grafo para cada rede.
O roteamento global utilizado é uma adaptação do algoritmo de roteamento global LocusRoute.
Este roteador global separa o problema do roteamento global em dois subproblemas distintos:
Balancear a densidade dos canais de roteamento;
Atribuir um caminho específico para cada conexão.
Para solucionar o primeiro sub-problema as redes multi-ponto são divididas em redes de conexão simples, ou seja, apenas entre dois pontos e depois se encontra a menor conexão possível, solução do segundo sub-problema.
O objetivo principal deste algoritmo é distribuir o número de redes que passam por um determinado canal, a fim de obter uma distribuição uniforme das redes nos canais de roteamento.
Os segmentos longos de fio são utilizados quando a distância entre blocos lógicos for grande.
O roteamento detalhado, este executado por o Sega, é composto de duas fases distintas.
Em a primeira fase são enumeradas todas as possibilidades para rotear cada rede do circuito.
A segunda fase examina todas as alternativas de conexão e decide qual deve ser implementada, tendo como base uma função custo com quatro termos, que foi calculada enquanto a primeira fase era executada.
A Figura 19 apresenta uma tela depois do roteamento ter sido realizado.
Este software permite também manipular os parâmetros Fc e Fs.
A Equação 1 mostra esta função-custo.
Os dois primeiros termos referem- se à alocação de segmentos curtos ou longos, e os dois últimos termos referem- se à &quot;roteabilidade «da conexão.
O caminho que apresentar o menor custo é o escolhido.
Os fatores w, wc, wf referem- se aos pesos (weight) aplicados a cada parcela da função-custo.
Equação 1 ­ é a Função custo de quatro parâmetros, sendo que p designa um caminho de uma dada rede (path).
C (p) ­ mede o desperdício dos segmentos longos de fio por as conexões menores.
O C (p) é definido por o quociente do tamanho total desperdiçado dos segmentos longos em p por o comprimento total dos segmentos em p..
Quando um segmento longo é utilizado é comum que parte de seu comprimento não seja utilizado, daí o desperdício.
Logo, em conexões curtas, segmentos longos devem ser evitados.
C (p) ­ mede o número de segmentos utilizados numa conexão.
O C (p) é definido por min, sendo min o número mínimo de segmentos que p pode utilizar e seg o número seg segmentos em p..
Quando mais próximo seg for do número mínimo de segmentos, menor será este fator.
Cc (p) -- permite que o roteador selecione uma conexão mesmo que a mesma possua poucas alternativas de roteamento.
Pode ser definida como a taxa do número de caminho restantes no grafo expandido.
Cf (p) ­ permite que o roteador selecione o caminho a ser conectado de forma a minimizar efeitos negativos nas outras conexões, ou seja, uniformiza a densidade de segmentos em cada canal.
O parâmetro Cf (p) é calculado armazenando todas as ocorrências dos segmentos em p que aresta possui j outras ocorrências, então Cf (p) é dada por:
onde: Alt (ej) é o número de arestas em paralelo com ej.
O VPR (Versatile Place and Route) é uma ferramenta de posicionamento, roteamento global e roteamento detalhado para FPGAs.
O algoritmo de posicionamento utilizado é o de têmpera simulada (Simulated Annealing), onde a chave do problema está numa função custo linear que leva em consideração a dificuldade de conexão em regiões com diferentes larguras de canal.
O roteamento é realizado através de uma variação do algoritmo PathFinder.
O algoritmo utiliza um algoritmo Maze para rotear cada rede.
Se uma rede ficar bloqueada durante o roteamento, então é realizado rip-up e re-route até que a conexão bloqueada seja roteada.
Uma importante característica de software é flexibilidade para a descrição da arquitetura alvo, através de um arquivo de configuração.
Em este arquivo os seguintes parâmetros podem ser capturados:
A palavra chave pinlist introduz uma lista contendo os nomes de todas as redes conectadas ao bloco lógico.
A identificação é posicional em relação a o arquivo que descreve a arquitetura.
Em a versão atual do VPR, o identificador subblock não é utilizado.
A Figura 22 apresenta um exemplo de circuito convertido para o formato (dot)_ NET.
Este circuito é constituído por um único bloco lógico, com três entradas e duas saídas.
Em o exemplo apresentado, quando um pino não é conectado utiliza- se a palavra chave open, devido a a conexão posicional entre a instância da CLB e sua declaração no arquivo de arquitetura.
A Figura 23 apresenta, parcialmente, um arquivo com a lista de redes (netlist) que serve como ponto de partida para o roteador VPR.
A Figura 24 apresenta o circuito depois da realização da etapa de posicionamento e a Figura 25 mostra como o circuito foi roteado por o software VPR.
VPR Timing Driven Para FPGAs que possuem a arquitetura de seus blocos lógicos baseados em clusters o roteador VPR teve de ser modificado para que pudesse utilizar todos os recursos deste tipo de arquitetura de FPGA.
Além de considerar clusters, esta versão do VPR considera em seu algoritmo de roteamento e posicionamento a otimização de desempenho.
A Figura 26 representa o fluxo de execução do roteador VPR Timing Driven.
A comparação do &quot;VPR timing driven «com o VPR demonstrou que o novo algoritmo de posicionamento aumentou em 42% o desempenho de posicionamento e posteriormente de roteamento.
Constatou- se também que houve a redução média de 5% na utilização dos segmentos de fio do dispositivo.
Os resultados foram obtidos através da utilização dos 20 circuitos de teste do conjunto de benchmarks MCNC.
Este algoritmo combina o roteamento global com o roteamento detalhado numa única etapa.
Assumindo que fs $= 3 e fc $= largura do canal de roteamento, o FPGA é roteado considerando cada domínio de trilhas como uma caixa e com um algoritmo greedy procura- se rotear todas as caixas até que não existam mais caixas sem conexão.
O método é utilizado por o software GBP, é similar ao método heurístico Best Fit Decreasing Bin--Packing.
Foi observado que o GBP não consegue uma ótima densidade para o último domínio.
Em o software OGC foi utilizado um outro mecanismo greedy, com uma modelagem diferente a fim de obter uma maior densidade nos domínios de trilhas, de forma a diminuir o roteamento utilizado.
Em esses algoritmos, de uma única etapa, as redes multi-ponto são roteadas uma de cada vez.
Se o roteamento falhar numa das redes, ela é movida para o começo da lista e o algoritmo é reiniciado, podendo assim ocorrer uma postergação indefinida.
Os objetivos propostos por este algoritmo são:
Aumentar a &quot;roteabilidade «e o desempenho (diminuir os atrasos) do circuito.
O roteamento é realizado em duas etapas:
Roteamento inicial e rip-up e re-route.
Em a primeira etapa, as redes são roteadas seqüencialmente de acordo com as suas prioridades, ou seja, primeiro as redes onde o atraso se torna mais crítico.
Durante a segunda etapa, é usado um rip-up e re-route, para solucionar problemas de violação dos recursos de roteamento (a rede ficou bloqueada) e os atrasos.
O FPR é uma ferramenta para posicionamento e roteamento simultâneos para FPGAs das séries 3000 e 4000 da Xilinx.
Este software combina uma estratégia geométrica recursiva para o posicionamento e roteamento global com um algoritmo baseado em coloração de grafos para o roteamento detalhado.
O posicionamento e o roteamento global utilizam uma técnica denominada &quot;Thumbnail Partitioning», que decompõe o circuito num plano m x n..
O roteamento detalhado é modelado como um grafo onde os vértices são os blocos lógicos e as arestas suas conexões.
As duas etapas são resolvidas através de uma árvore de Steiner, utilizando um algoritmo heurístico, que soluciona este problema em tempo polinomial.
Este algoritmo tem como objetivo principal reduzir a área e reduzir a densidade de roteamento nos canais.
Este software é utilizado para rotear FPGAs simétricos, desenvolvido com base no XC3000.
O objetivo é rotear o circuito no FPGA com o menor atraso possível, impondo restrições.
Esse software possui 4 passos:
Calcular o atraso de cada rede e ordenar- las em ordem decrescente de valor de atraso;
Alocar os recursos de roteamento, identificando as redes(\&gt; atraso) que serão roteadas nos segmentos longos;
roteia o número máximo de redes nos segmentos longos, de forma a esgotar este recurso de roteamento e roteia as redes que sobraram nos segmentos unitários2.
Em o primeiro passo, é utilizada uma função custo para determinar o atraso da rede:
L- value $= 1* netslack+ 2* fanout+ 3* span+ 4* USP Os parâmetros utilizados são os seguintes:
Netslack: É a diferença entre o tempo requerido para o sinal ser propagado até o destino e o tempo real de propagação.
Quanto mais negativo for o netslack, mais crítica é a rede.
Fanout: É o número de pinos conectado à saída de um bloco lógico.
Um fanout alto indica que a rede é crítica.
Span: Representa o comprimento da rede.
Quanto maior for a distância entre os blocos lógicos de uma rede, mais crítica é a rede.
USP: É um parâmetro opcional que é definido por o usuário para indicar uma rede mais crítica.
Segundo o autor, para que este software apresente um bom desempenho, as constantes devem possuir os seguintes valores:
Em o segundo passo, as redes são indicadas para o roteamento em segmentos longos de fio em razão de o atraso elevado.
Em o passo seguinte é iniciado o processo de roteamento nos segmentos longos, de forma a esgotar os segmentos longos de fio.
Para finalizar as redes restante são roteadas nas linhas de propósito geral.
Nota- se que o XC3000 possui apenas dois recursos de roteamento:
As linhas longas e as linhas de propósito geral.
Comparação entre os algoritmos de roteamento Em a Tabela 2 são apresentados os algoritmos de roteamento, seus algoritmos de base e as suas principais características.
Exploração de doglegs nos pinos de entrada e saída.
Para explicar o que significa doglegs será utilizado um exemplo prático.
Quando houver a necessidade de realizar duas conexões contidas no mesmo espaço de roteamento horizontal, de tal forma que a realização de uma conduz ao bloqueio da outra, haverá a necessidade de romper uma das conexões, através de uma ou mais chaves, criando assim uma rota alternativa para a conexão bloqueada.
Exploração dos Segmentos de Fio Longo. O objetivo desta técnica é reduzir o atraso provocado por as resistências e capacitâncias parasitas provenientes das chaves de conexão, reduzindo o desempenho do circuito.
Outra vantagem é que os sinais globais, por exemplo clocks ou resets, podem ser distribuídos uniformemente ao longo de todo o circuito.
Os softwares que utilizam essa técnica são o LocusRoute, Sega, VPR.
Rip-up e Re-routing.
Essa técnica é utilizada principalmente nos softwares de roteamento de dois passos, roteamento global e roteamento detalhado e em poucos casos nos softwares que realizam o posicionamento e o roteamento simultâneos.
O método consiste numa primeira fase chamada de roteamento global, onde é atribuída a rota que cada rede deve seguir.
Uma vez as rotas atribuídas, tem início a fase de roteamento detalhado, com o objetivo de realizar através dos recursos de roteamento disponíveis a conexão física dos blocos lógicos.
Quando uma conexão não pode ser fisicamente realizada, o algoritmo executa a rotina de rip-up e re-routing.
Essa rotina retira as conexões que bloqueiam determinada rede (rip-up), reordena a lista de redes, relançando o roteador sobre estas redes (removidas e não roteadas), processo denominado re-route.
Mecanismo de Solução Gulosa. Os algoritmos gulosos utilizam o princípio da localidade para encontrar a solução.
Consistem em dividir o problema em partes iguais e resolver apenas localmente, sendo que a solução encontrada é generalizada supondo que o comportamento seja o mesmo para todas as partes.
A primeira vista, o algoritmo parece eficiente, pois se consegue solucionar o problema local, obrigatoriamente o problema global será solucionado a partir de uma generalização da solução local.
No caso de o roteamento de FPGA é possível encontrar uma solução ótima local, porém quando generalizada a solução poderá haver redes não roteadas, sendo necessária a utilização de técnicas de rip-up e re-route para a completa solução do roteamento.
Árvore de Steiner. Modela- se o FPGA como um grafo, onde os nodos são os blocos lógicos e as arestas a suas conexões.
Como todas as redes possuem uma origem e um ou mais destinos, a origem é chamada de raiz e os nodos restantes são denominados nodos-folha.
Em razão de isto, a rede recebe o nome de árvore.
A árvore de Steiner tem como objetivo principal encontrar o menor caminho entre a origem e os destinos.
Quanto maior o número de nodos-folha, maior será a profundidade do grafo, contribuindo para o aumento da complexidade do problema.
Encontrar a menor árvore valorada que esteja conectada a todos os vértices de G, é classificado como um problema Np-completo.
Desempenho dos algoritmos A Tabela 3 apresenta a comparação entre os vários softwares de roteamento, onde os valores apresentados indicam a densidade mínima do canal.
Esta tarefa é realizada através de circuitos de teste (benchmarks) e o parâmetro utilizado é o de número máximo de trilhas por canal de roteamento.
Os valores mostrados na tabela correspondem ao número mínimo de trilhas por canal para rotear todo o circuito.
Os valores apresentados por a Tabela 3, foram obtidos com a combinação de ferramentas de posicionamento, roteamento global e roteamento detalhado.
A combinação dos roteadores acadêmicos VPR (posicionamento e roteamento global) e Sega (roteamento detalhado) obteve a menor densidade de trilhas por canal.
Com esta combinação foram necessárias 62 trilhas para que os 9 circuitos de teste fossem roteados com sucesso.
Esta comparação permite concluir que os algoritmos com roteamento global e detalhado em duas etapas (VPR e Sega), podem ser competitivos com os algoritmos de roteamento de uma etapa (TRACER e SROUTE), quando apenas a rotabilidade é importante.
É possível notar que o melhor desempenho global entre os softwares que utilizam o posicionador Altor é alcançada por o software TRACER.
Para a obtenção do melhor desempenho é preciso combinar os softwares VPR e Sega, onde o primeiro realiza o posicionamento e o roteamento global, indicando a rota que cada rede deve seguir, e o segundo, realiza o roteamento detalhado.
Existem outros circuitos de teste (Benchmarks), que foram utilizados na geração dos resultados da Tabela 4.
Os valores para o VPR foram encontrados através da realização de testes no laboratório.
Essa Tabela mostra a largura do canal necessária para que seja feito o posicionamento e o roteamento dos circuitos de teste.
Em a Tabela 4, observa- se que o VPR utilizou 197 trilhas enquanto o Sega utilizou 334 trilhas.
Com o objetivo de incentivar os pesquisadores a pesquisar novas formas de se rotear circuitos grandes, os autores do VPR propuseram um desafio.
O desafio consiste em desenvolver um roteador capaz de rotear todos os circuitos da tabela acima, com o menor número de trilhas possível.
O roteador SC-PathFinder apresentado em[ CHA97] e[ CHA00] conseguiu vencer o desafio reduzindo o número de trilhas necessárias para que os circuitos da tabela acima fossem roteados com sucesso.
Esse roteador necessitou de apenas 188 trilhas para rotear os circuitos, nove trilhas a menos do que necessitou o VPR.
A Tabela 5 apresenta a comparação entre o VPR e o roteador SC-PathFinder, atual vencedor do desafio proposto, e algoritmo de melhor desempenho hoje encontrado na literatura.
O objetivo deste Capítulo é apresentar a implementação do algoritmo seqüencial de roteamento.
A Seção 4.1 descreve os arquivos de entrada de dados (lista de redes e arquivo de arquitetura) do algoritmo de roteamento e suas estruturas.
Em a Seção 4.2 é apresentada a modelagem de dispositivos programáveis FPGA na forma de um grafo parametrizado, e como foi modelado através de uma matriz de números inteiros e será apresentada a biblioteca de estruturas de dados e algoritmos Leda.
A Seção 4.3 descreve a implementação do algoritmo Maze e as estruturas utilizadas na sua implementação.
A Figura 29 apresenta o fluxo de funcionamento do algoritmo de roteamento e suas entradas de dados.
Inicio Arquivo LCA Lê arquivos Incializa estruturas Ordena lista de redes Arquivo de Arquitetura Escolhe rede não roteada Roteia rede Limpa as estruturas Não Sim Roteada com sucesso?
Não Não Acrescenta na lista de redes não roteadas Acrescenta na lista de redes roteadas Número de tentativas esgotado?
Todas as redes processadas?
Fim com sucesso Sim Todas as redes roteadas?
Entrada de Dados A entrada de dados para a execução do algoritmo de roteamento é realizada através de dois arquivos, onde um contém a descrição da arquitetura do dispositivo FPGA e o outro a lista de redes do circuito a ser roteado.
A Seção 4.1.1 apresenta o arquivo de arquitetura, as estruturas e como é realizada a leitura do mesmo e na Seção 4.1.2 é apresentado o arquivo que contém a lista de redes representando o circuito a ser roteado.
Em o arquivo de arquitetura é definido o tipo de dispositivo que está sendo utilizado, o número de linhas e colunas de CLBs, o número de trilhas existentes em cada canal, a disposição dos pinos de conexão do Bloco Lógico e o número de vezes que o processo de roteamento deve ser realizado até o circuito ser totalmente roteado no dispositivo.
Estas informações são armazenadas na estrutura apresentada por a Figura 30 e um exemplo do arquivo de arquitetura pode ser visto no Anexo I. Este formato foi definido no escopo deste trabalho, não sendo um formato padrão.
A estrutura &quot;arc_ arch «é composta por 5 variáveis e por uma lista da estrutura &quot;arc_ pin».
A variável &quot;fpgaTipo «informa qual é o tipo de dispositivo que será utilizado.
As variáveis &quot;linhas «e &quot;colunas «indicam a quantidade de linhas e colunas de CLBs do dispositivo, ou seja, a quantidade de Blocos Lógicos existentes no dispositivo e a variável &quot;trilhas «informa o número de trilhas existentes em cada canal de roteamento.
A variável &quot;repeticoes «indica o número de execuções de &quot;rip-up and re-route «que devem ser executadas até o circuito ser roteado com sucesso.
Em a estrutura &quot;arc_ pin «são armazenadas as informações relativas à posição dos pinos de conexão do Bloco Lógico.
Ela é composta por duas variáveis e um ponteiro.
A variável &quot;pNome «indica o nome do pino, a variável &quot;pPosicao «indica em qual direção está localizado o pino de conexão do Bloco Lógico.
O ponteiro é utilizado para a criação de uma lista encadeada.
As posições dos pinos de conexão no arquivo de arquitetura são descritas por norte, sul, leste, oeste ou qualquer um dos lados do CLB (&quot;north», &quot;south», &quot;east», &quot;west «ou &quot;anyside&quot;).
Após a leitura, essas denominações são convertidas em números inteiros para que a execução do algoritmo seja simplificada.
O arquivo de lista de redes(».
Lca&quot;) contém todas redes que compõem o circuito a ser roteado.
Cada linha do arquivo corresponde a uma única rede do circuito, todas elas possuem a palavra &quot;Addnet «no início para indicar que a rede deve ser adicionada no circuito.
A sintaxe de cada rede é ilustrada por a Figura 32 e no Anexo II é apresentado um exemplo de arquivo de lista de redes.
A estruturas que armazenam as redes estão ilustradas na Figura 33.
A estrutura ap_ rede &quot;é composta por 7 variáveis e uma lista da estrutura ap_ ponto «que indica todas as conexões da rede.
A partir de a estrutura ap_ rede «é criada uma lista contendo todas as redes que compõem o circuito.
A variável &quot;Nome «é do tipo char e armazena o nome da rede a ser roteada e a variável &quot;nNome «é o nome da rede representado por um inteiro para facilitar a identificação da mesma numa matriz tri-dimensional.
As variáveis &quot;xmin», &quot;ymin», &quot;xmax «e &quot;ymax «são utilizadas para representar os limites de propagação para a rede que está sendo roteada.
Essas variáveis são preenchidas com as coordenadas mínimas e máximas representando um retângulo de procura.
Assim quando a propagação está ocorrendo e atingir a fronteira determinada por essas variáveis, o processo de expansão da frente de onda é interropido.
E por fim, a variável &quot;nTerms «indica a quantidade de pontos existentes na rede.
Essa informação é muito importante para que a lista de redes seja ordenada de forma decrescente.
A estrutura ap_ ponto «possui três variáveis inteiras que identificam em qual canal este pino da CLB está conectado e um ponteiro que indica o próximo ponto da rede.
A localização do canal é fornecida por a tripla (hv, x, y), onde hv indica se o canal está na vertical ou na horizontal, e as coordenadas x e y representam a linha e a coluna respectivamente no FPGA.
A Figura 34 representa a lista de redes e as suas estruturas.
A Figura 35 apresenta a rotina de leitura do arquivo de redes e a conversão das coordenadas dos Bloco Lógicos para lista de redes composta por a estrutura ap_ rede».
Em essa rotina a primeira tarefa a ser realizada é a leitura de todo o arquivo para uma lista de strings, visando assim reduzir o tempo de processamento visto que não é realizado nenhum acesso a disco para a conversão da rede lida.
Após a leitura do arquivo a rotina fica num laço enquanto a lista de strings não for vazia, procura o nome da rede e associa à mesma um número inteiro seqüencial.
Um novo laço é iniciado onde vão ser identificados e convertidos os pontos que compõem a rede até que a linha que está sendo analisada chegue ao fim.
Em essa etapa é também definida a janela de propagação e no final do laço determina- se o número de pontos da rede.
A função &quot;Converte Coordenadas «é utilizada para realizar a conversão das coordenadas lidas em coordenadas representadas por números inteiros (hv, x, y).
A rotina de conversão das coordenadas é descrita por a Figura 36.
Modelagem do FPGA Em a Seção 4.2.1 é apresentada a modelagem do FPGA como um grafo parametrizado.
Para a realização dessa modelagem era utilizada a biblioteca de estruturas de dados e algoritmos Leda.
Essa modelagem teve de ser abandonada, porque a biblioteca Leda deixou de ser de domínio público.
Em a Seção 4.2.2, é apresentado o FPGA modelado como uma matriz de estruturas, com 3 dimensões.
O dispositivo FPGA pode ser modelado como um grafo parametrizado onde os vértices são as matrizes de chaves (&quot;switch box&quot;) e as arestas representam os canais de roteamento, como pode ser observado na Figura 37.
Os Blocos Lógicos são identificados por uma dupla de letras (ou também par x, y) que informa a sua posição (linha, coluna) no dispositivo e os pinos de saída dos blocos são conectados a quatro canais de roteamento.
Os canais de roteamento são conectados entre si por as matrizes de chaves( «Switch
Box&quot;), e cada matriz de chaves deve ter no mínimo 2 canais de roteamento conectados.
Para a implementação dessa estrutura foi utilizada a biblioteca de estruturas de dados e algoritmos (Leda), por possuir a implementação de estruturas complexas (listas, filas, grafos, etc) e funções de para o tratamento dessas estruturas já implementadas.
As principais características dessa biblioteca são:
Leda provê uma considerável coleção de tipos de dados e algoritmos de forma simplificada tornando acessíveis as operações com tipos complexos, por exemplo grafos, a qualquer programador.
Possibilita uma especificação precisa e amigável para cada tipo de dado e algoritmo.
As especificações são pequenas (apenas uma linha de programação), gerais (permite a utilização em diferentes implementações) e abstratas (mascaram todos os detalhes de implementação).
Para uma estrutura de dados eficiente o acesso posicional é muito importante.
Em a Leda, o conceito de item foi desenvolvido de uma forma abstrata e de uso simplificado.
Contém implementações eficientes para cada tipo de dado, por exemplo, o algoritmo de procura Depth First Search, os algoritmos para descobrir o menor caminho em grafos (Dijkstra's e Minimum Spanning Tree) entre outros.
As arestas do grafo possuem toda a informação de roteamento, armazenada na estrutura &quot;CHANNEL».
O contador &quot;counter «é utilizado para indicar o nível de propagação da frente de onda através do grafo na fase de propagação, e vai sendo incrementado caso a aresta não tenha sido visitada.
Em a fase de retropropagação este contador é analisado com o intuito de encontrar o menor caminho entre os vértices, que por sua vez vai sendo decrementado até que a origem da rede tenha sido encontrada.
A variável &quot;visited «indica se a aresta já foi localizada por a frente de onda ou não e a variável &quot;routing «indica que o processo de roteamento está sendo realizado, sendo essa variável utilizada por a fase de retropropagação.
O número de trilhas já preenchidas é indicado por a variável &quot;used_ tracks», que após o término do roteamento da rede todas as arestas pertencentes à mesma são incrementadas e o nome da rede é armazenado numa lista.
Para indicar à qual Bloco Lógico o canal está conectado existem duas variáveis para este fim:
&quot;block1 «e &quot;block2».
O preenchimento destas variáveis é função da coordenada do Bloco Lógico, obtida através da Equação 2.
A variável &quot;block1 «refere- se ao Bloco Lógico situado a esquerda do canal e a variável &quot;block2 «indica o Bloco Lógico que está a direita do canal.
Se o canal está localizado na periferia do FPGA, as variáveis &quot;block1 «e &quot;block2 «podem assumir valores negativos.
Os valores negativos indicam que não existem Bloco Lógico conectado ao mesmo.
Onde: XX indica a coordenada da linha YY indica a coordenada da coluna Equação 2 ­ Fórmula de conversão da coordenadas Existem ainda duas estruturas auxiliares ligadas entre si, a primeira é uma lista onde estão relacionados os blocos lógicos e suas devidas conexões na rede e a outra contém as redes com os blocos lógicos que compõem a mesma, descritas anteriormente na Seção 4.1.
A estrutura TRACK é composta por um número inteiro que indica o nome da rede e é utilizada na estrutura CHANNEL para indicar se existe e qual é a rede que passa por aquele canal.
A estrutura SBOX é composta por um número inteiro seqüencial utilizado como índice e 4 apontadores do tipo &quot;edge «(aresta) que indicam a direção do próximo vértice.
O vértice seguinte pode estar localizado à direita, à esquerda, acima ou abaixo (&quot;east, west, north, south&quot;).
Se o apontador possui o seu valor menor do que 0, indica que naquela direção a borda do dispositivo foi encontrada.
A primeira versão do algoritmo foi implementada com a utilização das estruturas acima citadas.
Após a realização de testes preliminares constatou- se que essa implementação apresentava um baixo desempenho (tempo de processamento elevado).
Os circuitos demoravam muito tempo para serem roteados.
Outro fator que contribui para procurar uma nova forma de modelar o FPGA foi que a biblioteca Leda deixou de ser de domínio público, dificultando desta forma o desenvolvimento de uma ferramenta acadêmica de livre distribuição.
A partir destes dois fatores partiu- se para uma nova forma de modelar o FPGA.
O dispositivo programável FPGA foi então modelado com uma matriz de estruturas com 3 dimensões.
O FPGA foi dividido em canais que estão na posição horizontal e canais que estão na posição vertical.
Esse tipo de modelagem facilita a implementação do algoritmo de roteamento por lidar com índices representados por números inteiros e também contém todas as informações de roteamento apontando por estes índices.
Os índices da matriz são organizados da seguinte forma:
O primeiro índice informa se o canal a ser visitado está na horizontal ou na vertical, e os outros dois indicam a linha (L) e a coluna (C) no interior do dispositivo programável FPGA.
Então por exemplo, o canal está situado na horizontal, na linha 0 e na coluna 0.
As estruturas utilizadas para esse tipo de modelagem estão representadas na Figura 40.
Char Nome; A estrutura principal é chamada de ap_ canal «composta de 4 variáveis inteiras e um vetor de números inteiros.
A variável &quot;Visited «indica se o canal foi visitado ou não e a variável &quot;Counter «é utilizada na propagação da frente de onda indicando qual o nível da onda que alcançou o canal.
O número de trilhas vagas é indicado por a variável &quot;Vagas».
A variável &quot;nTrilhas «indica a quantidade de trilhas existente no canal.
Este valor é obtido após a leitura do arquivo de arquitetura do dispositivo.
Essa estrutura tem um vetor de números inteiros chamado de &quot;Trilhas», com o tamanho de &quot;nTrilhas «alocado dinamicamente e é utilizada para armazenar o nome das redes que estão ocupando o canal, bem como as trilhas do canal que já estão ocupadas.
A estrutura ap_ rede «é inicializada na leitura do circuito, conforme a Figura 33.
Em o momento da execução do algoritmo de roteamento todas as estruturas são inicializadas de forma dinâmica com o objetivo de reduzir ao máximo a utilização de memória.
A inicialização da matriz de estruturas está descrita na Figura 41.
A entrada da função de inicialização é a estrutura que contém as informações da arquitetura do dispositivo.
Após saber quais são as dimensões do FPGA, é feita a alocação dinâmica da primeira dimensão da matriz que indica se o canal está posicionado na horizontal ou na vertical (variável hv).
Depois de alocar a primeira dimensão da matriz, as linhas da mesma são alocadas.
E por fim, são alocadas as colunas da matriz.
Algoritmo de Roteamento A Seção 4.3.1 apresenta a implementação do algoritmo de roteamento do tipo Maze, a propagação de frente de onda sobre a matriz até que todos os pinos da rede sejam encontrados.
A Seção 4.3.2 apresenta a retropropagação (ou &quot;Backtracking&quot;) que é responsável por indicar e identificar todos os canais por onde a rede passa.
Essa rotina de retropropagação retorna sempre a menor distância entre todos os pinos da rede.
Em a Seção 4.3.3, é apresentada a rotina de &quot;rip-up&amp; re-route».
Se a lista de redes a ser roteada estiver vazia, mas pelo menos uma rede não for roteada, utiliza- se a rotina de &quot;rip-up&amp; re-route».
Essa rotina re-inicializa a matriz que representa o FPGA, e monta uma nova lista de redes, para uma nova execução do algoritmo.
A Figura 42 ilustra a rotina principal do algoritmo de roteamento.
Como pode- se observar na Figura 42, o algoritmo de roteamento pode ser dividido em 2 laços:
Principal e roteamento.
O laço principal é controlado por o de número de vezes que o roteamento deve ser aplicado sobre a lista de redes, a fim de conseguir rotear todas elas, definido no arquivo de arquitetura.
Em esse laço é executada a rotina de &quot;rip-up&amp; re-route», somente quando pelo menos uma rede da lista de redes não foi roteada.
A estrutura que representa o FPGA é re-inicializada e uma nova tentativa de roteamento é iniciada.
Em o laço de roteamento são executadas a propagação da frente de onda e a rotina de retropropagação.
As redes que são roteadas com sucesso são acrescentadas numa lista de redes roteadas e as redes que não obtiveram sucesso no roteamento são armazenadas na lista de redes não roteadas.
O laço de roteamento só termina quando a lista de redes é vazia.
Se todas as redes foram roteadas com sucesso, o algoritmo termina.
Senão a lista de redes roteadas é acrescentada no final da lista de redes não roteadas e é feita uma nova tentativa de roteamento.
A primeira parte do algoritmo de roteamento do tipo Maze é a propagação da frente de onda a partir de a origem da rede até que algum canal utilizado por a rede seja encontrado, ou seja, um destino.
Antes de iniciar a propagação da frente de onda é necessário verificar se algum dos pinos de destino não está presente no próprio canal do pino de origem.
Em essa etapa são criadas duas listas auxiliares:
Uma contendo os canais que estão sendo roteados (lista de roteamento) e uma que contém a lista de destinos (lista de destinos).
De essa forma é possível verificar se algum dos pinos de destino foi encontrado.
A Figura 43 ilustra o funcionamento da propagação da frente de onda, o qual é detalhado nos parágrafos seguintes.
O primeiro passo do algoritmo é procurar os canais vizinhos à origem e adicionar- los a lista de roteamento, com o nível de propagação em 1.
Se o canal estiver posicionado na horizontal, o mesmo pode ter 2 canais vizinhos na horizontal e 4 canais vizinhos na vertical.
Se o canal estiver na posicionado na vertical, o mesmo pode ter 2 canais vizinhos na vertical e 4 canais vizinhos na horizontal.
Cada canal de roteamento possui no mínimo 3 canais vizinhos, situação que ocorre na periferia do FPGA.
Procura os canais vizinhos à origem da rede Acrescenta os canais vizinhos na lista de roteamento Encontrou destino?
Término da rotina com sucesso Término da rotina sem sucesso Retira o primeiro canal da lista de roteamento Lista de roteamento é vazia?
A Figura 44a ilustra quais são as coordenadas dos canais vizinhos ao canal horizontal e a Figura 44b as coordenadas dos canais vizinhos ao canal vertical.
A Figura 45 apresenta a rotina de procura e validação dos canais vizinhos.
Após encontrar os vizinhos deve- se verificar se as coordenadas vizinhas são válidas.
As coordenadas inválidas referem- se a 5 condições:
Canal já visitado, canal sem trilha disponível, canal fora de o quadrado envolvente da rede (bounding box), canal com coordenada negativa, ou canal com coordenada maior que a dimensão do FPGA.
Esta rotina retorna uma lista com todos os vizinhos válidos de um dado canal.
Esta lista é posteriormente acrescentada à lista de roteamento.
O ponto de origem da rede &quot;d «está localizado na coordenada &quot;112», ou seja, o pino está localizado num canal vertical, linha 1 e coluna 2 (tripla).
Os demais canais pertencentes a esta rede são armazenados na lista de destinos.
Conforme a Figura 44, já realizamos os dois primeiros passos:
Construção da lista de canais vizinhos à origem e inserção desta lista na lista de roteamento.
Esta lista de roteamento é apresentada na segunda coluna da Tabela 6, primeira iteração.
Em esta lista não foi encontrado nenhum dos destinos da rede.
O primeiro canal é removido da lista de roteamento, inserindo- se nesta lista os canais vizinhos ao canal removido.
A partir de esta lista de roteamento modificada é feita uma nova busca por destinos.
O procedimento é repetido até que seja encontrado um destino ou não seja mais possível propagar a frente de onda (lista de roteamento vazia).
A Tabela 6 mostra a lista de roteamento após as 2 iterações necessárias para que fosse encontrado o primeiro destino da rede &quot;d».
A Figura 48 representa no FPGA as duas iterações necessárias, no caso de essa rede, para que um de seus destinos seja encontrado.
É possível observar que a primeira iteração encontra apenas 5 canais vizinhos para a origem, sendo que essa origem deveria ter 6 canais vizinhos (2 verticais e 4 horizontais).
Isso acontece por causa de a aplicação de limites para a propagação da frente de onda, ou seja, a propagação só será realizada nos canais contidos na área tracejada.
Esse limite ajuda a diminuir o tempo de processamento, pois não é necessário procurar os destinos fora de o limite.
Os vizinhos encontrados após a primeira iteração, são adicionados à lista de origens.
Os canais vizinhos à origem passam a ser as origens para a propagação de mais um nível da frente de onda (nível 2).
Antes de realizar uma nova propagação é necessário verificar se algum destes vizinhos é um canal de destino.
Quando um destino da rede é encontrado, tem início a fase de retropropagação (&quot;Backtracking&quot;), que será apresentada na Seção 4.3.2.
Supondo que a retropropagação tenha sido realizada, o FPGA com a rede &quot;d «parcialmente roteada é ilustrado na Figura 49.
A partir de a rede parcialmente roteada é iniciada uma nova propagação, onde as origens são os canais já roteados.
Essa técnica é utilizada para que os destinos que restam sejam encontrados de uma forma mais eficiente.
Ao invés de a propagação partir de um único ponto (canal de origem da rede), propaga- se a partir de 3 canais.
A Figura 50 mostra a propagação da frente de onda a partir de a rede parcialmente roteada.
A Tabela 7 ilustra as 3 iterações necessárias para que o próximo destino da rede &quot;d «seja encontrado.
O canal não possui nenhum vizinho para propagar a frente de onda, pois seus únicos vizinhos possíveis já tinham sido utilizados por os outro canais da lista de roteamento.
É possível também notar que a propagação ocorre de forma homogênea sobre o FPGA e obedecendo aos limites estabelecidos por o tamanho da rede.
Pode- se observar também que os dois destinos restantes encontram- se à mesma distância dos canais de origem.
Sendo assim, apenas um de eles será encontrado nessa propagação.
Em o momento em que um dos destinos for encontrado a propagação da frente de onda será interrompida e o outro destino ficará para a próxima propagação.
Isso ocorre porque para cada propagação com sucesso, temos apenas uma execução da rotina de retropropagação.
Não há critério de escolha para qual desses destinos deve ser roteado primeiro.
Em o Anexo II é descrito o circuito completo, de onde a rede &quot;d «foi retirada apenas para ilustrar o roteamento por o algoritmo proposto.
As coordenadas do circuito convertidas e o seu roteamento completo podem ser observados nesse Anexo.
O Anexo III apresenta a tela de execução do algoritmo proposto.
A propagação sem restrição de matrizes de chaves, ou seja, fs $ , não necessita verificar se as trilhas vagas na origem da rede permanecem vagas em todos os canais vizinhos.
Quando não utilizada a restrição de matrizes de chaves, a área de propagação torna- se maior, pois qualquer segmento da rede pode utilizar qualquer trilha do canal.
Para exemplificar será utilizado o circuito descrito no Anexo II.
A Figura 52 representa a parte &quot;congestionada «do circuito &quot;paper_ Lca».
Para a realização do mesmo não foi utilizada nenhuma restrição de matriz de chaves (fs $ ) e com a largura de canal igual a 2.
Se não for aplicada a restrição o circuito pode ser roteado.
Como é possível observar na Figura 52, a rede &quot;a «ocupa a trilha 0 do canal e ocupa a trilha 1 dos canais e.
Se a restrição de matriz de chaves for aplicada o algoritmo esgota todas as tentativas de roteamento definidos no arquivo de arquitetura.
Quando a restrição de matrizes de chaves é aplicada (fs) deve- se verificar se os canais vizinhos à origem e posteriormente todos os canais que vão compor a rede possuem a mesma trilha vaga.
Pode acontecer do canal possuir trilhas vagas, mas se não forem exatamente as mesmas trilhas vagas nos demais canais encontrados, o canal deve ser desconsiderado, porque não há caminho disponível para que possa encontrar um destino.
A Figura 53 apresenta a parte &quot;congestionada «do circuito descrito no Anexo II.
A largura teve de ser aumentada numa unidade, para que o circuito pudesse ser roteado aplicando as restrições de matriz de chaves.
Em a Figura 53 pode- se observar que cada rede ocupa sempre o mesmo canal em todos os seus componentes (canais).
A retropropagação possui esse nome por realizar a propagação da frente de onda na ordem inversa (destino até a origem da rede que está sendo analisada).
Em a propagação da frente de onda (origem até destino), descrita na Seção 4.3.1, a frente de onda se espalha por os canais numerando- os em ordem crescente, onde a origem recebe o número 0.
A retropropagação é dividida em duas partes:
Procura de vizinhos (canais) com nível de propagação menor do que o canal que está sendo analisado (rotina &quot;BackTracking «da Figura 54) e a sinalização da rede nos canais (rotina &quot;Preenche Estrutura FPGA da Figura «54), roteando assim a rede.
As restrições aplicadas a retropropagação são:
O nível do canal atual deve ser menor que o nível do canal anterior, o canal deve ter sido visitado por a primeira frente de onda, o canal analisado deve possuir pelo menos uma trilha vaga e deve- se evitar a troca de direções nos canais para que sejam usados os segmentos longos de fio (não utilizados na presente implementação).
Essa restrição melhora a desempenho do circuito, diminuindo o atraso da rede.
Esse atraso é causado por a capacitância existente nas matrizes de chaves do FPGA.
Quanto maior o número de matrizes de chaves possuir a rede em todo o seu percurso, maior será o atraso.
A Figura 55a apresenta uma rede roteada sem a aplicação da restrição de troca de direções e a Figura 55b apresenta a mesma rede roteada utilizando a restrição de troca de direções.
A primeira parte é iniciada logo após a propagação da frente de onda, da origem até um dos destinos da rede.
É nessa fase que são aplicadas duas das três restrições para a retropropagação.
A primeira restrição aplicada é a do nível de propagação, que deve ser menor nos canais vizinhos ao que está sendo analisado.
A segunda restrição é que os canais vizinhos devem ter sido &quot;visitados «por a frente de onda (da origem até um dos destinos).
Para demonstrar mais claramente como a retropropagação funciona será utilizado o mesmo exemplo da Seção 4.3.1.
A Figura 56 ilustra como é realizada a primeira etapa da retropropagação sobre o exemplo da rede &quot;d», descrita na Seção anterior.
O canal marcado com um círculo é o primeiro destino que foi encontrado na propagação da frente de onda.
É possível observar que o mesmo possui o nível de propagação igual a 2.
A procura dos vizinho é facilitada por a observação das restrições.
O canal destino possui 3 canais vizinhos que podem indicar o caminho até a origem, pois os demais não foram visitados por a frente de onda, por estarem fora de a área de procura da rede.
Aplicando- se as duas restrições dessa etapa, conclui- se que o canal analisado possui dois canais vizinhos com o nível de propagação igual ao que está sendo analisado, e apenas um indicando o nível de propagação menor do que o nível de propagação inicial.
A retropropagação é interrompida quando a origem da rede é encontrada.
O passo seguinte, após a origem ter sido encontrada, é a verificação da existência de trilhas vagas no canal.
Os canais que formam a rede são armazenados numa lista, sendo que essa lista é percorrida até que pelo menos uma trilha vaga seja encontrada.
Tendo encontrado uma trilha vaga, o contador de trilhas vagas (&quot;Vagas», Seção 4.2.2) é diminuído de uma unidade.
Após saber que o canal possui ao menos uma trilha vaga, é necessário saber qual a trilha que pode ser utilizada por a rede.
Depois de encontrada a trilha disponível, o nome da rede é colocado no vetor de trilhas (&quot;Trilhas», Seção 4.2.2).
A rede &quot;d «parcialmente roteada é apresentada na Figura 49 da Seção 4.3.1.
Em esta fase é que se aplica a restrição de canal (fs).
Se a restrição de canal for aplicada, todos os pontos da rede devem ser analisados a fim de que seja encontrada a mesma posição vaga no vetor de trilhas, para que o circuito seja completamente roteado.
Se essa restrição não for aplicada, as trilhas são escolhidas em ordem seqüencial, não importando se todos os pontos do circuito utilizam a mesma trilha no canal.
Sendo assim o espaço de procura para se rotear uma rede é reduzido.
Após a rede ser completamente roteada é necessário realizar a limpeza das estruturas.
Para realizar a limpeza, as variáveis &quot;counter «e &quot;routing «recebem o valor 0.
Tendo cuidado para não alterar a variável que informa a quantidade de trilhas vagas no canal (&quot;Vagas&quot;) e o vetor que indica os nomes das redes presentes no canal (&quot;Trilhas&quot;).
A técnica de &quot;rip-up&amp; re-route «é relativamente simples de ser implementada e é muito utilizada em algoritmos de roteamento.
O &quot;rip-up&amp; re-route «é executado quando o circuito não pode ser totalmente roteado no FPGA.
Em o &quot;rip-up é realizada uma «limpeza geral», sendo toda a estrutura que representa o FPGA reinicializada.
Esse processo é chamado assim, por desfazer todas as conexões (redes) que obtiveram sucesso na fase de roteamento.
A primeira iteração do roteamento ocorre com a &quot;lista de redes «ordenada conforme o &quot;fanout «de cada rede, ou seja, número de trilhas utilizadas para rotear a mesma.
Essa lista é ordenada de forma decrescente, pois redes com grande &quot;fanout «podem ser bloqueadas por as redes com &quot;fanout «menor.
Assim sendo, redes com alto &quot;fanout «devem ser roteadas primeiro e assim sucessivamente.
Durante o processo de roteamento cada rede que vai sendo roteada com sucesso é inserida numa lista denominada de &quot;lista de redes roteadas».
Por sua vez, as redes que não são roteadas são armazenadas em outra lista chamada de &quot;lista de redes não roteadas».
A o final do roteamento, é verificado se todas as redes circuito foram roteadas, ou seja, se a &quot;lista de redes não roteadas «é vazia.
Se essa lista não estiver vazia, é necessario que as redes sejam reordenadas e inseridas na &quot;lista de roteamento».
Essa reordenação é realizada da seguinte forma:
Todas as redes que não foram roteadas são inseridas na &quot;lista de roteamento», para que sejam as primeiras redes a serem roteadas.
E a &quot;lista de redes roteadas «é inserida no final da &quot;lista de roteamento».
É imperativo para que o roteamento seja concluído com sucesso, que essa ordenação seja feita na forma descrita acima.
Pode acontecer de uma rede muito longa, bloquear redes menores.
Como conseqüência da nova ordenação, as redes não roteadas na primeira tentativa serão as primeiras a serem roteadas.
Após estas terem sido roteadas, seque o roteamento das redes que foram roteadas com sucesso.
O Anexo IV mostra a execução do algoritmo de roteamento no circuito de teste «seq.
Lca &quot;e a execução de o «rip-up&amp; reroute».
O número de tentativas que o roteamento deve ser realizado, no caso de o algoritmo apresentado (Seção 4.3), é definido no arquivo de arquitetura (Seção 4.1.1).
Se o número de tentativas for excedido, então o circuito não pode ser roteado com sucesso.
Em esse caso, sugere- se o uso de três alternativas:
Aumentar o tamanho do FPGA (número de linhas e colunas) e não utilizar a restrição imposta por o &quot;quadrado envolvente», pois essa restrição diminui a área de procura do algoritmo;
Aumentar o número de trilhas disponíveis no FPGA;
E por fim aumentar o número de vezes que o &quot;rip-up&amp; re-route «deve ser executado.
A Figura 57 apresenta a evolução do número de trilhas roteadas para o circuitos de teste «seq.
Lca», descrito em.
Este circuito possui 1791 redes e a rede com maior &quot;fanout «possui 234 pinos de conexão do Bloco Lógico com o canal de roteamento.
Esta Figura mostra que foram necessárias 7 iterações para que o circuito fosse completamente roteado.
Sendo assim é possível concluir que a quantidade de redes não roteadas tende a estabilizar ao longo de as iterações que são efetuadas no circuito, até que o circuito seja totalmente roteado.
Se número de redes roteadas não ficar estável, a reordenação do &quot;rip-up&amp; re-route «não está sendo executada corretamente.
Para ilustrar melhor este processo, será utilizado o exemplo descrito por a Figura 58, a tela de execução e as estatísticas de roteamento do mesmo são apresentadas no Anexo III.
A Figura 59 apresenta a localização das redes do circuito no FPGA.
As origens das redes são os assinalados com um círculo e os destinos são representados por os hexágonos.
A largura de canal para esse circuito é igual a 1 (um).
Em a Figura 60, os canais e são a origem e o destino, respectivamente da rede &quot;a».
A rede &quot;a «não pode ser roteada porque teria de utilizar a trilha 0 do canal, mas a trilha 0 já está sendo ocupada por a rede &quot;b».
A rede &quot;b «já tinha sido roteada conforme é apresentada na Figura 60.
É possível observar também que na origem e no destino dessa rede existem trilhas vagas no canal.
A Tabela 8, apresenta a primeira tentativa de roteamento que não obteve sucesso e segunda tentativa, conseguindo assim que todo o circuito fosse roteado no FPGA.
Após o &quot;rip-up&amp; reroute «toda as trilhas são roteadas com sucesso.
A Figura 61 apresenta o circuito completamente roteado.
Pode- se observar que a rede &quot;b «precisou utilizar um canal a mais, do que o roteamento realizado por a primeira tentativa.
Avaliação do algoritmo desenvolvido Em a Seção 4.4.1 são apresentadas as características dos circuitos de teste (&quot;benchmarks&quot;) propostos por.
A Seção 4.4.2 apresenta os resultados obtidos por o algoritmo de roteamento descrito na Seção 4.3.
Os resultados apresentados foram realizados com os dois tipos de modelagem descritos na Seção 4.2.
Os circuitos de teste utilizados para realizar a validação das estruturas de dados descritas anteriormente e do algoritmo proposto fazem parte dos exemplos utilizados em 1991 em o «MCNC Em a Tabela 9 são apresentadas as características dos circuitos de teste.
Essas características são:
Número de pinos de entrada do circuito, número de pinos de saída do circuito e o número de redes que compõem os mesmos.
O maior circuito, em número de redes, é o &quot;clma «que possui 8445 redes.
De entre os circuitos de teste apresentados na Tabela 9, é possível destacar circuitos que são máquinas de estados finito, circuitos seqüenciais com lógica multi-nível (ex..
Clma), circuitos combinacionais multi-nível (ex_ Alu4) e circuitos combinacionais com lógica de 2 níveis (ex_ Apex2).
É importante analisar o fanout das redes dos circuitos, pois o roteador ordena as redes conforme esse parâmetro.
O algoritmo implementado inicia o roteamento com as redes que possuem maior fanout.
A Tabela 10 ilustra o percentual de &quot;fanout «que cada um dos circuitos de teste.
Tabela 10 ­ Percentual de fanout das redes dos circuitos de teste Nome alu4 apex2 apex4 bigkey Clma des diffeq dsip elliptic ex1010 70% ex5p frisc misex3 76% pdc s298 s38417 57% s 38584.1 69% seq spla tseng% fanout A Figura 62 apresenta a relação entre o número de pinos que compõem cada rede e o número de redes que formam o circuito.
Pode- se notar que as redes com menor &quot;fanout «são a maioria.
Analisando os dados contidos na Tabela 10 e a Figura 62, é possível observar que as redes multiponto são minoria em todos os circuitos.
Estas redes são as mais difíceis de rotear, pois são as mais suscetíveis de serem bloqueadas.
Por essa razão, deve- se antes de iniciar o roteamento, ordenar as redes em ordem decrescente de &quot;fanout».
Isso não quer dizer que, por a rede ter o maior &quot;fanout «de todo o circuito, ela seja a mais difícil de ser roteada, pois os pinos podem estar muito próximos.
Assim como, pode- se ter uma rede com &quot;fanout «igual a 2, em a qual a origem e o destino estarem em posições opostas no dispositivo.
Em esse caso, a rede terá de cruzar praticamente todo o circuito para que a mesma seja roteada com sucesso.
Em todos os circuitos de teste, foi retirada a rede de clock por esta utilizar um canal de roteamento dedicado, sendo utilizado para distribuir sinal de clock em todo o FPGA.
Isso é observado na família Virtex da Xilinx.
Outras redes globais poderiam ser excluídas, como por exemplo, rede de set/ reset, pois existem também recursos de roteamento dedicados para esse fim no FPGA.
A Tabela 11 ilustra os resultados obtidos utilizando o algoritmo proposto com a modelagem por grafos.
A Tabela 12 e a apresentam os resultados obtidos utilizando a estrutura do FPGA sendo modelada através de uma matriz com 3 dimensões.
Sendo o roteador executado em sistemas operacionais diferentes.
Número Total de trilhas utilizadas/* Número de repetições/** Porcentagem dos recursos de roteamento utilizados Nome do Arquivo A etapa de posicionamento foi realizada por a ferramenta acadêmica de posicionamento e roteamento VPR.
Após o posicionamento ter sido realizado, houve a necessidade de converter o arquivo posicionado numa lista de redes, para isso foi utilizado o conversor &quot;net2lca «desenvolvido durante este trabalho.
Para a obtenção dos dados contidos nas tabelas acima não foi aplicada a restrição de matriz de chaves, ou seja, fs $ .
Os testes utilizando a modelagem por grafos apresentaram uma redução muito pequena no número de trilhas.
O VPR utiliza 197 trilhas e a implementação descrita na Seção bigkey e ex5p, que precisaram de uma trilha a menos do que o VPR, para que fosse completamente roteado.
Quando os circuitos foram testados com a modelagem por matriz (Seção 4.2.2), observouse que foi possível reduzir o número de trilhas para 191, conforme os dados apresentados na Tabela seq.
Tendo como base os dados da Tabela 11 e da Tabela 12, pode- se observar que o número de repetições (&quot;Rip-up and Re-route&quot;) foi reduzido em praticamente todos os circuitos.
Com a utilização da representação do FPGA na forma de uma matriz de estruturas reduziu- se o tempo de execução em 90%.
O circuito Apex4 foi roteado aplicando- se ao roteamento a restrição de trilhas (fs $= 3) e retirando- se a restrição imposta por o quadrado envolvente da rede.
Para que o roteamento obtivesse sucesso, foi necessário que o número de trilhas disponíveis por canal fosse aumentado em 17 trilhas, ou seja, passou de 12 trilhas por canal para 29 trilhas por canal.
Em esse circuito 3% das redes possuem o &quot;fanout «maior do que 10, ou seja, 39 redes possuem mais de 10 pinos de conexão.
Sendo que dessas 39 redes, 32 possuem mais do que 50 pinos de conexão.
Durante a implementação do algoritmo de roteamento com modelagem através de matriz de estruturas foi implementado um visualizador de redes.
Este visualizador permite ver como a rede ficou distribuída no FPGA.
De essa forma, pode- se verificar que o roteador implementado está realizando o roteamento de circuitos digitais corretamente.
O Anexo V apresenta a tela de execução do aplicativo de visualização de redes roteadas.
A Tabela 13 apresenta a comparação entre as ferramentas acadêmicas de roteamento VPR, VPR Timing Driven e Maze, sendo a última implementada no decorrer deste trabalho.
Pode- se notar que o número de trilhas por canal aumentou quando foi utilizada a nova versão do VPR que visa otimizar o desempenho do circuito, ou seja, diminuindo o atraso relativo nas redes que compõem os circuitos de teste.
Este Capítulo tem como objetivo principal apresentar uma proposta de implementação paralela do algoritmo seqüencial descrito no Capítulo anterior.
A execução é distribuída numa rede de estações, onde cada estação é responsável por o roteamento de uma parte do circuito.
Em a Seção 5.1 é apresentado um exemplo de um roteador paralelo encontrado na literatura.
A Seção 5.2 apresenta a modelagem do FPGA para que a execução paralela do algoritmo seja possível.
Exemplo de roteador com execução paralela O &quot;SC-PathFinder «é um roteador com execução paralela e distribuída.
Esse roteador é o atual vencedor do desafio proposto em, utilizando apenas 188 trilhas para rotear os 20 circuitos teste propostos em.
Esse algoritmo é uma modificação realizada no algoritmo de roteamento &quot;PathFinder».
Em essa nova versão do algoritmo foram feitas 2 modificações.
A primeira modificação é explorar o processamento paralelo e distribuído de uma rede de estações (&quot;Cluster&quot;).
Em o cluster, cada estação é responsável por o roteamento de uma parte do circuito.
A segunda modificação foi implementar a troca de informações entre as estações, ou seja, compartilhando a informação de congestionamento dos recursos de roteamento.
Esse processamento paralelo não necessita de semáforos, pois cada estação possui todas as informações sobre o dispositivo e sobre o circuito que esta sendo roteado.
O algoritmo é denominado de &quot;negociador de caminho «A primeira iteração deste algoritmo distribui um conjunto de redes do circuito para cada estação do cluster.
Estes conjuntos de redes são roteados independentemente.
Uma vez todas as estações do cluster tendo concluído o processamento, as redes pertencentes aos canais congestionados são denominadas de redes compartilhadas.
Estas redes compartilhadas têm seu custo aumentado, e uma &quot;negociação «de qual tem mais prioridade determina a ordem do &quot;rip-up and re-route «(a função custo depende do histórico de compartilhamento da rede e do atraso estimado de esta).
O processo de roteamento termina quando não há mais redes compartilhadas.
O ganho de desempenho obtido deve- se ao fato de que o tempo de comunicação entre estações de uma mesma rede local, na ordem de milisegundos, é muito inferior ao tempo de processamento de um conjunto de redes.
O roteamento realizado por este algoritmo é denominado de grão grande, pois todo o circuito é roteado e posteriormente é feita a análise de congestão.
Rotear um conjunto muito pequeno de redes em cada estação não traria desempenho, pois o custo de comunicação ultrapassaria o de roteamento.
Proposta de Roteamento Paralelo O princípio que guia a presente proposta de implementação paralela de roteamento é a localidade das redes no interior do circuito.
O princípio é particionar o circuito em diferentes áreas, denominadas quadrantes, executando paralelamente o algoritmo em cada um destes quadrantes.
Observar que o paralelismo é de grão-grande, como na proposta anterior, porém com uma abordagem totalmente diferente.
A proposta é rotear redes em áreas independentes, sem haver a possibilidade de congestionar canais e posteriormente negociar quais redes têm prioridade para ficar no canal e quais devem sair.
O primeiro passo do procedimento do roteamento paralelo é particionar o circuito em quadrantes.
A Figura 63 ilustra um FPGA com dimensão 64 x 64 blocos lógicos.
A partição inicial, nível 0, corresponde ao tamanho total do FPGA (64 x 64).
Em esta figura observa- se que o FPGA foi particionado até o nível 6, resultando num quadrante com dimensão de 8 x 8 blocos lógicos.
A Tabela 14 apresenta a análise da ocupação de redes por quadrante para os benchmarks de roteamento.
Com o intuito de evitar partições pequenas, optou- se por dividir o FPGA até quadrantes de dimensão 8 x 8 blocos lógicos.
Caso a partição continue, o número de redes por quadrante fica muito reduzido, e o tempo de comunicação prevalece sobre o de processamento.
Por exemplo, uma rede que esteja na partição 5 implica que todos os seus pinos estão contidos neste quadrante.
Observando- se os dados fornecidos por a tabela pode- se concluir que em todos os circuitos a maioria das redes pode ser roteada em partições de tamanho 5 ou 6, corroborando a hipótese de localidade das redes.
A etapa de particionamento divide o circuito até alcançar quadrantes de dimensão 8 x 8 blocos lógicos.
Uma vez particionado o circuito, cria- se uma lista de redes para cada quadrante.
Cada quadrante pode ser visto como um FPGA independente.
Tendo definido o número de partições, a próxima etapa é realizar a distribuição das partições numa rede de estações.
Uma das estações é denominada de host, sendo responsável por realizar a partição, criar a lista de redes por partição e distribuir as listas para as diversas estações.
Cada estação realiza o roteamento de suas redes independentemente.
O algoritmo seqüencial utilizado difere do algoritmo apresentado no Capítulo anterior por o fato de não restringirmos a propagação da frente de onda ao quadrado envolvente da rede e sim por o tamanho do quadrante da partição.
Esta relaxação fornece um espaço de procura maior para a rede, sem contudo pesquisar em todo o FPGA, estando limitado ao quadrante.
É importante ressaltar que no nível de quadrante também há &quot;rip-up and re-route».
À medida que as estações forem concluindo o roteamento parcial os dados são enviados ao host.
O host recebe a lista de rede roteadas e a lista de redes não roteadas das estações.
As redes roteadas são marcadas como obstáculos e as redes não roteadas são promovidas para o quadrante de dimensão imediatamente superior.
A Figura 64 ilustra a proposta do algoritmo paralelo, no nível de ações a serem executadas.
Enquanto todas as redes não forem roteadas ou o número de iterações for menor que o máximo permitido:
Particionar o circuito até quadrante 8x8 Enquanto o tamanho da partição for menor que o tamanho do FPGA: --
Se há redes roteadas no circuito criar estrutura de dados representando obstáculos. --
Enviar lista de redes e obstáculos as para estações (processamento paralelo). --
Enquanto houver estação processando () estrutura do FPGA (obstáculos). --
Marcar as redes não roteadas para serem roteadas no quadrante subseqüente. --
Passar para a partição subseqüente.
Para as redes não roteadas:
A segunda iteração do algoritmo contém as redes do segundo nível de partição mais as redes não roteadas da partição anterior.
As redes não roteadas em a (s) partição (ões) anterior (es) têm maior prioridade para o roteamento.
O host além de enviar para cada estação a lista de redes, envia também os obstáculos impostos por as redes já roteadas.
Este processo continua até o nível 0, ou seja, até haver apenas uma estação roteando o circuito.
Alcançando- se o nível 0, havendo redes não roteadas, estas são marcadas como redes para &quot;rip-up and re-route».
Toda a estrutura de roteamento é desfeita, as redes marcadas são roteadas tendo toda a área do FPGA disponível e o processo de partição reinicia.
O algoritmo é encerrado quando todas as redes forem roteadas ou quando a dimensão do quadrante for igual à dimensão do FPGA e o número de iterações para &quot;rip-up and re-route «tiver sido excedido.
Espera- se com este algoritmo ter uma redução no tempo de processamento e uma redução no número de trilhas necessárias para rotear os circuitos.
A redução no tempo de processamento é esperada devido a o roteamento ser feito em paralelo.
Em uma partição 8 x 8, num circuito com uma dimensão até 64 x 64 blocos lógicos, há 64 quadrantes.
Em um cluster com 32 estações, cada estação realizaria o roteamento de apenas 2 quadrantes.
Uma crítica à proposta é a eventual existência de nodos ociosos no cluster quando o tamanho da partição se aproxima do tamanho do FPGA.
A redução no número de trilhas é esperada por o fato do roteamento e o &quot;rip-up and reroute «ser hierárquico.
O presente trabalho apresentou:
O estado da arte dos algoritmos de roteamento para FPGAs;
O desenvolvimento de um roteador seqüencial, que tem o algoritmo Maze como base de implementação e a proposta de paralelização do algoritmo apresentado.
A comunidade acadêmica continua pesquisando novas técnicas de se melhorar o desempenho dos algoritmos existentes, tanto em área ocupada, desempenho elétrico e tempo de processamento.
Em este trabalho foram citados alguns roteadores acadêmicos.
O roteador que teve a maior ênfase foi o VPR, por conseguir rotear os circuitos de teste com um reduzido número de trilhas.
Para que os circuitos de teste fossem roteados por o VPR foram utilizadas 197 trilhas.
Três anos mais tarde foi desenvolvido um novo roteador (&quot;SC-pathfinder&quot;) que conseguiu rotear os mesmos circuitos de teste com um número inferior ao VPR.
Esse roteador precisa de 188 trilhas para rotear com sucesso todos os circuitos de teste.
O &quot;SC-pathfinder «apresenta uma nova metodologia para o roteamento de FPGAs, utilizando um cluster de estações e técnicas de programação paralela.
O algoritmo de roteamento seqüencial foi desenvolvido utilizando- se a linguagem C (ANSI C), sendo o mesmo portável para diferentes sistemas operacionais.
Essa implementação apresentou a modelagem do FPGA na forma de um grafo e também apresentou o FPGA modelado como uma matriz de estruturas com 3 dimensões.
A modelagem escolhida para a implementação foi a matriz de estruturas, por esta ser mais versátil e por o fato da biblioteca Leda não estar mais disponível para domínio público sendo assim o roteador implementado pode ser distribuído gratuitamente.
Para que a implementação e a modelagem do FPGA fossem validadas foram realizados testes com os mesmos benchmarks utilizados por o VPR e o SC-pathfinder.
Para a obtenção dos resultados foram necessários 74 horas, na versão com o FPGA modelado com um grafo e 7,35 horas na versão com a modelagem de matriz de estruturas.
Outro ponto que deve ser salientado é o número de trilhas que cada canal deve conter.
Quanto menor for o número de trilhas por canal, melhor será a utilização dos recursos disponíveis no dispositivo, ou seja, melhor será a distribuição do circuito no mesmo.
O algoritmo apresentado neste trabalho necessita de 191 trilhas para rotear todos os circuitos de teste.
O roteador SC-pathfinde», o qual realiza roteamento paralelo, tenta rotear todas as redes do circuito de uma só vez, sem levar em consideração os bloqueios existentes.
Nossa proposta difere desta, utilizando como base o princípio da localidade das redes.
A idéia principal da proposta é dividir o FPGA em &quot;mini-FPGAs», e distribuir- los numa rede estações.
Assim cada estação será responsável por rotear uma parte do circuito, que posteriormente será agrupado por a estação &quot;host».
O &quot;rip-up&amp; re-route «é hierárquico.
Realizado nos &quot;mini-FPGAs «e posteriormente realizado também por a estação &quot;host», onde as redes não roteadas serão roteadas antes que uma nova partição seja feita.
A principal contribuição científica deste trabalho é disponibilizar ao meio acadêmico um algoritmo de roteamento para FPGAs, e uma proposta de roteamento paralelo para redução do tempo de processamento.
Para trabalhos futuros sugere- se a implementação deste algoritmo paralelo, assim como introduzir no algoritmo tratamento de linhas de tamanho diferenciado.
