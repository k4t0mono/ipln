O desenvolvimento de sistemas distribuídos e protocolos de comunicação é uma tarefa complexa e o uso de técnicas de especificação e verificação formal torna- se necessário para garantir a corretude de tais sistemas.
Enquanto técnicas de model-- checking passam por o problema da explosão do espaço de estados, o uso de provadores de teoremas representa um importante recurso para verificação de sistemas com ilimitado número estados.
O método formal Event-B, de uso crescente na indústria e academia, se apóia na técnica de prova de teoremas e suporta refinamento.
A contribuição deste trabalho está em proporcionar uma biblioteca reusável de padrões de especificação, em Event-B, de mecanismos de troca de mensagens em sistemas distribuídos.
Um padrão de especificação define a semântica de comunicação desejada num canal, demostrando formalmente suas propriedades.
Durante o desenvolvimento de um sistema distribuído, o desenvolvedor pode fazer uso destes padrões através de passos guiados de refinamento do sistema.
O sistema resultante garante a semantica de comunicação definida no padrão utilizado e livra o desenvolvedor de se preocupar em definir o sistema de comunicação a partir de o início e provar suas propriedades.
Palavras-chave: Sistemas Distribuídos;
Formalismos; Com o desenvolvimento de microprocessadores poderosos a preços atrativos e o surgimento de redes de computadores de alta velocidade, tornou- se possível transferir grandes volume de dados entre máquinas em poucos microsegundos, tornando- se prático compor um sistema utilizando um grande número de computadores conectados.
Sistema que chamamos de sistemas distribuídos.
A definição de um sistema distribuído difere entre autores, por exemplo, &quot;um sistema distribuído é aquele em o qual os componentes localizados em computadores interligados em rede se comunicam e coordenam suas ações apenas passando mensagens», ou &quot;um sistema distribuído é uma coleção de computadores independentes que na visão do usuário aparenta ser um único computador».
O desenvolvimento de sistemas distribuídos é uma tarefa complexa, pois exige do desenvolvedor um conhecimento detalhado sobre aspectos do ambiente de execução, que inerentemente é concorrente e sem estado global.
Além disso, a construção de sistemas distribuídos empregam dificuldades como:·
Heterogeneidade, que consiste em sistemas desenvolvidos num ambiente com diversas diferenças (sistemas operacionais diferentes, hardwares diferentes, redes diferentes) prejudicando a interação das diferentes partes.
Para contornar este problema, em redes heterogêneas utiliza- se de protocolos de comunicação, mascarando- se as diferenças.
Para o restante das diversidades normalmente é utilizado um middleware, resultando numa padronização dos componentes do sistema.·
A construção de sistemas distribuídos abertos, ou seja, sistemas onde possam ser adicionados ou substituídos novos componentes.
O fato de um sistema distribuído ser ou não um sistema aberto é determinado principalmente por o grau com que novos serviços podem ser adicionados e disponibilizados para uso por uma variedade de programas clientes.
Em um sistema distribuído aberto o maior desafio está em integrar os componentes de diferentes desenvolvedores.·
Um sistema distribuído deve manter- se funcional e eficiente a medida que aumenta- se o número de usuários acessando compartilhadamente determinado recursos.
Portanto o sistema deve manter a qualidade do serviço prestado, evitando- se possíveis gargalos.
A escalabilidade, como é chamada esta propriedade, é um dos problemas centrais encontrados em sistema distribuídos.·
Um sistema distruído deve manter- se seguro, ou seja, os dados do sistema que trafegam nas redes podem conter informações sigilosas dos usuários, por exemplo, sistema de serviços bancários, portanto necessitando estar seguros.
A segurança da informação é baseada em três princípios:
Confidencialidade (pessoas não autorizadas não podem acessar a informação), integridade (proteção dos dados ou informações contra alterações ou danos) e disponibilidade (a informação deve estar disponível quando necessária).·
Em um sistema distribuído podem ocorrer falhas de processo independentes, cabendo ao desenvolvedor do sistema o tratamento dessas falhas.
O tratamento de falhas torna- se difícil em sistemas distribuídos, por o fato que alguns componentes podem falhar enquanto outros continuam a executar.
Entretanto existem algumas técnicas para tratamento de falhas como:·
Os desenvolvedores de um sistema distribuído devem preocupar- se em torna o sistema transparente para o usuário final, ou seja, as diferentes partes do sistema devem ser vista como um todo.
Dadas as dificuldades para o desenvolvimento de sistemas distribuídos, este trabalho tem como finalidade reduzir os erros de projeto, ocasionados por a não conservação de uma propriedade do sistema.
Portanto pretende-se, através da especificação e análise de um sistema distribuído, verificar a corretude dos modelos em fases iniciais de desenvolvimento.
Motivação Em o desenvolvimento de sistemas distribuídos exige- se do desenvolvedor, um conhecimento detalhado sobre os aspectos do sistema empregado e do ambiente.
Portanto, torna- se interessante a utilização métodos formais que comprovem que o sistema se comporta de maneira correta, mesmo na existência de um ambiente hostil (existência de falhas), tendo como necessidade o quanto antes possível a afirmação das propriedades funcionais do sistema.
A modelagem é uma técnica de engenharia aprovada e bem aceita no desenvolvimento de sistemas.
Quanto maior for a complexidade de um sistema maior será a probabilidade de erro.
Através de modelos matemáticos é possível analisar os efeitos de um sistema.
Em um modelo é possível verificar as características do sistema e facilitar a comunicação das idéias entre diferentes desenvolvedores, assim como limitar o problema restringindo o mesmo para um único foco.
De esse modo pode- se dividir um problema grande em diversos problemas menores.
O uso de métodos formais para especificar algoritmos distribuídos e protocolos de comunicação é recorrente na literatura.
Tipicamente, são empregados formalismos baseados em álgebra de processos, linguagens de entrada para ambientes tradicionais de verificação, como por exemplo Vários de tais métodos dispõem de abstrações propícias à área do problema e tipicamente recaem sobre ferramentas de análise utilizando a estratégia de model checking.
Esta última é menos complexa para o usuário, se comparada com prova de teoremas, mas os modelos são limitados por o problema da explosão do espaço de estados.
Outra questão importante, com relação a vários de tais métodos, é a carência de abordagens para gerar implementações comprovadamente corretas a partir de as especificações.
O uso de técnicas de refinamento é importante neste sentido.
O uso de provadores de teoremas, ainda que uma tarefa não trivial, tem sido facilitado devido a o surgimento de linguagens de especificação e plataformas de suporte voltadas para este fim, como por exemplo Event-B e a plataforma RODIN (vide Seção 2.3).
É crescente a aplicação de Event-B para modelagem de sistemas distribuídos (vide Seção 2.4).
A utilização do formalismo Event-B na modelagem de sistemas distribuídos, implica num raciocínio antecipado sobre o problema a ser modelado, como também a garantia que as propriedades do sistema estarão presentes.
Com as propriedades desejadas do sistema preservadas diminui- se a possibilidade de erro, ou seja, a chance de ocorrer um erro por a não conservação de uma propriedade na validação do sistema (fase de testes) é menor.
O formalismo aplicado a sistemas complexos resulta em modelos grandes e complexos, tornandose uma tarefa árdua a sua utilização.
Entretanto Event-B possibilita o uso de refinamento, que permite especificar modelos em diferentes níveis de abstrações facilitando na modelagem e na prova das propriedades.
Além disso, no formalismo Event-B, existe o conceito de padrão que possibilita o reuso de modelos provados formalmente em novos modelos.
Objetivos Em a linguagem Event-B não existe suporte para representação de mensagens ou canais.
A linguagem é basicamente constituída de eventos e variáveis que representam transições de estados num modelo, portanto dificultando a representação das características de um sistema distribuído na modelagem.
A proposta deste trabalho é a criação de uma biblioteca de padrões de especificação formal em Event-B. Esta biblioteca suporta a representação de diferentes semânticas de comunicação clássicas da literatura, contendo suas propriedades formalmente provadas.
Desta forma, liberando o desenvolvedor que estiver modelando um sistema distribuído em Event-B das preocupações quanto a validação da comunicação do seu sistema.
Por fim será desenvolvida uma aplicação distribuída na plataforma RODIN contendo especificações da biblioteca, de forma a demonstrar a aplicação dos padrões em sistemas modelados em Event-B. Organização do Trabalho O restante do trabalho está organizado da seguinte forma:
Em o Capítulo 2 será apresentado o referencial teórico, contendo conceitos sobre o formalismo Event-B e trabalhos relacionados.
Em o apresentado um estudo de caso, aplicando- se alguns padrões de comunicação, contidos na biblioteca de padrões.
As conclusões são apresentadas no Capítulo 5.
Por fim no apêndice A são apresentados sistemas distribuídos modelados em Event-B. Em esta Capítulo será apresentado o embasamento teórico utilizado no restante do trabalho.
Ele está estruturado da seguinte forma:
Em a Seção 2.1 será descrito o formalismo Event-B. Em a Seção 2.2 será apresentado o conceito de padrões em Event-B. Em a Seção 2.3 será apresentada a Plataforma RODIN.
Por fim, na Seção 2.4 serão apresentados trabalhos relacionados com a proposta.
Event-B Em Event-B um modelo é caracterizado por:
Um nome, uma coleção distinta de variáveis que definem os estados do sistema, invariantes, eventos e um contexto associado.
Invariantes são definições impostas a fim de restringir variáveis de um sistema assegurando uma transição para um estado correto, tornando- se necessário garantir que estas restrições serão preservadas na ocorrência de um evento.
Portanto as invariantes tornam- se uma das propriedades a serem provadas para um sistema modelado em Event-B. Por exemplo, as invariantes &quot;inv1 «e &quot;inv2 «da Figura 2.1, determinam, como propriedades de um sistema qualquer, que o número de pessoas sempre devem ser menor ou igual ao número de lugares disponíveis e ainda ser um valor natural.
Os eventos anteriormente citados, definem um conjunto de transições no sistema que podem ocorrer quando determinadas circunstâncias forem satisfeitas.
Os eventos são compostos por três elementos:
Nome do evento (&quot;Entrada da Figura «2.2), guarda (&quot;grd1 «e &quot;gr2 «da Figura 2.2) e ação.
As guardas são predicados construídos sobre os estados das constantes e variáveis do sistema, sendo as condições necessárias para um evento ocorrer.
Quando a condição de uma guarda é satisfeita, realiza- se uma ação no sistema.
Ação que define o estado resultante da transição associada ao evento.
Para estas transições ocorrerem são realizadas substituições nas variáveis de estado presente no modelo, sendo essas chamadas de substituições generalizadas (generalized substitution).
Substituições generalizadas podem estar associadas a um before-after predicate, onde existe uma relação entre o valor do estado antes do evento determinado acontecer, e depois do evento acontecido.
Event-B não se limita apenas a modelos, existe a definição de outro componente na linguagem chamado de contexto, que define a forma como um determinado modelo vai ser parametrizado para ser instanciado.
Um contexto é composto por:
Um nome, uma lista distinta de carrier sets, uma lista distinta de constantes e de nomes das propriedades.
Os carrier sets existentes são representados por um nome no contexto, sendo os diferentes nomes tratados independentemente.
As constantes existentes no contexto são definidas por propriedades que devem ser adicionadas no contexto.
Importante observar que os contextos podem ser referenciados por modelos (Figura 2.3), quando de o contexto estão disponíveis para o modelo associado a ele.
A Figura 2.3 mostra as relações existentes entre modelo, contexto e eventos.
A aplicação de métodos formais em sistemas complexos produz um grande volume de modelos e provas, tornando- se muito trabalhosa a sua visualização e a garantia que as propriedades do sistema estão sendo asseguradas.
O formalismo Event-B possui alguns conceitos especiais visando facilitar a aprendizagem e o entendimento dos sistemas que estão sendo modelados, proporcionando assim uma melhor visualização das suas provas e propriedades.
Em a Seção 2.1.1 será apresentado o conceito mais utilizado na linguagem Event-B:
O refinamento.
A modelagem de um sistema, representando- se todas as propriedades e estados em apenas um nível, resultaria num modelo único gigantesco de difícil compreensão e até mesmo uma difícil leitura.
Para solucionar esse problema, a linguagem Event-B utiliza- se do conceito de refinamento, aonde através de o qual as propriedades dos sistemas se tornam mais detalhadas e são comprovadas a cada passo da modelagem, facilitando sua compreensão.
O sistema é modelado incrementalmente herdando- se as propriedades dos modelos anteriores.
A cada passo de refinamento, restringese o comportamento do modelo, através do fortalecimento das guardas, resultando num modelo mais preciso, determístico e mais perto de a realidade.
Pode- se visualizar um exemplo de refinamento na Figura 2.4, onde um modelo N chamado de modelo concreto refina um modelo M chamado de modelo abstrato.
Em o exemplo da Figura 2.4 é possível perceber que um modelo concreto N &quot;enxerga «um contexto concreto D, que refina um contexto abstrato C, que é &quot;visto «por o modelo abstrato M. Os refinamentos de modelos e contextos possuem algumas diferenças.
Para o refinamento do contexto da Figura 2.4, os conjuntos e constantes do contexto abstrato C são mantidos no seu refinamento e o refinamento do contexto concreto D consiste em adicionar novas constantes e propriedades (carrier sets) às constantes e propriedades (carrier sets) mantidas no contexto abstrato Em o modelo concreto N existem as gluing invariant (invariantes de aglutinação), que são um conjunto de invariantes as quais consistem em:
Invariantes do novo modelo N (Figura 2.4), agluti- nada às invariantes do modelo abstrato M (Figura 2.4) que ainda deverão ser conservadas.
Sendo assim as gluing invariant relacionam as variáveis do modelo abstrato com novas variáveis do modelo concreto (refinamento).
É possível existir um número muito grande de refinamentos, porém é importante salientar- se que as gluing invariant ocorrem em apenas dois níveis de refinamento, portanto apenas aglutinando o modelo concreto e abstrato que estará sendo tratado em questão.
Refinamentos em Event-B tratam diferentemente eventos existentes e eventos adicionados naquele passo de refinamento.
Eventos existentes, quando refinados, devem se adequar as variáveis adicionadas naquele passo de refinamento, sendo necessário garantir que seu refinamento realizou- se de modo correto.
Em eventos do modelo concreto, que possuem uma mesma substituição generalizada (mesma ação) é possível realizar a união dos eventos, unindo suas guardas e assim transformando- se &quot;n «eventos em apenas um evento no modelo concreto, como demonstra a Figura 2.5.
Entretanto para refinamento de novos eventos há duas restrições:
O novo evento deve refinar um evento skip (evento vazio) do modelo anterior, e deve- se permitir que cada guarda em algum momento possa ser verdadeira.
Todas as restrições, assim como as propriedades que o sistema deve preservar valida- se através das proof obligations.
Proof obligations (obrigações de prova) é o que caracteriza a semântica em Event-B, assim como verifica as propriedades contidas no modelo, transformando a linguagem Event-B num cálculo para modelagem que independe dos vários modelos de computação.
Confia- se nesta uniformidade como chave para o ensino de diferentes aspectos da modelagem de sistemas.
Quando um sistema é modelado em Event-B, o before-after predicate é responsável por a transição de estado do sistema (v para v da Figura 2.6).
Para modelagem correta do sistema é necessário uma proof obligation que garanta possibilidade de transição.
Esta propriedade é garantida através da proof obligation FIS (feasibility statement).
Tendo v como a representação do conjunto das variáveis do modelo, a FIS garante que as propriedades do modelo (P), as invariantes (I) e as guardas (G) vão implicar na existência de um estado futuro (R) (Figura 2.6).
Em um modelo em Event-B é importante garantir também que o sistema não entre em deadlock, ou seja, que sempre exista uma guarda que possa ocorrer.
A proof obligation que assegura esta propriedade é a DLKF (deadlock free).
As propriedades (P) e as invariantes (I) devem implicar numa condição a qual uma das guardas existentes no modelo deve ser verdadeira, pode- se visualizar essa relação na Figura 2.8.
A o ser realizado um refinamento deve- se garantir que o modelo refinado (modelo concreto) ainda conserva as propriedades do modelo anterior (modelo abstrato).
Para tanto utiliza- se as proof obligations descritas anteriormente, com a diferença que as mesmas devem comprovar que o refinamento conserva as propriedades do modelo anteriormente provadas.
Tendo v como as variáveis do modelo abstrato e w como as variáveis do modelo concreto, as proof obligations do refinamento que realizam essas provas são chamadas de FIS REF, GRD REF, INV REF e podem ser visualizada na Figura 2.9.
Como pode ser visualizado na Figura 2.9, a proof obligation FIS REF define que as propriedades (P), as invariantes (I), a gluing invariant (J) e as guardas (H -- modelo concreto) devem implicar em existir um transição de estado (S).
Em a GRD REF as propriedades (P), as invariantes (I), a gluing invariant (J), e as guardas (H -- modelo concreto) devem implicar nas guardas (G) do modelo abstrato.
Entretanto a INV REF possui uma terceira utilização que é para novos eventos, adicionados naquele passo de refinamento.
Isso deve- se ao fato que é necessário provar que os novos eventos irão conservar as invariantes do modelo abstrato.
Para tanto utiliza- se a proof obligation da Figura 2.10, onde as propriedades (P), as invariantes, a gluing invariant (J), as guardas do modelo concreto (H) e o before-after predicate (S) implicam no novo estado que deve conservar a gluing invariant (J).
Quando um novo evento é adicionado na modelagem existe a possibilidade deste evento tomar o controle do sistema, assim impossibilitando que outros eventos existentes ocorram.
Para que isso não ocorra, existe a proof obligation WFD REF da Figura 2.11, que garante que eventos não tomem posse eternamente do sistema.
Para garantir isso, deve- se encontrar uma equação chamada de variante, que os eventos decrementem com a transição de estados do sistema.
A WFD REF é definida da seguinte maneira:
As propriedades (P), as invariantes (I), a gluing invariant (J), as guardas (H), e o before-after predicate (S), devem implicar numa variante (V) que pertença aos naturais e que num estado futuro seja menor que no atual estado.
Event-B e B são métodos formais semelhantes.
A abordagem de ambos métodos para demostrar a corretude do sistema é através da descarga de um conjunto de obrigações de provas (proof obligations).
Entretanto a estrutura, assim como alguns itens presentes na linguagem do formalismo Event-B foram renomeados, diferenciando- se do método B. Em o método B todas as características do modelo são descritas numa máquina.
Além disso as guardas são especificadas como &quot;pre «(pré-condição) e os eventos como &quot;operations».
Em Event-B existe a separação da parte estática (contexto) e a parte dinâmica (modelo) do sistema modelado (Figura 2.3), ficando em diferentes estruturas as constantes e suas propriedades, assim como as variáveis do sistemas e as invariantes.
Além disso, Event-B possui uma ferramenta que ajuda no desenvolvimento da modelagem e que concentra- se na geração das proof obligation e dedução automática das proof obligation triviais.
Desta forma, tentando deixar apenas para o desenvolvedor a preocupação com a modelagem e não com suas provas.
Esta ferramenta é implementada no projeto RODIN e é uma extensão da plataforma Eclipse (Seção 2.3).
Por as dificuldades e complicações que poderia existir no aprendizado do formalismo Event-B na ferramenta, os desenvolvedores adotaram a terminologia &quot;máquina «ao invés de &quot;modelos «e &quot;axiomas «ao invés de &quot;propriedades», diferenciando- se portanto do manual da linguagem.
Segundo Hallerstede em, ficaria confuso utilizar- se da terminologia modelos numa frase como:
&quot;um modelo consiste de modelos e contextos».
Desta forma ficando contextos e máquinas1 caracterizados da seguinte forma:
Os contextos da plataforma Event-B possuem carrier sets, constantes, axiomas e teoremas;
Já as máquinas possuem variáveis, invariantes, teoremas, eventos e variantes.
Padrões em Event-B Padrões são construções que permitem o reuso de soluções genéricas para problemas frequentes, sendo extensivamente discutidos na engenharia de software há vários anos.
O emprego da noção de padrões a especificações formais permite o reuso de artefatos custosos, dado que formalmente especificados e analisados, integrando- os a sistemas alvo desejados.
Além de promover o reuso em fases mais iniciais do desenvolvimento, de grande importância é o reuso também de provas já realizadas sobre o padrão.
Estas não precisam ser repetidas sobre o sistema alvo.
Em métodos que suportam a noção de refinamento, o desenvolvimento se dá por uma cadeia de modelos relacionado.
A cada passo de refinamento, novas propriedades são adicionadas ao modelo.
Em este contexto, um padrão guia um passo de refinamento de tal forma que o modelo concreto obtido apresente um conjunto de propriedades definidas e provadas no padrão.
Para Event-B, este processo é discutido tanto em como em.
Assim, um padrão em Event-B é composto de um modelo abstrato PA, chamado em de especificação padrão, e de um modelo concreto PC, chamado de refinamento padrão, definindo um passo consistente de refinamento:
PA PC. Juntamente com este passo de refinamento, propriedades do padrão são provadas.
Tendo eventP A como evento da especificação padrão (PA) e os eventos event1REF n e event2REF n do modelo alvo (ref inamento n), no passo C2, indica- se os eventos que serão combinados (linha 1 da Tabela 2.2).
Em a combinação dos eventos, igualmente ao acontecido com a combinação das variáveis, existe a probabilidade do modelo alvo possuir eventos extras, ou seja, eventos não combinados (linha 2 Tabela 2.2).
Concluída a primeira fase, todas as variáveis e eventos da especificação padrão (PA) devem conter uma combinação no modelo alvo (ref inamento n).
Entretanto a combinação dos eventos e das variáveis não garantem que o padrão é realmente compatível com o modelo alvo.
Portanto sendo necessário verificar se a combinação é correta.
Em a segunda fase é preciso validar a combinação realizada na primeira fase, ou seja, verificar se a especificação padrão (PA) é compatível com o modelo alvo (ref inamento n).
Para tanto, os eventos combinados do modelo alvo (ref inamento n), deverão ser verificados um a um a sua compatibilidade com o padrão.
A verificação dos eventos combinados acontece da seguinte forma:
V1 As guardas da especificação padrão devem ser sintaticamente iguais as guardas do modelo alvo.
V2 Deve- se verificar as existências de guardas extras, ou seja, guardas não combinadas do modelo alvo.
V3 As ações das especificação padrão devem ser sintaticamente iguais as ações do modelo alvo.
V4 Deve- se verificar as existências de ações extras, ou seja, ações não combinadas do modelo alvo.
Para os eventos não combinados do modelo alvo, eventos extras, apenas deve- se verificar se eles não alteram alguma variável combinada (V5).
Sendo respeitadas estas condições o padrão pode ser aplicando no modelo alvo, passando- se para última fase:
A incorporação.
A fase de incorporação é caracterizada como um passo de refinamento do modelo alvo.
Através da incorporação as características do padrão são introduzidas no modelo.
Para tanto, diferentemente das fases de combinação e verificação, utiliza- se o refinamento padrão (PC).
Através da incorporação, o modelo alvo fica constituído de um modelo abstrato (ref inamento n) e um modelo concreto (chamado nesta descrição de ref inamento n+ 1).
Para a modelagem do ref inamento n+ 1 (incorporação do padrão), primeiro deve- se copiar para o modelo as variáveis do refinamento padrão e as variáveis não combinadas do modelo abstrato (ref inamento n) (passo chamado I1).
Logo após copiado as variáveis para o modelo concreto, no passo chamado I2, realiza- se a construção das invariantes do modelo ref inamento n+ 1.
Este passo é responsável por adicionar as propriedades preservadas do padrão.
Para tanto, as invariantes do ref inamento n+ 1 são construídas apartir das invariantes da especificação do padrão (PA) e do refinamento do padrão (PC).
Em este ponto da incorporação, o modelo concreto contém as invariantes e as variáveis necessárias ao modelo, restando apenas adicionar os eventos.
A modelagem dos eventos no ref inamento n+ 1 é divida em três tipos de eventos:
Eventos não combinados do ref inamento n (passo I3), eventos criados no refinamento padrão (PC) que não refinam eventos da especificação padrão (PA) (passo I4) e por último os eventos combinados (passo I5).
Os eventos extras, ou seja, eventos não combinados do modelo abstrato (ref inamento n) e os eventos criados no refinamento padrão (PC) devem ser copiados um a um para o ref inamento n+ 1.
Entretanto os pares de eventos combinados, fase C2 da Seção 2.2.1, possuem um tratamento diferenciado na incorporação:·
Inicialmente, copia- se para o ref inamento n+ 1 as guardas do evento combinado presente no refinamento padrão.·
Depois adiciona- se, nas guardas anteriormente copiadas, as guardas extras provenientes do evento combinado do modelo abstrato (passo V2 da Seção 2.2.2) (passo I5.
2).· Concluído a construção das guardas do evento, copia- se para o mesmo, as ações do evento combinado presente no refinamento padrão (PC) (passo I5.
3).· A seguir adiciona- se, nas ações anteriomente copiadas, as ações extras provenientes do evento combinado do modelo abstrato (V4 da Seção 2.2.2) (passo I5.
4). Como visto anteriormente, no passo I1, são copiadas as variáveis combinadas do refinamento padrão para o modelo concreto.
Esta ação faz com que as variáveis combinadas do modelo abstrato (ref inamento n) desapareçam no modelo concreto (ref inamento n+ 1).
Por razões de meta-- proof, no modelo concreto (ref inamento n+ 1), as variáveis do refinamento padrão, identificadas na fase C1 da Seção 2.2.1, devem ser renomeadas por sua respectiva combinação do modelo abstrato (ref inamento n).
Outra opção é a inclusão de uma invariante no ref inamento n+ 1 (modelo concreto).
Esta invariante teria como finalidade identificar as variáveis que desapareceram do modelo abstrato (ref inamento n), nas variáveis oriundas do refinamento padrão (PC).
Torna- se importante salientar que as modificações, anteriomente citadas, devem ser refletidas no restante do modelo, ou seja, é necessário refletir as modificações das variáveis nos eventos e invariantes.
Em o Capítulo 4 será apresentado em detalhe a aplicação de um padrão num sistema distribuído.
Plataforma RODIN A utilização de um modelo formal, para o desenvolvimento de sistemas complexos, como visto anteriormente, torna- se uma tarefa necessária a fim de garantir que um sistema vai ser bem arquitetado e provado.
Para tanto necessita- se uma boa ferramenta como suporte para especificação da notação de modelagem.
Para o formalismo Event-B, existe a plataforma RODIN2 como suporte para construção e validação das propriedades desejadas nos modelos.
A plataforma RODIN foi implementada no projeto RODIN3 (Rigorous Open Development Environment for Complex Systems), por se tratar de uma ferramenta aberta.
Desta forma facilitando assim a sua adaptação e extensão para plug-ins 4 como novos provadores de teoremas e ferramentas de análise de model checker.
Em a plataforma RODIN, as obrigações de provas (proof obligations) são descarregadas automáticamente, proporcionando um rápido feedback para o desenvolvedor sobre construção e a preservação das propriedades do modelo.
Além disso, é possível selecionar o conjuntos de provas que serão descarregados automáticamente nos modelos Event-B. Dadas estas características, nota- se que a plataforma RODIN fornece um apoio considerável na modelagem de sistemas em Event-B. Trabalhos Relacionados Em esta seção são apresentados trabalhos relacionados com a modelagem de sistemas distribuídos em Event-B. Em é apresentada a modelagem e análise em Event-B de um mecanimo de transação distribuída numa base de dados.
O problema distribuído modelado, baseia- se em garantir que as diferentes base de dados estejam consistentes.
Para garantir essa integridade são utilizados protocolos commit, através de o qual é possivel garantir que todas as bases de dados realizem o commit (aceitação) de uma transação ou abortem caso existam multiplas falhas.
Em é possivel encontrar modelado em Event-B uma grande variedade de sistemas distribuídos, de entre os quais se encontram:
O algoritmo de eleição de líder em topologia anel, o algoritmo de roteamento distribuído para agentes movéis e o algoritmo de exclusão mútua distribuída.
Em é modelado um algoritmo distribuído de contagem de referência (DRC) em EventB.
O algoritmo de DRC é utilizado para compartilhar recursos de forma distribuída e remover os mesmos caso não estejam mais sendo utilizados.
A remoção é realizada de modo distributed garbage collection5.
Em existe a modelagem de um protocolo clássico existente, o two-- phase handshake.
O two-- phase handshake é um protocolo composto por um sender responsável por enviar mensagens e um receiver responsável por receber às mesmas.
O Protocolo é baseado no principio da transferência de pacotes de dados entre dois dispositivos, sendo que para isso é necessária uma ordem para as entregas de pacotes do sender ao receiver.
A seguir são apresentados em detalhes, a modelagem de dois sistemas distribuídos em event-B:
O algoritmo distribuído de contagem de referência e o protocolo two-- phase handshake.
Algoritmo Distribuído de Contagem de Referência Em o algoritmo de DRC um conjunto finito de sites interagem de maneira distribuída, cada qual pode criar o seu recurso e compartilhar- lo com outros sites, sendo que o criador do recurso é chamado de proprietário.
Os recursos não precisam apenas ser compartilhados a partir de o owner (proprietário), os sites que possuem cópias do recurso do proprietário também podem compartilhar esses recursos com outros sites.
Entretanto um recurso só poderá ser removido do proprietário quando o mesmo não estiver sendo utilizado por qualquer outro site.
Existindo a possibilidade de sites poderem compartilhar um recurso sem ser o site proprietário, acaba- se tornando importante o proprietário do mesmo ter conhecimento de quantos sites estão a utilizar o seu recurso.
O algoritmo proposto por Moreau and Duprat ocorre da seguinte maneira:
O site proprietário manda seu recurso para o site s1;
O site s1 propaga o recurso do site proprietário para o site s2;
O site s1 incrementa sua variável, representando a propagação do recurso, sem o conhecimento do site proprietário;
O site s2 recebe o recurso do site s1 e manda uma mensagem para o site proprietário avisando que recebeu o seu recurso;
O site proprietário incrementa sua variável e manda uma mensagem para o site s1, avisando que foi informado que um novo site possui seu recurso;
A mensagem enviada do site s1 para o site s2 chama- se send.
A mensagem do site s2 para o site proprietário é a inc_ dec.
E a última mensagem enviada, do proprietário para o s1 é chamada de dec.
O funcionamento do algoritmo pode ser visualizado na Figura 2.13.
Event-B, foi representado por eventos.
Quando a mensagem é enviada de um dado site para outro, o evento responsável inclui ambos os sites numa variável, representando assim o envio da mensagem.
Para recepção da mensagem no segundo site é utilizado outro evento, o qual remove da variável que estava presente no evento de envio os dados que simbolizavam o processo de envio da mensagem.
Em existem eventos responsáveis por as trocas de mensagens, eventos como:
Send_ copy, receive_ inc e receive_ sendDec que serão descritos a seguir.
De estes eventos, citados anteriomente e modelados em Event-B, o primeiro é responsável por o envio de uma mensagem do tipo send, o segundo por a recepção de uma mensagem do mesmo tipo e o envio de uma mensagem tipo inc.
Os sites que possuem o recurso do proprietário são representados por o conjunto da variável Se a guarda for satisfeita então o evento send_ copy realiza as seguintes ações:
Adiciona ao;
Adiciona os mesmos valores para o conjunto da variável SendLoc;
Adiciona o contador ao conjunto da variável count, o qual representa as diferentes mensagens indexadas.
A variável SendLoc é o conjunto de mensagens de propagação de recurso que não tiveram conhecimento do proprietário.
Para remover uma dado desta variável é necessário o proprietário enviar uma mensagem de SendDec para o site s1, assim o proprietário indica ao site s1 que obteve conhecimento de seu recurso ter sido propagado por ele.
Caso as guardas sejam verdadeiras o evento adiciona uma mensagem no conjunto da variável 7 da Figura 2.15), indicando assim que a mensagem foi entregue.
O s2 é adicionado ao conjunto da variável REC, portanto recebendo o recurso do proprietário.
O evento da Figura 2.16 é responsável por receber a mensagem de Inc..
A variável Dec da Figura 2.16 é responsável por gerenciar as dec mensagens.
A operação Inc -- Dec resultará exatamente da mensagem inc_ dec do algoritmo proposto por Moreau and Duprat, sendo que a relação dos sites indexada ao contador c devem pertencer a este conjunto para o evento receive_ Inc ocorrer.
Sendo a guarda verdadeira, a relação deste sites é removida da variável Inc, adicionada na variável RecOwn e SendDec.
A variável RecOwn é o conhecimento local do proprietário sobre o status do seu recurso.
Então chegado ao evento receive_ inc o proprietário possui conhecimento da sua cópia ter sido propagada, agora restando ao propagador receber a mensagem de SendDec enviada por o proprietário.
Fato que é ocorrido no evento da Figura 2.17.
Portanto para o evento da Figura 2.17 ocorrer, a relação dos sites indexados ao contador deve existir no conjunto da variável SendDec.
Tornando- se verdadeira esta guarda, esta relação é retirada do conjunto da variável SendDec, simbolizando a entrega da mensagem ao site s1.
O mesmo ocorre no conjunto da variável SendLoc, simbolizando o decremento do propagador no algoritmo de Moreau and Duprat.
As propriedades distribuídas foram incrementalmente inseridas, sendo que de início foi preciso apenas garantir as propriedades de cada elemento em separado e depois ir adicionando aos poucos complexidade do problema.
O mesmo ocorre em, onde existe a modelagem de um protocolo clássico existente, o two-- phase handshake.
Protocolo Two--Phase Handshake O protocolo two-- phase handshake é baseado no envio de pacotes de dados entre dois processos em apenas um sentido.
Desta forma, o processo receiver, apenas tem a responsabilidade da confirmação das mensagens enviadas por o processo sender, assim tornando- se possível manter controle sobre as mensagens recebidas, e havendo um reenvio caso necessário.
Para tanto é necessário dois canais de comunicação entre os dispositivos, um responsável por o envio dos dados e outro por a confirmação do recebimento.
Para modelagem deste protocolo em Event-B foi utilizado de um princípio semelhante do encontrado em, onde uma variável do modelo representa o canal de comunicação e eventos são responsáveis por o envio e recebimento das mensagens.
Em, o modelo em Event-B no início era apenas constituído de um evento responsável dessa atribuição.
A Cada passo de refinamento o modelo foi incrementando com características do sistema real, se tornando cada vez mais concreto e percebendo- se a concretização do sender e receiver.
Entretanto nesta modelagem diferentemente da existente em chegou- se em ponto final onde foi utilizado de decomposição do modelo formando- se dois modelos, um contendo o sender e outro o receiver.
Os Eventos existentes nos mesmos responsáveis por a transferência dos dados podem ser visualizados na Figura 2.18.
As variáveis p e q na Figura 2.18, são variáveis externas do modelo, ou seja, após a decomposição do modelo tornaram- se necessárias ao sender e o receiver.
As variáveis externa p e q, composta por um bit de paridade, representam:
O valor da última mensagem enviada (p);
O valor da última mensagem recebida (q).
A variável s é o número do pacote que está sendo enviado, sendo assegurada por a variável n que representa a quantidade de pacotes.
Para o evento send_ data ocorrer, ou seja, o sender enviar um pacotes de dados, às seguintes guardas devem ser verdadeiras:
A última mensagem enviada por o sender deve ter sido recebida e a quantidade de pacotes enviados não pode exceder a quantidade de pacotes disponíveis.
Sendo verdadeira a guarda, o sender coloca o pacote a ser enviando na variável externa d que representa o canal de comunicação entre o sender e o receiver (linha 6), incrementa- se o s (linha 7) simbolizando que mais um pacote foi enviado e o bit de paridade de p é trocado.
Portanto enquanto q não voltar a ser igual a p o canal de comunicação continuará a conter o mesmo pacote.
Para o q voltar a ser igual a p, o receiver deve receber o dado contido no canal, necessitando que o evento send_ ack ocorra.
Para isso a seguinte guarda deve ser satisfeita:
O bit de paridade do ultimo dado enviado deve ser diferente do recebido.
Sendo verdadeira a guarda, o receiver recebe o pacote contido no canal, o número do pacote recebido é incrementado e o bit de paridade de q é modificado simbolizando que a mensagem foi entregue.
Com a modelagem dos sistemas distribuídos em Event-B, presentes no apêndice A deste trabalho, percebeu- se a necessidade de repetir semânticas de comunicação nos diversos modelos.
A possibilidade do reuso das semânticas de comunicação tornou- se atrativa.
Em este capítulo apresenta- se uma biblioteca de especificações em Event-B. Esta biblioteca tem como objetivo apresentar modelos que permitam o reuso de diversas semânticas de comunicação.
Desta forma, libera- se o desenvolvedor que estiver modelando um sistema distribuído em Event-B das preocupações quanto a validação da comunicação do seu sistema.
Durante o desenvolvimento de sistemas distribuídos, baseados em troca de mensagens, devese ter uma definição clara das suposições sobre o mecanismo subjascente de troca de mensagens utilizado.
Tais suposições podem implicar em diferenças significativas no sistema em desenvolvimento.
A literatura reporta várias características clássicas, de mecanismos de troca de mensagens, que podem ser assumidas para a construção de um sistema.
As seguintes são consideradas neste trabalho:·
envio de mensagens:
Unicast e multicast;·
ordenação diferenciada para comunicações multicast e unicast:
FIFO (First In First Out) e causal;·
primitivas de comunicação:
Síncronas ou assíncronas;·
em algumas situações, a entrega pode acontecer com duplicatas.
A comunicação unicast caracteriza- se por o envio de uma dada mensagem M de um processo E para um processo R, ou seja, trata- se de uma comunicação um-para-um.
Por outro lado, a comunicação multicast caracteriza- se por o envio de uma dada mensagem M de um processo E para um grupo de processos GP, ou seja, trata- se de uma comunicação realizada de um-para- muitos.
A comunicação multicast exige coordenação e acordo entre os processos (emissor e receptores).
O objetivo deste tipo de comunicação é que cada processo receptor, receba cópias das mensagens enviadas para o grupo, com garantias de distribuição.
Estas garantias incluem o acordo sobre o conjunto de mensagens que cada processo deve receber e a ordem de entrega para os membros do grupo.
Em a ordenação multicast FIFO, as mensagens de um mesmo processo emissor E devem chegar para os processos do grupo multicast GP na mesma ordem de envio.
A ordem de recepção de mensagens é coerente com a ordem de envio de mensagem de um mesmo originador.
A ordenação multicast causal entrega as mensagens, para os processos do grupo multicast GP, de modo que a pontecial causalidade entre mensagens diferentes seja preservadas.
Ou seja, se uma mensagem m1 preceder uma mensagem m2 por causalidade, para todo processo receptor, a mensagem m2 deverá ser entregue antes da m1.
Em o multicast totalmente ordenado atômico, neste trabalho chamado de multicast de ordem total, todas as mensagens são recebidas na ordem do seu envio, independente de originador e destinatários.
Para tal, supõe- se a existência de relógio global.
Dado este fator, torna- se importante salientar que esta ordenação é considerada fictícia.
Em a prática torna- se impossível manter um relógio global entre os diferentes processos emissores.
Em a comunicação síncrona, o processo emissor fica bloqueado até saber que sua requisição foi aceita por o receptor.
Já na comunicação assíncrona, o emissor continua sua execução imediatamente após ter enviado sua mensagem, não ficando bloqueado.
Configurações significativas das características anteriormente citadas foram consideradas para representação da biblioteca de especificações formais de padrões para mecanismos de troca de mensagens.
O objetivo é que o desenvolvedor de um sistema distribuído faça uso de tais padrões para representar, em seu sistema, as funcionalidades escolhidas de uma plataforma de comunicação.
Estes padrões foram construídos e provados em Event-B e, assim, cada um define um passo de refinamento guiado no sistema alvo.
A Figura 3.1 apresenta uma visão geral dos padrões construídos.
As linhas representam relações entre pares de especificação padrão e refinamento padrão, definindo cada uma um padrão.
Em esta figura, no sentido vertical, de cima para baixo, tem- se redução de não determinismo:
A especificação padrão está ao alto e o refinamento padrão abaixo, em cada padrão.
Nota- se que um refinamento padrão, num padrão, pode conter os elementos da especificação padrão de um ou mais outros padrões, ensejando a possibilidade de planejar diversos passos de refinamento para chegar às funcionalidades desejadas.
Por exemplo, veja na figura que a partir de a aplicação do padrão 4 pode- se considerar a aplicação dos padrões 5, 6 ou 7.
Visando facilitar a aplicação dos padrões contidos na biblioteca para os mais diversos tipos de sistemas distribuídos modelados em Event-B, todas as definições de tipos de dados e constantes dos padrões foram construídas no contexto, parte estática do modelo.
Com essa característica os padrões podem ser aplicados a diferentes tipos de dados, bastando alterações no respectivo contexto, não ficando restrita sua utilização a apenas uma construção.
Em as próximas seções serão descritos os padrões contidos na biblioteca de padrões.
Os padrões existentes na biblioteca de padrões foram construídos aos pares:
Especificação padrão (modelo abstrato) e refinamento padrão (modelo concreto).
Especificação Padrão Inicial O conjunto de padrões propostos, conforme Figura 3.1, tem a mesma especificação padrão de partida.
O modelo especificação padrão inicial define as estruturas básicas de comunicação necessárias para a troca de mensagens entre os processos.
Para tanto, no contexto da especificação padrão de partida, apenas declarou- se o conjunto Dados.
Tal conjunto representa os tipo de dados que trafegaram no canal de comunicação do modelo.
O modelo da especificação padrão inicial, conforme Figura 3.2, contém três variáveis declaradas:
Canaldados, dadosrecebidos e msgenviadas.
A variável dadosrecebidos, representa no modelo o buffer do processo receptor, sendo especificada igualmente ao canaldados (inv2 da Figura 3.3).
Já a variavel msgenviadas, representa a identificação que é enviada junto do dado na mensagem, sendo especificada como um valor natural diferente de zero (inv3 da Figura 3.3).
O evento initialisation da Figura 3.4 é reponsável por inicializar as variáveis do modelo.
Inicialmente os conjuntos canaldados e dadosrecebidos são vazios e variável msgenviadas tem valor 1 (act3 da Figura 3.4).
Além de o evento de inicialização, o modelo de especificação do padrão inicial, é constituído de dois eventos:
Sender e receiver.
O evento sender (Figura 3.5) é reponsável por o envio de uma mensagem.
Para tanto suas guardas deverão ser respeitadas, ou seja, a mensagem a ser enviada deve pertencer ao conjunto Dados e o identificador da mensagem deve ser um valor natural diferente de zero (grd2 da Figura 3.5).
Sendo verdadeiras essas condições, o evento sender coloca uma mensagem no canal de comunicação (act1 da Figura 3.5) e incrementa numa unidade o identificador da mensagem (act2 da Figura 3.5).
Já o evento receiver (Figura 3.6) é responsável por receber as mensagens que estão trafegando no canal.
Portanto para este evento ocorrer, basta que exista uma mensagem no canal de comunicação.
Sendo verdadeira esta condição, a buffer recebe a mensagem do canal de comunicação e através de uma ação não determinística, a mensagem pode continuar ou ser removida do canal (act2 da Figura 3.6).
Dada a modelagem da especificação padrão inicial, nota- se que as estruturas previamente necessárias num sistema alvo para aplicação do padrão são bastante simples.
A modelagem do usuário se inicia com uma noção ainda pouco definida das características de comunicação desejadas.
Este modelo é ponto de partida para os vários padrões da biblioteca e define todas possíveis seqüências de computações, em termos de operações de envio e recepção de mensagens, que este canal possa apresentar.
Os padrões descritos a seguir, restringem o conjunto possível de computações em passos de refinamento, adicionando estruturas, fortalecendo guardas e ações.
A o escolher aplicar um padrão específico, o usuário opta por uma dada semântica de comunicação.
Isso se concretiza com um passo de refinamento guiado que restringe não determinismo do sistema.
Para um padrão da biblioteca proposta, o passo de refinamento definido elimina computações que não representem as características específicas do mecanismo de comunicação desejado.
Padrão Unicast Síncrono O padrão unicast sícrono, consiste num mecanismo de comunicação para troca de mensagens entre um processo emissor e um processo receptor, sendo que uma operação de envio só tem sucesso com a respectiva operação de recepção.
Para controle das mensagens, enviadas por o sender para o receiver, no refinamento padrão Em as invariantes, definiu- se que as novas variáveis, adicionadas num passo refinamento, somente poderão conter o valor 0 ou 1 no modelo.
As invariantes inv6, inv7, inv8 da Figura 3.8 provam propriedades do sincronismo no sistema e serão discutidas adiante no trabalho.
Para garantir o sincronismo, foram adicionadas duas guardas no refinamendo do evento sender, restrigindo o evento a enviar uma mensagem somente quando:
Receber a confirmação do receiver e o canaldados esteja vazio.
Além de as guardas, foram adicionadas ações responsáveis por:
Avisar o receiver da mensagem enviada e atualizar o conhecimento local do sender sobre a última mensagem enviada.
Dada a modelagem do refinamento padrão síncrono, nota- se que:·
os canais adicionados possuem a função de sincronia no modelo, ou seja, um é utilizado para avisar o evento receiver quando uma nova mensagem é colocada no canal, deixando o sender bloqueado, e o outro para avisar o evento sender quando a mensagem for recebida por o evento receiver, portanto desbloqueando o sender.·
foi reduzido o não-determismo no evento receiver fazendo que com as mensagens sejam removidas do canal após lidas por o receptor.·
a conservação de três invariantes contidas no modelo refinamento padrão, permite comprovar que no máximo uma mensagem por vez estará trafegando no canal e que enquanto a confirmação do receiver não for concretizada o sender permanecerá bloqueado Padrão Unicast Assíncrono sem Ordem O padrão unicast assíncrono sem ordem, consiste num mecanismo de comunicação para troca de mensagens entre um processo emissor e um processo receptor.
O processo emissor não fica bloqueado aguardando resposta, com isso um número ilimitado de mensagens podem estar trafegando no canal de comunicação.
As mensagens são entregues em qualquer ordem.
Em o refinamento padrão as guardas dos eventos sender e receiver não foram modificadas, matendo a mesma construção da especificação padrão.
Apenas removeu- se o não determinismo na ação de recepção para que apenas uma cópia da mensagem seja recebida.
Padrão Unicast Assíncrono com Ordem.
O padrão unicast assíncrono com ordem, consiste num mecanismo de comunicação, para troca de mensagens entre um processo emissor e um processo receptor, com ordenação FIFO.
Novamente, um número ilimitado de mensagens podem estar no canal.
Entretanto, a modelagem realizada no refinamento do padrão unicast assíncrono com ordem é diferenciada das anteriores.
Em este, foi adicionado uma variável ordemrecv ao refinamento e restringido o evento receiver para respeitar a entrega das mensagens na ordenação FIFO.
Em o evento de inicialização do refinamento padrão, foi adicionada a inicialização da variável ordemrecv.
Em a Figura 3.15 é possivel perceber que ordemrecv é inicializada com valor 1 (act4).
Em este refinamento, não foram realizadas modificações no evento sender da especificação padrão.
A variável msgenviadas, do modelo abstrato, neste refinamento, representa um identificador de ordem global adicionado a cada nova mensagem no canal de comunicação entre o sender e o receiver.
Em o evento receiver, foram adicionadas:
Uma guarda para restringir a entrega das mensagens de acordo com a ordem da variável ordemrecv e uma ação para incrementar, na ocorrência de uma recepção, a variável ordemrecv numa unidade.
Além disso, após cada recepção, o evento receiver remove a mensagem do canaldados.·
com a utilização de uma ordenação global, associada ao envio de cada mensagens, e com a existência de uma guarda, que indica a próxima mensagem a ser recebida por o evento receiver (identmsg $= ordemrecv), foi possível garantir a ordenação FIFO de entrega da mensagens.·
com a existência da ordenação e com a remoção da mensagem após cada recepção, removeu- se o não determinismo existente na espeficicação padrão do modelo.
Padrão Multicast Assíncrono sem Ordem O padrão multicast assíncrono sem ordem, consiste num mecanismo de comunicação em grupo onde todo processo deste pode ser enviador ou receptor.
Dada tal característica, tornam- se necessária estruturas no modelo, de modo a identificar os diferentes processos participantes e o grupo multicast dos mesmos.
Para tanto, no contexto deste refinamento, foram adicionadas duas constantes:
N P que representa o último processo do modelo e GRU P O definido como um conjunto que contém os processos participantes do grupo multicast.
Em o modelo refinamento padrão, foi adicionada uma variável canalprocessos que contém os dados de origem e destino das mensagens multicast.
A variável canalprocessos é definida como um conjunto que contém:
Uma função parcial de um valor natural, diferente de zero, mapeado para um função parcial de um intervalo de 1 até Portanto no canalprocessos, os processos originadores são representados por um intervalo de 1 até da inv1 da Figura 3.18).
O novo canal adicionado foi inicializado com vazio no evento de inicialização da máquina.
Em o evento sender foram adicionadas uma guarda e uma ação.
A guarda é responsável por identificar um processo válido, como originador da mensagem e a ação por adicionar no canalprocessos, para cada mensagem postada no canal de comunicação (canaldados), a identificação da mensagem, o originador e o grupo de destinatários.
Analisando as ações do evento sender, é possivel perceber que o canalprocessos é relacionado com o canal de mensagens (canaldados) através de uma chave de identificação única que é a ordenação global de envio das mensagens (msgenviadas).
Em o evento receiver foram adicionadas duas guardas e uma ação.
Existindo um grupo de processos como destinatário para uma mensagem, as guardas acrescentadas no refinamento padrão informam um possível processo receptor.
Já a ação adicionada, representa a remoção ou não da mensagem no canal canalprocessos, ou seja, representa um não determinismo sobre o canal com os dados de origem e destino da mensagem Dada a modelagem do refinamento padrão do multicast sem ordem, nota- se que:·
neste passo de refinamento foram introduzidos estruturas nos eventos, de modo a proporcionar a recepção e o envio de mensagens por múltiplos processos.·
canalprocessos é relacionado com o canal de mensagens (canaldados) através de uma chave de identificação única, ou seja, para cada mensagem postada no canal de comunicação (canaldados) é especificado o originador e o grupo de destinatários (estruturas de comunicação multicast).·
os diferentes processos pertencentes ao grupo multicast podem receber as mensagens do canal nas mais diferentes ordens, assim como também podem postergar o recebimento de determinada mensagem ou receber duplicatas.·
existe a presença de não determinísmo sobre os canais de comunicação do modelo.·
este refinamento padrão define todas possíveis ordens de entrega para o grupo e, portanto, serve como especificação padrão para os outros padrões multicast (ordem FIFO, total e causal) Padrão Multicast FIFO O padrão multicast assíncrono com ordem FIFO, consiste num mecanismo de comunicação em grupo com entrega FIFO.
Em o refinamento padrão, do multicast FIFO, foram inseridas novas variáveis ao modelo, sendo as mesmas apresentadas na Figura 3.22.
A variável canalcontrole representa o canal de comunicação que identifica a ordem FIFO das mensagens postadas, sendo definida como uma função parcial de naturais, sem o zero, mapeada para naturais.
A ordem da última mensagem enviada, por cada processo emissor, é armazenada no historicosend.
Elemento, do domínio, tem que possuír um e somente um elemento, da imagem, mapeado.
As variáveis historicoorigem, historicoprocdestino e historicoordem representam o histórico das mensagens recebidas por os processos.
Portanto, registrando após cada recepção o processo de origem, o processo de destino e a ordem FIFO da mensagem.
Estes três históricos são definidos respectivamente por as invariantes inv3, inv5 e inv6 da Figura 3.23.
O evento de inicialização das variáveis do refinamento, pode ser visualizado na Figura 3.24.
Assim como os canais herdados do modelo abstrato (especificação padrão), o canalcontrole é inicializado vazio (act5 da Figura 3.24).
A ordem FIFO (historicosend) de todos os processos emissores do modelo, é mapeada para o valor zero (act6 3.24).
Os historicos do modelo são inicializados vazios.
O indexador dos historicos é iniciado com zero.
A ordem FIFO de recepção dos processos é mapeada para o valor zero na inicialização.
A variável controlecanal tem todos os seus elemento mapeados para zero.
Além de o evento de inicialização, são apresentados outros três eventos no refinamento padrão:
O sender e o receiver herdado da especificação padrão (Seção 3.5) e o evento removemsgcanal adicionado neste passo de refinamento (refinamento padrão).
Em o sender, do refinamento padrão, foram adicionadas duas ações:
Uma reponsável por adicionar no canalcontrole a ordem FIFO da mensagem postada (act4 da Figura 3.25), sendo relacionada com os outros canais por um identificador único (msgenviadas) e outra ação responsável por FIFO do processo emissor.
A recepção das mensagens, no refinamento, é divida em dois eventos:
Receiver e removemsgcanal.
A última recepção de cada mensagem é sempre realizada por o evento removemsgcanal, de modo que seja realizada a recepção e a remoção da mensagem do canal.
Os outros casos de recepção acontecem no evento receiver.
As guardas do evento receiver podem ser visualizadas na Figura 3.26.
As guardas grd8 e grd9 da Figura 3.26 são responsáveis por identificar a ordem FIFO da última mensagem recebida do processo originador para o processo receptor.
Já as guardas grd1, grd2 e grd3 da Figura 3.26 são herdadas da especificação padrão (Seção 3.5).
Além de as guardas citadas anteriomente, para o evento receiver ocorrer, as seguintes guardas devem ser verdadeiras:
Deve existir uma dado, com a ordem FIFO da mensagem, no canalcontrole (grd4 da Figura 3.26);
O processo originador deve ser um processo válido do modelo (grd5 da Figura da mensagem deve ser um valor natural diferente de zero (grd7 da Figura 3.26);
Levando em conta o mesmo processo de origem e destino, a ordem da mensagem do canal de comunicação deverá ser uma unidade maior que a ordem da última recepção;
O identificador usado para associar os canais deve pertencer ao domínio do controlecanal;
A mensagem em questão não pode ter sido recebida por todos os processos do grupo multicast;
O processo receptor deve pertencer ao grupo de processos válidos;
As ordens FIFO do processo receptor devem pertencer a imagem de controleordem.
Sendo verdeiras as guardas do evento receiver, são realizadas as seguintes ações nas variáveis do modelo:
A buffer recebe a mensagem enviada;
A mensagem recebida por o processo continua presente no canal de comunicação (act2 da Figura 3.27);
Os historicos historicoorigem, historicoprocdestino e historicoordem são atualizados com os novos valores da recepção (act3, act5 e act6 da Figura 3.27);
Levando- se em conta o processo originador e o processo receptor da mensagem recebida, atualizada- se a ordem FIFO da variável de controle, para o valor contido na mensagem (act7 da Figura 3.27);
Para que os outros processos do grupo multicast possam receber a mensagem, canalprocessos continua com a mensagem no canal (act8 da Figura da Figura 3.27).
Em a Figura 3.28 são descrita as guardas do evento removemsgcanal.
Comparando- se as guardas do evento receiver (Figura 3.26), com as guardas do evento removemsgcanal (Figura 3.28) é possivel perceber que, com exceção da grd12, as guardas que restrigem os dois eventos são as mesmas.
Assim como as guardas, as ações dos eventos removemsgcanal (Figura 3.27) e receiver são iguais, com exceção das ações act2, act3 e act4.
As semelhanças encontradas nas guardas e nas ações dos eventos receiver e removemsgcanal, deve- se ao fato que, as restrições para recepção das mensagens são necessárias a ambos eventos.
Dada a modelagem do refinamento padrão do multicast FIFO, nota- se que:·
foi definido um canal adicional contendo a ordenação FIFO das mensagens enviadas por os processos.
Desta forma, o refinamento ficou constituído de três canais de comunicação:·
para realizar a ordenção FIFO, modelou- se uma estrutura que armazena as mensagens recebidas (controleordem), de cada processo originador e destinatário.·
com base nas restrições, adicionadas neste passo de refinamento, os eventos responsáveis por as recepções de mensagens, verificam qual a próxima possibilidade de recepção para cada processo do grupo multicast, ou seja, para ser realizada a recepção de uma mensagem, a ordem do processo de origem, associada a mensagem, deve ser uma unidade maior que a existente no processo receptor.·
foi adicionado um evento, que na última recepção de cada mensagem, remove a mensagem do canal de comunicação e as informações associadas a ela.
Desta forma, removendo o não determinísmo sobre os canais, ou seja, restringindo o comportamento do modelo.·
em a inv9 da Figura 3.23 foi possivel provar que o grupo multicast terá o máximo N P elementos.
Já a inv10 define que o número máximo de recepções será o número de elementos do grupo, poratnto nenhum processo realizará a recepção de uma mesma mensagem duas vezes.
Padrão Multicast Total O padrão multicast assíncrono com ordem total, consiste num mecanismo de comunicação em grupo onde todos processos recebem as mensagens na mesma ordem global do seu envio.
Em o refinamento padrão do multicast total, foram inseridas duas novas variáveis:
Ordem e historicoprocesso.
A variável ordem é utilizada na remoção das mensagens do canal de comunicação, sendo definida por a inv1 da Figura 3.31 como um valor natural.
Já a variável historicoprocesso é responsável por registrar a ordem das recepções das mensagens por os processos, ou seja, representa a ordem total no modelo.
Historicoprocesso é definida, por a inv2 da Figura 3.31, como um elemento de uma função total de 1 até N P mapeado para valores naturais.
O refinamento padrão, do padrão multicast total, contém quatro eventos:
O evento de inicialização, o evento sender, o evento receiver e por último o evento removemsgcanal, adicionado neste passo de refinamento.
Em o evento de incialização, foram adicionadas duas novas ações:
Ordem é iniciada com valor 1 (act5 da Figura 3.32) e historicoprocessos tem os valores de 1 até N P mapeados para zero (act7 da Figura 3.32).
Em o refinamento da especificação padrão, não foi realizada nenhuma modificação no evento sender.
Portanto, no refinamento padrão, do padrão multicast total, o evento sender continua igual ao descrito na Seção 3.5.
Igualmente ao padrão multicast FIFO, a recepção das mensagens, no padrão multicast total, foi divida em dois eventos:
Receiver e removemsgcanal.
Em o evento receiver, a recepção de uma dada mensagem ocorre até o penúltimo processo do grupo multicast.
Para tanto, as guardas do evento receiver deverão ser verdadeiras:
Deve existir uma mensagem no canaldados e um dado associado (identmsg) no canalprocessos com a origem e o destino da mensagem (grd2 da Figura 3.33);
A recepção deve ser realizada por um processo pertencer ao grupo de destino da mensagem (grd3 da Figura 3.33);
Sendo verdadeiras as guardas do evento receiver, as seguintes ações são realizadas:
A buffer recebe a mensagem;
Visando futuras recepções, por outros processos do grupo multicast, a mensagem continua no canal de comunicação (act2 da Figura 3.33);
O historico de recepção do processo é atualizado para ordem contida na mensagem (act3 da Figura 3.33);
Por o mesmo motivo do canal de comunicação (canaldados), o dado associado a mensagem é mantido no canal (act4 da Figura 3.33).
O evento removemsgcanal é responsável por a recepção das mensagens, entretanto, neste evento, somente é realizada a recepção quando restar apenas um processo para receber determinada mensagem.
Além de realizar a recepção, o evento removemsgcanal deve remover a mensagem do canal de comunicação.
Para o evento removemsgcanal ocorrer, suas guardas deverão ser verdadeiras:
Deve exitir uma mensagem no canal de comunicação e uma dado associado com a origem e o destino da mensagem (grd2 da Figura 3.34);
O processo receptor deve pertencer ao grupo de destino da mensagem (grd3 da Figura 3.34);
Deve apenas faltar um processo para realizar a recepção da mensagem em questão (grd5 da Figura 3.34);
A ordem total das mensagens enviadas deve ser preservada (grd7 da Figura 3.34).
Sendo verdadeiras estas condições, são aplicadas as seguintes ações no modelo:
A buffer recebe a mensagem presente no canal de comunicação;
A mensagem é removida do canal de comunicação (act2 da Figura 3.34);
A variável de controle da ordem total é incrementada numa unidade (act3 da Figura 3.34);
Os dados associados a mensagem do canal de comunicação são removidos do canal (act4 da Figura 3.34);
O histórico de recepção das mensagens recebe a ordem contida na mensagem recebida (act5 da Figura 3.34).
Dada a modelagem do padrão multicast total, nota- se que:·
em o modelo do refinamento padrão do multicast total não foi inserida nenhuma estrutura nova de canal.
Os canais presentes no modelo são herdados da especificação padrão (Seção 3.5).·
para a ordenação total das mensagens, foi utilizada a chave de identificação única, introduzida no padrão multicast sem ordem.
Desta forma, a ordenação total, foi garantida através restrição das guardas dos eventos receptores, ou seja, um processo receptor somente receberá a mensagem que contiver uma ordem com o valor de uma unidade maior da contida no seu histórico (grd4 da Figura 3.33 e grd7 da Figura 3.34).·
foi introduzido um novo evento para remoção das mensagens dos canal de comunicação, ou seja, removeu- se o não determinísmo do modelo existente na especificação padrão.
Padrão Multicast Causal O padrão multicast assíncrono com ordem causal, consiste num mecanismo de comunicação em grupo onde a recepção de mensagens respeita a relação de causa.
A modelagem da ordenação causal, descrita neste refinamento, é baseado no conceito de relógios lógicos descritos em.
As variáveis presente no refinamento padrão, do padrão multicast causal, podem ser visualizadas na Figura 3.35.
As variáveis inseridas neste passo de refinamento são:
Historicoorigem, historicoprocdestino, historicoordem, conthistorico, vetorclocks, canalordem e controlecanal.
A variável vetorclocks representa o relógio vetorial (vetores de clock) de cada processo em particular.
Para tanto, precisou ser definida como uma função total de 1 até N P, mapeado para outra função total de 1 até N P, mapeado para valores naturais (inv7 da Figura 3.36).
A variável canalordem, representa a ordem causal dos processos emissores, sendo definida, por a inv8 da Figura 3.36, como um conjunto que deve conter uma função parcial de valores naturais, sem o zero, mapeado para uma função total de 1 até N P, mapeado para valores naturais.
Por último, controlecanal, representando o número de processos que efetuaram a recepção de determinada mensagem, sendo definida como uma função total de um valor natural, sem o zero, mapeado para valores de zero até N P menos 1.
A inv10 da Figura 3.36 garante que o grupo multicast terá no máximo N P elementos no conjunto.
Fazem parte do refinamento padrão, do padrão multicast causal, os seguintes eventos:
Evento de inicialização, evento sender, evento receiver e evento removemsgcanal.
O evento de inicialização do modelo, encontra- se na Figura 3.37.
Através da Figura 3.37 percebe- se que, em relação variáveis adicionadas neste passo de refinamento:
Todos os históricos e o canalordem iniciam vazios;
A variável usada para associar os históricos é iniciada com valor zero;
Todos os valores do vetorclocks e da variável controlecanal são mapeado para zero.
Para o evento sender ocorrer, as suas guardas deverão ser respeitadas, ou seja:
A mensagem deve pertencer ao conjunto Dados;
O identificador de associação dos canais deve ser um valor natural;
O processo emissor deve ser um processo válido;
O processo emissor deve possuir um relógio vetorial;
O relógio vetorial do processo emissor, deve conter a ordem causal da mensagem;
Para este padrão, assim como nos outros padrões multicast com ordem (FIFO e total), são dois os eventos responsáveis por realizar a recepção das mensagens:
Receiver e removemsgcanal.
Para o evento receiver ocorrer, as seguintes condições devem ser verdadeiras:
Deve ter que existir uma mensagem no canal de comunicação;
Deve ter que existir dados de origem e destino associado a mensagem;
O processo receptor tem que estar no grupo de destino da mensagem;
O processo emissor tem que ser válido;
O processo receptor tem que pertencer ao grupo multicast;
Analisando a Figura 3.41, que contém as guardas do evento removemsgcanal, nota- se que para o evento ocorrer são necessárias as mesmas restrições impostas por o evento receiver, exceto por a gr14 da Figura 3.41, que no evento removemsgcanal, determina que a recepção somente ocorrerá quanto existir apenas um processo faltando para receber a mensagem.
Portanto sendo verdadeiras as guardas do evento removemsgcanal, as seguintes ações são realizadas:
A buffer recebe a mensagem do canal de comunicação;
A mensagem é removida do canal de comunicação (act2 da Figura 3.42);
Os históricos são atualizados com os dados associados a mensagem (act3, act5, act6 da Figura 3.42);
O identificador que associa os históricos é incrementado numa unidade (act4 da Figura 3.42);
Os dados de origem e destino são removidos do canal (act7 da Figura 3.42);
O relógio vetorial do processo receptor é atualizado para a ordem do processo originador, contida no relógio vetorial associado a mensagem (act8 da Figura o relógio vetorial associado a mensagem é removido do canal.
Dada a modelagem do multicast Causal, nota- se que no refinamento padrão:·
foi necessário introduzir uma estrutura de controle para cada processo manter seu relógio vetorial (vetorclocks).·
foi adicionado um canal de controle (canalordem), contendo informação sobre a relação causal entre as mensagens, na forma de um relógio vetorial.
Este canal de comunicação é associado a mensagem com um identificador único.·
a garantia da ordenação causal no sistema é comprovada por as restrição das guardas nos eventos receptores.
As guardas dos eventos receptores foram restritas para realizar a recepção das mensagem em que:
A ordem do processo originador, contida no relógio vetorial associado a mensagem, for uma unidade maior que ordem do processo originador, presente no relógio vetorial do processo receptor;
O restante dos processos (diferentes do originador), presentes no relógio vetorial da mensagem, devem possuir uma ordem maior ou igual as contidas no relógio vetorial do processo receptor (grd12 das Figuras 3.39 e· foi adicionado um evento (removemsgcanal) para remoção da mensagem do canal de comunicação e os dados associados a mensagem.
A remoção ocorre na recepção do último processo, de um dada mensagem, por um grupo multicast.
Desta forma, removendo- se o não determinísmo do sistema.
Para exemplificação do uso da biblioteca de padrões (Capítulo 3), neste capítulo, foi realizada a modelagem de um sistema distribuído em Event-B:
O protocolo two-- phase commit (2 PC).
O=2  PC é um protocolo para efetivação de modificações por um grupo de processos, que opera em duas fases.
Em ambas fases, um processo, dito líder, coordena a ações dos demais processos, ditos participantes.
Em a primeira fase são realizadas as seguintes ações:
O líder muda seu estado para wait, enviando, para os processos participantes, uma mensagem de vote_ request.
Desta forma convocando os processos participantes a votarem por efetivar (commit) ou abortar (abort) modificações conjuntas.
Os processos participantes votam, mudando os seus estados para ready.
O líder recolhe os votos dos participantes e computa a decisão:
Caso todos tenham votado por a efetivação, o líder modifica seu estado para commit.
Caso ao menos um participante tenha votado por abortar as modificações, o líder modifica seu estado para abort.
Em a segunda fase, o líder informa a decisão a todos participantes:
Caso seja por a efetivação, o líder envia uma mensagem de global_ commit para os processos participantes;
Caso seja por abortar, o líder envia uma mensagem de global_ abort.
Por fim os processos participantes confirmam a decisão, mudando seus estados com base na decisão do líder, ou seja, commit ou abort).
A modelagem do 2 PC contém um contexto que é parametrizado para todas as máquinas do modelo.
Em o contexto foram definidos quatro conjuntos:
FASELIDER, FASEPROCESSO, MSGLIDER e FASELIDER contém, como elementos do conjunto, os estados válidos para o processo líder axm2 da Figura 4.2):
MSGLIDER contém, como elementos do conjunto, as seguintes constantes (axm8 da Figura que o líder pode enviar para os processos participantes.
Já o conjunto Votos, que representa os possíveis votos dos processos participantes, é definido por o axm10, da Figura 4.2, com as seguintes constantes como elementos:
Semvoto, processoscommit, processoabort.
Além de as constantes, citadas anteriomente, como elementos dos conjuntos, o contexto do modelo contém também as seguintes constantes:
LIDER que representa o processo líder na modelagem, sendo definida com valor 1 (axm7 da Figura 4.2);
Np que representa o valor máximo de processos na modelagem, sendo definido com o valor 4;
Processos representando o conjunto dos processos participantes, sendo defindo no axioma axm6, da Figura 4.2, com os valores 2, 3 e 4 como elementos de Processos.
Os axiomas axm3, axm4, axm9, axm11 são utilizados para especificar na modelagem que os diversos elementos contidos nos conjuntos, anteriomente descritos, são diferentes.
FIFO (Seção 3.6) e padrão unicast síncrono (Seção 3.2).
A modelagem do 2 PC_ 1, inicia contemplando a comunicação no sentido líder -- participantes e estruturas que definem os estados de cada processo.
Com relação a os padrões anteriormente descritos, esta máquina tem combinação com a especificação padrão do multicast sem ordem (Seção de originador e destinatário, além de um evento de envio e um de recepção.
As seguintes variáveis compõem a máquina 2 PC_ 1: Estadoprocesso, estadolider, canallider, canalcontrole, dadosrecebidos, msgenviadas.
A variável estadoprocesso representa o estado que cada processo participante em particular encontra- se.
Tal variável foi definda como uma função total de 2 até Np, mapeada para o conjunto FASEPROCESSO.
A variável ESTADOLIDER representa o estado que o líder encontra- se, portanto sendo definida como um elemento de FASELIDER (inv2 da Figura 4.3).
As variáveis canallider, canalcontrole, dadosrecebidos e msgenviadas são variáveis responsáveis por o envio das mensagens do líder para os processos participantes, desta forma, necessárias para a combinação do modelo two phase commit com o padrão multicast FIFO.
Portanto as invariantes inv3, inv4, inv5 e inv6 são definidas de acordo com a especificação padrão, do padrão (Seção 3.5).
Em o 2 PC_ 1, todos os processo participantes iniciam no estado initp e o líder inicia no estado init.
O restante das ações (act3, act4, act5, act6 da Figura 4.4) são necessárias para combinação, portanto sendo inicializadas de acordo com a especificação padrão, do padrão multicast FIFO (Seção 3.5).
Além de o evento de inicialização (Figura 4.4), o 2 PC_ 1 é composto de dois eventos:
O evento de envio, das mensagens multicast, do líder para os participantes, chamado multicastlider;
O evento de recepção, das mensagens multicast por os participantes, chamado processorecebemsg.
Em o evento multicastlider (Figura 4.5) foram adicionadas:
As guardas necessárias para a combinação do 2 PC_ 1 com o padrão;
Uma restrição nas guardas, afim de garantir que somente o líder envie mensagens multicast para os processos participantes (grd3);
Uma guarda para restringir as trocas de estado do líder, para um estado válido do modelo (grd5);
Ações responsáveis por colocar a mensagem no canal, sendo necessárias para a combinação do padrão multicast FIFO (act2, act3 e act4);
Uma ação responsável por modificar o estado do líder (act1).
Já no evento processorecebemsg foram adicionadas:
As guardas necessárias para a combinação;
As guardas responsáveis por restringir a troca dos processos para um estado válido do modelo (gdr4 e grd5 da Figura 4.6);
As ações responsáveis por receber as mensagens do canal de comunicação, sendo necessárias para combinação do modelo com o padrão multicast FIFO (act2, act3 act4 da Figura 4.6);
A ação responsável por a troca de estado dos processos participantes na recepção das mensagens.
Dada a modelagem, percebe- se que o envio das mensagens do líder para os processos participantes e as mundanças de estado da modelagem, tanto do líder como dos participantes, ocorrem sem ordem.
Além disso, como comentado anteriomente, as comunicação até a presente modelagem ocorrem em apenas um sentido (líder -- processos participantes).
Em esta fase, foram combinadas as variáveis e os eventos da máquina.
Para tanto, foram utilizados o 2 PC_ 1, anteriomente descrito, e a especificação padrão do multicast FIFO (Seção 3.5).
Observando a Tabela 4.1 percebe- se que:
Em a linha 1, canaldados foi combinada com canallider;
Em a linha 2, dadosrecebidos (especificação padrão) foi combinada com dadosrecebidos (2 PC_ 1);
Em a linha 3, msgenviadas (especificação padrão) foi combinada com msgenviadas (2 PC_ 1);
Em a linha 4, canalprocessos foi combinada com canalcontrole;
Estadoprocesso e estadolider são variáves extras na combinação (linhas 5 e 6).
Em a Tabela 4.2 são apresentados os eventos combinado.
Observando a Tabela 4.2, percebe- se:
Em a linha 1, foram combinados o initialisation da especificação padrão e o initialisation do 2 PC_ 1;
em a linha 2, foram combinados o sender da especificação padrão e o multicastlider do 2 PC_ 1;
em a linha 3, foram combinados o receiver da especificação padrão e o processorecebemsg do 2 PC_ 1;
em esta combinação, não existem eventos extras.
Sendo definidas as variáveis combinadas e os eventos combinados é terminada a primeira fase (combinação).
Em a segunda fase é realizada a verificação das variáveis e eventos combinados.
Para realização da fase de verificação, foram utilizados o 2 PC_ 1, anteriomente descrito, e a especificação padrão do multicast FIFO (Seção 3.5).
Analisando a Figura 4.7, nota- se que:
As guardas grd1, grd2, grd3 do sender são sintaticamente iguais, respectivamente, às guardas grd1, grd4, grd2 do evento multicastlider;
As guardas grd1, grd2, grd3 do receiver são sintaticamente iguais, respectivamente, às guardas grd1, grd2, grd3 do processosrecebemmsg.
Em o passo V1, o evento de inicialização não é comparado por se tratar de um evento sem guardas.
A verificação V1 é dada como correta, visto que todos os eventos combinados da especificação padrão, do padrão multicast FIFO, possuem guardas sintaticamente iguais nos eventos combinados do 2 PC_ 1.
Em o passo V2 é verificado a existência de guardas extras.
Observando a Figura 4.7, percebe- se a existência de quatro guardas extras (não combinadas):
Grd3 e grd5 do evento multicastlider;
Grd4 e grd5 do evento processosrecebemsg.
Definidas as guardas extras da máquina, foi realizado o passo V3, ou seja, a verificação sintática das ações.
Verificando os eventos da especificação padrão e do 2 PC_ 1, percebe- se que:
As ações act1, act2, act3 e act4, do evento initialisation da especificação padrão, são sintaticamente iguais, respectivamente, às ações act3, act5, act6 e act4 do evento initialisation do 2 PC_ 1;
Em o evento sender a ações act1, act2, act3 são sintaticamente iguais, respectivamente, às ações act2, act3, act4 do evento multicastlider (Figura act2, act4, act3 do evento processosrecebemsg.
Todas as ações dos eventos initialisation, sender e receiver (especificação padrão), tem uma ação sintaticamente igual nos respectivos eventos combinados do 2 PC_ 1 (Tabela 4.2).
Portanto é dada como correta a verificação V3.
Em o último passo da verificação (passo V4), procura- se ações extras (não combinadas) nos eventos combinados do 2 PC_ 1.
Neste passo, analisando a Figura 4.8, foram encontradas quatro ações extras no 2 PC_ 1: Act1 e act2 do evento initialisation;
Act1 do evento multicastlider;
Act1 do evento processosrecebemsg.
Completado os passos de verificação, percebe- se que o padrão multicast pode ser incorporado no 2 PC_ 1.
Para incorporação do padrão é gerado um refinamento no modelo two phase commit, chamado 2 PC_ 2.
Em o 2 PC_ 2 é incorporado ao modelo a ordenação FIFO.
A aplicação do pardão FIFO gera um modelo análogo ao anterior, unicamente inserindo a propriedade de ordem na comunicação lider participante.
A ordenação FIFO é necessária na comunicação líder -- participante, pois uma decisão de abortar poderia ser recebida antes de um participante ter recebido a mensagem de pedido de votação.
Isto poderia acontecer caso um outro participante imediatamente vote por abortar.
Para incorporação é utilizado o refinamento padrão, do padrão multicast FIFO (Seção 3.6), e o Em o primeiro passo da incorporação, foram copiadas as variáveis do refinamento padrão (Seção Segundo é considerado um bom método renomear as variáveis criadas do refinamento padrão, para que numa futura aplicação, do mesmo padrão no modelo, não existam variáveis repetidas.
Para tanto, após copiar as variáveis para a máquina, foram inseridas, nas variáveis criadas no refinamento padrão, o sufixo_ votacão.
Além disso, como relatado anteriomente (Seção 2.2), para que os teoremas identifiquem as variáveis, foi necessário modificar as variáveis combinadas da especificação padrão, existentes no refinamento padrão, por as variáveis combinadas do 2 PC_ 1.
Desta forma ficando as variáveis da máquina 2 PC de acordo com o passo I1.
3 da Tabela 4.3.
Definidas as variáveis da máquina, foi realizada a incorporação das invariantes do 2 PC_ 2 (passo I2).
Para tanto, foram copiadas as invariantes da especificação padrão (Seção 3.5) e do refinamento padrão (Seção 3.6), do padrão multicast FIFO, para o refinamento 2 PC_ 2 (Figura 4.9).
Observando a Figura 4.9 é possivel notar que as mudanças necessárias as variáveis, no passo I1, foram refletidas nas invariantes do 2 PC_ 1, assim como no decorrer de a modelagem, serão refletidas na construção dos eventos.
Em o refinamento padrão do padrão multicast FIFO (Seção 3.6) existem 4 eventos:
Initialisation, sender, receiver e o removemsgcanal.
O evento receiver da especificação padrão do multicast FIFO foi decomposto em dois eventos no refinamento padrão:
Receiver e removemsgcanal.
Com isso, o evento removemsgcanal, apesar de surgir no refinamento padrão, não é considerado um evento novo, mas um evento refinado da especificação padrão.
Dado que o refinamento padrão, do multicast FIFO, é apenas constituído de eventos refinados dos eventos combinados da especificação padrão e dado que não existam eventos extras na combinação, os passos I3 e I4 da incorporação não foram necessárias.
Em o passo I5 é realizada a incorporação dos eventos refinados da especificação padrão, presentes no refinamento padrão, do padrão multicast FIFO.
Para tal passo, a incorporação é realizada evento a evento, ou seja, os eventos initialisation, multicastlider, processosrecebemsg e removemsg_ votacão, do 2 PC_ 2, foram incorporados um a um.
O primeiro evento incorporado no 2 PC_ 2 foi o initialisation.
Dado que este evento não contém guardas os passos I5.
1 e I5.
2 não foram aplicados.
Portanto, para este evento, necessitando apenas a incorporação das ações do evento initialisation.
Primeiramente compiaram- se as ações do evento initialisation do refinamento padrão, para a máquina 2 PC_ 2.
Em seguida, foram acrescentadas a ações extras ao evento e realizadas as trocas necessárias nas ações, refletindo as trocas de variáveis do passo I1.
Portanto ficando as ações do evento de inicialização do 2 PC_ 2 apresentadas no passo I5.
4 da Figura 4.10.
O segundo evento incorporado no 2 PC_ 2 foi o evento multicastlider.
Em este evento, ao contrário de o evento de inicialização, foram incorporadas ações e guardas.
Em a incorporação das guardas foram copiadas as guardas do evento sender do refinamento padrão, do padrão multicast FIFO.
Após tal passo, foram adiconadas as guardas extras e realizada a modificação necessária na guarda da linha 1 do passo I5.
1 da figura 4.11.
Em a incorporação das ações do evento multicastlider:
Copiaram- se as ações do evento sender para a máquina 2 PC_ 2;
Foi adicionado uma ação extra no evento;
Realizaram- se as trocas necessárias nas ações do evento, para refletir as mudanças das variáveis, ocorridas no passo I1.
Em o passo I5.
3 e I5.
4 do evento processosrecebemmsg, foram incorporadas as ações, ou seja:
Compiaram- se as ações do evento receiver, do refinamento padrão para o evento processorecebemmsg;
Foram adicionadas as variáveis extras no evento processorecebemmsg;
As mudanças nas variáveis do 2 PC_ 2 foram refletidas no evento Em a Figura 4.14 (passo I5.
4) é apresentada as ações do evento processorecebemmsg do 2 PC_ 2.
O evento removemsg do refinamento padrão, teve seu nome trocado na incorporação para removemsg_ votacao.
O removemsg_ votacão foi o último evento incorporado no 2 PC_ 2.
Para incorporação das guardas do removemsg_ votacão, foram copiadas do refinamento padrão as guardas do evento removemsg.
Sendo o evento removemsg, do refinamento padrão, um evento refinado do evento receiver, combiando com o evento processosrecebemmsg, igualmente o evento removemsg_ votacacão é considerado o refinamento do evento processosrecebemmsg do 2 PC_ 1.
Para tanto foi adicionada a guarda extra do evento processosre-cebemmsg nas guardas do evento removemsg_ votacão.
Para incorporação das ações do removemsg_ votacao:
Foram adicionadas as ações do evento removemsg do refinamento padrão;
Semelhante ao ocorrido com as guardas presentes no evento removemsg_ votacão, foi adicionado a variável extra do evento processosrecebemmsg nas ações do evento removemsg_ votacão.
Em as ações do evento remove_ votacacão apenas a linha 1 do passo I5.
3, da figura 4.16, não precisou ser adequada na máquina 2 PC_ 2.
As ações do evento remove_ votacão são representadas no passo I5.
4 da Figura 4.16.
Em este ponto da modelagem a comunicação no sentido líder -- participantes encontra- se ordenada, ou seja, as determinações do líder são efetivadas ordenadamente nos processos participantes.
Entretanto os processos participantes ainda não conseguem comunicar o líder de seus votos.
Desta forma, foi criado um novo refinamento 2 PC_ 3 para inserção da comunicação no sentido participantes -- lider (Seção 4.3).
Neste passo de refinamento são introduzidas estrturas para comunicação dos processos participantes com o líder.
Dada que a comunicação do sentido líder -- participantes está completa, as guardas dos eventos, responsáveis por tal comunicação, recebem novas restrições no 2 PC_ 3.
Desta forma, restringindo o comportamento do modelo, ou seja, deixando mais perto de a realidade do two phase commit.
Em o 2 PC_ 3 foram adicionadas as seguintes variáveis:
Canalvotacao; Votosrecebidos;
Msgenviadasprocessos; Canalid;
Estadovotacao; Votodosprocessos.
A variável canalvotacacão é o canal de comunicação onde são postados os votos dos processos participantes.
A variável votosrecebidos é o buffer onde são armazenados os votos recebidos no processo líder.
A variável msgenviadasprocessos é o identificador da mensagem enviada.
As variáveis canalvotacão, votosrecebidos e msgenviadasprocessos são necessárias para combinação do padrão síncrono com o modelo 2 PC_ 3, portanto definidas por as invariantes inv1, inv2 e inv3 de acordo a especificação padrão do unicast síncrono.
Já canalid representa o canal de comunicação, que indica o processo originador do voto.
Canalid é definida como elemento de valor zero até Np.
A variável estadovotacão é utilizada para controle da votacação dos processos, sendo definida como um elemento de 2 até Np, Por fim votodosprocessos representa o conhecimento local do líder, sobre os votos dos processos.
Em o refinamento 2 PC_ 3 foram modelados 6 eventos:
Initialisation; Lidermulticast;
Processosrecebemmsg; Removemsg_ votacacao;
Processosvotacao; Liderrecebe.
Os eventos initialisation, lidermulticast e processosrecebemmsg são herdados da máquina abstrato (2 PC_ 2).
Já os eventos processosvotacão e liderrecebe foram criados neste passo de refinamento e são responsáveis por a comunicação no sentido participantes -- líder.
Em o evento de inicialização do 2 PC_ 3 foram adicionadas a inicialização das variáveis criadas neste passo de refinamento.
As ações das variáveis canalvotacacão, votosrecebidos e msgenviadasprocessos são necessárias para combinação, portanto sendo inicializadas de acordo com a especificação padrão do unicast síncrono.
A variável canalid é inicializada com zero, representando que não existem mensagens no canal.
A variável estadovotacão é iniciada com todos os valores (2 até Np) mapeados para False.
Já votodosprocessos, todos os valores (2 até Np) foram mapeados para semvoto.
Em o evento multicastlider foi adicionado uma guarda, afim restringir a troca de estado do processo líder e ordenadar o tipo de mensagens a ser enviada levando em conta a fase do líder no two phase commit.
Para tanto, na guarda grd6 da Figura 4.20, determinou- se que:
Se o estado do líder for init então a mensagem a ser enviada, para os participantes, deve ser vote_ request e o próximo estado do líder wait.
De a mesma forma, nos eventos processosrecebemmsg e removemsg_ votacão foram adicionadas guardas para restringir o comportamento da troca de fase dos processos participantes.
As guardas adicionada nos eventos determina que:
Se o estado do processo participante na recepção, for initp e a mensagem no canal for vote_ resquet, então o participante receptor muda seu estado para ready.
O evento processosvotacão, criado neste refinamento, é responsável por o envio das mensagens com os votos dos processos participantes para o líder.
Para evento processosvotacão ocorrer, as seguintes guardas deverão ser verdadeiras:
O voto dos processo participantes devem pertencer ao conjunto Voto;
O identificador associado a mensagem tem quer ser um valor natural (grd2 da Figura 4.22);
O processo originador tem que fazer parte dos processos participantes (grd3 da Figura 4.22);
O processo originador tem que estar no estado ready (grd4 da Figura 4.22);
O processo originador não pode ter votado (grd5 da Figura 4.22);
O voto tem quer ser diferente de semvoto (grd6 da Figura 4.22).
As guardas gr1 e grd2 da Figura 4.22 são derivadas do evento sender da especificação padrão do unicast síncrono, ou seja, são necessárias para combinação do padrão.
As ações act1 e act2 são derivadas do evento sender da especificação, padrão do unicast síncrono, sendo necessárias para combinação do padrão.
A guarda grd1 é derivada do evento receiver da especificação padrão, do padrão unicast síncrono, portanto sendo utilizada para combinação do padrão.
Sendo verdadeiras as guarda, as seguintes ações são realizadas no evento liderrecebe:
O buffer recebe o voto do processo participante, presente no canal de comunicação;
Terminada a modelagem do 2 PC_ 3, percebe- se que o refinamento gerado introduz um canal simples de comunicação e dois novos eventos:
Um responsável por o envio dos votos dos participantes e outro por a recepção dos votos por o líder.
As guardas dos eventos, responsáveis por a comunicação do líder para os processos participantes, foram restringidas, limitando as trocas de estados iniciais, para um modo ordenado no processo líder e nos processos participantes.
As estruturas introduzidas, neste refinamento, propiciam a combinação com o padrão unicast síncrono, dado que neste nível da modelagem ainda não existe ordem na comunicação participante -- líder.
A ausência de ordem no sentido participante -- líder acarreta na repetição ou perca de votos, além de a impossibilidade de restringir o evento líder para uma tomada de decisão (abort ou commit);
Para tanto é necessário a incorporação do padrão unicast síncrono.
Para incorporação do padrão, novamente foram realizados três fases para garantir a corretude da incorporação:
Combinação, verificação e incorporação.
As variáveis combinadas, na incorporação do unicast síncrono, foram:
Canaldados da especificação padrão com canalvotacão do 2 PC_ 3;
Dadorecebidos da especificação padrão com votosrecebidos do 2 PC_ 3 (linha 2 Tabela 4.4);
Msgenviadas da especificação padrão com msgenviadasprocessos do 2 PC_ 3 (linha 3 Tabela 4.4).
Em o passo C2, foram definidos os seguintes eventos combinados:
Initialisation da especificação padrão com initialisation do 2 PC_ 3;
Sender da especificação padrão com processosvotacão do 2 PC_ 3 (linha 2 da Tabela 4.4);
Receiver da especificação padrão (Seção 3.1) com liderrecebe do 2 PC_ 3 (linha 3 da Tabela 4.4).
Definida as combinações, os eventos e variáveis extras, realiza- se a verificação das combinações.
Realizando o passo V3 da verificação, para os eventos initialisation da especificação padrão e do 2 PC_ 3, percebe- se que as ações dos eventos são sintaticamente iguais.
Já no passo V4, do evento initialisation (2 PC_ 3), foram encontradas as seguintes ações extras:
Act1, act2, act3, act4, act5, act6, act7, act8, act9, act10, act11, act12, act13, act14, act18, act19, act20 da Figura 4.19.
Em o passo V1 e V2 da verificação dos eventos sender e processosvotacão, nota- se que as guardas são sintaticamente iguais e que o evento processosvotacão contém as seguintes guardas extras:
Assim como as guardas, no passo V3, foi verificado que as ações dos eventos sender e processosvotacão são sintaticamente iguais e que o evento processosvotacão contém as ações act3 e act4 da Figura 4.23, como ações extras.
Em a verificação dos últimos eventos combinados receiver e liderrecebe, as guardas e ações foram consideradas sintaticamente iguais.
Além disso, no passo V2, foram encontradas as guardas extras grd2, grd3 e grd4 da Figura 4.24.
Em o passo V4 foram encontradas as ações extras act3 e act4 da Figura 4.25.
Tendo como correta todas as verificações, anteriomente citadas, para a incorporação foi gerado um novo refinamento chamado 2 PC_ 4 (Seção 4.4) Em o refinamento 2 PC_ 4 é incorporado o padrão unicast síncrono aos eventos combinados no refinamento anterior (2 PC_ 3).
Em o passo I1 da incorporação, foram copiadas as variáveis do refinamento padrão, do padrão unicast síncrono (Seção 3.2), para o refinamento 2 PC_ 4.
Semelhante a incorporação da Seção 4.2, foram realizada as trocas necessárias nas variáveis da máquina.
As variáveis presentes no 2 PC_ 4 podem ser visualizadas na Figura 4.26.
Analisando a Figura 4.26 é possivel perceber que, neste refinamento, foi adicionado o sufixo_ sincronismo nas 4 variáveis oriundas do refinamento padrão.
Após a incorporação das variáveis no 2 PC_ 4, foi incorporado as invariantes (passo I2).
Para tanto, foram copiadas as invariantes da especificação padrão e do refinamento padrão, do unicast síncrono (Seção 3.2).
A seguir, foram realizadas as trocas necessárias para adequação das invariantes no refinamento, com isso resultando nas invariantes apresentadas na Figura 4.27.
Em o passo I3, foram incorporados os eventos multicastlider, processosrecebemmsg e removemsg_ votacão, ou seja, os eventos não combinados.
Para incorporação, deste tipo de evento, foi copiado os eventos sem nenhum modificação nas guardas ou ações.
Portanto os eventos multicastlider, processosrecebemmsg e removemsg_ votacão, do refinamento do 2 PC_ 4, tratam- se dos mesmo eventos descritos anteriormente no 2 PC_ 3.
A incorporação dos eventos combiandos, foi realizada evento a evento.
O primeiro evento incorporado foi o initialisation.
Para este evento foram copiadas as ações do evento initialisation do refinamento padrão (Seção 3.2) e adicionadas as variáveis extras do evento initialisation do 2 PC_ 3.
Por fim realizado as mudanças nas ações do evento, afim de adequar as mesmas ao refinamento As ações do evento de inicialização são apresentadas na Figura 4.28.
Em o evento processovotacão, inicialmente foi incorporado sua guarda ao refinamento do 2 PC_ 4.
Para incorporação da guardas, foram copiadas as guardas do evento sender, do refinamento padrão, do padrão unicast síncrono (Seção 3.2) e adicionadas as guardas extras encontradas no passo V2 do evento processovotacao.
Logo após foi realizado as modificações necessárias nas guardas, para adequar as mesmas ao refinamento 2 PC_ 4.
Desta forma, ficando as guardas do evento processovotacão de acordo com a Figura 4.29.
Para incorporação das ações, do evento processovotacão, foram copiadas as ações do evento sender do refinamento padrão, do padrão unicast síncrono e adicionadas as ações extras do processovotacao.
Igualmente as guardas, as ações foram adaptadas a realidade do 2 PC_ 4.
As ações do processovotacão no 2 PC_ 4 podem ser visualizada na Figura 4.30.
Para incorporação das ações evento liderrecebe foram realizadas as seguintes ações:
Adicionadas as guardas do evento receiver do refinamento padrão, do padrão unicast síncrono;
Adicionadas as ações extras do evento liderrecebe;
Realizadas as modificações necessárias nas ações.
Terminada a incorporação do padrão unicast síncrono no two phase commit, nota- se que, no canal introduzido no refinamento anterior (2 PC_ 3), a votação dos processos participantes para o líder passou a ser realizada de modo síncrono.
Assim, quando um participante está votando, outro processo não pode realizar a votação até que o líder seja desbloqueado.
Em este momento o modelo contém comunicação ordenada nos dois sentidos.
O líder se comunica, através de mensagens multicast assíncronas de ordem FIFO, com os processos participantes e os processos participantes mandam seus votos de modo unicast síncrono para o líder.
A partir de o 2 PC_ 4 foi gerado um novo refinamento para adicionar as características de decisão do líder.
Finalmente, com toda a estrutura de canais de comunicação, pode- se refinar a máquina anterior e introduzir a decisão do coordenador com base nos votos dos participantes.
Os processos participantes devem respeitar a decisão do líder e mudar seu estado para abort ou commit.
Para tanto, foi adicionado restrições nas guardas dos eventos de recepção das mensagens enviadas por o líder, de modo que, os processos participantes realizem a decisão do líder.
Dada a modelagem do two phase commit, nota- se que até o terceiro refinamento, como não existia uma comunicação confiável entre os processos participantes e o líder, não era possível garantir que o líder chegava a uma decisão.
Com isso era inviável introduzir estruturas comportamentais e provas relacionadas as possíveis decisões do líder no modelo (abort ou commit), dado que a decisão do líder é baseada nos votos dos processos participantes.
Em o quarto refinamento, entretando, foi possível introduzir as caracerísticas comportamentais da votação dos processos no modelo.
Este trabalho abordou a utilização do formalismo Event-B, para especificação de sistemas distribuídos, de forma a garantir, já em fases iniciais de modelagem, que as propriedades desejadas do sistema sejam preservadas.
Em a realização da modelagem dos sistemas distribuídos em Event-B, notou- se a possibilidade de classificar as diversas semânticas de comunicação conforme restrições do não determinísmo, nas possíveis computações permitidas, em termos de troca de mensagens.
Desta forma, viabilizou- se a construção da biblioteca de padrões de comunicação para mecanismo de trocas de mensagens.
A biblioteca permite o reuso das semânticas, e portanto, o reuso das provas.
Com isso, este trabalho se diferência dos citados na Seção 2.4, por não se tratar de um sistema específico modelado em Event-B, mas de uma biblioteca de padrões de especificação, que suportam diversas semânticas de comunicação por troca de mensagem.
Portanto a contribuição aqui feita apresenta um conjunto abrangente de padrões para diversas semânticas de comunicação possíveis.
A aplicação dos padrões da biblioteca é facilitada, dado o fator que os padrões são modelados em dois níveis:
Modelo abstrato (especificação padrão) usado para combinação com o modelo alvo;
Modelo concreto (refinamento padrão) usado para incorporar as características distribuídas no modelo alvo.
Os padrões contidos na biblioteca de padrões, livram o desenvolvedor de se preocupar com a comunicação na modelagem de sistemas distribuídos em Event-B. Fato que foi demostrado neste trabalho, através da aplicação de dois padrões da biblioteca num sistema distribuído o two phase commit.
Para aplicação do padrão, apenas foi necessário se preocupar com as estruturas mínimas necessárias para combinação.
Além disso, o conceito de refinamento, existente em Event-B, permitiu que os padrões fossem aplicados em passos de refinamento, portanto a cada passo agregando canais em diferentes sentidos, como novas características, tanto de comunicação através da incorporação do padrão, como características de comportamento do two phase commit.
Para modelagem dos sistemas distribuídos e dos padrões da biblioteca, em Event-B, foi utilizado a plataforma RODIN.
A plataforma proporcionou uma interação amigável com o processo de provas inerente ao método.
Em a modelagem dos sistemas, grande parte das obrigações de provas, necessárias para garantir a corretude dos sistemas em Event-B, eram descartadas automaticamente, dando um rápido feed back sobre a corretude dos sistemas.
Entretanto, alguns casos foram necessárias a interação para realização das provas.
No entanto, percebeu- se que na contrução de propriedades mais elaboras ou grandes quantidades de características adiciondas num nível, algumas provas não são satisfeitas por a ferramenta.
Desta forma, tornando- se árdua a utilização dos teoremas para usuários sem conhecimentos avançados sobre as obrigações de prova e estratégias de prova dos provadores.
Como trabalhos futuros, pretende-se:·
adicionar nos padrões da biblioteca mais propriedades representando o comportamento das semânticas de comunicação modeladas.·
introduzir novos padrões, na biblioteca de padrões, de forma a abranger uma maior quantidade de semânticas de comunicação.·
criar uma biblioteca com especificação de mecanismos de tolerância a falhas modelados em Event-B.
