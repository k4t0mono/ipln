O uso de processos de desenvolvimento de software nas organizações de Ti tem se tornado cada vez mais comum.
Um dos motivos é que a qualidade do produto de software está relacionada com a qualidade do processo utilizado na sua construção.
Em esse contexto, o interesse das organizações é estabelecer um ou mais processos de desenvolvimento de software bem definidos;
Adaptando- os, quando necessário, para atender metas específicas dos projetos de software.
Contudo, devido a a grande quantidade de elementos e relacionamentos que um processo de desenvolvimento de software possui, as atividades de definição e adaptação de processos são tarefas não triviais.
Quando alguns cuidados não são tomados, inconsistências podem ser facilmente introduzidas num processo de desenvolvimento de software, fato que pode, muitas vezes, ocasionar a geração de um processo inadequado que acarretará em erros durante a execução de um projeto de software.
Considerando a necessidade de evitar inconsistências num processo de desenvolvimento de software, esta pesquisa propõe uma infraestrutura que viabiliza a definição e adaptação dos processos de desenvolvimento de software consistentes baseados no metamodelo SPEM 2.
0. A infraestrutura definida é composta por uma extensão ao metamodelo SPEM 2.
0, um conjunto de regras de boa-formação para consistência dos processos de desenvolvimento de software e um protótipo de ferramenta que auxilia o uso do metamodelo proposto e das regras de boa-formação.
Palavras chave:
Consistência, processo de desenvolvimento de software, definição de processos, adaptação de processos, metamodelo SPEM 2.
0 Ao longo de os últimos anos, o software tem conquistado um papel essencial e crítico em nossa sociedade, uma vez que a dependência por produtos e serviços oferecidos através de sistemas de computador, é cada vez mais comum.
Em esse sentido, a indústria do software está passando por um acentuado crescimento, impulsionado por as exigências do mercado, no sentido de desenvolverem seus produtos de software em prazos e custos determinados, obedecendo a padrões de qualidade.
Para auxiliar as organizações de Tecnologia da Informação -- Ti a atingirem níveis mais elevados de qualidade em seus produtos de software, satisfazendo prazos e custos, encontram- se os processos de desenvolvimento de software (ou simplesmente processos de software), que são a principal base para melhorar a produtividade das equipes de desenvolvimento, com vistas a a qualidade dos produtos de software desenvolvidos.
Com base nesse contexto, o interesse das organizações de Ti é definir um ou mais processos de software, adaptando- os, quando necessário, para atender metas específicas dos projetos de software.
Definir um processo de software consiste em escolher um conjunto de elementos tais como tarefas, produtos de trabalho e papéis, combinando e organizando estes elementos em fluxos de trabalho para a construção ou manutenção de um produto de software.
Já a adaptação desse processo envolve adicionar, excluir e/ ou modificar alguns de seus elementos e relacionamentos com o objetivo de tornar- lo mais apropriado para o alcance das metas de um projeto de software específico.
Dada a complexidade de um processo de software, decorrente da sua elevada quantidade de elementos e relacionamentos, ambas as atividades de definição e adaptação de processos não são triviais.
Alguns cuidados devem ser tomados durante estas atividades, principalmente para evitar a incidência de inconsistências nos processos de software.
De acordo com Harmsen, uma inconsistência num processo de software é representada por um conjunto de informações incompletas e/ ou incoerentes nos seus elementos e relacionamentos, e, quando não identificada previamente, esta inconsistência é reproduzida na execução dos projetos de software, o que pode ocasionar o seu insucesso.
Em a literatura, soluções têm sido propostas para a identificação de inconsistências em processos de software.
Em geral, o foco tem sido a definição de um conjunto de estudos que tratam da consistência de apenas alguns aspectos e/ ou elementos de um processo de software, como por exemplo, da consistência referente a o sequenciamento de tarefas.
Diante de isso, constata- se como uma lacuna para área de pesquisa sobre processos de software, a falta de estudos mais completos sobre a consistência desses processos durante suas atividades de definição e adaptação.
Entende- se por mais completos estudos que considerem os principais elementos de um processo de software e que definam soluções para o tratamento da consistência em ambas as atividades de definição e adaptação de processos.
Segundo a OMG e, os principais elementos de um processo de software são Atividades, Tarefas, Papéis e Produtos de Trabalho.
Baseado no exposto acima, esta tese tem como o foco estudar todos os aspectos de consistência de um processo de software considerando seus principais elementos e relacionamentos nas suas atividades de definição e adaptação.
Durante a condução desse estudo, o metamodelo SPEM 2.
0 será utilizado como referência e como resultado de pesquisa será apresentada uma infraestrutura que viabiliza a definição e adaptação de processos de sofware consistentes.
A infraestrutura definida será composta por uma extensão ao metamodelo SPEM 2.
0, um conjunto de regras de boa-formação para consistência dos processos de software e um protótipo de ferramenta que auxilia o uso do metamodelo proposto e das regras de boa-formação.
Como resultado adicional da pesquisa, será também apresentado um guia que auxilia a definição e adaptação de processos de software utilizando a infraestrututra apresentada neste trabalho.
As seções seguintes, apresentam um detalhamento sobre os objetivos, etapas de pesquisa e contribuições desta pesquisa.
O objetivo geral desta pesquisa é o desenvolvimento de uma infraestrutura que suporte a definição e adaptação de processos de software consistentes baseados no metamodelo SPEM 2.
0. Para a consecução do objetivo geral proposto pode ser desmembrado nos seguintes objetivos específicos:
Identificar um conjunto de premissas para a definição de processos de software consistentes;
Propor uma extensão ao metamodelo SPEM 2.
0 para o atendimento das premissas para a contrução de processos de software consistentes.
A extensão proposta inclui e/ ou altera alguns elementos, bem como alguns relacionamentos do metamodelo SPEM 2.
0; Propor um conjunto de regras de boa-formação para consistência que serão utilizadas nas atividades de definição e adaptação dos processos de software.
Como forma de respeitar as regras de boa-formação definidas na pesquisa será desenvolvida a análise dos impactos sobre os elementos e relacionamentos para os mecanismos de adaptação do metamodelo SPEM 2.
0; Desenvolver um guia que auxilia o uso da infraestrutura para consistência proposta nesta pesquisa.
Formalizar as regras de boa-formação para consistência em Lógica de Primeira Ordem;
Implementar um protótipo de ferramenta que automatize a infraestrutura para consistência proposta nesta pesquisa;
Avaliar a solução proposta, utilizando- se de cenários simulados que são baseados no processo OpenUP.
Uma vez apresentado os objetivos geral e específicos deste estudo, introduz- se a questão de pesquisa utilizada:
&quot;Como viabilizar a consistência dos processos de software baseados no metamodelo SPEM 2.
0 durante suas atividades de definição e adaptação?»
Embora alguns trabalhos relacionados com o objetivo desta pesquisa tenham sido encontrados na revisão teórica desenvolvida, não se tem conhecimento de que o problema apresentado tenha sido tratado da mesma maneira em outros estudos.
Desta forma, esta pesquisa se caracteriza como exploratória, sendo o principal método de pesquisa utilizado, de acordo com a classificação de Oates, projeto e criação (do inglês design and creation).
Segundo Oates, a estratégia de pesquisa projeto e criação têm como finalidade o desenvolvimento de novos produtos de Ti que podem ser construções, modelos, métodos ou instanciações.
Para este último caso, considera- se como instanciação um trabalho que demonstra que modelos, métodos, gêneros ou teorias podem ser implementados num sistema de computador.
Salienta- se que, para projetos que seguem a estratégia de projeto e criação serem considerados de fato uma pesquisa, eles devem demonstrar, segundo Oates, &quot;qualidades acadêmicas, como análise, discussão, justificação e avaliação crítica».
Em esta pesquisa os novos produtos de Ti desenvolvidos envolvem um modelo e um protótipo de ferramenta.
O modelo proposto é resultado da extensão proposta ao metamodelo SPEM 2.
0 e o protótipo de ferramenta implementa o modelo desenvolvido.
A avaliação do modelo foi realizada com o auxílio do protótipo de ferramenta desenvolvido e realizada de forma analítica, ou seja, verificando- se os resultados produzidos por o modelo em decorrência de algumas informações manipuladas em cenários simulados.
A seção a seguir apresenta as etapas que constituíram esta pesquisa:
Resumidamente, esta tese foi realizada através de quatro etapas, as quais estão representadas por a Figura 1 e são descritas a seguir:
Etapa 1: Inicialmente, para obter maior conhecimento sobre o assunto de pesquisa, realizou- se um levantamento bibliográfico e estudo do referencial teórico que permitiu aprofundar os conhecimentos sobre processos de software.
Etapa 2: Com base nos resultados da etapa 1, um estudo foi realizado sobre os processos de software Rational Unified Process ­ RUP, Object-oriented Process, Environment and Notation ­ OPEN e também sobre o metamodelo SPEM 2.
0. A partir de isto, um conjunto de premissas relacionadas com a consistência foi identificado para os processos de software que são baseados no metamodelo SPEM 2.
0. Com base nas premissas definidas, uma nova análise ao metamodelo SPEM 2.
0 foi realizada e como resultado para esta análise, identificou- se a necessidade de uma extensão a esse metamodelo.
Desta forma, ainda nesta etapa foram estudados os mecanismos de extensão para metamodelos e o mecanismo de merge1 da UML 2.
0. Etapa 3: Foi nesta etapa que se desenvolveu grande parte da infraestrutura que viabiliza a consistência dos processos de software que são definidos e adaptados a partir de o metamodelo SPEM 2.
0. Para fazer isso, uma extensão a esse metamodelo foi proposta envolvendo os seguintes passos:
Alteração e/ ou inclusão de alguns elementos e relacionamentos;
Inclusão de um conjunto de regras de boa-formação que visam atender as premissas desta pesquisa para consistência dos processos de software e que devem ser utilizadas nas atividades de definição e adaptação de processsos;
E alteração das semânticas de alguns mecanismos de adaptação do metamodelo SPEM 2.
0 com a proposição de uma análise de impacto para os elementos e relaciomentos desse metamodelo, quando operações de adaptação são conduzidas.
Em adição, na etapa 3, todo o conjunto de regras de boa-formação foi formalizada em Lógica de Primeira Ordem e o guia que auxilia o uso da infraestrutura para consistência foi definido.
Também foi nesta etapa que foi conduzida uma revisão sistemática sobre o tratamento da consistência dos processos de software para suas atividades de definição e adaptação.
O objetivo da revisão foi acompanhar o estado da arte sobre os trabalhos relacionados com esta pesquisa.
Explicado na Seção 2.6.1.3 deste trabalho.
Etapa 4: A etapa final desta pesquisa constituiu- se da construção do protótipo de ferramenta e da avaliação do metamodelo e regras de boa-formação definidos nesta pesquisa.
O protótipo desenvolvido oferece suporte automatizado para definição e adaptação de processos de software.
As contribuições desta tese para a área de Engenharia de Software estão relacionadas principalmente com o desenvolvimento de uma infraestrutura que suporte a definição e adaptação de processos de software consistentes baseados no metamodelo SPEM 2.
0, o qual é tido hoje por a OMG como principal referência na área de processos de software.
A infraestrutura proposta abrange os principais elementos e relacionamentos de um processo de software e aborda aspectos de sua consistência tanto para as atividades de definição quanto para as atividades de adaptação.
Desta forma, indica- se uma contribuição para o estado da arte nos estudos sobre a consistência dos processos de software.
Os produtos que integram a infraestrutura para consistência também são considerados como contribuições específicas desta pesquisa e são:
Extensão ao Metamodelo SPEM 2.
0 que inclui e/ ou altera alguns elementos, bem como alguns relacionamentos do metamodelo SPEM 2.
0. A principal contribuição do metamodelo proposto é a redefinição de alguns relacionamentos do metamodelo SPEM 2.
0 que geram inconsistências para os processos de software.
Conjunto de regras de boa-formação para consistência que são utilizadas nas atividades de definição e adaptação dos processos de software.
A principal contribuição das regras é guiar a construção (através das atividades de definição e adaptação) de processos de software consistentes.
Pode- se apontar também como uma contribuição a análise de impacto definida para os mecanismos de adaptação do metamodelo SPEM 2.
0 que permite identificar todos os elementos e relacionamentos afetados durante as operações de adaptação realizadas sobre um processo de software.
A principal contribuição da análise de impacto proposta é garantir que as dependências de um processo de software serão respeitadas durante uma operação de adaptação, evitando assim, que inconsistências sejam geradas no processo resultante.
Protótipo de ferramenta que implementa:
A extensão do metamodelo proposta nesta pesquisa incluindo o conjunto total de regras de boa-formação para consistência de processos (definição e adaptação dos processos);
mecanismo de funcionamento do repositório de conteúdos do metamodelo SPEM 2.
0; visões gráficas para um processo de software;
análise de impacto para os mecanismos de adaptação;
E um mecanismo para verificação de processos de software.
A principal contribuição do protótipo de ferramenta desenvolvido é auxiliar o uso e avaliação da infraestrutura de consistência proposta nesta pesquisa.
Além disso, o suporte automatizado para esta infraestrutura é considerado de alta importância, uma vez que, como mencionado acima, a quantidade e complexidade de informações envolvidas num processo de software construído a partir de a extensão proposta ao metamodelo SPEM 2.
0 é elevada.
Além de as contribuições específicas dos produtos que integram a infraestrutura de consistência, também são definidos nesta pesquisa um conjunto de premissas para a definição de processos de software consistentes e um guia para definição e adaptação dos processos de software.
O guia elaborado especifica um fluxo de atividades a ser seguido para a definição e adaptação de processos utilizando a infraestrututra apresentada neste trabalho.
A contribuição mais expressiva deste guia é facilitar o uso da solução aqui proposta, uma vez que devido a grande quantidade de elementos, relacionamentos e regras de boa-formação da extensão definida para o metamodelo SPEM 2.
0, seu uso se torna uma tarefa não trivial.
Este documento está organizado da seguinte forma:
O capítulo 2 apresenta a base teórica da área e descreve o funcionamento do metamodelo SPEM 2.
0; o capítulo 3 discorre sobre o aspecto da consistência em processos de software e apresenta o estado da arte sobre este assunto;
O capítulo 4 descreve a extensão proposta ao metamodelo SPEM 2.
0; o capítulo 5 descreve o guia para definição e adaptação de processos definidos nesta pesquisa;
O capítulo 6 apresenta a formalização das regras de boaformação;
O capítulo 7 apresenta a avaliação da solução proposta nesta pesquisa baseado em cenários de uso;
E, por fim, no capítulo 8 são apresentadas as considerações finais seguidas das referências bibliográficas.
Este capítulo descreve a introdução à área de estudo e também traz alguns conceitos utilizados no contexto desta pesquisa.
Metamodelo SPEM 2.
0 é apresentado.
Em seguida, um detalhamento do Em o contexto da computação, um processo é uma tarefa em execução inserida num dispositivo computacional.
No entanto, não existe um consenso entre os autores no tocante a definição de um processo de software.
Adicionalmente, existem também diferenças na nomenclatura utilizada para o termo na área de pesquisa, já que alguns autores utilizam como sinônimo para processo de software os termos método ou metodologia.
Segundo Jacobson, um processo de software é o conjunto completo de atividades necessárias para transformar requisitos de usuários em produtos de software.
Como as organizações geralmente consideram o desenvolvimento de um produto de software como um projeto, então, um processo pode ser considerado como uma seqüência de passos que um projeto pode seguir para desempenhar alguma tarefa.
Para, um processo de software é um conjunto de atividades e resultados associados que levam ao desenvolvimento de um produto de software.
Ainda, segundo Fuggetta, o processo de software pode ser definido como um conjunto coerente de políticas, estruturas organizacionais, tecnologias, procedimentos e produtos de trabalho que são necessários para compreender, desenvolver e manter um produto de software.
Com relação a os estudos que utilizam o termo método ou metodologia, apresentam- se, e.
De acordo com Perez e Sellers, uma metodologia é a especificação do processo a ser seguido, dos produtos de trabalho a serem gerados, das pessoas e das ferramentas envolvidas durante um esforço de desenvolvimento de software.
Para Sellers, uma metodologia (ou método) inclui aspectos de processo e descrições dos produtos de trabalho que serão gerados na construção e/ ou manutenção de um produto de software.
De acordo com Kornyshova, por sua vez, uma metodologia é um conjunto de idéias, abordagens, técnicas e ferramentas usadas por analistas de sistemas para a construção e/ ou manutenção de um produto de software.
Através do exposto acima, pode- se observar que, embora existam vários termos e definições na presente área de pesquisa, não existem diferenças significativas para os conceitos apresentados.
Assim, deste ponto em diante, assume- se, nesta pesquisa, os termos processo de software, metodologia e método como sinônimos.
Ainda no contexto da solução apresentada neste estudo, o termo processo de software será utilizado.
Faz- se necessário também definir, neste ponto, os termos utilizados no presente estudo para os principais elementos de um processo de software.
Isso porque, mediante a existência de vários processos de software na literatura, nem sempre o nome dos elementos são os mesmos, sendo comum termos diferentes terem o mesmo significado.
Em esta pesquisa, assume- se a utilização dos termos apresentados no metamodelo SPEM, na sua versão 2.0, que são Atividade, Artefato, Papel e Tarefa.
Contudo, como outros processos de software são utilizados em alguns pontos deste trabalho, a Tabela 1 apresenta a correlação entre os termos utilizados nos processos RUP, OPEN e OpenUP com os termos do metamodelo SPEM 2.
0. Durante a descrição dos trabalhos relacionados e definições da literatura apresentadas no texto que segue, correlações entre a nomenclatura original dos estudos e a terminologia utilizada nessa pesquisa, também serão realizadas.&amp;&amp;&amp;
Em a literatura, muitos estudos indicam que o estabelecimento de um ou mais processos de software nas organizações de Ti tem se tornado cada vez mais comum.
Um dos motivos disso é que existem fortes indícios que a qualidade do produto de software está relacionada com a qualidade do processo utilizado na sua construção.
Desta forma, o interesse das organizações de Ti é estabelecer um ou mais processos de software bem definidos buscando atender metas específicas de seus projetos de software.
Além de o interesse por o aumento da qualidade dos produtos de software, outro aspecto a ser considerado é que a adoção de um processo de software torna- se ainda mais importante para organizações de Ti que desejam implantar um modelo de qualidade como as normas Iso/ IEC 15504, Iso/ IEC 12007 ou Capability Maturity Model Integration (CMMI).
Isso porque tais modelos possuem seus esforços centrados na definição e uso de processos de software e na constante melhoria destes processos.
Em esse sentido, estabelecer um processo de software é uma tarefa não trivial.
Basicamente, isto envolve as seguintes atividades:
Definição de um processo de software (em inglês process modeling);
Adaptação do processo de software (em inglês process tailoring);
E execução do processo de software (em inglês enactment).
Tais atividades ocorrem em instantes diferentes e constituem o ciclo de vida básico de um processo de software, conforme mostrado na Figura 2.
Em a Figura 2, no instante 0 e 3, em tom mais claro, está a atividade de definição de um processo de software.
As entradas para esta atividade, no instante 0, são as características de desenvolvimento da organização, das políticas e de outros fatores tais como se a organização pretende atingir algum nível de maturidade em determinado modelo de qualidade.
A saída para essa atividade é a definição de um ou mais processos de software para a organização.
Em seguida, o instante 1, em tom de cinza intermediário, representa a atividade de adaptação de um processo para um projeto específico.
Em esse momento, além de as entradas já consideradas para o instante de definição de processos, somam- se as entradas específicas de cada projeto de software, tais como características do projeto, ferramentas disponíveis, características da equipe e do ciclo de vida selecionado para o projeto.
Logo, a saída desta atividade é a especificação de um processo adequado ao projeto de software, comumente chamado de processo específico do projeto.
Por fim, em tom mais escuro está o instante 2, que representa a atividade de execução do processo de software.
Em esse momento, os recursos são selecionados e associados ao processo específico do projeto.
As saídas desta atividade são os resultados do projeto relativos ao processo de software executado (por exemplo, lições aprendidas) e possíveis ações corretivas.
A Figura 2 exibe também que a saída do instante de execução pode ser entrada para uma nova atividade de definição do processo de software, o que caracteriza o instante 3 do ciclo de vida do processo.
Isso ocorre, porque melhorias podem ser realizadas, a qualquer momento, num processo de software.
Em verdade, todo processo de software precisa ser monitorado na execução dos projetos de software para que possíveis falhas não ocorram.
A importância da constante melhoria de um processo de software pode ser possivelmente notada por a quantidade de trabalhos disponíveis na literatura especializada, a qual é chamada de Melhoria de Processos de Software (em inglês Software Process Improvement ­ SPI).
Em a seção seguinte, cada uma das atividades do ciclo de vida de um processo de software será apresentada.
Como o foco desta pesquisa concentra- se nas atividades de definição e adaptação de processos de software, estas serão as atividade mais detalhadas.
Torna- se importante também ressaltar que os aspectos relacionados com a melhoria dos processos de software não serão tratados nesta pesquisa.
O primeiro passo para a definição de um processo de software é a especificação de suas informações.
Isto envolve escolher um conjunto de elementos tais como atividades, tarefas, produtos de trabalho e papéis, combinando e organizando estes elementos em fluxos de trabalho para a construção ou manutenção de um produto de software.
Em esse estágio, deve- se considerar as tecnologias utilizadas por a organização onde o processo será utilizado, os tipos de software desenvolvidos, o domínio de aplicação, o grau de maturidade (ou capacitação) da equipe em engenharia de software, as características próprias da organização e as características dos projetos e das equipes, e.
Tipicamente, para definir um processo de software as organizações de Ti podem se utilizar de processos off- the- shelf, tais como RUP e OPEN, os quais estão disponíveis na literatura e especificam as melhores práticas de engenharia de software.
Os referidos processos podem ser adotados por completo, ou podem ainda, ser adaptados de acordo com as características da organização.
Faz- se possível, também, que uma organização baseie- se em mais de um desses processos mencionados para especificação de seu ou, ainda, que especifique seu processo próprio, através de consultorias ou de um grupo de processos de software interno.
Independente da estratégia escolhida para a definição do processo, além de a especificação de suas informações, torna- se necessário também a sua modelagem.
Modelar um processo de software consiste em representar as informações deste, utilizando alguma linguagem de modelagem de processos.
Uma linguagem de modelagem de processos (em inglês Process Modeling Language ­ PML) tem como objetivo apoiar a representação de diversos conceitos que caracterizam um processo de software.
Atualmente, uma grande quantidade de linguagens de modelagem de processos está disponível na literatura, mas, nos últimos anos, numa tentativa de padronização destas linguagens muitos pesquisadores e profissionais da área têm adotado o uso da UML como PML.
Já em 1999, Franch e Ribó definiram a UML como uma linguagem emergente que havia despertado um grande interesse por parte de a indústria e academia e estava se tornando, de fato, um padrão na área da modelagem de processos.
Em esse sentido, a popularização da UML, como linguagem para modelagem de processos, deve- se principalmente ao fato de importantes processos terem sido modelados, utilizando essa linguagem.
Esse é o caso, por exemplo, dos processos RUP e OPEN, os quais possuem metamodelos de processos representados com diagramas de classe da UML e.
Outro fato que contribuiu para o aumento do uso da UML como PML foi a definição do metamodelo de processos SPEM e.
Este metamodelo, que teve sua primeira versão publicada em 2002, encontra- se hoje na versão 2.0 e, como já dito anteriormente, é tido como referência para a definição de processos de software.
Uma vez que o metamodelo SPEM 2.
0 será utilizado nesta pesquisa para a modelagem de processos de software, a Seção 2.6 abordará alguns conceitos sobre metamodelagem e detalhará o metamodelo SPEM 2.
0. Seguindo com o entendimento acerca de a atividade de definição dos processos de software, é importante considerar que, torna- se também necessário determinar a forma como isso será feito numa organização de Ti.
Tipicamente, organizações podem optar por definir apenas um processo de software (conhecido como processo padrão de desenvolvimento de software) que servirá como base para todos os projetos ou podem ainda seguir a abordagem proposta por a área de pesquisa denominada Engenharia de Método (em inglês Method Engineering).
Em esta área, os autores estabelecem a criação dos processos de software a partir de um repositório de fragmentos de processo e fragmentos de produto.
Cada um destes fragmentos é responsável por descrever somente uma parte do processo de software.
Um processo padrão de desenvolvimento de software é o processo que deve servir como referência para guiar a execução de todos os projetos de software dentro de uma organização.
De acordo com Ginsberg e Quinn, este é o meio por o qual a organização expressa os requisitos que todos os processos de software dos projetos devem atender.
Assim sendo, a implantação de um processo padrão apresenta vantagens, como:
Redução dos problemas relacionados a treinamento, revisões e suporte de ferramentas;
Maior facilidade em medições de processo e qualidade;
Maior facilidade de comunicação entre os membros da equipe;
Melhor desempenho, previsibilidade e confiabilidade dos processos de trabalho.
Além de as vantagens acima, outro incentivo para definição de um processo padrão é que este é um dos requisitos essenciais para obtenção de alguns níveis de maturidade de importantes modelos de qualidade tais como Iso/ IEC 15504 e CMMI.
Segundo Borges e Falbo, esses modelos definem um processo padrão como um ponto base a partir de o qual um processo especializado poderá ser obtido de acordo com as características de um projeto de software específico.
Em esse sentido, um cenário bastante comum nas organizações de Ti que utilizam um processo padrão é a utilização de processos já estabelecidos e difundidos na literatura (processos off- the- shelf).
Como já mencionado anteriormente, essas organizações, muitas vezes adotam tais processos por completo ou fazem adaptações de acordo com suas características de desenvolvimento.
A principal abordagem da área de engenharia de método é a decomposição de um processo de software em partes modulares conhecidas na bibliografia especializada, como fragmentos ou chunks de método (em alguns artigos chamados de fragmentos ou chunks de processo).
De acordo com Sellers, esses fragmentos ou chunks ficam armazenados num repositório e são disponibilizados para serem selecionados durante a criação de qualquer processo de software.
O termo fragmento de método (ou fragmento de processo) foi introduzido nos estudos da área por Harmsen Em.
Os autores definiram um fragmento de método como uma descrição de um método de engenharia ou qualquer parte coerente deste método.
Um fragmento de método é classificado em dois tipos e:
Os fragmentos de processo e os fragmentos de produto.
Os fragmentos de processo descrevem as ações do processo de software e podem ser representados por as atividades e tarefas.
Já os fragmentos de produto representam as estruturas dos produtos de trabalho de um processo de software.
Deliverables, diagramas e modelos constituem exemplos de fragmentos de produto.
Analogamente aos fragmentos de método, alguns autores, em seus respectivos estudos, e, definiram o termo chunk de método (ou chunk de processo).
Um chunk de método é uma combinação de uma parte processo (também chamada de guideline) com uma parte produto.
A grande diferença para os fragmentos de método é que um chunk de método apresenta um forte acoplamento entre produto e processo.
De acordo com Sellers, a ligação entre produto e processo do chunk de método é uma abstração de todos os tipos de ligação (produção, modificação, etc) que a parte processo realiza sobre a parte produto de um processo de software.
Usualmente, ambos (fragmentos e chunks de métodos) são modelados utilizando um metamodelo.
Muitos trabalhos, como, e, propõem soluções para esta modelagem, e há também alguns autores que utilizam o metamodelo SPEM 2.
0 para modelagem de fragmentos e chunks de métodos.
Os tópicos de pesquisa em engenharia de método são muitos, entre eles, existem estudos que referenciam como os processos devem ser estruturados numa organização de Ti.
Alguns trabalhos, e propõem a definição de um processo de software para cada projeto da organização.
A ideia é a de que, através das técnicas para recuperação de fragmentos e chunks a partir de o repositório, apenas sejam selecionados os fragmentos e chunks de método necessários a um projeto.
Em essa abordagem, todo projeto inicia com uma etapa de definição de processo em que os fragmentos ou chunks de método são selecionados e organizados para atender às necessidades específicas do projeto em questão.
Outros autores propõem uma abordagem similar à já apresentada sobre processo padrão.
Para isso, esses pesquisadores definem que um processo base deve ser estabelecido, através dos fragmentos e chunks, e tem de estar disponível para ser utilizado em todos os projetos de software.
Não existe um processo de software que possa ser genericamente aplicado e.
Em esse sentido, conforme os estudos, e, o mesmo processo de software não pode servir a qualquer tipo de projeto.
De essa maneira, questões relacionadas ao porte da empresa e à cultura organizacional, aos objetivos de projetos específicos, aos recursos disponíveis, às tecnologias, ao conhecimento e à experiência da equipe impõem características aos processos.
Hoje em dia, é mundialmente aceito que um processo de software deve sofrer adaptações para atender as necessidades específicas no contexto dos projetos.
Isso porque cada projeto é único em termos de domínio de negócio, requisitos de cliente, tecnologia, entre outros.
Adaptar consiste em excluir, modificar ou adicionar novos elementos e/ ou relacionamentos a um processo de software.
De acordo com os estudos, essa atividade deve gerar um processo de software específico para o projeto cada vez que for executada.
Ainda, de acordo com Kellner e Yoon, a atividade de adaptação também pode ser considerada como uma atividade de reuso de processos.
Devido a importância da adaptação dos processos de software muitos estudos estão disponíveis na literatura.
Tanto autores que propõem o uso de um processo padrão nas organizações quanto os autores que utilizam a abordagem de criação de processos para cada projeto por a seleção de fragmentos e chunks de método são unânimes em estabelecer mecanismos de adaptação para os processos de software, visando atender as necessidades específicas de cada projeto.
Quando um processo padrão é estabelecido, o mecanismo de adaptar um processo é comumente conhecido na literatura como Process Tailoring, e.
Especificamente, sobre este assunto é trivial encontrar estudos na literatura que apresentam mecanismos de adaptação para processos off- the- shelf, tais como as pesquisas de, e que se baseiam no processo RUP.
Os estudos que relacionam os mecanismos de adaptação e o uso de fragmentos ou chunks de processo fazem parte de uma subárea da engenharia de método chamada engenharia de método situacional (em inglês Situational Method Engineering -- SME).
O principal objetivo em SME é a construção de métodos modulares que representem uma coleção de fragmentos ou chunks de método que se interconectem.
Segundo Mirbel e Ralyté, graças a essa modularidade, os métodos são mais flexíveis e adaptáveis, pois permitem que fragmentos ou chunks de métodos sejam adicionados e/ ou removidos para cada projeto de software.
Dentro de a subárea da engenharia de método, como já mencionado na seção anterior deste estudo, há autores que defendem o uso de um processo base (processo padrão) como ponto de partida para a criação de um processo específico de projeto, e.
Em esses estudos, a adaptação de processos é conhecida também como Process Tailoring ou ainda como Method Configuration.
Com relação a isso, cabe destacar que a adaptação de processos é considerada um mecanismo tão importante que os modelos de qualidade Iso/ IEC 15504, Iso/ IEC 12007 e CMMI também referenciam essa atividade como um requisito para as organizações de software.
Além disso, vários processos de software, tais como o RUP, OPEN, OpenUP, assim como metamodelos de processo tais como, OPF e SPEM 2.
0, também referenciam as atividades de adaptação.
Basicamente, o que fica estabelecido em tais processos e metamodelos é a possibilidade de exclusão de elementos não requeridos, inclusão de elementos requeridos e modificação de elementos existentes para um projeto em particular.
A execução de processos de software é a atividade do ciclo de vida de processos de software em a qual as tarefas modeladas são realizadas tanto por os desenvolvedores (quando demandam agentes humanos) quanto automaticamente (quando demandam a invocação de ferramentas autônomas).
Portanto, essa atividade envolve questões importantes acerca de planejamento, controle, monitoração, garantia de conformidade com o processo modelado, treinamento, segurança e recuperação do processo.
De acordo com Lee, um metamodelo é um modelo que serve para modelar um outro modelo conceitual, ou seja, é uma forma de descrever como um modelo deve ser modelado.
De essa forma, um metamodelo também pode ser utilizado para modelar metadados, assim como, por exemplo, configuração de um software ou os metadados dos requisitos.
Em o contexto da definição e adaptação dos processos de software os metamodelos possuem um papel essencial.
Isto porque processos construídos a partir de um metamodelo, geralmente, oferecem um alto grau de formalismo e melhor suporte para consistência e customização, uma vez que os conceitos que formam sua base são explicitamente definidos.
Segundo Perez e Sellers, essa é a maneira de formalizar as ideias e conceitos subjacentes de um processo de software que são importantes para sua checagem de consistência e, também, para possíveis extensões e/ ou modificações do processo.
De acordo com Hug, um metamodelo torna- se necessário para a definição e adaptação dos processos de software por o fato destes processos serem basicamente formados por conceitos, regras e relacionamentos.
Ainda, um metamodelo de processo é necessário para definição de regras que garantam a integridade entre os elementos e relacionamentos num processo de software, tanto na atividade de definição quanto durante as atividades de adaptação.
O uso de metamodelos também possibita o suporte automatizado para os processos de software, o que é considerado de alta importância devido a a quantidade e complexidade de informações envolvidas num processo de software.
Em esta pesquisa, o metamodelo SPEM 2.
0 é utilizado para as atividades de definição e adaptação de processos de software.
As próximas seções deste trabalho descrevem a organização do metamodelo SPEM 2.
0 em pacotes, detalham o conteúdo de cada pacote e apresentam os mecanimos de adaptação propostos nesse metamodelo.
Através da Figura 3 é possível também observar que a definição de qualquer metamodelo de processo de software que se origina do SPEM 2.
0 encontraria- se- no nível M2, bem como que os modelos de processo derivados a partir desses metamodelos estariam no nível M1.
Assim, por exemplo, a inclusão dos metamodelos do processo RUP ou do processo OPEN na Figura 3, os quais possuem elementos que podem ser facilmente relacionados com os elementos do SPEM 2.
0, seria realizada no nível M2.
Já os modelos desses processos ficariam no nível M1.
O SPEM 2.
0 separa a engenharia dos processos de desenvolvimento de software em dois momentos principais:
A criação de um repositório de conteúdo do processo (Method Content) e a utilização deste conteúdo (Process Structure) num processo de desenvolvimento de software.
Method content é tudo aquilo que provê explicações passoa-passo, descrevendo como os objetivos de um processo de desenvolvimento de software serão alcançados, independente do ciclo de desenvolvimento.
Já o Process Structure contém os elementos que permitem a definição dos processos de software e também definem os mecanismos que possibilitam o uso dos elementos definidos no Method Content nestes processos.
A Figura 4 fornece uma visão de como os conceitos definidos no SPEM 2.
0 são posicionados para representar o conteúdo do processo (Method Content) e sua utilização (Process Structure).
O Method Content é representado no lado esquerdo da Figura 4 e é formado por as definições dos Produtos de Trabalho, definições dos Papéis e definições das Tarefas.
Merge é um relacionamento entre dois pacotes onde o conteúdo do pacote de destino é combinado com o conteúdo do pacote de origem através de especializações e redefinições, quando aplicáveis.
Method Plugin -- define os conceitos necessários para criar, gerenciar e manter bibliotecas e processos de software.
A metaclasse ExtensibleElement, vista na Figura 9, é uma generalização abstrata que representa qualquer metaclasse do metamodelo SPEM 2.
0 que pode ter um valor de 'kind' atribuído, expressando, assim, uma qualificação definida por o usuário.
Cada metaclasse do metamodelo SPEM 2.
0 que permite utilizar esta qualificação deriva direta ou indiretamente da metaclasse ExtensibleElement.
A metaclasse kind que também é mostrada na Figura 9, é um especialização da metaclasse ExtensibleElement.
Esta metaclasse é usada para qualificar outras intâncias de metaclasse do metamodelo SPEM 2.
0 com tipos definidos por o usuário.
Prosseguindo com e explanação sobre as metaclasses do pacote Core, têm- se as mostradas na Figura 10.
Inicialmente, a metaclasse ParameterDirectionKind é de enumeração que representa parâmetros de entrada (in), saída (out) e também de entrada e saída (inout) para as instâncias das metaclasses e subclasses de WorkDefinition.
Esses parâmetros são definidos através do atributo direction definido para a classe WorkDefinitionParameter que é uma generalização abstrata para elementos do processo e representa os parâmetros para as metaclasses e subclasses de WorkDefinition.
Pacote Process Structure O pacote Process Structure é o pacote que define a base para todos os processos de software no metamodelo SPEM 2.
0. Em esse pacote, processos são representados por uma estrutura de Work Breakdown Element ­ WBS que permite o aninhamento de atividades dentro de outras atividades ou, ainda, o aninhamento de outros elementos dentro de uma atividade.
De esse modo, os elementos que podem ser aninhados em atividades são papéis, produtos de trabalho e também várias metaclasses que representam relacionamentos.
A Figura 11 e 12 exibem, respectivamente, a taxonomia de metaclasses do pacote Process Structure e as principais associações definidas em ele.
Em a Figura 12 as metaclasses Activity, ProcessPerformer, ProcessParameter e BreakdownElement especializam, respectivamente, as metaclasses WorkDefinition, WorkDefinitionPerformer, WorkDefinitionParameter e ExtensibleElement do pacote Core.
As metaclasses Process Element, BreakdownElement e WorkBreakdownElement são metaclasses abstratas.
Especificamente, as metaclasses BreakdownElement e WorkBreakdownElement é que permitem a representação de um processo através de uma estrutura WBS.
A ideia é que a metaclasse Activity seja utilizada para instanciar os elementos que representam unidades de trabalho nos processos tais como as atividades e também utilizadas para instanciar os elementos do processo que organizam as unidades de trabalho em definições de tempo tais como as fases, as iterações e o próprio processo.
Já os outros elementos deste pacote que são RoleUse, WorkProductUse, WorkProductUseRelationship, WorkSequence, Milestone, ProcessPerformer e ProcessResponsabilityAssignment podem ser instanciados dentro de as atividades para representar as outras informações do processo de software.
WorkProductUseRelationship estabelece WorkProductUses;
ProcessPerformer estabelece a relação entre as atividades e os papéis no processo de software;
ProcessResponsabilityAssignment estabelece a relação de responsabilidade entre os papéis e os produtos de trabalho;
ProcessParameter estabelece através do atributo direction e da metaclasse de enumeração ParameterDirectionKind os parâmetros de entrada e/ ou saída para as atividades em termos de produtos de trabalho.
Por fim, a metaclasse WorkSequence permite estabelecer sequenciamento entre as atividades utilizando o atributo linkKind e a metaclasse de enumeração WorkSequenceKind.
As relações de sequenciamento permitem estabelecer relações de dependência entre as atividades em que uma atividade depende do início ou fim de outra (s) atividade (s) para poder iniciar ou terminar.
Outros relacionamentos, não são representados por metaclasses, existem no pacote ProcessStructure.
Estes relacionamentos são o auto-relacionamento usedActivity metaclasse Activity relações suppressedBreakdownElement nestedBreakdownElement entre as metaclasses Activity e BreakdownElement.
A relação nestedBreakdownElement é a que permite o aninhamento de elementos dentro de uma atividade.
Já as relações usedActivity e suppressedBreakdownElement permitem, respectivamente, um mecanismo de reuso e supressão de elementos do processo.
Essas relações serão detalhadas na seção 2.6.1.5 deste estudo, pois, embora possam ser usadas na atividade de definição de processos, são também consideradas como mecanismos de adaptação do metamodelo SPEM 2.
0. Pacote Managed Content O pacote Managed Content define os conceitos fundamentais para gerenciar as descrições textuais para os processos (elementos do ProcessStructure) e elementos do Method Content no SPEM 2.
0. Esse pacote introduz a metaclasse abstrata DescribableElement que, através do mecanismo de merge, serve como uma super classe para elementos de processo definidos no pacote Process Structure e também para as metaclasses do pacote Method Content.
O elemento DescribableElement é composto de uma metaclasse ContentDescription que permite relacionar descrições textuais para os elementos.
A Figura 13 mostra as metaclasses e relações do pacote Managed Content.
Em a Figura 13, é possível verificar que a metaclasse DescribableElement é uma especialização da metaclasse ExtensibleElement do pacote Core.
A metaclasse DescribableElement possui uma relação de composição com a metaclasse ContentDescription que possui vários atributos relacionados com descrição textual, bem como relação de composição com uma metaclasse denominada Section.
Isso é o que permite que todas as especializações da metaclasse DescribableElement possuam descrições textuais e também que se utilizem do conceito de Seção.
Em a Figura 13, observa- se também que a metaclasse ProcessElement (definida no pacote ProcessStrucure) aparece como uma especialização da metaclasse DescribableElement.
Através dessa relação é que todos os elementos do pacote ProcessStructure podem possuir descrições textuais.
Existem também as metaclasses Guidance, Category e Metric que especializam a metaclasse DescribableElement.
A metaclasse Guidance, além de ser uma especialização de DescribableElement, possui relação com essa metaclasse.
Isso permite que guias contendo informação adicional possam ser associados a qualquer elemento DescribableElement.
As metaclasses Category e Metric, igualmente a metaclasse Guidance, também possuem relação com a metaclasse DescribableElement.
Tais metaclasses podem ser usadas, respectivamente, para categorizar os elementos DescribableElement e para associar uma ou mais restrições que fornecem medidas para qualquer elemento DescribableElement.
O pacote Method Plugin define a capacidade para gerenciar bibliotecas de Method Content e Processos.
Esse pacote endereça o interesse de estabelecer grandes bibliotecas por definir Method Plugins and Method Configurations.
Adicionalmente, o pacote Method Plugin define mecanismos de variabilidade e extensibilidade para o Method Content e Processos.
Tais mecanismos são considerados por o metamodelo SPEM 2.
0 como mecanismos de adaptação, os quais permitem que processos sejam criados sobre demanda ou adaptados de acordo com o contexto dos projetos de software.
As novas metaclasses incluídas no pacote Method Plugin são mostradas na Figura 18 que exibe a taxonomia de metaclasses para esse pacote.
Observa- se ainda que novas metaclasses são incluídas nesse metamodelo e também que há novas definições especialização.
A adaptação de processos de desenvolvimento de software é tratada em dois pacotes do metamodelo SPEM 2.
0. Em o pacote Process Structure, isso é feito, através dos seguintes relacionamentos:
UsedActivity e suppressedBreakdonwElement.
Já no pacote Method Plugin isso é definido por a metaclasse VariabilityElement e seus relacionamentos.
Inicialmente, no pacote Process Structure o auto-relacionamento definido para o elemento Activity chamado usedActivity permite o reuso do conteúdo definido para uma atividade em outra atividade.
De essa forma, torna- se possível herdar a estrutura definida para uma atividade em termos de seus elementos aninhados numa segunda atividade.
O metamodelo SPEM 2.
0 define alguns tipos de herança para o relacionamento usedActivity, os quais são estabelecidos por o atributo useKind da metaclasse Activity e por a metaclasse de enumeração ActivityUseKind.
Esses tipos de herança são:
Em a:
Este é o valor default do atributo useKind de todas as atividades.
Esse valor é usado para atividades que não instanciam a relação usedActivity.
Extension: Este mecanismo permite reutilizar, dinamicamente, as subestruturas (elementos aninhados por a relação de composição) de uma atividade em outras atividades.
De essa forma, a atividade que é associada à outra, por a relação usedActivity e possui o valor para o atributo useKind igual a extension herda todo conteúdo dessa atividade.
LocalContribution: Este mecanismo deve ser sempre utilizado em conjunto com o mecanismo de extensão (extension).
Ele permite que adições locais (contribuições) sejam feitas em atividades que estão sendo herdadas através do mecanismo de extensão.
Uma atividade A poderia, por exemplo, herdar toda estrutura da atividade B por o mecanismo de extensão (extension).
Contudo, poderia ser necessário fazer adições locais (contribuições) para a atividade A, através da relação localContribution.
Para fazer isso, devem existir subatividades dentro de as atividades A e B_ Em a subatividade de A (por exemplo, A_ 1), devem ser definidas as contribuições locais e, nesse momento, ser apontado para subatividade de B (por exemplo B_ 1).
O resultado em A_ 1 será todo conteúdo de B_ 1 somado aos elementos pré-definidos em A_ 1.
LocalReplacement: Este mecanismo deve ser sempre utilizado em conjunto com o mecanismo de extensão (extension).
Ele permite que substituições locais sejam feitas em atividades que estão sendo herdadas, através do mecanismo de extensão.
Uma atividade A poderia, por exemplo, herdar toda estrutura da atividade B por o mecanismo de extension.
Contudo, poderia ser necessário fazer substituições locais para partes da atividade A, através da relação localReplacement.
Para fazer isso, devem existir subatividades dentro de as atividades A e B_ Em a subatividade de A (por exemplo, A_ 1) deve ser definido o conteúdo local que vai substituir o conteúdo sendo herdado e, nesse momento, ser apontado para subatividade de B (por exemplo B_ 1).
O resultado em A_ 1 será seu próprio conteúdo, já que tal conteúdo foi definido para substituir o conteúdo de B_ 1.
Além de os mecanismos acima, a relação supressedBreakdownElement também é definida entre as metaclasses Activity e BreakdownElement.
De acordo com a especificação do metamodelo SPEM 2.
0, essa relação também deve ser sempre utilizada em conjunto com o mecanismo de extensão (extension).
Ela permite suprimir elementos de uma atividade após o mecanismo de extensão (extension) ter sido realizado.
Após uma atividade A, por exemplo, ter herdado todo conteúdo da atividade B, fazendo ou não contribuições e/ ou substituições locais, é possível ainda que elementos sejam suprimidos da atividade A_ Para facilitar o entendimento dos mecanismos explicados acima, a Figura 21 mostra um exemplo.
Em esta figura é mostrado que a atividade Process 2 estende a atividade Process 1 realizando algumas contribuições, substituições e supressão de elementos.
O resultado, após a interpretação das relações é mostrado na parte direita da Figura 21.
Para finalizar o entendimento sobre a aplicação dos mecanismos usedActivity, supressedBreakdownElement e Variability é importante apenas considerar que, embora estes mecanismos sejam utilizados na atividade de adaptação de um processo de software, eles podem também ser utilizados na sua atividade de definição.
Este capítulo apresentou os conceitos referentes a processos de software objetivando demonstrar a importância de seu uso para as organizações de Ti.
Inicialmente, foi apresentado o ciclo de vida básico para um processo de software e descritas em detalhe as suas atividades de definição e adaptação.
Em seguida, foi realizada uma descrição sobre o metamodelo SPEM 2.
0 que é utilizado por esta pesquisa para a definição e adaptação dos processos de software.
Após o entendimento sobre o ciclo de vida básico dos processos de software e do funcionamento do metamodelo SPEM 2.
0, o capítulo seguinte desta tese discorre sobre o aspecto da consistência nos processos de software.
Em este capítulo, será descrito o aspecto da consistência nos processos de software durante suas atividades de definição e adaptação.
Apresentarão- se- também apresentados os resultados de uma revisão sistemática, conduzida nesta pesquisa sobre como é realizado o tratamento da consistência em estudos que apresentam soluções para definição e adaptação dos processos de software.
O desenvolvimento de sistemas tem sido prejudicado por problemas de inconsistência desde seu início.
Esse é um dos motivos por o qual a verificação de inconsistências envolvendo diversos tipos de informação tem sido objeto de estudos em muitas áreas da engenharia de software.
Uma das primeiras áreas que identificaram problemas relacionados com o gerenciamento e a manutenção de inconsistências foi a de banco de dados.
Em esta área, as primeiras inconsistências detectadas foram, na sua maioria, causadas por redundância de informações, resultantes de erros em projetos de banco de dados.
Outra área que explora, há bastante tempo, o aspecto da consistência é a conhecida na literatura como Verificação de Modelos (do inglês Model Checking).
Em esta área, o interesse é a checagem de consistência entre modelos UML e é consenso, entre seus autores, que, devido a a existência dos múltiplos modelos dessa linguagem, várias inconsistências sejam introduzidas numa especificação de software,.
Sendo assim, tais inconsistências podem se constituir numa fonte de numerosos erros num produto de software, dificultando sua manutenção.
Uma prova da importância do tema consistência entre modelos UML é a quantidade de trabalhos encontrados na literatura sobre o assunto.
Em uma recente revisão sistemática conduzida por, foram analisados 44 artigos sobre este assunto, fato que levou os autores desse estudo a concluírem que esta é uma área de pesquisa altamente ativa e promissora.
Outro importante fator que prova a relevância do tema consistência entre modelos UML são as ferramentas comerciais e não comerciais que implementam funcionalidades de verificação de modelos.
Esse é caso das ferramentas comerciais IBM Rational Software Architecture e IBM Software Modeler e do plugin do eclipse Eclipse Modeling Framework ­ EMF, que é uma ferramenta não comercial.
Uma terceira área da engenharia de software que trata de aspectos de consistência é a modelagem de processos de negócio e workflows.
Em este campo de pesquisa, os autores apresentam vários estudos, propondo soluções para garantir a consistência do workflow que modela um processo de negócio, e.
Isso porque, de acordo com, um modelo de workflow que contém inconsistências pode levar à falha na execução de um processo de negócio.
Especificamente na área dos processos de software, a consistência também possui devida importância tanto nas atividades de definição e adaptação quanto na sua atividade de execução.
Logo, considerando que esta pesquisa tem foco no tratamento da consistência dos processos de software nas atividades de definição e adaptação, as próximas seções deste trabalho apresentarão, respectivamente, uma descrição sobre este assunto e o resultado de uma revisão sistemática conduzida nessa área.
Após vários estudos preliminares na literatura para identificação de pesquisas relacionadas foi realizada, nesta pesquisa, uma revisão sistemática sobre o tratamento do aspecto da consistência nos processos de software.
De acordo com kitchenham, uma revisão sistemática permite identificar, avaliar e interpretar toda a literatura relevante para uma determinada questão de pesquisa, tópico ou fenômeno de interesse.
As três principais fases de uma revisão sistemática são:
Planejamento, condução e relatório da revisão.
A fase de planejamento envolve a definição do protocolo da revisão sistemática, que apresenta o propósito da revisão e os procedimentos que serão adotados.
Durante a condução da revisão, é feita a busca por trabalhos relevantes para o objeto de estudo, a seleção das publicações e a extração dos dados de cada uma das publicações selecionadas.
Em a fase de relatório da revisão, as conclusões obtidas devem ser descritas em relatórios ou artigos.
Exemplos de revisões sistemáticas na literatura podem ser encontrados em, e.
Inicialmente, para realizar esta revisão, o protocolo (Apêndice A) definido partiu da comtemplação da seguinte questão de pesquisa:
&quot;Quais são as abordagens que apresentam soluções relacionadas com o aspecto de consistência num processo de desenvolvimento de software nas suas atividades de definição e/ ou adaptação?»
A partir de a definição desta questão de pesquisa, das &quot;strings «e fontes de busca utilizadas que estão descritas no protocolo, a revisão sistemática foi executada.
A seleção inicial dos artigos retornou um total de 212 artigos.
A partir deste resultado os seguintes procedimentos foram realizados na revisão:
Foram excluídos os artigos que não estavam no formato completo ou que não puderam ser baixados a partir de os motores de busca.
Foram lidos o título e o resumo (abstract) de cada artigo para verificar se o artigo era aprovado para revisão.
Os artigos remanescentes (aprovados) foram selecionados para leitura integral.
Em o primeiro procedimento (exclusão de artigos não completos), foram excluídos 33 artigos.
De os 179 artigos selecionados para a segunda etapa, 135 foram excluídos após a leitura de título e resumo.
De essa forma, 44 artigos foram lidos de forma integral, sendo que apenas 10 atenderam aos critérios para extração de informações (o que correspondeu a 4,7% do conjunto inicial de artigos).
Além de os 10 artigos selecionados na execução da revisão sistemática outros 3 artigos foram incluídos para extração de informações.
Segundo, a inclusão de artigos é possível em revisões sistemáticas e isso é comum em várias áreas do conhecimento, tal como, por exemplo, a Medicina.
A Tabela 6 lista os títulos e as referências dos artigos usados nessa revisão sistemática para extração de informações.
Em as últimas linhas, em destaque, estão os artigos que não foram obtidos com os critérios estabelecidos por essa revisão.
Para avaliar o conjunto de artigos relacionados na tabela acima o seguinte conjunto de critérios para identificação de informações foi utilizado.
Mais especificamente, as informações buscadas foram:
Linguagem para Modelagem de Processos:
Indica se a solução usa ou propõe alguma linguagem para modelagem de processos (por exemplo, metamodelo baseado na UML, PML, etc) Regras e/ ou Restrições para Consistência na Definição de Processos:
Indica se a solução define algum tipo de mecanismo baseado em regras ou restrições para consistência dos processos durante suas atividades de definição;
Define Operações para Adaptação:
Indica se a solução propõe operações para adaptação de processos (por exemplo, inclusão de atividades, exclusão de produtos de trabalho, etc);
Regras e/ ou Restrições para Consistência na Adaptação de Processos:
Indica se a solução define algum tipo de mecanismo baseado em regras ou restrições para consistência dos processos durante suas atividades de adaptação;
Forma de Avaliação:
Indica como a solução foi avaliada;
Ferramenta: Indica se a solução usa alguma ferramenta ou protótipo;
Verificação de Processos:
Indica se a solução propõe algum mecanismo de verificação ou checagem de consistência nos processos de software nas atividades de definição e/ ou adaptação;
Formalismo para Regras:
Indica se a solução utiliza algum tipo de formalismo nas regras e/ ou restrições de consistência nas atividades de definição e/ ou adaptação.
Os itens marcados com um asterisco(*) nas Tabelas 7 e 8 indicam que a característica em questão é tratada de forma superficial ou não muito clara no artigo, quer dizer, sem apresentar diretamente uma solução para a característica em questão (contudo, ainda importante para o presente estudo).
Primeira parte dos resultados da revisão sistemática De essa maneira, na sequência, uma análise qualitativa dos artigos selecionados a partir de a revisão sistemática será descrita.
Para essa descrição os artigos serão organizados em dois grupos:
Artigos com foco no tratamento da consistência na atividade de definição dos processos de software;
E artigos com foco no tratamento da consistência na atividade de adaptação dos processos de software.
Os estudos de, e que, de alguma forma, relacionam o aspecto da consistência em ambas as atividades de definição e adaptação, aparecerão nos dois grupos conforme o aspecto tratado.
Considerando o primeiro critério de extração de informações que é sobre o uso ou definição de linguagem para modelagem de processos, constata- se, a partir de as Tabelas 7 e 8, que todos os artigos descrevem algum tipo de solução relacionada com esse aspecto.
De os 13 artigos analisados, apenas e, os marcados com* não apresentam com clareza como é realizada a modelagem de processos.
Em o caso específico do estudo apresentado em, os autores trabalham com linhas de processo e diagrama de features, não dando ênfase a linguagem de modelagem dos processos.
Contudo, em alguns pontos, os referidos autores relacionam o uso do metamodelo SPEM 2.
0. Em, os autores apenas referenciam o uso de uma linguagem denominada EPMN que seria baseada em Redes de Petri.
Contudo, nenhum detalhamento maior sobre a linguagem ou forma de modelagem é apresentado.
Também de forma consistente.
Além disso, é possível também definir pontos opcionais no processo e, dessa forma, os autores exploram como devem ser estabelecidas as relações de precedência envolvendo os elementos opcionais do processo, uma vez que eles poderão ser excluídos num novo processo.
O objetivo é, mais uma vez, não violar o fluxo de tarefas do processo gerado.
Os trabalhos de, e são os mais completos em estabelecerem regras para consistência de processos na atividade da definição.
Em os autores definem um conjunto de regras e classificam as mesmas em regras de restrição (constraint) e regras fato.
Relacionadas com aspecto de consistência estão as regras de restrição, as quais são subdivididas em:
Regras de fluxo, regras de estrutura, regras de consistência e regras de completude.
Inicialmente, as regras de fluxo definem condições que precisam ser atendidas para que uma transição possa ser executada.
Essas regras equivalem as condições de guarda do diagrama de atividades da UML.
Uma condição de guarda controla qual transição, de um conjunto de transições alternativas, ocorre após a conclusão da atividade.
As regras de estrutura são análogas as regras de fluxo, pois também estabelecem condições para que um fato ocorra dentro de o processo.
Segundo Bajec, a diferença das regras de estrutura para as regras de fluxo são que as regras de estrutura restringem qualquer elemento do processo e não somente tarefas (denominada em como atividade) (como é o caso das regras de fluxo).
Uma regra de estrutura pode, por exemplo, definir, que quando uma determinada tarefa for executada num período superior a um mês, ela deverá ser realizada utilizando determinada ferramenta.
Ambas as regras de fluxo e regras de estrutura são regras que consideram as características de projeto e estão associadas à execução do processo num projeto de software.
Por fim, as regras de completude e consistência são as regras que mais se aproximam do tema desta pesquisa.
As regras de completude são aquelas relacionadas com as multiplicidades UML e estabelecem que todas as associações entre as metaclasses de um metamodelo devem ser devidamente respeitadas na modelagem de um processo.
Já as regras de consistência são aquelas que não podem ser expressas através das multiplicitadades UML e que definem as dependências entre os elementos de um processo de software.
Como um exemplo para as regras de consistência, o autor cita a dependência que pode ocorrer entre dois produtos de trabalho Empty ­ esta regra estabelece que tarefas não podem ser vazias, ou seja, não possuir parâmetros nem de entrada e nem de saída (em termos de produtos de trabalho);
Black Holes: Esta regra estabelece que tarefas não podem ter somente parâmetros de entrada (em termos de produtos de trabalho);
Miracle: Esta regra estabelece que tarefas não podem ter somente parâmetros de saída (em termos de produtos de trabalho);
E Transformation:
Esta regra estabelece que todos os parâmetros de saída (em termos de produtos de trabalho) de uma tarefa devem também estar conectados como seus parâmetros de entrada.
No caso de esta última, os autores definem que poderá ser usado um qualificador para indicar que o produto de trabalho está sendo produzido na tarefa.
Em esse caso, a regra não indicaria o erro.
O segundo conjunto de regras proposto por é relacionado com as dependências que pode haver entre os elementos de um processo de software.
Basicamente, as regras propostas aqui verificam se um produto de trabalho que é consumido numa tarefa foi produzido anteriormente e se existe caminho entre sua tarefa de produção e as tarefas que consomem este artefato.
Outra regra estabelecida é verificar se os produtos de trabalho que são produzidos num processo são consumidos em algum ponto deste processo.
Segundo Atkinson, isso só não gera uma inconsistência em se tratando da ação final.
Em o estudo descrito em, são apresentadas somente regras relacionadas com consistência do sequenciamento entre atividades.
Os autores definem regras de sequenciamento para diagramas de atividade, Redes de Petri e diagrama de fluxo de dados.
Regras são definidas para essas três estruturas, pois, segundo os autores qualquer uma de elas pode ser utilizada para modelagem de um processo.
Com o intuito de entender melhor as regras definidas neste trabalho, abaixo, seguem as regras estabelecidas para os diagramas de atividade:
Diagramas de atividade devem possuir somente um nodo inicial;
Diagramas de atividade devem possuir um ou mais nodos finais;
Todas as atividades devem ter caminho originado a partir de o nodo inicial;
Considerando a atividade de definição de processos verificou- se que todos os estudos analisados propõem ou se utilizam de uma linguagem para modelagem de processos.
Em o que concerne às regras e/ ou restrições de consistência para a atividade de definição de processos, identificou- se, por o nível de aprofundamento do assunto nos artigos selecionados para esta revisão sistemática, que esta é uma área de pesquisa que merece maior atenção.
Concluiu- se isto, inicialmente, porque três dos nove artigos encontrados sobre esse assunto não definem de forma clara, suas regras para consistência.
Em seus estudos, e citam, por exemplo, a importância da consistência para os processos de software na atividade de definição, contudo não deixam claro como isto é realizado.
Especificamente, no caso de a justificativa se dá por o fato desse trabalho ter maior foco na atividade de adaptação dos processos, o que não é o caso dos estudos de e, os quais possuem foco em consistência na atividade de definição dos processos.
Analisando as regras apresentadas nos seis artigos restantes, constatou- se que muitos autores estabelecem poucas regras em seus estudos e deixam vários aspectos de consistência sem tratamento.
Em o caso específico dos trabalhos apresentados em e, os autores focam apenas nas regras que podem ser expressas através das informações de multiplicidade UML entre as metaclasses de seus metamodelos.
Em, uma regra adicional considerando a dependência entre produtos de trabalho também é mostrada e descrita em linguagem natural.
Contudo, em ambos os trabalhos, não é citado referências sobre regras de sequenciamento das atividades ou tarefas de um processo ou regras mais complexas envolvendo produtos de trabalho, papéis e até mesmo as tarefas.
De essa forma, seria possível, por exemplo, nos processos gerados com base na solução proposta por os estudos apontados acima incluir como parâmetro de entrada para uma tarefa um produto de trabalho que por o sequenciamento estabelecido ainda não foi produzido no processo, ou ainda, um produto de trabalho que foi produzido anteriormente, mas que, por o sequenciamento estabelecido, não possui nenhuma ligação (não possui caminho) com a tarefa que o consome.
De acordo com Atkinson, ambas as situações acima representam inconsistências para um processo de software.
Outros trabalhos que também tem foco em aspectos mais específicos para consistência de um processo de software são os estudos de e.
Os autores desses estudos apresentam regras específicas sobre sequenciamento entre atividades e tarefas num processo de software, deixando em aberto todos os outros aspectos e elementos envolvidos em tal processo.
O trabalho apresentado por Atiknson Em é considerado o que tem a solução mais completa em relação a definição de regras de consistência para a atividade de definição dos processos de software.
Ainda assim, cabe enfatizar que esses autores também não abordam vários aspectos de consistência num processo e não consideram o elemento de processo papel em suas regras.
Seria possível, por exemplo, num processo definido a partir de essa solução a definição de um sequenciamento entre atividades ou tarefas totalmente inconsistente por a inclusão de situações que representem deadlocks durante a execução de um processo de software.
Seria possível ainda definir tarefas que não fossem executadas por nenhum papel.
A partir de as conclusões acima, identifica- se como principal lacuna para a área de pesquisa específica sobre as regras de consistência na atividade de definição a falta de estudos mais completos sobre o assunto.
Entende- se como mais completos estudos que abordem todos os aspectos de consistência para os principais elementos de um processo de software, que de acordo com e são as Atividades, as Tarefas, os Papéis e os Produtos de Trabalho.
Quanto a a atividade de adaptação de processos, obteve- se como resultado que 8 dos 13 artigos analisados abordam, em suas soluções, algum aspecto relacionado com adaptação de processos.
Nota- se que a quantidade de artigos que abordam este aspecto é grande, fato que indica a importância da atividade de adaptação no ciclo de vida dos processos de software.
Já com relação a o primeiro critério analisado, observa- se nas Tabelas 7 e 8 que todos os estudos definem operações de adaptação de processos.
Inicialmente, com o trabalho apresentado em verifica- se que Yoon Consideram operações de adaptação somente sobre tarefas e produtos de trabalho do processo.
Isto é feito no estudo citado, porque esses são os únicos elementos considerados por os autores para a definição dos processos.
Porém, referente a as operações de adaptação, os mesmos autores relacionam operações de exclusão, adição, união e divisão de tarefas e produtos de trabalho.
Tais pesquisadores apenas restringem a união de produtos de trabalho, pois, segundo eles, um produto de trabalho não pode ter duas tarefas de produção e, no caso de dois produtos de trabalho serem acoplados sem a união de suas tarefas produtoras, eles passariam a ser produzidos em ambas as tarefas, o que violaria uma de suas regras de consistência para definição de processos.
Em, por sua vez, a definição de um processo é realizada com base em uma linha de processos.
De essa forma, os autores definem os pontos de variação e variantes num diagrama de features.
Isso caracteriza uma operação de substituição, pois as variantes podem variar de um processo para outro.
Além disso, como nos diagramas de features pontos podem ser definidos como opcionais considera- se que a operação de exclusão é permitida.
Contudo, como no estudo acima não são explicitados quais os elementos que fazem parte de um processo, então, não é possível identificar quais são os elementos que realmente podem sofrer operações de adaptação.
Através dos exemplos do artigo em discussão foi possível identificar apenas as operações de exclusão em tarefas e produtos de trabalho.
Não existem referências, por exemplo, aos papéis envolvidos no processo.
O conjunto de operações proposto em é bastante completo e permite a exclusão, inclusão, substituição, modificação e união de tarefas, produtos de trabalho e papéis do processo RUP.
Em, o conjunto de operações também é mais completo, uma vez que os autores desse estudo permitem a exclusão, adição, união e divisão de tarefas (denominado em como atividade).
Prosseguindo com a avaliação sobre o critério relacionado com as operações de adaptação, encontram- se os estudos que não definem suas operações explicitamente e são marcados com* na Tabela 7.
Tais estudos são, e.
Começando por o trabalho de, identifica- se que seus autores não descrevem atividades de adaptação e operações de forma evidente.
Esses autores apenas citam.
Em seu trabalho.
Que tarefas (denominada em como atividade) podem ser excluídas de um processo e, dessa forma, considera- se que a operação de exclusão de tareafas é permitida nesse estudo.
Em os autores definem que um processo base (padrão), o qual é formado por fragmentos de método, tem muitos destes fragmentos opcionais para um projeto específico.
De essa maneira, analogamente ao trabalho de, considerase que a exclusão de elementos é permitida em.
Contudo, como os autores do referido trabalho não detalham quais elementos de um processo formam os fragmentos de método e nem definem sua granularidade, não é possível saber exatamente quais elementos podem sofrer operações de adaptação.
Analogamente ao funcionamento da operação de exclusão proposta em, apresenta- se a solução definida em.
Em este estudo, Ojeda Também definem a operação de exclusão por considerarem fragmentos de método opcionais.
A única diferença em relação a é que os autores do estudo apresentado em não relacionam o uso de um processo base (padrão) em sua solução.
Eles definem que um repositório de fragmentos de método desconexos deve estar disponível e que todo processo específico de um projeto deve ser montado por a seleção de tais fragmentos.
Além disso, esses autores também consideram que novos fragmentos de método podem ser incluídos pra um projeto em específico.
Por fim, analisando o estudo de, verifica- se que seus autores não definem claramente operações de adaptação em seu trabalho, uma vez que este não tem como foco a adaptação de processos.
Sendo assim, os autores, apenas citam, durante o texto que, elementos tais como papéis, produtos de trabalho e tarefas (denominados em, respectivamente, como papéis, produtos de trabalho e atividades) podem ser adicionados, excluídos ou modificados num processo.
Isto é referido no artigo porque os autores afirmam que estas são as possíveis alterações que um processo pode sofrer.
Com relação a as regras ou restrições de consistência para adaptação de processos, foi constatado que apenas em não existe a definição de regras para controlar as operações de adaptação.
Outro resultado da análise sobre esse aspecto é que alguns autores propõem muitas operações de adaptação, contudo, no momento de apresentar as regras que guiam tais operações, não o fazem de forma completa, apresentando regras somente para parte das operações propostas.
Em esse contexto, os trabalhos mais completos são os de e, em os quais há definição de regras de consistência para todas as operações propostas em seus estudos.
Em as regras de consistência são definidas para as operações de inclusão, exclusão, união e divisão de tarefas e produtos de trabalho.
As regras mais simples nesse estudo são definidas para a operação de inclusão de tarefas e produtos de trabalho, uma vez que elas apenas definem que, quando um destes elementos é incluído, o mesmo deve ser devidamente relacionado com os outros elementos (também tarefas e produtos de trabalho) do processo.
Resumidamente, para as operações de divisão de tarefas e produtos de trabalho, define- se, respectivamente, que os produtos de trabalho resultantes da divisão devem ser conectados nas mesmas tarefas que o produto de trabalho original era conectado, bem como que as novas subtarefas resultantes da divisão também devem ser conectadas com os mesmos produtos de trabalho que a tarefa original possuía associações.
Para esta última regra, fica estabelecido em que o responsável por a operação de divisão de tarefas deve verificar, após a execução da operação, se algum produto de trabalho não está sendo produzido por duas tarefas no processo resultante.
Isso não deve ser permitido, pois viola a única regra de consistência para definição dos processos de software deste estudo.
Prosseguindo com as regras de consistência definidas em, têm- se as regras para as operações de união de tarefas.
Em esta operação, é definido que, quando duas tarefas são unidas, todas as suas entradas e saídas em termos de produtos de trabalho devem ser conectadas na tarefa resultante.
Por fim, as regras para a operação de exclusão de tarefas definem que, quando uma tarefa é excluída de um processo de software, os produtos de trabalho gerados por esta tarefa serão também excluídos.
Em esse contexto, quando um produto de trabalho é excluído, deve- se eliminar a associação de ele com todas as tarefas remanescentes no processo.
Em caso de alguma das tarefas afetadas ser a tarefa produtora do produto de trabalho excluído, ela também deverá ser excluída do processo.
Por fim, caso existam produtos de trabalho no processo que dependem (relação de dependência) do produto de trabalho excluído, eles também deverão ser eliminados do processo.
Já o estudo de possui regras de consistência totalmente focadas no sequenciamento das tarefas de um processo de software.
Como dito anteriormente, os autores propõem as operações de exclusão, adição, união e divisão de tarefas.
Assim, esses autores apresentam regras para qualquer uma dessas operações, considerando que as tarefas estejam em sequência, sejam paralelas ou estejam envolvidas num sequenciamento com decisão ou iteração (tarefas que são executadas repetidamente).
Um exemplo da regra destes autores pode ser o seguinte:
Quando uma tarefa envolvida numa estrutura de decisão é apagada, deve- se verificar se ainda existe a necessidade de manter tal estrutura ou definir apenas uma estrutura de sequência entre as atividades remanescentes.
Analogamente, se a tarefa apagada é paralela a apenas uma outra tarefa no processo, então, é necessário apagar a estrutura de paralelismo, criando apenas uma estrutura de sequência simples entre as tarefas remanescentes.
Prosseguindo com a avaliação, encontra- se o estudo de, o qual propõe um conjunto bastante completo de operações:
Exclusão, inclusão, substituição, modificação e união de tarefas, produtos de trabalho e papéis.
Contudo, nesse estudo, não são descritas regras para todas as operações propostas.
Os autores somente apresentam as regras para adição e exclusão dos elementos referidos, as quais são definidas exatamente da mesma forma que as regras já apresentadas para o trabalho de.
Em o trabalho dos autores consideram que as regras de restrição utilizadas para modelagem de processos devem ser respeitadas durante a adaptação dos processos.
Segundo esses autores, quando os fragmentos de processo opcionais não são selecionados para um projeto, é preciso que essa seleção não viole nenhuma regra de restrição.
Em e, analogamente ao critério de operações de adaptação, o critério das regras de consistência para adaptação de processos é definido de forma superficial.
Especificamente em, é explorado amplamente a definição de processos específicos para projetos, realizada a partir de um repositório de processos, o que é feito a partir de a utilização de uma ferramenta denominada agentTool Process Editor ­ APE.
Em esta ferramenta, que é um plugin do eclipse e tem integração com o Eclipse Process Framework ­ EMF, existe um framework de validação para consistência dos processos gerados.
Contudo, as regras implementadas dentro de o framework de validação não são exploradas.
A única regra explorada no estudo e mostrada como exemplo no framework de validação é a que checa se as entradas de uma tarefa já foram produzidas no processo.
Segundo os autores desse estudo, tais entradas são definidas como as précondições para que uma tarefa possa ser executada.
Ainda relacionado ao estudo de, embora não citado por os autores, considera- se que as regras de multiplicidades e atributos definidos num modelo de classes UML também são verificadas.
Isso porque a ferramenta APE, analogamente à ferramenta apresentada em, é um plugin do eclipse baseado no EMF.
Em constatou- se que não existem regras explícitas de consistência para adaptação de processos.
O que os autores apresentam, nesse estudo, é como montar modelos de dependência dos elementos a partir de um processo.
A ideia é a de que tais modelos permitam realizar análise de impacto, quando um elemento for adicionado, excluído ou modificado.
Os modelos de dependência propostos por Park São:
Modelo de dependências entre o fluxo das tarefas que mapeia as relações de precedência das tarefas num processo;
Modelo de produtos de trabalho no processo que mapeia informações sobre composição, agregação e dependências entre produtos de trabalho num processo de software;
Modelo de dependência entre papéis que mapeia as dependências entre papéis por suas competências.
Isto quer dizer que, se papéis tem as mesmas competências, eles estão relacionadas no modelo de dependência de papéis.
Tal assertiva serve para indicar que papéis relacionados podem desempenhar as mesmas tarefas (tarefa possui informação de competência necessária);
Modelo de dependência de atribuição que mapeia qual papel desempenha qual tarefa num processo;
E Modelo de dependência In/ Out que mapeia quais tarefas consomem e produzem cada produto de trabalho do processo.
Embora, como dito anteriormente, os modelos acima permitam mapear os impactos, quando o processo é alterado, não existe, em, uma descrição sobre as regras e/ ou procedimentos a serem tomados durante uma alteração.
Alguns indícios de regras são extraídos a partir de exemplos apresentados no estudo.
Por exemplo, é definido em que quando um papel é excluído de um processo e no modelo de dependência entre papéis existe um ou mais papéis relacionados o papel excluído, não existe impacto no processo que sofreu a modificação.
Contudo, se não existem papéis relacionados ao papel excluído, então, uma ou mais tarefas poderão ser afetadas, pois tais tarefas podem não possuir mais relação com nenhum papel no processo e, desse modo, também necessitarão serem excluídas.
Por conseqüência, um ou mais produtos de trabalho do processo igualmente podem ser afetados e causar novas excluções.
O que se observa, no estudo de, é que a grande contribuição desse trabalho está na riqueza da análise de impacto permitida por os modelos de dependência propostos.
Por fim, o estudo de define regras de consistência para adaptação de processos de forma um pouco diferente.
Isso porque, como dito em momento anterior, esse estudo utiliza a ideia de linhas de processos para geração de um processo específico.
De essa forma, durante uma operação de substituição (utilizando- se das variantes de processo) ou exclusão (que será feita nos pontos opcionais) de elementos, várias regras são definidas para que os relacionamentos estabelecidos no diagrama de features sejam respeitados.
O que se observa em é que o foco de grande parte das regras é o sequenciamento das tarefas num processo.
Contudo, como esse estudo é específico sobre linhas de processo, consideram- se suas regras aplicáveis a trabalhos que utilizem esse tipo de solução, o que não é caso, por exemplo, desta pesquisa.
Como visto, podem existir diferentes formas para a adaptação dos processos de software e um mecanismo pode se mostrar mais completo que outro.
Além disso, alguns autores preconizam o uso de um processo padrão, como é casos dos estudos de e, e outros definem que processos devem ser estabelecidos para cada projeto por a seleção de fragmentos de método, a partir de um repositório, como é o caso do estudo apresentado em.
Especificamente sobre as operações de adaptação, identifica- se na análise dos estudos encontrados nesta revisão sistemática, que não existe um consenso na literatura analisada sobre quais as operações devem ser permitidas durante a adaptação dos processos.
Alguns estudos propõem um conjunto maior de operações, como é o caso de, e, contudo, seus autores não justificam qual seria a motivação ou situação em que determinadas operações seriam necessárias num projeto de software.
Em esse contexto, as únicas operações que apresentam um consenso nos estudos são as de adição e exclusão de elementos e relacionamentos de um processo.
Com relação a as regras para consistência que guiam as operações de adaptação, conclui- se que os trabalhos apresentam regras bem completas para suas operações, destacando- se os trabalhos apresentados em e.
Observa- se ainda que as regras de consistência para adaptação têm como principal objetivo manter a consistência estabelecida durante a definição dos processos.
Isto é dito, pois embora alguns estudos não tenham foco nas atividades de definição de processos, seus autores citam que o objetivo das regras utilizadas nas atividades de adaptação é manter a consistência do processo original nos processos adaptados.
Mesmo que exista, como dito acima, a preocupação nos trabalhos selecionados com a consistência dos processos durante as atividades de adaptação, observa- se um problema em alguns estudos que definem regras para consistência.
O problema é relacionado com a falta de referências a importantes elementos do processo como, por exemplo, os trabalhos de, e que não possuem referências ao elemento papel em seus trabalhos.
De essa forma, durante as operações de adaptação e uso das regras para consistência, esse elemento não possui nenhum tratamento.
Em os casos específicos de e, também não existem referências ao elemento de processo produto de trabalho.
Como base contexto acima identificam- se, algumas lacunas específicas sobre ao tratamento da consistência durante a adaptação dos processos de software.
Tais lacunas são:
Necessidade de maior investigação sobre quais operações de adaptação devem ser permitidas quando um processo de software é adaptado;
Especificamente sobre as regras de consistência, necessidade de definição de regras de consistência mais completas que envolvam os principais elementos e relações de um processo de software. Conforme
já explicado na Seção 3.3.1.1 deste trabalho os principais elementos de um processo de software são Atividades, Tarefas, Papéis e Produtos de Trabalho.
Através da revisão sistemática conduzida nesta pesquisa, bem como dos estudos preliminares na literatura, do estudo aprofundado na especificação do metamodelo SPEM e dos processos de software OPEN, RUP e OpenUp, identificou- se um conjunto de premissas que são apliváveis em qualquer processo de software para seus principais elementos que são Produto de Trabalho, Atividades, Tarefas e Papel.
A Tabela 9 apresenta as premissas identificadas e descritas no contexto do metamodelo SPEM 2.
0 que é utilizado como referência nesta pesquisa.
Em a Tabela 9, as premissas são listadas juntamente com as referências de onde elas foram extraídas.
Adicionalmente, para facilitar a identificação de cada premissa no restante deste trabalho, um identificador foi criado para todas elas e é também relacionado na Tabela 9.
Torna- se também importante considerar que as referências listadas não são as únicas a mencionar individualmente cada premissa, porém, para a grande maioria de elas, pelo menos uma referência está presente.
Em as últimas linhas da Tabela 9, se apresentam algumas premissas que não estão associadas com nenhuma referência da literatura por terem sido definidas especificamente nesta pesquisa.
A justificativa para tais definições é descrita a seguir juntamente com a explicação de cada uma das premissas.
Projetos de software podem consumir produtos de trabalho externos ao projeto.
Produtos de trabalho externos são consumidos e/ ou modificados num projeto de software.
Todo produto de trabalho que não é externo a um projeto de software deve ser produzido no próprio projeto de software.
Produtos de trabalho podem assumir relações de agregação com outros produtos de trabalho num processo de software.
Produtos de trabalho podem assumir relações de dependência com outros produtos de trabalho num processo de software.
Todo produto de trabalho deverá possuir um responsável associado a sua produção.
Toda tarefa de um projeto de software deve ser desempenhada por um papel e deve produzir um resultado de valor observável em termos de produto de trabalho.
Todas as dependências (em termos de produtos de trabalho) de um produto de trabalho devem estar disponíveis no momento da sua produção.
Todas as entradas de uma tarefa devem estar disponíveis no momento de sua execução.
O seqüenciamento das atividades ou tarefas não deverá apresentar situações que representem deadlocks para a execução de um processo de software.
O processo de software deverá possuir um nodo inicial e um nodo final.
Todo sequenciamento entre as atividades ou tarefas deverá ter seu começo no nodo inicial e seu término no nodo final do processo de software.
Quando atividades compostas por outras atividades e/ ou tarefas definem seus parâmetros de entrada e/ ou saída em termos de produtos de trabalho, estes parâmetros devem ser compatíveis com os parâmetros de entrada e/ ou saída definidos nas suas atividades e tarefas internas.
Todo papel deverá participar na execução de pelo menos uma tarefa.
Atividades, tarefas, produtos de trabalho e papéis podem ser opcionais num projeto de software.
Todo produto de trabalho obrigatório deverá estar associado a pelo menos uma tarefa obrigatória e um papel obrigatório.
Todo papel obrigatório deverá estar associado a execução de pelo menos uma tarefa obrigatória.
Toda tarefa obrigatória deverá estar associada a pelo menos um produto de trabalho obrigatório e um papel obrigatório para sua execução.
Toda atividade opcional não deverá possuir como uma de suas partes nenhum elemento de processo obrigatório.
Toda atividade obrigatória deverá possuir como uma de suas partes ao menos uma tarefa obrigatória.
Instâncias de produtos de trabalho e papéis que possuem nomes iguais não devem ser criados num processo de software.
Instâncias de relacionamentos que representem mais de uma vez a mesma relação entre dois elementos de processo não devem ser criados.
As premissas P&amp; 1 e P&amp; 2, relacionadas a definição de produtos de trabalho externos a um projeto de software foram definidas com o objetivo de:
Contemplar os produtos de trabalho de projetos de manutenção de software que em sua grande maioria estão prontos necessitando apenas de atualizações;
E contemplar produtos de trabalho padrões definidos nas organizações para serem somente consumidos nos projetos.
Em este último caso especificamente, cita- se como exemplo um plano de medições e análise que pode ser definido de forma corporativa e pode ser apenas consumido como uma referência em todos os projetos de software de uma organização.
A premissa P&amp; 3 estabelece que todos os produtos de trabalho do tipo interno deverão ser produzidos em pelo menos um ponto no ciclo de vida de um projeto de software.
Esta premissa é relacionada em vários estudos da literatura, tais como em e, e também nos processos de software OPEN, RUP e OpenUP.
As premissas P&amp; 4 e P&amp; 5 dizem respeito aos tipos de relacionamentos que os produtos de trabalho podem assumir com outros produtos de trabalho num projeto de software.
Especificamente a premissa P&amp; 4 considera que produtos de trabalho podem ser compostos (assumindo relações de agregação simples e agregação composta) por outros produtos de trabalho.
Vários exemplos de produtos de trabalho com este tipo de relação podem ser encontrados em ambos os processos RUP e OPEN,.
Já a premissa P&amp; 5 estabelece que produtos de trabalho podem assumir relações de dependência com outros produtos de trabalho ao longo ciclo de vida de um processo de software.
Particularmente durante a definição dos processos de software, relacionamentos de dependência são necessários para construção do fluxo de produção dos produtos de trabalho e definição das entradas das tarefas.
Durante as atividades de adaptação, este tipo de relacionamento assume um papel essencial, pois é preciso conhecer- los para que inconsistências não sejam geradas no processo resultante.
Em operações de exclusão de elementos, por exemplo, torna- se necessário conhecer a relação de dependência entre produtos de trabalho para que seja possível impedir que determinados produtos de trabalho sejam excluídos do processo enquanto outros produtos de trabalho que dependem do produto de trabalho excluído fizerem parte do mesmo.
A premissa P&amp; 6 relaciona- se com o fato que todo produto de trabalho possui um papel responsável que deve participar de sua tareafa de produção.
Em o caso específico dos processos RUP e OPEN, identificou- se que todos os produtos de trabalho destes processos tem a participação de seus papéis responsáveis em suas tarefas de produção.
Desta forma, esta premissa foi criada e se aplica a qualquer processo de software que prevê a relação de responsabilidade entre papéis e produtos de trabalho.
A definição da premissa P&amp; 7 é baseada no fato de que tarefas num processo de software deverão produzir um resultado, criando ou modificando um ou mais produtos de trabalho.
Essa definição é facilmente encontrada na literatura e, bem como nos processos de software, tais como o RUP e o OPEN.
Além de produzir ou modificar um ou mais produtos de trabalho, essa premissa também estabelece que uma tarefa é sempre desempenhada por pelo menos um papel.
As premissas P&amp; 8 e P&amp; 9 estão relacionadas com a disponibilidade de produtos de trabalho para execução das tarefas num processo de software.
Especificamente a premissa P&amp; 8 define que todas as dependências (em termos de produtos de trabalho) de um produto de trabalho devem estar disponíveis neste processo no momento de sua produção.
Isso quer dizer que todo relacionamento de dependência entre produtos de trabalho estabelece que um produto de trabalho depende de um ou mais produtos de trabalho para ser produzido num processo de software,.
A premissa P&amp; 9 define que, quando um produto de trabalho é utilizado num processo de software, ele deve estar disponível.
Essa premissa é específica para produtos de trabalho do tipo interno e implica que quando um produto de trabalho é consumido num processo de software é necessário que esse produto de trabalho esteja associado a pelo menos uma atividade de produção (ou seja, sua produção já deve ser sido iniciada no processo de software) e que exista pelo menos um caminho entre essa tarefa e as tarefas que consomem o produto de trabalho.
As premissas P&amp; 10, P&amp; 11 e P&amp; 12 relacionam- se com o sequenciamento entre as atividades ou tarefas do metamodelo SPEM 2.
0. Elas definem as condições que um sequenciamento estabelecido, entre as atividades ou tarefas num processo de software, deverá atender para ser consistente.
Em vários processos de software, incluindo aqueles definidos a partir de o metamodelo SPEM 2.
0, atividades podem ser compostas por outras atividades e/ ou tarefas.
Para esses casos, torna- se necessário garantir a consistência dos produtos de trabalho definidos como entrada e saída para estas atividades e tarefas.
Em outras palavras, é necessário verificar se as entradas e saídas definidas para uma atividade estão definidas igualmente em pelo menos uma de suas tarefas internas.
Não é possível, por exemplo, no caso específico do RUP que uma atividade (no RUP um workflow detail) possua um parâmetro de saída indicando a produção de um produto de trabalho sendo que suas tarefas (no RUP as tarefas) internas não produzem tal produto de trabalho em nenhum ponto da execução desta atividade.
Baseado neste contexto a premissa P&amp; 13 estabelece que quando uma atividade é composta por outras atividades e/ ou tarefas e estabelece entradas e saídas em termos de produtos de trabalho, estas mesmas entradas e saídas, devem obrigatoriamente, estar definidas numa de suas tarefas internas.
A premissa P&amp; 14 é básica e define que um papel deverá participar na execução de pelo menos uma tarefa.
Essa definição é comum na literatura e pode ser encontrada explicitamente em e.
As premissas P&amp; 15, P&amp; 16, P&amp; 17, P&amp; 18, P&amp; 19 e P&amp; 20 estão relacionadas com os aspectos de opcionalidade dos elementos num processo de software.
Especificamente a premissa P&amp; 15 estabelece que elementos tais como papel, atividade, tarefa e produto de trabalho podem ser opcionais em projetos de software.
Esta premissa é comumente encontrada na literatura sobre adaptação de processos.
Isso porque vários dos elementos opcionais num processo poderão ser excluídos num procedimento de adaptação.
As premissas P&amp; 16, P&amp; 17, P&amp; 18, P&amp; 19 e P&amp; 20 estabelecem como os elementos obrigatórios deverão estar relacionados num processo de software e, ainda, como uma atividade opcional deverá ser definida.
Não é possível, por exemplo, estabelecer uma tarefa obrigatória num processo de software que é executada somente por papéis definidos como opcionais.
Isso poderia facilmente gerar um inconsistência durante uma atividade de adaptação do processo em questão para um projeto específico, uma vez que os papéis opcionais poderiam ser excluídos deixando a tarefa obrigatória (que não poderia ser excluída) sem executores.
Outro exemplo que poderia gerar inconsistências durante as atividades de adaptação seria a definição de uma atividade opcional que é composta por elementos de processo obrigatórios.
Em um procedimento de adaptação não seria possível excluir a atividade em questão (que é definida como opcional), uma vez que esta atividade contém elementos que são obrigatórios e, portanto, não podem ser excluídos em nenhum projeto de software.
Embora as premissas P&amp; 16, P&amp; 17, P&amp; 18, P&amp; 19 e P&amp; 20 não estejam relacionadas com nenhuma referência da literatura analisada, suas definições foram necessárias nesta pesquisa para garantir que as informações sobre as opcionalidades dos elementos num processo de software, que é definido a partir de o metamodelo SPEM 2.
0, sejam consistentes (de acordo com premissa P&amp; 15).
Por fim, as premissas P&amp; 21 e P&amp; 22 estabelecem que alguns elementos e relacionamentos não devem ser definidos mais de um vez num processo de software.
Por exemplo, não devem ser definidos dois ou mais papéis denominados como Tester, ou ainda, dois ou mais produtos de trabalho denominados como Vision num processo de software.
Especificamente considerando os relacionamentos, define- se, por exemplo, que não devem existir dois relacionamentos no mesmo processo que estabeleçam o papel Analyst como responsável por o produto de trabalho Use Case.
Observa- se na Tabela 9 que as premissas P&amp; 21 e P&amp; 22 não estão ligadas a nenhuma referência da literatura analisada, uma vez que não foi possível encontrar referências explícitas nos estudos sobre as informações relacionadas com tais premissas.
Este capítulo identificou as principais lacunas de pesquisa sobre o tratamento da consistência durante a definição e adaptação dos processos de software e também definiu um conjunto de premissas relacionadas com o aspecto de consistência que devem ser atendidas em qualquer processo de software.
A seguir, com base no conteúdo apresentado até este momento, a solução proposta nesta pesquisa para o tratamento da consistência dos processos de software começa a ser apresentada.
Em o próximo capítulo, uma extensão ao metamodelo SPEM 2.
0 e um conjunto de regras de boa-formação para consistência serão descritos, visando o atendimento das premissas apresentadas nesse capítulo.
Este capítulo apresenta uma extensão ao metamodelo SPEM 2.
0, que é nomeada como sSPEM 2.0, e um conjunto de regras de boa-formação relacionado com o aspecto da consistência dos processos de software.
Ambos, o metamodelo sSPEM 2.0 e o conjunto de regras de boa-formação, são partes da infraestrutura para consistência que está sendo definida nesta pesquisa e visam atender as premissas para consistência dos processos de software, as quais já foram apresentadas no capítulo anterior deste trabalho.
O metamodelo sSPEM 2.0 inclui um conjunto de elementos e relacionamentos, bem como realiza alterações no metamodelo original SPEM 2.
0. Esse metamodelo será utilizado para condução de todas atividades de definição e adaptação de processos nesta pesquisa.
Já as regras de boa-formação são estabelecidas com base nos elementos e relacionamentos do metamodelo sSPEM 2.0 e estabelecem as condições que devem ser verdadeiras (premissas) para todos os processos de software em qualquer ponto do seu ciclo de vida, não se alterando sobre qualquer conjunto de transformações.
Em o contexto desta pesquisa, transformações num processo de software são consideradas como as modificações que um processo pode sofrer, decorrente das atividades de adaptação para projetos em específico.
Em esta pesquisa, foram definidas 50 regras de boa-formação.
A ideia é que estas regras sejam utilizadas para especificar os elementos e relacionamentos de um processo de software de maneira coerente e, assim, evite que possíveis inconsistências estejam presentes nos projetos de software.
A seção seguinte identifica quais os elementos e relacionamentos que foram tratados na extensão realizada ao metamodelo SPEM 2.
0. As outras seções deste capítulo descrevem, respectivamente, o metamodelo sSPEM 2.0, as regras de boaformação e também os mecanismos de adaptação do metamodelo sSPEM 2.0.
As alterações realizadas no metamodelo original SPEM 2.
0 e todo o conjunto de regras de boa-formação criado, foram definidos utilizando os elementos de processo Atividade, Tarefa, Produto de Trabalho e Papel e todos os relacionamentos existentes O metamodelo sPEM 2.0 foi incluído nas camadas de metamodelagem propostas por a OMG, conforme mostrado na Figura 25.
Observa- se nesta figura que o esse metamodelo é definido na camada M2 como uma instância do MOF 2.
0 definido na camada M3.
O metamodelo sSPEM 2.0 se relaciona por meio de um extends com o metamodelo SPEM 2.
0, caracterizando- se como uma extensão deste metamodelo.
As últimas camadas mostram, respectivamente, os modelos gerados a partir de os metamodelos definidos na camada M2 e as instâncias de tais modelos.
Destaca- se que a grande diferença entre os modelos gerados a partir de o metamodelo SPEM 2.
0 e do metamodelo sSPEM 2.0 reside no fato de que os modelos gerados a partir de o sSPEM 2.0 poderão ser verificados através das regras de boa-formação para consistência.
Em a sequência, serão descritos os pacotes do metamodelo sSPEM 2.0: Esta seção relaciona as alterações e regras de boa-formação definidas especificamente para o pacote Process Structure.
Como forma de auxiliar no entendimento do conteúdo apresentado, a Tabela 11 relaciona cada alteração e as regras de boa-formação incluídas no pacote Process Structure com as premissas definidas nesta pesquisa.
Em a Tabela 11, especificamente nas últimas linhas, várias regras de boa-formação, não estão relacionadas com nenhuma alteração do metamodelo.
Isso ocorre, pois em alguns casos, para o atendimento de algumas premissas, não são necessárias mudanças sobre metaclasses e relações do metamodelo, mas sim a inclusão de regras que definam algumas condições de instanciação destes elementos num processo de software.
Em a Tabela 11, pode- se observar, também, que existe uma modificação que não é relacionada com nenhuma premissa e com nenhuma regra de boa-formação.
Isso ocorre, pois especificamente esta alteração foi realizada para permitir a criação de um procedimento de análise de impacto para os mecanimos de adaptação do metamodelo sSPEM 2.0, que serão descritos a seguir, na Seção 4.4 deste capítulo.
O primeiro conjunto de alterações realizadas no pacote Process Structure está relacionada com os elementos WorkProductUse e WorkProductUseRelationship, conforme pode ser visto na Figura 26 (indicado por a Letra A).
Especificamente, a alteração realizada diretamente sobre o elemento WorkProductUse envolve a inclusão das metaclasses InternalUse e ExternalUse como especializações dessa metaclasse.
Como consequência, a metaclasse WorkProductUse passsa a ser abstrata no pacote Process Structure.
O objetivo de incluir as metaclasses InternalUse e ExternalUse foi diferenciar quando um produto de trabalho é produzido ou somente consumido e/ ou modificado num processo de software.
Em esse sentido, a metaclasse InternalUse deve ser utilizada toda vez que um produto de trabalho é obrigatoriamente produzido num determinado processo de software e a metaclasse ExternalUse deve ser utilizada para representar produtos de trabalho que são apenas consumidos e/ ou modificados em tal processo.
A modificação realizada sobre o elemento WorkProductUseRelationship envolve a inclusão do atributo relationType (indicado por a Letra B na Figura 26).
Ainda relacionado a este elemento, foi incluída uma metaclasse do tipo enumeração chamada WorkProductRelationshipKind que define os valores válidos (dependência, composição e agregação) para o atributo relationType, conforme mostrado na Figura 26 (indicado por a Letra C).
Tanto o atributo relationType quanto a metaclasse de enumeração WorkProductRelationshipKind foram definidas no pacote Process Structure para estabelecer quais são os tipos de relacionamentos que os produtos de trabalho podem assumir entre si.
Isso foi feito, porque, originalmente, na especificação do metamodelo SPEM 2.
0, já há a consideração de que produtos de trabalho podem assumir relações entre si através da classe WorkProductUseRelationship, contudo, como os tipos de relações não são predefinidas, elas não possuem nenhum tipo de regra de boa-formação relacionada com consistência.
Em esta pesquisa, os tipos de relações permitidas entre produtos de trabalho foram definidas com base na literatura e são os de dependência, agregação e composição.
A relação de dependência é citada por vários estudos, tais como, e estabelece que um produto de trabalho (source) depende de um ou mais produtos de trabalho (target) para ser produzido num processo de software.
Já as relações de agregação e composição possuem o mesmo significado de relações da UML e estabelecem que um produto de trabalho (source) pode ser composto por um ou mais produtos de trabalho (target) num processo de software.
A diferença entre as relações de agregação e composição é que, assim como na UML, uma relação de composição estabelece uma relação mais forte entre os produtos de trabalho.
Em esse tipo de relação, o (s) produto (s) de trabalho que representa (m) a (s) parte (s) na relação não faz (em) sentido sem o produto de trabalho que representa o todo desta relação.
Especificamente, no contexto dos processos de software, analisando os estudos de, os quais citam as relações de agregação e composição, verificou- se que, numa relação de composição o produto de trabalho que representa o todo também não faz sentido sem o (s) produto (s) de trabalho que representa (m) sua (s) parte (s).
Em esse sentido, mudanças também foram feitas sobre alguns relacionamentos e multiplicidades do pacote Process Structure, sendo a primeira de elas realizada no relacionamento entre as metaclasses WorkProductUse e ProcessResponsabilityAssignment.
Originalmente, no metamodelo SPEM 2.
0, é estabelecido que um produto de trabalho pode estar associado a zero ou vários papéis responsáveis num processo de estabelecidos no pacote Process Structure foi feita na relação estabelecida entre as metaclasses ProcessParameter e WorkProductUse.
Originalmente, no pacote Process Structure do metamodelo original SPEM 2.
0 uma instância da metaclasse WorkBreakdownElementKind deve ser utilizado para todas as outras atividades do processo de software.
Por fim, como mostrado por as Letras I e J da Figura 26, incluiu- se um atributo chamado optionality também para a metaclasse abstrata ProcessParameter juntamente com uma metaclasse de enumeração chamada OptionalityKind que define os valores válidos (mandatory e optional) para esse atributo.
O motivo para inclusão do atributo optionality e da metaclasse OptionalityKind é diferenciar quando um parâmetro de entrada e/ ou saída numa atividade é obrigatório ou opcional para sua execução.
Essa informação é essencial durante as operações de adaptação, uma vez que toda atividade que possui parâmetros obrigatórios depende de eles para ser executada.
Assim, caso um desses parâmetros seja excluído, a atividade a qual pertece também deverá ser eliminada.
Esta seção apresenta o conjunto de regras de boa-formação para consistência definido no pacote Process Structure.
Em este, encontra- se o maior número de regras de boa-formação contemplando grande parte das premissas para consistência de processos propostas nesta pesquisa (conforme Seção 3.4).
As primeiras regras de boa-formação relacionam- se com as metaclasses ExternalUse e InternalUse e tem como objetivo garantir que os produtos de trabalho do tipo interno serão produzidos num processo de software e que os produtos de trabalho do tipo externo serão apenas consumidos e/ ou modificados em tal processo.
Tais regras são:
Regra&amp; 1 -- Os produtos de trabalho externos (ExternalUse) não podem ser produzidos num processo de software.
Semântica: Nenhuma instância da metaclasse ExternalUse pode possuir relação com instâncias da metaclasse ProcessParameter que possuem o valor do atributo direction igual a &quot;out».
Regra&amp; 2 -- Os produtos de trabalho externos (ExternalUse) devem ser consumidos e/ ou modificados num processo de software.
Semântica: Toda instância da metaclasse ExternalUse deve ter pelo menos uma relação com uma instância da metaclasse ProcessParameter que tenha o valor do atributo direction igual a &quot;in «ou &quot;inout».
Regra&amp; 3 -- Os produtos de trabalho internos (InternalUse) devem ser produzidos num processo de software.
Semântica: Toda instância da metaclasse InternalUse deve ter pelo menos uma relação com uma instância da metaclasse ProcessParameter que tenha o valor do atributo direction igual a &quot;out».
As próximas regras de boa-formação são relacionadas com as metaclasses InternalUse, ExternalUse e WorkProductRelationshipUse e são específicas sobre as relações de dependência, agregação e composição que os produtos de trabalho do tipo externo ou interno podem assumir num processo de software.
A definição de tais regras foi realizada para respeitar as propriedades de reflexividade, simetria e transitividade das relações dependência, agregação e composição.
Considerando a propriedade de reflexividade, diz- se que todas as relações de dependência, agregação e composição entre produtos de trabalho são irreflexivas, ou seja, para todas essas relações, produtos de trabalho não poderão estar relacionados com si mesmo.
Considerando a relação de composição, por exemplo, produtos de trabalho não podem ser definidos como composições de si próprios.
O mesmo vale para as relações de dependência e agregação.
Com relação a a transitividade, define- se que todas as relações de dependência, agregação e composição entre produtos de trabalho são transitivas, ou seja, elas se transmitem em cadeia.
Por exemplo, dado que um produto de trabalho A é composto de um produto de trabalho B e B é composto de um produto de trabalho C, então A também é composto de C. O mesmo se aplica para as relações de dependência e agregação.
Por fim, relacionado a propriedade de simetria, estabelece- se que todas as relações de dependência, agregação e composição entre produtos de trabalho são assimétricas.
Por exemplo, se o produto de trabalho A é composto por o produto de trabalho B, então o produto de trabalho B não é composto por o produto de trabalho A_ O mesmo é válido para as relações de dependência e agregação.
Além de as propriedades acima, uma regra específica também foi criada para a relação de composição entre produtos de trabalho.
Tal regra define que um produto de trabalho (interno e externo) não pode estar envolvido como uma &quot;parte «em mais de um relacionamento de composição.
Isso respeita a definição dessa relação estabelecida na literatura sobre processos de software e também na linguagem UML.
Baseado no contexto acima, as seguintes regras de boa-formação foram definidas:
Regra&amp; 5 -- Um produto de trabalho externo ou interno (ExternalUse ou InternalUse) não pode ser o &quot;todo «num relacionamento de composição se uma de suas &quot;partes «já representa o seu &quot;todo «em outro relacionamento de composição ou representa o seu &quot;todo «por a transitividade da relação de composição.
Semântica: Dado que existe uma instância da metaclasse WorkProductUseRelationship 1 com o seguintes valores de atributos:
RelationType igual a composition;
Source associado com a instância da metaclasse InternalUse A;
E target associado com as instâncias da metaclasse ExternalUse B e C, não pode existir outra instância da metaclasse WorkProductUseRelationship com os seguintes valores de atributos:
RelationType igual a composition;
Source associado com a instância da metaclasse ExternalUse B ou C;
E target associado com a instância da metaclasse InternalUse A_ Regra&amp; 5 -- Um produto de trabalho externo ou interno (ExternalUse ou InternalUse) não pode ser o &quot;todo «num relacionamento de agregação se uma de suas &quot;partes «já representa o seu &quot;todo «em outro relacionamento de agregação ou representa o seu &quot;todo «por a transitividade da relação de agregação.
Semântica: Dado que existe uma instância da metaclasse WorkProductUseRelationship 1 com o seguintes valores de atributos:
RelationType igual a agreggation;
Source associado com a instância da metaclasse InternalUse A;
E target associado com as instâncias da metaclasse ExternalUse B e C, não pode existir outra instância da metaclasse WorkProductUseRelationship com os seguintes valores de atributos:
RelationType igual a agreggation;
Source associado com a instância da metaclasse ExternalUse B ou C;
E target associado com a instância da metaclasse InternalUse A_ Regra&amp; 5 -- Um produto de trabalho externo ou interno (ExternalUse ou InternalUse) não pode depender de um produto de trabalho externo ou interno (ExternalUse ou InternalUse) que já é seu dependente.
Semântica: Dado que existe uma instância da metaclasse WorkProductUseRelationship 1 com o seguintes valores de atributos:
RelationType igual a dependency;
Source associado com a instância da metaclasse InternalUse A;
E target associado com as instâncias da metaclasse ExternalUse B e C, não pode existir outra instância da metaclasse WorkProductUseRelationship com os seguintes valores de atributos:
WorkProductUseRelationship onde o valor do atributo relationType é igual a &quot;composition «e o valor do atributo target dessas instâncias possuem a mesma instância da metaclasse ExternalUse ou da metaclasse InternalUse.
Dando sequência à definição das regras de boa-formação ainda relacionadas com os produtos de trabalho (internos e externos) e seus relacionamentos, definiram- se duas novas regras que estabelecem, respectivamente, que toda instância da metaclasse ProcessParameter deverá estar associada a um produto de trabalho do tipo interno ou externo e que todo produto de trabalho do tipo interno deverá possuir uma associação com a metaclasse ProcessResponsabilityAssignment.
Essa última regra torna- se necessária para que todo produto de trabalho interno, o qual é obrigatoriamente produzido num processo de software, esteja relacionado com ao menos um papel responsável por sua produção.
Em esse sentido, faz- se necessário considerar que ambas as regras citadas acima, as quais serão apresentadas a seguir, já estão expressas no metamodelo (ver Figura 26) com as alterações realizadas sobre a multiplicidade das relações entre os elementos WorkProductUse e ProcessParameter e, também, entre os elementos ExternalUse e ProcessResponsabilityAssignment.
Regra&amp; 4 ­ Uma parâmetro de entrada e/ ou saída (ProcessParameter) de uma atividade deve estar sempre associado a exatamente um produto de trabalho do tipo interno ou externo (InternalUse ou ExternalUse).
Semântica: Toda instância da metaclasse ProcessParameter deve possuir uma instância da metaclasse ExternalUse ou da metaclasse InternalUse associada a seu atributo parameterType.
Regra&amp; 8 ­ Um produto de trabalho do tipo interno (InternalUse) deve possuir ao menos um relacionamento com a metaclasse ProcessResponsabilityAssignment.
Semântica: Toda instância da metaclasse InternalUse deve estar associada ao atributo linkedWorkProductUse de pelo menos uma instância da metaclasse ProcessResponsabilityAssignment.
Outras regras de boa-formação estabelecidas para o pacote Process Structure são relacionadas com os aspectos de duplicidade e opcionalidade e envolvem os elementos de processo Atividade, Produto de Trabalho e Papel e os seus relacionamentos.
Essas regras, descritas abaixo, estabelecem, respectivamente, que nenhum elemento de processo ou um de seus relacionamentos devem ser definidos mais de uma vez num processo de software, assim como que informações de opcionalidade devem ser consistentes entre si.
Não é possível definir uma instância de atividade como opcional num processo, por exemplo, se essa atividade possui instâncias de elementos internos definidos como obrigatórios.
Regra&amp; 25 ­ Uma atividade (Activity) opcional não deve possuir elementos obrigatórios.
Semântica: Toda instância da metaclasse Activity que possui o valor &quot;true «para o atributo isOptional não deve possuir como parte nenhuma instância das metaclasses InternalUse, ExternalUse e RoleUse com o valor &quot;false «para seus respectivos atributos isOptional.
Regra&amp; 29 ­ Um produto de trabalho do tipo interno (InternalUse) obrigatório deve ser associado a pelo menos um papel (RoleUse) obrigatório.
Semântica: Toda instância da metaclasse ExternalUse que possui o valor' false` para o atributo isOptional deve estar associada ao atributo linkedWorkProductUse de pelo menos uma instância da metaclasse ProcessResponsabilityAssignment, onde o atributo linkedRoleUse dessa instância de ProcessResponsabilityAssignment deve ser associado a uma instância da metaclasse de RoleUse que possui o atributo isOptional igual a'false'.
Regra&amp; 33 ­ Não pode existir mais de um papel (RoleUse) com o mesmo nome num processo de software.
Semântica: Não pode existir mais de uma instância da metaclasse RoleUse com o mesmo valor para o atributo name.
Regra&amp; 34 ­ Não pode mais de um produto de trabalho do tipo externo (ExternalUse) com o mesmo nome num processo de software.
Semântica: Não pode existir mais de uma instância da metaclasse ExtenalUse com o mesmo valor para o atributo name.
Regra&amp; 34 ­ Não pode existir mais de um produto de trabalho do tipo interno (InternalUse) com o mesmo nome num processo de software.
Semântica: Não pode existir mais de uma instância da metaclasse InternalUse com o mesmo valor para o atributo name.
Regra&amp; 36 ­ Um papel (RoleUse) não pode ser definido mais de uma vez como responsável por o mesmo produto de trabalho do tipo externo ou interno (ExternalUse ou InternalUse).
Semântica: Não pode existir mais de uma instância da metaclasse ProcessResponsabilityAssignment que possui a mesma instância da metaclasse ExternalUse ou da metaclasse InternalUse selecionada para o atributo linkedWorkProductUse e a mesma instância da metaclasse RoleUse selecionada para o atributo linkedRoleUse.
Regra&amp; 37 ­ Um produto de trabalho do tipo externo ou interno (ExternalUse ou InternalUse) não pode ser definido mais de uma vez como dependente do mesmo produto de trabalho do tipo externo ou interno (ExternalUse ou InternalUse).
Semântica: Não pode existir mais de uma instância da metaclasse WorkProductUseRelationship que possua o valor &quot;dependency «para o atributo relationType e que possua a mesma instância da metaclasse ExternalUse ou da metaclasse InternalUse selecionada para o atributo source e a mesma instância da metaclasse ExternalUse ou da metaclasse InternalUse selecionada para o atributo target.
Regra&amp; 38 ­ Um produto de trabalho do tipo externo ou interno (ExternalUse ou InternalUse) não pode ser definido mais de uma vez como o todo, através de uma relação de composição, do mesmo produto de trabalho do tipo externo ou interno (ExternalUse ou InternalUse).
Semântica: Não pode existir mais de uma instância da metaclasse WorkProductUseRelationship que possua o valor &quot;composition «para o atributo relationType e que possua a mesma instância da metaclasse ExternalUse ou da metaclasse InternalUse selecionada para o atributo source e a mesma instância da metaclasse ExternalUse ou da metaclasse InternalUse selecionada para o atributo target.
Regra&amp; 39 ­ Um produto de trabalho do tipo externo ou interno (ExternalUse ou InternalUse) não pode ser definido mais de uma vez como o todo, através de uma relação de agregação, do mesmo produto de trabalho do tipo externo ou interno (ExternalUse ou InternalUse).
Semântica: Não pode existir mais de uma instância da metaclasse WorkProductUseRelationship que possua o valor &quot;agregation «para o atributo relationType e que possua a mesma instância da metaclasse ExternalUse ou da metaclasse InternalUse selecionada para o atributo source e a mesma instância da metaclasse ExternalUse ou da metaclasse InternalUse selecionada para o atributo target.
Regras de boa-formação relacionadas com a consistência do sequenciamento de atividades também foram determinadas.
Tais regras envolvem as metaclasses WorkBreakdownElement, WorkSequence, Activity e as metaclasses de enumeração WorkSequenceKind e WorkBreakdownElementKind.
As primeiras regras de formação para consistência do sequenciamento de atividades são relacionadas com os nodos iniciais e finais de um processo de software e estabelecem:
Todo processo deve possuir exatamente um nodo inicial e um nodo final;
O nodo inicial de um processo de software não deve ser conectado como sucessor para nenhuma atividade desse processo;
O nodo final de um processo de software não deve ser conectado como predecessor para nenhuma atividade desse processo;
O nodo inicial de um processo de software deve ser o predecessor para pelo menos uma atividade desse processo;
E o nodo final de um processo de software deve ser o sucessor para pelo menos uma atividade desse processo.
Um processo de software deve possuir exatamente um nodo final.
Semântica: Apenas uma instância da metaclasse Activity com o valor do atributo specialNode igual a &quot;end «deverá ser instanciada num processo de software.
Regra&amp; 13 ­ Um processo de software deve possuir exatamente um nodo inicial.
Semântica: Apenas uma instância da metaclasse Activity com o valor do atributo specialNode igual a &quot;start «deverá ser instanciada num processo de software.
Regra&amp; 14 ­ O nodo inicial não pode ser sucessor para nenhuma atividade no sequenciamento definido num processo de software.
Semântica: Uma instância da metaclasse Activity que possui o valor do atributo specialNode igual a &quot;start «não pode estar associada no atributo successor de uma instância da metaclasse WorkSequence.
Regra&amp; 15 ­ O nodo final não pode ser predecessor para nenhuma atividade no sequenciamento definido num processo de software.
Semântica: Uma instância da metaclasse Activity que possui o valor do atributo specialNode igual a &quot;end «não pode estar associada no atributo predecessor de uma instância da metaclasse WorkSequence.
Regra&amp; 43 ­ O nodo inicial deve ser definido como predecessor para pelo menos uma atividade no sequenciamento definido num processo de software.
Semântica: Toda instância da metaclasse Activity que possui o valor do atributo specialNode igual a &quot;start «deve estar associada no atributo predecessor de pelo menos uma instância da metaclasse WorkSequence.
Regra&amp; 44 ­ O nodo final deve ser definido como sucessor para pelo menos uma atividade no sequenciamento definido num processo de software.
Semântica: Toda instância da metaclasse Activity que possui o valor do atributo specialNode igual a &quot;end «deve estar associada no atributo successor de pelo menos uma instância da metaclasse WorkSequence.
Seguindo com as regras de boa-formação para consistência do sequenciamento de atividades num processo de software, apresenta- se a seguir uma regra de boaformação que respeita uma definição específica desta pesquisa.
Tal definição estabelece que todo nodo inicial e final que estiver conectado, respectivamente, como predecessor e sucessor para outras atividades do processo, através de instâncias da metaclasse WorkSequence deve ser conectado com o tipo de sequência finishToStart.
Em o caso específico do nodo inicial, isso fará com que todas as conexões que partem desse nodo para outras atividades do processo sejam do tipo finishToStart.
Já no caso de o nodo final, a definição faz com que todas as conexões que chegam de outras atividades para esse nodo sejam do tipo finishToStart, ou seja, todas as atividades do processo precisam terminar para a chegada do nodo final desse processo.
Regra&amp; 45 ­ O sequenciamento estabelecido entre as atividades e o nodo inicial ou final num processo de software deve ser realizado através do tipo de sequenciamento finishToStart.
Semântica: Toda instância da metaclasse Activity que possui o valor do atributo specialNode igual a &quot;start «ou &quot;end «só pode ser associada com instâncias da metaclasse WorkSequence que possuem valor do atributo linkKind igual a &quot;finishToStart».
Outras regras de boa-formação necessárias são as regras que estabelecem que os nodos inicial e final não podem ter relação com outros elementos de processo que não sejam especificamente relações de sequenciamento com outras atividades.
O motivo para essa definição e criação de regras é devido a o fato das atividades que representam os nodos inicial e final de um processo serem consideradas nesta pesquisa como tipos de atividades especiais.
Em esse contexto, as regras de boa-formação a seguir estabelecem:
As atividades que representam os nodos inicial e final não devem estar associadas a papéis através de instâncias da metaclasse ProcessPerformer;
E as atividades que representam os nodos inicial e final de um processo não devem possuir elementos.
Regra&amp; 41 ­ As atividades do processo que representam os nodos inicial e final não devem ser associados com instâncias da metaclasse ProcessPerformer.
Semântica: Toda instância da metaclasse Activity que possui o valor do atributo specialNode igual a &quot;start «ou &quot;end «não pode estar associada no atributo linkedTaskUse de nenhuma instância da metaclasse ProcessPerformer.
Regra&amp; 42 ­ As atividades do processo que representam os nodos inicial e final não devem possuir elementos.
Semântica: Nenhuma instância da metaclasse Activity que possui o valor do atributo specialNode igual a &quot;start «ou &quot;end «não pode possuir outras instâncias através de um relacionamento de composição com metaclasses que mantém relacionamento de herança com a metaclasse BreakdownElement.
O número de situações possíveis para formação de ciclos envolvendo o sequenciamento de duas atividades é dezesseis.
Esse número é resultado de todas as combinações possíveis com as transições (finishToStart, startToStart, finishToFinish e startToFinish) propostas por o metamodelo original SPEM 2.
0. Em a montagem dos gráficos para as dezesseis combinações, como o mostrado na Figura 28, encontrou- se como resultado a formação de deadlocks em sete situações.
Todos os resultados podem ser vistos na Tabela 12.
Tabela 12 ­ Combinações para as transições possíveis entre duas atividades 1 1 2 3 4 5 6 Linhas 2 3 Ss deadlock deadlock Colunas 4 A Ss SF FF Fs SF deadlock FF deadlock Fs deadlock deadlock deadlock 5 6 Para demonstrar como a Tabela 12 foi montada, a Figura 29 mostra o exemplo da combinação de transições da coluna 5 e da linha 6 dessa tabela.
Exatamente nesta célula (coluna 5 e linha 6) o resultado indicado é um deadlock para as combinações de transições.
Interpretando as informações dos cabeçalhos da coluna 5 e da linha 6, obtémse como resultado o sequencimento mostrado no lado esquerdo na Figura 29.
O lado direito desta Figura mostra o gráfico que contém uma linha de tempo no eixo X e as atividades A e B no eixo Y. Ainda na Figura 29, em verde, a execução das atividades A e B, respeitando a transição FF, é mostrada e, em vermelho, apresenta- se a execução das atividades A e B, respeitando a transição Fs.
Nota- se, também na mesma figura, que nenhuma execução que respeita ambas as transições FF e Fs foi mostrada.
O fato para que isto tenha ocorrido é que a combinação das transições mostradas nessa imagem forma um deadlock entre as atividades A e B_ O deadlock ocorre porque o fim da atividade A precisa acontecer para que B termine e o fim da atividade B precisa acontecer para que A inicie.
Sequenciamento definido para atividades do metamodelo SPEM 2.
0 com inclusão de nova transição obtida através de informações sobre transitividade das relações A nova transição, que é destacada em vermelho na Figura 30, forma agora, um ciclo apenas entre as atividades B e D com ambas as transições entre os estes elementos do tipo finishToStart.
Consultando a Tabela 12, já foi explicada acima, torna- se possível identificar a formação de um deadlock entre as atividades B e D, o que, por consequência, indica um deadlock no ciclo entre as atividades B, C e D mostrado na Figura 30.
Prosseguindo com a avaliação sobre os ciclos entre as atividades da Figura 27, analisaram- se as transições entre as atividades E, F e G para a tentativa de simplificação desse ciclo para apenas duas atividades.
Uma vez que existem duas transições (finishToFinish e startToStart) entre as atividades E e F, foram realizadas duas análises.
Assim, as primeiras transições analisadas foram as seguintes:
E finishToFinish F;
F finishToFinish G. Utilizando, mais uma vez, as informações sobre transitividade, é possível concluir que se o fim da atividade E precisa acontecer para que F termine e o fim da atividade F precisa acontecer para que G termine, logo, o fim da atividade E precisa acontecer para que G termine.
A partir de essa conclusão, pode- se incluir uma nova transição entre as atividades E e G do tipo finishToFinish.
Continuando com as tentativas de simplificação, analisaramse as seguintes transições para o mesmo ciclo:
E startToStart F;
F finishToFinish G. Para estas, não se encontrou nenhum tipo de conclusão relacionada com as atividades E e G, quando consideradas as informações de transitividade entre as relações de sequenciamento.
De essa forma, não foi possível a simplificação do ciclo entre as atividades E, F e G para um ciclo que contivesse apenas duas atividades, o que impossibilitou, até este momento da pesquisa, saber se esse ciclo representa ou não um deadlock no sequenciamento estabelecido na Figura 27.
Baseado no contexto acima, a tentativa de simplificar os ciclos, através das informações de transitividade para a descoberta de deadlocks, foi descartada.
A nova solução adotada foi a interpretação das transições (finishToStart, startToStart, finishToFinish e startToFinish) propostas por o metamodelo original SPEM 2.
0, utilizando- se dos conceitos atividade_ início e atividade_ fim, os quais foram propostos por esta pesquisa.
Com isso, pretende-se que todas as atividades envolvidas num sequenciamento sejam divididas em atividade_ início e atividade_ fim e que seja incluída para estas atividades uma transição que parte da atividade_ início e chega à atividade_ fim, indicando sempre que o início de uma atividade precede o seu fim.
Após esses passos, qualquer uma das transições propostas por o metamodelo original SPEM 2.
0 pode ser redefinida, utilizando os inícios e fins de cada atividade.
A Figura 31, mostra como um exemplo da solução proposta, a transformação de um sequenciamento realizado entre atividades com as transições indicadas por o metamodelo original SPEM 2.
0 para o sequenciamento que utiliza os novos conceitos de atividade_ início e atividade_ fim.
Observa- se na Figura 31 que ambos os sequenciamentos 1 e 2 representam grafos direcionados4.
Contudo, o primeiro grafo possui informações nas arestas, o que, como já mencionado acima, dificulta a identificação de deadlocks num processo de software.
De essa forma, nesta pesquisa, assume- se a utilização de grafos direcionados como o mostrado na parte direita da Figura 31 (representado por o sequenciamento 2).
Além disso, outra definição estabelecida por esta pesquisa é que, para a obtenção de um sequenciamento consistente, o grafo resultante (após a transformação para um grafo com atividades_ início eatividades_ fim) deve ser acíclico e não possuir Um grafo é comumente representado como um par ordenado (V, A), em que V é o conjunto dos vértices do grafo, e A o conjunto das arestas.
Os grafos direcionados são conhecidos como digrafos, grafos dirigidos ou grafos orientados e são tidos como grafos onde as arestas A são ordenadas (direcionadas), ou seja, a aresta (V1, V2) é diferente da aresta (V2, V1).
Nota- se, na Figura 32, que algumas arestas, as quais formam ciclos no grafo, foram destacadas em vermelho.
Isso ocorreu, porque, como mencionado acima, a formação de ciclos representa inconsistências (nesse caso, deadlocks) num sequenciamento que se utiliza da solução proposta nesta pesquisa.
Toda explicação anterior foi realizada com o objetivo de encontrar inconsistências relacionadas com os deadlocks de um processo de software.
Contudo, a nova solução proposta para o sequenciamento de atividades, também auxilia na identificação de outras inconsistências tais como a garantia de que todas as atividades são iniciadas após o nodo inicial e finalizadas antes do nodo final.
Embora esta possa parecer uma situação trivial, dificuldades foram encontradas, quando considerada somente a solução de sequenciamento proposta por o metamodelo original SPEM 2.
0. Um exemplo prático dessas dificuldades é ilustrado na Figura 33 que mostra um pequeno conjunto de atividades sequenciadas.
Depois de explicar o funcionamento da solução proposta para o sequenciamento de atividades, as últimas regras de boa-formação que estabelecem as condições para a definição de um sequenciamento de atividades consistente serão apresentadas.
Como já mencionado, elas são relacionadas com a formação de deadlocks, garantia de ligação de todas as atividades com os nodos inicial e final e ausência de transições duplicadas num sequenciamento.
Tais regras de boa-formação são:
Regra&amp; 16 ­ O sequenciamento de atividades não deve possuir situações que representem um deadlock na execução de um processo de software.
Semântica: Após a divisão das atividades em atividade_ início e atividade_ fim e a simplificação das informações sobre as transições não devem existir em nenhum ponto do sequenciamento resultante ciclos e laços.
Regra&amp; 17 ­ Não pode existir mais de uma transição igual entre duas atividades num sequenciamento.
Semântica: Não pode existir duas ou mais instâncias da metaclasse WorkSequence que possuam o mesmo valor para o atributo linkKind e que possuam a mesma instância da metaclasse Activity selecionada para o atributo predecessor, bem como a mesma instância da metaclasse Activity selecionada para o atributo successor.
Regra&amp; 18 ­ Todas as atividades que são sequenciadas num processo de software deverão ter ligação com o nodo inicial e final do processo para garantir que toda atividade é iniciada após o nodo inicial e possui seu término antes do nodo final.
Semântica: Após a divisão das atividades em atividade_ início e atividade_ fim e a simplificação das informações sobre as transições, toda atividade_ início deve possuir pelo menos uma aresta chegando nessa atividade e toda atividade_ fim deve possuir pelo menos uma aresta partindo para outra atividade.
Embora todo conjunto de regras de boa-formação relacionadas com o sequenciamento de atividades tenha sido apresentado acima, um fato importante, o qual não foi explicado até o momento, diz respeito a como o sequenciamento funciona quando uma ou mais atividades possuem subatividades.
Esse é o caso do exemplo mostrado na Figura 35, em o qual as atividades superiores da estrutura mostrada são sequenciadas e possuem subatividades que, por sua vez, também são divididas em novas subatividades.
Analisando a Figura 35, observa- se que todas as atividades estão sequenciadas.
Isso porque o sequenciamento realizado nas atividades superiores é passado por transitividade para suas atividades inferiores.
Interpretando o sequenciamento, tem- se que a atividade A deve ser executada antes da atividade B_ Como a atividade A é composta por por as atividades A1 e A2 que, por sua vez, são compostas, respectivamente, por as atividades A1.
1, A1.
2 e A2.
1 e A2.
2, diz- se que todo esse conjunto de atividades deve ter sua execução terminada para que qualquer subatividade de B possa ser iniciada.
As últimas regras de boa-formação definidas foram para o autorrelacionamento usedActivity da metaclasse Activity e para o relacionamento supressedBreakdownElement que é definido entre as metaclasses Activity e BreakdownElement.
Contudo, como esses relacionamentos são considerados como mecanismos de adaptação de processos do metamodelo original SPEM 2.
0, suas regras de boa-formação serão detalhadas na Seção 4.4 deste trabalho.
Em esta seção as alterações e regras de boa-formação incluídas no pacote Method Content serão apresentadas.
Antes disso, a relação das alterações e regras de boaformação com as premissas definidas para esta pesquisa é mostrada na Tabela 13.
Em esta tabela, é possível observar que algumas regras de boa-formação e premissas também não são relacionadas com alterações em metaclasses e relações do metamodelo sSPEM 2.0, assim como no pacote Process Structure.
Isso ocorre, mais uma vez, devido a o fato de que o atendimento de algumas premissas não exige modificações sobre metaclasses e relações, mas envolve apenas a definição de algumas regras que controlem a instanciação desses elementos num processo de software.
As mudanças realizadas no pacote Method Content foram feitas apenas sobre as metaclasses WorkProductDefinitionRelationship, WorkProductDefinition e Default_ TaskDefinitionParameter e têm o mesmo significado de alterações já realizadas sobre as metaclasses WorkProductUseRelationship, WorkProductUse e ProcessParameter do pacote Process Structure.
Tais alterações são:
A inclusão do atributo relationType para a metaclasse WorkProductDefinitionRelationship;
A inclusão da metaclasse do tipo enumeração chamada WorkProductRelationshipKind que define os valores válidos (dependência, composição e agregação) para o atributo relationType;
E a alteração da multiplicidade no relacionamento entre as metaclasses parameterType.
Regra&amp; 5 -- Um produto de trabalho (WorkProductDefinition) não pode ser o &quot;todo «num relacionamento de composição se uma de suas &quot;partes «já representa o seu &quot;todo «em outro relacionamento de composição ou representa o seu &quot;todo «por a transitividade da relação de composição.
Semântica: Dado que existe uma instância da metaclasse WorkProductDefinitionRelationship 1 com o seguintes valores de atributos:
RelationType igual a composition;
Source associado com a instância da metaclasse WorkProductDefinition A;
E target associado com as instâncias da metaclasse WorkProductDefinition B e C, não pode existir outra instância da metaclasse WorkProductDefinitionRelationship com os seguintes valores de atributos:
RelationType igual a composition;
Source associado com a instância da metaclasse WorkProductDefinition B ou C;
E target associado com a instância da metaclasse WorkProductDefinition A_ Regra&amp; 5 -- Um produto de trabalho (WorkProductDefinition) não pode ser o &quot;todo «num relacionamento de agregação se uma de suas &quot;partes «já representa o seu &quot;todo «em outro relacionamento de agregação ou representa o seu &quot;todo «por a transitividade da relação de agregação.
Semântica: Dado que existe uma instância metaclasse WorkProductDefinitionRelationship 1 com o seguintes valores de atributos:
RelationType igual a agreggation;
Source associado com a instância da metaclasse WorkProductDefinition A;
E target associado com as instâncias da metaclasse WorkProductDefinition B e C, não pode existir outra instância da metaclasse WorkProductDefinitionRelationship com os seguintes valores de atributos:
RelationType igual a agreggation;
Source associado com a instância da metaclasse WorkProductDefinition B ou C;
E target associado com a instância da metaclasse WorkProductDefinition A_ Regra&amp; 5 -- Um produto de trabalho (WorkProductDefinition) não pode depender de um produto de trabalho (WorkProductDefinition) que já é seu dependente.
Semântica: Dado que existe uma instância da metaclasse WorkProductDefinitionRelationship 1 com o seguintes valores de atributos:
RelationType igual a dependency;
Source associado com a instância da metaclasse WorkProductDefinition A;
E target associado com as instâncias da metaclasse WorkProductDefinition B e C, não pode existir outra instância da metaclasse WorkProductDefinitionRelationship com os seguintes valores de atributos:
RelationType igual a dependency;
Source associado com a instância da metaclasse WorkProductDefinition B ou C;
E target associado com a instância da metaclasse WorkProductDefinition A_ Regra&amp; 49 -- Um produto de trabalho (WorkProductDefinition) não pode representar o &quot;todo «e a &quot;parte «num relacionamento de composição.
Semântica: Uma instância da metaclasse WorkProductDefinitionRelationship que possui o valor &quot;composition «para o atributo relationType não pode possuir a mesma instância da metaclasse WorkProductDefinition associada nos seus atributos source e target.
Regra&amp; 49 -- Um produto de trabalho (WorkProductDefinition) não pode representar o &quot;todo «e a &quot;parte «num relacionamento de agregação.
Semântica: Uma instância da metaclasse WorkProductDefinitionRelationship que possui o valor &quot;agregation «para o atributo relationType não pode possuir a mesma instância da metaclasse WorkProductDefinition associada nos seus atributos source e target.
Regra&amp; 49 -- Um produto de trabalho (WorkProductDefinition) não pode depender de si próprio.
Semântica: Uma instância da metaclasse WorkProductDefinitionRelationship que possui o valor &quot;dependency «para o atributo relationType não pode possuir a mesma instância da metaclasse WorkProductDefinition associada nos seus atributos source e target.
Regra&amp; 7 -- Um produto de trabalho (WorkProductDefinition) não pode ser &quot;parte «em mais de um relacionamento de composição.
Semântica: Não podem existir duas ou mais instâncias da metaclasse (WorkProductDefinition) devem estar conectadas como entrada nas suas tarefas (TaskDefinition) de produção.
Semântica: Dado que existe uma instância da metaclasse Semântica.
Não pode existir mais de uma instância da metaclasse RoleDefinition com o mesmo valor para o atributo name.
Regra&amp; 34 ­ Não pode existir mais de um produto de trabalho (WorkProductDefinition) com o mesmo nome no repositório (Method Content).
Semântica: Não pode existir mais de uma instância da metaclasse WorkProductDefinition com o mesmo valor para o atributo name.
Regra&amp; 35 ­ Um papel (RoleDefinition) não pode ser definido mais de uma vez como executor da mesma tarefa (TaskDefinition).
Semântica: Não pode existir mais de uma instância da metaclasse Default_ TaskDefinitionPerformer que possua a mesma instância da metaclasse RoleDefinition selecionada para o atributo linkedRoleDefinition e a mesma instância da metaclasse TaskDefinition selecionada para o atributo linkedTaskDefinition.
Regra&amp; 36 ­ Um papel (RoleDefinition) não pode ser definido mais de uma vez como responsável por o mesmo produto de trabalho (WorkProductDefinition).
Semântica: Não pode existir mais de uma instância da metaclasse Default_ ResponsabilityAssignment que possua a mesma instância da metaclasse WorkProductDefinition selecionada para o atributo linkedWorkProductDefinition e a mesma instância da metaclasse RoleDefinition selecionada para o atributo linkedRoleDefinition.
Regra&amp; 37 ­ Um produto de trabalho (WorkProductDefinition) não pode ser definido mais de uma vez como dependente do mesmo produto de trabalho (WorkProductDefinition).
Semântica: Não pode existir mais de uma instância da metaclasse WorkProductDefinitionRelationship que possua o valor &quot;dependency «para o atributo relationType e que possua a mesma instância da metaclasse WorkProductDefinition selecionada para o atributo source e a mesma instância da metaclasse WorkProductDefinition selecionada para o atributo target.
Regra&amp; 38 ­ Um produto de trabalho (WorkProductDefinition) não pode ser definido mais de uma vez como o todo, através de uma relação de composição, do mesmo produto de trabalho (WorkProductDefinition).
Semântica: Não pode existir mais de uma instância da metaclasse WorkProductDefinitionRelationship que possuam o valor &quot;composition «para o atributo relationType e que possua a mesma instância da metaclasse WorkProductDefinition selecionada para o atributo source e a mesma instância da metaclasse WorkProductDefinition selecionada para o atributo target.
Regra&amp; 39 ­ Um produto de trabalho (WorkProductDefinition) não pode ser definido mais de uma vez como o todo, através de uma relação de agregação, do mesmo produto de trabalho (WorkProductDefinition).
Semântica: Não pode existir mais de uma instância da metaclasse WorkProductDefinitionRelationship que possua o valor &quot;agregation «para o atributo relationType e que possua a mesma instância da metaclasse WorkProductDefinition selecionada para o atributo source e a mesma instância da metaclasse WorkProductDefinition selecionada para o atributo target.
Regra&amp; 40 -- Uma tarefa (TaskDefinition) não pode possuir dois ou mais parâmetros de entrada e/ ou saída (Default_ TaskDefinitionParameter) iguais.
Semântica: Nenhuma instância da metaclasse TaskDefinition pode possuir mais de uma instância da metaclasse Default_ TaskDefinitionParameter com os mesmos valores para os atributos direction e parameterType.
WorkProductPackage, ToolPackage, RolePackage MethodContentRelationshipPackage.
Todas as novas metaclasses incluídas foram associadas através de um relacionamento de composição com a metaclasse já existente no metamodelo SPEM 2.
0, denominada MethodContentPackage, conforme mostrado na Figura 38.
Analogamente às inclusões descritas acima, outras metaclasses foram incluídas, contudo, agora, com objetivo de organizar os elementos do processo em pacotes de elementos e relacionamentos.
As novas metaclasses são:
TaskUsePackage, e RoleUsePackage, WorkProductUsePackage, ProcessRelationshipPackage ActivityPackage.
Elas foram associadas através de um relacionamento de composição com a metaclasse já existente no metamodelo SPEM 2.
0, denominada ProcessPackage, conforme mostrado na Figura 39.
Regra&amp; 10 ­ Uma tarefa (TaskUse) deve possuir ao menos um relacionamento com a metaclasse ProcessPerformer.
Semântica: Toda instância da metaclasse TaskUse deve estar associada no atributo linkedTaskUse de pelo menos uma instância da metaclasse ProcessPerformer.
Regra&amp; 48 ­ Um papel (RoleUse) deve possuir ao menos um relacionamento com a metaclasse ProcessPerformer.
Semântica: Toda instância da metaclasse RoleUse deve estar associada no atributo linkedRoleUse de pelo menos uma instância da metaclasse ProcessPerformer.
Seguindo com a definição das regras de boa-formação para o elemento de processo tarefa e para os outros elementos de processo relacionados com este elemento tem- se:
Regra&amp; 9 ­ Uma tarefa (TaskUse) deve modificar ao menos um produto de trabalho do tipo interno ou externo (InternalUse ou ExternalUse) e/ ou produzir ao menos um produto de trabalho do tipo interno (InternalUse).
Semântica: Toda instância da metaclasse TaskUse deve possuir ao menos uma instância da metaclasse ProcessParameter com o valor do atributo direction igual a &quot;out «ou &quot;inout».
Regra&amp; 11 ­ Todas as dependências de um produto de trabalho do tipo interno (InternalUse) devem estar conectadas como entrada nas suas tarefas (TaskUse) de produção.
Semântica: Dado que existe uma instância da metaclasse WorkProductUseRelationship 1 com o seguintes valores de atributos:
RelationType igual a dependency;
Source associado com a instância da metaclasse InternalUse A;
E target associado com as instâncias da metaclasse ExternalUse B e C. E, que a instância da metaclasse InternalUse A está associada a uma instância da metaclasse TaskUse T1 através de uma instância da metaclasse ProcessParameter com o valor do atributo direction igual a &quot;out».
Em esse caso, as instâncias da metaclasse ExternalUse B e C deverão também estar associadas a instância da metaclasse TaskUse T1 através de instâncias da metaclasse ProcessParameter com o valor do atributo direction igual a &quot;in».
Regra&amp; 24 ­ Toda tarefa (TaskUse) que produz um produto de trabalho do tipo interno (InternalUse) deverá estar associada com ao menos um papel (RoleUse) que é responsável por este produto de trabalho.
Semântica: Dado que existe 1 com uma os instância seguintes da valores metaclasse de atributo:
ProcessResponsabilityAssignment linkedWorkProductUse associado com a instância da metaclasse InternalUse A e linkedRoleUse associado com a instância da metaclasse RoleUse R1.
E, que a instância da metaclasse InternalUse A está associada a uma instância da metaclasse TaskUse T1 através de uma instância da metaclasse ProcessParameter com o valor do atributo direction igual a &quot;out».
Em esse caso, deverá existir uma instância da metaclasse ProcessPerformer com o seguintes valores de atributo:
LinkedTaskUse associado com a instância da metaclasse TaskUse T1 e linkedRoleUse associado com a instância da metaclasse RoleUse R1.
Outras regras de boa-formação, envolvendo o elemento de processo tarefa e o elemento de processo atividade também foram estabelecidas.
Essas regras definem, respectivamente, que toda atividade deve possuir pelo menos uma tarefa e que as entradas e saídas de uma atividade devem ser compatíveis com as entradas e saídas de suas atividades e tarefas internas.
Caso exista, por exemplo, um parâmetro (ProcessParameter) na atividade A (Activity) indicando que ela produz o produto de trabalho interno X (InternalUse), deve existir pelo menos uma instância de tarefa (TaskUse) dentro de a atividade A que produz o produto de trabalho interno X (InternalUse).
Regra&amp; 21 ­ Uma atividade (Activity) deve possuir ao menos uma tarefa (TaskUse).
Semântica: Toda instância da metaclasse Activity deve possuir como parte ao menos uma instância da metaclasse TaskUse.
Regra&amp; 22 ­ Os parâmetros de entrada e/ ou saída (ProcessParameter) de uma atividade (Activity) devem ser compatíveis com os parâmetros de entrada e/ ou saída (ProcessParameter) de suas tarefas (TaskUse).
Semântica: Para toda instância da metaclasse ProcessParameter que é associada com uma instância da metaclasse Activity 1 deve existir outra instância da metaclasse ProcessParameter com os mesmos valores para os atributos direction e parameterType.
Esta outra instância da metaclasse ProcessParameter deverá estar associada a uma instância da metaclasse TaskUse que é parte da metaclasse Activity 1.
Prosseguindo com a definição de regras de boa-formação para o elemento tarefa, têm- se as regras para este elemento relacionadas com os aspectos de duplicidade e opcionalidade.
Tais regras são:
Regra&amp; 23 ­ Um papel (RoleUse) obrigatório deve ser associado a pelo menos uma tarefa (TaskUse) obrigatória.
Semântica: Toda instância da metaclasse RoleUse que possui o valor' false` para o atributo isOptional deve estar associada ao atributo linkedRoleUse de pelo menos uma instância da metaclasse ProcessPerformer, onde o atributo linkedTaskUse dessa instância de ProcessPerformer deve ser associado a uma instância da metaclasse de TaskUse que possui o atributo isOptional igual a'false'.
Regra&amp; 25 ­ Uma atividade (Activity) opcional não deve possuir elementos obrigatórios.
Semântica: Toda instância da metaclasse Activity que possui o valor &quot;true «para o atributo isOptional não deve possuir como parte nenhuma instância das metaclasses InternalUse, ExternalUse, TaskUse e RoleUse com o valor &quot;false «para seus respectivos atributos isOptional.
Regra&amp; 26 ­ Uma atividade (Activity) obrigatória devel possuir ao menos uma tarefa (TaskUse) obrigatória.
Semântica: Toda instância da metaclasse Activity que possui o valor &quot;false «para o atributo isOptional deve possuir como parte ao menos uma instância da metaclasse TaskUse com o valor &quot;false «para seu atributo isOptional.
Regra&amp; 27 ­ Um produto de trabalho do tipo externo (ExternalUse) obrigatório deve ser consumido e/ ou modificado por pelo menos uma tarefa (TaskUse) obrigatória.
Semântica: Toda instância da metaclasse ExternalUse que possui o valor &quot;false «para o atributo isOptional deve estar associado ao atributo parameterType de por o uma instância da metaclasse ProcessParameter que tenha o valor do atributo direction igual a &quot;in «ou &quot;inout «e que seja parte de uma instância da metaclasse TaskUse com o valor &quot;false «para o atributo isOptional.
Regra&amp; 28 ­ Um produto de trabalho do tipo interno (InternalUse) obrigatório deve ser produzido por pelo menos uma tarefa (TaskUse) obrigatória.
Semântica: Toda instância da metaclasse InternalUse que possui o valor &quot;false «para o atributo isOptional deve estar associado ao atributo parameterType de por o uma instância da metaclasse ProcessParameter que tenha o valor do atributo direction igual a &quot;out «e que seja parte de uma instância da metaclasse TaskUse com o valor &quot;false «para o atributo isOptional.
Regra&amp; 30 ­ Uma tarefa (TaskUse) obrigatória deve modificar pelo menos um produto de trabalho do tipo externo (ExternalUse) obrigatório e/ ou produzir ao menos um produto de trabalho do tipo interno (InternalUse) obrigatório.
Semântica: Toda instância da metaclasse TaskUse que possui o valor &quot;false «para o atributo isOptional deve possuir ao menos uma instância da metaclasse ProcessParameter com o valor do atributo direction igual a &quot;out «e o valor do atributo parameterType associado com uma instância da metaclasse InternalUse que possui o valor &quot;false «para o atributo isOptional ou uma instância da metaclasse ProcessParameter com o valor do atributo direction igual a &quot;inout «e o valor do atributo parameterType associado com uma instância da metaclasse InternalUse ou da metaclasse ExternalUse que possui o valor &quot;false «para o atributo isOptional.&amp;&amp;&amp;
Regra&amp; 31 ­ Toda tarefa (TaskUse) obrigatória que produz um produto de trabalho do tipo interno (InternalUse) obrigatório deverá estar associada com ao menos um papel (RoleUse) obrigatório que é responsável por este produto de trabalho.
Semântica: Dado que existe 1 com uma os instância seguintes da valores metaclasse de atributo:
ProcessResponsabilityAssignment linkedWorkProductUse associado com a instância da metaclasse InternalUse A (com atributo isOptional igual a &quot;false&quot;) e linkedRoleUse associado com a instância da metaclasse RoleUse R1 (com atributo isOptional igual a &quot;false&quot;).
E, que a instância da metaclasse InternalUse A está associada a uma instância da metaclasse TaskUse T1 (com atributo isOptional igual a &quot;false&quot;) através de uma instância da metaclasse ProcessParameter com o valor do atributo direction igual a &quot;out».
Em esse caso, deverá existir uma instância da metaclasse ProcessPerformer com o seguintes valores de atributo:
LinkedTaskUse associado com a instância da metaclasse TaskUse T1 e linkedRoleUse associado com a instância da metaclasse RoleUse R1.
Regra&amp; 32 ­ Um tarefa (TaskUse) obrigatória deve ser associada a pelo menos um papel (RoleUse) obrigatório.
Semântica: Toda instância da metaclasse TaskUse que possui o valor' false` para o atributo isOptional deve estar associada ao atributo linkedTaskUse de pelo menos uma instância da metaclasse ProcessPerfomer, onde o atributo linkedRoleUse dessa instância de ProcessPerfomer deve ser associado a uma instância da metaclasse de RoleUse que possui o atributo isOptional igual a'false'.
Semântica: Toda instância da metaclasse WorkProductUseRelationship que possui o valor do atributo relationType igual a &quot;dependency «deverá ter as instâncias da metaclasse InternalUse que estão associadas no seu atributo target produzidas antes da instância da metaclasse InternalUse que está associada no seu atributo source.
Em um sequenciamento que considera a divisão das tarefas em tarefas_ início e tarefas_ fim isso quer dizer que as intâncias da metaclasse InternalUse associadas no atributo target de uma instância da metaclasse WorkProductUseRelationship deverão ser produzidas por tarefas que precedem a (s) tarefa (s) que produzem a intância da metaclasse InternalUse associada no atributo source da mesma instância da metaclasse WorkProductUseRelationship.
Regra&amp; 20 ­ Todos os produtos de trabalho do tipo interno (InternalUse) devem ser produzidos antes de serem consumidos num processo de software.
Semântica: Para toda instância da metaclasse InternalUse que esta associada a uma instância da metaclasse TaskUse através de uma instância da metaclasse ProcessParameter com o valor do atributo direction igual a &quot;in «ou &quot;inout», deverá existir pelo menos uma associação da mesma instância da metaclasse InternalUse com uma instância da metaclasse TaskUse através de uma instância da metaclasse ProcessParameter com o valor do atributo direction igual a &quot;out».
Considerando a precedência das tarefas, a instância da metaclasse TaskUse que possui a instância da metaclasse ProcessParameter com o valor do atributo direction igual a &quot;out «deverá sempre preceder a tarefa que possui a instância da metaclasse ProcessParameter com o valor do atributo direction igual a &quot;in «ou &quot;inout».
Não foram necessárias alterações para nenhuma metaclasse e/ ou relacionamento do pacote Method Plugin.
Contudo, é necessário considerar que através do mecanismo de merge todos os elementos do metamodelo sSPEM 2.0 estão incluídos no pacote Method Plugin.
Com relação a a definição de regras de boa-formação específicas para o pacote Method Plugin, uma regra foi definida para a metaclasse Variability e seus relacionamentos.
Contudo, considerando que a metaclasse Variability e seus relacionamentos são considerados como mecanismos de adaptação de processos no metamodelo sSPEM 2.0, a regra de boa-formação específica é descrita na próxima seção deste trabalho.
Em esta seção, os mecanismos de adaptação e duas das regras de boa-formação para consistência de um processo de software são apresentados.
Inicialmente, serão descritos os mecanismos de adaptação dos relacionamentos usedActivity e supressedBreakdownElement, os quais são definidos no pacote Process Structure.
Em seguida, será exposto o mecanismo de adaptação da metaclasse Variability, a qual é definida no pacote Method Plugin.
Faz- se necessário considerar que todos os mecanismos acima, embora sejam considerados como mecanismos de adaptação do metamodelo original SPEM 2.
0, podem ser utilizados também para a definição de processos de software.
De esse modo, nas seções seguintes, as diferenças de funcionamento desses mecanismos nas atividades adaptação e definição dos processos de software, serão explicadas.
Salienta- se também que as duas regras de boa-formação que serão apresentadas para os mecanismos usedActivity e Variability não foram relacionadas com nenhuma premissa para consistência de processos de software identificadas nesta pesquisa.
Isso porque tais regras são específicas dos mecanismos usedActivity e Variability e foram definidas para garantir alguns aspectos de consistência durante a aplicação desses mecanismos.
O relacionamento usedActivitiy é definido no pacote Process Structure como um autorrelacionamento para a metaclasse Activity.
Este relacionamento, detalhado na Seção 2.6.1.5 deste trabalho, é considerado como um mecanismo de adaptação do metamodelo original SPEM 2.
0, pois permite que o conteúdo definido para uma atividade seja reutilizado em outras atividades de um mesmo processo de software ou, até mesmo, a partir de atividades de outros processos.
Isso possibilita, por exemplo, o reuso de um processo completo, já que, no metamodelo original SPEM 2.
0, e também no metamodelo sSPEM 2.0, o elemento atividade é indicado como o elemento a ser usado para instanciação de processos de software.
Nenhuma alteração foi realizada em termos de metaclasses ou relacionamentos no pacote Process Structure, considerando o autorrelacionamento usedActivity.
Contudo, uma regra de boa-formação específica para este relacionamento foi definida.
Além disso, as semânticas dos tipos de herança (extension, localcontribution e localreplacement) definidos para o relacionamento usedActivity também foram alteradas visando manter a consistência das instâncias da metaclasse Activity.
A regra de boa-formação definida para o relacionamento usedActivity estabelece que uma atividade não pode herdar seu próprio conteúdo, ou seja, uma instância de atividade não pode estabelecer um autorrelacionamento usedActivity do tipo extension.
Regra&amp; 46 ­ Uma atividade não pode herdar seu próprio conteúdo.
Semântica: Nenhuma instância da metaclasse Activity deverá possuir um autorrelacionamento usedActivity.
Seguindo com as definições sobre o relacionamento usedActivity, se encontram as alterações realizadas sobre as semânticas dos tipos de herança extension, localContribution e localReplacement.
A primeira modificação realizada foi realizada especificamente sobre os tipos de herança localContribution e localReplacement que são utilizados no metamodelo origianl SPEM 2.
0 em conjunto com o tipo de herança extension.
Tal modificação define que, em ambos os tipos de herança, as atividades que apontam para outras atividades, utilizandose destes valores, não podem estar vazias, ou seja, no caso de uma contribuição (localContribution), algum elemento deve existir na atividade de origem para que realmente exista uma contribuição quando o conteúdo da atividade de destino for herdada.
Já no caso de uma substituição (localReplacement), a atividade de origem não pode estar vazia, uma vez que seu conteúdo substituirá o conteúdo da atividade de destino.
A próxima alteração realizada para o relacionamento usedActivity foi feita sobre os tipos de herança extension e localContribution e diz respeito ao resultado dos elementos herdados quando estes tipos de valores são utilizados.
Em a semântica definida por a especificação do metamodelo original SPEM 2.
0, é dito apenas que, quando uma atividade aponta para outra atividade com o valor do atributo useKind igual a extension, todo conteúdo da atividade que recebe o apontamento deve ser copiado para a atividade que realiza o apontamento.
O mesmo ocorre quando o tipo de herança localContribution é utilizado.
A única diferença é que, para o uso do localContribution ser permitido, ele deve ser utilizado em conjunto com o valor extension e o resultado da interpretação do tipo de herança localContribution é a soma do conteúdo herdado com o conteúdo da atividade que faz o apontamento.
Embora o funcionamento de ambos os tipos de herança citados estejam bem estabelecidos no metamodelo original SPEM 2.
0, algumas inconsistências são encontradas quando o resultado desses mecanismos é analisado em detalhes.
O problema ocorre quando atividades que estão sendo herdadas se relacionam com elementos do processo que estão fora de esta atividade.
Especificamente, sobre essa situação, não são encontradas referências na semântica dos tipos de herança extension e localContribution do metamodelo original SPEM 2.
0. Para facilitar o entendimento do que foi exposto, a Figura 41 mostra um exemplo, contendo uma pequena estrutura de atividades e um relacionamento usedActivity com o tipo de herança extension sendo realizado.
Torna- se importante considerar que, tanto para o exemplo mostrado na Figura 41 quanto para todos os exemplos que serão utilizados nesta seção, várias informações de processo (informações de sequenciamento, criação de nodos inicial e final, entre outros) foram omitidas e dessa forma, os exemplos podem possuir inconsistências de processo.
Isso foi feito apenas como forma de simplificar os exemplos sobre os tipos de herança do relacionamento usedActivity.
Em o exemplo da Figura 41, as metaclasses que representam os relacionamentos ProcessParameter, ProcessResponsabilityAssignment e ProcessPerformer tiveram suas nomenclaturas descritas em inglês por não terem sido traduzidas nesta pesquisa como elementos de processos.
Elas expressam, respectivamente, que a Tarefa 1 produz o Produto de Trabalho P, o Produto de Trabalho P possui como responsável o Papel A e que a Tarefa 1 é desempenhada por o Papel A_ Observa- se, no exemplo, que algumas relações definidas dentro de a Atividade 1.1 utilizam o elemento de processo Papel A definido na sua atividade superior, ou seja, tais relações utilizam um elemento que está fora de a Atividade 1.1.
Ainda observando o exemplo da Figura 44, nota- se que a Atividade 1.2 aponta para a Atividade 1.1, utilizando o relacionamento usedActivity com o tipo de herança extension.
Em esse tipo de situação o metamodelo original SPEM 2.
0 não deixa claro exatamente como devem ser os resultados dos tipos de herança extension e localContribution.
Em esta pesquisa, definiu- se que, nos mecanismos de herança extension e localContribution, todos os elementos que são utilizados por uma atividade, através de seus relacionamentos, e estão definidos em suas atividades superiores (atividades pai) ou estão definidos nos pacotes de elementos, são considerados como parte desta atividade e, desse modo, serão herdados.
Além disso, no caso de a atividade a ser herdada possuir um ou mais elementos envolvidos em instâncias de relacionamentos definidos nos pacotes de relacionamentos, tais relacionamentos deverão ser herdados sempre que possível.
Considera- se também possível herdar uma instância de relacionamento se ele não apresentar nenhuma inconsistência depois da interpretação da herança.
Por exemplo, para que um relacionamento de responsabilidade sobre um produto de trabalho (ProcessResponsabilityAssignment) seja definido sem inconsistências, ele precisa estar associado a exatamente um produto de trabalho e pelo menos um papel.
Assim, considerando um processo que contenha a definição de um relacionamento de responsabilidade definido nos pacotes de relacionamento e a definição do produto de trabalho e do papel que estão associados a este relacionamento em diferentes atividades do processo, só será possível herdar este relacionamento, se ambas as atividades que contém o produto de trabalho e o papel forem herdadas.
O mesmo ocorre com as seguintes relações do processo:
WorkSequence, WorkProductRelationshipUse e ProcessPerformer.
Em o caso específico da relação WorkSequence, que sempre é definida nos pacotes de relacionamento (conforme Seção 5.3) e, para ser consistente, necessita de exatamente uma instância das metaclasses Activity ou TaskUse associada como predecessor, bem como de uma instância das metaclasses Activity ou TaskUse associada como sucessor, sabe- se que esse tipo de relação, muitas vezes, não será herdada, causando, assim, inconsistências no sequenciamento dos processos de software.
Contudo, é importante considerar que, embora inconsistências sejam geradas através do mecanismo de herança, todas elas são esperadas e apontadas por as regras de boaformação para consistência, as quais foram apresentadas na Seção 4.3.
Ainda quanto a a herança de relacionamentos, é necessário ressaltar que também se considera possível herdar um relacionamento, se, no processo que está recebendo o conteúdo herdado, já existir um ou mais elementos que pertencem a esse relacionamento.
Considere, por exemplo, que durante um mecanismo de herança entre dois processos diferentes, um produto de trabalho tenha sido herdado e não tenha sido possível herdar o seu relacionamento de responsabilidade, devido a o papel associado a essa relação não fazer parte do conteúdo a ser herdado (não estar definido nos pacotes de elementos, não estar definido na atividade que é herdada e nem numa de suas atividades superiores).
Em este caso do exemplo, se a atividade que contém o papel definido no relacionamento for herdada mais tarde será possível herdar também o relacionamento.
Isso porque será detectado que um dos elementos que fazem parte deste relacionamento já se encontra no processo que está recebendo o conteúdo herdado.
Para facilitar o entendimento do exposto acima, a Figura 42 mostra a interpretação do mecanismo de herança proposto na Figura 41.
Observa- se, na referida figura, que, na solução proposta por esta pesquisa, o Papel A é considerado como parte da Atividade 1.1.
A justificativa a isso se dá porque esse elemento é utilizado por relações da Atividade 1.1 e é definido na sua atividade superior.
Assim, o resultado da extensão feita através das atividades Atividade 1.1 e Atividade 1.2, mostra que todos os elementos herdados na Atividade 1.2 utilizam o Papel A_ Em o resultado exibido na Figura 44, observa- se que os produtos de trabalho e os dois relacionamentos que definem as responsabilidades sobre esses produtos de trabalho foram movidos para os pacotes de produtos de trabalho e de relacionamentos, respectivamente.
Isso foi feito para evitar que inconsistências relacionadas com duplicação de elementos fossem reproduzidas após os mecanismos de herança serem executados.
Para finalizar o entendimento sobre como os mecanismos de herança extension e localContribution funcionam na solução proposta, um exemplo de herança entre processos diferentes foi elaborado.
Para esse exemplo, o conjunto de elementos de processo da Figura 44 é considerado.
Contudo, para enriquecer a ilustração, definiu- se localmente para a Atividade 2.1 um novo produto de trabalho chamado Y e considerou- se que o Produto de Trabalho P, que já era dependente do Produto de Trabalho R, também depende do Produto de Trabalho Y. Para estabelecer essa relação, bastou incluir o Produto de Trabalho Y no atributo target do relacionamento de dependência que se encontra no pacote de relacionamentos.
Prosseguindo com o exemplo, criou- se um novo processo de software com apenas uma atividade (Atividade Estender) e se definiu um relacionamento de extension com a Atividade 1.1 da Figura 44.
O resultado, após a interpretação do mecanismo de herança é mostrado na Figura 45.
O resultado exibido na Figura 45 mostra que todo conteúdo da Atividade 1.1 foi herdado para a Atividade Estender juntamente com todos os elementos e relacionamentos que estavam no pacote e possuiam alguma relação com o conteúdo dessa atividade.
Esse é o caso do Produto de Trabalho R e seu relacionamento de responsabilidade (ProcessResponsabilityAssignment) que foram copiados, uma vez que esse produto de trabalho é utilizado por a Atividade 1.1 através do relacionamento de dependência que o Produto de Trabalho P tem com o Produto de Trabalho R. A diferença da aplicação dos mecanismos de extension e localContribution entre processos diferentes é que inconsistências quase sempre são incluídas no processo que herda algum conteúdo.
Nota- se na Figura 45, por exemplo, que o Produto de Trabalho R, o qual é do tipo Interno, não herda sua tarefa de produção, gerando, assim, uma inconsistência no processo resultante.
Contudo, é importante considerar que, como já mencionado acima, todas as inconsistências causadas nos mecanismos de herança são esperadas e são apontadas por as regras de boa-formação para consistência definidas nesta pesquisa.
As únicas inconsistências geradas através do mecanismo de herança entre dois processos diferentes, que não podem ser identificadas através das regras de boaformação, estão relacionadas com a herança dos relacionamentos de dependência e composição.
Em o caso específico do exemplo descrito acima, nota- se, também na Figura 45, que o relacionamento de dependência não foi herdado por completo.
Em o exemplo proposto, o Produto de Trabalho P dependia dos produtos de trabalho R (que encontrava- se no pacote) e Y (que foi definido localmente na Atividade 2.1) e, após o mecanismo de herança ser interpretado, o Produto de Trabalho P depende apenas do Produto de Trabalho R sem existir nenhuma referência ao Produto de Trabalho Y. Caso o Produto de Trabalho R também estivesse definido localmente dentro de outra atividade, o relacionamento de dependência nem seria criado no processo resultante e, após uma validação de consistência nenhum erro seria encontrado para tal processo.
A mesma situação ocorrerá com os produtos de trabalho que mantêm relações de composição e dependem de uma de suas partes ou do todo para ser instanciado.
Para resolver a situação acima, na solução proposta toda vez que um produto de trabalho herdado num mecanismo de herança (extension ou localContribution) depende de outros produtos de trabalho ou representa uma parte ou o todo numa relação de composição, essa informação deverá ser herdada juntamente com esse produto de trabalho, sendo criado automaticamente uma inconsistência no processo resultante.
Em se tratando de um relacionamento de dependência, a inconsistência só será resolvida quando todas as dependências do produto de trabalho em questão forem criadas no processo.
Já no caso de um relacionamento de composição, a inconsistência poderá ser resolvida de duas formas.
Caso o produto de trabalho herdado represente uma parte numa relação de composição, a inconsistência é resolvida quando o produto de trabalho que representa o todo dessa relação é criado.
Mas, no caso de o produto de trabalho herdado representar o todo de uma relação de composição, a inconsistência é resolvida quando qualquer uma de suas partes é criada no processo.
Com base em todo contexto evidenciado, a nova descrição para a semântica dos tipos de herança localContribution e localReplacement foi estabelecida.
Um ponto importante a ser considerado é que tais semânticas, descritas abaixo, funcionam da mesma maneira para ambas as atividades de adaptação e definição dos processos de software.
Extension: Este mecanismo permite reutilizar dinamicamente as subestruturas (elementos aninhados por a relação de composição) de uma atividades em outras atividades.
De essa forma, a atividade que é associada à outra atividade, por a relação usedActivity e por o valor para useKind igual a extension, herda todo conteúdo dessa atividade.
Considera- se que, durante o mecanismo de herança, todos os elementos que são utilizados, através de relacionamentos por a atividade que sofre o apontamento extension e estão definidos em suas atividades superiores (atividades pai) ou estão definidos nos pacotes de elementos e relacionamentos, são considerados como parte dessa atividade e, desse modo, são herdados.
LocalContribution: Este mecanismo deve ser sempre utilizado em conjunto com o mecanismo de extensão (extension).
Ele permite que adições locais (contribuições) sejam feitas em atividades que estão sendo herdadas através do mecanismo de extensão.
Assim, toda atividade que aponta para outra atividade, utilizando- se do valor localContribution não pode estar vazia.
Essa atividade deve possuir, no mínimo, um elemento de processo instanciado como parte de ela.
Uma atividade A, por exemplo, poderia herdar toda estrutura da atividade B por o mecanismo de extension.
Contudo, poderia ser necessário fazer adições locais (contribuições) para a atividade A através da relação localContribution.
Para fazer isso, devem existir subatividades dentro de as atividades A e B_ Em a (por exemplo, A_ 1), devem ser definidas as contribuições locais e, nesse momento, deve ser apontada subatividade de A para subatividade de B (por exemplo B_ 1).
O resultado, em A_ 1, será todo conteúdo de B_ 1 somado aos elementos pré-definidos em A_ 1.
Considera- se que durante o mecanismo de herança, todos os elementos que são utilizados através de relacionamentos por a atividade que sofre o apontamento localContribution e estão definidos em suas atividades superiores (atividades pai) ou estão definidos nos pacotes de elementos e relacionamentos são considerados como parte desta atividade e, dessa maneira, são herdados.
Até o momento, a única definição específica para o tipo de herança localReplacement foi o estabelecimento de que a atividade que realiza um apontamento deste tipo não pode estar vazia.
Contudo, uma vez que o tipo de herança localReplacement envolve a exclusão dos elementos e relacionamentos que serão substituídos por os novos elementos e relacionamentos, alterações em seu funcionamento foram propostos nesta pesquisa.
As alterações realizadas sobre esse tipo de herança dizem respeito à inclusão de análise de impacto sobre os elementos resultantes num processo de software, toda vez que um apontamento do tipo localReplacement é realizado.
O principal objetivo da análise de impacto é identificar possíveis elementos e relacionamentos que, por motivo de dependências, precisam também ser excluídos.
Contudo, a análise de impacto só é necessária quando a herança que se utiliza de localReplacement ocorre entre duas atividades que pertencem a processos diferentes.
Isso porque, quando este tipo de herança é utilizado entre atividades do mesmo processo, o conteúdo que está sendo excluído por o mecanismo localReplacement ainda permanece no processo, uma vez que ele é mantido na atividade que sofre o apontamento.
Para demonstrar o funcionamento do localReplacement, considerando duas atividades num mesmo processo, a Figura 46 mostra um exemplo.
Para realizar a análise de impacto para o tipo de herança localReplacement, tornou- se necessário mapear todos os impactos causados por a exclusão de cada elemento que pode pertencer a uma atividade.
O resultado desse mapeamento será apresentado ainda nesta seção juntamente com as alterações propostas para o relacionamento supressedBreakdownElement.
A nova semântica do tipo de herança localReplacement é a seguinte:
LocalReplacement: Este mecanismo deve ser sempre utilizado em conjunto com o mecanismo de extensão (extension).
Ele permite que substituições locais sejam feitas em atividades que estão sendo herdadas através do mecanismo de extensão.
Assim, toda atividade que aponta para outra atividade, utilizando- se do valor localReplacement não pode estar vazia.
Essa atividade deve possuir, no mínimo, um elemento de processo instanciado como parte dessa atividade.
Por exemplo, uma atividade A poderia herdar toda estrutura da atividade B por o mecanismo de extension.
Contudo, poderia ser necessário fazer substituições locais para partes da atividade A através da relação localReplacement.
Para isso, devem existir subatividades dentro de as atividades A e B_ Em a subatividade de A (por exemplo, A_ 1) deve ser definido o conteúdo local que vai substituir o conteúdo sendo herdado e, neste momento, deve ser apontada a subatividade de A para subatividade de B (por exemplo B_ 1).
O resultado em A_ 1 substituirá todo conteúdo de B_ 1.
Considerar que durante a interpretação do mecanismo localReplacement para atividades que estão em processos distintos, uma análise de impacto deverá ser realizada para todos os elementos no processo resultante.
A análise de impacto mapeará todas as dependências dos elementos excluídos e indicará se novas exclusões são necessárias.
Uma diferença existe para o funcionamento do tipo de herança localReplacement nas atividades de adaptação e definição de um processo de software.
Essa diferença está relacionada com a opcionalidade dos elementos de processo atividade, tarefa, produto de trabalho e papel e especifica que, para a atividade de definição de um processo de software (onde o Process Package possui o valor do atributo isAuthoring $= true), durante a interpretação dos mecanismos de herança, não são consideradas as opcionalidades dos elementos de processo acima e, dessa forma, qualquer exclusão poderá ser feita através do mecanismo de substituição.
Já durante a atividade de adaptação (onde o Process Package possui o valor do atributo isAuthoring $= false), as opcionalidades dos elementos de processo são consideradas e, dessa maneira, não é possível realizar substituições quando elementos de processo obrigatórios necessitam ser excluídos.
Especificamentedurante a adaptação de um processo, para os casos onde as substituições são propostas para elementos obrigatórios ou, ainda, quando a substituição de qualquer elemento opcional causar a exclusão de um ou mais elementos de processo obrigatórios, a operação de substituição deverá ser cancelada.
Além de as alterações realizadas especificamente sobre o relacionamento usedActivity, algumas definições também foram modificadas no relacionamento supressedBreakdownElement, o qual se estabelece entre as metaclasses Activity e BreakdownElement e, como já explicado na Seção 2.6.1.5 deste trabalho, só pode ser utilizado em conjunto com o relacionamento usedActivity.
Originalmente, no metamodelo SPEM 2.
0, o relacionamento supressedBreakdownElement permite que todas as atividades que herdam conteúdos de outras atividades por o tipo de herança extension possam ter qualquer elemento excluído.
De essa forma, toda vez que o relacionamento extension é interpretado, a relação supressedBreakdownElement é liberada, permitindo a exclusão de elementos do conteúdo herdado.
Contudo, na especificação original do metamodelo SPEM 2.
0, assim como para o tipo de herança localReplacement, não existem referências sobre o impacto das exclusões realizadas por o relacionamento supressedBreakdownElement sobre outros elementos e relacionamentos, o que pode gerar várias inconsistências no processo resultante.
Em a tentativa de evitar inconsistências num processo de software causadas por as exclusões do relacionamento supressedBreakdownElement, uma análise de impacto foi incluída para quando esse tipo de relação for utilizada.
Basicamente, o funcionamento da análise de impacto proposta para o relacionamento supressedBreakdownElement é o mesmo daquela já explicada para o tipo de herança localReplacement, como mostra o exemplo a seguir.
O exemplo proposto para demonstrar o funcionamento da relação supressedBreakdownElement foi realizado sobre a Atividade Processo 2 exibido na Figura 52.
Essa atividade foi escolhida por já ter utilizado o tipo de herança extension e, desse modo, possuir o uso do relacionamento supressedBreakdownElement liberado.
A proposta do exemplo foi excluir o Produto de Trabalho Interno W e a Tarefa 5 da Atividade Processo 2, os quais são mostrados em negrito na Figura 50.
É possível observar na Figura 50 que o Produto de Trabalho Interno W é um produto de trabalho central na Atividade 2.1 e que sua exclusão causa impactos nessa atividade, já que ele é o único produto de trabalho produzido por a Tarefa 4.
Já observando a Tarefa 5 da Atividade 2.2, nota- se que sua exclusão não causa nenhum impacto aos outros elementos da Atividade Processo 2, uma vez que essa tarefa não possui relação com outros elementos (o que representa, inclusive, uma inconsistência).
Em o resultado mostrado na Figura 51, todos os elementos destacados em vermelho são os elementos que necessitam ser excluídos juntamente com o Produto de Trabalho Interno W e a Tarefa 5.
Para chegar a tal resultado foi necessário analisar todos os relacionamentos de cada elemento excluído com objetivo de verificar a necessidade de novas exclusões.
Como forma de entender como a análise de impacto é realizada, a Tabela 15 mostra os elementos impactados quando um elemento do tipo produto de trabalho interno é excluído (no exemplo, o Produto de Trabalho Interno W).
Tabela 15 ­ Análise de impacto para a exclusão de uma instância do elemento InternalUse Elemento do Processo Metaclasse Activity Impacto -- A instância de InternalUse excluída deve ter suas associações com as instâncias de Activity eliminadas. --
Se a instância de InternalUse excluída está associada ao atributo target de uma ou mais instâncias de WorkProductUseRelationship com valor de atributo relationType igual a dependency, então a instância de InternalUse associada no atributo source de a (s) instância (s) WorkProductUseRelationship deve (m) ser excluída (s). --
Se a instância de InternalUse excluída for o único elemento associado no atributo target de uma instância de WorkProductUseRelationship com valor de atributo relationType igual a composition, então a instância de InternalUse associada no atributo source de a (s) instância (s) WorkProductUseRelationship deve (m) ser excluída (s). --
Se a instância de InternalUse excluída está associada Metaclasse TaskUse Metaclasse RoleUse Metaclasse InternalUse ao atributo source de uma ou mais instâncias de WorkProductUseRelationship com valor de atributo relationType igual a composition, então todas as instâncias de InternalUse associadas no atributo target de a (s) instância (s) WorkProductUseRelationship deve (m) ser excluída (s).
Metaclasse ExternalUse -- Se a instância de InternalUse excluída está associadoa ao atributo target de uma ou mais instâncias de WorkProductUseRelationship com valor de atributo relationType igual a dependency, então a instância de ExternalUse associada no atributo source de a (s) instância (s) WorkProductUseRelationship deve (m) ser excluída (s). --
Se a instância de InternalUse excluída for o único elemento associado no atributo target de uma de WorkProductUseRelationship com valor de atributo relationType igual a composition, então a instância de ExternalUse associada no atributo source de a (s) instância (s) WorkProductUseRelationship deve (m) ser excluída (s). --
Se a instância de InternalUse excluída está associada ao atributo source de uma ou mais instâncias de WorkProductUseRelationship com valor de atributo relationType igual a composition, então todas as instâncias de ExternalUse associadas no atributo target de a (s) instância (s) WorkProductUseRelationship deve (m) ser excluída (s). --
Todas as instâncias de ProcessParameter que estão associadas com a instância de InternalUse excluída devem também ser excluídas. --
A instância de InternalUse excluída deve ter suas associações com as instâncias de WorkProductRelationshipUse eliminadas.
Se alguma das instâncias de WorkProductRelationshipUse afetadas não possuir mais instâncias de InternalUse e/ ou ExternalUse associadas aos seus atributos source e target, então estas instâncias deverão também ser excluídas.
Todas as instâncias de ProcessResponsabilityAssingment que estão associadas com a instância de InternalUse excluída devem também ser excluídas.
Metaclasse ProcessParameter Metaclasse ProcessPerformer Metaclasse WorkSequence Metaclasse WorkProductRelationshipUse Metaclasse ProcessResponsabilityAssingment Um ponto a ser considerado na análise de impacto mostrada na Tabela 15 é que, assim como o tipo de herança localReplacement, o relacionamento supressedBreadkdownElement considera as informações de opcionalidade diferentes para as atividades de adaptação (onde o Process Package possui o valor do atributo isAuthoring $= false) e definição (onde o Process Package possui o valor do atributo isAuthoring $= true) de processos de software.&amp;&amp;&amp;
Para esse tipo de relacionamento, igualmente ao tipo de herança localReplacement, foi estabelecido que, durante a definição de um processo de software, as informações de opcionalidade não são consideradas e qualquer elemento pode ser excluído.
Já durante as atividades adaptação, uma vez que as opcionalidades dos elementos de processo são consideradas, não é possível realizar exclusões de elementos de processo obrigatórios.
Sendo assim, definiu- se que, durante as atividades de adaptação, qualquer operação de exclusão (realizadas por o supressedBreakdownElement) ou de substituição (realizadas por o localReplacement) que indicar como resultado da análise de impacto a exclusão de um ou mais elementos de processo (atividade, tarefa, papel e produtos de trabalho do tipo interno ou externo) obrigatórios deverá ser cancelada.
Uma descrição completa para a análise de impacto de cada um dos elementos excluídos numa atividade pode ser vista no Apêndice C. Por fim, é importante citar que toda a análise de impacto mostrada na Tabela 15 e Apêndice C, a qual é definida para o relacionamento supressedBreadkdownElement, é a mesma utilizada no tipo de heranaça localReplacement.
O mecanismo de adaptação Variability é definido no pacote Method Plugin e possui muitas similaridades com o mecanismo usedActivity.
As diferenças entre estes dois mecanismos, é que o Variability permite definir variantes do conteúdo do processo (elementos do Method Content) e das atividades de um processo de software (Activity) e não é considerado somente como um mecanismo de herança, tal como é o caso do usedActivity.
Outra diferença fundamental entre os mecanimos usedActivity e Variablity é que este último pode ser utilizado em todos os elementos do repositório do processo e também nos elementos do tipo atividade de um processo.
Além disso, para utilizar o mecanismo Variability não existe necessidade de combinações entre tipos de herança.
Embora existam algumas diferenças conceituais e de funcionamento entre os mecanismos usedActivity e Variability, as modificações realizadas para o mecanismo Variability são praticamente as mesmas feitas para o mecanismo usedActivity.
A primeira de elas, por exemplo, foi a definição da regra de boa-formação que estabelece que uma instância de um elemento do repositório ou uma atividade do processo não pode definir um autorrelacionamento do tipo Variablity.
Isso evita que esses elementos apontem para sua própria instância e tentem variar (herdar, contribuir ou substituir) seu próprio conteúdo.
Regra&amp; 47 ­ Elementos do repositório de conteúdo (Method Content) e atividades (Activity) não podem variar seu próprio conteúdo.
Semântica: Nenhuma instância da metaclasse MethodContent ou da metaclasse Activity deverá estabelecer um autorrelacionamento VariabilityBasedOnElement.
Após a definição da regra de boa-formação acima, foram realizadas modificações nas semânticas dos tipos de herança Contributes, Replaces e Extends-replaces para estabelecer que os elementos que realizam esses tipos de apontamento não podem estar vazios, ou seja, eles necessitam ter algum valor de atributo preenchido e/ ou associações com outros elementos.
A motivação para a mudança da semâncica destes tipos de herança é que, como já explicado para o mecanismo usedActivity, no caso de uma contribuição (Contributes) algum novo valor de atributo ou alguma nova associação deve existir no elemento de origem (variabilitySpecialElement) para que realmente exista uma contribuição quando o conteúdo da elemento de destino (variabilityBasedOnElement) for herdado.
Já no caso de uma substituição (Replaces) total ou uma substituição parcial (Extends-replaces) o elemento de origem (variabilitySpecialElement) não pode estar vazio, uma vez que seu conteúdo substituirá total ou parcialmente o conteúdo do elemento de destino (variabilityBasedOnElement).
Outra modificação realizada para todos os tipos de herança foi realizada para o momento em que qualquer um desses tipos de herança é aplicado para o elemento atividade num processo de software.
Essa modificação estabelece que durante uma herança, todos os elementos utilizados, através de relacionamentos por a atividade que está sendo herdada e estão definidos em suas atividades superiores (atividades pai) ou estão definidos nos pacotes de elementos e relacionamentos, são considerados como parte dessa atividade e, desse modo, são herdados.
Por fim, a última modificação realizada foi feita para a semântica dos tipos de herança que envolvem mecanismos de substituição, como é o caso das heranças Replaces e Extends-Replaces.
A alteração proposta foi definida apenas para quando o elemento atividade utiliza esses tipos de herança e estabele que uma análise de impacto deverá ser realizada em todo processo durante qualquer mecanismo de substituição.
Uma vez que esta pesquisa estendeu o metamodelo original SPEM 2.
0, utilizando os princípios de empacotamento definidos na UML, existe a necessidade de especificar o (s) ponto (s) de conformidade para o metamodelo sSPEM 2.0.
De essa forma, o ponto de conformidade estabelecido é descrito a seguir:
SSpem Complete, que define a utilização de todos os pacotes do metamodelo.
Este nível estabelece a implementação de todo o metamodelo, focando na construção de processos de software completos e reutilizáveis.
Embora, nesta pesquisa, não tenham sido realizadas modificações nos pacotes Managed Content e Process Behavior, eles foram mantidos no metamodelo sSPEM 2.0 e, dessa forma, considera- se que todos os pacotes podem ser utilizados na definição de um processo de software, fato que levou a especificação do ponto de conformidade sSpem Complete.
Este capítulo apresentou uma extensão ao metamodelo SPEM 2.
0 denominada sSPEM 2.0.
Durante a descrição do capítulo, todas as alterações em termos de elementos e relacionamentos, bem como as regras de boa-formação para consistência definidas para o metamodelo sSPEM 2.0 foram descritas.
Em adição, foi apresentado também neste capítulo, os mecanismos de adaptação usedActivity, supresssedBreakdownElement e Varialibity.
O próximo capítulo desta tese apresenta um guia para construção e adaptação dos processos de software.
O guia especifica o fluxo de atividades a ser seguido para a definição e adaptação de processos utilizando o metamodelo sSPEM 2.0 e as regras de boa-formação, os quais integram a infraestrututra para consistência apresentada neste trabalho.
Este capítulo apresenta um guia que especifica o fluxo de atividades a ser seguido para a definição e adaptação de processos, utilizando a infraestrututra para consistência, apresentada neste trabalho.
Para representar o fluxo de atividades do guia proposto, a Figura 52 mostra um diagrama que é composto por 4 etapas:
A definição de uma biblioteca que armazena conteúdo e processos;
A definição do repositório de conteúdo;
A definição dos processos de software;
E a adaptação dos processos de software.
É necessário considerar que todas as etapas mostradas na Figura 52 devem ser realizadas utilizando o metamodelo sSPEM 2.0, sendo as etapas 1, 2 e 3 executas por o papel Engenheiro de Processo e a etapa 4 executada por o papel Gerente de Projeto.
A seguir, apresenta- se um detalhamento das etapas para definição e adaptação de processos de software:
A primeira atividade que deve ser realizada antes da definição de repositórios de conteúdo e processos é a definição de uma biblioteca.
Basicamente, a criação de uma biblioteca é bastante simples e envolve apenas dois passos.
Inicialmente, para representação da biblioteca, uma instância da metaclasse Method Library deverá ser criada e nomeada.
Em seguida, uma instância da metaclasse Method Plugin deverá ser definida como parte da instância de Method Library.
Um Method Plugin é sempre criado para uma biblioteca, pois este elemento representa no metamodelo sSPEM 2.0 um contêiner físico que armazena todo conteúdo do repositório (Method Content) e os processos de software (Process Structure).
Inicialmente, para definir um repositório de conteúdo, uma instância da metaclasse MethodContent deverá ser criada como parte de uma instância da metaclasse MethodPlugin.
Em seguida, conforme necessário, instâncias das metaclasses que representam os pacotes de elementos e relacionamentos podem ser criadas.
Tais metaclasses são:
RolePackage, WorkProductDefinitionPackage, TaskPackage, ToolPackage e MethodContentRelationshipPackage.
A partir de a definição dos pacotes acima, qualquer instância de elemento e relacionamento pode ser criada nos seus respectivos pacotes (atividade Criar Elemento no Repositório).
Identifica- se apenas que, durante a criação destes elementos e relacionamentos, as regras de boa-formação definidas para o pacote Method Content (conforme Seção 4.3.2.2) deverão ser respeitadas.
Durante a atividade de criação de um elemento, é possível que as informações sejam definidas localmente (informando as informações do elemento diretamente nos seus atributos) para este elemento ou ainda, que o mecanismo Variability seja utilizado através da atividade Variar Elementos.
Em este último caso, para execução da atividade Variar Elementos, deve- se relacionar o elemento criado através do seu atributo variabilityBasedOnElement com o elemento que se deseja criar uma variação, estabelecendo o tipo de herança através do atributo variabilityType (que possui os valores Replaces, Contributes, Extends e Extends-Replaces) (conforme Seção 4.4.2).
Após definir cada elemento do repositório, o Engenheiro de Processo deverá verificar a necessidade de criação de novos elementos (atividade Criar Elemento no Repositório) ou alteração de elementos existentes deste repositório (atividade Alterar Elemento do Repositório).
Caso nenhuma destas atividades sejam necessárias, a atividade Verificar Elementos do Repositório deverá ser executada.
O objetivo desta última atividade é checar a consistência dos elementos do repositório, utilizando para isto, as regras de boa-formação para consistência definidas nesta pesquisa para a atividade de definição de processos.
O funcionamento da atividade Verificar Elementos do Repositório envolve inicialmente, a seleção do elemento que deve ser verificado para que, a partir de isto, todos elementos que estão estruturalmente dentro (em outras palavras, elementos aninhados por a relação de composição) do elemento selecionado sejam verificados.
Assim, caso o Engenheiro de Processo selecione a instância da metaclasse MethodContent para verificação, todo o conteúdo do repositório será validado e o resultado desta validação conterá todas as suas inconsistências, caso elas existam.
A última atividade da etapa 1 envolve a alteração dos elementos do repositório, caso a atividade de verificação retorne erros.
A ideia é que a atividade Alterar Elementos de Repositório seja executada até que todas as inconsistências sejam eliminadas do repositório.
Uma vez que o repositório de conteúdos foi criado, a criação de um novo processo pode ser iniciada (atividade Criar Novo Processo).
Para fazer isto, o Engenheiro de Processo deverá definir inicialmente, uma instância da metaclasse ProcessPackage (com valor de atributo isAuthoring $= true) como parte da instância de MethodPlugin.
Em seguida, para criação de um novo processo devem ser definidas, respectivamente, uma instância da metaclasse ActivityPackage e uma instância da metaclasse Activity.
O estabelecimento de uma instância de ActivityPackage é obrigatória pois nenhum elemento pode ser criado fora de os pacotes.
Já o estabelecimento da instância de Activity se torna necessária pois, tanto no metamodelo original SPEM 2.
0 quanto na solução proposta por esta pesquisa, este é o elemento que deverá representar o processo de software sendo criado.
Prosseguindo com a atividade de criação de um processo de software, assim como num repositório de conteúdo, conforme a necessidade, instâncias das metaclasses que representam os pacotes de elementos e relacionamentos do processo podem ser criadas.
Em um ProcessPackage tais metaclasses são:
E WorkProductUsePackage, ProcessRelationshipPackage.
Após a criação dos pacotes, os elementos e relacionamentos podem começar a ser definidos para o processo em questão através da atividade Criar Elemento do Processo.
Para realizar esta atividade basta criar uma instância do elemento desejado.
Contudo, durante esta criação algumas regras estabelecidas nesta pesquisa necessitam ser respeitadas.
As regras definidas são relacionadas com o local onde os elementos e relacionamentos devem ser criados para um processo de software e foram estabelecidas, pois, como já explicado na Seção 4.3.3.1 deste trabalho, todos elementos criados nos pacotes são considerados como elementos globais, ou seja, podem ser utilizados por qualquer atividade do processo.
Além disso, as relações que são definidas nos pacotes de relacionamento podem estar associadas a elementos que estão em qualquer atividade do processo.
Já os elementos que são criados dentro de uma atividade em específico só podem ser utilizados por elementos e relacionamentos que estejam definidos numa de suas sub-atividades.
Baseado no contexto acima, inicialmente, considerando os relacionamentos, ficou estabelecido que qualquer instância de WorkSequence deverá ser definida dentro de o pacote de relacionamentos.
Isso se torna necessário, uma vez que este tipo de relacionamento deverá ter acesso a todas as atividades e tarefas de um processo de software.
Seguindo com as definições sobre o local de criação dos relacionamentos, recomenda- se que as relações de responsabilidade sobre os produtos de trabalho (ProcessResponsabilityAssigment) e os relacionamentos estabelecidos entre estes mesmos elementos (WorkProductUseRelationship) sejam também criados nos pacotes de relacionamentos.
Embora isso não seja obrigatório, faz- se esta recomendação por tratarem- se de relacionamentos que valem para o processo todo e que em muitas situações só podem mesmo serem criados nos pacotes de relacionamentos, como é o caso onde os elementos envolvidos em alguma destas relações estejam definidos em atividades diferentes.
Por fim, ainda referente a definição de relacionamentos, apenas como recomendação estabelece- se que toda instância de ProcessPerformer deverá ser criada no mesmo local onde está localizada a tarefa associada a esta relação.
As últimas regras relacionadas com o local de criação dos elementos e relacionamentos, estabelecem que os nodos iniciais e finais devem ser criados da seguinte forma:
Quando o sequenciamento é estabelecido entre tarefas e os nodos especiais são instâncias destes elementos eles deverão ser definidos nos pacotes de tarefas.
Já quando o sequenciamento é feito entre as atividades de um processo os nodos iniciais e finais devem ser criados no nível mais superior do processo, ou seja, diretamente dentro de a atividade que representa tal processo.
A motivação para definir em qual local os nodos iniciais e finais devem ser criados num processo de software, foi a preservação destes elementos quando uma operação de substituição e/ ou exclusão é realizada nesse processo.
Após a definição de uma instância de elemento para um processo de software, a definição de seu conteúdo pode ser feita de duas maneiras, conforme definição original do metamodelo SPEM 2.
0. A primeira forma diz respeito a definição local do conteúdo do elemento criado, ou seja, uma instância do tipo Use é criada para um elemento ou relacionamento e suas informações são incluidas diretamente nos seus atributos.
A segunda forma, a qual é indicada por o metamodelo original SPEM 2.
0 como sendo a principal maneira de definição de um processo, é a utilização do conteúdo estabelecido no repositório de conteúdos.
Para fazer uso deste repositório, a atividade Usar Elementos do Repositório deverá ser executada.
Esta atividade consiste em apontar a instância (Use) do elemento de processo criado (papel, produto de trabalho ou tarefa) através de um atributo (role, workProduct ou task) para um elemento do mesmo tipo no repositório.
Em este momento, todo conteúdo definido para o elemento que sofre o apontamento e também alguns de seus elementos relacionados são copiados para o processo.
Toda explicação sobre a cópia de elementos do repositório para um processo de sofware é realizada na Seção 5.5 deste capítulo.
Outra forma de definir conteúdo para um processo de software é através da execução da atividade Reusar Atividades que envolve o uso dos mecanismos Variability e usedActivity, os quais permitem que partes do mesmo processo ou ainda, de processos diferentes sejam herdados.
Em o contexto de um processo de software, a atividade Reusar Atividades só pode ser executada se o elemento definido na sua atividade anterior (Criar Elemento do Processo) for uma instância do elemento atividade.
Isso porque, atividades são os únicos elementos num processo que podem utilizar os mecanismos Variability e usedActivity.
Para executar a atividade Reusar Atividades com o mecanismo Variability é necessário apontar a instância da atividade criada através de seu atributo variabilityBasedOn para a atividade que se deseja criar uma variação estabelecendo o tipo de herança através do atributo variabilityType (que possui os valores Replaces, Contributes, Extends e Extends-Replaces).
Já para executar a atividade Reusar Atividades com o mecanismo usedActivity é necessário apontar a instância da atividade criada através de seu atributo usedActivity para a atividade que se deseja herdar o conteúdo estabelecendo o tipo de herança extension através do atributo useKind.
Após a execução do mecanismo usedActivity, o relacionamento supressedBreakdownElement torna- se disponível para realizar exclusões no conteúdo herdado através do atributo suppressedBreakdownElement do elemento atividade.
Após definir um elemento do processo, o Engenheiro de Processo deverá verificar a necessidade de criação de novos elementos (atividade Criar Elemento de Processo) ou alteração de elementos existentes deste processo (atividade Alterar Elemento do Processo).
Caso nenhuma destas atividades sejam necessárias, a atividade Verificar Elementos do Processo deverá ser executada.
O objetivo desta última atividade é checar a consistência dos elementos do processo, utilizando para isto, as regras de boa-formação para consistência definidas nesta pesquisa para a atividade de definição de processos.
O funcionamento da atividade Verificar Elementos do Processo envolve inicialmente, a seleção do elemento que deve ser verificado para que, a partir de isto, todos elementos que estão estruturalmente dentro (em outras palavras, elementos aninhados por a relação de composição) do elemento selecionado sejam verificados.
Assim, caso o Engenheiro de Processo selecione a instância da metaclasse ProcessPackage para verificação, todo o conteúdo do processo será validado e o resultado desta validação conterá todas as suas inconsistências, caso elas existam.
A última atividade desta etapa envolve a alteração dos elementos do processo, caso a atividade de verificação retorne erros.
A ideia é que a atividade Alterar Elementos de Processo seja executada até que todas as inconsistências sejam eliminadas do processo de software.
Uma vez que pelo menos um processo está disponível no repositório de processos, as atividades de adaptação podem começar a ser realizadas por o Gerente de Projeto.
Basicamente, as atividades de adaptação propostas por o metamodelo original SPEM 2.
0 e, consequentemente, por esta pesquisa, são baseadas em reusar partes (atividades) de um ou mais processos de software para o processo que está sendo adaptado, permitindo que modificações sejam realizadas nestes conteúdos através dos mecanismos usedActivity, supressedBreakdownElement e Variability.
Para executar a primeira atividade de adaptação, um novo processo deve ser criado através da execução da atividade Criar Novo Processo para Adaptação.
Esta atividade envolve, respectivamente, a criação de uma instância da metaclasse ProcessPackage (com valor de atributo isAuthoring $= false) como parte da instância de MethodPlugin, uma instância da metaclasse ActivityPackage e uma instância da metaclasse Activity.
Assim como na atividade de construção de processos, o estabelecimento de uma instância de ActivityPackage é obrigatória pois nenhum elemento pode ser criado fora de os pacotes.
Já o estabelecimento da instância de Activity é necessário para representar o processo de software sendo criado.
Após a definição de um novo processo de software que irá gerar um processo específico através dos mecanimos de adaptação, a atividade Selecionar Atividades de Processo deverá ser executada.
Esta atividade poderá ser executada basicamente de duas formas:
se é desejado que o processo criado herde todo o conteúdo de outro processo a própria instância de Activity criada para representar o processo de software pode realizar o apontamento para outra atividade que representa outro processo de software utilizando os mecanismos Variability (utilizando os atributos variabilityBasedOnElement e variabilityType) ou usedActivity (utilizando os atributos usedActivity e useKind).
Em o caso específico do usedActivity, conforme necessário, outras instâncias de atividades podem ser criadas para utilização dos tipos de herança adicionais localContribution e localReplacement.
Além disso, após qualquer atividade ser herdada através do mecanismo usedActivity será possível excluir qualquer um de seus elementos e uma relacionamentos vez que (utilizando o atributo supressedBreakdownElement), relacionamento supressedBreakdownElement será liberado;
E se é desejado criar um processo reutilizando (através do usedActivity) ou criando variações (através do Variability) de apenas partes de um ou vários outros processos, é necessário que uma nova instância de Activity seja definida como parte da instância de Activity que representa o processo para que esta nova Activity realize o apontamento para a atividade desejada em outro Elementos do Processo tem o mesmo funcionamento desta atividade na Etapa 3 (conforme Seção 5.3).
A última atividade desta etapa envolve a alteração dos elementos do processo, caso a atividade de verificação retorne erros.
A ideia é que a atividade Alterar Elementos de Processo Adaptado seja executada até que todas as inconsistências sejam eliminadas do processo de software.
A especificação textual do metamodelo original SPEM 2.
0 não realiza um detalhamento sobre a forma como os elementos devem ser copiados do repositório para um processo de software.
Em esse metamodelo, é apenas definido que quando um elemento de processo aponta para um elemento do repositório cópias congruentes dos elementos que se relacionam com este elemento devem ser fornecidas.
Basicamente, a proposta do metamodelo original SPEM 2.
0 é modularizar conteúdos de processo num repositório, permitindo assim a utilização destes módulos em diferentes processos de software.
Esta ideia vai ao encontro de a abordagem utilizada por os autores da área de Engenharia de Método, uma vez que tais autores defendem a criação de fragmentos de método (processo e produto) armazenados em repositórios para reutilização em processos distintos.
Fazendo o mapeamento dos conceitos utilizados no repositório de conteúdos (Method Content) para os conceitos utilizados por os autores da Engenharia de Método, pode- se considerar que as tarefas e produtos de trabalho criados no repositório de conteúdos do SPEM 2.
0 representam, respectivamente, os fragmentos de processo e os fragmentos de produto de um processo de software.
Ambos os tipos de fragmentos, irão se relacionar com o elemento de processo papel e, mais especificamente, os fragmentos de processo irão também se relacionar com os elementos do tipo ferramenta.
Tais relacionamentos são do mesmo modo bastante comuns na área de Engenharia de Método.
Ainda que seja possível fazer o mapeamento dos conceitos relacionados com o repositório de conteúdos (Method Content) no metamodelo SPEM 2.
0 para os conceitos na área de Engenharia de Método, algumas divergências podem ser encontradas quanto a o funcionamento proposto por o metamodelo SPEM 2.
0 para este repositório.
Inicialmente, diz- se isto, pois, de acordo com a especificação textual do SPEM 2.
0 é possível criar um elemento do tipo papel no processo e fazer o apontamento para a definição de um papel no repositório.
Isso dá a ideia de que este elemento representa um fragmento, o que não existe na Engenharia de Método, uma vez que, embora esses elementos estejam presentes num repositório, não existem fragmentos específicos para eles.
O que há são as relações dos fragmentos de processo e fragmentos de produto com esse elemento.
Outra diferença do metamodelo SPEM 2.
0 relacionada com a área da Engenharia de Método é específica com a formação de um fragmento de produto no repositório.
Fazse tal assertiva, em função de que, embora não exista uma definição rígida para um fragmento de produto na Engenharia de Método, a visão da maioria dos autores, tais como Harmsen Em e Ralyté em, é a de que, mesmo que um fragmento de produto esteja associado a vários fragmentos de processo, no momento que este fragmento de produto é selecionado para um processo, somente os fragmentos de processo responsáveis por produzir tal fragmento são também selecionados.
Isso funciona de forma diferente no metamodelo SPEM 2.
0, uma vez que esse metamodelo estabelece que, toda vez que um produto de trabalho é criado no processo e aponta para a definição de um produto de trabalho (o que representa um fragmento de produto) no repositório, todas as relações deste produto de trabalho devem ser copiadas.
Isso faz com que todas as tarefas (que representam os fragmentos de processo) relacionadas com esse produto de trabalho, incluindo aquelas que apenas o consomem e/ ou o modificam, sejam também copiadas para o processo de software.
Por exemplo, para a criação de um produto de trabalho no processo que aponte para o produto de trabalho Visão (considerando o processo RUP) no repositório, seria necessária a criação de muitas outras tarefas no processo, já que este é um produto de trabalho central (consumido e modificado em vários pontos do processo) para as tarefas de requisitos do processo RUP.
Baseado no exposto acima, considera- se que a proposta do metamodelo original SPEM 2.
0 para funcionamento do repositório de conteúdo apresenta alguns problemas de coesão e acoplamento.
Por esse motivo, esta pesquisa definiu um novo funcionamento do repositório de conteúdos para o metamodelo sSPEM 2.0.
Inicialmente, relacionado ao elemento papel definiu- se nesta pesquisa que este tipo de elemento não pode sofrer apontamentos diretos a partir de um processo de software.
Isso significa que não é possível criar uma instância de papel no processo (instância do tipo Use) e apontar para uma instância do repositório (instância do tipo Definition).
A única forma de usar uma instância de papel do repositório num processo de software será através do apontamento de suas tarefas (fragmentos de processo) e produtos de trabalho (fragmentos de produto) relacionados.
Em o momento em que, por exemplo, uma tarefa do processo aponta para uma tarefa do repositório, os papéis relacionados (executores) com esta tarefa serão copiados para o processo.
Em este momento, instâncias de processo (instância do tipo Use) do elemento papel serão criadas e apontadas para as instâncias de definição desses elementos no repositório.
De a mesma maneira, quando um produto de trabalho do processo aponta para um produto de trabalho do repositório, os papéis relacionados (responsáveis) com esse produto de trabalho serão também copiados para o processo de software, sendo realizados os devidos apontamentos das instâncias de processo para as instâncias do repositório.
Para o uso do elemento produto de trabalho do repositório em processos de software, várias definições foram realizadas com base na área de Engenharia de Método.
Inicialmente, definiu- se que durante o apontamento entre produtos de trabalho (processo x repositório) devem ser copiadas para o processo apenas as tarefas que estão relacionadas com o produto de trabalho através de uma relação de produção, ou seja, serão copiadas somente as tarefas que produzem tal produto de trabalho.
Em seguida, definiu- se que quando tais tarefas são copiadas, elas devem ser trazidas de forma completa, ou seja, para cada tarefa de processo que realiza apontamento para uma tarefa de repositório, devem ser copiadas todas suas relações e elementos destas relações.
É necessário estabelecer que, quando produtos de trabalho do tipo externo (ExternalUse), os quais não são produzidos num processo de software, realizam apontamento para um produto de trabalho do repositório, nenhuma tarefa é copiada para o processo.
Especificamente, considerando as relações que o produto de trabalho que sofre apontamento possui com outros produtos de trabalho no repositório, definiu- se que nem todas estas relações e elementos serão copiados.
Considerando as três relações possíveis entre produtos de trabalho (dependência, agregação e composição) identificouse que elas possuem funcionamentos distintos.
Relacionado com a relação de dependência durante um apontamento entre produtos de trabalho (processo x repositório), definiu- se que serão copiadas para o processo somente as relações entre produtos de trabalho que estabelecem que o produto de trabalho que está sofrendo o apontamento depende de outro produto de trabalho.
Analisando, em detalhes, os apontamentos realizados a partir de os Processo 1 e 3, ambos realizados com o produto de trabalho W, observa- se que seus resultados são diferentes.
Isso ocorre, porque, no apontamento realizado a partir de o Processo 1, uma instância de produto de trabalho externo (ExternalUse) foi criada, enquanto que a instância de produto de trabalho que realiza o apontamento no Processo 3 é do tipo interno (InternalUse).
Os resultados do Processo 1 mostram que os produtos de trabalho B e C também foram copiados, uma vez que o produto de trabalho W depende desses produtos de trabalho no repositório de conteúdo.
Além disso, para todos os produtos de trabalho copiados foram também trazidos do repositório suas relações com seus papéis responsáveis.
Já analisando o resultado do Processo 3, verifica- se que, por se tratar de um produto de trabalho interno realizando o apontamento, sua tarefa de produção foi trazida do repositório juntamente com todas as suas entradas e saídas em termos de produtos de trabalho, bem como os papéis responsáveis por sua execução e também responsáveis por os produtos de trabalho copiados.
Adicionamente, as relações de dependência entre os produtos de trabalho também foram copiadas.
É necessário considerar que durante a cópia dos produtos de trabalho para qualquer um dos processos de software, é o usuário quem escolhe se o produto de trabalho sendo copiado é do tipo interno ou externo (ExternalUse ou InternalUse).
Apenas nos casos onde uma tarefa sendo copiada mantém relação de produção com um ou mais produtos de trabalhos, não será possível o usuário definir o tipo de produto de trabalho a ser criado, uma vez que para estes produtos de trabalho, instâncias de produtos de trabalho internos serão criadas automaticamente.
Considere- se, por exemplo, o apontamento no Processo 3 realizado a partir produto de trabalho interno W. Durante tal apontamento, foi possível o usuário escolher que tipos de instâncias de produtos de trabalho (interno ou externo) deveriam ser criados para os produtos de trabalho B e C. Contudo, para os produtos de trabalho X e Y, os quais são produzidos por a tarefa 1, instâncias de produtos de trabalho do tipo interno foram criadas automaticamente.
Após entender como funciona a cópia dos elementos para um processo de software, explica- se a última definição realizada para o repositório de conteúdos do metamodelo sSPEM 2.0.
Tal definição é relacionada com as alterações locais realizadas nos elementos que foram copiados do repositório (feitas nos processos de software).
Tais definições são:
todo elemento copiado do repositório pode ser modificado nos processo de software;
E (2) toda vez que um elemento de repositório sofre atualizações, todos os elementos dos processos de software que realizam apontamento para o elemento modificado e não sofreram alterações locais devem ser também atualizados.
Este capítulo apresentou o guia que auxilia a definição e adaptação de processos de software a partir de o metamodelo sSPEM 2.0 e das regras de boa-formação.
Também foi descrito como funciona o repositório de conteúdos nesse metamodelo.
O próximo capítulo desta tese apresenta a formalização das regras de boaformação para consistência em lógica de primeira ordem.
Este capítulo apresenta a formalização das regras de boa-formação que foram descritas no Capítulo 4.
Para a formalização dessas regras, optou- se por a lógica de primeira ordem onde foram identificados as constantes e os predicados compondo o alfabeto da linguagem e, a partir de eles, foram formalizados os axiomas.
Como base para a formalização mencionada, foram utilizados os diagramas de classes da UML que representam os pacotes do metamodelo sSPEM 2.0.
Quanto a o alfabeto do diagrama de classes da UML, destaca- se que ele é composto por um conjunto de nomes de classes, um conjunto de nomes de atributos, um conjunto de nomes de associação e um conjunto de nomes de tipos de dados.
Em esta pesquisa, foram suficientes a utilização do conjunto de nomes de classes que, na linguagem formal utilizada, são os predicados definidos como Tipos e Subtipos;
O conjunto de nomes de atributos que, são os predicados definidos como Propriedades;
E um subconjunto dos nomes de associação definidos na UML, os quais são predicados tidos na linguagem utilizada, como Associações.
Um Tipo representa um conceito num processo de software e é representado por uma classe nos diagramas de classes que compõem o metamodelo sSPEM 2.0.
Um Subtipo também representa um conceito num processo de software, mas, num diagrama de classes, caracteriza uma subclasse que especializa uma superclasse através do conceito de herança.
As propriedades representam as características para um Tipo ou Subtipo e estão sempre associadas aos referidos conceitos.
Por fim, uma Associação representa uma relação binária entre dois Tipos e/ ou Subtipos.
A seguir, serão apresentadas, a linguagem formal utilizada nesta pesquisa e a formalização das regras de boa-formação para consistência de processos.
Para facilitar o entendimento do capítulo, as regras estão organizadas exatamente da mesma maneira que no Capítulo 4, ou seja, divididas nos pacotes do metamodelo sSPEM 2.0.
Vale lembrar que os identificadores de cada regra de boa-formação utilizados no Capítulo 4 são únicos, e, portanto, também serão empregados neste capítulo do trabalho.
Em o contexto do diagrama de classes apresentado na Figura 55, observa- se que o elemento WorkProductUse se apresenta como uma metaclasse Abstrata que possui um relacionamento de generalização/ especialização com as metaclasses InternalUse e ExternalUse.
Em UML, uma classe abstrata é desenvolvida para representar entidades e conceitos abstratos.
Assim, esse tipo de classe é sempre uma superclasse que não possui instâncias.
Ela define um modelo (template) para um grupo de subclasses que herdam todo seu comportamento e os seus relacionamentos.
Para formalizar a existência do elemento WorkProductUse e de suas especializações, foram definidos os seguintes predicados:
O tipo workProductUse indicando que x é um WorkProductUse;
O sub-tipo externalUse indicando que x é um ExternalUse;
E o subtipo internalUse indicando que x é um InternalUse.
Como dito, os subtipos são criados para representar subclasses em UML que herdam o comportamento e os relacionamentos de superclasses através de uma associação chamada generalização/ especialização.
Como toda subclasse em UML é uma instância da superclasse, para representar a notação de subtipo, os seguintes axiomas foram definidos:
Além de os predicados e axiomas acima, para a formalização das primeiras regras, foi necessário a criação de outros predicados.
Em esse sentido, criou- se o tipo processParameter que indica que x é um ProcessParameter.
Este, por sua vez, representa um parâmetro de entrada e/ ou saída para uma tarefa ou atividade em termos de um produto de trabalho (ExternalUse ou InternalUse) num processo de software.
Para indicar se o parâmetro é de entrada e/ ou saída a metaclasse ProcessParameter possui um atributo chamado direction, o qual possui os valores de In, Out e InOut.
Em a linguagem formal utilizada nesta pesquisa, o atributo direction é uma propriedade do tipo ProcessParameter.
Para sua representação definiram- se os seguintes predicados:
Direction (x, 'in'), direction (x, 'out') e direction (x, 'inout').
Em todos os predicados, o x representa uma instância do tipo ProcessParameter e'in',' out` e'inout' se referem aos valores (constantes) de direction que o x pode assumir.
A metaclasse ProcessParameter também possui um atributo que indica qual é o WorkProductUse (ExternalUse ou InternalUse) que representa o parâmetro para a tarefa ou atividade.
Tal atributo é chamado parameterType e é definido com o seguinte predicado:
ParameterType (x, y) onde x representa uma instância do tipo ProcessParameter e y representa uma instância do tipo ExternalUse ou do tipo InternalUse.
Com a utilização dos predicados e axiomas definidos acima, as primeiras regras para o elemento WorkProductUse foram escritas em lógica de primeira ordem e são:
Regra&amp; 1 -- Os produtos de trabalho externos (ExternalUse) não podem ser produzidos num processo de software.
Regra&amp; 2 -- Os produtos de trabalho externos (ExternalUse) devem ser consumidos e/ ou modificados num processo de software.
X (externalUse (x) y (processParameter (y) (direction (y, 'in') direction (y, 'inout') parameterType (y, x)) Regra&amp; 3 -- Os produtos de trabalho internos (InternalUse) devem ser produzidos num processo de software.
Regra&amp; 4 ­ Uma parâmetro de entrada e/ ou saída (ProcessParameter) de uma atividade deve estar sempre associado a exatamente um produto de trabalho do tipo interno ou externo (InternalUse ou ExternalUse).
Y (processParameter (y) x (internalUse (x) externalUse (x)) parameterType (y, x)) A metaclasse WorkProductUse possui outras relações no diagrama de metaclasses da Figura 1 que necessitam ser traduzidas na linguagem formal sobre processos de software.
Esse é o caso, por exemplo, e sejam das relações com as que metaclasses permitem, para um ProcessResponsabilityAssignment respectivamente, que papéis WorkProductUseRelationship atribuídos como responsáveis WorkProductUse (ExternalUse ou InternalUse) e que relacionamentos sejam criados entre WorkProductUses (ExternalUse ou InternalUse).
Para definir a relação de responsabilidade para um determinado WorkProductUse, os seguintes predicados foram criados:
ProcessResponsabilityAssignment onde x representa uma instância da metaclasse ProcessResponsabilityAssignment e linkedWorkProductUse (x, y) onde x corresponde a uma instância da metaclasse ProcessResponsabilityAssignment e y representa uma instância da metaclasse WorkProductUse (ExternalUse ou InternalUse).
Considerando a metaclasse WorkProductUseRelationship que, como já dito, permite determinar diferentes tipos de relacionamentos entre WorkProductUses, definiram- se os seguintes predicados:
WorkProductUseRelationship onde x representa uma instância de WorkProductUseRelationship e relationType (x, 'composition') onde x representa uma instância de WorkProductUseRelationship e'composition' o valor da propriedade (constante) relationType.
A propriedade relationType também pode assumir os valores' dependency` e'agregation'.
Foram necessários ainda os predicados source (x, y) e target (x, y) em os quais, em ambos os predicados x representa uma instância de WorkProductUseRelationship e y corresponde a uma instância de um WorkProductUse (ExternalUse ou InternalUse).
O WorkProductUse que está no source é o elemento que mantém relacionamento com o WorkProductUse que está no target.
Considere, por exemplo, que o InternalUse A mantém um relacionamento do tipo WorkProductUseRelationship com o ExternalUse B, com o valor de relationType igual a &quot;composition».
Se o InternalUse A está no source desta relação e o ExternalUse B está no target, significa dizer que o InternalUse A é uma composição de ExternalUse B_ O predicado que define uma relação de composição entre dois WorkProductUses é o seguinte:
Uma vez que o predicado acima será bastante utilizado, optou- se por simplificar- lo, criando a seguinte sentença:
Z, x, y (externalUse (x) internalUse) (externalUse (y) internalUse (y)) (workProductUseRelationship (z) relationType (z, 'composition') source (z, x) target (z, y) composicao (x, y) Agora, toda vez que for necessário estabelecer uma relação de composição entre dois WorkProductUses, usará- se- o predicado composicao (x, y).
Considere, também, que o predicado acima existe para os outros valores de relationType.
De essa forma, para obter os predicados dos valores' dependency` e'agregation', basta trocar o valor de relationType e o nome do predicado.
A relação de dependência possui um predicado adicional, pois algumas regras de boa-formação para consistência são válidas apenas para quando um WorkProductUse é do tipo InternalUse.
De essa maneira, considere o seguinte predicado para o momento em que um WorProductUse (InternalUse ou ExternalUse) depende de um InternalUse:
Conforme explicado no Capítulo 4, as relações de composição, agregação e dependência são relações transitivas.
Os axiomas abaixo formalizam essa propriedade para tais relações.
X, y, z (composicao (x, y) composicao (y, z) composicao (x, z) x, y, z (agregacao (x, y) agregacao (y, z) agregacão (x, z) x, y, z (dependencia (x, y) dependência (y, z) dependência (x, z) (A5) Com base nas relações e predicados definidos acima, as seguintes regras de boaformação para consistência foram definidas.
Regra&amp; 5 -- Um produto de trabalho externo ou interno (ExternalUse ou InternalUse) não pode ser o &quot;todo «num relacionamento de composição se uma de suas &quot;partes «já representa o seu &quot;todo «em outro relacionamento de composição ou representa o seu &quot;todo «por a transitividade da relação de composição.
X, y (composicao (x, y) composicao (y, x) Regra&amp; 5 -- Um produto de trabalho externo ou interno (ExternalUse ou InternalUse) não pode ser o &quot;todo «num relacionamento de agregação se uma de suas &quot;partes «já representa o seu &quot;todo «em outro relacionamento de agregação ou representa o seu &quot;todo «por a transitividade da relação de agregação.
Regra&amp; 5 -- Um produto de trabalho externo ou interno (ExternalUse ou InternalUse) não pode depender de um produto de trabalho externo ou interno (ExternalUse ou InternalUse) que já é seu dependente.
X, y (dependencia (x, y) dependencia (y, x) Regra&amp; 49 -- Um produto de trabalho externo ou interno (ExternalUse ou InternalUse) não pode representar o &quot;todo «e a &quot;parte «num relacionamento de composição.
Regra&amp; 49 -- Um produto de trabalho externo ou interno (ExternalUse ou InternalUse) não pode representar o &quot;todo «e a &quot;parte «num relacionamento de agregação.
X agregacao (x, x) Regra&amp; 49 -- Um produto de trabalho externo ou interno (ExternalUse ou InternalUse) não pode depender de si próprio.
Regra&amp; 7 -- Um produto de trabalho externo ou interno (ExternalUse ou InternalUse) não pode ser &quot;parte «em mais de um relacionamento de composição.
X, y, z (composition (x, y) composition (x, z) Regra&amp; 8 ­ Um produto de trabalho do tipo interno (InternalUse) deve possuir ao menos um relacionamento com a metaclasse ProcessResponsabilityAssignment.
As próximas regras de boa-formação formalizadas são relacionadas com os aspectos de duplicidade e opcionalidade e envolvem os elementos de processo Atividade, Produto de Trabalho (Interno ou Externo) e Papel, bem como seus relacionamentos.
Embora estes elementos de processo possuam muitos relacionamentos, os predicados definidos para a formalização das próximas regras de boa-formação foram apenas:
O tipo activity onde x representa uma instância da metaclasse Activity;
O tipo roleUse onde x corresponde a uma instância da metaclasse RoleUse;
E o predicado isOptional (x, 'true') que representa uma propriedade para os elementos Atividade, Produto de Trabalho (Interno ou Externo) e Papel.
Em esse último, x representa uma instância da metaclasse Activity, RoleUse, InternalUse ou ExternalUse e'true` ou 'false' referem aos valores (constante) para a propriedade isOptional que o x pode assumir.
A partir de os novos predicados, as seguintes regras de boa-formação foram formalizadas:
Regra&amp; 25 ­ Uma atividade (Activity) opcional não deve possuir elementos obrigatórios.
Regra&amp; 29 ­ Um produto de trabalho do tipo interno (InternalUse) obrigatório deve ser associado a pelo menos um papel (RoleUse) obrigatório.
X (internalUse (x) isOptional (x, 'false) y, z (roleUse (y) isOptional (y,' false') (processResponsabilityAssignment (z) linkedWorkProductUse (z, x) linkedRoleUse (z, y))) Regra&amp; 33 ­ Não deve existir mais de um papel (RoleUse) com o mesmo nome num processo de software.
Regra&amp; 34 ­ Não deve existir mais de um produto de trabalho do tipo externo (ExternalUse) com o mesmo nome num processo de software.
X, y, n1, n2 (externalUse (x) name (x, n1) (externalUse (y) name (y, n2) n1 n2) Regra&amp; 34 ­ Não deve existir mais de um produto de trabalho do tipo interno (InternalUse) com o mesmo nome num processo de software.
Regra&amp; 36 ­ Um papel (RoleUse) não deve ser definido mais de uma vez como responsável por o mesmo produto de trabalho do tipo externo ou interno (ExternalUse ou InternalUse).
X, y, z (roleUse (x) workProductUse (y) (processResponsabilityAssignment (r) linkedRoleUse (r, x) linkedWorkProductUse (r, y)) w (processResponsabilityAssignment (w) linkedRoleUse (w, x) linkedWorkProductUse (w, y)) Regra&amp; 37 ­ Um produto de trabalho do tipo externo ou interno (ExternalUse ou InternalUse) não deve ser definido mais de uma vez como dependente do mesmo produto de trabalho do tipo externo ou interno (ExternalUse ou InternalUse).
ExternalUse) (internalUse (y) ExternalUse (y)) (workProductUseRelationship (r) source (r, x) target (r, y) relationType (r, 'dependency') w (workProductUseRelationship (w) source (w, x) target (w, y) relationType (r, 'dependency' Regra&amp; 38 ­ Um produto de trabalho do tipo externo ou interno (ExternalUse ou InternalUse) não deve ser definido mais de uma vez como o todo, através de uma relação de composição, do mesmo produto de trabalho do tipo externo ou interno (ExternalUse ou InternalUse).
ExternalUse) (internalUse (y) ExternalUse (y)) (workProductUseRelationship (r) source (r, x) target (r, y) relationType (r, 'composition') w (workProductUseRelationship (w) source (w, x) target (w, y) relationType (r, 'composition' Regra&amp; 39 ­ Um produto de trabalho do tipo externo ou interno (ExternalUse ou InternalUse) não deve ser definido mais de uma vez como o todo, através de uma relação de agregação, do mesmo produto de trabalho do tipo externo ou interno (ExternalUse ou InternalUse).
ExternalUse) (internalUse (y) ExternalUse (y)) (workProductUseRelationship (r) source (r, x) target (r, y) relationType (r, 'agregation') w (workProductUseRelationship (w) source (w, x) target (w, y) relationType (r, 'agregation')) Observando as relações do elemento Activity no pacote Process Structure, nota- se que esse elemento possui um relacionamento de composição com a metaclasse abstrata BreakdownElement, a qual tem como subclasses ProcessParameter, ProcessPerformer, WorkProductUse, RoleUse, entre outras.&amp;&amp;&amp;
De esse modo, para representar tal relação definiu- se o predicado de associação parte-de (x, y) que indica que x é uma parte de y.
Em a relação entre Activity e ProcessParameter, por exemplo, pode- se usar esse predicado para descrever a relação de composição existente entre as referidas metaclasses.
Assim, considerando o predicado parte-de, derivam- se os seguintes axiomas:
Outra relação elemento Activity, herdada metaclasse WorkBreakdownElement, que precisou ser formalizada foi a relação com a metaclasse WorkSequence que permite definir o sequenciamento entre atividades de um processo de software.
Para capturar essa relação de seqüenciamento entre atividades, foi necessário a criação de vários predicados e axiomas que formalizam esta relação.
De essa maneira, os primeiros predicados criados são relacionados com a metaclasse WorkSequence e seus atributos.
Tais predicados são:
WorkSequence; Predecessor (x, y);
Sucessor (x, y) e linkKind (x, 'Fs').
Em todos eles, o x é uma instância de WorkSequence.
Em os predicados predecessor e sucessor o y representa uma instância de Activity, e, no predicado linkKind 'Fs' representa o valor finishToStart.
O último predicado também pode assumir os outros valores (constantes) do atributo linkKind que são e'SS' (startToStart).
Outro predicado definido foi o predicado specialNode (x, 'start') onde x é uma instância de Activity e'start' denota o tipo desta Activity.
O predicado specialNode pode assumir também os valores (constantes)' end` e'em a'.
Embora as metaclasses e relações descritas acima, mostradas na Figura 55, sejam suficientes para expressar o conceito de precedência entre tarefas, na linguagem utilizada nesta pesquisa, foi definido um novo conjunto de conceitos e predicados.
A ideia é que as mesmas informações presentes no modelo da UML possam ser expressas.
Contudo, considerando a lógica de primeira ordem, os novos conceitos e predicados facilitam o entendimento das regras de boa-formação que consideram as informações de precedência.
Em esse sentido, afim de capturar o conceito de atividade predecessora e sucessora criou- se os predicados pré-atividade e pós-atividade indicando, respectivamente, que a1 é uma atividade predecessora de a2 ou, de forma inversa, que a2 é uma atividade sucessora de a1.
Como pode ser visto, em ambos os predicados, a1 e a2 são instâncias de Activity.
Considerando que as relações de precedência pré e pósatividade são transitivas e assimétricas, os seguintes axiomas foram definidos:
Para formalizar os conceitos de atividade- inicio e atividade-fim, os quais foram incluídos nesta pesquisa no metamodelo sSPEM 2.0 (conforme Capítulo 4), os seguintes predicados foram definidos:
Atividade- inicio (a, ai) e atividade-fim (a, af), em os quais a representa uma instância de Activity e ai e af identificam, respectivamente, o início e o fim dessa Activity.
Em o intuito de registrar que toda atividade realmente possui um início e um fim e que o início precede o fim, considere os seguintes axiomas:
Regra&amp; 39 ­ Um produto de trabalho (WorkProductDefinition) não deve ser definido mais de uma vez como o todo, através de uma relação de agregação, do mesmo produto de trabalho (WorkProductDefinition).
A avaliação da solução proposta nesta tese foi feita com base em testes analíticos verificando- se os resultados produzidos por a aplicação das regras de boa-formação para consistência sobre cenários simulados.
Para realização desta avaliação foi desenvolvido um protótipo de ferramenta que suporta automaticamente o uso do metamodelo sSPEM 2.0 e das regras de boa-formação para consistência.
Em as seções seguintes, serão apresentados cinco cenários baseados no processo de software OpenUP.
O OpenUP é uma parte do Eclipse Process Framework -- EPF que representa um framework de processo open source desenvolvido dentro de a Eclipse Foundation.
Este processo é uma versão simplificada do RUP que aplica uma abordagem iterativa e incremental dentro de um ciclo de vida estruturado.
O OpenUP foi escolhido para realização dessa avaliação porque esse processo está em conformidade com o metamodelo sSPEM 2.0.
Além disso, por fazer parte do EPF, esse processo vem sendo utilizado por a comunidade de software livre, assumindo certa relevância como processo de engenharia de software.
O restante deste capítulo é organizado da seguinte forma:
Em a Seção 7.1 o protótipo desenvolvido é resumidamente descrito;
Em a Seção 7.2 os cenários de testes são descritos e as regras de boa-formação para consistência são utilizadas, sendo os resultados desta utilização descritos de forma analítica;
E, por fim, a Seção 7.3 apresenta as conclusões do capítulo.
Tendo em vista que a quantidade de metaclasses e regras de boa-formação para consistência do metamodelo sSPEM 2.0 é elevada e que processos de software, geralmente, possuem uma grande quantidade de informações, considera- se que a falta de suporte automatizado torna o uso da solução proposta por esta pesquisa bastante difícil.
Isso porque, todas as análises implícitas nas regras de boa formação para consistência, tanto na atividade de definição dos processos quanto nas atividades de adaptação desses processos, constituiriam uma tarefa exaustiva com maior probabilidade de erros.
Baseado nesse contexto, foi desenvolvido um protótipo de ferramenta para auxiliar a utilização do metamodelo sSPEM 2.0 e das regras de boa-formação para consistência.
O protótipo, que é denominado sSPEM Tool, foi desenvolvido utilizando como principais tecnologias o Eclipse Modeling Framework -- EMF e o IBM Rational Software Modeler -- RSM.
O IBM Rational Software Modeler (RSM) é uma ferramenta Case desenvolvida por a IBM Rational Software que foi construída para facilitar a modelagem de sistemas Orientados a Objetos utilizando UML.
O foco dessa ferramenta é sua capacidade de permitir a modelagem visual dos conceitos definidos por a Model Driven Development (MDD).
O protótipo sSPEM Tool implementa funcionalidades para a definição de processos de software a partir de o metamodelo sSPEM 2.0 e das regras de boa-formação para consistência.
Também permite a adaptação desses processos através dos mecanismos de adaptação usedActivity e supressedBreakdownElement.
O Eclipse Modeling Framework provê funcionalidades de infraestrutura reutilizáveis e, por se constituir basicamente do ECore, fornece diversas funcionalidades de modelagem, tais como:
Persistência em XMI ou Objeto Relacional, validação de integridade de modelo e gerência dos dados do modelo com utilização de transação.
Metamodelagem A camada de modelo possui toda a implementação do metamodelo sSPEM 2.0 que foi feita com a utilização de linguagem Java.
Em essa camada estão os contratos e restrições, feitos a partir de Java Interfaces.
Interface Gráfica A interação entre a ferramenta e o seu usuário é realizada através desta camada.
Toda a interface gráfica utiliza SWT e baseia- se nos conceitos de Views, Perspectives e Wizards, assim como nos encontrados na plataforma Eclipse.
Isso ocorre por o fato da ferramenta sSPEM Tool funcionar como um plugin para o Eclipse, estendendo suas funcionalidades.
As principais funcionalidades do sSPEM Tool são a definição e a adaptação de processos de desenvolvimento de software.
Adicionalmente, uma funcionalidade para validação de consistência dos processos de software, também encontra- se disponível neste protótipo.
Em esta seção são apresentados os cenários desta avaliação.
Como já exposto, todos os cenários utilizam informações do processo OpenUP.
Contudo, outras informações são introduzidas nesse processo para contemplar os novos elementos do metamodelo sSPEM 2.0.
Tais informações são relacionadas com:
Opcionalidade de elementos;
Produtos de trabalho internos x externos;
E dependências entre produtos de trabalho.
Além de as informações acima, são incluídas algumas situaçõesproblema que representam inconsistências num processo de software.
O objetivo das inserções é demonstrar que as regras de boa-formação para consistência identificam tais inconsistências.
Todas as informações acima e situações-problema são incluídas nos cinco cenários a seguir.
Comentários explicando cada etapa desta avaliação são apresentados para facilitar a compreensão.
Durante a avaliação a identificação das regras de boa-formação será realizada por os seus respectivos identificadores, conforme apresentado no Capítulo 4.
Tendo em vista que sSPEM Tool foi implementado utilizando- se da língua inglesa, os identificadores das regras de boa-formação tiveram a palavra Regra traduzida para o inglês.
Assim, por exemplo, a regra de boa-formação Regra&amp; 1 é identificada em sSPEM Tool como Rule&amp; 1.
Para iniciar a criação dos cenários de avaliação foi necessário a inclusão do processo OpenUP em sSPEM Tool.
Para realizar essa inclusão, os passos definidos no guia para definição de um processo de software que reutiliza conteúdo de um repositório (Method Content) foram seguidos (conforme Capítulo 5).
Os referidos passos são:
Criar uma nova biblioteca (Method Library);
criar um Method Content para a biblioteca e criar um ProcessPackage (definindo o atributo isAuthoring igual a true).
A Tabela 16 mostra os tipos e quantidade de elementos criados para o Method Content e o ProcessPackage da biblioteca em questão.
A tabela também expõe as metaclasses do metamodelo sSPEM 2.0 utilizadas para criação desses elementos.
Essas metaclasses foram escolhidas, respeitando a especificação textual do SPEM 2.
0. Apenas para o caso da metaclasse ProcessPackage, outras instâncias desse elemento foram criadas durante a presente avaliação.
Isso foi feito, pois, de acordo com o guia para definição e adaptação de processos, cada processo de software definido a partir de o metamodelo sSPEM 2.0 deve ser representado por uma instância da metaclasse ProcessPackage.
Além disso, é definido, no mesmo guia, que, para cada instância de ProcessPackage, deverá ser informado, através do atributo isAuthoring, se o processo de software sendo criado está na fase de definição (isAuthoring $= 'true') ou irá sofrer atividades de adaptação (isAuthoring $= 'false').
Vale destacar também que, para inclusão do processo OpenUP, todas as tarefas, produtos de trabalho e papéis definidos no Process Package foram criados e associados aos elementos do Method Content, ou seja, o conteúdo definido para a biblioteca foi utilizado na criação do processo.
O número elevado de tarefas no Process Package se dá devido a o fato de uma mesma tarefa ser executada várias vezes no ciclo de vida do desenvolvimento.
Além de os elementos relacionados na Tabela 16, outros foram criados tanto no Method Content quanto no Process Package durante a inclusão do OpenUp.
Estes elementos representam os relacionamentos do processo.
Várias instâncias, por exemplo, da metaclasse ProcessPerformer e Default_ ProcessPerformer, foram criadas para, respectivamente, no Process Package e Method Content, representar a associação entre as tarefas e os papéis.
Outro exemplo são as instâncias da metaclasse WorkSequence criadas no Process Package, as quais foram utilizadas para definir o sequenciamento entre as fases do OpenUp e entre algumas das atividades que compõem as iterações desse processo.
A Figura 60 mostra o processo OpenUP incluído em sSPEM Tool.
Como pode ser visto, a GUI é dividida em várias janelas:
Em a) está a janela Package Hierarchi View que provê uma iteração com os projetos existentes e seus conteúdos internos, apresentados de forma hierárquica.
O primeiro cenário utilizado nesta avaliação é o processo OpenUP na sua forma original.
Para esse cenário, nenhuma informação específica do metamodelo sSPEM 2.0 foi utilizada.
O objetivo aqui foi verificar se o processo avaliado, quando não submetido a nenhuma mudança, é consistente.
É importante considerar que nem todas as regras de boa-formação para consistência definidas nesta pesquisa podem ser avaliadas nesse cenário, uma vez que como dito acima, nenhuma informação específica do metamodelo sSPEM 2.0 foi incluída até o presente momento no processo OpenUP.
Assim, sabe- se que alguns tipos de inconsistências não poderão ser identificados e, por conseqüência, algumas premissas não poderão ser analisadas.
Baseado no contexto acima, as premissas e regras de boa-formação consideradas para este cenário são:
A o final desta seção todas as premissas e regras de boa-formação avaliadas neste cenário são relacionadas com objetivo de verificar quais de elas foram atendidas e quais não foram atendidas (gerando inconsistências no processo).
O primeiro passo para avaliação do Cenário 1 envolve e execução do framework de validação sobre esse processo.
Em a prática isto implica na validação do elemento Process Package, uma vez que todos os demais elementos do processo estão a ele vinculados por um relacionamento de composição.
A Figura 64 exibe os erros retornados por o protótipo na janela Problems View.
A seguir, segue- se uma interpretação dos resultados desta validação.
Observa- se, na Figura 64 (janela Properties View) que a quantidade de erros retornados por o protótipo durante a primeira avaliação foi igual a 19 e a quantidade de warnings igual a 7.
Analisando, inicialmente, os erros retornados, verifica- se que grande parte de eles, é relacionada com a regra de boa-formação Rule&amp; 20.
A regra de boa-formação em questão estabelece que todo produto de trabalho considerado interno (InternalUse) deverá ser produzido por, pelo menos, uma tarefa no processo de software antes de ser consumido.
Além disso, é preciso que a tarefa que gera o produto de trabalho tenha caminho definido, através das estruturas de sequenciamento até as tarefas que consomem esse produto de trabalho.
Especificamente, dos 17 erros retornados por essa regra, 10 de eles estão relacionados com as tarefas das atividades Initiate Project e Plan and Manage Iteration.
Existem casos onde o produto de trabalho foi produzido (produtos de trabalho Iteration Plan, Vision e Glossary), mas não existe caminho entre a tarefa produtora e a tarefa consumidora;
E, existem casos onde o produto de trabalho realmente ainda não foi produzido.
Como exemplo para este segundo caso, verifica- se os produtos de trabalho Use Case, Use Case Model, System-Wide Requirement e Work Items List que são consumidos por a tarefa Plan Project, mas não são produzidos por nenhuma das tarefas iniciais do processo.
Prosseguindo com a avaliação das inconsistências, verifica- se que outros dois erros relacionados com as regras de boa-formação Rule&amp; 28 e Rule&amp; 3 também foram apresentados.
Ambos os erros são apontados para o produto de trabalho Work Items List e indicam, respectivamente, que esse produto de trabalho não é produzido por nenhuma tarefa no processo e não está associado a nenhuma tarefa obrigatória.
Em verdade, os dois erros foram apontados por o fato do produto de trabalho Work Items List não ser produzido por nenhuma tarefa no processo OpenUP, mas, mais especificamente, a regra Rule&amp; 3 identificou que a tarefa produtora desse produto de trabalho precisa ser obrigatória no processo, já que tal produto de trabalho foi definido como obrigatório.
Isso aconteceu porque, embora esse cenário não contemple as informações incluídas no metamodelo sSPEM 2.0 (como, por exemplo, as opcionalidades dos elementos para o processo), elas já existem em sSPEM Tool e, para alguns casos, são de cadastramento obrigatório, como é o caso de informações sobre opcionalidade.
Assim, todos os elementos do OpenUP foram incluídos como obrigatórios no protótipo.
Além de os erros retonados por a validação feita no OpenUP, verifica- se também que 7 warnings foram identificados.
Warnings não representam inconsistências num processo de software e não podem causar danos à execução das tarefas.
Em o caso específico da avaliação deste cenário, todos os warnings identificados estão relacionados com a relação tarefas x produtos de trabalhos x papéis.
O que ocorre é que, em todos os casos, mais de um responsável foi definido para os produtos de trabalho e existem casos onde nem todos os responsáveis por um determinado produto de trabalho foram associados às suas tarefas de produção.
Como a regra de boa-formação Rule&amp; 24 estabelece que, pelo menos, um responsável por o produto de trabalho deve estar associado a todas as suas tarefas de produção a condição foi atendida.
Contudo, os alertas existem e são de caráter informativo.
Em a Tabela 17 é apresentado o resultado da avaliação indicando quais regras de boa-formação foram atendidas e não atendidas neste Cenário.
O Cenário 2 avalia os aspectos de dependência entre os produtos de trabalho e as informações sobre opcionalidade num processo de software.
As premissas e regras de boa-formação avaliadas nesse cenário são:
Em o Cenário 2 novas informações foram incluídas no processo OpenUP, tendo como base o metamodelo sSPEM 2.0.
Tais informações referem- se a dependências entre os produtos de trabalho e opcionalidade dos elementos deste processo.
Para incluir as dependências entre os produtos de trabalho do OpenUP, uma análise sobre a descrição de todas as tarefas do processo foi realizada.
Uma vez que este processo não mapeia esse tipo de informação, esta foi a única forma de identificar as dependências existentes sobre os produtos de trabalho.
Para entender melhor como foi realizado o processo de mapeamento de dependências entre produtos de trabalho, pode- se tomar como exemplo a dependência encontrada entre os produtos de trabalho Test Case x Test Script.
Em essa relação, foi definido que o produto de trabalho Test Script depende do produto de trabalho Test Case.
Isso foi feito, pois, observando a descrição de ambos produtos de trabalho e também de suas tarefas produtoras, constatou- se que não é possível produzir Test Script no OpenUP sem produzir o produto de trabalho Test Case.
A Tabela 18 indica a relação de dependências mapeadas para todos os produtos de trabalho do OpenUP.
Em a coluna da esquerda é relacionado um produto de trabalho e, na coluna da direita, foram relacionadas suas dependências.
Produto de Trabalho Test Case Build Test Script Architecture Notebook Design Implementation Test Log Dependência (s) Use Case Implementation Test Case System-Wide Requirements e Use Case Desing, Use Case e System-Wide Requirements Build, Test Script e Implementation Depois de incluído as dependências acima, as informações sobre opcionadade precisaram também ser incluídas.
Mais uma vez, um estudo sobre toda descrição do processo foi realizada.
Em este momento, verificou- se que todas as tarefas e todos os produtos de trabalho são obrigatórios no OpenUP, assim sendo, tornar- los opcionais levaria a várias mudanças nesse processo.
Então, para resolver essa situação viabilizando a avaliação das premissas e regras de boa-formação sobre opcionalidade, novas atividades, tarefas, papéis e produtos de trabalho foram incluídos.
De esse modo, foi possível incluir algumas situações-problema no processo e avaliar os resultados do framework de validação.
A nova atividade incluída é composta de 3 novas tarefas, 2 novos produtos de trabalho e 2 novos papéis e refere- se a uma atividade de verificação e validação dos requisitos no processo.
Embora o OpenUP não possua essa atividade, ela é bastante comum nos processos de desenvolvimento de software, tais como o RUP e o OPEN.
Tal atividade foi incluída em todas as iterações onde existem atividades de documentação de requisitos.
A Figura 67 detalha a atividade incluída em termos de tarefas e produtos de trabalho (consumidos, modificados e produzidos).
Abaixo, a Figura 68 mostra os novos elementos incluídos em sSPEM Tool.
É possível ver na Figura 68 que a atividade Verify and Validate Requirements foi incluída nas fases Inception, Elaboration e Construction, respectivamente, nas suas iterações Inception Iteration, Elaboration Iteration e Construction Iteration.
Os únicos elementos que não foram mostrados na Figura 67 foram os novos papéis que desempenham as novas tarefas (iss porque eles foram incluídos no pacote de papéis).
Esses papéis são Client e Reviewer que desempenham, respectivamente, as tarefas Validade Requirements e Verify Requirements.
A tarefa Validade Requirements é também desempenhada por o papel Analyst que é quem desempenha a nova tarefa Ajust Requirements.
O responsável por os novos produtos de trabalho Requirements Acceptance e Requirements Verification é o papel Analyst.
Deve- se notar que o responsável por o produto de trabalho Requirements Verification não é o papel que desempenha a tarefa de produção (Verify Requirements) desse produto de trabalho.
Essa situação-problema foi incluída, propositalmente, no sSPEM Tool para verificar o resultado de sua avaliação no framework de validação.
Outra situação-problema incluída nos novos elementos foi referente a a sua opcionalidade no processo de software.
Foram definidos como opcionais o produto de trabalho Requirements Acceptance e o papel Reviewer.
Isso introduz 2 novas inconsistências no processo que são explicadas a seguir, durante a análise dos resultados deste cenário.
Uma vez incluídas todas as informações necessárias no Cenário 2, o próximo passo desta avaliação foi executar o framework de validação sobre o elemento Process Package.
O resultado disso foi o retorno de 41 erros e 7 warnings.
A saída exibida na janela Problems View pode ser vista na Figura 69.
Visualiza- se que os 19 erros e 7 warnigns encontrados no Cenário 1 foram novamente retornados por o framework de validação.
Isso já era esperado uma vez que nenhum dos erros foi consertado até o momento, tendo sido apenas incluídas novas informações.
Os novos erros totalizam 22 novas inconsistências para o processo OpenUP.
Em análise aos novos erros gerados, verificou- se, por os resultados retornados, que as inconsistências relacionadas com informações sobre dependência entre produtos de trabalho foram as inconsistências que violaram as regras de boa-formação Rule&amp; 11 e Rule&amp; 19.
Estas regras estabelecem, respectivamente, que as todas as dependências de um produto de trabalho devem estar conectadas como entrada nas suas tarefas de produção e que todas estas dependências devem ser produzidas antes do produto de trabalho em questão.
Além disso, a Rule&amp; 19 verifica ainda se existe caminho entre as tarefas que produziram a dependência e a (s) tarefa (s) que a consome (m).
Para a Rule&amp; 11, foram mostrados 4 erros para o mesmo produto de trabalho e para a mesma tarefa.
Isso ocorreu, pois a tarefa em questão (Run Developer Tests) é executada em 4 pontos diferentes do processo e não possui como entrada o produto de trabalho Test Script que é necessário à produção do produto de trabalho Test Log.
Contudo, embora o erro esteja replicado, para consertar- lo, basta corrigir essa tarefa no Method Content.
Em este momento, todas as instâncias dessa tarefa no processo de software, seriam atualizadas.
Em verdade, qualquer erro relacionado com tarefas que possuem mais de uma instância no processo de software é replicado no resultado de validação.
Como dito acima, não é necessário consertar um erro por vez, mas sim consertar o erro no Method Content.
Os erros retornados para a Rule&amp; 19 já eram esperados nesta avaliação.
A razão para ocorrência desse tipo de erro no OpenUP está relacionado ao mesmo motivo da ocorrência dos erros relacionados com a Rule&amp; 20.
Como já mencionado no Cenário 1, isso ocorre porque o sequenciamento entre tarefas não é completo no OpenUP, ou seja, nem todas as tarefas deste processo são seqüenciadas e muitos produtos de trabalho são realmente consumidos antes de serem produzidos.
Outros erros retornados no resultado desta avaliação são todos resultantes dos novos elementos (atividades, tarefas, produtos de trabalho e papéis) incluídos neste cenário.
Especificamente, em análise ao erro relacionado com a regra de boa-formação Rule&amp; 24, é possível verificar que este erro foi retornado pois o papel que é responsável por o produto de trabalho (Requirements Verification) não é o mesmo que desempenha suas tarefas de produção no processo.
Cabe lembrar que, para este cenário, foi incluído o papel Analyst como responsável por o produto de trabalho Requirements Verification e definido o papel Reviewer como desempenhador das tarefas que produzem este produto de trabalho (Verify Requirements).
Como esse fato viola a regra de boa-formação Rule&amp; 24, o erro foi retornado 3 vezes no framework de validação, indicando que a tarefa é executada em 3 pontos diferentes do processo.
Por fim, os erros relacionados com as regras de boa-formação Rule&amp; 30, Rule&amp; 31 e Rule&amp; 32 são todos relacionados com aspectos de opcionalidade dos elementos no processo de software.
Esses erros ocorreram, pois o papel Reviewer e o produto de trabalho Requirements Acceptance foram definidos como opcionais e todos os outros elementos, os quais são relacionados com ambos, papel e produto de trabalho, são obrigatórios.
O erro relacionado com a regra de boa-formação Rule&amp; 30 ocorreu pois a tarefa obrigatória Validade Requirements produz apenas o produto de trabalho opcional Requirements Acceptance.
Como a Premissa P&amp; 18 estabelece que toda tarefa obrigatória deverá estar a associada a, pelo menos, um produto de trabalho obrigatório, bem como ser executada por, pelo menos, um papel obrigatório e a Premissa P&amp; 7 estabelece que toda tarefa de um projeto de software deve ser desempenhada por um papel e produzir um resultado de valor observável em termos de produtos de trabalho, esse cenário desrespeita diretamente a Premissa P&amp; 18 e indiretamente a Premissa P&amp; 7.
Diz- se que a Premissa P&amp; 7 é desrespeitada indiretamente porque o produto de trabalho Requirements Acceptance poderia ser excluído do processo e, nesse caso, violaria a regra de boa-formação Rule&amp; 9, desrespeitando, assim, diretamente a premissa P&amp; 7.
As últimas regras de boa-formação violadas neste Cenário foram as regras Rule&amp; 31 e Rule&amp; 32.
Relacionado à regra Rule&amp; 31, isso ocorreu, pois o papel obrigatório Analyst que é responsável por o produto de trabalho obrigatório Requirements Verification não está associado à tarefa obrigatória de produção desse produto de trabalho (Verify Requirements).
Embora essa regra seja similar a regra Rule&amp; 24 explicada acima, ela trata especificamente sobre a opcionalidade dos elementos.
Por fim, a regra de boaformação Rule&amp; 32 foi violada, pois o papel opcional Reviewer foi definido como único executor da tarefa obrigatória Verify Requirements.
Os fatos acima desrespeitam diretamente a Premissa P&amp; 18 e Premissa P&amp; 6 e indiretamente a Premissa P&amp; 7.
Vale destacar que os erros estão duplicados no resultado da avaliação, uma vez que as tarefas em questão são desempenhadas em vários pontos do processo OpenUP.
A Tabela 19 mostra os resultados da avaliação do Cenário 2 em termos de quais regras de boa-formação e premissas puderam ou não ser atendidas.
Observa- se que muitos produtos de trabalho foram definidos como produtos de trabalho externos.
Por se tratar de um processo para um projeto de manutenção de software, foi considerado para o Cenário 3 que todos os produtos de trabalho de Requisitos, Análise, Implementação e Testes já estavam prontos e sofrerão apenas modificações no novo projeto de software.
Essa é a razão para que tais produtos de trabalho tenham sido definidos como externos (ExternalUse).
Outro ponto importante a considerar é que algumas tarefas foram alteradas na iteração Inception Iteration para contemplar apenas a modificação dos produtos de trabalho externos.
Quanto a a opcionalidade dos elementos do processo, considerou- se que a modificação de todos os produtos de trabalho de Requisitos, Análise, Implementação e Testes é opcional no processo criado.
Em projetos de software, por exemplo, que não possuem nenhuma alteração, inclusão e exclusão de termos de negócio, não será necessário a atualização do produto de trabalho Glossary.
Já em projetos que apenas corrijem erros no código não serão necessárias alterações em nenhum produto de trabalho de Requisitos e Análise.
Como consequência da definição de produtos de trabalho opcionais, para não causar inconsistências em tal processo, todas as tarefas de modificação e papéis associados a essas tarefas também foram definidos como opcionais.
Essa definição foi realizada, pois, embora se saiba que num processo de manutenção de software evolutiva exista alteração, inclusão e/ ou exclusão de requisitos, por não conhecer tais requisitos, não é possível identificar durante a definição de um processo de software quais produtos de trabalho sofrerão alteração.
Ainda relacionado ao aspecto de opcionalidade, o produto de trabalho Requirements Verification e as tarefas de verificação e ajuste dos requisitos Verify Requirements e Ajust Requirements também foram redefinidas como opcionais.
Todas as outras tarefas e os outros produtos de trabalho relacionados com planejamento de projeto e validação dos requisitos por parte de o cliente continuaram sendo considerados obrigatórios.
Após todas as definições acima e criação das novas tarefas no Method Content, o novo processo foi definido na área de processos em sSPEM Tool.
Em este momento, todos os produtos de trabalho, tarefas e papéis foram utilizados a partir Method Content.
Ainda, todos os produtos de trabalho de Requisitos, Análise, Implementação e Testes foram definidos como externos.
A Figura 71 exibe a iteração Inception Iteration incluída em sSPEM Tool.
Como já exposto, o processo criado para este cenário é composto apenas por uma iteração.
Até este momento, nenhuma informação sobre sequenciamento foi incluída.
A ideia foi de, antes de incluir essas informações, executar o framework de validação e verificar se inconsistências relacionadas com aspectos de sequenciamento são identificados.
O resultado dessa validação é exibido na Figura 72.
Avaliando os resultados retornados por o framework de validação, verifica- se que várias inconsistências já explicadas nos cenários anteriores aparecem novamente.
É o caso das inconsistências relacionadas com as regras de boa-formação Rule&amp; 3,&amp; 20,&amp; 24,&amp; 28,&amp; 30 e&amp; 32.
A única diferença encontrada no resultado deste cenário relacionado com estas regras é a sua quantidade.
No caso de as inconsistências retornadas para as regras de boa-formação Rule&amp; 20,&amp; 24,&amp; 30 e&amp; 32, verifica- se que o número de inconsistências diminuiu.
Isso ocorreu porque este cenário não possui execução das mesmas tarefas em pontos diferentes do processo e porque a quantidade de produtos de trabalho utilizados é menor do que a quantidade dos outros cenários.
Já a regra de boa-formação Rule&amp; 3 aparece também para o produto de trabalho Test Log.
Isso ocorre, pois esse produto de trabalho não é produzido em nenhum ponto do processo.
A nova regra de boa-formação resultante no framework de validação é a regra Rule&amp; 18.
Ela aparece duas vezes no framework de validação e indica que existem inconsistências no fluxo do processo, uma vez que existem tarefas no processo desconectadas do nodo inicial e/ ou do nodo final.
Em o caso específico desta avaliação, uma vez que nenhum sequenciamento foi ainda definido, a regra retorna duas vezes indicando que todas as tarefas estão desconectadas do início e fim do processo.
Ainda que tenham sido criados vários produtos de trabalho do tipo externo para este cenário, verifica- se que nenhuma inconsistência foi encontrada relacionada com esse aspecto.
Isso ocorre pois todos os produtos de trabalho foram conectados como entrada e/ ou conectados como saída (para modificação) em alguma tarefa e também porque nenhuma tarefa foi conectada como produtora para nenhum desses produtos de trabalho, o que indica que eles foram definidos de forma consistente.
Para finalizar a avaliação do Cenário 3 outras regras de boa-formação para consistência relacionadas com sequenciamento foram testadas.
Para fazer isso, inicialmente, um fluxo foi definido para as tarefas que fazem parte da iteração Inception Iteration.
Optou- se por definir o fluxo entre as tarefas para que inconsistências relacionadas com os produtos de trabalho comecem a ser consertadas.
O fluxo definido para a iteração Inception Iteration é mostrado no em a Figura 73.
Essa figura mostra um módulo em sSPEM Tool desenvolvido para verificar informações sobre sequenciamento graficamente.
Deve- se notar que a Figura 73 apresenta, pela primeira vez, o sequenciamento num grafo, ou seja, nessa figura, é apresentada a solução de sequenciamento proposta nesta tese (conforme Capítulo 4).
A Figura 77 mostra a validação de uma nova regra relacionada com sequenciamento.
Em essa figura, os nodos em verde são os nodos que apresentam problemas (conforme legenda da Figura 77), pois não possuem conexão com o final do processo.
Ainda que exista problema de duplicação do nodo inicial do processo, a regra Rule&amp; 18 não aparece para esse tipo de nodo, pois todas as tarefas do processo estão devidamente conectadas com, ao menos, um início no processo, fato que atende a regra Rule&amp; 18.
Para complementar os erros que foram apresentados de forma visual, a Figura 78 mostra o resultado do framework de validação para o novo Cenário (neste momento, sem ciclos).
O resultado da validação mostrado na Figura 78 exibe que o processo não tem mais problemas de ciclo, uma vez que não existe mais retorno para a regra Rule&amp; 16.
A Figura 78 também mostra que os problemas relacionados com a regra Rule&amp; 20 voltaram a ser exibidos.
Isso ocorre, pois como dito anteriormente, quando não existem problemas de ciclo as regras Rule&amp; 17, Rule&amp; 18, Rule 19 e Rule&amp; 20 são normalmente avaliadas em sSPEM Tool.
Outra diferença encontrada referente a a última validação foi o novo erro (Rule&amp; 18) exibido como resultado.
Avaliadas as inconsistências relacionadas com sequenciamento de tarefas e tendo sido demonstrado a utilização de produtos de trabalho do tipo externo, considerouse, neste momento, encerrada a avaliação do Cenário 3.
A Tabela 20 apresenta o resultado da avaliação deste cenário.
Em este cenário as regras de boa-formação específicas para adaptação de processo são analisadas, sendo utilizado para tanto os mecanimos usedActivity e supressedBreakdownElement.
Aqui, o ambiente utilizado foi o mesmo do Cenário 3, ou seja, as atividades e tarefas da iteração Inception Iteration.
É importante citar, entretanto, que o Cenário considerado neste ponto da avaliação é o mesmo apresentado na Figura 73 e os erros considerados são os exibidos na Figura 74.
Em outras palavras, para esse cenário utiliza- se o Cenário 3 antes da inclusão dos problemas de sequenciamento (nodo inicial duplicado, exclusão do nodo final e inclusão de ciclos), bem como avalia- se as mesmas premissas e regras de boa-formação.
Uma vez que o processo do Cenário 3 contém várias inconsistências (conforme Figura 74) e que um novo processo será gerado através dos mecanismos de adaptação, o primeiro passo desta avaliação foi a modificação de algumas informações do processo utilizado nesse cenário com objetivo de consertar as suas inconsistências.
As primeiras informações modificadas corrigem os erros da regra Rule&amp; 20.
Em este momento, essa regra aparece 5 vezes no resultado da avaliação (conforme Figura 74) pois 5 produtos de trabalho são consumidos antes de serem produzidos no processo do Cenário 4.
Analisando esses produtos de trabalho, verifica- se que dois de eles, Iteration Plan e List Risk, são consumidos e produzidos por a mesma tarefa.
Como o consumo destes produtos de trabalho é opcional, optou- se por excluir- los das suas tarefas produtoras.
Após essas exclusões, o resultado do framework de validação retornou 11 erros.
Em verdade, o problema relacionado com o produto de trabalho List Risk foi solucionado pois este produto de trabalho não é mais consumido no processo do Cenário 4.
Contudo, os erros relacionados com a Rule&amp; 20 ainda se apresentam para os seguintes produtos de trabalho:
Iteration Plan, Project Plan, Work Items List e Test Log.
A solução para consertar os erros citados acima é a criação de caminhos entre as tarefas que produzem os produtos de trabalho em questão e todas as tarefas que consomem eles.
Contudo, nota- se, no framework de validação, através do erro Rule&amp; 3, que os produtos de trabalho Work Items List e Test Log não possuem tarefa de produção e, dessa forma, torna- se necessário a criação de novos elementos para o processo do Cenário 4.
Antes de continuar tratando os erros Rule&amp; 20, optou- se por analisar os produtos de trabalho Work Items List e Test Log.
Inicialmente, verificou- se que o produto de trabalho Test Log é entrada opcional para apenas uma tarefa (Assess Results) no Cenário 4.
De essa forma, decidiu- se excluir os seguintes elementos do processo:
O produto de trabalho Test Log, o relacionamento que definia os papéis Tester e Developer como responsáveis por este produto de trabalho e também o parâmetro de entrada que continha o produto de trabalho Test Log da tarefa Assess Results.
Em este momento, executou- se o framework de validação para verificar se as ações de exclusão não haviam gerado novos erros.
O resultado da nova validação é mostrado na Figura 79.
Observa- se, na figura acima, que a quantidade de erros diminuiu, não existindo mais referências para o produto de trabalho Test Log.
Especificamente os erros Rule&amp; 3 e&amp; 20 deixaram de existir no processo.
Para consertar os problemas relacionados com o produto de trabalho Work Items List, os quais são originários do processo OpenUP, uma análise foi realizada sobre a descrição desse produto de trabalho e sobre as tarefas do processo.
Verificou- se, assim, que o objetivo do Work Items List é listar todo o trabalho, geralmente expresso em termos de produtos de trabalho, que deve ser realizado num projeto de software, podendo isso ser produzido como parte do produto de trabalho Iteration Plan (informações extraídas da seção Representation Options do produto de trabalho Work Items List no OpenUP).
De essa maneira, com base na informação exposta acima, optou- se, nesta avaliação por produzir o produto de trabalho Work Items List na tarefa Plan Iteration.
Originalmente, tal produto de trabalho era apenas modificado por essa tarefa.
Após as alterações do processo do Cenário 4, a execução do framework de validação mostrou os seguintes resultados (Figura 80).
Nota- se que os erros Rule&amp; 3 e&amp; 28 não apareceram no resultado da validação.
Isso ocorreu, pois, agora, o produto de trabalho Work Items List é produzido por uma tarefa obrigatória, fato que atende ambas as regras de boa-formação em questão.
Seguindo a avaliação, os erros da regra Rule&amp; 20 foram consertados.
Como dito anteriormente, para fazer isto, é necessário criar caminho entre as tarefas que produzem e as tarefas que consomem os produtos de trabalho em questão.
Em este momento, apenas um sequenciamento do tipo startToStart entre as tarefas Plan Project e Plan Iteration foi incluído.
Isso foi realizado porque, analisando as informações de sequenciamento estabelecidas no Cenário 3 e também a descrição das tarefas do OpenUP, verificou- se que é necessário que a tarefa de planejamento de projeto tenha começado para que a tarefa de planejamento de iteração possa ser iniciada.
Além de a inclusão do sequenciamento mencionado, os parâmetros de entrada das tarefas do processo foram analisados.
Isto foi feito, pois se constatou que algumas tarefas estavam erradas pois consumiam produtos de trabalho produzidos por uma tarefa posterior.
Especificamente neste cenário, observou- se que os produtos de trabalho Iteration Plan e o Work Items List produzidos na tarefa Plan Iteration eram consumidos por a tarefa Plan Project (tarefa que é anterior a tarefa Plan Iteration).
Como esses parâmetros de entrada eram opcionais, neste momento, decidiu- se por excluir essas informações da tarefa Plan Project.
A Figura 81 mostra o resultado do framework de validação neste ponto da avaliação.
Observa- se, na Figura acima, que todos os erros relacionados com a regra Rule&amp; 20 não são exibidos.
O restante dos erros mostrados são provenientes dos novos elementos incluídos no Cenário 2 desta avaliação.
Como já detalhado na execução do Cenário 2, alguns erros foram incluídos propositalmente, como por exemplo, a inclusão de elementos opcionais que conflitam com elementos obrigatórios.
De esse modo, para consertar os últimos erros, o papel Analyst e o produto de trabalho Requirements Acceptance foram definidos como obrigatórios e o papel Analyst, que é responsável por o produto de trabalho Requirements Verification, foi incluído como desempenhador da tarefa Verify Requirements (atendendo as regras Rule&amp; 24).
Por fim, apenas para eliminar o warning que aparece no framework de validação, duas transições desnecessárias foram excluídas.
Uma das transições (conforme mostrado na Figura 73) diz respeito a uma transição incluída no Cenário 3 (entre as tarefas Plan Project e Update the Architecture).
A outra transição excluída foi a transição do tipo finishToStart entre o nodo inicial e a tarefa Plan Iteration.
Uma vez que o início da tarefa Plan Iteration foi condicionado neste cenário ao início da tarefa Plan Project, essa transição tornou- se desnecessária.
Em este ponto da avaliação do Cenário 4, considera- se que todas as inconsistências foram consertadas no processo.
De essa forma, o framework de validação foi novamente executado para confirmar que nenhum erro é encontrado no processo.
O resultado, que é visto na Figura 82, retorna 0 erros e 0 warning, demonstrando que o processo encontra- se 100% consistente com as regras de boa-formação propostas nesta tese.
Após consertar todos os erros provenientes do Cenário 3, os primeiros passos para criação de um processo de software através dos mecanimos de adaptação do metamodelo sSPEM 2.0 foram realizados.
Isto envolveu a definição de uma instância da metaclasse ProcessPackage (com valor de atributo isAuthoring $= false) como parte da instância de MethodPlugin, a criação de uma instância da metaclasse ActivityPackage e a criação de uma instância da metaclasse Activity.
Tais instâncias tornam- se necessárias, pois conforme explicado no guia para definição e adaptação de processos apresentado na em o Capítulo 5 deste estudo, todo novo processo deverá ser representado por uma nova instância de ProcessPackage.
Além disso, o estabelecimento de uma instância de ActivityPackage é obrigatória, uma vez que nenhum elemento pode ser criado fora de os pacotes.
Já o estabelecimento da instância de Activity é necessário para representar o processo de software sendo criado.
Em a primeira etapa da avaliação do Cenário 4, optou- se por avaliar o tipo de herança extension do mecanimo usedActivity e o mecanismo supressedBreakdownElement.
Para esse cenário, foi considerado que um novo processo necessitava ser montado para um determinado projeto de manutenção de software bastante simples.
Assim, a ideia foi herdar todo conteúdo do processo OpenUp Maintenance Process (criado no Cenário 3) através do mecanismo extension e após isto excluir alguns elementos desse processo através mecanismo supressedBreakdownElement.
Como uma instância da metaclasse Activity já foi criada no cenário em questão para representar o processo sendo adaptado, então, para herdar o conteúdo do processo OpenUp Maintenance Process, bastou relacionar a nova instância de Activity com a instância de Activity que representa o processo OpenUp Maintenance Process por o relacionamento usedActivity com valor igual a extension.
Em esse momento, todo conteúdo do processo OpenUp Maintenance Process foi herdado e o mecanismo supressedBreakdownElement foi liberado em sSPEM Tool para realizar as exclusões necessárias.
Vale destacar que como todo processo OpenUp Maintenance Process foi herdado, o processo sendo adaptado não possui inconsistências, uma vez que nesse momento da avaliação ele representa uma cópia exata do processo OpenUp Maintenance Process.
Para justificar as exclusões de elementos e relações através do mecanismo supressedBreakdownElement, foi considerado algumas características do projeto de manutenção para o qual está sendo criado um novo processo.
Inicialmente, o projeto de manutenção em questão foi considerado como uma manutenção evolutiva que não inclui e/ ou exclui funcionalidades, necessidades e atores do sistema.
A ideia é que apenas alguns casos de uso fossem modificados para contemplar algumas alterações de funcionalidades do sistema.
Com base nesses fatos, considerou- se que nenhuma alteração seria necessária nos produtos de trabalho Vision e Glossary.
Além disso, para esse tipo de projeto, ponderou- se que não seria precisa a revisão de requisitos (tarefa Verify Requirements e produto de trabalho Requirements Verification).
Partindo do contexto acima, as primeiras exclusões realizadas neste cenário foram os 2 produtos de trabalho citados acima (Vision e Glossary).
Contudo, apenas para demonstrar com mais detalhes a análise de impacto realizada durante a exclusão de um elemento apenas um produto de trabalho foi excluído por vez, iniciando- se as operações de exclusão por o produto de trabalho Vision.
Em este momento, como sSPEM Tool implementa uma funcionalidade de análise de impacto, os elementos afetados por a operação de exclusão foram mostrados, conforme pode ser visto na Figura 83.
A Figura 83 mostra somente parte dos elementos afetados por a exclusão do produto de trabalho Vision.
Contudo, através desta figura é possível observar que, em sSPEM Tool, os elementos afetados por uma operação de exclusão são destacados com ícones que indicam novas exclusões ou ícones de alerta.
Isso ocorre porque, devido a a exclusão de um elemento, outros elementos são afetados.
Especificamente no caso de o produto de trabalho Vision, observa- se que alguns elementos necessitam ser apagados (os que possuem o ícone) e alguns necessitam ser apenas alterados (os que possuem).
Especificamente, além de o produto de trabalho Vision alguns relacionamentos são apagados e alguns elementos sofrem alterações como, por exemplo, a tarefa Update Vision que não possuiria mais este produto de trabalho como parâmetro de entrada.
Vale destacar que a tarefa Update Vision não foi excluída pois o produto de trabalho Vision foi definido como um parâmetro opcional para esta tarefa.
O Cenário 5 foi criado apenas para demonstrar inconsistências relacionadas com algumas regras de boa-formação que não foram citadas até este momento.
O processo utilizado neste ponto da avaliação foi o processo final do Cenário 4, ou seja, o processo após todas operações de exclusão realizadas e que não possui erros.
Basicamente, nesse cenário, somente informações inconsistentes foram incluídas no processo (sem a utilização do Method Content) com objetivo de ocasionar alguns erros.
Após tais inclusões, o framework de validação foi sempre acionado para demonstrar que os erros incluídos de forma proposital são encontrados.
Inicialmente, para avaliar as regras Rule&amp; 6,&amp; 14,&amp; 15,&amp; 41,&amp; 42,&amp; 44 e&amp; 45 que são relacionadas com os nodos inicial e final do processo, os elementos listados na Tabela 22 foram incluídos.
Tabela 22 -- Relação de elementos relacionados com nodos inicial e final incluídos no Cenário 5 Além de as inclusões acima, uma alteração foi realizada na WorkSequence 20 que liga a Task Use Assess Results com a Task Use End.
A alteração feita foi a mudança do valor do atributo linkKind de finishToStart para startToStart.
Em este momento da avaliação o framework de validação foi executado.
O resultado desta validação é apresentado na Figura 92.
Os erros exibidos na Figura 93 mostram que todos os elementos incluídos apresentam algum problema.
Esse é o caso, por exemplo, da Activity TEST que exibe o erro da regra Rule&amp; 22, pois possui parâmetros incompatíveis com os parâmetros das suas tarefas.
Isso ocorre porque foi definido um Process Parameter dentro de a Activity TEST do tipo out para o novo produto de trabalho TEST External e o mesmo Process Parameter não existe em nenhuma de suas tarefas internas.
Essa situação indica que o produto de trabalho TEST External é produzido em alguma das tarefas da Activity TEST.
Contudo, isso não é verdade, pois nenhuma tarefa desta atividade produz o novo produto de trabalho.
Outro problema, ainda relacionado com essa situação, é que um Process Parameter do tipo out foi associado para um produto de trabalho do tipo externo, sendo que tal fato viola a regra de boa-formação Rule&amp; 1.
Considerando que as últimas regras de boa-formação foram testadas a execução do Cenário 5 foi encerrada.
A Tabela 24 relaciona a análise das premissas e regras de boa-formação analisadas neste Cenário.
Tabela 24 -- Premissas e regras analisadas no Cenário 5 Este capítulo apresentou cinco cenários para definição e adaptação de processos de software que demosntraram a aplicação do metamodelo sSPEM 2.0 e do conjunto de regras de boa-formação para consistência.
Toda avaliação foi desenvolvida, utilizando- se do processo de software OpenUp e conduzida no protótipo de ferramenta sSPEM Tool.
Como pôde ser visto ao longo de o capítulo, foram utilizadas na avaliação todas as informações (metaclasses e relacionamentos) incluídas no metamodelo original SPEM 2.
0 por a extensão proposta nesta pesquisa (metamodelo sSPEM 2.0).
Esse é o caso, por exemplo, dos relacionamentos de dependência entre os produtos de trabalho, que embora não estivessem modelados no processo OpenUP, puderam ser facilmente constatados na descrição textual deste processo.
Outro tipo de informação que se aplicou muito bem nesta avaliação foi o uso dos produtos de trabalho do tipo External que foram utilizados no Cenário 3 para a confecção de um processo específico para um projeto de manutenção.
De acordo com OMG, para esses tipos de projeto, constata- se a necessidade de diferenciar os produtos de trabalho que são produzidos ou somente modificados, uma vez que muitos desses produtos de trabalho já se encontram documentados nestes projetos de software.
Durante a condução da avaliação, 48 regras de boa-formação (conforme Capítulo 4) para consistência relacionadas com a atividade de definição de processos foram avaliadas e demonstradas através da inclusão de erros no processo OpenUP.
As únicas regras de boa-formação que não foram avaliadas através da inclusão de erros, foram as 2 regras específicas dos mecanismos usedActivity e Variability (Regra&amp; 46 e Regra&amp; 47).
Isso ocorreu porque em sSPEM Tool estas regras foram implementadas através de filtros aplicados sobre os atributos usedActivity e variabilityBasedOnElement, os quais não permitem que elementos do processo ou do repositório de conteúdo definam um autorelacionamento para utilização dos mecanimos usedActivity e Variability.
Essa implementação faz com que nenhum elemento em sSPEM Tool possa herdar (no caso de o mecanismo usedActivity) ou variar (no caso de o mecanismo Variability) seu próprio conteúdo, o que respeita a definição das regras Regra&amp; 46 e Regra&amp; 47.
Também foram demonstrados na avaliação alguns exemplos dos mecanismos de adaptação usedActivity e supressedBreakdownElement.
Durante a condução desses exemplos, foi possível demonstrar o funcionamento da análise de impacto proposta para a exclusão de elementos num processo de software.
Por fim, vale destacar que durante a criação dos cenários para esta avaliação foi utilizado o repositório de conteúdo (Method Content) em sSPEM Tool.
Embora não tenha sido explorado na descrição do texto os resultados de cada apontamento realizado para o repositório, deixou- se claro que para criação dos Cenários 1, 2 e 3 todas as informações foram provenientes de reuso de elementos e relacionamentos.
Apesar de a importância da definição e adaptação de processos de software consistentes, constatou- se, a partir de a literatura analisada, que o aspecto da consistência de processos é abordado de forma parcial nos estudos.
Muitos autores propõem soluções para o tratamento da consistência apenas nas atividades de definição dos processos de software, ou, abordam este aspecto, somente durante as atividades de adaptação desses processos.
Ainda, considerando as pesquisas que apresentam regras para definição de processos de software consistentes, pôde- se verificar que, em todos os estudos analisados, apenas alguns aspectos de consistência e/ ou elementos de um processo de software são tratados, como por exemplo, o estudo apresentado em, que aborda apenas o aspecto de consistência relacionado com a definição de um sequenciamento de tarefas.
Em esta tese, como forma de viabilizar a definição e adaptação de processos de software consistentes, uma infraestrutura para consistência foi definida utilizando o metamodelo SPEM 2.
0, o qual, é tido nos dias de hoje por a OMG, como principal referência para modelagem de processos de software.
Para construção da infraestrutura, inicialmente, foi definido um conjunto de premissas a serem observadas durante as atividades de definição e adaptação dos processos de software.
Tais premissas foram identificadas com base na literatura analisada, nos processos de software RUP, OPEN e OpenUP e também a partir de o metamodelo SPEM 2.
0. Para atendimento dessas premissas, foi definida uma extensão ao metamodelo SPEM 2.
0 com a inclusão e alteração de um conjunto de elementos e relacionamentos, bem como foi desenvolvido um conjunto de regras de boaformação para consistência que estabelecem as condições que devem ser verdadeiras para todos os processos de software (premissas) em qualquer ponto do seu ciclo de vida.
As regras de boa-formação devem ser utilizadas durante a definição de um processo de software e, necessitam ser respeitadas quando um processo de software é adaptado.
Em esse sentido, para auxiliar as atividades de adaptação de processos, foi também desenvolvido, nesta pesquisa, a análise de impacto sobre os elementos e relacionamentos que são afetados durante a condução de alguns mecanismos de adaptação do metamodelo sSPEM 2.0.
A principal contribuição da análise de impacto é garantir que as dependências de um processo de software serão respeitadas durante uma operação de adaptação, evitando assim, que inconsistências sejam geradas no processo resultante.
Um fato importante sobre as regras de boa-formação, é que, elas podem ser utilizadas de maneira independente.
Pesquisados e/ ou implementadores de ferramentas podem utilizar as regras de boa-formação de acordo com os pacotes do metamodelo sSPEM 2.0.
Por exemplo, no caso de um pesquisador ter interesse nas regras definidas para o pacote Process Structure, seria possível a utilização de somente um subconjunto das regras de boa-formação para consistência.
Isso seria possível, uma vez que como pôde ser observado no Capítulo 4, todas as regras de boa-formação são incluídas de maneira incremental utilizando- se do mecanismo de merge da UML.
Salienta- se apenas que as regras de boa-formação que envolvem os elementos e relacionamentos incluídos no metamodelo original SPEM 2.
0 por esta pesquisa, necessitariam de maior atenção, já que várias metaclasses e relações do metamodelo sSPEM 2.0 seriam necessárias.
Além de o metamodelo sSPEM 2.0 e das regras de boa-formação, é parte também da infraestrutura para consistência, o protótipo de ferramenta sSPEM Tool, que foi desenvolvido para viabiliar a utilização do metamodelo sSPEM 2.0 e das regras de boaformação de forma automática.
As principais funcionalidades implementadas no sSPEM Tool são as funcionalidades para definição e adaptação de processos de software, bem como a funcionalidade para validação desses processos, que consistiu- se na inclusão de todas as regras de boa-formação no framework de validação existente no plugin EMF.
Por fim, foi definido um guia para auxiliar a definição e adaptação de processos a partir de o metamodelo sSPEM 2.0 e das regras de boa-formação.
A contribuição desse guia é facilitar o uso da infraestrutura para consistência, uma vez que devido a grande quantidade de elementos e relacionamentos do metamodelo sSPEM 2.0, bem como a elevada quantidade de regras de boa-formação, seu uso se torna uma tarefa não trivial.
Embora todos os produtos acima possam ser destacadas como contribuições para a solução apresentada nesta tese, apresentam- se a seguir algumas sugestões para continuidade do trabalho.
Durante a elaboração desta tese, algumas ideias adicionais foram identificadas e são aqui indicadas como sugestão para trabalhos futuros:
Ampliar o conjunto de regras de boa-formação para consistência das atividades de definição e adaptação de processos para contemplar todos os elementos e relações do metamodelo SPEM 2.
0. Isto envolveria a criação de regras para as metaclasses Guidance, Section, Composite Role, Team Profile e Qualification.
Avaliar se solução proposta é aplicável em processos de software que não são compatíveis ao metamodelo SPEM 2.
0. Isso seria necessário, pois, embora esse metamodelo seja atualmente considerado como principal referência para definição e adaptação de processos, não é possível afirmar que a infraestrutura para consistência, incluindo todas as regras de boa-formação, sejam aplicáveis a qualquer processo de software.
