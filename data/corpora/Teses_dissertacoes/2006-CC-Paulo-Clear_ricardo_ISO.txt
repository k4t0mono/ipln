Os estudos na área de Avaliação de Desempenho de Sistemas tem evoluído nos últimos anos, em especial com a definição do formalismo de Redes de Automatos Estocásticos (SAN) e com a implementação do algoritmo Shuffle, o qual implementa um metodo eficiente para a execução da multiplicação vetor-descritor, necessaria para a resolução de modelos SAN.
Mais recentemente, foi proposto um novo método para a multiplicação vetor-descritor, o método Slice, que introduzindo novos conceitos, prometia na teoria ser mais eficierlte que o tradicional método Shufle.
Pois neste estudo, este recem definido e ate então pouco explorado método, foi estudado em detalhes e realizada uma implementação incluindo algumas otimizações no seu algoritmo original.
Ainda, durante este estudo, foram realizadas algumas modificações no algoritmo do metodo Slice com o intuito de resolver modelos SAN funcionais, uma vez que as versões anteriores não eram capaz de tratar funções.
Para demonstrar a eficiência do método Slice e das otimizações propostas, diversos experimentos foram conduzidos utilizando dois modelos SAN.
Os resultados de tempo e custo computacional foram analisados e discutidos durante este estudo, comparando- os inclusive com resultados do tradicional metodo Shufle.
Desta forma, verificou- se o quanto o metodo Slice pode ser útil na resolução de sistemas, uma vez que os resultados praticos mostram que o metodo Slice é mais eficiente que a solução tradicional (Shuffle) na maioria dos casos.
A avaliação de desempenho de sistemas tem se tornado cada vez mais difícil, pois os sistemas em geral envolvem a cada dia que passa mais detalhes, tornando- se cada vez mais complexos.
O alto nível de detalhes dos sistemas encontrados no mundo real geram diversos problemas para a avaliação de desempenho.
Estes problemas vão desde a dificuldade na modelagem do sistema num certo formalismo, até problemas relacionados ao custo computacional necessario para o calculo da solução do sistema.
Um dos principais problemas encontrados na avaliação de desempenho de sistemas e a explosão do número de estados do sistema.
Muitos estudos vem sendo realizados nesta área com o intuito de encontrar técnicas para solucionar, ou ao menos minimizar este problema.
Algumas abordagens, como o formalismo de Redes de Automatos Estocásticos (SAN), apresentam uma modelagem que Visa reduzir o impacto da explosão do espaço de estados.
Porém, ainda assim, este problema persiste e tem se tornado uma grande barreira para a evolução da área de Avaliação de Desempenho de Sistemas.
Atualmente, existem diversas técnicas para avaliação de desempenho de sistemas, porém nenhuma de elas apresenta resultados satisfatórios para todo e qualquer sistema.
O que ocorre, e que algumas técnicas são melhores para alguns sistemas específicos, enquanto outras se mostram mais adequadas para os demais tipos de sistemas.
Portanto, estudos nesta área ainda são realizados com grandes expectativas de bons resultados, não pensando em encontrar uma única técnica para cobrir todos os sistemas possíveis, mas principalmente para bus ar melhores resultados em termos de desempenho.
Com o surgimento do formalismo de Redes de Automatos Estocásticos (SAN -- Stochastic Automata Networks), muitos estudos voltaram- se para o cálculo da resolução de sistemas modelados por este formalismo, uma vez que em termos de armazenamento, SAN apresenta uma forma bastante compacta e eficiente.
Sendo assim, o que se espera dos estudos nesta área e uma forma eficiente de resolver sistemas descritos por este formalismo, de maneira a exigir o menor custo computacional possível.
Com este objetivo, duas técnicas podem ser citadas, a técnica Shuffle, tradicional e ja bastante explorada e divulgada mundialmente, e a técnica Slice, mais recente e ainda pouco divulgada, uma vez que seus estudos até então eram apenas teóricos A forma mais adequada de resolver modelos SAN e utilizando- se metodos iterativos, os quais possuem como operação fundamental a multiplicação de um vetor de probabilidades 7T por o gerador infinitesimal Q (denominada Multiplicação Vetor--Descritor).
O objetivo principal deste trabalho e estudar em detalhes a técnica Slice de nlultiplicação vetor-descritor e provar na pratica o seu bom desempenho na resolução de sistemas.
Além disso, a medida que cada parte do algoritmo desta técnica seja completamente entendida, são descobertas e propostas algumas otimizações, demonstrando tanto na teoria como na pratica o ganho de desempenho que cada otimização resultaria.
Como um objetivo secundário, mas também bastante importante para a evolução dos estudos nesta área, pretende-se extender a técnica Slice com o intuito de resolver não apenas modelos com taxas exclusivamente constantes, mas também sistemas que apresentem nlodelagens contendo taxas funcionais.
De fato, isto seria fundamental para que a técnica Slice seja reconhecida globalmente como uma boa alternativa para resolução de modelos SAN, uma vez que a maioria dos sistemas requerem taxas funcionais em suas modelagens.
Enfim, ao final deste estudo, sera possível conhecer melhor a técnica Slice e saber o quanto esta técnica realmente contribuirá para a evolução da resolução de sistemas, não apenas na teoria, mas também na pratica atraves de exemplos de modelos SAN.
Este trabalho é formado por cinco capítulos incluindo esta introdução e as considerações finais.
O estudo é dividido basicamente em três partes principais, os conceitos basicos, a técnica Slice na teoria e a analise do desempenho desta técnica.
Em o Capítulo 2 são apresentados todos os conceitos basicos necessarios para o completo entendimento do estudo que segue.
Micialmente e descrito o formalismo de Redes de Autômatos Estocásticos, seguido por a explicação de como e realizada a resolução de modelos SAN e tambem definição do descritor Markoviano das SAN.
A o final, o capítulo 2 ainda apresenta a tradicional técnica de multiplicação vetor-descritor, conhecida como Shufle, a qual e atualmente o parametro de comparação para qualquer nova técnica desta área.
Em as paginas deste capítulo e possível entender como esta técnica realiza a multiplicação vetordescritor, passando por cada etapa deste processo, conhecendo assim o conceito de Fator Normal Unitário Aditivo, que e a principal inovação da técnica Slice.
Em o capítulo seguinte, o Capítulo 4, e apresentada uma analise numérica do desempenho da e dividida em duas partes, uma parte teórica, em que e estimado o custo computacional para ambas as técnicas atraves das fórmulas de custo computacional, e uma parte pratica, a qual apresenta resultados práticos da implementação da técnica Slice, incluindo memória e tempo necessarios para a execução de alguns exemplos de modelos SAN.
Finalmente, nas considerações finais são apresentadas as conclusões em relação a o desempenho da técnica Slice para resolução de modelos SAN, demonstrando assim a sua real contribuição para a área de avaliação de desempenho de sistemas, bem como os possíveis trabalhos futuros relacionados a este estudo.
Conceitos Básicos Em este Capítulo são apresentados alguns Conceitos basicos importantes para o entendimento do trabalho desenvolvido.
Primeiramente, o formalismo Redes de Automatos Estocásticos é descrito de forma a esclarecer os seus principais conceitos, o seu propósito e como é realizada a solução de sistemas neste formalismo.
Em seguida, e apresentado o metodo Shuffle, uma técnica tradicional utilizada para resolução de sistemas modelados atraves do formalismo SAN.
Estes conceitos são importantes para facilitar a compreensão da técnica Slice, a qual é o foco deste trabalho.
Redes de Automatos Estocásticos (SAN) é um formalismo, baseado em Cadeias de NIarkov, para modelagem de sistemas.
Seu surgimento ocorreu nos anos 80 com Plateau.
A idéia central deste formalismo é modelar um sistema através de diversos subsistemas, chamados de autômatos, que podem ou não interagir entre si.
Através do uso de SAN a modelagem se apresenta mais compacta e modular, tornando- se muito interessante em sistemas com grandes espaços de estados.
A grande diferença e principal vantagem de Redes de Automatos Estocásticos (SAN) em relação a Cadeias de Markov é exatamente a modularização, pois esta permite uma forma mais eficiente de armazenamento dos dados do sistema, evitando em muitos casos a explosão do espaço de estados, algo muito comum em Cadeias de Markov.
Desta forma, e possível encontrar soluções para sistemas maiores, com grande quantidade de dados.
E interessante ressaltar que toda SAN pode ser representada por um único autômato estocástico, o qual contém todos os estados possíveis do sistema.
Esse único autômato corresponde a Cadeia de Markov equivalente ao modelo SAN.
Logo, este formalismo é capaz de manter o poder de modelagem que se tinha com a utilização de Cadeias de Markov.
A seguir, são apresentados cada um dos conceitos relacionados às SAN e ainda uma breve introdução dos métodos numéricos mais utilizados nas soluções estacionarias e transiente das SAN.
Imagine um sistema com um conjunto finito de estados e finitas transições entre eles, onde o sistema passa de um estado para outro por meio de eventos.
Esta é uma definição simplificada de um autômato estocastico.
O sistema pode encontrar- se em qualquer um de seus estados, os quais sintetizam as informações relativas as entradas anteriores e informam ainda os possíveis comportamentos do sistema diante de as entradas seguintes, A denominação de estocásticos atribuída a esses autômatos da- se por a razão do tempo ser tratado como uma variavel aleatória, a qual obedece uma distribuição exponencial na escala de tempo contínua, ou geométrica no caso de escala de tempo discreta.
Em este estudo utiliza- se a escala de tempo contínua.
Existem duas formas de observar estados num modelo SAN.
Uma forma e observar o estado individual de cada autômato pertencente ao modelo, chamado este de estado local.
Outra, e considerar a combinação dos estados de todos os autômatos envolvidos no modelo, o qual denomina- se de estado global do sistema.
Portanto, a mudança do estado de qualquer autômato do modelo, ilecessariamente acarretará na mudança do estado global do sistema.
As mudanças de estados locais 11 os autômatos ocorrem atraves de transições, que por sua vez são disparadas por a ocorrência de eventos ao longo de o tempo.
Cada transição deve ter ao menos um evento associado a ela, podendo este ser um evento local ou sincronizante.
Pode- se definir um evento como uma ação relevante que modifica o estado global do sistema.
Os eventos estão diretamente associados às transições do modelo, isto é, sempre que um evento ocorre, uma ou mais transições são realizadas.
Em SAN, os eventos podem ser de dois tipos, locais ou sincronizantes.
Eventos locais são aqueles que modificam o estado local de um único autômato sem interferir no estado local dos demais autômatos do modelo.
Estes eventos são normalmente utilizados quando se quer modelar comportamentos independentes entre autômatos.
Por outro lado, e possível modelar sincronismo entre dois ou mais autômatos atraves de eventos sincronizantes.
Estes eventos disparam transições ein mais de um autômato, inodificando assim os estados locais dos autômatos envolvidos.
Todo modelo SAN para estar completo deve apresentar uma tabela de eventos.
Esta tabela contem os identificadores dos eventos, as taxas de ocorrências e ainda o tipo de cada evento pertencente ao modelo.
Deve- se consultar essa tabela para distinguir os eventos locais dos sincronizantes, uma vez que a representação gráfica não apresenta tal informação.
A Figura 2.1 apresenta um modelo SAN formado por dois autômatos com tres eventos locais e um evento sincronizante, como pode ser observado na Tabela 2.1.
Em este exemplo, o autômato Am possui três estados 0m, 1m e 2m, enquanto que o autômato Am do modelo possui apenas dois estados 0m e 1m.
O modelo apresenta ainda quatro eventos, sendo três eventos locais (el, 62 e 64) e um sincronizante.
Quando o evento sincronizante ocorre, o autômato Am passa do estado local 20) para 0m ao mesmo passo que o autômato Am sai do estado OQ) e vai para o estado 1m.
Todo evento num modelo SAN deve ter associado a si uma taxa de ocorrência e uma probabilidade de rotação.
Tanto a taxa de ocorrência como a probabilidade de rotação podem ser definidas como valores constantes ou valores funcionais.
Quando as taxas e/ ou probabilidades são definidas como valores funcionais, estas são então ditas taxas e/ ou probabilidades funcionais.
Em este caso, os valores assumidos por estas taxas e probabilidades dependem dos estados locais dos demais autômatos do modelo.
A utilização de taxas e probabilidades funcionais proporciona uma segunda possibilidade de interação entre autômatos 11 os modelos SAN, a outra possibilidade e a utilização de eventos sincronizantesl como visto anteriormente.
As funções associadas com as taxas e/ ou probabilida Ia utilização de taxas e probabilidades funcionais não esta limitada aos eventos locais e podem ser empregadas nos eventos sincronizantes exatamente como nos eventos locais.
A Figura 2.2 apresenta um exemplo de modelo SAN corn 2 autôrnatos, o primeiro corn 3 estados e o segundo com 2 estados.
Em este exemplo, pode- se observar no autômato.
Am a utilização de probabilidades para as diferentes transições do evento sincronizante a4.
Além disso, analisando a Tabela 2.2, nota- se que o evento a5 do autôrnato.
Am possui urna função f1 associada a sua taxa de ocorrência.
De essa forma, a taxa de ocorrência deste evento sera determinada por a função fl..
A função f] por sua vez é definida por:
Está no estado 0m;
Está no estado 2m;
A1 se autôrnato A para o estado 1 a) ocorre com urna taxa de ocorrência A1, caso o autôrnato.
Am esteja no estado Oil), ocorre corn uma taxa Àg, caso o autôrnato Am esteja no estado 2m, e não ocorre caso o autômato Am esteja no estado 1m.
Função de atingibilidade nada mais e do que uma função booleana que determina os estados atingíveis ein uni modelo SAN.
Esta função deve ser utilizada sempre que for identificado que uni ou mais estados do sistema nunca serão alcançados.
Por outro lado, a função de atingibilidade deve assumir o valor 1 caso todos os estados do modelo SAN sejam atingíveis.
Considerando a Figura 2.1 podemos supor, por exemplo, que o autômato AU) não pode se encontrar no estado 2m se o autômato AQ) estiver no estado 1m, e vice-versa.
Para isto deve- se definir a seguinte função de atingibilidade2:
De essa forma, os possíveis estados globais desta SAN seriam:
As funções de integração podem ser definidas em qualquer modelo SAN.
A proposta destas funções e obter a probabilidade do modelo encontrar- se num determinado estado.
As funções de integração podem ser definidas de forma a avaliarem a probabilidade do modelo estar num conjunto de estados, podendo obter assim índices de desempenho e confiabilidade do modelo.
A avaliação dessas funções é realizada sobre o vetor de probabilidades que contém a probabilidade do modelo se encontrar em Cada um de seus possíveis estados.
Por exemplo, considerando a SAN apresentada na Figura 2.2, a função de integração f, definida abaixo, avaliaria a probabilidade do autômato Am estar no estado?
Existem alguns métodos iterativos que podem ser aplicados à resolução das SAN, entre estes, destaca- se:
O metodo de Arnoldi, GMRES e o metodo da Potência implementados na ferramenta PEPS Em estes métodos, a operação básica e a multiplicação de um vetor de probabilidades por uma matriz, ou seja, a cada iteração é gerada uma seqüência 77W de valores aproximados do vetor de probabilidades estacionarias que devem convergir para a solução 71'.
Logo o número de iterações torna- se um fator relevante na verificação do custo total de aplicação destes metodos.
O Metodo da Potência em especial sera o foco do estudo comparativo deste trabalho, uma vez que serão estudados algoritmos de resolução de SAN que se utilizam deste método.
Todos os Conceitos vistos nesta seção podem ser encontrados com maiores detalhes em.
ZA função de atingibilidade utiliza a mesma notação da linguagem de programação C. SDa mesma forma que as funções de atingibilidade, as funções de integração fazem uso da sintaxe da linguagem de programação C. O Método da Potência 'Tradicional O princípio basico deste metodo e, através da multiplicação de um vetor de probabilidades&amp; por uma matriz de probabilidades P, obter o vetor solução ou auto-vetor 7 T, isto se considerarmos que a matriz P estará elevada no oo, ou seja, 71' $= 7140) P00.
Normalmente, as soluções dos metodos iterativos, como e o caso do metodo da Potência, são obtidas atraves de aproximações constantes, onde uma solução é considerada satisfatória somente se obedece a algum critério de tolerância estabelecido.
Este criterio pode ser observado atraves da diferença entre as iterações anteriores e a atual iteraçao.
Desta forma, a solução esperada e WW, e para sabermos seu valor é necessario conhecer o valor de W014), e assim sucessivamente, como a seguir:
Portanto, para o calculo do vetor de probabilidades estacionarias 77 W, considera- se o esquema iterativo descrito genericamente por nl) 2 7 T(&quot;' 1) P. Em o ambito da multiplicação vetordescritor rlecessária para solução de modelos SAN, considera- se P uma dada matriz de transição Q, que deve estar normalizada (aqui representada como â), somada a urna matriz identidade Além de isto,&amp; pode ser um vetor de probabilidades inicialmente equiprovável, ou um vetor inicializado com probabilidades pre-definidas segundo algum criterio.
A solução que buscamos neste caso e um vetor de probabilidades normalizado, onde a soma de seus elementos e igual a Logo, o sistema linear a resolver é:
Considerando que um descritor SAN e urn gerador infinitesirnal dado por(§+ I), a solução estacionaria de urna SAN e simplesmente a resolução deste sistema linear.
Em este caso, com matrizes de transição, realiza- se o seguinte esquema de iterações:
Em este esquema de iterações demonstrado na Equação 2.1, tem- se o termo (â+ I) que representa urna matriz de probabilidade (denominada matriz P anteriormente).
Logo, o esquema iterativo pode ser representado por:
Note que o esquema iterativo pode também ser descrito como:
Para entender o Descritor Markoviano das SAN, primeiramente e necessario compreender o conceito de matriz de transição de um autômato estocastico.
A matriz de transição de um autômato estocastico nada mais e que uma representação matricial das possíveis trocas de estados do autômato, levando- se em conta também as taxas das transições.
Para entender como pode- se obter a matriz de transição correspondente a um determinado autômato estoeastico, consideremos a cadeia de Markov descrita na Figura 2.3.
A matriz de transição Q desta cadeia de Markov e uma matriz quadrada de ordem nQ igual ao número de estados pertencentes a esta cadeia, neste caso, nQ $= 4 (estados A, B, C e D respectivamente).
Cada linha e cada coluna da matriz de transição Q é associada a um estado da cadeia de Markov segundo a ordem lexicográfica dos mesmos.
Logo, considerando o exemplo dado, a primeira linha e a primeira coluna de Q correspondem ao estado A, a segunda linha e a segunda coluna correspondem ao estado B, assim como a terceira linha e a terceira coluna correspondem ao estado C, e a quarta linha e quarta coluna ao estado D. Sendo assim, a matriz de transição Q correspondente a cadeia de Markov representada por a Figura 2.3 e:
Os elementos qi¡ de uma matriz Q correspondem as taxas de disparo das transições do autôrnato estocastico que se esta sendo representando, considerando o estado associado à linha i couro o estado de partida da transição e o estado associado à colunaj o estado de chegada desta mesma transição.
De essa forma, obtém- se os elementos irao- diagonais da matriz Q, os elementos da diagonal principal desta matriz são definidos de forma a ser nula a soma dos elementos em cada uma das linhas da matriz.
Assim, a diagonal expressara o ajuste necessario para que a soma de todos os elementos de cada linha seja igual a zero.
Portanto, os elementos da diagonal principal serão necessariamente negativos ou nulos.
O formalismo SAN fornece uma descrição compacta da matriz de transição (gerador infinitesimal) correspondente a Cadeia de Markov associada a0 modelo completo, a qual e chamada de Descritor Mar/ comuna.
Essa e mais uma vantagem do formalismo SAN em relação a os demais formalismos.
O descritor Markoviano, considerando as matrizes de transição de cada autômato do modelo, descreve de forma algébrica o gerador infinitesimal da cadeia de Markov associada a SAN.
Cada autômato estocastico AV) de uma modelo SAN possui uma matriz de transição local Qlm, que agrupa todas as taxas correspondentes transições locais, e 2E matrizes de transição sincronizantes, as quais agruparn todas as taxas de transições dos eventos sincronizantes e do conjunto s, chamadas Qi?
E Qí, onde E e o total de eventos sincronizantes do modelo SAN e s é o conjunto de identificadores destes eventos.
Estas matrizes de transição, locais e sincronizantes, são utilizadas para expressar o descritor Nlarkoviano de uma rede de autômatos estocasticos, como apresentado nas seções subseqüentes.
O descritor Markoviano de uma rede de autômatos estocasticos é descrito através de operações tensoriais entre as matrizes de transição do modelo.
Este descritor e expresso em duas partes:
A parte local, que corresponde as transições locais de cada automato do modelo, e a parte sincronizante, que corresponde as transições disparadas por os eventos sincronizantes pertencentes ao modelo SAN.
Parte Local do Descritor Markoviano A parte local do descritor Markoviano e definida por uma soma tensorial das matrizes locais de cada autômato do modelo, como segue:
Considerando o exemplo de modelo SAN apresentado por a Figura 2.1, vejamos como seriam descritos os seus eventos locais.
Para cada autômato Ai «do modelo, existe uma matriz de transição local QP associada.
Logo, para o exemplo da Figura 2.1 tem- se duas matrizes locais.
A matriz de transição local Q¡ do automato equivalente a esta rede de automatos estocasticos corresponde a soma tensorial das matrizes de transições locais, como e mostrado a seguir:
Portanto, uma matriz de transição local agrupa todas as taxas dos eventos locais do autômato.
Se o modelo SAN da Figura 2.1 apresentasse somente eventos locais, o gerador infinitesimal Q do autômato equivalente a este modelo seria simplesmente a soma tensorial4 das matrizes de transição locais do modelo.
Parte Sincronizante do Descritor Markoviano A parte sincronizante do descritor Markoviano é composta por as matrizes de transição dos eventos sincronizantes do modelo SAN.
Para cada evento sincronizante e para cada autômato do modelo são descritas duas matrizes:
Uma descrevendo as ocorrências do evento sincronizante (matriz positiva), e a outra (matriz negativa) descrevendo o ajuste diagonal correspondente a cada taxa descrita na matriz de ocorrência.
Para cada evento sincronizante do modelo SAN e definido um autômato mestre e um ou mais autômatos escravos, de entre os autômatos que sofrem influência destes eventos.
Podem ainda existir autômatos que não são influenciados por determinados eventos sincronizantes.
Em este caso, as matrizes positivas e negativas destes eventos para estes autômatos serão matrizes identidade, uma vez que não ocorrerá nenhuma mudança de estado nestes autômatos em decorrência de tal evento.
A matriz positiva correspondente ao autômato mestre contem a taxa de disparo de um dado evento sincronizante e, enquanto que as matrizes positivas dos autômatos escravos contêm uma taxa de disparo igual a um, ou igual a probabilidade da transição relacionada ao evento ocorrer.
Vejamos a parte sincronizante positiva do modelo SAN da Figura 2.1 considerando o autômato All) mestre para o evento sincronizante a3:
As matrizes de ajuste diagonal, ou matrizes negativas, possuem apenas elementos na diagonal principal, os quais correspondem aos ajustes correspondentes as taxas apresentadas nas matrizes positivas.
Em a matriz do autôrnato mestre, a taxa e igual a da matriz positiva, porém negativa, ao passo que nas matrizes dos autômatos escravos, as taxas são sempre iguais a um.
Sendo assim, para o exemplo da Figura 2.1 teríamos as seguintes matrizes negativas, considerando o autôniato Am como mestre:
Portanto, para cada evento sincronizante do modelo SAN são descritos dois produtos tensoriais, um produto das matrizes positivas e outro das matrizes negativas, sendo definido genericamente por a seguinte equação:
Como dito anteriormente, o descritor Markoviano e composto de duas partes, a parte Correspondente as matrizes de transição locais e a parte contendo as matrizes sincronizantes (positivas e negativas).
Sendo assim, o descritor Markoviano completo para o exemplo da Figura 2.1 pode ser descrito da seguinte forma:
Portanto, considerando que o descritor Markoviano completo é a soma da parte local com a parte sincronizante de cada autômato do modelo SAN, pode- se descreves- lo genericamente atraves da seguinte equação:
Considerando ainda que uma soma tensorial entre matrizes é decomposta na soma convencional de produtos tensoriais destas matrizes 5, o descritor Markoviano pode ser descrito de outra forma como mostra a Tabela 2.3, a qual apresenta todas as matrizes de transição necessárias para descrever uma rede de autômatos estocastittos.
Tambem conhecida como Técnica de Embaralhamento, a técnica Shufle6 implementa uma técnica tradicional utilizada ern uma das operações fundamentais realizadas por os métodos iterativos, a multiplicação de um vetor de probabilidades v, por o gerador infinitesimal Q. Esta multiplicação é dada por a seguinte expressão, sendo N o número de autômatos na rede, e E o número de eventos sincronizantes:
Em especial, são tratadas as particularidades envolvidas na seguinte operação de multiplicação:
A seguir, serão estabelecidas algumas defiilições sobre seqüências finitas de matrizes, importantes para a apresentação do algoritmo utilizado no método Shume.
Sejam m;
Dimensão da zlésima matriz de uma seqüência;
Veremos na próxima seção que atraves da propriedade de decomposição de produtos tensoriais a multiplicação de um vetor U por o termo Qi «pode ser reescrita de uma forma mais modular utilizando- se fatores normais.
Fator normal e um caso especial de produto tensorial entre uma matriz Q e uma matriz identidade I, sendo dois fatores normais possíveis:
Assim, a implementação desta operação torna- se mais flexível.
Com o intuito de decompor o termo QM e assim facilitar a operação de multiplicação do vetor por o termo, faz- se uso da propriedade de decomposição de produtos tensoriais mostrada abaixo.
De essa forma, o termo@ i1 Qi «pode ser reescrito da seguinte maneira:
Essa nova forma de calcular o produto tensorial entre as matrizes da SAN simplifica bastante a multiplicação do vetor U por o descritor infiriitesinral Q. Pois agora, é possível multiplicar o vetor por cada fator norrnal individualmente, podendo- se criar fases bern distintas.
Assim, o calculo como um todo se tornã mais modular e o custo com memória diminui consideravelmente, uma vez que não é mais necessário gerar todo o descritor Markoviano antes de efetuar a multiplicação com o vetor.
Vale salientar que tudo isso é possível graças à propriedade de associatividade da multipliCação (convencional) de matrizes.
Alem disto, a propriedade da Comutatividade entre fatores normais permite à multiplicação de fatores normãis em qualquer ordem, se necessario.
Sendo assim, para calcular o produto vetor-descritor, basta multiplicar o vetor' U por o prirneiro fator normal, multiplicar então o resultado por o segundo fator normal, e assim por diante, até o último dos fatores normãis.
Por exemplo, Considerando as três matrizes, e, anteriormente teríamos o seguinte produto à resolver:
Aplicando a propriedade de decomposição de produtos tensoriais, temos agora as seguintes operações a realizar:
Ou simplesmente:
Portanto, genericamente temos:
Onde, N é o número total de matrizes da SAN.
Claramente nota- se que agora é possível realizar a multiplicação do vetor por cada matriz individualmente, não sendo mais necessario trabalhar com todas as matrizes num mesmo momento.
Em as proximas seções Veremos como funciona e como foi implementado o algoritmo de Deslocamento para a multiplicação do Vetor v por cada tipo de fator normal.
Multiplicação do Último Fator Normal A multiplicação do vetor u por o último fator normal e dada por:
U X mleflN® Sabe- se que o produto tensorial de uma matriz identidade por uma matriz Aí qualquer sempre resulta numa matriz de blocos diagonais, onde cada bloco é a própria matriz M. Logo, a matriz resultante do produto tensorial mlefm® QM) é uma matriz de nleftN blocos diagonais, onde cada bloco e simplesmente a matriz QlNl.
De essa forma, podemos dividir o Vetor'U em nleftN vetores (chamados de zm) com nN elementos e multiplicar cada um destes com a matriz QM) que corresponde ao bloco diagonal da matriz resultante.
A Figura 2.4 ilustra como seria este procedimento.
Valores do Vetor v, como mostra a Figura 2.5, e para acumular os resultados da multiplicação no vetor v..
Em a linha 8 ocorre a multiplicação propriamente dita do vetor zm por a matriz QW) e o resultado armazenado em outro vetor denominado zout de mesmo tamanho do vetor zm.
Note que todo o procedimento é realizado apenas com a utilização do vetor v e da matriz QW), não sendo necessário gerar a..
A multiplicação do vetor u por o primeiro fator normal e semelhante a do último fator normal, a única diferença está no processo de extração dos valores do vetor' U para gerar cada vetor zm.
Essa diferença se dá por o fato da matriz possuir uma forma distinta em relação a matriz envolvida na outra multiplicação, veja abaixo:
De essa forma, para gerar o vetor zm não basta extrair nN elementos consecutivos do vetor v, e preciso extrair os elementos alternadamente, como mostra a Figura 2.6.
Isto é, tem- se que buscar um elemento a cada nrightl elementos do vetor v..
O algoritmo 2.2 apresenta a multiplicação do vetor v por a matriz Qu)® mn-ghtl.
Este algoritmo forma nrightl vetores 2m buscando os elementos alternadamente no Vetor v (linhas 4-7).
Realiza a multiplicação do vetor zm por a matriz QQ) (linha 8) e acumula o resultado no vetor auxiliar zum.
Este vetor então é atribuído ao vetor U que ao final conterá o resultado de toda a operação.
A multiplicação do vetor v por os demais fatores normais é realizada com a combinação das duas outras.
A técnica básica consiste em aplicar a propriedade da pseudo-comutatividade do fator normal:
Isto nos leva a sempre multiplicar os fatores normais, inclusive o primeiro e o filtimo, da seguinte maneira:
As multiplicações são realizadas sempre de acordo com a posição da matriz QM.
O Algoritmo 2.3 resume os passos implementados para multiplicar um Vetor U por um produto tensorial® fllQ(».
Em este algoritmo os fatores normais são tratados do primeiro ao filtimo.
Entretanto, de acordo com a propriedade da comutatividade dos fatores normais, outra ordem pode também ser aplicada.
Note que as multiplicações por o primeiro e por o último fator normal também são cobertos por este algoritmo, logo os algoritmos 2.1 e 2.2 não precisam serem implementados, são usados apenas para o entendimento.
O Algoritmo 2.3 forma nleft¡\&gt; nright¡ vetores zm buscando os elementos nas posições corretas do Vetor v, conforme o nrighti.
Em seguida, realiza a multiplicação do Vetor 2m por a matriz QM e acumula o resultado no Vetor auxiliar 20m.
Este vetor então é atribuído, de forma análoga a extração, ao vetor v que ao final terá o resultado de toda a multiplicação.
Multiplicação v\&gt; Qm® mn-ghtl Esta seção apresenta através de um exemplo todas as etapas que (tonstituem o procedimento de multiplicação vetor-descritor.
Considere um modelo SAN definido por três autômatos:
A multiplicação do vetor 1) por a parte local do descritor passa por os seguintes termos, sendo Qlm o descritor correspondente a descrição das transições locais de cada automato i:
Qí&quot;® IM Im 1711 e QE &quot;g[ ng[ nl g[ ng e of «Cada termo e multiplicado por o vetor v previamente inicializado.
O resultado de cada niultiplicação e então acumulado num vetor auxiliar w.
Após realizar as multipliçações com cada um dos três termos, o valor resultante acumulado no vetor w é então atribuído novamente às posições de v..
O que ocorre, na realidade, resume- se nas seguintes operações:
Deve- se multiplicar o vetor v por o descritor de cada evento sincronizante ei.
Supondo que a SAN possua três eventos sincronizantes, as seguintes operações são necessárias:
É importante salientar que a multiplicação por a parte sincronizante deve ser realizada tanto para a parte positiva quanto para a parte negativa, portanto o procedimento acima deve ser realizado duas Vezes.
A o final, o vetor auxiliar w contém o resultado da multiplicação do vetor v por o descritor Markoviano do modelo, mostrado de forma geral na Tabela 2.3, ou seja:
O custo computacional do algoritmo Shufle, segundo seus criadores, para realizar o produto de um vetor por um termo tensorial e obtido por o número de multiplicações vetor-matriz executadas.
Para cada iteração i do algoritmo são executadas nlefti\&gt; nríght, nlultiplicações vetor-matriz com matrizes de tamanho m..
Supondo que as matrizes QV) não possuem elementos nulos, o número de multiplicações para cada produto vetor' matriz é igual a..
Lembrando que, o custo computacional do Algoritmo Shufle e definido por:
Porém, normalmente as matrizes Qli) possuem um número considerável de elementos nulos, os quais são desconsiderados por o algoritmo.
Logo, o número de multiplicações para cada produto vetor-matriz sera, freqüentemente, inferior a (n02.
Assim, sendo nz¡ o número de elementos não nulos de uma dada matriz QV), o custo computacional apresentado neste algoritmo é entao:
Em a prática, Considerando que para obter as soluções estacionárias dos modelos SAN é necessário multiplicar um vetor de probabilidades por o Descritor Nlarkoviano connpleto do nwdelo, tem- se um custo computacional dado por:
O capítulo seguinte apresenta uma descrição detalhada da técnica Slice, bem como os príncipais trechos de seu algoritmo.
Técnica de Fatiamento ou Slice O principal problema para a resolução de Redes de Automatos Estocásticos (SAN) vem sendo ao longo de o tempo a explosão do espaço de estados.
Isso se deve ao fato de que para resolver uma SAN é necessario realizar a multiplicação de um vetor de probabilidades por o gerador infinitesirnal, operação que normalmente envolve un1a grande quantidade de dados, exigindo un1 alto processamento e uso de memória.
Com o intuito de minimizar a utilização de recursos computacionais, diferentes técnicas vêm sendo estudadas, entre elas destacam- se a técnica Shujflel e a técnica Slice A técnica Slice é uma técnica recentemente descoberta que implementa a resolução de Redes de Autôniatos Estocásticos (SAN).
A operação fundamental realizada nesta técnica, assin1 como na maioria das outras técnicas semelhantes, é a multiplicação de um vetor de probabilidades o por o gerador infinitesimal Q. Esta multiplicação é dada genericamente por a seguinte expressão, sendo N o número de autômatos na rede, e E o número de eventos sincronizantes:
Em especial, serão tratadas as particularidades envolvidas na execução e na implementação da operação de multiplicação apresentada a seguir, visto que esta é a operação fundamental para a resolução de modelos SAN.
Todas as definições estabelecidas na seção 2.4 do capítulo 2 sobre seqüências finitas de matrizes serão da mesma forma utilizadas neste capítulo na definição do algoritmo da técnica Slice.
IO algoritmo Shume foi desenvolvido por Fernandes, Plateau e Stewart Apesar de não ter recebido inicialmente esta denominação, o mesmo vem sendo recentemente denominado como tal Para realizar a multiplicação vetor-descritor, a técnica Slice, utilizando- se de propriedades da álgebra tensorial, introduz uma nova forma de decompor esta operação, chamada de Decomposição Aditivo em Fatores Normais Unitários Aditivos, a qual é abordada nas seções subseqüentes.
Fatores Normais Unitarios Aditivos e uma nova maneira de decompor um produto tensorial qualquer.
O objetivo é reduzir as operações necessárias para executar a multiplicação de um dado Vetor 77W por um produto tensorial entre matrizes.
Os fatores normais unitários aditivos levam em consideração as primeiras matrizes componentes do produto tensorial, onde N e o número total de matrizes envolvidas na operação.
Cada fator normal unitário aditivo (AUNF) pi é constituído por o produto tensorial da matriz resultante do produto tensorial entre as primeiras matrizes contendo apenas um elemento não-nulo por vez, por a última matriz N. Por exemplo, o produto tensorial A® B® C, onde as matrizes têm ordem n:
2, teria a formação dos seguintes fatores normais unitários aditivos:
Segundo Webber, para diversos modelos tem- se um ganho significativo em termos de o número de multiplicações realizadas.
Essa seção apresenta as etapas que constituem a multiplicação vetor-descritor utilizando a decomposição em fatores normais unitários aditivos.
A multiplicação vetor-descritor e composta por a multiplicação do vetor de probabilidades por a parte local e por a parte sincronizante do descritor Markoviano, como veremos a seguir.
Considerando o exemplo anterior, a multiplicação do vetor U por a parte local do descritor passa por os seguintes termos, sendo QÉZ) o descritor correspondente a descrição das transições locais de cada autômato i:
Cada termo e multiplicado por o vetor v previamente inicializado.
O resultado de cada mul-tiplicãção é então acumulado num vetor auxiliar w.
Após realizar as multiplicações com cada um dos tres termos, o valor resultante acumulado no vetor w é então atribuído novamente as posições de v..
O que ocorre, na realidade, resume- se nas seguintes operações:
Resultado acumulado em w y a Em a pratica, o algoritmo da técnica Slice realiza a multiplicação da parte local do descritor fatiando cada um destes termos, como detalhado a seguir.
A multiplicação do vetor de probabilidades por o gerador infinitesimal é dividida em duas partes da mesma forma como o descritor Nlarkoviano, conforme exposto na seção 2.3 do capítulo do modelo SAN e a segunda a multiplicação do mesmo vetor de probabilidades por a parte sincronizante do modelo.
A o final, soma- se os vetores resultantes de cada uma destas operações encontrando- se então o vetor com o resultado final da multiplicação do vetor de probabilidades por o descritor Markoviano.
A Tabela 3.1 apresenta a parte local do descritor Markoviãno, a qual contém apenas as matrizes de transição dos eventos locais do modelo SAN.
Observa- se nesta tabela que a parte local do gerador infinitesinlal e formado por o somatório de N produtos tensoriais de N matrizes.
Sendo assim, a multiplicação do vetor de probabilidades por a parte local do gerador infinitesimal pode ser dividida em N partes, onde cada uma corresponde a multiplicação do vetor de probabilidades por o produto tensorial apresentado em cada li11ha da Tabela 3.1.
Percebe- se ainda que cada produto tensorial e composto por N-J matrizes identidades e apenas uma matriz Qlm, a qual pode conter qualquer valor em seus elementos, onde i e o índice do autômato no modelo SAN.
Sabe- se que num produto tensorial, as matrizes identidades não modificam os elementos das demais matrizes, apenas replicam e reposicionam estes valores na matriz resultante.
De essa forma, a matriz resultante do produto tensorial de cada linha da Tabela reposicionados.
Portanto, a operação de multiplicação do vetor de probabilidades por cada um destes produtos tensoriais resume- se em descobrir onde cada um dos elementos não-nulos da ma triz Qlm seria posicionado na matriz resultante, pois assim basta multiplicar estes valores por os elementos correspondentes no vetor de probabilidades.
Em a pratica, o algoritmo da técnica Slice descobre apenas onde apareceria a primeira ocorren cia de cada valor não-nulo da matriz Q na matriz resultante do produto tensorial.
Sabendo- se onde estaria posicionada a primeira ocorrência do elemento e considerando a posição da matriz Qlm no produto tensorial, e possível descobrir quais valores do vetor de probabilidades devem ser multiplicados por este elemento Iião-nulo.
O Algoritmo 3.1 mostra como é realizada a mul tiplicação de um valor não-nulo da matriz QÉ&quot;) por os elementos correspondentes no vetor de probabilidades, onde bi e bj são inicializados respectivamente com alinha e a coluna da primeira ocorrência de uma elemento não-nulo da matriz Qgi) na matriz resultante, m;
É o tamanho do vetor de probabilidades, m'a dimensão da matriz Qlm, nRight e o produto das dimensões de todas as matrizes a direita da matriz QP, vProb o vetor de probabilidades, dElem o elemento nao-nulo da matriz Q e vRes o vetor acumulador resultante.
É importante salientar que em momento algum os produtos tensoriais entre as matrizes identidades e as matrizes QV) são realizados, reduzindo assim consideravelmente o custo computacional de toda operação.
Para realizar a multiplicação do vetor de probabilidades por cada um dos N produtos tensoriais descritos na Tabela 3.1, o algoritmo da técnica Slice executa nz, vezes o código apresentado no Algoritmo 3.1, onde nz, e o número de elementos não-nulos da matriz Qli).
Portanto, para Algoritmo 3.
1 2 do i:
Bi', 5 do UResUi]\&gt; k dElem;
Algoritmo 3.1: Multiplicação de um elemento não-nulo de uma matriz QE «por o vetor de probabilidades realizar a multiplicação completa do vetor de probabilidades por a parte local do descritor Markoviano, basta executar repetidas vezes o Código apresentado no Algoritmo 3.1.
É na multiplicação do vetor de probabilidades por a parte sincronizante do descritor Markoviano que se encontra a principal diferença entre a técnica Slice e as demais, vejamos um exemplo.
Considerando tres matrizes de ordem n,:
2 e um vetor de probabilidades H0nl\&gt; n;\&gt;
H3), tem- se para este exemplo a definição de (n12\&gt; n22) fatores normais unitários aditivos, um para cada elemento não-nulo do produto tensorial A® B. Vejamos então as etapas da multiplicação vetor-descritor para o termo A® B® C supondo as seguintes matrizes:
&quot;Xi 0000® 1112] Este AUNF e decomposto em dois fatores normais tradicionais:
O vetor nu) terá dois elementos nãonulos (ordem?
LN da última matriz).
O resultado em&amp; é então acumulado num vetor acumulador l'l. &quot;Tolfilg 1112] 7T O resultado em «é então acumulado num vetor acumulador H. Temos então basicamente duas operações que devem ser realizadas para cada ACNF com o intuito de obter o vetor de probabilidades H. Essas operações são a multiplicação do vetor rw) por o primeiro termo do AUNF e a multiplicação do vetor 71-0) por o segundo termo deste mesmo Para entender como o algoritmo da técnica Slice realiza a multiplicação do vetor de probabilidades por a parte sincronizante do descritor Niarkoviano, Vejamos na Tabela 3.2 a parte sincronizante do gerador infinitesimal, que corresponde apenas as matrizes de transição dos eventos sincronizantes do modelo SAN.
A parte sincronizante do descritor Niarkoviano e dividida em duas partes, uma correspondendo as matrizes positivas dos eventos sincronizantes e a outra referente as matrizes negativas destes mesmos eventos.
Observando- se a Tabela 3.2, nota- se que a parte das matrizes sincronizantes positiva e exatamente igual a correspondente as matrizes negativas, podendo se diferenciar apenas no conteúdo das matrizes.
Por este motivo, são apresentados a seguir apenas os detalhes do algoritmo da técnica Slice referentes a multiplicação do vetor de probabilidades por a parte positiva do gerador infinitesimal, uma vez que a operação envolvendo a parte negativa dos eventos sincronizantes e realizada da mesma maneira.
Observando novamente a Tabela 3.2, percebe- se que diferentemente da parte local, a parte sincronizante do descritor Markoviano é composto por produtos tensoriais de matrizes que não são necessariamente identidades, o que torna o calculo da multiplicação um pouco mais complicado.
Assim como na multiplicação por a parte local do gerador infinitesimal, e possível modularizar o calculo da parte sincronizante em multiplicações mais simples.
Estas correspondem as multiplicações do vetor de probabilidades por cada produto tensorial das N matrizes de cada evento sincronizante do modelo SAN, representados por cada linha da Tabela 3.2.
Alem disso, como apresentado na seção 3.1, o produto tensorial entre as matrizes sincronizantes é decomposto em diversos Fatores Normais Unitarios Aditivos, que por sua vez são decompostos em Fatores Normais Tradicionais, tornando o calculo ainda mais modularizado.
De essa forma, a multiplicação do vetor de probabilidades por a parte sincronizante do descritor Markoviano resume- se a um somatório do resultado da multiplicação do vetor de probabilidades por o primeiro Fator Normal Tradicional do AUNF, multiplicado por o segundo Fator Normal Tradicional do mesmo AUNF.
O Algoritmo 3.2 apresenta em linhas gerais os passos implementados para realizar a multiplicação do vetor de probabilidades vProb por a parte sincronizante do descritor Markoviano.
O Algoritmo 3.2 percorre todos os eventos sincronizantes atraves do laço na linha 1, onde nE é o total de eventos sincronizantes do modelo SAN.
Para cada evento, um novo laço (linha 2) percorre todos os Fatores Normais Unitarios Aditivos que compõem o produto tensorial entre as matrizes sincronizantes deste evento.
Enfim, para cada AUNF multiplica- se o vetor de probabilidades vProb por o primeiro Fator Normal Tradicional do AUNF, e em seguida, o resultado armazenado em vAuzr e multiplicado por o segundo Fator Normal Tradicional do ACNF e o resultado é acumulado no vetor vRes, que ao final contera o vetor resultado de toda a operação.
Para descobrir cada um dos Fatores Normais Unitarios Aditivos dos eventos sincronizantes de um modelo SAN, basta na verdade descobrir a linha, a coluna e o valor de cada um dos elementos da matriz resultante do produto tensorial das N r 1 primeiras matrizes sincronizantes do evento.
O Algoritmo 3.3 apresenta o código necessário para descobrir cada um destes valores com suas respectivas linhas e colunas nesta matriz resultante, sem realizar de fato o produto tensorial entre as matrizes.
O Algoritmo 3.3 mostra como foi implementada a rotina que descobre o elemento não-nulo de cada AUXF.
Primeiramente, verifica- se se e o primeiro AUXF para calcular, se for, é necessario percorrer todas as matrizes para pegar um elemento de cada para calcular o elemento nao-nulo do AUNF.
A linha 6 apresenta o laço que percorre as matrizes para pegar seus elementos.
Para otimizar este processo, as multiplicações entre os elementos das matrizes a medida que estão sendo realizadas são armazenadas num vetor vFator, com o intuito de serem reutilizadas quando necessario, conforme descrito em De essa forma, não é necessário percorrer todas as matrizes sempre que o elemento rlão-nulo de um AUNF for calculado, nem mesmo realizar todas as multiplicações novamente.
A função neactElem (linha 7) retorna um elemento não-nulo de uma determinada matriz, ou zero caso já tenha retornado todos.
Se todos os elementos de uma matriz ja foram utilizados, o algoritmo verifica se esta e a primeira matriz, caso seja, retorna zero sinalizando que não existe mais AUNF.
Caso não seja a primeira matriz, o algoritmo retorna para a matriz anterior para pegar o próximo elemento desta matriz e então prossegue o calculo normalmente.
Calcula o elemento não-nulo de cada AUNF Nota- se que o Algoritmo 3.3 não apresenta de que forma a linha e a Coluna do elemento são descobertas, isto porque estas são facilmente obtidas através do uso de uma classe que transforma um índice composto (que contem o índice de cada matriz envolvida na operação) no índice da matriz resultante.
Por exemplo, considerando três matrizes de ordem 2, o índice &quot;O10», que corresponde ao índice &quot;0 «na primeira matriz, &quot;l «na segunda e &quot;0 «na terceira, equivaleria ao índice &quot;2 «na matriz resultante do produto tensorial destas matrizes.
Sendo assim, o algoritmo apenas atualiza o índice composto com as linhas e as colunas dos elementos de cada uma das matrizes envolvidas no cálculo.
Uma vez calculado o elemento não-nulo do AUNF, realiza- se a multiplicação do vetor de probabilidades vProb por o primeiro Fator Normal Tradicional do AUNF, como mostra a linha 3 do Algoritmo 3.2.
A implementação desta operação e apresentada por o Algoritmo 3.4.
Conforme apresentado na seção 3.1, o primeiro Fator Normal Tradicional de um AUN F e composto por o produto tensorial de uma matriz unitária, que contém o elemento não-nulo calculado por o Algoritmo 3.3, por uma matriz identidade de ordem mv, onde mv e a ordem da matriz do último evento sincronizante do modelo.
Sendo assim, basta multiplicar mv elementos consecutivos do Vetor de probabilidades por o elemento não-nulo do AUNF, Conforme mostra o Algoritmo 3.4, onde i e j são respectivamente o índice da linha e da coluna do elemento nãonulo da matriz unitária.
A o final desta operação, o vetor resultante@ Aux contera mv elementos não-nulos.
Lvlultiplicação do vetor de probabilidades por o primeiro Fator Normal Tradicional do AUNF Por fim, a última operação que (tompõe a multiplicação do vetor de probabilidades por a parte sinçronizante do gerador infinitesimal é a multiplicação do vetor resultante@ Aux da operação anterior por o segundo Fator Normal Tradicional do AUNF, Conforme a linha 4 do Algoritmo 3.2.
O segundo Fator Normal Tradicional de cada AUNF, conforme a seção 3.1, é composto por o produto tensorial entre uma matriz identidade de ordem nleftN e a última matriz, onde nleftN é o produto das dimensões de todas as matrizes à esquerda da última matriz do calculo.
Sabe- se que o produto tensorial de uma matriz identidade por uma matriz JM qualquer sempre resulta numa matriz de blocos diagonais, onde cada bloco e a própria matriz 1M.
Logo, a matriz resultante do produto tensorial mWy/ N é uma matriz de nleftN blocos diagonais, onde cada bloco e exatamente a matriz QW).
Considerando que o Vetor@ Aux possui apenas nN elementos nao-nulos e que estes elementos estão posicionados de forma a coincidir exatamente com um bloco diagonal da matriz resultante, basta multiplicarmos estes elementos por a matriz QW).
O Algoritmo 3.5 apresenta os passos necessários para realizar esta operação.
Algoritmo 3.5 1 index:
Primeiramente, o Algoritmo 3.5 extrai os mv elementos não-nulos do vetor' uAucc e coloca- os num Vetor menor chamado de zm (linhas l a 5), onde index e inicializado por o índice da coluna j correspondente ao elemento não-nulo da matriz unitária do primeiro Fator Normal Tradicional do AUNF.
Em seguida, multiplica- se o vetor zm por a última matriz (linha 6) e por fim acumula os resultados no vetor' URCS (linhas 7 a ll), que contem previamente os resultados acumulados de todas as operações anteriores.
Note que todo o procedimento é realizado apenas com a utilização do vetor@ Aux e da matriz QW), não sendo necessario gerar a matriz mgcftw@ Qwl em nenhum momento.
Após realizar cada uma das operações descritas nesta seção, tem- se então o vetor resultado da multiplicação do vetor de probabilidades por a parte sincronizante do descritor Markoviano.
Basta então somar este vetor com o vetor resultado da parte local para enfim encontrar- se o vetor contendo o resultado final da nlultiplicação vetor-descritor.
A utilização de taxas funcionais e muito comum no formalismo de redes de automatos estocasticos.
Muitos modelos SANapresentam taxas funcionais com intuito de facilitar e compactar a descrição do sistema no formalismo, uma vez que algumas peculiaridades do sistema podem ser mais facilmen e modelados utilizando- se este importante recurso.
Ate então, os poucos estudos realizados sobre o algoritmo da técnica Slice não levaram em consideração a u ilização de taxas funcionais em modelos SAN.
Acreditando ser fundamental que o algoritmo Slice funcione também para modelos envolvendo taxas funcionais, foi realizada uma analise do a goritmo da técnica Slice com o intuito de descobrir quais partes deveriam ser modificadas ou a é mesmo reescritas para suportar o uso de taxas funcionas nos modelos.
Porém, após analise do algoritmo original da técnica Slice, chegou- se a conclusão que o uso de taxas funcionais não modificaria a estrutura geral do algoritmo.
A única parte do algoritmo que necessitaria e uma pequena modificação e a parte responsavel por gerar os elementos nãonulos de cada AL NF.
Lsto porque as taxas funcionais, como visto na seção 2.1.4 do capítulo 2, assumem valores que dependem do estado local dos demais autômatos do modelo, sendo assim rlecessário sempre reavaliar todos os elementos.
Com isso, ao imização proposta e implementada para o calculo dos elementos não-nulos de cada ACNF apresentado no Algoritmo 3.3 não e mais valida.
Pois com o uso de taxas funcionais, e necessario sempre percorrer todas as matrizes para avaliar as possíveis funções, uma vez que a cada mudança de um estado local (linha de um elemento de uma matriz de transição), todas as outras taxas funcionais do modelo podem ser afetadas.
Portanto, a otimização proposta na seção 3.2.2, a qual armazena resultados parciais de multiplicações entre elementos de matrizes de transições sincronizantes, não pode ser utilizada quando o modelo SAN apresentar taxas funcionais.
O Algoritmo 3.6 apresenta como é realizado o calculo dos elementos rlão-nulos de cada ACNF para modelos SAN que incluem taxas funcionais na sua definição.
Em a linha 1, a função neztElemmdez descobre o próximo indice composto (índice de cada matriz envolvida no calculo) para o elemento a ser calculado.
Em seguida, é atribuída a variável nFator o valor do elemento da primeira matriz.
Depois, este valor e multiplicado por o elemento da segunda matriz, da terceira e assim sucessivamente (linhas 3, 4 e 5) até a penúltima matriz do modelo.
Enfim, na linha 6, a variavel nFator conterá o próximo fator da AUNF que é então retornado.
Calcula o elemento nãoqiulo de cada AUNF para modelos SAN com taxas funcionais Novas alternativas de otimização para o algoritmo da técnica Slice precisam ser estudados no caso de o uso de taxas funcionais nos modelos SAN.
Em especial, seria interessante estudar em detalhes o calculo dos elementos nao-nulos dos fatores normais unitários aditivos (AUXF) quando de o uso de taxas funcionais, tentando- se encontrar 'uma forma de otimizar' este cálculo, visto que a otimização proposta neste estudo só e válida para modelos com taxas exclusivamente constantes.
O custo computacional da técnica Slice para a parte local de um modelo SAN é igual ao custo da técnica Shufle para esta mesma parte, uma vez que o número de multiplicações em ponto-flutuante é o mesmo, o que difere uma da outra é apenas a forma como o cálculo é realizado.
Portanto, considerando N o número de autômatos do modelo SAN, m, a dimensão da i-ésima matriz e n 21- o número de elementos irao- nulos da matriz i, o custo computacional da técnica Slice para a parte local do modelo é representado por a seguinte expressão:
Hu¡\&gt; É O custo computacional para a parte sincronizante do modelo depende do custo necessário para multiplicar um vetor de probabilidades 7r por um fator normal unitario aditivo, o qual é representado por a expressão 3.2, onde mv e nzN são respectivamente a dimensão e o número de elementos não-nulos da última matriz do termo.
Em a expressão acima temos (N -- 2) multiplicações entre elementos das N r 1 matrizes envolvidas.
Alem disto, como para cada AUNF são gerados dois fatores normais tradicionais, para o primeiro fator normal temos mv multiplicações por o vetor 7 r, e para o segundo, nzN multiplicações.
Sabendo-se que o número de fatores normais unitarios aditivos a tratar é dado por todas as Combinações de elementos não-nulos das N -- 1 matrizes iniciais, tem- se como Custo computacional total para a parte síncronizante a expressão a seguir:
Portanto, o custo computacional total da técnica Slice é a soma dos custos da parte local e sincronizante do modelo SAN, resultando na seguinte expressão:
Para demonstrar o quanto a técnica Slice pode contribuir para a resolução de modelos SAN, este capítulo apresenta uma análise do custo computacional e de resultados práticos obtidos de dois exemplos de modelos SAN.
Com intuito de fazer uma analise completa do desempenho do algoritmo da técnica Slice, dois exemplos de modelos SAN corn.
Alem disso, para os testes praticos, diferentes Valores foram atribuídos para as taxas dos eventos locais e sincronizantes dos modelos.
Primeiramente, todas as taxas dos eventos dos modelos foram definidas com valores constantes, em seguida, a maioria das taxas receberam valores funcionais, possibilitando assim uma analise do comportamento da técnica Slice com e sem taxas funcionais, uma vez que a avaliação das taxas funcionais pode gerar um custo relevante em termos de tempo de execução.
As Figuras 4.1 e 4.2 apresentam os autômatos referentes aos exemplos de modelo SAN utilizados na analise numérica, ao passo que as Tabelas 4.1 e 4.2 descrevem respectivamente os eventos destes modelos.
Observa- se nestas tabelas que as taxas são definidas por variaveis, pois como dito anteriormente, estas taxas recebem diferentes valores para cada caso de teste.
Como resultado da analise apresentada neste capítulo pretende-se obter o desempenho da técnica Slice sem e com otimizações.
Em especial duas otimizações foram testadas, a otimização da diagonal, ja estudada detalhadamente em trabalhos anteriores, e a otimização na geração dos fatores, a qual e proposta neste trabalho para modelos com taxas exclusivamente constantes.
Além disso, é realizada uma comparação entre os resultados da técnica Slice e os resultados da tradicional técnica Shuffle.
Afinal, um dos objetivos da técnica Slice é apresentar uma forma mais eficiente de resolver modelos SAN em relação as demais técnicas existentes.
Antes mesmo de qualquer implementação do algoritmo da técnica Slice, e possível xrerificar na teoria qual seria o seu custo computacional.
Utilizando-se da fórmula do custo computacional da técnica Slice, facilmente pode- se calcular o número de multiplicações em ponto-flutuante necessarias para realizar uma iteração da resolução de modelos SAN.
Essa informação e determinante para avaliar na teoria o desempenho de uma técnica, uma vez que as multipliçações em pontqfiutuante são as principais operações realizadas neste processo.
Portanto, sabendo- se o número de multiplicações em ponto-flutuante necessarias para resolver um modelo SAN, tem- se então uma noção do tempo de processamento necessario para a resolução do modelo.
Em esta seção, serão considerados o custo computacional da técnica Shame, da técnica Slice, e também do algoritmo da técnica Slice com a otimização na geração dos fatores.
Além disso, estes custos serão calculados de duas formas, a primeira sem considerar uma otimização de pre-calculo da diagonal e a segunda considerando esta otimização.
A otimização do pre-calculo da diagonal, ou simplesmente otimização da diagonal, consiste em calcular e armazenar previamente todos os elementos da diagonal principal do descritor do modelo SAN, desconsiderando assim os elementos da diagonal principal das matrizes locais e todas as matrizes negativas dos eventos sincronizantes do modelo.
Com isso, diminui- se o número de multiplicações em cada iteração da resolução do modelo SAN.
Por outro lado, o custo em memória para armazenar a diagonal principal do descritor pode ser bastante considerável dependendo do tamanho do modelo SAN em questão, o qual será abordado na análise dos resultados práticos.
Observando as fórmulas do custo computacional da técnica Shafle e Slice, percebe- se que o custo para realizar os calculos da parte local de um modelo SAN e igual para as duas técnicas.
Por conseqüência, a grande quantidade de matrizes identidades envolvidas no calculo, acaba anulando a vantagem em utilizar- se a técnica Slice, uma vez que diversas multiplicações se tornam desnecessárias.
Analisando-se mais detalhadamente o cálculo da parte local, percebe- se que este nada mais e do que a multiplicação de elementos de uma dada matriz do modelo por diversos elementos do vetor de probabilidades, os quais dependem da localização da matriz do modelo no produto tensorial com as matrizes identidades.
Ou seja, a multiplicação do vetor de probabilidades por um fator normal.
Este processo e exatamente o foco da técnica Shuffle, como visto na seção eficiente por a técnica Shame, pois ao contrario desta, a técnica Slice não se preocupa com o custo necessario para descobrir os elementos do vetor ao qual cada elemento das matrizes do modelo devem ser multiplicados.
Por outro lado, a parte local do algoritmo da técnica Slice, assim como a parte sincronizante, e mais flexível a implementações paralelas, pois a multiplicação do vetor de probabilidades por as matrizes do modelo é realizada separadamente para cada elemento das matrizes, enquanto que na técnica Shafle esta operação é realizada utilizando- se de uma vez só todos os elementos de cada matriz do modelo SAN.
Sendo assim, quando se tratar de uma implementação seqüencial, sugere- se utilizar a técnica Shame para o calculo da parte local do modelo, enquanto que para implementações paralelas, a técnica Slice mostra- se mais adequada.
Em esta seção serão apresentados o custo computacional para as técnicas Shame e Slice sem considerar a otimização da diagonal.
Ou seja, fazem parte do calculo todos os elementos díagonais das matrizes locais dos modelos, assim como todas as matrizes negativas dos eventos sincronizantes.
Custo Computacional para o primeiro exemplo Sabendo- se que N e o número total de autômatos do modelo, E e o número de eventos sincronizantes, n¡ é o número de estados do autômato i e que nz, é o número de transições que o autômato i possui para Cada evento local e sincronizante do modelo, pode- se facilmente calcular o custo computacional para cada uma das técnicas.
Primeiramente, vejamos para o exemplo apresentado por a Figura 4.1 quais seriam os valores para cada uma das variaveis das fórmulas do custo computacional das técnicas, considerando a parte local e sincronizante do modelo SAN.
Observando a Figura 4.1 e a Tabela 4.1 sabe- se que para este exemplo, o número de autômatos N e 6 e o total de eventos síncronizantes E e 9.
A Tabela 4.3 apresenta ainda a definição das variaveis n¡ e nz, para a parte local do primeiro exemplo de modelo SAN.
Em a Tabela 4.4 são apresentadas as definições das variaveis m e n 21-para cada evento sincronizante do modelo, referindo- se a parte sincronizante do primeiro exemplo de modelo SAN.
Como nenhum autômato deste modelo apresenta duas ou mais transições saindo de um único estado para outros utilizando o mesmo evento sincronizante, pode- se considerar os Valores apresentados na Tabela 4.4 para as matrizes positivas e negativas do modelo.
Considerando as Tabelas 4.3 e 4.4, e ainda a fórmula do custo computacional para a técnica Shuffle, o primeiro exemplo de modelo SAN apresenta o seguinte custo computacional (calculo completo no apêndice B):
Portanto, utilizando- se a técnica Shufle são necessarias 171.992 multiplicações em pontoflutuailte para cada iteração da resolução deste primeiro exemplo de modelo SAN.
Desta forma, tem- se uma noção do tempo de processamento necessario para realizar este cálculo.
Sabendo que mv e nzN são respectivamente a ordem e o número de elementos ilao- nulos da matriz do último autômato do modelo SAN, no caso o autômato Am), o custo computacional da técnica Slice para este exemplo é (consulte o apêndice B para detalhes do calculo):
Portanto, se a técnica Slice for utilizada para resolver este exemplo de modelo SAN, serão necessarias apenas 20.160 multiplicações em ponto-flutuante para cada iteração, ao passo que para a técnica Shufíe seriam necessarias 171.992 destas operações.
Custo Computacional para o segundo exemplo Analisando a Figura 4.2 e a Tabela 4.2 observa- se que para este segundo exemplo de modelo SAN, o número de autômatos N é 6 e o total de eventos sincronizantes E é 8.
As Tabelas 4.5, positiva e sincronizante negativa respectivamente para este modelo SAN.
Considerando os valores apresentados por as Tabelas 4.5, 4.6 e 4.7, o calculo do custo computa cional da técnica Shufíe para este exemplo de modelo SAN seria (calculo completo no apêndice:
Portanto, utilizando-sc a técnica Shuffle para rosolxror o segundo exemplo do modelo SAN, são necessárias 187.968 multiplicações en1 ponto- flutuante para cada iteração da resolução deste modelo.
Para osto mesmo (txonlplo, pode-sc (talcular também o provável custo computacional para a tívcnica Slice, o qual seria:
Portanto, se utilizarmos a técnica Slice para resolver este mesmo exemplo de modelo SAN, serão necessárias 49.344 multiplicaçõos cm ponto- fiutuantc para cada itoração da resolução dosto modelo.
Como visto anteriormente, no Capítulo 3, para modelos corn taxas exclusivamente constantes é possível realizar uma otimização no calculo da parte sincronizante dos modelos SAN.
A idéia é otimizar o processo de descoberta dos fatores normais unitários aditivos, reaproveitando as multiplieações ja realizadas entre os elementos das matrizes do termo calculado.
A fórmula do custo Computacional original para a parte sincronizante da técnica Slice considera que as multiplicações entre os elementos das matrizes são realizas toda vez para cada fator normal unitário aditivo.
Analisando ilovamente esta equação, nota- se que para Cada AUNF, representadas por o termo, são contabilizadas N r 2 multiplicações.
Custo computacional original para parte sincronizante.
Implementando- se a otimização proposta, não se fazem necessarias tantas multiplicações para descobrir os fatores normais unitários aditivos.
A lógica e simples, se e preciso realizar diversas multiplieações entre três ou mais números, variando- se um número de cada vez, pode- se armazenar uma parte do calculo para ser reaproveitada, evitando assim repetições de multiplicações ja realizadas, Vejamos um exemplo pequeno:
Expressões para serem resolvidas:
Sem otimização seriam necessaria 12 multiplirações.
Com otimização seriam necessaria apenas 7 multiplicações.
Em este pequeno exemplo ja pode- se ter uma noção da quantidade de multiplicações que seriam evitadas por a otimização do cálculo.
Percebe- se que os resultados intermediários 12, 24 e 72 são armazenados e reutilizados para os próximos calculos, evitando assim uma série de multiplicações desnecessárias.
Logo, considerando essa otimização, pode- se reescrever a fórmula do custo computacional para a parte sincronizante da técnica Slice da seguinte forma:
Sendo assim, considerando que os exemplos 1 e 2 de modelo SAN apresentem apenas taxas constantes, o custo computacional para estes utilizando o algoritmo otimizado da técnica Slice seria (calculo completo no apêndice B):
O custo computacional para as técnicas Shufle e Slice apresentado nesta seção leva em Consideração a otimização da diagonal.
Ou seja, são eliminados do calculo todos os elementos diagonais das matrizes locais dos modelos, assim como todas as matrizes negativas dos eventos sincronizantes.
De essa forma, o número de multiplicações em ponto-flutuante certamente sera reduzido.
Vejamos a seguir como seriam os custos computacionais para os dois exemplos estudados.
Custo Computacional para o primeiro exemplo Tendo realizado o calculo do custo computacional sem a otimização da diagonal, torna- se fácil de descobrir o custo considerando esta otimização.
Basta refazer os cálculos da parte local do modelo, uma Vez que os Valores de nz, para as matrizes locais sofrem modificações, somar com o resultado da parte sincronizante positiva obtido anteriormente, e por fim desconsiderar o cálculo da parte sincronizante negativa do modelo SAN.
Considerando a Tabela 4.8, que apresenta a definição das variaveis n, e nz¡ para a parte local do primeiro exemplo de modelo SAN com a otimização da diagonal, o custo computacional para as técnicas Shuffle e Slice seriam (detalhes do calculo no apêndice B):
Custo computacional da técnica Shuüíe para este modelo SAN.
Custo computacional da técnica Slice para este modelo SAN.
Portanto, observa- se que com a otimização da diagonal, o número de multiplicações em pontoflutuante para cada iteração é reduzido de forma significativa, tanto para a técnica Shuffle quanto para a técnica Slice.
Custo Computacional para o segundo exemplo Assim como realizado para o exemplo anterior, para descobrir o custo computacional considerando a otimização da diagonal, deve- se recalcular apenas a parte local do segundo modelo SAN de exemplo.
Considerando a Tabela 4.9, que apresenta as definições das variáveis n, e nz¡ para a parte local do modelo com a otimização da diagonal, o custo Computacional para as técnicas Shuffle e Slice seriam (calculo completo no apêndice B):
Custo computacional da técnica Shame para este modelo SAN.
Custo computacional da técnica Slice para este modelo SAN.
Portanto, mais uma vez Verifica- se que com a otimização da diagonal, o número de multiplicações em ponto-flutuante para cada iteração diminui significativamente para ambas as técnicas.
Custo Computacional para Slice Otimizado Considerando que a otimização dos fatores proposta para o algoritmo da técnica Slice refere- se somente à parte sincronizante do modelo, e que a otimização da diagonal não modifica o cálculo da parte sincronizante positiva, pode- se utilizar estas duas otiinizações em conjunto, obtendo um custo computacional de 8.926 e 18.800 para o primeiro e segundo exemplos de modelo SAN respectivamente.
Após calcular o custo computacional das técnicas Shu/ fla e Slice para os dois exemplos de modelo SAN apresentados por as Figuras 4.1 e 4.2, é possível fazer uma análise sobre os resultados obtidos.
A Tabela 4.10 apresenta os resultados do custo computacional para calcular uma iteração da resolução dos exemplos 1 e 2 atraves das técnicas Shufle e Slice.
O custo computacional e representado por o numero de multiplicações em ponto-flutuante necessarias para realizar o cálculo.
Analisando os custos computacionais das técnicas Slice e Shuffle para os dois modelos SAN apresentados nesta seção, percebe- se claramente na teoria que a técnica Slice apresenta um desempenho bastante superior a técnica Shufle na resolução destes modelos, seja utilizando- se a otimização da diagonal ou não.
Sem a otimização da diagonal a técnica Slice obteve um custo computacional mais de 8,5 vezes menor para o exemplo 1 e de aproximadamente 3,8 vezes menor para o exemplo 2.
Considerando a otimização da diagonal, a técnica Slice mantem uma boa vantagem em relação a Shame, porém diminui um pouco.
Para o exemplo 1, a técnica Slice apresenta um custo computacional quase 8, 4 vezes melhor que a Shume, enquanto que para o exemplo 2 essa relação e de aproximadamente 3, 56.
Pode- se atribuir esta pequena diferença da vantagem da técnica Slice sobre a Shuffle, quando utiliza- se a otimização da diagonal, ao fato de que corn esta otimização não são contabilizadas as multiplicações da parte sincronizante negativa do modelo, a qual a técnica Slice levaria vantagem em relação a técnica Shuüle.
Porém, percebese que para ambas as técnicas a otimização da diagonal reduz consideravelmente o custo computacional, demonstrando assim que a otimização da diagonal também é válida para a técnica Slice.
Alem disso, utilizando- se a otimização na geração dos fatores para modelos com taxas exclusivamente constantes, observa- se que o custo computacional da técnica Slice tornou- se ainda melhor, apresentando uma redução no número de multiplicações de aproximadamente 13% e 29% para os exemplos 1 e 2 respectivamente.
O que aumenta ainda mais a vantagem da técnica Slice em relação a Shufle, chegando a apresentar um custo computacional quase 10 vezes menor para o primeiro exemplo e acima de 5 vezes menor para o segundo exemplo.
Cornprovando- se assim, que a otimização proposta para a técnica Slice reduz significativamente o numero de multiplicações em ponto- i'lutuante necessárias para realizar o calculo de cada iteração da resolução do modelo SAN.
Considerando que para resolver um modelo SAN normalmente são necessarias inúmeras iterações e que os custos computacionais apresentados por a Tabela 4.10 são para o cãlculo de apenas uma iteração da resolução dos modelos SAN, pode- se imaginar o quanto seria o ganho total no desempenho para a resolução completa de um modelo SAN.
A analise do custo computacional e importante para fundamentar os estudos realizados e ambém para encorajar os pesquisadores a continuar os estudos caso estes resultados teóricos sejam positivos.
Assim, considerando que os resultados da analise do custo Computacional da ecnica Slice foram muito significativos, torna- se valida a realização de uma analise sobre resultados praticos desta técnica.
Realizando essa analise sera possível verificar se os resultados eóricos se confirmam na pratica, provando assim o bom desempenho da técnica Slice.
Para realizar uma analise sobre resultados práticos foi preciso implementar o algoritmo da ecnica Slice, uma vez que nenhuma implementação deste algoritmo havia sido realizada ate então.
Logo, uma nova versão da ferramenta PEPS foi desenvolvida incluindo o algoritmo da écnica Slice.
De essa forma, foi possivel realizar testes práticos com as duas técnicas, pois o algoritmo Shufle ja havia sido implementado nesta ferramenta.
É importante salientar que a analise realizada neste trabalho e exclusivamente numérica e aseou- se apenas em algoritmos seqüenciais para ambas técnicas.
Ou seja, não foram realizadas implementações paralelas e nem otimizações algorítmicas, como a utilização de pacotes de softwares para otimizar determinadas funções.
A implementação da técnica Slice foi realizada utilizando- se o algoritmo Slice para a parte sincronizante e o algoritmo Shuffle para o calculo da parte local dos modelos SAN, uma vez que na teoria para implementações seqüenciais este apresenta- se mais adequado para esta parte.
Porém, em momento algum houve influência nos resultados dos testes realizados, pois a principal diferença entre estas duas técnicas esta exatamente na parte sincronizante dos modelos SAN.
Para obter resultados práticos através da ferramenta PEPS, utilizou- se novamente os dois exemplos de modelos SAN apresentados por as Figuras 4.1 e 4.2.
Os calculos foram realizados sobre o sistema operacional Linux num computador Pentium IV Xeon 2, 2 GHz com 512 MB de memória Cache e 4 GB de memória principal.
Além disso, com o intuito de obter resultados de tempo mais precisos, foram executadas dez vezes cada caso do teste, com aproximadamente 1.000 iterações, e considerado como resultado final a média dos tempos obtidos.
Logo, todos resultados apresentados nas tabelas e gráficos das próximas seções são referentes ao tempo de execução de 1.000 iterações da resolução do modelo Para distinguir os resultados da técnica Slice sem e com a otimização da diagonal nas tabelas e graficos apresentados nesta seção, estabeleceu- se que a legenda Slice-SD representa resultados da técnica Slice sem a otimização da diagonal, ao passo que a legenda Slice-CD representa os resultados com esta otimização.
Em esta seção serão apresentados e analisados alguns resultados práticos para a técnica Slice sem considerar a otimização da diagonal.
Alem disso, são apresentados os resultados para a técnica Shuffle, porém esta utilizando a otimização da diagonal, uma vez que não existe a im plementação desta técnica sem esta otimização.
Sendo assim, torna- se necessário apresentar tambem o total de memória exigida por cada uma das técnicas, para então possibilitar uma análise do custo/ benefício de cada técnica.
Resultados para modelos com taxas exclusivamente constantes.
Primeiramente foram realizados testes com os dois exemplos de modelos SAN contendo apenas taxas constantes, ou seja, nenhuma taxa dos modelos foi definida através de função.
De essa forma, será possível analisar com maior precisão o desempenho das técnicas, uma vez que 0 tempo que se gastaria para avaliar funções não e contabilizado.
A Figura 4.3 apresenta o grafico com os tempos de execução obtidos atraves da ferramenta PEPS para as técnicas Shame e Slice para os dois exemplos SAN com taxas exclusivamente constantes, além de a memória consumida por cada uma das técnicas.
Observando o grafico e a tabela da Figura 4.3, percebe- se que a técnica Slice mesmo sem utilizar a otimização da diagonal apresenta um melhor desempenho que a técnica Shame, tanto para o exemplo 1 quanto para o exemplo 2.
Além disso, o consumo de memória foi bastante inferior na técnica Slice, o que já se previa por o fato desta não estar utilizando a otimização da diagonal.
Nota- se também, que a técnica Slice obteve um desempenho melhor para o segundo exemplo, o que nos leva a crer que as características deste exemplo sejam mais favoráveis ao algoritmo da técnica Slice.
Ainda, e possível verificar o desempenho da técnica Slice quando utilizada a otimização na geração dos fatores normais unitários aditivos.
Percebe- se que para ambos os exemplos esta otimização se mostra Valida, uma Vez que obteve- se uma redução no tempo de execução de aproximadamente 27% e 18% para os exemplos 1 e 2 respectivamente.
Uma vez analisados os desempenhos das técnicas para modelos SAN com taxas exclusivamente constantes, e importante Verificar tambem o comportamento destas técnicas quando os modelos SAN possuem taxas funcionais.
Isto porque a maioria dos sistemas modelados em SAN exige esse tipo de taxa de transição.
A Figura 4.4 apresenta o gráfico com o tempo e a memória exigida para a execução das técnicas Shuffle e Slice para os exemplos de modelos SAN com diversas taxas funcionais.
Os resultados apresentados por a Figura 4.4 demonstram que o custo para avaliar taxas funcionais ainda é bastante elevado, principalmente para a técnica Slice.
Percebe- se claramente isto, pois para modelos com taxas funcionais o seu desempenho diminuiu significativamente, tornou- se menos eficiente que a técnica Shufle.
De qualquer forma, os resultados para a técnica Slice são ainda assim bastante interessantes, uma vez que esta não fez uso da otimização da diagonal e também por se tratar da sua primeira implementação.
Alem disso, o estudo da otimização dos fatores pode ser aprofundado, de forma a abranger também modelos com taxas funcionais, o que certamente iria melhorar consideravelmente o desempenho da técnica nestas situações.
Em esta seção serão apresentados e analisados alguns resultados práticos para as técnicas Shuüfle e Slice para os modelos SAN de exemplo, considerando- se a utilização da otimização da diagonal para ambas as técnicas.
Resultados para modelos com taxas exclusivamente constantes A Figura 4.5 apresenta o grafico com os tempos de execução obtidos atraves da ferramenta PÉPS para as técnicas Shuffle e Slice para os dois exemplos SAN com taxas exclusivamente constantes.
Através da Figura 4.5 é possível analisar o desempenho das técnicas Shufle e Slice quando irtilizada a otimização da diagonal.
Percebe- se que para os dois exemplos a técnica Slice apre senta um menor tempo de execução, Chegando a ser menos da metade do tempo gasto por a técnica Shuffle para ambos exemplos.
Lsso demonstra que para resolver estes exemplos a técnica Slice certamente seria a melhor opção.
Alem disso, mais uma Vez a otimização proposta para o processo de geração dos fatores apresentou resultados significativos.
Resultados para modelos com taxas funcionais A Figura 4.6 apresenta o grafico com os tempos de execução das técnicas Shuüle e Slice para os exemplos de modelos SAN com diversas taxas funcionais.
A Figura 4.6 apresenta resultados bastante animadores em relação a resolução de modelos SAN com taxas funcionais atraves da técnica Slice, uma vez que mesmo sendo a primeira implementação desta técnica, os resultados foram consideravelmente melhores do que os obtidos por a tradicional técnica Shufle.
A otimização da diagonal e realmente bastante interessante quando se tem disponível memória suficiente para armazenar a diagonal do modelo sem a necessidade de realizar swap.
Porém, se isso não ocorrer, a otimização perde sua validade, podendo ate piorar o desempenho da técnica utilizada.
Considerando que a técnica Slice apresenta um custo computacional significativamente menor que o custo apresentado por a técnica Shu/ fla e que os resultados praticos comprovam um melhor desempenho para a técnica Slice, pode- se não ser interessante utilizar a otimização da diagonal para esta técnica, pois mesmo aumentando urn pouco o custo computacional, o ganho na utilização da memória seria eompensador.
Esta decisão deveria ser tomada caso a caso, dependendo do tamanho do sistema modelado.
Com intuito de demonstrar que para modelos maiores a otimização da diagonal pode não ser interessante, criou- se um exemplo de modelo SAN com 12 autômatos com o número de estados variando entre 2 a 6, totalizando ern 10.616.832 o espaço de estados do rnodelo.
Calculou- se então o tempo necessario para executar cada iteração deste modelo utilizando- se a técnica Shu/ fla com a otimização da diagonal e a técnica Slice sem esta otimização.
Para os cálculos foi utilizado um computador com um processador Pentiurn IV 2, 8 GHz, 256 MB de memória cache e 512 MB de memória principal, sobre o sistema operacional Linux.
A Figura 4.7 apresenta uma tabela com 0 tempo de execução para apenas uma iteração da resolução deste modelo, assirn como a memória consumida por cada técnica.
Alem disso, esta figura apresenta tambem um grafico comparando os tempos de execução.
Observando a Figura 4.7, percebe- se que para modelo SAN, a implementação da técnica Shame com a otimização da diagonal necessitou de um grande volume de memória, tornando necessário a realização de swap, o que acabou influenciando diretamente no seu desempenho.
Por este motivo, a técnica Slice sem a otimização da diagonal apresentou um desempenho bastante superior.
Percebe- se ainda que utilizando a versão otimizada da técnica Slice, a qual realiza menos multiplicações para calcular cada fator normal unitario aditivo, o desempenho e ainda melhor, chegando a reduzir em aproximadamente 58% o tempo de execução de cada iteração.
Alguns estudos ja demonstravam que a ordem dos automatos do modelo SAN influência o desempenho da técnica Slice.
Em a verdade, o que realmente influência a técnica Slice, assim como a própria técnica Shame, é a ordem das matrizes de cada termo do calculo da iteração da resolução do modelo SAN.
A técnica Shuffle, por existir a mais tempo e por já ter sido bastante estudada, apresenta uma implementação onde as matrizes são permutadas de forma a realizar o calculo de cada termo com a melhor disposição possível destas matrizes.
O algoritmo desta técnica foi implementado realizou a primeira revisão, em 1994 e 1997 foi a vez de Fernandes dar a sua contribuição revisando novamente o algoritmo da técnica Shufle.
Isso demonstra o quanto a técnica Shuüfle ja foi melhorada ao longo de o tempo.
Por outro lado, a técnica Slice esta apenas na sua primeira versão, implementada durante a execução deste trabalho.
Apesar de a implementação do algoritmo desta técnica ter sido realizada de forma cuidadosa, buscando sempre o melhor desempenho, certamente novas versões deste algoritmo serão implementadas no futuro.
Ate porque, esta primeira versão da técnica Slice não inclui permutações entre matrizes o que resultaria num melhor desempenho da técnica.
Lsso nem poderia ser realizado, pois o estudo da melhor ordem das matrizes para a técnica Slice ainda precisa ser Concluído.
Com o intuito de demonstrar como a ordem dos autômatos ou das matrizes do modelo influençiam diretamente no desempenho da técnica Slice, foram testados diversas variações da ordem dos autômatos dos exemplos 1 e 2.
Para estes testes considerou- se apenas o algoritmo da técnica Slice utilizando- se a otimização da diagonal, mas sem levar em Consideração a otimização dos fatores normais unitários aditivos.
As Figuras 4.8 e 4.9 apresentam diversas variações na ordem dos autômatos dos dois modelos SAN de exemplo, assim como o tempo necessario para executar 1.000 iterações para çada nova seqüência.
Analisando as Figuras 4.8 e 4.9 percebese que a ordem dos autômatos nos modelos SAN realmente influência o desempenho da técnica Slice.
Lsso ja era esperado, uma vez que o número de fatores normais unitarios aditivos depende diretamente da ordem das matrizes nos termos de o calculo.
Ou seja, uma determinada seqüência de autômatos pode gerar mais fatores do que outra, e conseqüentemente exigir mais multiplicações em ponto-flutuante, o que certamente consumiria mais tempo para execução.
Observando os graficos e tabelas das Figuras 4.8 e 4.9 nota- se que os resultados são muito semelhantes para as seqüências que apresentam o mesmo autômato no final.
Isso se deve pois a ordem dos N -- 1 primeiros autômatos do modelo não influência o número de fatores normais unitários aditivos.
Por outro lado, a troca do ultimo autômato do modelo modifica as matrizes envolvidas no calculo dos fatores, o que pode gerar mais ou menos fatores.
De essa forma, parece correto dizer que para a técnica Slice o que importa e qual sera o último autômato do modelo.
Portanto, torna- se bastante interessante a realização de um estudo detalhado para descobrir a melhor ordem das matrizes para cada termo do calculo da técnica Slice.
Assim, como realizado para a técnica Shuffle, sera possível implementar uma nova versão da técnica Slice incorporando mais esta otimização, o que certamente resultará num desempenho ainda melhor.
A Figura 4.10 reúne 05 principais resultados apresentados ao longo deste capítulo, facilitando assim uma analise completa do desempenho da técnica Slice.
Observando a Figura 4.10 percebe- se que mesmo sem a otimização da diagonal a técnica Slice apresenta melhores resultados que a tradicional técnica Shujíe.
Ou seja, com a técnica Slice e possível resolver modelos SAN em menos tempo e consumindo menos memória.
Alem disso, comparando os resultados obtidos, fica claro que a otimização na geração dos fatores obteve sucesso, diminuindo consideravelmente o tempo necessário para a execução de cada iteração da resolução do modelo SAN.
Tempo (segundos) 3¡ Shuffle!
Considerações Finais mfelizmente muitos sistemas em funcionamento hoje em dia nunca tiveram o seu desempenho avaliado de forma consistente, entenda- se por sistemas não só programas de computador, mas toda e qualquer atividade que envolva dados de entrada e de saída.
Por exemplo, o funcionamento de um posto de gasolina pode ser considerado um sistema, onde os (rlientes e o lucro seriam os principais dados deste sistema.
Em este caso, diversas avaliações sobre o seu desempenho poderiam ser realizadas, desde a melhor forma de disponibilizar as bombas de gasolina, ate o número de funcionários necessario e a capacidade dos tanques de combustível, tudo isso dependendo do número de clientes do posto e visando sempre a satisfação dos clientes e o lucro do proprietário.
A precária forma de avaliação de sistemas ou mesmo a falta desta prática vem prejudicando inúmeras empresas no mercado acirrado dos negócios de hoje em dia.
Diversas empresas tem apresentado prejuízos e ate mesmo encerrando suas atividades muitas vezes por falta de um planejamento e avaliação adequados do seu negócio.
Isso se deve pois até então não existe uma forma consistente e de baixo custo para realizar uma boa avaliação dos sistemas.
Atualmente, para realizar uma completa avaliação de um sistema razoavelmente grande, ao qual envolve diversos fatores e peculiaridades, exigiria- se um enorme custo computacional, muitas vezes tornando- se inviável de ser realizada.
Por este motivo, os estudos na área de avaliação de desempenho de sistemas não podem parar, por o contrario, deve- se investir cada vez mais nesta área, pois tende a ser uma área bastante promissora.
Com a definição do formalismo de Redes de Automatos Estocásticos (SAN), a modelagem de sistemas tornou- se mais compacta e modular, facilitando assim a modelagem de sistemas maiores e com um maior nível de detalhes.
Porém, mesmo com o formalismo SAN, a resolução de alguns sistemas ainda exige um alto custo computacional, uma vez que o espaço de estados destes modelos pode ser muito grande.
Diversas técnicas para resolução de modelos SAN vêm sendo estudadas ao longo de o tempo, e muitos resultados positivos ja foram encontrados, como a criação e aperfeiçoamento da tradicional tecnirza Shufle, a qual tornou- se inclusive uma referência mundial no assunto.
Porém, novas técnicas têm se mostrado muito interessantes e apresentado ótimos resultados, como é o caso da técnica Slice estudada em detalhes neste trabalho.
Em o decorrer deste estudo foi realizada uma analise profunda da técnica Slice, com o intuito de explorar mais os seus pontos fortes e buscar melhorias para os seus pontos que apresentavam um menor desempenho.
Para tanto, irnplementou- se a primeira versão desta técnica, tirando- a definitivamente do papel, e possibilitando pela primeira vez uma analise de resultados praticos do seu desempenho para resolução de modelos SAN.
Além disso, estendeu- se o algoritmo da técnica Slice para abranger também modelos com taxas funcionais, o que ate então não tinha sido estudado nem mesmo na teoria.
Por fim, ainda foi proposta e implementada uma otimização num dos principais pontos do algoritmo desta técnica, a geração dos fatores normais unitários aditivos.
Após implementar a técnica Slice, realizou- se então uma série de testes em diversas situações, visando analisar o desempenho da técnica na resolução de modelos SAN.
Com os resultados dos testes realizados foi possível constatar que a técnica Slice é realmente uma ótima alternativa para a resolução de sistemas rnodelados por o formalismo SAN, uma vez que seus resultados superaram na maior parte das vezes a tradicional técnica Shuffle.
Alem disso, o fato da técnica Slice apresentar uma maior flexibilidade para implementações paralelas certamente contribuirá para o seu reconhecimento nesta área de pesquisa.
Ainda como resultados adicionais deste estudo, surgem ao menos cinco possibilidades de trabalhos futuros.
Considerando que a analise realizada neste estudo teve como foco principal o número de multiplicações em ponto-flutuante rlecessárias para os calculos e não a forma com que o algoritmo foi implementado, pode- se imaginar como um trabalho futuro uma analise algorítmica desta técnica, visando melhorar sua implementação.
Seguindo a otimização realizada neste trabalho para a geração dos fatores, poderia- se estudar no futuro uma forma de estender esta otimização para modelos com taxas funcionais, uma vez que neste estudo esta foi limitada a modelos com taxas exclusivamente constantes.
Ainda, um estudo profundo para descobrir a melhor ordem das matrizes dos termos do calculo poderia contribuir muito para o desempenho da técnica Slice, como visto na análise de resultados práticos apresentados neste trabalho.
Alem disso, um outro trabalho futuro poderia estudar e propor um algoritmo híbrido, o qual utilizaria de forma eficiente as técnicas Shufle e Slice para cada termo do cálculo da resolução do modelo SAN, levando- se em consideração as melhores situações para cada técnica.
Por fim, ainda seria muito interessante a implementação de uma versão paralela do algoritmo da técnica Slice, pois dessa forma certamente seria possível resolver sistemas com maiores espaços de estados.
Enfim, pode- se afirmar que este trabalho contribuiu muito para a evolução da técnica Slice e conseqüentemente para a área de avaliação de desempenho de sistemas.
Pois, a partir de agora sera possível resolver inúmeros sistemas com esta técnica e assim seguir os estudos para quem sabe um dia a técnica Slice tornar- se a nova referência mundial para resolução de modelos SAN.
