A crescente demanda por a redução do time- to-- market para SoCs (System-on-chip) leva a mudanças essenciais na maneira como esses sistemas são concebidos.
Um dos componentes críticos em qualquer SoC é a arquitetura interna de comunicação entre módulos do sistema.
Tradicionalmente, estas são implementadas como arquiteturas de comunicação baseadas em barramentos.
Contudo, a medida que a complexidade de SoCs cresce com a evolução tecnológica, barramentos apresentam crescentes limitações com relação a escalabilidade, consumo de potência e paralelismo.
Devido a estas limitações, estruturas do tipo redes intrachip ou NoCs (Networks-on-Chip) têm ganho crescente destaque como forma de permitir superar as limitações derivadas do uso de barramentos em SoCs.
Tais redes ampliam o espaço de soluções de projeto de estruturas de comunicação intrachip e trazem como vantagem largura de banda escalável de forma mais sistemática, o uso de conexões ponto a ponto curtas com menor dissipação de potência e a capacidade de facilmente definir o grau de paralelismo da comunicação.
O processo de projeto de NoCs tem sido alvo de esforços da indústria e do meio acadêmico e este trabalho contribui com a avaliação de um processo de projeto que está retomando força com ferramentas comerciais, a síntese comportamental.
O processo de projeto avaliado aqui, especificamente aquele ao qual dá suporte o ambiente Cynthesizer da Forte Design Systems, não foi concebido para dar suporte ao projeto de arquiteturas de comunicação intrachip e não possui associados arcabouços de projeto para tal tarefa.
No entanto, a facilidade de modelagem dessas estruturas mostrou- se atraente para realizar tal avaliação.
Para tanto, foram escolhidos estudos de caso de NoCs com topologia toro 2D bidirecionais, pouco exploradas na literatura.
Como contribuições deste trabalho cita- se a avaliação da síntese comportamental para o projeto de NoCs e a adaptação de algoritmos livres de (deadlocks) da literatura.
Tais algoritmos foram propostos para redes de topologia malha e para toro unidirecional, e neste trabalho realizaram- se adaptações para uso destes em redes toro bidirecionais.
Como resultado da avaliação, conclui- se que o estado da arte da síntese comportamental ainda precisa avançar e incluir processos para a geração e otimização de arquiteturas de comunicação intrachip.
Os resultados obtidos são significativamente inferiores àqueles derivados de codificação direta no estilo RTL em termos de área e velocidade, mesmo depois de aplicado esforços significativos de otimização de código e exploração do espaço de projeto.
Este trabalho demonstrou, contudo um fator positivo da síntese comportamental, qual seja a facilidade de modelagem e avaliação de algoritmos de roteamento.
Palavras-chave: Redes Intrachip, Síntese Comportamental, NoCs, SoCs, FPGA, Fluxos de Projeto.
Um System-on-chip, ou SoC, incorpora um sistema complexo inteiro num único circuito integrado (Ci), podendo conter processadores, memórias, controladores de periféricos e outros elementos de processamento.
A crescente complexidade desses sistemas e a demanda por a redução do tempo de chegada de produtos ao mercado (em inglês, time- to-- market) leva a mudanças essenciais na maneira como esses sistemas são projetados.
Uma das estruturas críticas em qualquer SoC é a arquitetura interna de comunicação entre módulos do sistema.
Tradicionalmente implementadas como arquiteturas de comunicação baseadas em interconexão multiponto como provido por barramentos, estas arquiteturas estão se transformando.
Por força de a necessidade de melhor escalabilidade destas estruturas, arquiteturas mais elaboradas estão surgindo, frequentemente denominadas de redes intrachip (em inglês, Network-on-Chip -- NoC).
Os esquemas de comunicação com barramentos têm um baixo custo de implementação, já possuem uma longa história em reuso de componentes e em geral têm um bom desempenho em termos de consumo de potência e latência para conectar poucos módulos.
Porém, tal organização tem um custo proibitivo com o aumento da quantidade de módulos a interconectar, o que acarreta aumento da latência de comunicação, aumento da dissipação de potência, em virtude de o aumento do tamanho dos fios, e o aumento da complexidade da arbitragem de controle da comunicação.
De essa forma, estruturas do tipo redes intrachip ou NoCs ganham destaque como forma de aumentar a escalabilidade de comunicação em SoCs complexos.
Uma rede intrachip pode ser definida como um conjunto de roteadores e canais ponto-a-ponto que interconectam os núcleos de um SoC de modo a suportar a comunicação entre esses núcleos.
Tais redes ampliam o espaço de soluções de projeto de estruturas de comunicação e trazem como vantagem a largura de banda escalável, o uso de conexões ponto-a-ponto curtas, com menor dissipação de potência, e o paralelismo na comunicação.
Porém, tal expansão do espaço de projeto tem custo:
É necessária a elaboração de métodos de projeto e construção de redes intrachip, um foco atual na área acadêmica e na indústria.
Diversos arcabouços são apresentados na literatura para dar suporte ao projeto de estruturas de comunicação intrachip incluindo NetChip, OCCN, Xpipes Compiler, SUNMAP, Atlas, etc..
Em sua maioria, as soluções apresentadas baseiam- se no uso de codificação RTL que pode ser sintetizada para topologias específicas de estruturas de comunicação ou em modelagem em alto nível não sintetizável, utilizada para validação de estruturas de comunicação através de simulação apenas.
Em esta última, não há um fluxo de projeto contínuo desde a modelagem em alto nível até a descrição sintetizável verificada.
Quando se necessita avaliar uma proposta de modelo de estrutura de comunicação intrachip, o projetista recorre de ferra-mentas que permitam descrever tal projeto em alto nível para realizar o trabalho de validação de forma mais rápida.
Depois de validado, o modelo proposto precisa ser transcrito corretamente para uma arquitetura sintetizável, e validado com ferramentas adequadas.
Em busca de uma solução diferente para o projeto estruturas de comunicação intrachip do que é explorado na literatura, a síntese comportamental oferecida por ferramentas comerciais já disponíveis é avaliada neste trabalho como alternativa para o projeto de estruturas de comunicação do tipo redes intrachip.
A utilização de síntese comportamental na implementação de redes intrachip permite que esses sistemas possam ser modelados e validados numa linguagem de alto nível, como SystemC, e posteriormente traduzidos automaticamente para descrições sintetizáveis por ferramentas comerciais.
Isso viabiliza modelar sistemas de comunicação intrachip bastante complexos de uma maneira mais intuitiva e em menor tempo com um fluxo de projeto contínuo desde a modelagem até o ASIC ou FPGA.
Porém, tal tipo de síntese não foi definida especificamente para o projeto de estruturas de comunicação intrachip, que essencialmente têm pouca lógica de processamento e muita troca de sinais de controle, ocasionando a geração de hardware menos eficiente para garantir a sincronização perfeita do sistema e não comprometer seu funcionamento.
Em este trabalho, o processo de síntese comportamental oferecido por a ferramenta Cynthesizer, da Forte Design Systems, é avaliado especificamente para o projeto de redes intrachip.
Foram escolhidos estudos de caso com complexidade suficiente para avaliar o processo de modelagem e validação disponibilizados por a ferramenta.
Os estudos de caso contemplaram redes com topologia toro 2D bidirecional e algoritmos de roteamento adaptados da literatura, com e sem utilização de canais virtuais.
A adaptação dos algoritmos, que foram inicialmente desenvolvidos para redes de topologia malha ou para topologia toro unidirecional, demandou um esforço considerável de avaliação para comprovar a ausência de deadlocks antes da implementação e validação através de síntese comportamental.
Todo o processo de modelagem, incluindo o estilo de codificação em SystemC aceito por a ferramenta, e o processo de validação foi estudado e aplicado nos estudos de caso.
Foi explorada durante o projeto a integração com outras ferramentas de síntese RTL, lógica e física e simuladores.
Como motivação para o desenvolvimento deste trabalho, está a constante evolução do estado de arte em projetos de CIs de larga escala.
Tal cenário de evolução aponta cada vez mais para a inviabilidade do uso de estruturas de comunicação intrachip do tipo barramento em SoCs complexos, motivando assim o esforço na pesquisa de NoCs.
Essas redes trazem junto com o aumento do espaço de soluções de projeto dessas estruturas de comunicação, um grau de complexidade de projeto bastante acentuado.
Essa complexidade está associada a carência de métodos de desenvolvimento práticos e com resultados realmente eficientes.
O custo da complexidade do projeto desse tipo de infraestrutura de comunicação influência diretamente o custo da produção de SoCs.
As pressões e necessidades de mercado têm influência na crescente complexidade desses SoCs e na redução do tempo de chegada desses componentes ao seu público consumidor.
Assim, o processo de concepção desses sistemas necessita ser rápido e oferecer resultados satisfatórios em termos de custo-benefício.
Isso indica cada vez mais mudanças na maneira como esses sistemas são projetados.
Uma das conseqüências dessa mudança de concepção é que o uso de descrições RTL na captura inicial da descrição formal do sistema poderá se tornar inviável, mostrando a necessidade de elevar o nível de abstração de descrições iniciais executáveis do sistema.
O principal objetivo deste trabalho é dominar o processo de modelagem e validação de projeto oferecido por a síntese comportamental e utilizar- lo para desenvolver estruturas de comunicação intrachip.
Para tanto, os seguintes objetivos específicos são determinantes:·
Dominar o fluxo de projeto da ferramenta Cynthesizer e sua interação com fluxos de ferramentas de síntese RTL para ASIC e FPGA e todo o processo de simulação e validação.·
Avaliar a sobrecarga causada por o uso de ferramentas de síntese comportamental na descrição de arquiteturas de comunicação, quando comparado com a codificação direta em· Dominar o estilo de descrição comportamental em SystemC aceito por a ferramenta e a utilização de diretivas de síntese para explorar espaço de projeto de descrições de NoCs.·
Desenvolver estudos de caso complexos o suficiente para avaliar o processo.·
Avaliar os resultados obtidos nas diversas fases do projeto para cada estudo de caso.·
Avaliar a factibiliade da utilização de tal síntese para o projeto de estruturas de comunicação intrachip.
Como contribuições principais deste trabalho estão uma avaliação específica da síntese comportamental oferecida por a ferramenta Cynthesizer para o projeto de redes intrachip e a adap-tação e avaliação de algoritmos da literatura desenvolvidos para redes de topologia toro 2D unidirecional e topologia malha para a rede toro 2D bidirecional.
Também como contribuição deste trabalho está um método para utilização da ferramenta Atlas como auxiliar no processo de avaliação da modelagem comportamental de estruturas de comunicação intrachip.
O restante do documento está organizado como segue.
O Capítulo 2 traz uma revisão de literatura sobre a síntese comportamental.
O Capítulo 3 apresenta a ferramenta de síntese comportamental utilizada neste trabalho o ambiente Cynthesizer.
O Capítulo 4 discute as principais diferenças de estilo entre codificações RTL e comportamental.
O Capítulo 5 apresenta arcabouços de projeto em alto nível para modelar estruturas de comunicação intrachip e apresenta o estilo de modelagem adotada neste trabalho.
O Capítulo 6 traz a revisão dos algoritmos de roteamento para redes com topologia toro.
O Capítulo 7 apresenta um dos estudos de caso do trabalho com rede de topologia toro 2D bidirecional sem canais virtuais e algoritmo adaptado da literatura revisada.
O Capítulo 8 apresenta a modelagem e validação de uma rede de topologia toro 2D bidirecional com a utilização de canais virtuais e algoritmo adaptado da literatura revisada.
Por fim, o Capítulo 9 apresenta conclusões e uma proposta de trabalhos futuros.
Segundo Gajski et al.
Em, a atividade de síntese é todo processo automatizado que refina a descrição abstrata do circuito em termos de primitivas mais próximas da sua realização física.
O processo de síntese pode ser aplicado a diferentes descrições de projeto em diversos níveis de abstração, podendo ser classificado justamente por tais critérios.
Antes de diferenciar os tipos de síntese é preciso definir os níveis de abstração sobre os quais se trabalha, tais como:
Em o nível RTL, são especificados os elementos estruturais do sistema, bem como as máquinas de estado que controlam sua funcionalidade a cada ciclo do relógio.
A descrição possui informações de temporização e o tempo é dividido em intervalos chamados passos de controle.
Em o nível físico a descrição contém uma lista com todas as células físicas do sistema.
A Síntese RTL parte de um conjunto pré-determinado de estados e um conjunto de transferências entre os registradores e gera a estrutura correspondente em duas partes:
Caminho de dados (do inglês, datapath) e unidade de controle.
O datapath é a estrutura contendo todos os elementos de armazenamento de informações e unidades funcionais que transferem e/ ou transformam dados entre registradores.
A unidade de controle dirige a sucessão dos estados durante a operação do sistema.
A Síntese Comportamental transforma uma descrição comportamental numa representação arquitetural.
Ela parte de um conjunto de processos que se comunicam através de mensagens ou variáveis compartilhadas, e gera a estrutura do sistema com componentes de uma biblioteca previamente caracterizada, que se adaptam a funcionalidade desejada.
Esta Seção introduz a comparação entre fluxos de projeto e síntese RTL e Comportamental apresentado por Lee em.
Para tanto, é necessário definir o que é espaço de soluções de um projeto.
Esse conceito refere- se ao conjunto de diferentes organizações que podem implementar uma determinada arquitetura.
Tanto na síntese RTL como na Comportamental é possível explorar esse espaço, porém de maneira diferente em cada uma.
A síntese RTL automatizada tradicional inicia com uma descrição arquitetural em a qual o escalonamento e alocação já estão determinados por o projetista, que gera a descrição de entrada.
Se algum dos requisitos de projeto não for atendido por essa descrição após a síntese, a maneira de atender- lo é, tipicamente, modificar a arquitetura RTL.
De esse modo, o projetista deve modificar manualmente o escalonamento e a alocação para explorar o espaço de soluções de projeto.
Para projetos muito complexos, isto acaba tornando- se um gargalo no desenvolvimento.
A Figura 1 ilustra o fluxo de síntese RTL tradicional.
Em a Figura, as elipses, os quadrados e os losangos representam respectivamente, ações, repositórios e decisões.
Os processos manuais são marcados com M e os automatizados com A. Em a síntese RTL, a descrição RTL pode ser verificada, por exemplo, através de simulação.
Ela pode ser sintetizada quando atender os requisitos de projeto.
A síntese RTL é automatizada por ferramentas capazes de associar a tecnologia alvo do projeto, utilizar critérios/ diretivas de otimização e restrições à síntese e disponibilizar estimativas antecipadas de resultados.
A síntese associa os componentes arquiteturais da descrição aos disponibilizados por bibliotecas de tecnologia respeitando a temporização definida na descrição inicial.
Assim, é obtido um netlist que contém a descrição da arquitetura em termos de as primitivas físicas da tecnologia alvo do projeto.
Em o processo de síntese comportamental, a funcionalidade do circuito é especificada de forma algorítmica, a chamada descrição comportamental.
Em este tipo de descrição não é definido o comportamento do circuito a cada ciclo de relógio nem os recursos necessários para executar o algoritmo.
A síntese de alto nível transforma a descrição comportamental numa micro-arquitetura, em a qual, após fixado o comportamento em ciclos de relógio, podem ser satisfeitas as restrições de área, desempenho e potência.
A síntese comportamental pode facilitar a exploração do espaço de soluções de projeto, caso um conjunto de arquiteturas RTL possa ser derivado automaticamente a partir de uma descrição do comportamento do circuito.
A Figura 2 mostra um fluxo de síntese comportamental, salientando como este gera automaticamente um conjunto de micro-arquiteturas RTL.
Em a Figura, as elipses, os quadrados e os losangos representam, respectivamente, ações, repositórios e decisões.
Os processos manuais são marcados com M e os automatizados com A. Em esse fluxo, após a descrição inicial ser validada segundo os critérios funcionais do projeto, pode- se executar a síntese comportamental.
Essa deve ser capaz de associar diretivas para a exploração de espaço de projeto e a tecnologia alvo de forma automatizada.
Como resultado é obtido um conjunto de micro-arquiteturas.
A ferramenta que automatiza esse processo deve ser capaz de gerar estimativas inciais sobre o atendimento dos requisitos de projeto.
Essa estimativa auxilia na escolha da micro-arquitetura que melhor satisfaz os requisitos.
Com o resultado obtido, é possível realizar em seguida o processo de síntese RTL automatizada tradicional.
Lee, em, apresenta um fluxo de atividades para realização de síntese Comportamental, para ferramentas que automatizam esse processo de síntese.
A entrada desse processo é uma descrição do comportamento do circuito.
Esse comportamento pode ser especificado numa linguagem de descrição de hardware de alto nível.
Em uma especificação comportamental um bloco básico é definido como uma seqüência de atribuições que não contém testes nem desvios, exceto o teste de condição de parada.
De esta descrição podese derivar um grafo de fluxo de dados (em inglês, data flow graph ou DFG) do bloco básico, onde cada vértice está associado a uma operação e cada aresta a uma variável.
As dependências de dados estão implícitas nas direções das arestas do grafo.
VI VO VM, e Oj associado a cada, 1 j n, é uma operação com vj como operando e vj+ 1 como resultado.
Ainda, se v1 e v2 representam o mesmo vértice, o DFG é cíclico e v1 ou v2 são chamadas variáveis limitadas.
Um DFG cíclico é inferido de construções de linguagem Para cada operação O associada com um nó num DFG, O. Earliest denota o ciclo mais cedo em que a operação pode executar e O. Latest denota o ciclo mais tardio em que a operação pode executar sem violar a dependência de dados expressa no DFG.
A folga (do inglês, slack) de O é definida por o intervalo, e a mobilidade de O é definida como O. Latest -- O. Earliest.
A seqüência de operações com mobilidade igual a zero é chamada caminho crítico.
Folgas em mobilidade podem ser utilizadas para indicar a liberdade de escalonamento para uma operação.
A tarefa de escalonamento atribui um tempo de execução, ou passo de controle, para cada operação da especificação comportamental.
O DFG obtido após o escalonamento é chamado DFG Escalonado (em inglês scheduled data flow graph ou SDFG).
Segundo Lee, os algoritmos de escalonamento podem ser classificados como de transformação ou iterativos/ construtivos.
Os escalonamentos com transformação partem de uma solução inicial e tentam realizar transformações, preservando o comportamento, para obter uma melhoria da estrutura inicial.
A abordagem iterativa/ construtiva escalona a operações de forma construtiva a partir de a junção de componentes um a um.
Algoritmos que partem dessa abordagem são o escalonamento assoon-as-- possible (ASAP), as- late- as- possible (ALAP), escalonamento do caminho crítico, etc..
ASAP e ALAP são tipos simples de algoritmos construtivos.
Para cada operação O do DFG, o algoritmo ASAP escalona para o ciclo corrente O. Earliest, enquanto ALAP escalona O. Latest.
Esses algoritmos são mais rápidos, porém não consideram o caminho crítico e alocam mais recursos do que os necessários.
O algoritmo de escalonamento do caminho crítico escalona primeiramente as operações do caminho crítico do DFG.
As operações restantes são escalonadas de acordo com sua mobilidade.
Dado um SDFG, a tarefa de alocação de recursos atribui elementos de hardware para realizar operações e produzir uma micro-arquitetura RTL.
Para definir formalmente a tarefa de alocação de recursos é preciso definir o conceito de tempo de vida de uma variável.
Segundo Lee, num SDFG acíclico, o instante de nascimento de uma variável v, denotado por v..
Birth é o ciclo em que ela é definida;
O instante de morte de v, denotado por v..
Death, é o último ciclo em que a variável é utilizada.
O tempo de vida de v é definido por o intervalo.
Similarmente, a alocação de módulos de processamento, denotada por M, pode ser considerada operações oi e oj em Mk, 1 k m, não tenham tempos de execução conflitantes.
A partir de um SDFG é derivado um grafo não dirigido, chamado grafo de alocação de módulos (em inglês, module allocation graph ou MAG), em que cada nodo corresponde a uma operação do SDFG e cada aresta corresponde à capacidade de compartilhamento de um mesmo módulo entre dois nodos conectados.
O grau de capacidade de compartilhamento pode ser diferenciado atribuindo pesos às arestas.
A Figura 3 apresenta um SDFG e o MAG com pesos correspondentes, supondo que dois somadores sejam reservados, e que o peso de compartilhamento entre+ a e+ b é 1 e entre+ a e+ c, 3.
Como o peso entre+ a e+ c é maior que aquele entre+ a e+ b, um somador será compartilhado entre+ a e+ c e outro(+ b) será dedicado.
A alocação de interconexões associa fios a sinais de vai- um e variáveis entre registradores e módulos.
Dois sinais podem ser associados para o mesmo fio, desde que seus tempos de vida não se sobreponham.
A Figura 4 (a) mostra um exemplo de especificação comportamental, onde cada variável representa um nome de sinal e cada operação representa uma computação que será realizada.
A Figura 4 (b) apresenta um DFG que pode ser derivado da especificação inicial.
A Figura 4 (c) apresenta uma possibilidade de arquitetura para o comportamento descrito no algoritmo inicial.
Em essa arquitetura, três registradores são alocados por a síntese de alto nível para armazenar os valores das variáveis:
R1 para a e d, R2 para b e R3 para c e k.
Um multiplicador e um somador são mapeados para realizar as operações especificadas.
O tempo de execução de cada operação também é escalonado por a síntese de alto nível.
Em o primeiro ciclo, O multiplicador gera o produto em R1 a partir de os operandos de R1 e R2 (a e b).
Em o segundo ciclo, o somador adiciona os operandos de R1 e R3 (c e d) e armazena o produto k em R3.
Segundo de Ku e de Micheli, pontos de sincronização são os pontos do tempo onde ocorre interação do sistema com o ambiente em o qual ele está inserido.
Em sistemas digitais síncronos a diferença essencial entre os níveis de abstração são os pontos de sincronização utilizados.
A Tabela 1, retirada de, apresenta os diversos pontos de sincronização utilizados em diferentes níveis de abstração.
Em o nível Sistema, processos são sincronizados através de trocas de mensagens.
Processos podem ser representados no nível Algorítmico por grafos de dados/ controle, sincronizados por eventos de entrada e saída (E/ S).
Em o nível Algorítmico, o grafo de fluxo de dados/ controle pode ser representado utilizando máquinas de estados finitas com datapath (FSMD).
Em o nível RTL, transferências de dados são realizadas dentro de os limites de cada ciclo de relógio e o modelo de entrada contempla as FSMs (Máquinas de Estados Finita, do inglês Finit State Machines), BDD (Diagrama de Decisão Binária, do inglês Binary Decision Diagram) e as Equações Booloeanas.
Em o nível Físico, as mudanças de valores nos fios definem a sincronização.
A Tabela 2, retirada de[ 7], mostra o escopo das tarefas realizadas por as sínteses comportamental e RTL e os modelos de entrada associados a cada tarefa.
Pode- se observar que existe uma sobreposição de funcionalidades entre a síntese comportamental e RTL.
O modelo de entrada da síntese RTL e a arquitetura produzida têm em comum a sincronização dentro de os limites dos ciclos de relógio, isto é, são precisas em nível de ciclo.
Em a síntese comportamental essa precisão somente é obtida após a tarefa de escalonamento.
A síntese comportamental traz um conjunto potencial de vantagens tais como o encurtamento do ciclo de desenvolvimento do projeto, antecipação das estimativas de desempenho, maior facilidade de reuso, independência de tecnologia, melhor relação dos compromissos assumidos com relação a área, tempo, potência e desempenho.
Contudo, conforme, existem alguns problemas ainda hoje que dificultam que esse tipo de síntese seja utilizado por a indústria, incluindo:
O resultado da síntese é difícil de entender, o modelo de entrada não é prático e é difícil integrar síntese comportamental nos fluxos de projeto existentes.
Além de isto, e em muitos casos, ferramentas RTL têm um resultado nitidamente melhor.
A referência apresenta uma proposta de integração eficiente entre síntese comportamental e RTL.
Aquele trabalho introduz um fluxo de síntese comportamental, cujas principais características são:
A síntese é centrada na tarefa de escalonamento e sua saída é um código de alto nível preciso em nível de ciclo, que descreve uma FSM que pode ser explorada via síntese RTL;
O modelo comportamental de entrada é um subconjunto de VHDL que permite misturar protocolos precisos e modelos comportamentais puros numa mesma especificação.
O código RTL produzido é fácil de entender, alegam ainda os autores do trabalho.
O escalonamento proposto consiste dividir operações complexas do sistema em operações mais simples, para que estas fiquem confinadas num ciclo relógio.
O método de escalonamento usado parte de FSMs complexas em nível comportamental e produz um conjunto de FSMs precisas em nível de ciclo.
Dois passos são utilizados durante este processo.
O primeiro passo manipula os estados da FSM implícitos na descrição comportamental.
Isto se dá, principalmente, devido a a dependência de dados e laços que incluem ou não pontos de sincronização.
Para isso, o algoritmo de escalonamento dinâmico de laços é utilizado.
Esse algoritmo produz um novo modelo onde as transações são formadas por operações que podem ser executadas em paralelo num passo de controle.
Este passo assume que existe um período de relógio infinito e uma quantidade de recursos também infinita.
O segundo passo realiza uma retemporização (do inglês, retiming) em nível de sistema para assegurar que todas operações simples, que foram anteriormente extraídas de uma descrição complexa, possam ser executadas num único ciclo de relógio.
Assim, novos estados de FSM podem ser incluídos para garantir a execução correta das operações do sistema.
A descrição resultante da execução do escalonamento pode ser utilizada numa ferramenta de síntese RTL tradicional para as etapas de alocação e amarração de recursos.
A referência classifica três gerações distintas de ferramentas de síntese comportamental, a partir de a contribuição destas para o processo de síntese de alto nível e da evolução de seus algoritmos e técnicas de otimização.
A primeira geração de ferramentas foi desenvolvida principalmente por a comunidade de arquitetura de computadores e sua principal contribuição foi a definição precisa das tarefas de síntese.
A síntese baseada em descrições RTL ainda não era realidade na época.
O trabalho de maior destaque na época é o ambiente de projeto Mimola, baseado na linguagem Mimola (Machine Independent Microprogramming Language).
Sistema Mimola O ambiente de projeto Mimola(, foi concebido como uma ferramenta para o projeto de estruturas de hardware.
Esse ambiente compreende uma série de ferramentas para descrever, simular e sintetizar circuitos.
Ele contém um método de projeto para processadores digitais a partir de uma especificação de alto nível.
A característica chave deste método é a síntese de um processador a partir de os programas que constituem aplicações típicas.
Mimola dá atenção especial à predição de desempenho, paralelismo e flexibilidade.
A Figura 6 apresenta o diagrama do fluxo de projeto do ambiente.
Dada a descrição funcional das aplicações que serão executadas no processador projetado, é feita a alocação por substituição de elementos RT de funcionalidade equivalente às operações em alto nível (Figura 6 (b)).
A troca de elementos da descrição de alto nível por elementos equivalentes em RTL é definida por regras de substituição.
Essas regras são armazenadas numa biblioteca.
A partir de o momento em que se obtém uma descrição com elementos RT (Figura 6 (c)) é possível realizar uma simulação para verificar se o programa resultante está correto (Figura 6 (d)).
A detecção das funcionalidades que possam ser executadas em paralelo é diagnosticada após esse ponto do processo e tudo é agrupado em blocos paralelos (Figura 6 (e)).
Essa transformação é realizada com base na avaliação do fluxo de controle e das dependências de dados.
Após o mapeamento para RTL e a detecção de paralelismos, é realizada a atividade de síntese (Figura 6 (f)).
Em essa fase, é gerada uma descrição de hardware para um processador e são computados os seguintes parâmetros arquiteturais:
Número de portas de entrada e saída, já que o procedimento de síntese computa o número máximo de operações de leitura e escrita num bloco para criar os registradores das portas;
Número de funções, que são criadas quando a execução paralela de todas as funções dentro de cada bloco é possível;
Caminhos (fios), o número necessário de caminhos é computado;
E formato das instruções, onde assume- se que as unidades de hardware são controladas diretamente por um campo da instrução.
O processo de geração de diagnósticos (Figura 6 (h)) é responsável por a geração automática de alguns tipos de teste, como para detecção de erros do tipo stuck-at.
Se não for possível gerar automaticamente teste para alguma estrutura do sistema, esta deve ser modificada manualmente antes de continuar o processo do projeto.
Para permitir a estimativa de desempenho e geração de código para o hardware projetado, os programas de aplicação são vinculados aos recursos de hardware.
Isso é feito por um alocador (Figura 6 (g)).
Esse alocador é composto por dois componentes.
O primeiro tenta encontrar conjuntos de funções que podem ser mapeadas para os operadores e portas de memória de operações de leitura e escrita.
O segundo seleciona o conjunto que proporciona o tempo mínimo de execução.
Após essa fase, são obtidos a descrição do hardware e o microprograma (Figura 6), e é possível realizar uma nova simulação para validar o funcionamento do sistema gerado (Figura 6 (j)).
A segunda geração de ferramentas se caracterizou por a escolha de domínios de aplicação restritos e a geração de arquiteturas com bloco de controle e datapath.
Essas ferramentas se concentravam em poucas tarefas de síntese e eram baseadas em geração de máquinas de estados RTL e mapeamento tecnológico.
Muitas ferramentas foram desenvolvidas nessa fase para uma variedade de aplicações:
DSP, controladores embarcados, circuitos de comunicação, etc..
O principal inconveniente dessas ferramentas é a dificuldade de gerar eficientemente a descrição RTL, principalmente devido a a falta de processos que fossem capazes de fazer otimizações durante o fluxo de síntese.
O principal ambiente de projeto concebido nessa época foi o System Architect's Workbench, que engloba uma série de ferramentas para converter uma descrição algorítmica num conjunto de componentes em nível RTL, cujo controle é especificado por uma tabela de transição de estados.
Em este ambiente de síntese de alto nível foi introduzida a fase de Particionamento Arquitetural, que é uma fase do projeto em nível de sistema que determina o número de blocos que serão usados para implementar o projeto e o subconjunto do comportamento que será implementado em cada um de eles.
Essa fase acontece antes que a síntese RTL inicie.
As características estruturais determinadas no particionamento podem ser utilizadas para conduzir as decisões de síntese de baixo nível.
O objetivo principal do particionamento arquitetural é descobrir a estrutura implícita na descrição de um comportamento, conforme ilustrado na Figura 7.
Determinar a estrutura correta tem um efeito positivo na área e no desempenho do projeto.
Boas partições podem reduzir o comprimento global dos fios através de agrupamentos de partes da arquitetura que se comunicam muito.
Assim, são reduzidas as interconexões necessárias para implementar dependências de dados entre as partições.
A clusterização é utilizada para agrupar operadores em grupos significativos para síntese, ou seja, em grupos cuja funcionalidade pode ser combinada numa unidade de hardware.
O algoritmo de clusterização comum considera um conjunto de objetos e os agrupa acordo com algum critério de aproximação.
A Figura 8 mostra os objetos que são agrupados de acordo com suas medidas de proximidade.
A e B são clusterizados primeiro e considerados como um único objeto.
Já a clusterização em múltiplos estágios é uma variação desse algoritmo.
Múltiplos estágios facilitam a implementação e o desempenho da clusterização.
Em o algoritmo de clusterização multiestágio ocorrem vários passos seqüenciais de clusterização, cada um tendo seu próprio critério de aproximação.
Cada um desses passos é construído com os resultados do passo anterior.
Em cada um de eles é criada uma árvore de clusters.
A partir de isso, uma linha de corte é escolhida em algum nível dessa árvore e cada sub-árvore abaixo de a linha torna- se um elemento que será considerado para a clusterização no próximo estágio.
Após a construção da árvore completa é escolhida a melhor linha de corte para a clusterização final.
Em o trabalho de Bergamaschi, descrito em, é apresentada uma abordagem alternativa para integrar as sínteses comportamental e RTL no mesmo fluxo de projeto.
A síntese RTL é utilizada para executar parte das tarefas que seriam realizadas por a síntese comportamental e este modelo é chamado Behavioral Network Graph (BNG).
Em a maioria das metodologias, a rede RTL gerada por o processo de síntese de alto nível (em inglês High Level Synthesis ou HLS) é submetida à síntese lógica para otimização em nível de portas, que tenta satisfazer certas restrições de área e atrasos.
A qualidade do resultado obtido depende da qualidade das duas sínteses utilizadas.
Para produzir uma rede RTL eficiente, a síntese de alto nível deve estimar o efeito que cada decisão, tomada a partir de a descrição algorítmica, terá sobre a rede de portas resultante.
Este efeito é traduzido em estimativas de latência de operação, área ocupada ou potência consumida.
Porém, alguns algoritmos ignoram aspectos importantes, como o tamanho e o atraso do bloco de controle, multiplexadores e registradores.
Segundo Bergamaschi, o principal problema para computar estes custos com precisão é que o modelo interno em que a síntese de alto nível opera é demasiado distinto da rede RTL final.
Em a maioria dos sistemas descritos em alto nível, os modelos internos são os grafos de controle e dados.
Um CDFG representa uma especificação de um projeto de uma maneira muito diferente de uma implementação de hardware.
Embora um CDFG contenha arestas e nós que representam valores e operadores (somadores, subtratores, etc.), geralmente ele não contém uma especificação explícita dos multiplexadores e lógica de controle necessários para a implementação do hardware.
Em o trabalho de, o BNG (em inglês, Behavioral Network Graph) é uma representação de uma rede RTL contendo descrições comportamentais não escalonadas.
Para tanto, é preciso de-terminar a rede RTL que pode representar todos os escalonamentos possíveis que uma descrição comportamental pode assumir.
Outra questão importante é que não se deve criar representações ambíguas de um comportamento.
A Figura 10 ilustra a metodologia proposta em.
O CDFG é utilizado como uma árvore de análise estendida, representando a mesma semântica que uma linguagem de descrição de hardware.
Além de otimizações do compilador, o CDFG pode ser submetido a transformações específicas, como extração de paralelismos e desdobramento de laços.
O próximo passo é o mapeamento do CDFG numa representação BNG.
As tarefas de escalonamento, alocação e compartilhamento de recursos são realizadas sobre o BNG.
Pode- se também realizar transformações lógicas e análise de temporização para avaliar com maior precisão os custos envolvidos durante a síntese de alto nível.
Após essas tarefas, o BNG representa a rede RTL final.
O método proposto por Dougherty e Thomas unifica síntese comportamental e projeto físico, permitindo escalonamento, alocação, vinculação e posicionamento simultâneos.
Isto ocorre através de um conjunto de transformações definidas em ambos domínios e levando a um sistema comportamental/ físico.
Segundo, as ferramentas de síntese comportamental não são bem aceitas devido a a baixa qualidade de seus resultados.
O grande problema é que essas ferramentas têm pouca ou nenhuma base em projeto físico.
Assim, alguns componentes do projeto são desenvolvidos com baixa qualidade desde o início do processo.
A proposta desenvolvida no trabalho citado tenta unificar projeto físico e síntese comportamental.
Assim, decisões comportamentais e transformações são representadas como forças agindo em objetos do modelo comportamental (DFG).
De o mesmo modo, transformações no projeto físico são representadas por forças agindo nos objetos posicionáveis.
Em esta metodologia, os objetos do modelo comportamental e os objetos posicionáveis do modelo físico são considerados como sendo o mesmo objeto.
Esta formulação permite que decisões comportamentais e físicas sejam tomadas simultaneamente.
O método parte de uma descrição HDL em alto nível.
Este código é compilado para uma representação DFG.
O DFG é modificado, seguindo o grafo da rede comportamental e permi- tindo escalonamento e alocação simultâneos.
A seguir, as operações são fisicamente dispostas no chip.
Junto com a disposição, este processo combina operações sem o conhecimento do escalonador.
Conforme esses eventos vão ocorrendo, restrições são geradas para assegurar que o resultado final seja um escalonamento válido.
Após isso, todas as operações são vinculadas a unidades funcionais.
Em esta fase ainda não se tem informações sobre o hardware e o escalonamento.
Baseado na fase de posicionamento, uma árvore parcial é construída para o projeto e utilizada para produzir uma série de escalonamentos e alocações que vão construindo simultaneamente o projeto físico.
O processo de síntese com ferramentas modernas combina a automação com restrições específicas de alto nível, para que o projetista possa controlar a implementação do hardware e fazer com que seu projeto atinja uma qualidade significativamente melhor em menos tempo.
As otimizações realizadas por as ferramentas associadas são oriundas da evolução dos algoritmos e técnicas desenvolvidas nas ferramentas das gerações anteriores.
Entre os métodos e algoritmos que são utilizados nessas ferramentas está a técnica de clusterização comportamental.
Esta técnica é utilizada para aperfeiçoar desempenho, área e consumo de potência em projetos DSP (Digital Signal Processing).
O método de clusterização comportamental permite combinar e otimizar processos de tal maneira que a qualidade dos resultados (QoR) seja significativamente melhor do que quando esses mesmos processos são implementados separadamente.
Algoritmos de clusterização, como os vistos na Seção 7, servem para determinar o particionamento de um projeto entre chips, datapaths ou entre hardware e software.
Geralmente esses algoritmos têm como ponto de partida uma descrição comportamental monolítica e o objetivo de manter blocos que se intercomunicam juntos, ou próximos.
Contudo, aplicações do tipo DSP têm um ponto de partida diferente.
Geralmente, elas são especificadas como um conjunto de processos que se comunicam entre si.
Cada processo corresponde a um bloco DSP.
Em o processo tradicional de síntese RTL, cada bloco é implementado separadamente, em nível RTL, e depois combinados para formar o projeto completo.
Já no processo de síntese comportamental, a clusterização comportamental pode ser utilizada para combinar os processos em conjuntos semelhantes antes do processo de síntese.
A Figura 11 ilustra a clusterização comportamental em que os processos menores são agrupados em dois conjuntos.
O reuso é uma otimização em que alguma parte da computação é compartilhada por alguns processos, como multiplicadores, somadores e subtratores.
Essa transformação reduz a área total do circuito.
Assume- se que a técnica de clusterização comportamental tenta ir de encontro a os seguintes ojetivos, considerando que Pa e Pb processos;
PaU b denota o cluster formado por os dois processos;
Area (Pa) é a área presumida para o processo a Latency (Pa) é o tempo que o processo a leva para executar;
T hroughput (Pa) é a taxa de dados que o processo a produz ou consome:·
Aperfeiçoar área se Area (PaU b) Area (Pa)+ Area (Pb);·
Aperfeiçoar latência se Latency (PaU b) Latency (Pa)+ Latency (Pb);·
Aperfeiçoar throughput (PaU b) Area (Pa) e T hroughput (PaU b) Area (Pb).
Porém, existem três limitações principais quando processos são agrupados em clusters:
Distribuição do relógio, porque é preciso garantir que os processos de um mesmo cluster pertençam ao mesmo domínio de relógio;
Comunicação, porque o algoritmo tem maior impacto se todos os processos têm um grande volume de comunicação;
Escalabilidade, já que os blocos comportamentais englobam blocos maiores que o de uma síntese RTL.
Ferramentas disponíveis no mercado Em esta Seção são apresentadas resumidamente as ferramenta:
Catapult C da Mentor Graphics, Agility Compiler da Celoxica e Cynthesizer da Forte Design System.
A ferramenta Catapult C é a ferramenta comercializada por a Mentor Graphics para síntese comportamental a partir de uma descrição em C+ não temporizada para uma descrição RTL otimizada.
Essa ferramenta permite a exploração de múltiplas micro-arquiteturas e interfaces com uma qualidade superior a uma exploração manual.
O resultado é garantido por um fluxo que produz descrições RTL precisas a nível de ciclo de relógio ajustadas para uma tecnologia alvo.
A ferramenta não exige que as interfaces do projeto da descrição comportamental que o projetista escolha interfaces como FIFO, handshaking, single ou dual port..
A ferramenta permite o controle do projetista sobre o processo de síntese através de restrições que são inseridas na descrição inicial.
As restrições que podem ser aplicadas são:
Desdobramento de laços, pipeline, fusão de laços, mapeamento para RAM, ROM e FIFO, alocação de recursos e compartilhamento e utilização simplificada de recursos de memória.
A ferramenta permite que um testbench escrito em C+ possa ser reutilizado para verificar o RTL (Verilog ou VHDL) gerado por o processo de síntese.
Esse processo é automatizado através da geração dos wrappers e transatores que permitem a cossimulação de todo o projeto.
A ferramenta Agility Compiler, comercializada por a Celoxica, é um compilador para síntese comportamental que aceita como entrada descrições Tl (Transaction Level Modeling) em SystemC.
Essa ferramenta gera automaticamente código RTL otimizado para a síntese RTL Xilinx.
Essa ferramenta permite explorar algoritmos complexos e micro-arquiteturas nos passos iniciais do fluxo de projeto.
Permite também analisar o desempenho e fazer estimativas de temporização antes da prototipação ou verificação do ASIC fabricado.
A ferramenta Cynthesizer da Forte Design Systems transforma uma implementação comportamental SystemC numa descrição RTL Verilog ou SystemC.
Partindo de um modelo de alto nível sem temporização descrito em SystemC, essa ferramenta constrói micro-arquiteturas RTL temporizadas baseadas num conjunto de diretivas especificadas por o projetista.
Essas diretivas podem ser relacionadas à latência de operação, paralelismo temporal (pipeline), área, desenrolamento de laços, etc..
Essa ferramenta também disponibiliza um processo eficiente de verificação e simulação das micro-arquiteturas obtidas.
O mesmo testbench SystemC pode ser utilizado em todas as fases do projeto.
Comparação entre as Ferramentas Apresentadas Em esta Seção é apresentado um quadro contendo uma comparação inicial das ferramentas de síntese comportamental modernas comerciais.
O resumo desta comparação aparece na Tabela Esta Seção apresenta uma comparação entre as gerações de ferramentas de síntese comportamental conforme proposto em.
A Tabela 4 apresenta a contribuição de cada geração, as dificuldades de seu emprego e ferramentas representativas da geração.
Tabela 4 ­ Quadro comparativo de gerações de ferramentas de síntese comportamental.
3 Síntese Comportamental com a Ferramenta Cynthesizer A necessidade de um método prático que permita gerenciar de maneira eficiente projetos de sistemas digitais de grande complexidade num ciclo de desenvolvimento mais curto, faz com que a síntese em alto nível seja retomada como opção de processo de concepção de sistemas digitais.
Em este capítulo, será apresentada em detalhe a funcionalidade da ferramenta Cynthesizer da Forte Design Systems.
Essa ferramenta permite que o projeto de um sistema digital seja capturado em nível comportamental de maneira formal e refinado até atender restrições de desempenho e área.
O método proposto por o Cynthesizer habilita a exploração do espaço de soluções de projeto aliado à síntese de alto nível e verificação baseada na utilização da linguagem C+ e de SystemC.
A ferramenta Cynthesizer disponibiliza a automação do processo de transformação de algoritmos em alto nível em descrições RTL otimizadas incluindo síntese, verificação e simulação, permitindo investigar múltiplas implementações RTL.
Essa investigação é baseada no uso de diretivas sem a modificação da descrição original do projeto.
A ferramenta inclui:
Alocação de recursos, temporização, escalonamento de operações, particionamento de datapath e blocos de controle, implementação de máquinas de estados e tradução de SystemC para Verilog.
O ambiente do Cynthesizer contém ainda ferramentas de automação de geração para síntese para ASIC ou FPGA e simulação HDL.
A Figura 12 mostra onde a ferramenta pode ser encaixada num fluxo de projeto.
Primeiramente, é realizada uma etapa de projeto em nível de sistema, ESL (do inglês, Electronic System Level Design) em que são especificados os requisitos funcionais do sistema.
Isso é apoiado por a escolha de uma plataforma (ASIC ou FPGA) e por o particionamento das funcionalidades em hardware/ software.
Em a fase seguinte, de especificação, a plataforma é especificada em detalhes e as funcionalidades resultantes do particionamento anterior são descritas em especificações executáveis.
Em a fase de implementação, a especificação do software será refinada, otimizada e compilada sobre uma base de sistema operacional, tipicamente de tempo real (em inglês, Real Time Operating System ou RTOS).
A especificação de hardware será refinada, otimizada e sintetizada, obtendo- se, ao final do processo, a descrição física dessa partição.
Em a fase final, de validação, o sistema é integrado à plataforma e validado.
A ferramenta Cynthesizer é encaixada na fase de especificação e implementação da partição de hardware do sistema.
O digrama do fluxo da ferramenta mostra, simplificadamente:
A descrição inicial em SystemC do hardware do sistema, com sua respectiva simulação comportamental;
A geração da descrição RTL por a ferramenta com a utilização de uma biblioteca de tecnologia, que deve ter relação com a plataforma escolhida para o sistema, seja essa baseada em ASIC ou FPGA;
A simulação funcional do código RTL obtido, com o mesmo testbench utilizado na simulação comportamental;
A síntese lógica, com alguma ferramenta associada ao Cynthesizer (tal como o Synplify-Pro da Symplicity), do código RTL obtido, gerando um netlist de portas; (
v) simulação em nível de portas do netlist final com o mesmo testbench utilizado nas simulações anteriores.
O Cynthesizer é formado por dois componentes de software principais:
O mecanismo de síntese comportamental e um ambiente chamado Behavioral Design Workbench (BDW).
O mecanismo de síntese comportamental é realizado por duas ferramentas:
CynthHL, que faz a síntese da descrição comportamental C+/ SystemC numa descrição RTL C+;
E cynthVLG, que transforma o código RTL C+ em RTL Verilog.
O BDW possui ferramentas para automação e simulação HDL.
A Figura 13 apresenta a relação entre os componentes do Cynthesizer.
O BDW é responsável por comandar todo o processo.
O projetista precisa definir a especificação comportamental e suas diretivas de síntese, os arquivos de controle de simulação (testbenchs) e o arquivo de regras de projeto (project.
Tcl). O arquivo de regras de projeto será utilizado por o BDW para construir a caracterização da biblioteca de tecnologia e a sua associação na transcrição da especificação comportamental para RTL.
Essa transcrição é realizada por as ferramentas cynthHL e cynthVLG, que são coordenadas por o BDW com auxílio de compilador C+/ SystemC.
Esse ambiente automatiza a simulação de todas as descrições, integrando algum simulador (tal como o Modelsim da Mentor) quando necessário, e gerando os wrappers necessários para simulação do código Verilog RTL.
A simulação da descrição comportamental e a da descrição RTL SystemC gerada é realizada por o próprio ambiente.
O ambiente também faz a integração com ferramentas de síntese lógica disponíveis no mercado, para ASIC ou FPGA, disponibilizando também a simulação para os resultados desses processos de síntese.
A ferramenta disponibiliza também a geração de relatórios de todos os processos de síntese em páginas Html.
O ambiente Cynthesizer executa vários processos durante a síntese comportamental.
Primeiramente, é realizada uma compilação da descrição comportamental SystemC para garantir que nenhum erro de sintaxe existe no código fonte do projeto.
Após a compilação, a ferramenta realiza a análise do fluxo de dados do projeto.
Em esse passo determina- se como os dados de entrada serão conduzidos através das operações datapath para implementar a funcionalidade da descrição inicial.
Esta análise determina todos os operadores (de forma independente de tecnologia), multiplexadores e a lógica de controle necessários para a implementação do projeto.
A fase seguinte é a alocação, onde cada operador identificado no passo anterior é mapeado para um operador da biblioteca de tecnologia.
Em essa fase, são extraídas informações de temporização para cada operador da biblioteca.
Em a fase seguinte, de escalonamento, cada operador alocado na fase anterior recebe um ciclo de relógio específico onde será executado, baseado no fluxo do projeto e em seu atraso relativo.
Durante o escalonamento introduz- se paralelismo na execução e as diretivas definidas para latência e throughput são utilizadas para derivar o escalonamento final.
Todos os operadores alocados são mapeados para uma descrição RTL na fase de vinculação e a saída resultante é um código RTL, SystemC ou Verilog.
Simulação no Ambiente Cynthesizer A ferramenta disponibiliza uma metodologia para simulações, onde o mesmo testbench é utilizado para verificar a implementação comportamental e todas as implementações derivadas por a ferramenta, conforme apresentado na Figura 14.
As simulações podem ser feitas por o próprio ambiente, no caso de a verificação funcional da especificação comportamental, ou por ferramentas integradas como o Modelsim da Mentor, no caso verificação funcional do resultado derivado da Síntese Comportamental e da verificação com temporização dos resultados da Síntese Lógica para ASIC ou FPGA.
Para que o mesmo testbench possa ser aproveitado, é preciso que o projetista especifique protocolos de sincronização para cada sinal de interface.
A Figura 27 apresenta um exemplo de comunicação entre threads de uma descrição comportamental, com uma thread produzindo dados (Figura 27 (a)) e a outra consumindo (Figura 27 (b)).
Em (a), a thread informa que tem um dado através do sinal tx, assinalando- o com 1, disponibiliza o dado no sinal data e espera enquanto o sinal ack_ tx, escrito por a thread consumidora, é igual a 0.
Quando ack_ tx for igual a 1 a thread produtora assinala tx com 0.
Em (b), a thread consumidora espera enquanto tx é igual a 0.
Quando tx passa a ser 1 o dado do sinal data é consumido e o sinal ack_ tx é mantido por um ciclo no valor 1 para concluir a sincronização.
Figura 15 ­ Exemplo de interface de comunicação entre duas threads: (
a) produzindo dados; (
b) consumindo dados.
Esses arquivos se relacionam conforme apresentado na Figura 16.
O módulo de projeto, seu testbench e todos os sinais de interface entre eles são instanciados nos arquivos de sistema (system.
Cc e system.
H). O sistema como um todo é instanciado no arquivo main.
Cc. Todos eles são descritos em SystemC/ C+.
Os arquivos de regras de projeto e diretivas são scripts declarativos escritos em TCL.
Em o arquivo project.
Tcl são especificados os arquivos do projeto, a tecnologia alvo, os arquivos de diretivas de síntese, as configurações da simulação e da síntese, etc..
Em o arquivo de diretivas, estão as definições de síntese utilizadas em cada uma das configurações de exploração de espaço de projeto aceitas por a ferramenta.
Em esta Seção será apresentado um exemplo simplificado, baseado no apresentado por Ober, da elaboração de uma especificação comportamental aceita por o Cynthesizer, através da descrição de um módulo que calcula o cubo de um número.
Para o projetista, é disponibilizado um esqueleto básico do conteúdo dos arquivos necessários para o projeto.
A primeira ação do projetista deve ser a definição de todas as portas do módulo.
Assim, poderão ser geradas de maneira automatizada, com um script em Perl disponibilizado por a ferramenta, a declaração das portas de entrada e saída nos arquivos da descrição do módulo, no testbench e nos arquivos de sistema (system.
H e system.
Cc). A partir de então, o projetista pode iniciar a descrição comportamental e demais tarefas sob sua responsabilidade.
Uma biblioteca de tecnologia deve ser utilizada em conjunção com as ferramentas de síntese comportamental.
Para o exemplo, foi escolhida a vtvtlib25, desenvolvida e mantida por o grupo Virginia Tech VLSI for Telecommunication para a tecnologia TSMC 0.
25 µ, com valor de lambda igual a 0, 12 µm.
Esta biblioteca é compatível com as regras de projeto da MOSIS (SCN5M-DEEP) para a fabricação junto à fundição TSMC.
A biblioteca deve ser previamente caracterizada para a síntese comportamental.
A ferramenta Cynthesizer pode assim realizar as estimativas de área e desempenho baseado nas características extraídas dos elementos da biblioteca que serão alocados para a geração da micro-arquitetura do projeto.
A Figura 18 (a) e (b) apresentam, respectivamente, os arquivos cubo.
H e cubo.
Cc, que descrevem o módulo de exemplo desta Seção.
Em cubo.
H é feita a declaração do módulo, a declaração de seus sinais de entrada, da thread de comportamento e do construtor do módulo.
Os sinais declarados são:
Clk, que é o sinal de relógio;
Rst, sinal de reset do módulo;
In, sinal de entrada sinais que são necessários para a sincronização na comunicação com o módulo.
Para a porta de entrada in:
In_ rdy assinala quando o módulo está pronto para receber dados e in_ vld assinala quando o dado na entrada é um dado válido.
Para a porta de saída out:
Out_ rdy assinala quando o parceiro de comunicação do módulo está pronto para receber um dado e out_ vld quando o módulo tem um dado válido em sua saída.
Após, é descrito o laço infinito que descreve a operação realizada por o módulo.
Em esse laço, inicialmente, é apresentado o comportamento da porta de entrada do módulo, também descrita como um bloco de protocolo preciso a nível de ciclo item 2).
Após, é descrito o algoritmo da operação do módulo item 3).
Esse algoritmo não é temporizado, nem descreve uma máquina de estados finitos, ficando livre para o escalonamento realizado por a ferramenta.
Por fim, o laço contém a descrição da interface de saída do módulo, com a devida sincronização descrita também num protocolo item 4).
Quando o módulo cubo começa sua operação, o sinal de in_ rdy é ativado.
Com isso, seu parceiro de comunicação, que pode ser outro módulo ou um testbench, é informado de que a especificação já está pronta para receber os dados.
O algoritmo espera até que o parceiro na comunicação assinale in_ vld, indicando que o valor apresentado na porta de entrada é válido.
Quando isto ocorre, o módulo lê a entrada, desativa o sinal in_ rdy para informar ao parceiro que não pode receber dados e processa a operação de cálculo do cubo.
Quando acaba de processar, o algoritmo espera que sinal out_ rdy seja ativado por o parceiro, indicando que o mesmo está pronto para receber os dados.
Quando isso ocorre, o módulo escreve os resultados na porta de saída e assinala out_ vld, para informar que está apresentando dados válidos nessa interface.
Após isso, espera por um ciclo de relógio e baixa out_ vld para que possa ser iniciada iniciada uma nova execução.
Ainda é preciso descrever o arquivo de projeto, com os detalhes necessários para a automatização do processo.
A Figura 19 apresenta um exemplo desse arquivo para o projeto do módulo cubo.
É necessário definir:
Uma biblioteca de síntese, cynthLib;
Uma biblioteca de tecnologia, techLib;
Opções para o Compilador GCC, ccOptions;
Opções globais para a transcrição do projeto em RTL, cynthHLoptions;
Opções de simulação, como o simulador para Verilog, o tipo de log de simulação gerado, o tempo de início da simulação, etc;
Os módulos não sintetizáveis, systemModule;
Os módulos sintetizáveis, cynthModule, e suas respectivas configurações de exploração de espaço de projeto, cynthConfigs;
E as configurações de simulação, simConfig.
Outro aspecto importante é a definição das diretivas de projeto, que irão habilitar a exploração do espaço de soluções do projeto.
Elas podem ser inseridas diretamente no código ou encapsuladas em macros.
Em o Cynthesizer são permitidas as seguintes diretivas:·
CYN_ FLATTEN -- que permite que os arrays sejam implementados como registradores individuais ao invés de serem implementados como memórias.·
CYN_ UNROLL -- desenrola os laços, para que mais operações sejam realizadas em paralelo.·
CYN_ PIPELINE -- transforma os laços em operações pipeline.·
CYN_ BASIC -- é utilizada por omissão, quando nenhuma diretiva é definida.
Como exemplo da utilização de diretivas, considerando T AP S como uma constante previamente definida, pode- se utilizar CYN_ UNROLL para desenrolar um laço for:
CYN_ UNROLL (COMPLETE, TAPS, &quot;loop_ for&quot;);
Assim, o laço é desenrolado e todas as suas iterações ocorrem em paralelo.
Para melhor modularização da implementação, a diretiva pode ser encapsulada com definição de uma macro, que deve ser incluída no arquivo de diretivas de projeto:
Para o módulo exemplo, o arquivo de diretivas com a definição das macros de síntese é apresentado na Figura 20.
Com a especificação do módulo pronta, é preciso criar o testbench para as simulações de verificação do módulo.
É necessário dar atenção às interfaces, que têm de ter os sinais complementares aos do módulo a ser testado.
O testbench deve implementar as threads produtoras e consumidoras de estímulos, com a interface sincronizada da mesma maneira que as interfaces do módulo.
Em esse ponto, toda a especificação a cargo de o projetista está pronta e pode ser iniciado o processo de verificação e síntese.
A ferramenta não oferece interface gráfica e todos os comandos devem ser disparados manualmente através de um shell.
Os comandos estão especificados do tipo da configuração\&gt;.
São comandos de simulação resultantes:
Sim_ BEH, simulação comportamental;
Sim_ BASIC_ C, para a simulação do RTL SystemC da configuração BASIC_ C;
Sim_ BASIC_ V, para a simulação do RTL Verilog da configuração BASIC_ V;
Sim_ LATENCY_ C, para simular o RTL SystemC da configuração LATENCY;
Sim_ LATENCY_ V, para simular o RTL Verilog da configuração LATENCY.
Os comandos de síntese são do tipo cynth_ da configuração\&gt;.
A partir de então, o projetista pode iniciar o processo de verificação e síntese da descrição comportamental.
Para o projeto exemplo, a verificação da descrição comportamental é realizada com a utilização do comando make sim_ BEH, que realiza a compilação, vinculação, e execução da simulação da descrição.
Caso erros de sintaxe e semântica sejam encontrados, ou a simulação não ocorra da forma esperada o projetista deve modificar o código da descrição ou testbench para acertar os eventuais erros.
Se a simulação comportamental foi concluída com sucesso, o projetista pode iniciar a síntese.
Para esse projeto, existem quatro opções:
Síntese para RTL SystemC e Verilog para a configuração BASIC;
E síntese para RTL SystemC e Verilog para a configuração LATENCY.
Para exemplificar, realiza- se a síntese RTL SystemC para BASIC e LATENCY, respectivamente, com os comandos make cynth_ BASIC_ C e make cynth_ LATENCY_ C. Pode-se então gerar um relatório preliminiar de área e demais informações de síntese para o projeto na biblioteca de tecnologia escolhida.
A Figura 21 apresenta o relatório das estimativas de área iniciais para as duas configurações de síntese.
Após a síntese, é possível realizar a simulação dos códigos RTL SystemC gerados por a ferramenta, para as duas configurações.
Com os comandos sim_ BASIC_ C e sim_ LATENCY_ C, realiza- se a simulação para as configurações geradas, respectivamente, BASIC e LATENCY.
Em o arquivo project.
Tcl foi definido que o log de simulação seria do formato VCD (logOptions vcd), o que permite que a simulação seja exibida por alguma ferramenta gráfica.
A simulação do RTL SystemC da configuração BASIC é apresentada na Figura 22 e a da RTL SystemC da configuração LATENCY é apresentada na Figura 23.
Em a configuração BASIC, a operação completa demora 5 ciclos para completar e na configuração LATENCY um ciclo a menos é consumido para realizar a operação.
O fluxo de projeto oferecido por o Cynthesizer operar com diversas ferramentas integradas a ele.
A Tabela 6 apresenta as ferramentas de diversos fornecedores e um descrição de sua utilização.
Em este trabalho as ferramentas utilizadas em conjunto com o Cynthesizer foram ModelSim, para as simulações RTL e Synplify Para o, para a síntese de FPGA.
Este Capítulo apresenta uma breve comparação entre os estilos de codificação para as descrições Comportamental e RTL.
Conforme visto no Capítulo 2, Seção 2.3, a principal diferença entre as descrições RTL e Comportamental é a maneira como é realizada a sincronização do sistema.
Em uma descrição Comportamental a sincronização dos módulos /processos/threads é realizada através de troca de mensagens.
Assim, os eventos de entrada/ saída têm aqui um papel fundamental.
Em uma descrição RTL, os módulos /processos/threads sincronizam sua comunicação com um sinal de relógio.
Todo o controle dessa atividade é realizada por máquinas de estados finitas (FSM).
Porém, outras diferenças podem ser observadas entre descrições Comportamentais sintetizáveis e descrições RTL.
Em uma especificação RTL, independentemente da linguagem, cada processo deve estar confinado em ciclos de relógio.
O projetista é responsável por decompor funcionalidades mais complexas, que custariam vários ciclos, num conjunto de passos simples, que executam em poucos ciclos, quase sempre controlados por uma FSM.
Em uma especificação Comportamental sintetizável com as ferramentas disponíveis atualmente, uma funcionalidade que custa vários ciclos pode ser descrita sem a necessidade de decomposição em passos.
Isso torna a descrição mais simples e natural.
Um fator bastante importante para a comparação entre os estilos de codificação é o acesso à memória.
A implementação do acesso à memória em descrições RTL é realizada através da construção explícita de FSMs.
Os componentes de memória devem ser instanciados e o acesso deve ser controlado por a FSM, observando a interface oferecida por o componente.
Já em descrições comportamentais, isso é realizado de maneira mais intuitiva, como um acesso a um vetor, utilizando a construção de indexação da linguagem.
O processo de Síntese Comportamental se encarrega de instanciar os elementos de memória, mapeando- os para componentes disponíveis nas bibliotecas, e de inferir a FSM de acesso a esses elementos.
Outra facilidade da codificação Comportamental é a liberdade na utilização de laços.
Em condições de parada com construções do tipo break.
Ferramentas de síntese Comportamental como o Cynthesizer permitem que esses laços sejam desenrolados para obter paralelismo de execução.
Para descrições RTL as ferramentas de síntese impõe restrições à utilização de laços.
Exemplos dessas restrições são índices fixos nas iterações e o corpo do laço dever consumir apenas um ciclo de relógio.
Essas condições permitem que as ferramentas possam inferir paralelismo com mais eficiência.
Porém, obrigam o projetista a criar FSMs complexas para garantir a operação do sistema.
O restante do Capítulo é organizado:
A Seção 4.1 apresenta exemplos de implementações RTL e comportamental para o módulo de controle do roteador da NoC Hermes;
A Seção 4.2 apresenta exemplos de acesso a elementos de memória em especificações comportamentais;
A Seção 4.3 mostra como devem ser organizadas as interfaces de comunicação entre os processos de uma descrição comportamental;
A Seção 4.4 trata de métodos para otimizar os resultados no Cynthesizer FSMs e Funcionalidades Multiciclo Um exemplo de especificação RTL em SystemC é o mostrado na Figura 24, que implementa o módulo de controle dos roteadores da rede Hermes.
O módulo de controle é responsável por realizar o chaveamento entre as portas.
Em o arquivo controle.
H (Figura 24 (a)) são declarados os sinais de interface do módulo, os sinais internos, a enumeração dos estados da FSM de controle e os métodos da classe.
Em a declaração do construtor da classe, cada método tem associada a sua lista de sensitividade.
Em o arquivo controle.
Cc (Figura 24 (b)) são implementados os métodos da classe.
Em a Figura são apresentados, simplificadamente, apenas três dos métodos da classe:
Upd_ SC, upd_ PSC e main_ action.
O método upd_ SC é responsável por informar ao método main_ action o estado atual da operação da FSM.
O método upd_ PSC determina qual o próximo estado da FSM.
E por fim, main_ action realiza as decisões de roteamento, baseado no estado atual do processo, e no modelo de chaveamento utilizado (XY, west-- first, negative-first, etc).
Em a descrição, para cada thread é necessário incluir o comportamento da mesma quando ocorre o reset, ou seja, as inicializações.
Em o laço principal é incluída a inicialização das variáveis auxiliares para o algoritmo de roteamento.
A comunicação com a arbitragem e com as portas de saída é realizada através de protocolos de comunicação.
O processo de arbitragem informa se existe alguma requisição (sinal req_ rot), para atender uma determinada porta (sinal incoming) e o flit de cabeçalho do pacote recebido (sinal header).
Instanciar e utilizar elementos de memória em especificações comportamentais é mais simples do que em descrições RTL, já que não é preciso declarar explicitamente a FSM de controle de acesso e os componentes podem ser inferidos por o próprio processo de síntese comportamental.
Porém, o projetista pode decidir por o reuso de componentes de memória, que podem ser descritos em nível comportamental, RTL ou netlist, e para isso precisa criar wrappers para que a simulação seja possível.
Isso vale também para qualquer componente que possa ser reutilizado no projeto.
A Figura 26 apresenta a instanciação e o acesso de elementos de memória numa descrição comportamental.
Os componentes MEM1, MEM2, e MEM3 são instâncias de wrappers de componentes de memória que foram reusados para essa descrição.
O vetor MEM4 instanciado será mapeado por a síntese comportamental para uma memória disponível em alguma biblioteca caracterizada para o projeto, ou para uma memória genérica, derivada por a própria síntese comportamental.
Ainda, a critério das diretivas utilizadas por o projetista, o mapeamento pode ser feito para um conjunto de registradores, que podem ser acessados individualmente, de forma paralela.
MEM4 $= MEM1 x é gerada uma FSM para que cada iteração do laço aconteça num número finito de ciclos de relógio.
Em uma especificação comportamental, a troca de informações entre as threads que descrevem o comportamento de um módulo é sincronizada através de troca explícita de sinais e controle, conforme apresentado no Capítulo 3 Seção 3.1.1.
Tais trocas inserem ciclos de relógio na especificação RTL derivada da síntese comportamental.
A Figura 27 retoma o exemplo da Seção citada acima de comunicação entre threads de uma descrição comportamental, com uma thread produzindo dados (Figura 27 (a)) e a outra consumindo (Figura 27 (b)).
Em (a), a thread informa que tem um dado através do sinal tx, atribuindo 1 a este, disponibiliza o dado no sinal data e espera até que o sinal ack_ tx, escrito por a thread consumidora, seja igual a 1.
Quando ack_ tx for igual a 1 a thread produtora assinala tx com 0.
Em (b), a itthread consumidora espera enquanto tx for igual a 0.
Quando tx passa a ser 1, o dado do sinal data é consumido e o sinal ack_ tx é mantido por um ciclo no valor 1, para concluir a sincronização.
E: Confirmação da conclusão da troca do flit;
E: Nova transmissão é iniciada na interface de saída do buffer.
A qualidade em latência da descrição de hardware em nível RTL, extraída da síntese comportamental disponibilizada por a ferramenta utilizada neste trabalho, está diretamente ligada ao volume da troca de sinais entre as threads que implementam um determinado comportamento, porque essas trocas precisam ser sincronizadas com sinais adicionais.
Para cada sinal que precisar de protocolo para a comunicação, a síntese comportamental irá derivar os ciclos que forem necessários para tal sincronização. Quanto mais
threads forem incluídas na implementação de um módulo e quanto mais sinais essas threads trocarem, menos eficiente em latência será o hardware derivado.
Grande parte da degradação do desempenho em descrições comportamentais de estruturas de comunicação intrachip está relacionada à necessidade da troca de sinais para sincronização da comunicação.
Portanto, a escolha do protocolo para sincronização pode reduzir os ciclos gastos nas troca de mensagens entre threads.
A Figura 29 apresenta um exemplo da sincronização por handshake na interface de entrada de uma porta do roteador.
A Figura 30 mostra a sincronização com mecanismo de crédito.
A sincronização com handshake consome em média 3 ciclos para trocar um dado e armazenar no buffer.
A sincronização com mecanismo de créditos leva 2 ciclos para realizar o mesmo processo. Quanto
menos operações de sincronização forem necessárias para descrever um determinado comportamento melhor será a eficiência em termos de latência do resultado obtido.
Sempre que for preciso utilizar sincronização, o projetista deve avaliar o protocolo de comunicação que garanta o funcionamento correto do sistema para que o mesmo não consuma ciclos desnecessariamente.
A diretiva CYN_ UNROLL é utilizada para desdobrar laços para que cada iteração, ou um conjunto destas, possa ser executada em paralelo com outras.
A diretiva pode ser usada de duas maneiras:
CYN_ UNROLL (ON| ALL| OFF, Nome Para Relatório) para desenrolar o laço em quantas iterações ele possui (On), todos os laços internos ao laço principal (ALL) ou desabilitar o desdobramento do laços (Off);
E (2) CYN_ UNROLL (COMPLETE| CONSERVATIVE| AGRESSIVE, Número De Vezes Que O Laço Pode Ser Desenrolado, Nome Para Relatório) para desenrolar parcialmente o laço.
A diferença entre Complete, CONSERVATIVE e AGRESSIVE está na maneira como a ferramenta deriva a descrição comportamental para RTL.
Considere o laço, em que OP pode ser uma das três opções:
CYN_ UNROLL (OP, 2, &quot;laço&quot;);
A Tabela 7 apresenta o código RTL derivado por a ferramenta para cada uma das opções para desenrolar parcialmente o laço.
Desenrolar complementante o laço, em geral melhora a latência da operação.
Contudo em certos casos, como para acesso de vetores de muitas posições, isso pode implicar um aumento significativo de área, já que tal elemento pode ser mapeado para um conjunto de registradores ao invés de uma memória.
Desenrolar parcialmente é uma opção intermediária entre um hardware com latência aceitável para a operação e uma área menor do que a obtida com o desenrolamento completo.
A diretiva CYN_ FLATTEN aplicada a um vetor transforma- o num conjunto de registradores.
Se esses registradores são vinculados a variáveis como índice, e esta não pode ser reduzida a uma constante, a ferramenta deriva um multiplexador para realizar esse acesso.
Em Diretiva RTL SystemC Derivado por a Ferramenta break;
Em o código acima, a ferramenta infere um multiplexador 128 para 1.
Porém, com alguma modificação na descrição, retirando a leitura da porta in1 da operação de indexação, pode- se obter apenas um multiplexador 2 para 1.
Tal modificação está descrita no código abaixo:
CYN_ UNROLL (Complete, 32, &quot;laço&quot;);
A diretiva CYN_ LATENCY é utilizada para otimização de latência em certas partes de algoritmos.
A estutura de uso da diretiva é:
CYN_ LATENCY (MÍNIMO Em Ciclos, Máximo Em Ciclos, Nome Para Relatório).
Abaixo dá- se um exemplo:
Aqui, o projetista especifica que a operação x $= y 3+ u deve ser escalonada para conter 1, 2 ou 3 ciclos de relógio.
Durante a síntese, componentes das bibliotecas caracterizadas para o projeto são escolhidos para compor a operação e ocorre a verificação do atendimento da restrição de latência.
A ferramenta pode ou não confinar a operação nos limites especificados por o projetista e gera um relatório sobre esse processo.
No caso de a operação acima, uma latência menor implica em adição de área para atender à restrição de 1 ciclo.
Este Capítulo apresenta uma revisão dos arcabouços de projeto alto nível para redes intrachip e apresenta também a abordagem de modelagem adotada neste trabalho.
Bertozzi e outros, em ressaltam a importância do suporte das ferramentas de CAD para que o projeto de redes intrachip seja viável.
É necessário desenvolver bibliotecas especializadas, ferramentas de mapeamento de aplicações, fluxos de síntese específicos para NoCs, etc..
Desenvolver sistemas de síntese específicos para NoCs é crucial para encontrar soluções de projeto viáveis em termos de desempenho, consumo de energia e personalização para aplicações específicas.
Para ser realmente efetivo, tal processo depende de um método de projeto que parta de uma aplicação, descrita em alto nível, e derive uma configuração otimizada da distribuição dos módulos e de sua correspondente arquitetura de comunicação.
A Seção 5.1 apresenta um fluxo específico para síntese de redes intrachip, conforme relatado por Bertozzi e outros.
A Seção 5.2 apresenta a proposta de Coppola e outros para modelagem de estruturas de comunicação intrachip baseado num modelo conceitual disposto em níveis de abstração OCCN.
A Seção 5.3 apresenta os modelos propostos por Marcon e sua implementação no arcabouço CAFES.
Por fim, a Seção 5.4 descreve como foi realizada a modelagem das estruturas de comunicação que foram estudo de caso deste trabalho.
Bertozzi e outros apresentam um fluxo de projeto chamado NetChip como uma alternativa para personalizar arquiteturas de comunicação intrachip.
Esse fluxo pressupõe o mapeamento da aplicação em núcleos durante uma fase de projeto integrado de hardware e software, com a utilização de alguma ferramenta específica para esse passo.
A ferramenta utilizada nesse processo deve ser capaz de gerar um grafo (core graph) com os respectivos núcleos e a informação das demandas de suas comunicações.
Esse grafo é a entrada do fluxo NetChip e passa por três fases de operação:
Mapeamento da topologia, seleção da topologia e geração da topologia.
Essas fases são realizadas por duas ferramentas integradas no fluxo NetChip:
SUNMAP, que realiza as fases de mapeamento e seleção, e o xpipesCompiler que gera a topologia selecionada.
A Figura 31 apresenta o fluxo de projeto NetChip.
Em a fase de seleção da topologia, os resultados obtidos anteriormente são avaliados de acordo com os objetivos do projeto e uma topologia para a aplicação é selecionada por o projetista.
A ferramenta SUNMAP, que engloba as duas fases apresentadas, gera como saída a descrição da topologia e dos roteadores da microrede.
A ferramenta xpipesCompiler, responsável por a fase de geração da topologia, transforma a descrição obtida na fase anterior numa descrição SystemC.
Essa descrição é gerada a partir de os elementos disponíveis na biblioteca xpipes.
Essa biblioteca é composta de macros (roteadores, interfaces, enlaces) descritas em SystemC com precisão a nível de ciclo.
Em a fase inicial, de mapeamento da topologia, uma biblioteca de funções de roteamento é associada ao processo.
A ferramenta dá suporte a diferentes funções de roteamento:
Determinísticas tais como com ordenamento de dimensões e outros algoritmos de caminhos mínimos;
Obter um mapeamento inicial dos núcleos da rede através de um algoritmo guloso.
Para roteamento com caminhos mínimos, esses caminhos e os custos são computados como produtos origem/ destino.
Quando o roteamento é por divisão de tráfego, os cami-nhos são obtidos resolvendo um sistema de equações MCF (do inglês, Multi--Commodity Flow), obtendo os produtos origem/ destino.
A solução é melhorada iterativamente, invocando o segundo passo da heurística para cada mapeamento produzido com a troca origem/ destino dos vértices.
De essa forma, no mapeamento inicial o nodo que tem a máxima demanda de comunicação é mapeado para uma posição na rede em que tenha o número máximo de vizinhos.
Uma vez definido esse mapeamento, os produtos (origem/ destino) são classificados em ordem, e assim, para cada produto forma- se um grafo de quadrante entre a origem e o destino.
Dois exemplos de grafos de quadrante entre origem e destino são apresentados na Figura 32, formados entre os nodos e h..
Para cada grafo de quadrante, se forem considerados apenas os caminhos mínimos no roteamento, é aplicado o algoritmo de Dijkstra para obter os caminhos mínimos desse grafo.
Após esses passos, pesos apropriados são colocados nas arestas.
Isso é realizado para cada um dos produtos origem/ destino na ordem inicialmente estabelecida.
Após realizado o roteamento para todos os produtos, NetChip dispõe de uma funcionalidade de geração de planta baixa do circuito, baseada nos módulos do Xpipes Compiler e associada à tecnologia escolhida, que é utilizada para realizar estimativas iniciais de área.
Se as restrições de área e largura de banda forem atendidas, o custo da comunicação é calculado.
A restrição de largura de banda é satisfeita se no resultado do mapeamento o tráfego que passa por um enlace é menor ou igual à capacidade do mesmo.
Essa capacidade é oriunda da tecnologia associada à implementação.
A restrição de área é satisfeita quando a área do mapeamento está dentro de os limites permitidos associados à implementação.
Todo esse processo é repetido no terceiro passo da heurística, quando os pares origem/ destino são invertidos.
Em o final, o melhor mapeamento de todos os gerados é selecionado.
Com essa heurística, o problema é particionado e os caminhos são selecionados dentro de partições e não sobre o grafo completo da rede.
Após essa seleção uma configuração personalizada da NoC pode ser gerada por o xpipesCompiler.
Esse compilador utiliza a biblioteca xpipes, que contém componentes parametrizáveis para estruturas de comunicação que podem ser associados à arquitetura descrita em alto nível obtida nos passos anteriores.
A saída é uma descrição SystemC hierárquica de todos os roteadores, enlaces, nodos de processamento da rede e interfaces.
Coppola e outros propõem outra abordagem para o projeto de estruturas de comunicação intrachip, chamada OCCN (do inglês, On-Chip Communication Network).
Os Autores propõem um arcabouço conjuntamente com uma metodologia para especificação, modelagem, simulação e exploração do espaço de projeto de arquiteturas de comunicação intrachip.
É disponibilizada uma API (do inglês, Application Programming Interface) SystemC orientada a objetos, aberta e flexível, que habilita a criação e o reuso de modelos executáveis de OCCAs (do inglês, On-Chip Communication Architectures).
Essas arquiteturas de comunicação intrachip englobam desdes barramentos, estruturas do tipo crossbar e NoCs, disponibilizando o mecanismo de comunicação entre os elementos de processamento distribuídos.
Segundo Coppola e outros, modelar uma NoC consiste num conjunto de passos:·
Modelar os níveis de abstração -- modelo funcional -- definido como o modelo que não considera o compartilhamento de recursos nem informações sobre o tempo, ou o tipo de sincronização ocorrendo numa sequência de eventos;
Modelo transacional comportamental -- são modelos mapeados para um domínio discreto de tempo, cuja sincronização é realizada por operações atômicas chamadas transações;
Modelo transacional preciso a nível de ciclo -- este mapeia as transações para ciclos de relógio, estes modelos nem sempre são modelos sintetizáveis;
Modelo RTL -- são modelos precisos em nível de ciclo de relógio, sintetizáveis com caminho de dados e controle bem definidos;
Modelo de portas -- este descreve o sistema em termos de primitivas lógicas.·
Ortogonalização -- separar as funcionalidades de comunicação e computação da arquitetura de comunicação.·
Determinar um modelo de protocolo de comunicação -- como o OSI, definindo as funções de cada camada de protocolos.
O método OCCN estabelece um modelo conceitual para comunicação de intermódulos baseado em níveis de abstração.
São três níveis:
Comunicação, adaptação e aplicação.
A Figura 33 apresenta a estrutura desse modelo conceitual.
O nível de comunicação é o inferior e implementa uma ou mais camadas do modelo OSI, a partir de a camada física.
O nível intermediário é o de adaptação, que mapeia uma ou mais camadas intermediárias do modelo OSI.
Ele inclui componentes de adaptação de software e hardware para disponibilizar os drivers necessários para computação, comunicação, sincroni-zação e serviços disponíveis para aplicações.
O nível superior é o de aplicação, que mapeia diretamente a camada de aplicação OSI que lhe corresponde.
Para esses níveis de abstração, o modelo conceitual OCCN disponibiliza duas Apis.
A API de comunicação, associada à interface entre os níveis comunicação e adaptação, disponibiliza uma interface que simplifica a implementação de vários níveis de drivers de comunicação em diferentes níveis de abstração.
Esta é baseada em modelos genéricos, com reuso de componentes e separação entre comunicação e computação, oferecendo um conjunto de métodos para troca de dados e sincronização.
A API de aplicação, que fica entre os níveis de aplicação e adaptação, especifica os métodos necessários para que a aplicação possa requisitar e utilizar serviços do nível de adaptação, e para que esse nível possa disponibilizar seus serviços para a aplicação.
O nível de adaptação tem vários subníveis, é definido por o projetista e deve incluir os elementos de adaptação de software e hardware, implementando funções como:
Interrupções, compartilhamento de memória, escalonamento de tarefas, etc..
Em a adaptação de software, o nível mais baixo é composto por o BSP (do inglês, Board Support Package), que permite que todo software, inclusive o sistema operacional, seja carregado em memória para começar a executar, está o nível dos drivers de dispositivo e do sistema operacional.
A camada seguinte é a de arquitetura, que contém a estrutura dos serviços oferecidos.
Em o topo da adaptação de software está a interface de troca de requisições/ respostas oferecida ao nível de aplicação do modelo OCCN.
Marcon propõe modelos em alto nível para avaliar o problema do mapeamento, que consiste em associar os núcleos de propriedade intelectual (IPs) da aplicação nos nodos da infraestrutura de comunicação.
Os modelos permitem capturar as características da rede intrachip a ser utilizada e o comportamento da aplicação a qual a rede deve dar suporte para avaliar os resultados em termos de consumo de energia, com base em modelos propostos em seu trabalho e na literatura.
Os modelos explorados no trabalho de Marcon são:·
O modelo de comunicação com pesos (CWM, do inglês Communication Weighted Model) modela uma aplicação em função de a quantidade de comunicação que ocorre entre uantidade de comunicação considerada é a soma de todos os bits os pares de núcleos.
A q de todos os pacotes transmitidos entre núcleos durante a execução da aplicação.·
O modelo estendido de comunicação com pesos (ECWM, do inglês Extended Communication Weighted Model) acrescenta ao CWM as transições que ocorrem entre bits consecutivos na comunicação para computar o consumo de energia da comunicação de forma mais precisa.·
O modelo de dependência da comunicação (CDM, do inglês Communication Dependence Model) modela a aplicação em função de a quantidade de comunicação e das dependências na disputa por recursos da infra-estura da rede.
Tal modelo permite avaliar a contenção da rede e suas implicações no cálculo do consumo de energia e descobrir quais mapeamentos são menos custosos em relação a isso.·
O modelo de computação e dependência da comunicação (CDCM, do inglês Communication Dependence and Computation Model) acrescenta ao CDM a quantidade de computação dos núcleos da aplicação.
A quantidade de computação é o tempo decorrente entre a ativação do envio da mensagem e o do real envio da mesma.
Assim, podem ser considerados os períodos de ociosidade da infra-estrutura de comunicação no consumo de energia.·
O modelo do padrão de comunicação da aplicação (ACPM, do inglêsApplication Communication Pattern Model) modela uma aplicação através do ordenamento total dos eventos de forma que seja associada à cada mensagem um marcador de tempo.
Esse marcador indica o instante em que uma mensagem é enviada de um núcleo para outro.
Esse modelo não considera a computação dos núcleos da aplicação no cálcuo do consumo de energia.·
O modelo de tarefas de comunicação (CTM, do inglês Communication Task Model) considera a computação e a comunicação da aplicação e modela o sistema baseado no escalonamento das tarefas e da taxa de comunicação entre as mesmas.
Esse modelo contempla as aplicações de tempo real, já que permite a inserção de restrições de tempo para a execução das tarefas da aplicação.
Marcon porpõe o arcabouço CAFES (do inglês, Communication Analysis for Embedded Systems), que inicialmente foi projetado para analisar as estimativas de consumo de energia de comunicação em aplicações embarcadas, em que os modelos propostos foram incorporados para avaliar o consumo de energia em comunicações aplicadas em redes intrachip.
Para utilizar a ferramenta, o projetista deve informar como entrada os dados da infra-estrutura de comunicação alvo da aplicação:
Parâmetros de topologia, que contempla NoCs com topologia 2D malha e toro com roteamento XY e chaveamento wormhole, tamanho de buffers, tamanho da rede e comprimento entre as conexões da rede parametrizáveis;
Parâmetros de tempo, que são freqüência de relógio, número de ciclos para transmissão de 1 phit e número de ciclos para executar o roteamento;
Parâmetros de consumo de energia, como potência dissipada num roteador e consumo de energia para transmitir 1 phit, considerando ou não transições em bits consecutivos.
A partir de aí, o projetista pode descrever a aplicação graficamente usando um formato particular de cada modelo e extrair o mapeamento de menor custo em termos de energia e tempo por a aplicação dos algoritmos adequadamente disponíveis.
O processo de modelagem e validação de estruturas de comunicação intrachip deste trabalho foi realizado com uma ferramenta de síntese comportamental que não possui um arcabouço de projeto específico para NoCs ou outra estrutura de comunicação intrachip.
A modelagem de cada estudo de caso foi realizada em SystemC, com o estilo de codificação aceito por a ferramenta Cynthesizer.
Todas as classes que compõem a descrição de projeto foram elaboradas sem auxílio de outros arcabouços de projeto e validadas segundo o fluxo de verificação disponibilizado na ferramenta.
Para as simulações foi necessária a utilização do ambiente Atlas.
Cabe salientar que essa modelagem não considerou a aplicação para a qual a rede servirá e contemplou apenas redes de topologia toro 2D bidirecional.
Os passos que seguem foram realizados para cada estudo de caso:
Avaliação de algoritmo da literatura para adaptação para topologia toro 2D bidirecional.
Essa avaliação contemplou a verificação de que a adaptação do algoritmo é livre de deadlock.
Descrição comportamental das classes de projeto que compõe a rede.
Elaboração de processo automatizado para parametrizar o tamanho de buffer e as dimensões da rede.
Síntese comportamental e posterior validação funcional oferecida por o Cynthesizer.
Em esse passo, ficou evidente a necessidade de auxílio para gerar tráfego para a simulação das re- des.
Para tanto, foi realizada uma adaptação utilizando a ferramenta Atlas para gerar tráfego e analisar resultados do desempenho da rede.
Esta adaptação está descrita no Capítulo 7.
Uma rede intrachip é um conjunto de roteadores e canais ponto-a-ponto que interconectam elementos de um sistema de forma que estes possam comunicar- se de maneira eficiente.
Uma rede de interconexão qualquer, e uma rede intrachip em particular, pode ser caracterizada por a maneira com que seus nodos são interligados, ou seja sua topologia.
Quanto a o tipo de topologia de interconexão, tais redes podem ser classificadas em diretas ou indiretas.
Em as redes de topologia direta, cada nodo de processamento possui um nodo de chaveamento associado.
As topologias diretas mais comumente utilizadas são a malha n-dimensional, toro, n-cubo k-ário e hipercubo.
Glass e Ni, em, apresentam definições formais para cada umas dessas topologias, reproduzidas a seguir:
Todo nodo da rede é identificado da forma, onde 0 ai ki para todo i, 0 i d..
Cada nodo é conectado a outros nodos da rede da forma, onde 0 i d..
As arestas que conectam os nodos identificados por e são chamadas arestas de retorno (do inglês, wraparound) e as outras são chamadas arestas internas.·
Redes n-cubo k-ário. Essas redes contêm k n nodos e todos os nodos possuem o mesmo número de vizinhos.
Se k $= 2 cada nodo tem n vizinhos.
Se k\&gt; 2 cada nodo tem 2n vizinhos.
Se n $= 1 o n-cubo k-ário é também chamada uma rede anel de k nodos.·
O hipercubo é um caso especial de rede malha n-dimensional e n-cubo k-ário (Figura 34 (c)).
Essa topologia corresponde a uma malha n-dimensional com ki $= 2 para todo 0 i n -- 1, ou seja, um n-cubo 2-ário.
Em as redes de topologia indireta, os nodos de chaveamento não possuem necessariamente um nodo de processamento associado.
O principal exemplo desse tipo de rede é o crossbar, como o apresentado na Figura 35 (a).
Com N entradas e M saídas, um crossbar necessita N × M pontos de chaveamento na rede.
Redes como o crossbar. Outras organizações de topologia indireta são as redes multiestágios, como a butterfly (Figura 35 (b)), em que os pacotes são roteados através de vários estágios de chaves.
Uma rede intrachip também pode ser definida por seus mecanismos de comunicação.
Esses mecanismos definem as formas como as mensagens são transferidas ao longo de a rede.
Esses mecanismos são:
Modo de chaveamento e algoritmo de roteamento. O modo de chaveamento define como uma mensagem é transferida da entrada de um roteador para um de seus canais de saída.
O chaveamento pode ser de circuito ou de pacotes.
Em o chaveamento de circuito um caminho físico é reservado da origem até o destino, antes do início da transmissão dos dados.
Em o chaveamento de pacotes, a mensagem pode, ou não, ser dividida mais de um pacote e cada um de eles é encaminhado individualmente da origem até o destino.
As técnicas de chaveamento de pacotes são:
Store-and--foward, em que o pacote é inteiramente armazenado em cada nodo de chaveamento antes de ser enviado para o próximo nodo;
O algoritmo de roteamento define a seqüência de canais que uma mensagem percorre para chegar ao seu destino.
Duato et al. Definem uma taxonomia para a classificação dos algoritmos de roteamento.
Segundo estes Autores, vários critérios podem ser utilizados para classificar- los, incluindo:·
Número de destinos: Os pacotes tem múltiplos destinos (multicast) ou um único destino (unicast).·
Local das decisões de roteamento: Para roteamentos unicast as decisões de roteamento podem ocorrer de maneira centralizada, com um controle central da rota dos pacotes;
Em o roteador de origem do pacote;
De maneira distribuída, ou seja, em cada nodo do caminho do pacote é tomada alguma decisão em relação encaminhamento daquele pacote;
Ou de maneira híbrida, combinando os roteamentos anteriores.·
Implementação: Independente do local das decisões de roteamento a implementação pode ser realizada através de uma tabela de roteamento ou de máquinas de estados finitas.·
Adaptatividade: Tanto a implementação com tabela de roteamento quanto com máquinas de estados permitem que o roteamento seja determinístico ou adaptativo.
Em o roteamento determinístico, pacotes com mesma origem e destino percorrem sempre o mesmo caminho.
Em o roteamento adaptativo, é permitido que esses pacotes possam prosseguir por rotas diferentes para alcançar o destino.·
Progressividade: Os algoritmos adaptativos podem ser classificados como progressivos ou regressivos (do inglês, backtracking).
Os progressivos reservam um canal a cada operação de roteamento.
Os regressivos permitem que o pacote retorne, liberando canais reservados anteriormente.·
Minimalidade: Algoritmos podem ser classificados quanto a sua minimalidade em mínimos ou não mínimos.
Um roteamento é mínimo quando o pacote chega ao seu destino no menor número de hops possíveis.·
Número de caminhos: Algoritmos de roteamento adaptativos podem ser classificados como parcialmente adaptativos, em que apenas parte dos caminhos disponíveis pode ser utilizada, ou totalmente adaptativos, em que todos os caminhos possíveis do roteamento podem ser utilizados.
Segundo Glass e Ni em, um bom algoritmo de roteamento deve proporcionar uma baixa latência de comunicação, uma boa vazão de mensagens e ser fácil de implementar em VLSI.
Os algoritmos de roteamento devem garantir que os pacotes sejam entregues a seus destinatários.
Para isso, é preciso garantir que o algoritmo seja livre de condições de starvation, livelock e deadlock.
Starvation é uma condição em que um processo solicitando acesso a um recurso pode ter sua requisição indefinidamente postergada, devido a uma política de atendimento não igualitária de alocação.
Considerando o exemplo da Figura 36, em que os processos P1, P2 e P3 disputam vetor do árbitro que armazena as requisições dos processos, a ordem de percurso desse vetor para atendimento das requisições pode acarretar starvation.
Se o percurso inicia sempre por o primeiro elemento do vetor e P1 sempre faz requisições, P2 e P3 correm o risco de nunca serem atendidos.
Se a ordem do percurso for que o último processo atendido recebe mínima prioridade, um critério mais igualitário, todos as requisições serão eventualmente atendidas.
No caso de redes intrachip, quando o cabeçalho de uma mensagem chega a um roteador, ele pode ser processado por o mecanismo de arbitragem para que possa requisitar roteamento.
Se esse mecanismo não for suficientemente justo, é possível que ocorra starvation em fluxos de mensagens.
Caso as mensagens que trafegam na rede possam ter seu percurso entre fonte e destino definido de tal forma que jamais atinjam o destino, ocorre a condição de livelock.
Tipicamente, algoritmos de roteamento não-determinísticos e não mínimos mal elaborados podem apresentar riscos de gerar esta condição.
A Figura 37 apresenta um exemplo, com uma rede malha 9X9 o nodo 88 tem um pacote destinado ao nodo 77.
Com a utilização de um algoritmo adaptativo não mínimo é possível que ocorra uma sitação de livelock se for permitido que o pacote se aproxime e se afaste sem jamais atingir seu destino.
Deadlock é uma condição em que ocorre pelo menos uma dependência cíclica quando dois ou mais processos requisitam recursos que estão alocados a outros processos participando das solicitações, e isso causa um bloqueio cíclico de todos ou de um subconjunto dos processos envolvidos.
No caso de redes de intrachip, considere- se uma rede com técnica de chaveamento wormhole e topologia anel unidirecional.
Considere- se ainda que a cada roteador, a lógica de roteamento disputa os canais do caminho que cada pacote deve seguir.
Deadlock pode ocorrer quando as mensagens não podem avançar porque os buffers intermediários do caminho estão ocupados e forma-se um ciclo de dependência. A Figura 39, adaptada de Dally, apresenta um exemplo.
Em ela estão representadas as filas de uma rede anel de quatro nodos usando filas de entrada, cujo conteúdo indica o índice do nodo destino.
Cada nodo da rede tem um pacote que deve ser encaminhado ao nodo oposto, isto é:
O nodo n0 tem um pacote endereçado para o nodo n2;
N1 tem um pacote para n3; N2 para n0;
N3 tem um pacote destinado a n1. As filas representadas estão cheias e nenhuma mensagem consegue avançar e isso permanecerá assim até que uma ação excepcional quebre o ciclo do impasse.
Garantir que um algoritmo de roteamento seja globalmente livre de starvation, livelock e deadlock é imprescindível para assegurar que pacotes sejam entregues a seus destinos.
Para cada uma destas situações é possível associar técnicas de prevenção:·
Starvation -- é um problema relativamente simples de resolver com alguma técnica de escalonamento de processos/ recursos que ofereça algum grau de justiça, como por exemplo, o escalonamento round-robin, também chamado de prioridade rotativa dinâmica.
Em esta, a abitragem das requisições dos canais de cada roteador é baseada no último canal atendido.
Caso se use arbitragem baseada em prioridades, alguma banda deve ser reservada para os pacotes de baixa prioridade, seja limitando o número de pacotes com alta prioridade ou reservando canais virtuais para os pacotes de baixa prioridade.·
Livelock -- a utilização de algoritmos de roteamento mínimos é uma solução.
Porém, se existe a necessidade de tolerância a falhas, caminhos não mínimos devem ser utilizados, mas com algum limite.·
Deadlock -- existem três tipos de estratégias para essa situação:
Prevenir, evitar e recuperar.
Para prevenir o sistema de entrar numa situação de impasse é preciso garantir que a alocação dos recursos (canais, buffers) nunca vai levar a essa situação.
Para isso, é preciso reservar todos os recursos antes de começar a transmitir o pacote.
Esse é o caso do chaveamento de circuito.
No caso de outros tipos de chaveamento, em que os recursos são alocados conforme o pacote avança na rede, utiliza- se prevenção e/ ou recuperação de impasses.
Em a prevenção de deadlock, recursos são alocados se levarem um estado global seguro.
Para a recuperação de deadlock é preciso estabelecer um mecanismo de detecção de deadlock e recursos podem ser retirados de processos para quebrar as situações de impasse.
Em a Seção 6.1 a seguir são explorados alguns algoritmos de roteamento específicos para redes com topologia toro com chaveamento wormhole e suas soluções para evitar situações de deadlock.
Algoritmos de Roteamento para Redes Toro Em o caso específico de redes toro, a inserção de canais de wrapparound é problemática porque os algoritmos disponíveis para a rede malha não podem ser diretamente usados para realizar o roteamento livre de deadlock.
A Seção 6.1.1 apresenta o método proposto por Dally para gerar algoritmos de roteamento para redes toro unidirecionais com a inserção de canais virtuais para evitar deadlock, ilustrando o mesmo para redes anel.
A Seção 6.1.2 mostra a adaptação e simplificação que Duato, Ni e Yalamanchili realizaram no algoritmo de Dally para uma redes toro unidirecionais em geral.
A Seção 6.1.3, apresenta um modelo geral que serve para a elaboração de algoritmos de roteamento livres de deadlock, para várias redes diretas sem adição de canais virtuais proposto por Glass e Ni.
Este modelo é denominado turn model.
Por fim, a Seção 6.1.4 mostra o algoritmo de Draper e Petrini para redes toro bidirecionais.
Abordagem de Dally e Seitz Dally e Seitz descrevem na implementação de uma rede toro dentro de o TRC (do inglês, Torus Routing Chip) utilizando canais virtuais para evitar deadlocks.
Através da divisão de canais físicos em canais virtuais a dependência cíclica de canais numa dimensão é transformada numa espiral acíclica.
Segundo Dally e Seitz, uma rede de interconexão direta pode ser descrita por um grafo direcionado I $= G (N, C), cujos vértices (N) representam os nodos de processamento e as arestas (C) representam os canais de comunicação.
Assume- se que o chaveamento da rede é do tipo wormhole.
A cada canal ci é associada uma fila com capacidade cap (ci).
O nodo de origem de um pacote é chamado si e o de destino di.
A essa rede associa- se uma função de roteamento R:
C × N C, que a cada roteador mapeia o canal de entrada de um pacote (cc) para um canal de saída (cn) baseado no seu nodo de destino (nd).
Essa função de roteamento permite descrever roteamentos determinísticos.
A função de roteamento R pode ser usada para gerar um grafo de dependências entre canais D $= G (C, E), em que o conjunto dos vértices de D são os canais de I e as arestas de D função tem como resultado uma configuração de atribuição de canais em cada vértice n N do caminho que o pacote deve seguir.
Uma configuração é suscetível a deadlock, dada a função de roteamento R e considerando size (cj) como o número de flits de um pacote, di como o nodo de destino e member (n, ci) indicando que o canal ci tem um flit destinado ao nodo n, definida por Dally como:
Ci C, (n member (n, ci), n $= di and cj $= R (ci, n) size (cj) $= cap (cj)).
Em essa configuração, nenhum flit está a apenas um hop de seu destino e nenhum flit pode avançar porque a fila do próximo canal está cheia.
Para solucionar o problema dodeadlock para arquiteturas de comunicação, Dally apresenta teorema a seguir:
Teorema 1 Uma função de roteamento R, para uma rede de interconexão I, é livre de impasse se não existirem ciclos no grafo de dependência de canais D. Dally e Seitz provam esse teorema propondo uma forma de garantir que não haverão ciclos através de um ordenamento dos canais.
Para garantir que os ciclos do grafo sejam quebrados, são introduzidos canais virtuais para cada porta de comunicação do roteador.
Dally e Seitz substituem cada canal por dois canais virtuais, um canal baixo c0x e um canal alto c1x.
Assim, o ciclo de dependência entre os canais pode ser quebrado.
A Figura 41 apresenta à esquerda o novo grafo de interconexão I e à direita o grafo de dependência D, correspondentemente.
O novo grafo de dependências pressupõe que pacotes partindo de um nodo com numeração menor que o destino percorrem seu caminho através de canais altos e os que partem de um nodo com numeração maior que o destino são encaminhados por os canais baixos.
Os canais são percorridos em ordem decrescente de seus índices e o roteamento é então livre de impasse.
Essa técnica pode ser estendida de redes anel para redes toro em geral.
Duato, Ni e Yalamanchili, em, realizaram um estudo sobre algoritmos de roteamento e apresentaram uma codificação adaptada do algoritmo de Dally e Seitz, descrito na Seção Em esta codificação, cada canal da rede foi dividido em dois canais virtuais, c0i e c1i.
Após, correspondente.
A Figura 42 apresenta uma rede 2-cubo 4-ária (toro 4x4) unidirecional e seus canais numerados de acordo com o método de Duato, Ni e Yalamanchili.
A partir de esta codificação dos canais, o algoritmo de roteamento encaminha pacotes seguindo sempre uma ordem crescente dos canais.
Duato apresenta um algoritmo específico para redes toro 2D.
Considera- se: (Xcurrent, Ycurrent) como as coordenadas do nodo em que o pacote se encontra; (
Xdest, Ydest) como as coordenadas do nodo de destino do pacote;
Canal como o canal selecionado para encaminhar o pacote, a estrutura do algoritmo proposto é apresentada na Figura 43.
O terceiro índice da codificação não aparece no algoritmo porque ele é utilizado para diferenciar um roteador do outro dentro de o anel correspondente da rede.
Esse algoritmo é muito simples de ser implementado e não é necessário para o roteador conhecer as dimensões específicas da rede e todos os roteadores são equivalentes para o roteamento.
A Figura 44 mostra um exemplo de execução do algoritmo.
Em uma rede toro 3x3 unidirecional, o nodo 22 tem um pacote destinado ao nodo 11.
O valor de Xoffset calculado no nodo 22 é negativo e o canal baixo c002 é escolhido.
Em o nodo seguinte, 32, novamente Xoffset é negativo e o canal baixo do wraparound c003 é selecionado.
Chegando ao nodo 02, Xoffset passa a ser positivo e o canal alto c010 é escolhido.
Assim o pacote atravessa a dimensão X e chega ao nodo 12, em que Xoffset é igual a zero e Yoffset passa a ser considerado.
Em o nodo 12, Yoffset é negativo, assim o canal baixo c102 é selecionado.
Em o nodo 13, novamente Yoffset é negativo e o canal baixo de wraparound c103 é selecionado.
Em o nodo seguinte, 10, o Yoffset passa a ser positivo e o canal alto c110 é selecionado.
Em o nodo 11, destino do pacote, Xoffset e Yoffset são zero e o pacote é encaminhado para o módulo de processamento local.
Yalamanchili. Glass e Ni realizaram um extenso estudo sobre roteamento adaptativo e propuseram um modelo chamado turn model para gerar algoritmos de roteamento que evitem a situações de deadlock em redes com chaveamento do tipo wormhole com topologias malha, n-cubo k-ário e hipercubos, sem a adição da canais virtuais.
Esse modelo pressupõe o uso de redes ortogonais, ou seja, aquelas onde a posição de cada roteador por ser definida por uma tupla de valores, uma para cada dimensão da rede.
O modelo consiste em analisar as curvas (turns) que um pacote pode tomar, ou seja, as trocas de direção ortogonal ao longo de o caminho do pacote entre fonte e destino, e os ciclos que essas mudanças de direção podem causar.
Com base nisso, os Autores propõem algoritmos de roteamento baseados na proibição de algumas curvas para quebrar os ciclos do grafo de dependência, eliminando assim a possibilidade de deadlock.
Os algoritmos de roteamento assim produzidos são em geral parcialmente adaptativos, porque sem a utilização de canais virtuais não é possível obter algoritmos totalmente adaptativos livres de deadlock.
Uma situação de deadlock não ocorre se não existir dependência cíclica entre os canais.
Em o turn model, uma curva ocorre quando o pacote passa de uma dimensão para outra.
Em esse modelo, para evitar deadlock é preciso proibir tipos de curva em número suficiente para quebrar todos os ciclos da rede.
Para redes do tipo malha n-dimensional e n-cubo k-ário, seis passos devem ser seguidos para desenvolver um algoritmo baseado no turn model:
Classificar os canais de acordo com as direções que podem ser tomadas por o roteamento dos pacotes.
No caso de n-cubo k-ário, os canais de wrapparound não devem ser considerados nesse passo.
Identificar as curvas que ocorrem entre duas dimensões, omitindo as curvas de 0 e 180 graus.
Curvas de 180 graus mudam o pacote de direção, mas não de dimensão.
Curvas de 0 graus ocorrem quando existem canais virtuais numa direção e o pacote pode trocar de canal virtual sem mudar a direção ou sentido do movimento.
Identificar os ciclos mais simples que essas curvas podem formar.
Proibir pelo menos uma curva em cada ciclo.
No caso de n-cubo k-ário, incorporar as curvas que envolvem canais de wrapparound, desde que estes não introduzam novos ciclos.
Adicionar curvas de 0 e 180 graus, desde que sem reintroduzir ciclos.
Isso somente é necessário quando existem canais virtuais e para roteamentos não-mínimos.
Considerado uma rede malha de duas dimensões, as quatro direções que podem ser tomadas permitem oito curvas, ou seja, direita e esquerda para leste, oeste, norte e sul.
Essas oito curvas formam dois ciclos simples, conforme mostrado na Figura 45 (a).
O algoritmo de roteamento XY, em que primeiro o pacote atravessa a dimensão X e depois a dimensão Y, proíbe quatro curvas, conforme Figura 45 (b).
O deadlock é evitado, porém sem garantir adaptatividade ao algoritmo.
Dentro de os ciclos, é possível evitar impasse proibindo apenas uma curva, o que ocasionaria uma certa adaptatividade ao algoritmo.
Porém, nem sempre o deadlock seria evitado se os dois ciclos fossem combinados.
A Figura 46 apresenta essa situação.
Em a Figura 46 (a) as três curvas à esquerda permitidos equivalem a curva à direita proibido na Figura 46 (b).
Para redes do tipo toro bidirecional, Glass e Ni afirmam que é possível estender os algoritmos de roteamento da rede malha.
O algoritmo negative-first pode ser estendido classificando cada canal wraparound como negativo ou positivo, de acordo com a posição relativa da rede malha.
Os canais de retorno só são utilizados uma vez no caminho do pacote.
O algoritmo negative-first, para esse caso, é não-minímo.
Para redes toro bidirecionais com k\&gt; 4, é impossível gerar algoritmos mínimos sem adicionar canais virtuais.
Glass e Ni citam o trabalho de Linder e Harden, que trata do particionamento da rede n-cubo k-ário bidirecional em 2 n-1 redes virtuais com n+ 1 níveis por rede virtual e k n canais virtuais por nível.
Assim, cada canal físico é particionado em) 2 n-2 canais virtuais.
Essa abordagem é claramente impraticável para NoCs.
Glass (n+ 2) sugere a utilização do algoritmo proposto por Dally e Seitz para obter algoritmos adaptativos e mínimos e praticáveis para toro ou n-cubo k-ário unidirecional.
Uma abordagem de roteamento específica para rede n-cubo k-ário bidirecional, é apresentada nos trabalhos de Draper e Petrini.
Essa abordagem também utiliza canais virtuais e ordenação dos mesmos para a execução da função de roteamento.
Draper, em, apresenta o algoritmo Red Rover para redes de anéis bidirecionais.
Cada canal físico do anel é dividido em dois canais virtuais e os canais da rede são separados em dois conjuntos A e B. Em esse algoritmo, a rede anel é organizada em dois conjuntos de nodos contíguos:
Os nodos de 0 a como um grupo e os nodos k até k -- 1 outro grupo.
Mensagens que são injetadas na rede por um dos grupos de nodos são sempre encaminhadas por os canais do conjunto A, independente do destino.
Mensagens injetadas na rede por o outro grupo de nodos percorrem sempre os canais do grupo B. A Figura 48 apresenta o mapeamento dos canais virtuais na rede anel.
Esse mapeamento forma quatro redes distintas:
Para provar que o algoritmo é livre de deadlock basta mostrar que não existem ciclos se os pacotes forem encaminhados num ordenamento coerente.
Para cada uma das redes virtuais é possível mostrar um ordenamento de canais válido.
Em as redes A+ e B+ o ordenamento é crescente e nas redes A- e B-decrescente.
Por exemplo, para a rede A+ cada um dos nodos, -- 1 k nodo k -- 1 por os canais A+.
O ordenamento de canais para a rede A+ é c0+, A\&gt; c1+, A\&gt; um encaminhamento com ordenamento válido.
Já para a rede B-, o ordenamento dos canais é não resulta num ordenamento válido.
Draper e Petrini, em, estendem o algoritmo para redes toro bidirecionais.
O algoritmo deve ser combinado com o algoritmo de ordenamento de dimensões.
Primeiramente, o pacote é encaminhado seguindo o ordenamento das dimensões.
Quando alcança a última dimensão é então encaminhado segundo o algoritmo Red Rover.
A Tabela 8 apresenta um quadro comparativo entre os algoritmos revisados no capítulo.
São considerados como critérios:
A solução para deadlocks, a utilização de canais virtuais, o tipo de roteamento e as redes que abrangem.
Como um estudo de caso de implementação prática para esse trabalho foi escolhida uma rede toro 2D bidirecional com modo de chaveamento wormhole e algoritmo de roteamento Turn Model.
Para tanto, foram estudados algoritmos de roteamento com técnicas de prevenção de deadlocks, conforme Capítulo 6, Seção 6.1.
O trabalho de Dally e Seitz, apresentado na Seção 6.1, Subseção 6.1.1 apresenta um algoritmo de roteamento para rede toro unidirecional utilizando canais virtuais para evitar deadlocks.
A solução de Duato, Ni e Yalamanchili, apresentada na Seção 6.1, Subseção 6.1.2 é uma simplificação do modelo de Dally com uma codificação e algoritmo mais simples, também para toro unidirecional.
Uma solução para roteamento em toro bidirecional com canais virtuais é apresentada por Draper e Petrini na Seção de Glass e Ni, na Seção 6.1, Subseção 6.1.3 em que restrições de certas curvas em certas direções no roteamento pode evitar impasses.
Porém essa última abordagem não é suficientemente explorada para redes com topologia toro.
Em esse trabalho foi realizado um estudo sobre a adaptação do algoritmo west-- first nãomínimo para redes toro 2D bidirecionais, sem a utilização de canais virtuais.
Devido a a inserção de canais de wraparound, quando se migra da topologia malha para a topologia toro, é preciso considerar o comportamento do algoritmo nas bordas da rede.
A Figura 49 apresenta uma rede toro 4x4 2 D, onde I representa o conjunto dos roteadores da extremidade esquerda, II o conjunto da extremidade direita, III o da extremidade norte e IV o da extremidade sul.
Em o turn model, algumas direções devem ser proibidas para evitar ciclos de impasse.
Com os canais wraparound isso complica- se e as restrições de roteamento devem incluir a consideração das particularidades desses canais.
Por exemplo, seguir um enlace de wraparound é continuar na mesma direção ou realizar uma curva de 180 graus?
Uma maneira de garantir que não ocorrerá deadlock é fazer com que os canais de wraparound sejam usados apenas uma vez no roteamento.
Para evitar transportar informações dinâmicas de roteamento no pacote, pode- se ainda forçar que a utilização desses canais possa ocorrer apenas no primeiro hop do pacote.
Assim, o roteador deve ser capaz de reconhecer que tem um ou mais canais de retorno e se é vantajoso utilizar- lo quando um pacote é injetado na sua porta local.
Outra questão importante é garantir que a utilização desse canal não entre em conflito com as restrições do algoritmo west-- first.
Em a adaptação aqui proposta, o algoritmo west-- first é utilizado sempre que um pacote é injetado num roteador que não é da borda.
Se o pacote for injetado num roteador de um dos conjuntos das extremidades, deve- se realizar uma operação baseada no destino do pacote.
Se for vantajoso, utiliza- se o canal de wraparound para o primeiro hop.
Caso contrário, o westfirst deve ser seguido a risca.
Após utilizar o canal de wraparound um pacote.
Segue o algoritmo west-- first até alcançar o destino.
A Figura 50 apresenta resumidamente um pseudo-código da descrição comportamental do algoritmo de roteamento west-- first não-mínimo adaptado para a rede toro 2D bidirecional.
Considere- se:
DIM_ M e DIM_ N como as dimensões em X e em Y da rede;
Add_ x e add_ y como o endereço (X, Y) de cada nodo na rede;
Header_ x e header_ y como o endereço de destino em X e Y do pacote que chega ao nodo;
Incoming como a fila que fez a requisição para tal roteamento;
Controle como uma variável auxiliar para o processo de decisão;
Canais como o vetor que contém a lista de portas válidas para o caminho daquele pacote;
E Xof f set para incoming, header_ x e header_ y.
Primeiramente, se o pacote é injetado na rede no roteador, ou seja, por a porta Local deste, um conjunto de condições é testado para verificar se o nodo pertence a algum dos conjuntos de borda da rede.
Se pertencer, verifica- se vale a pena utilizar o canal de wraparound.
Caso contrário, se não se trata de um roteador de borda e/ ou não vale a pena utilizar o wraparound, a variável controle é setada para 1.
A partir de aí, se controle $= 1, devido a o não atendimento das condições anteriores, ou se o pacote chega ao nodo por as outras portas (Leste, Oeste, Norte ou Sul), o algoritmo west-- first puro é seguido.
Em esse algoritmo, quando o pacote alcança sua dimensão X, vindo na direção Leste-Oeste, e tem os canais nas direções de Y bloqueados (Norte ou Sul) pode- se contornar essa situação continuando na direção Oeste.
De isso decorre a não-minimalidade do algoritmo.
A função atualiza_ tabela_ roteamento (incoming, canais) percorre o vetor canais verificando, em ordem, se entre os canais escolhidos algum está disponível e garante que o pacote não retorne por a porta em que chegou ao roteador.
Essa função também atualiza os valores das tabelas de roteamento, responde ao árbitro e informa as portas de saída do estabelecimento das conexões.
O encerramento das conexões foi omitido nesse pseudo-código.
Dois exemplos são apresentados na Figura 51 (a) e (b).
Em (a), o roteador 13 tem um pacote injetado com destino ao nodo 30.
Qualquer uma das rotas adaptativas do west-- first usando os caminhos de uma malha equivalente levaria 5 hops para chegar ao destino.
Com a utilização do canal de retorno levaria- se- 3 hops.
Em esse caso, é vantajoso utilizar o canal de wraparound.
Já na situação (b), em que o roteador 23 tem um pacote injetado com destino ao nodo 00, não é possível utilizar o canal de retorno porque a condição inicial do algoritmo west-- first seria quebrada, pois o pacote não poderia seguir na direção Oeste depois de utilizar um canal de qualquer outra direção.
A rede descrita anteriormente foi modelada através de descrições comportamentais SystemC com a metodologia de projeto oferecida por a ferramenta Cynthesizer.
A Figura 52 apresenta simplificadamente a arquitetura desse roteador.
Todos os roteadores da rede são similares e possuem cinco interfaces de comunicação:
Local, Leste, Oeste, Norte e Sul.
Todas essas interfaces possuem memorização na entrada e mecanismo de controle de fluxo do tipo handshake, na interface Local, para a compatibilidade de interface para a simulação com a adaptação feita na ferramenta Atlas, e mecanismo de crédito nas demais interfaces.
O roteador implementa ainda lógica de arbitragem e roteamento, usando, respectivamente, arbitragem rotativa dinâmica e o algoritmo de roteamento west-- first para toro 2 D, conforme descrito acima.
O tamanho do flit para a rede e o tamanho das filas de entrada pode ser variável.
A lógica de arbitragem e roteamento são duas threads SystemC, que descrevem o comportamento do módulo árbitro e do módulo de roteamento;
As portas de saída são threads que descrevem comportamentos individuais.
O crossbar do centro da arquitetura é um conjunto de threads que realiza a lógica de cola entre os sinais trocados por as Entradas, Saídas e a Lógica de Arbitragem e Roteamento.
Cada uma das filas de entrada se comunica com o módulo árbitro.
Sempre que um novo pacote chega a uma fila uma nova requisição de roteamento é gerada.
A fila informa que existe um novo pacote e informa o cabeçalho desse pacote ao árbitro e aguarda até receber uma resposta afirmativa para iniciar a transmissão.
Os sinais trocados entre a fila e o árbitro são:
H, em que a fila informa ao árbitro que tem um novo pacote;
H_ header, que a fila informa o cabeçalho do pacote ao árbitro;
Ack_ h, em que o árbitro informa para a fila que a transmissão pode ser iniciada.
O módulo de controle implementa o algoritmo de roteamento da rede.
Ele mantém uma tabela com informações sobre a situação das conexões.
Esse módulo atende os pedidos de conexão das filas que são ordenados por o módulo árbitro, monitora o término das transmissões das filas de entrada e atualiza as informações de roteamento para as interfaces de saída.
Para esse estudo de caso foi elaborado um processo automatizado que instancia uma rede toro 2D de dimensões quaisquer.
Essa rede pode ser simulada em nível comportamental e RTL, seja em SystemC, seja em Verilog, gerados por a ferramenta Cynthesizer.
A geração dos pacotes para simulação foi realizada com o ambiente Atlas.
Com essa ferramenta é possível gerar automaticamente configurações para a rede Hermes, HermesTU, HermesTB e Mercury, e criar cenários de tráfego variados.
A ferramenta integra ainda um fluxo de simulação da rede gerada e um método de avaliação baseada na simulação com os cenário de tráfego ao qual a rede foi submetida.
Cabe salientar que nesse trabalho o Atlas é utilizado para gerar os cenários de tráfego e para realizar a avaliação do resultado da simulação.
A simulação da rede implementada nesse estudo de caso em si foi realizada no ambiente disponibilizado no Cynthesizer.
Além de a rede descrita em VHDL, dos pacotes a serem injetados, a ferramenta produz três módulos SystemC para a avaliação do tráfego da rede:
InputModule, que injeta pacotes na rede;
OutputModule, que consome os pacotes da rede;
OutputModuleRouter, que monitora as interfaces entre os roteadores da rede.
Depois da geração do cenário de tráfego, esses três módulos são utilizados na composição do testbench e da rede para a simulação no Cynthesizer.
A Figura 55 apresenta a organização do roteador e do testbench para utilizar os módulos gerados por o ambiente Atlas no Cynthesizer.
O testbench instancia os módulos InputModule e OutputModule e associa suas interfaces com a interface de simulação da rede toro.
A rede instancia o OutputModuleRouter, que deve ser marcado no arquivo de projeto (project.
Tcl) como um módulo não sintetizável, e associa as interfaces entre os roteadores aos sinais consumidos por o módulo.
Após a simulação, que é realizada no ambiente do Cynthesizer, são obtidos arquivos com informações da utilização dos canais internos e das interfaces de saída da rede.
Esses arquivos são transportados para o ambiente Atlas para que os relatórios de utilização de canais e latência possam ser gerados e a NoC avaliada.
Conforme apresentado no Capítulo 4, a exploração do espaço de projeto pode ser realizada modificando construções algorítmicas, diretivas de síntese permitidas por a ferramenta de síntese utilizada e/ ou alterando o processo de sincronização entre as threads que compõe as funcionalidades.
Um exemplo de exploração de sincronização de sinais pode ser observado no mecanismo de inclusão de dados na fila de entrada de uma porta do roteador.
Foram implementados dois mecanismos de sincronização:
Créditos e handshake.
Em a Tabela 9, é apresentada a codificação em SystemC, aceita por a ferramenta utilizada neste trabalho, para esses mecanismos de sincronização.
Também é apresentado na tabela um resumo do relatório disponibilizado por a ferramenta para cada uma das implementações para os critérios:
Número de ciclos para incluir um dado na fila e LUTS ocupadas no dispositivo alvo da síntese, considerando uma fila de 8 flits de 16 bits.
Quanto a o primeiro critério, observa- se o ganho de um ciclo na sincronização por mecanismo de créditos.
Quanto a o segundo, lembrando que o relatório apresenta o número de LUTS do componente buffer que contém a entrada e o consumo de dados da fila, o mecanismo de crédito torna o hardware um pouco mais custoso.
Critério Crédito Código da sincronização da entrada da credito_ o.
Write; Ciclos para in- 2 cluir dado na fila LUTS ocupadas 243 Handshake wait;
Outro ponto do trabalho em que foi realizado o estudo de diretivas para exploração do espaço de projeto foi o componente de roteamento.
O algoritmo de roteamento implementado é composto por duas funções principais:
A lógica de roteamento e a consulta e atualização das tabelas de roteamento.
A primeira é apresentada na Figura 56 a segunda na Figura 57.
As seguintes diretivas foram marcadas no código:
1) diretiva de latência para a parte da decisão de roteamento;
2) diretiva de latência para a função de consulta e atualização das tabelas de roteamento;
3) diretiva para desdobramento do laço para que as operações sejam realizadas em paralelo.
LUTS com tempos de resposta entre 3 e 10 ciclos de relógio.
Para o sexto cenário, é suprimida a diretiva 2, e a ferramentas escalona as operações em 357 LUTS, com um custo de 4 a 6 ciclos de relógio para responder às requisições de roteamento.
Para ilustrar cada cenário apresentado, foi realizada a simulação do comportamento da rede e recortado o comportamento do roteador de endereço 00 numa rede toro 4x4.
Em esse roteador, acontece uma requisição da porta Local com destino ao roteador 11;
outra requisição da porta Norte com destino à 00;
uma requisição vinda do canal de wraparound, correspondente a porta Oeste do roteador, com destino ao roteador 22;
e outra requisição vinda da porta Leste com destino à 00.
Com o processo automatizado implementado para esse estudo de caso, foram geradas redes de dimensões 2x2 e 3x3 com filas de 8 e 16 flits.
Em a implementação foram marcadas as diretivas para condução da síntese comportamental, de forma que os laços sejam desenrolados e que as restrições de latência específicas para certos pontos do projeto sejam atendidas.
As redes foram sintetizadas para ASIC com a biblioteca de tecnologia TSMC 0.
18 µm e foram geradas as descrições RTL SystemC e Verilog e os relatórios com as informações relativas ao processo de síntese.
Para ilustrar simplificadamente que informações são apresentadas nos relatórios gerados por o Cynthesizer tem- se:
A Figura 64 apresenta um resumo das informações contidas no relatório de síntese para os módulos buffer e buffer_ c, que implementam respectivamente o controle de entrada com handshake e com mecanismo de créditos, com capacidade de 8 flits de 16 bits.
Ambos implementam uma fila linear para armazenamento dos flits do pacote.
As Figuras 65 e 66 apresentam o relatório do mapeamento dos módulos extraídos na síntese comportamental dos módulos buffer e buffer_ c com os elementos disponíveis na biblioteca de tecnologia e os que foram gerados automaticamente por a ferramenta.
Lógica, que foi realizada com Synplify Para o e do P&amp;R realizado com o ISE.
A Tabela 11 apresenta as informações gerais sobre a área da rede implementada com a síntese realizada para ASIC.
Para a rede de dimensão 2x2, o aumento do buffer de 8 para 16 flits causou um acréscimo de 303567,56 µm2 em área, que corresponde a um aumento de 34,55%.
Aumento de proporção semelhante ocorreu na rede de dimensões 3x3, com o aumento do buffer de 8 para 16 flits.
5) da XILINX para caracterização da biblioteca para a síntese lógica.
A rede foi gerada com dimensões 2x2, 3x3 e 4x4 com buffers de profundidade 8 e 16 flits.
A partir de aí foi realizada a síntese comportamental e a síntese lógica das redes para o dispositivo escolhido.
A Tabela 12 apresenta os resultados relativos à ocupação do dispositivo para cada rede em relação a sua dimensão.
Para a rede 2x2 o aumento dos buffers causou um acréscimo de 19,62% da ocupação de LUTS do dispositivo.
Para a rede 3x3, o aumento do tamanho dos buffers gerou um acréscimo de 18,3% em LUTS.
Para a rede de dimensão 4x4 o aumento do tamanho dos buffers de 8 para 16 flits gerou um acréscimo de 17.48% em LUTS.
7.1.3 Avaliação de Latência da NoC Gerada com Síntese Comportamental Para auxiliar a avaliação da qualidade do resultado obtido por a síntese comportamental em termos de latência da rede gerada foi utilizado o ambiente Atlas, conforme exposto anteriormente.
Para efeitos de comparação dos resultados, a Tabela 14 mostra a comparação das latências médias obtidas de cenário de tráfego com NoC 4x4, com distribuição uniforme, trá-fego do tipo complemento e tamanho do pacote de 16 flits.
Tal cenário foi simulado com a NoC Hermes Tb do trabalho de Scherer e com a NoC produzida neste trabalho.
Claramente observa- se que a qualidade do resultado gerado não tem bom desempenho em termos de latência.
Conforme mostrados no Capítulo 4, Seção 4.3, toda a troca de dados entre as threads que compõe o roteador da NoC inserem ciclos de relógio e sinais de controle para sincronização da comunicação, o que acarreta em custo de latência para a transmissão de dados.
Para cada sincronização entre as threads internas do roteador para a transmissão de um flit são perdidos entre 2 e 3 ciclos de relógio, o que gera um grande impacto na latência final da transmissão do pacote.
Para a avaliação, também foi gerada uma rede toro 7x6, com tamanho de fila de 16 flits.
Para a simulação foi gerado um cenário de tráfego com distribuição normal e destino aleatório, com cada nodo enviando 10 pacotes, cada pacote com 16 flits.
A Tabela 15 apresenta os valores para as 10 menores latências obtidas na simulação e a Tabela 16 apresenta as 10 maiores latências para o mesmo cenário.
Tabela 16 ­ As 10 maiores latências obtidas na simulação do cenário com a rede 7x6 com buffers de 16 flits.
A Figura 68 apresenta os caminhos seguidos por alguns dos pacotes dessa simulação.
O pacote com maior latência da simulação, que é injetado no nodo 51 e tem como destino o nodo 05, passa por 9 hops até chegar a seu destino.
Os dois pacotes que tem como origem-destino, respectivamente, 53 para 32 e 05 para 60, levam 5 e 7 hops para chegar ao seu destino.
O pacote com menor latência, com origem no nodo 10 e destino 15, leva 1 hop para alcançar seu destino.
Este Capítulo apresenta um projeto de rede toro 2D usando um algoritmo de roteamento com a codificação proposta por Duato, Ni e Yalamanchili.
Embora tal adaptação resulte em estruturas de comunicação intrachip bastante custosas, já que o gerenciamento de canais virtuais insere um custo em área e latência adicional, o estudo de caso agrega a complexidade necessária para a avaliação da síntese comportamental como instrumento de modelagem e validação dessas estruturas de comunicação.
Para tanto foi necessária a criação do algoritmo de roteamento Sul-Oeste, complementar ao Leste-Norte proposto por Duato e apresentado na Seção 6.1, Subseção 6.1.2.
O algoritmo Leste-Norte encaminha os pacotes primeiro para os canais do Leste, se for o caso, e depois para os canais do Norte, se for necessário, até alcançar o seu destino, percorrendo canais em ordem crescente.
O algoritmo complementar Sul-Oeste encaminha os pacotes primeiro para os canais do Sul, se necessário, e depois para Oeste, com ordenamento decrescente de canais.
Em o algoritmo Sul-Oeste a codificação proposta por Duato, Ni e Yalamanchili é respeitada e a prova de que o mesmo é livre de deadlock é análoga a do algoritmo Leste-Norte.
A codificação dos canais para o algoritmo Sul-Oeste é apresentada no exemplo da Figura 69.
O algoritmo SulOeste é apresentado na Figura 70.
A Figura 71 apresenta um exemplo da execução do algoritmo Sul-Oeste para uma rede toro 4x4.
Em a adaptação realizada para a rede toro 2D bidirecional, os dois algoritmos são utilizados para compor o processo de roteamento da rede.
Porém, um pacote que é injetado na rede só pode trafegar obedecendo a apenas um dos algoritmos.
A decisão de qual algoritmo seguir deve ser tomada no roteador de origem do pacote.
Sendo assim, a prova de que a solução é livre de deadlock é a prova de que cada um dos algoritmos, Leste-Norte e Sul-Oeste, é livre de deadlock.
Como os roteamentos ocorrem como se fossem em redes virtuais diferentes, os pacotes ficam confinados na rede virtual do algoritmo escolhido na origem, não disputando os canais da rede virtual do algoritmo complementar.
Leste-Norte; (b) o pacote injetado na rede por 21 com destino 33 segue o caminho Sul-Oeste, devido a o congestionamento da porta de saída Leste do roteador 21 por outro pacote.
Porém, se o critério de decisão para o algoritmo adaptado de Duato for a menor distância entre os roteamentos disponíveis, o roteador tem o custo adicional para realizar tal cálculo.
É necessário que o mesmo seja capaz de calcular a menor distância relativa ao destino para cada um dos roteamentos, Leste-Norte e Sul-Oeste, e escolher a mais vantajosa.
A Figura 73 apresenta essa situação.
O nodo 21 tem um pacote injetado com destino 02.
Se o pacote seguir a rota de Leste-Norte chegará ao destino em 3 hops.
Se o pacote seguir por a rota de Sul-Oeste alcançará o destino em 5 hops.
A decisão tomada na origem deve ser escolhida de acordo com a aplicação a qual a rede deverá dar suporte.
Cabe salientar que se for inserida alguma adaptatividade, como o caso da decisão baseada no congestionamento da origem, os pacotes de uma determinada origem e mesmo destino podem chegar fora de ordem ao nodo final.
Em este trabalho, o critério para a implementação da escolha do caminho do pacote foi o congestionamento no nodo de injeção do pacote na rede.
A Figura 74 apresenta o pseudo-código simplificado do processo de roteamento implementado.
Em este processo, após a requisição do árbitro, se o canal de entrada do pacote for um dos canais de injeção na rede (canais da porta local) é obtido o canal de saída do pacote através do algoritmo Leste-Norte.
Porém, se o canal retornado por esse algoritmo estiver ocupado, o canal de saída do pacote é dado por o algoritmo Sul-Oeste.
Se o pacote chegar ao roteador por qualquer canal que não seja um canal de injeção, ele continua trafegando na rede segundo o algoritmo que foi estabelecido em seu nodo de origem até chegar ao seu destino.
Ou seja, se o pacote chegar ao roteador por canais do Sul e do Oeste, continua o caminho dado por o algoritmo Leste-Norte, sempre indo para Norte ou Leste.
Se o pacote chegar ao roteador por canais do Norte ou Leste, continua sua rota por o algoritmo Sul-Oeste, indo sempre para Sul ou para Oeste.
A rede toro 2D com canais virtuais foi modelada através de descrição comportamentais em SystemC, utilizando a metodologia de projeto oferecida por a ferramenta Cynthesizer.
Todos os roteadores da rede são similares e possuem cinco interfaces de comunicação:
Local, Leste, Oeste, Norte e Sul.
As interfaces Leste, Oeste, Norte e Sul possuem dois canais virtuais com memorização somente na entrada e controle de fluxo através do mecanismo de créditos.
A interface Local possui apenas um canal de entrada com memorização na entrada e mecanismo de controle de fluxo do tipo handshake, para manter a compatibilidade com a interface da rede Hermes para a utilização das mesmas ferramentas de avaliação.
O roteador contém ainda lógica de arbitragem e roteamento que implementam, respectivamente, arbitragem rotativa dinâmica e o algoritmo de roteamento para toro 2D adaptado do algoritmo de Duato.
O tamanho do flit para a rede é de 16 bits e o tamanho da fila nas entradas é de 8 flits.
A Figura 75 apresenta simplificadamente a arquitetura desse roteador.
Cada módulo do roteador foi descrito em nível comportamental:
Interfaces de comunicação, arbitragem e roteamento e demais threads necessárias a sincronização dos sinais de comunicação entre esses módulos.
Para as interfaces de comunicação com memorização na entrada, duas filas do tipo FIFO foram implementadas:
Uma para controle de fluxo com mecanismo de aperto de mão e outra para o controle de fluxo com mecanismo de crédito.
Leste recebe a atualização da tabela de roteamento;
E começa a transmissão por o lane baixo;
O dado gravado no buffer do canal virtual baixo da porta de entrada Oeste do nodo vizinho;
A porta recebe nova atualização da tabela de roteamento e agora a linha de dados precisa ser compartilhada;
E transmissão realizada por o lane baixo e dado gravado no buffer do canal baixo do nodo vizinho;
E transmissão realizada por o lane alto e dado gravado do buffer do canal alto nodo do vizinho.
A interface de comunicação da porta Local do roteador tem apenas um canal para manter a interface de acordo com a adaptação feita para simulação com a ferramenta Atlas, explicada no Capítulo 7.
Em a interface de entrada utiliza- se uma fila com controle de fluxo por aperto de mão.
Em a interface de saída é necessário gerenciar apenas um canal de saída e recolhe- se as informações vindas do módulo de controle para transferir os dados que vem das filas das entradas de outras portas.
A requisição das filas de entrada por o roteamento do pacote é semelhante ao apresentado no estudo de caso anterior.
Os módulos de arbitragem e roteamento trocam os mesmos sinais que são apresentados naquele estudo de caso, com o diferencial do algoritmo de roteamento implementado e do número de canais atendidos por a arbitragem rotativa dinâmica.
Para o roteador deste estudo de caso, um processo semelhante ao apresentado no estudo de caso anterior foi desenvolvido para explorar o espaço de projeto.
Para validar a rede foi elaborado uma esquema de comunicação em que cada roteador envia dez pacotes de tamanhos aleatórios para cada um dos outros roteadores da rede.
A verificação do sucesso desse processo foi realizada de forma automatizada, através da elaboração de um programa que confere se os pacotes na saída dos roteadores estão de acordo com os pacote das entradas e se a contagem das mensagens destinadas a cada roteador está correta.
As Seções seguintes apresentam resultados adicionais de latência e área dos resultados de síntese obtidos com a ferramenta.
Para o presente estudo de caso também foi utilizada a ferramenta Atlas para a avaliação de latência do resultado obtido nas sínteses realizadas.
Como exemplo de avaliação, foi instanciada uma rede toro 2D 3x3, com tamanho de buffer de 8 flits, e gerado na Atlas um cenário de tráfego onde cada chave envia 30 pacotes de 16 flits a um destino aleatório.
As Tabelas 17 e 18 mostram, respectivamente, as 10 menores e as 10 maiores latências da simulação deste cenário de tráfego.
Para avaliação de área da NoC gerada, foram extraídos relatórios da síntese para FPGA visando o dispositivo Virtex II XC2 V4000 (speed grade 5) da XILINX.
A Tabela 19 apresenta o resultado do processo de síntese lógica para FPGA, a partir de o resultado obtido na síntese comportamental, para NoCs de dimensão 3x3 e 4x4, com tamanho dos buffers de 4 e 8 flits.
Para as redes de dimensão 3x3, o aumento do buffer gerou um acréscimo de 7,21% em LUTS ocupadas.
Para as redes 4x4 o aumento do buffer gerou um acréscimo de 7,77% em LUTS ocupadas.
O dispositivo escolhido não comporta a rede de dimensão 4x4.
Tabela 18 ­ As 10 maiores latências obtidas na simulação do cenário com a rede 3x3 com buffer de 8 flits.
A avaliação do uso de um processo de síntese comportamental como alternativa para o projeto de redes intrachip foi realizada quanto a modelagem de projeto e a qualidade dos resultado obtidos.
Por o que foi demonstrado nos Capítulos 7 e 8, o processo de síntese comportamental avaliado em termos de modelagem mostrou- se bastante intuitivo e simples, principalmente por o uso da linguagem SystemC.
O estilo de codificação em SystemC aceito por a ferramenta Cynthesizer foi dominado rapidamente e permitiu que os estudos de caso fossem implementados em pouco tempo, inclusive com reuso de codificação.
Também devido a esse estilo simples foi possível criar facilmente programas em C que gerassem automaticamente a instanciação das redes implementadas.
Quanto a a validação, o processo integrado de simulação oferecido por a ferramenta torna transparente e fácil para o projetista a realização da simulação em vários níveis de abstração, o que permite verificar funcionalmente a validade do sistema desenvolvido.
Outra vantagem observada foi a facilidade de utilizar ferramentas integradas ao ambiente de desenvolvimento, tais como Modelsim, Synplify Para o e ISE, habilitando um fluxo de projeto com bom grau de integração entre diferentes etapas, partindo da especificação inicial e chegando ao FPGA ou ASIC devidamente verificados.
Porém, conforme foi mostrado no Capítulo 4, e comprovado nos Capítulos 7 e 8, tal síntese não foi desenvolvida para contemplar projetos de estrutura de comunicação intrachip, que em geral, possuem pouco processamento e muita troca de sinais.
A qualidade em latência da descrição de hardware em nível RTL está diretamente ligada ao volume da troca de sinais entre threads que implementam um determinado comportamento, porque essas trocas precisam ser sincronizadas com sinais adicionais. Quanto mais
threads forem incluídas na implementação de um módulo e quanto mais sinais essas threads trocarem, pior será a latência do hardware derivado.
Também em consequência disso, a ferramenta gera mais hardware para conseguir controlar a sincronização especificada por o projetista.
Comparado com a codificação direta em estilo RTL, a ferramenta gera hardware com baixa eficiência em área e latência para projetos de estruturas de comunicação intrachip.
Como resultado adicional desse trabalho os estudos de caso de adaptação de algoritmos de roteamento para redes toro bidirecionais, com ou sem canais virtuais foram concluídos a contento.
Tais estudos de caso inseriram a complexidade necessária para realizar as avaliações que eram objeto deste trabalho, já que redes toro bidirecional 2D não são exploradas suficientemente na literatura.
O algoritmo de roteamento apresentado no Capítulo 7, que foi desenvolvido em parceria com o colega Carlos Scherer, trata de uma adaptação sugerida por os proponentes do modelo turn model, porém sem registros de implementação na literatura.
O algoritmo de roteamento apresentado no Capítulo 8 é uma contribuição deste trabalho e trata do suporte que a rede física oferece para permitir redes virtuais e executar dois algoritmos diferentes na mesma infra-estrutura de comunicação.
Conforme mostrado, tal suporte tem alto custo em termos de área e latência.
Também, como contribuição deste trabalho, cita- se a utilização dos produtos da ferramenta Atlas integrados ao fluxo de verificação do Cynthesizer, para que as redes pudessem ser simuladas com tráfego sintético complexo e avaliadas mais facilmente.
Como trabalhos futuros, a sugestão é a avaliação dos algoritmos de roteamento implementados em RTL para que a comparação no mesmo nível com outras redes, como a Hermes, seja realizada em termos de área e latência.
Também, como sugestão coloca- se a utilização do Cynthesizer como ambiente para integração e simulação, já que a ferramenta permite simulação em vários níveis de abstração através da iteração com outras ferramentas comerciais, de forma transparente para o projetista.
