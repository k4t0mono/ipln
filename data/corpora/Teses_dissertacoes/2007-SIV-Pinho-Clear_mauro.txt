Este trabalho consiste no estudo de técnicas de robótica e de Realidade Virtual (RV) para desenvolver um simulador que possa ser empregado nas escolas de robótica, possuindo uma visualização adequada e uma forma de interação simples e intuitiva.
Para isto, foi desenvolvido um Ambiente Virtual (AV), em linguagem C+, utilizando OpenGL.
Foram incorporados recursos de RV para melhorar a visualização e facilitar a interação do usuário com o programa.
A avaliação do ambiente foi realizada através da análise dos resultados obtidos nos experimentos realizados com usuários, em que foram gerados relatórios automáticos para as questões quantitativas, e preenchidos questionários para as questões qualitativas.
Os resultados mostraram que o uso de RV auxilia na execução da tarefa, pois melhora a visualização, reduzindo o tempo total e melhorando a precisão.
A utilização da informática na educação tem crescido nos últimos anos, sempre com o objetivo de facilitar o processo de ensino/ aprendizagem.
Para criar situações que representem a realidade, foram desenvolvidos diversos tipos de ferramentas.
Uma das técnicas mais utilizadas são os simuladores.
Primeiramente adotou- se o uso de simuladores textuais, que geralmente recebiam um arquivo de entrada ou dados digitados e geravam um relatório com os resultados.
Os primeiros simuladores gráficos criados trabalhavam com gráficos bidimensionais, possuindo uma representação simbólica da realidade.
Após isto, passaram a ser criados Ambientes Virtuais (AV), que exibem um AV tridimensional, com o qual é possível realizar interações, simulando a situação real.
Por não utilizarem recursos de RV, estes ambientes são chamados de ambientes virtuais não-imersivos.
Este tipo de sistema é muito utilizado em diversas áreas.
Apesar de esta tendência, o uso de ambientes virtuais sem imersão em alguns casos pode não ser a melhor forma de criar um ambiente eficaz para atingir o objetivo esperado, de criar aplicações com fácil interação e que representem o mundo real de forma adequada.
Um exemplo disto são as aplicações que necessitam manipular objetos tridimensionais, como aplicações para o ensino de geometria espacial, em o qual é possível criar e manipular os objetos com os formatos geométricos estudados, ou robótica em que é necessário manipular um braço de robô para efetuar uma certa operação.
Uma alternativa para solucionar este problema são os Ambientes Virtuais Imersivos (AVI), com uso de equipamentos de RV como óculos estereoscópicos, luva e rastreador.
Desta forma, pode haver um ganho significativo em relação a as aplicações tradicionais, pois a interação tornase mais próxima da realidade, sendo também mais intuitiva.
Com o uso de RV os sentidos da percepção humana podem ser melhor aproveitados, pois a visualização estereoscópica em conjunto com o rastreamento dos movimentos do usuário permitem gerar melhor visualização, uma interação mais robusta e a locomoção ao redor de o cenário.
Além de isto, recursos como tato pode permitir a geração de sensações de toque, melhorando a percepção do ambiente.
Segundo Bell, a experiência é uma poderosa ferramenta de aprendizagem, pois pode proporcionar um entendimento detalhado dos conteúdos e processos.
Os ambientes de RV possuem a característica de simular o mundo real, permitindo que os alunos experimentem as tarefas várias vezes, tendo mais chances de aprendizagem.
Além disso, com RV é possível realizar um treinamento com segurança, o que nem sempre é possível no mundo real.
Os ambientes de RV podem ainda ajudar a diminuir os custos, nos casos em que os equipamentos reais ou os materiais de reposição são muito caros, gerando aplicações mais próximas da realidade, pois permitem interação mais semelhante à realizada no mundo real.
Em este contexto, este trabalho consiste no estudo de técnicas de robótica e de RV para desenvolver um simulador que possa ser empregado nas escolas de robótica, possuindo uma visualização adequada e uma forma de interação simples e intuitiva.
O ambiente desenvolvido, chamado de VR Robotics, simula o braço mecânico ScorbotER VII, fabricado por a empresa israelense Eshed Robotec.
Este simulador possui um AV tridimensional, que permite realizar a navegação no cenário, um editor de cenários, que permite a manipulação de todos objetos da cena, e o Teach Pendant (TP), uma espécie de controle remoto com fio, que permite fazer os movimentos necessários com o robô.
Para melhorar a visualização este ambiente incorporou recursos de estereoscopia, para tornar a interação mais intuitiva foi utilizado o rastreamento da cabeça do usuário, e para descobrir qual dos dispositivos de visualização gera melhor resultado, foram utilizados três diferentes tipos.
Para validar o programa foram realizados testes com usuários, utilizando os três tipos de dispositivos de visualização, com ou sem rastreamento e estereoscopia.
O restante da dissertação é estruturado da seguinte forma:
O Capítulo 2 aborda o uso de RV no ensino em geral.
O Capítulo 3 discute aspectos conceituais importantes sobre robótica.
O como é ensinado robótica em três escolas pesquisadas.
O Capítulo 7 detalha o ambiente desenvolvido.
Finalmente, o Capítulo 8 detalha os testes realizados e os resultados obtidos.
Em o Anexo A são detalhadas as aplicações adicionais desenvolvidas, no Anexo B é exibido o componente curricular de robótica de uma das escolas pesquisadas, no Anexo C está o questionário pré-teste, no Anexo D o questionário pós-teste, no Anexo E o documento de descrição dos testes e no Anexo F estão as estatísticas dos testes dos usuários.
Ambientes de RV com objetivo educacional foram desenvolvidos para diversas áreas, como ferramentas de apoio ao ensino.
Segundo Sánchez, o uso de ambientes de RV voltados para o ensino é mais apropriado para conhecimentos abstratos, que possuem conceitos mais complexos, como teorias, regras e processos.
Isto se deve ao fato de que eles podem não ter uma correspondência clara no mundo real, por serem abstratos, teóricos ou entidades genéricas.
Além disso, estes conhecimentos são difíceis de visualizar ou imaginar, sendo então difíceis de representar em papel ou verbalmente.
Por isso os sistemas educacionais com esta finalidade têm crescido muito.
São desenvolvidas aplicações para ensinar matemática, principalmente para trabalhar com formas tridimensionais, para ensinar biologia, possibilitando a manipulação dos compostos orgânicos, além de sistemas para trabalhar com radiologia sem correr o risco da exposição à radiação, etc..
Uma das áreas em que o uso de RV se mostrou eficiente é na Geometria Espacial, pois muitos alunos têm dificuldade de imaginar as formas tridimensionais, e com um AV isto pode ser facilmente reproduzido.
O sistema VRMath, visto na Figura 1, foi desenvolvido para ajudar crianças no entendimento da geometria espacial, permitindo que o usuário crie objetos, manipule e navegue por o cenário criado.
Este programa permite que crianças criem formas tridimensionais, através de uma interface de programação de eventos, com comandos intuitivos, a partir de uma área de visualização e interação e de uma área com um fórum hipermídia, que permite o diálogo com outras crianças para tirar dúvidas.
Outra ferramenta de RV com o objetivo de ensinar geometria espacial, que também ensina outros conceitos de matemática, foi desenvolvida por Kaufmann.
Esta ferramenta se chama Construct3D, e consiste de uma ferramenta colaborativa com o uso de Realidade Aumentada (Ra), em que uma tarefa é executada por dois alunos, ou por um aluno auxiliado por o professor, que também interage no AV, como visto na Figura 2.
Por ser um sistema de Ra, o óculos utilizado é semi-transparente, permitindo que o usuário veja o mundo real com imagens virtuais sobrepostas a ele, formando o cenário desejado.
Esta técnica é interessante porque muitas pessoas perdem a orientação ao utilizar um ambiente totalmente virtual, assim, a visão do mundo real possibilita que o usuário não perca a referência.
Para criar as formas tridimensionais, numa das mãos o usuário utiliza uma caneta equipada com um rastreador e dois botões, e na outra mão uma prancheta, onde é projetado o menu da aplicação.
Em o menu existem os botões com as formas geométricas possíveis e também as operações para carregar e salvar cenários, apagar objetos, etc..
Um sistema educacional de biologia chamado MolecularStudio, visto na Figura 3, foi desenvolvido por Lu, visando ensinar algumas estruturas bio-moleculares.
Este sistema foi criado para permitir que os alunos aprendam a estrutura das moléculas navegando entre os átomos ao invés de utilizar os tradicionais modelos bio-moleculares aumentados feitos de madeira, metal ou plástico, que além de difíceis de construir, são estruturas estáticas.
Em o sistema MolecularStudio é possível interagir com as moléculas e navegar por dentro de as mesmas.
Para isto pode ser utilizada uma luva ou volante utilizados para jogos, além de o óculos do tipo shutter.
Um exemplo de uso do sistema é no estudo da estrutura do vírus HIV, que no mundo real é limitado apenas a pessoas muito especializadas.
Além de reduzir o custo, pois um laboratório deste tipo requer grandes investimentos e reposição periódica de materiais, um experimento bio-molecular real pode ser muito perigoso.
Em este sistema um grande número de estruturas biomoleculares estão disponíveis para serem observadas, tocadas e manipuladas sem risco algum e com facilidade, sendo que os dispositivos de manipulação utilizados, segundo o autor, são intuitivos.
Em este casos, deve ser tomado muito cuidado para que o AV esteja muito semelhante ao real, para que seja possível atingir o resultado esperado.
Um ambiente com essas características, chamado EyeSi, foi desenvolvido por Wagner, e pode ser visto na Figura 4.
O programa foi criado para simular cirurgias nos olhos, que, por serem micro-cirurgias, requerem precisão milimétrica por parte de o médico.
Para que o ambiente ficasse mais próximo de o real, este foi adaptado a um aparelho semelhante ao microscópio utilizado neste tipo de cirurgias, onde foram colocados pequenos displays de cristal líquido, que exibem as imagens estereoscópicas.
Em o local onde estaria o paciente foi colocada uma face artificial.
As ferramentas disponibilizadas no AV são muito semelhantes às utilizadas na cirurgia real.
Outra área da medicina em que a RV tem sido usada é no treinamento para diagnósticos por o tato, através da palpação.
Um sistema com esse propósito chamado Virtual Haptic Back (VHB), foi desenvolvido para treinamento em medicina osteopática, terapia física, terapia por massagem e áreas relacionados.
O sistema utiliza dois PHANToMs 3.0 para permitir o treinamento de palpação com as duas mãos, como visto na Figura 5.
Existem dois níveis de retorno tátil, sendo o primeiro para simular a pele e o segundo para simular os ossos.
Para informar se a vértebra escolhida é a correta, o usuário pressiona um botão com o pé, então um retorno sonoro é emitido informando se está correto ou errado.
As deficiências ósseas podem ser geradas automaticamente ou definidas por o professor antes da realização do teste.
Existem dois tipos de deficiência, sendo o primeiro uma rotação anormal de uma vértebra e o segundo uma dificuldade de dobrar a coluna em alguma vértebra.
O sistema também permite gravar as ações de um profissional para reproduzir- las aos alunos posteriormente.
A entrada dos comandos é feita por meio de uma interface gráfica, que exibe os comandos possíveis e permite a escolha.
Entre os comandos disponíveis estão:
Cortar, despedaçar, caminhar, gatinhar, escalar, puxar, molhar com a mangueira e carregar diversas ferramentas.
Em os ambientes apresentados neste capítulo, é possível perceber que alguns utilizam os recursos de RV para criar formas de interação que se assemelhem com a realidade, o que torna estes sistemas mais intuitivos e realísticos.
Porém, alguns sistemas que segundo os autores são de RV, utilizam linhas de comando como forma de interação, o que pode dificultar o uso do sistema, por não possuir uma forma direta de interação.
Um robô é um manipulador multifuncional programável, composto por mecanismos que incluem vários graus de liberdade, geralmente tendo aparência de um ou vários braços, finalizado por um punho, capaz de segurar uma ferramenta, uma peça ou algum outro dispositivo.
Em a Figura 7 é mostrado um robô modelo Scorbot-ER VII.
Este robô é capaz de mover materiais, partes, peças, ferramentas ou dispositivos específicos, através de movimentos programados, armazenados na memória, para a realização de uma grande variedade de tarefas.
Existem alguns conceitos importantes para o entendimento do funcionamento de um braço mecânico, como os segmentos que o formam, as tecnologias utilizadas para movimentar- lo, os sitemas de coordenadas existentes para posicionamento e movimentação, e os tipos de sensores utilizados.
Estes conceitos serão apresentados nas seções a seguir.
Componentes Os braços mecânicos são compostos por uma quantidade variável de segmentos, dependendo da aplicação, como visto na Figura 8, sendo os componentes básicos explicados a seguir:·
tronco (torso, body sweep):
É a primeira junta, presa ao corpo do robô, permitindo o giro do robô em torno de o eixo vertical;·
ombro (shoulder):
É a segunda junta, presa ao tronco de forma que, quando o tronco gire, todo sistema sofra uma rotação.
Em esta junta é preso o braço superior, que pode ser rotacionado para cima ou para baixo;·
cotovelo (elbow):
É a terceira junta, presa entre os braços superior e inferior, que pode ser rotacionado para cima ou para baixo;·
punho (wrist):
O punho é a última junta, presa entre o braço inferior e a garra, que pode realizar três tipos de movimentos, sendo um para rotacionar a garra em torno de o eixo horizontal, mudando a elevação (pitch), outro de rotação da garra em torno de seu centro (roll) e o último de rotação da garra em torno de o eixo vertical (yaw);·
garra (gripper):
Existem vários tipos de garra, dependendo da aplicação, como por exemplo, para pegar objetos, pintura, solda, etc..
Dependendo do tipo existem comandos para abrir, fechar, ativar, desativar, etc..
Tecnologia de Movimento Outro aspecto importante quando se analisam robôs é a tecnologia usada para criar os movimentos.
Os robôs industriais podem ser movidos de três formas, dependendo da aplicação.
A primeira forma é através de atuadores pneumáticos, utilizados quando o robô não necessita transportar uma grande carga.
A segunda forma é através de atuadores hidráulicos, que aumentam o poder de carga, mas possuem alguns problemas, pois é necessário filtrar o fluído, além de o mecanismo ser suscetível a vazamentos.
A terceira forma é através de motores elétricos, sendo de mais fácil controle, porém necessita de redutores de velocidade, que podem causar erros de operação.
Sistemas de Coordenadas Para definir a posição atual do ponto central da ferramenta, conhecido como Tool Center juntas e o sistema de coordenadas cartesianas (ou XYZ).
Para os dois sistemas, as posições podem ser absolutas ou relativas.
Para representar uma coordenada no sistema de coordenadas das juntas, é necessário armazenar o ângulo de cada junta, além de os ângulos da garra.
Em a Figura 8 é possível identificar os ângulos necessários para definir uma posição nos robôs Scorbot, que são Base (Torso), Shoulder, Elbow, Pitch e Roll.
Uma posição neste sistema pode ser representada de duas formas, sendo a absoluta, que utiliza os ângulos reais de cada junta, e a relativa, que utiliza as diferenças entre os ângulos atuais e os da posição desejada, indicando o quanto cada junta deve andar para atingir a posição relativa.
Para obter a posição atual da garra do robô neste caso é utilizada a cinemática direta, realizando um cálculo utilizando os ângulos de cada parte do robô.
Para representar uma coordenada no sistema de coordenadas cartesianas, é necessário indicar ainda o pitch e o roll da ferramenta, além de o ponto central da ferramenta no espaço tridimensional, como visto na Figura 9.
Este ponto central é representado por um ponto, que indica as coordenadas (X, Y, Z) da ferramenta em relação a o ponto de origem, localizado no centro da base do robô, quando as coordenadas forem absolutas, ou em relação a o ponto atual, no caso de coordenadas relativas.
Para obter o ângulo de cada uma das juntas, dado o TCP, é utilizada a técnica de cinemática inversa.
Sensores Segundo James, para realizar as trajetórias o robô deve evitar colisão com obstáculos, portanto os robôs podem incluir sensores, sendo alguns de eles listados abaixo:·
sensor de visão:
Com uma câmera acoplada podem ser reconhecidos objetos indesejáveis, fazendo com que o robô mude a trajetória para atingir o ponto desejado;·
sensor de voz:
Este sensor não tem a função de evitar colisões, mas permite a programação do robô através do reconhecimento de comandos de voz.
Existem várias formas de programar os robôs, sendo que algumas requerem que o usuário conheça uma linguagem de programação, e através de ela, emita &quot;comandos «para o robô.
Estas formas são chamadas de programação textual.
Já uma segunda categoria, chamada de programação não-textual, permite que o robô seja &quot;ensinado «através da movimentação física do braço mecânico, quando a trajetória desejada é armazenada de maneira automática ou manual, dependendo do tipo de programação utilizada.
Estas duas formas de programação não são mutuamente-exclusivas, podendo ser combinadas, utilizando uma forma não-textual para posicionar o robô em locais específicos, e a forma textual para realizar os movimentos, passando por estas posições.
Programação textual A programação textual consiste em escrever um programa contendo os comandos necessários para o robô realizar a tarefa desejada.
Alguns modelos trazem acoplados um monitor e um teclado, permitindo a programação diretamente no robô, outros permitem a conexão a um computador por a porta serial ou USB, outros permitem a entrada do programa por disquete.
Um dos problemas enfrentados neste caso, é que existem diversas linguagens de programação, pois não existe um padrão entre os fabricantes.
Os comandos dos robôs incluem deslocamento para uma posição absoluta, ou para uma posição relativa à posição atual.
Para isto é necessário gerar uma trajetória, que é calculada por o micro-controlador do robô.
A programação textual pode ser dividida em três classes:
Orientada a juntas, orientada a manipuladores e orientada a tarefas.
As características de cada classe são apresentadas a seguir.
Em a programação orientada a juntas, o programa é baseado no nível das juntas, sendo que em cada movimento são informados detalhes sobre cada um dos atuadores do robô.
Tipicamente uma instrução indica uma seqüência de movimentos das juntas do robô, da seguinte forma:
JMOVE q1, q2, q3, q4, q5, q6.
Em este caso as variáveis de q1 a q6 representam cada junta do robô.
O valor informado é um ângulo ou um deslocamento, dependendo do tipo de junta.
Um exemplo de linguagem deste tipo é ARMBASIC, para o Microbot Minimover 5.
Em a programação orientada a manipuladores os comandos guiam o ponto central da ferramenta (TCP -- Tool Center Point) de um local a outro.
Em muitos sistemas o programa pode ser construído nas coordenadas cartesianas, cilidricas ou da ferramenta.
Ainda podem ser incorporados comandos para informar tempos de espera, abrir ou fechar a garra, etc..
Em este tipo de programação, a conversão da posição desejada para os valores dos ângulos em cada junta é feita automaticamente por o software do robô.
Uma instrução de deslocamento neste caso é representada na seguinte forma:
Move px, py, pz,,.
Onde px, py, pz representam a posição da ferramenta e, representam os ângulos de orientação global do robô.
Exemplos deste tipo de linguagem de programação são VAL para o Unimation Puma, Sigla para o Oliveti Sigma e TEACH para o Bendix PACS.
A programação orientada a tarefas é considerada a segunda geração de linguagens de programação de robôs.
Este tipo de linguagem permite executar tarefas mais complexas, provê construções para controlar múltiplos braços mecânicos em cooperação, aceita instruções mais abstratas e menos detalhadas, além de ter uma melhora na eficiência e ser mais fácil de programar, por ser mais similar à linguagem falada.
Os programas construídos precisam modelar todo o ambiente de trabalho dos robôs, além de registrarem os movimentos dos objetos reais.
Normalmente, para que os robôs possam aceitar os comandos, é necessário ter uma descrição precisa do cenário, com os seguintes itens:·
descrição geométrica de todos objetos;·
descrição das características físicas de todos objetos, como massa e inércia;·
descrição geométrica dos robôs;·
descrição das características dos robôs, como limite das juntas, aceleração, e características dos sensores;·
posições de todos objetos.
Estas linguagens aceitam instruções como:
Coloque A Peça Em o Orifício.
Exemplos de linguagens dessa categoria são:
AL, desenvolvida no Laboratório de Ia de Stanford, AUTOPASS da IBM, Lama da MIT e Lama-S da Iria, na França.
Programação não-textual A programação textual permite a criação de programas complexos, controlando até mesmo mais de um robô ao mesmo tempo, porém, o programador precisa conhecer a fundo a linguagem de programação, além de ser demorado.
Em face destes problemas, foram desenvolvidas algumas formas de programar- se um robô sem precisar conhecer a linguagem de programação do mesmo.
Algumas dessas formas são explicadas nas seções a seguir.
Walk--through é o tipo de programação em que o operador faz o robô percorrer a trajetória desejada com as mãos.
Em esse caso, chaves e botões no painel de controle são usadas para especificar quando entrar ou sair do modo de programação, indicar a taxa de amostragem para armazenar os pontos, executar o movimento gravado, ou excluir um movimento.
Para gerar um programa, o operador guia o braço do robô com as mãos, percorrendo a trajetória desejada, na velocidade desejada.
Para que seja possível realizar essa trajetória, o robô possui mecanismos que permitem que o braço fique leve quando entra no modo de programação.
Enquanto isto ocorre, os sinais analógicos gerados por o movimento são convertidos para a linguagem do robô e gravados, de modo que o robô possa percorrer a trajetória novamente.
A vantagem deste tipo de programação está na facilidade de utilização, pois nenhum conhecimento de linguagem de programação é necessário.
Já a desvantagem é que caso seja cometido um erro, todo movimento deve ser feito novamente.
Lead-through é um dos tipos mais comuns de programação de robôs industriais.
A programação é feita através de um dispositivo de comando manual, como um controle remoto com fio, que permite fazer os movimentos necessários com o robô.
Este dispositivo é comumente chamado de Teach Pendant (TP), e possui funções para mover ou rotacionar cada junta, abrir ou fechar a garra, registrar a posição atual do TCP, etc..
Em este caso, para realizar a programação, o operador move o robô com o TP, realizando a trajetória desejada e salvando posições-chave do movimento desejado.
Enquanto o robô é ensinado, as posições, velocidade e tempo de espera são gravados, sendo que durante a execução do programa, o controlador se encarrega de realizar os movimentos necessários para levar o robô até a posição desejada.
A trajetória criada pode ser gravada como um programa, que o robô é capaz de executar, repetindo o movimento armazenado.
As vantagens deste tipo de programação são:·
a possibilidade de se programar muitas funções especiais, como tempo de espera e velocidade de movimento;·
a capacidade de edição é melhor que no walk-- through;·
a criação de programas maiores que no walk-- through, pois com o TP normalmente são armazenados apenas os pontos extremos de cada reta da trajetória.
Algumas desvantagens deste tipo de programação são:·
permite a programação do robô somente no modo on-line;·
permite apenas a criação de programas simples, com ramificações limitadas;·
exige grande habilidade do operador para movimentos mais complexos.
Existem ainda outras formas de programação não-textual, que não serão abordadas aqui por 5 Sistemas computacionais para ensino de robótica O uso de robôs reais para ensino de robótica é inviável para muitas escolas, devido a o alto custo do equipamento.
Segundo Jason, existem quatro opções viáveis para ensinar robótica nas escolas, que são:·
utilizar robôs educacionais de baixo custo;·
utilizar simuladores educacionais de baixo custo;·
utilizar simuladores com RV;·
utilizar simuladores juntamente com um ou mais robôs reais, para executar os programas criados nos simuladores.
Os robôs educacionais possuem baixa confiabilidade, os simuladores de baixo custo, em geral, possuem várias limitações, além de dificultar o uso, pois geralmente não possuem uma visualização adequada.
Por isto, os simuladores com RV estão se tornando uma alternativa interessante ao ensino.
Existem diversos tipos de sistemas de simulação de robótica, divididos em sistemas comerciais e sistemas não comerciais, sendo que alguns utilizam recursos de RV, outros podem ser acessados por a Internet permitindo inclusive, em alguns casos, acesso a um laboratório real remotamente, através da Internet, como visto nas seções a seguir.
Sistemas comerciais Os simuladores comerciais aqui apresentados possuem uma área de visualização 3 D, permitem a conexão com o robô real e a programação tanto na forma textual quanto na forma não-textual, podendo- se misturar as duas formas.
Segundo os fabricantes, estes programas são simuladores RV, porém não incluem suporte a dispositivos de RV.
Então, nas categorias de Jason, estes simuladores se enquadram na categoria de simulador com RV, por não serem simuladores de baixo custo e possuirem visualização 3D.
Para os modelos de robôs Scorbot fabricados por a empresa israelense Eshed Robotec, existe o simulador RoboCell, criado por a empresa americana Intelitek, visto na Figura 10.
Este simulador integra um programa antigo da mesma empresa, chamado de Scorbase, com um módulo gráfico 3 D, a fim de permitir a criação de programas, simulação da execução e a obtenção dos pontos da trajetória desejada sem a necessidade de um robô real.
O simulador permite o envio dos programas criados para o robô real, bem como a simulação sincronizada com o robô real.
Em este simulador, uma célula consiste na descrição do cenário em que o robô está inserido, colocando uma representação dos objetos próximos ao robô, como mesa, peças, caixas, etc..
Para programar o robô podem ser combinadas a forma textual com a forma não-textual.
A forma não-textual de programação é feita diretamente na interface gráfica da célula virtual, permitindo a realização de rotações na câmera, a aplicação de zoom para aumentar a precisão, a visualização das posições dos objetos, o ajuste das posições gravadas, além de outras funções.
Estas posições gravadas são conhecidas como pontos de referência, e são os pontos-chave utilizados para movimentar o robô durante a execução de um programa, sendo usados na maioria das metodologias de programação.
Existem duas formas de marcar este pontos:·
movimento manual:
Em uma tela com funções similares às disponíveis no TP real, é possível realizar manualmente o movimento de uma das juntas do robô;·
movimento automático:
O robô movimenta- se automaticamente até uma posição indicada, sendo necessário para isto informar os valores de x, y, z, pitch e roll.
A forma textual de programação é feita através de uma linguagem de programação própria do simulador que possui operadores de comparação, permite a criação de sub-rotinas para melhor organização do código e possui comandos intuitivos e simples, utilizando as posições armazenadas, como por exemplo &quot;vá para a posição 1 com velocidade 5», &quot;abra/ feche a garra «ou &quot;pule para o label início».
Em esse caso, os labels servem para permitir a criação de laços de repetição, possibilitando a execução repetida de um conjunto de operações.
Além de isto, existem comandos como o salto condicional, salvamento da posição atual, criação de variáveis, impressão de valores na tela, etc..
Para evitar que o usuário tenha que decorar os comandos, eles são selecionados numa lista com todos os comandos disponíveis, preenchendo- se em seguida os parâmetros adicionais do comando escolhido, como por exemplo o ponto ou label.
Com o uso deste programa, o valor gasto para montar um laboratório diminui, pois cada robô Scorbot custa aproximadamente U 6.500, enquanto cada licença do programa custa aproximadamente U 1.000.
Desta forma, segundo Jason, o ideal é ter o programa instalado em várias máquinas e um ou dois robôs reais, para executar os programas depois de prontos, para que todos alunos possam aprender a programar.
Apesar de diminuir o custo, este programa ainda possui um valor elevado, dificultando a criação de laboratórios para grandes turmas.
O VR Robot dispõe de um AV 3D para simulação, sendo possível fazer a integração com o robô real.
Em este simulador o usuário pode programar tanto de forma não-textual, através de uma interface similar ao TP, chamada de VR teachbox, quanto de forma textual, com os comandos do robô, permitindo que os programas criados no simulador sejam enviados ao robô.
Juntamente com o simulador existe uma biblioteca de modelos 3 D, que podem ser colocados na célula de simulação para tornar o ambiente similar ao real, simulando também a detecção de colisão com os objetos.
Além de isto, o ambiente permite simular dois robôs ao mesmo tempo, o que é útil para testar algum tipo de trabalho colaborativo entre os robôs.
Para o caso de não ser utilizado nenhum robô real, existe o simulador HandlingPRO, da empresa FANUC Robotics, visto na Figura 12, baseado nos robôs da empresa FANUC.
Este simulador possui um ambiente 3D para criação de células de trabalho, que permite tanto o uso dos objetos que acompanham o programa quanto os modelados por o usuário, em ferramentas de CAD.
Com isto é possível criar ambientes com mais de um robô e com todos objetos que ficam em volta do robô no ambiente real, possibilitando a verificação de colisão com objetos ou até mesmo outros robôs durante a execução da simulação.
Como no caso de o RoboCell, este programa permite também a edição dos programas através do TP.
Além disso, uma simulação pode ser gravada num arquivo de vídeo no formato AVI.
Sistema de realidade virtual para ensino de robótica As formas tradicionais de se programar robôs textualmente podem tornar- se pouco intuitivas para usuários iniciantes, pois o operador necessita conhecer a linguagem de programação do robô e ainda deve ser capaz de resolver o problema através de algoritmos, existindo a necessidade de realizar muitos testes até que o robô realize o movimento esperado.
Outro fator complicador é a existência de linguagens diferentes, dependendo do fabricante do robô.
Já na forma não-textual, com o uso de um TP, fica difícil criar movimentos complexos.
A taxa de atualização do rastreador é bem superior à taxa permitida por o protocolo da porta serial, então, para tornar possível esta comunicação é necessário realizar uma filtragem nos dados.
A filtragem é feita em duas etapas, primeiro eliminando- se os pontos iguais ou muito próximos ao último ponto enviado, assumindo- se desse modo que o usuário manteve a mão parada por algum tempo.
Em seguida são eliminados os pontos colineares desnecessários, pois formando uma reta apenas os extremos são necessários.
As trajetórias realizadas podem ser armazenadas, para não ser preciso executar o mesmo movimento várias vezes.
Além de a operação remota foi criado um ambiente de RV, visto na Figura 14, que permite visualizar a trajetória do robô no próprio ambiente, utilizando o monitor ou um óculos de RV, onde pode ser acoplado um rastreador de posições, para permitir girar em torno de o robô virtual.
Com a criação deste ambiente não é necessário ter o robô físico sempre que se desejar criar uma trajetória, além de permitir que a trajetória seja testada no simulador antes de enviar para o robô, o que diminui o risco no caso de ser cometido um engano.
Internet (Simulado) Como alternativa de aplicações de simulação mais acessíveis, foi criado por Martin um simulador de robótica que pode ser executado através de um navegador de Internet, em qualquer computador.
O simulador foi criado utilizando a linguagem VRML 2.
0, que pode ser executada em qualquer navegador, necessitando apenas de um plugin.
A dificuldade encontrada neste caso foi na manipulação do robô, pois VRML não permite a utilização de um mouse 3D.
Para resolver este problema foi criada uma interface com ícones, que representam as ferramentas que permitem o controle do robô através do mouse.
Esta interface pode ser vista na Figura 15.
Em esta aplicação, todas as movimentações do robô são iniciadas a partir de eventos, chamados a cada mudança de ângulo ou posição.
Cada evento contém as informações necessárias para realizar os movimentos desejados, que podem ser feitos de duas formas, definindo diretamente a posição ou rotação de cada junta ou então determinando a posição para onde o robô deve ir.
De essa forma, para posicionar a ferramenta corretamente são utilizados os cálculos de cinemática direta ou inversa, de acordo com o tipo de movimento desejado.
Em esta aplicação, os autores pretendem numa versão futura possibilitar a realização de experimentos reais.
Para isto seria gerada uma visualização do robô real, através de imagens capturadas por uma câmera.
Em este caso, a interação com um robô real se daria através de um servidor conectado ao robô real, num laboratório remoto, que faria a leitura dos eventos gerados por o usuário e os passaria para o robô real, movendo o robô virtual a cada movimento do robô real, através da geração de um evento no aplicativo VRML.
Experimentos de controle de robôs reais por a Internet Aplicações que além de simular a programação do robô permitem executar o programa no robô real, tornam o aprendizado mais rico.
Existem formas de tornar possível a execução de programas no robô real através da Internet.
Com este tipo de aplicação, é criado um laboratório real acessível de qualquer parte do mundo.
Uma aplicação deste tipo foi criada por Riko.
Em esta aplicação foi criado um simulador em VRML, visto na Figura 16, com uma célula de trabalho semelhante a uma célula real.
Em este simulador foi implementada a detecção de colisão entre o robô e os objetos do cenário, utilizando a biblioteca v-Collide, pois além de tornar a aplicação mais real, evita colisões entre o robô real e os objetos, o que não poderia ser controlado à distância em tempo hábil.
Para mostrar os modelos em VRML e os movimentos no AV, foi utilizada a biblioteca VRaniML.
O robô utilizado foi o MA2000, um braço mecânico de seis eixos fabricado por a empresa TecEquipment Ltd.
Foi feita uma integração entre o programa do robô, as bibliotecas e a interface VRML, possibilitando a execução remota.
A interface com o robô real ocorre através do envio do arquivo com a tarefa, através de um formulário numa página PHP.
A Figura 17 mostra a organização do programa.
Quando o robô não estiver disponível, é possível colocar a tarefa na fila, para ser executada mais tarde.
Em este caso, um vídeo é gravado mostrando a execução da tarefa, podendo ser visualizado por o usuário posteriormente.
Para o desenvolvimento do presente trabalho, foram pesquisadas três escolas que ensinam a programação de robôs:
Faculdade de Tecnologia (FATEC) SENAI Poa, curso superior em Automação Industrial e curso Técnico em Eletrônica, Laboratório CIM -- Faculdade de Engenharia Mecatrônica -- Pontifícia Universidade Católica do Rio Grande do Sul, e Escola de Educação Profissional SENAI Ney Damasceno Ferreira -- Curso Técnico em Mecatrônica, Gravataí-RS.
Em estas escolas são trabalhados conceitos como cinemática direta, cinemática inversa e definição de pontos de referência para a criação de programas.
A metodologia de programação usada nas escolas pesquisadas baseia- se principalmente na definição destes pontos de referência para se criar trajetórias do robô.
Segundo esta metodologia, primeiramente o robô deve ser posicionado com o TP no ponto desejado, que é então gravado numa posição de memória do robô.
Em os programas, quando for necessário movimentar o robô para esta mesma posição, utiliza- se apenas o endereço da memória em que o ponto foi gravado.
De as escolas pesquisadas, apenas a FATEC utiliza o simulador RoboCell no laboratório.
Devido a o alto valor das licenças, é utilizado um simulador para cada dois alunos.
Em esta escola existem três robôs Scorbot Er-4 que são utilizados apenas para testar os programas prontos, depois de funcionarem no simulador.
Estes robôs permitem controlar até dois dispositivos externos, no caso, a escola possui apenas dois dispositivos adicionais, sendo uma mesa eletropneumática da marca Festo, com coordenadas X, Y, Z e uma ferramenta de sucção, e uma bancada eletropneumática também da marca Festo.
A PUCRS possui um Laboratório de Manufatura Integrada por Computador (CIM), visto na Figura 18, onde são ministradas duas disciplinas:
&quot;Programação de Robôs e Sistemas Robotizados «e &quot;Sistema de Fabricação».
O laboratório é composto por um sistema de manufatura flexível completamente controlado por computadores.
O sistema contém seis estações para manufatura, controle de qualidade, montagem de peças e produtos.
As estações de manufatura e montagem são integradas por meio de um sistema de transporte automatizado de robôs.
Programas específicos integram todos os aspectos do planejamento e operação do sistema, desde o gerenciamento de pedidos de clientes até o controle de dispositivos e máquinas CNC.
O laboratório CIM engloba, de forma multidisciplinar, todos os aspectos de um sistema moderno de produção.
CNC. O torno CNC pode ser acionado por os robôs, que podem abrir ou fechar a porta do torno e iniciar um programa gravado na sua memória.
A quarta estação é utilizada para controle de qualidade e é composta por um robô MK3, um paquímetro digital e um altímetro.
A quinta e última estação é a de montagem, composta por um robô SCARA ER14, visão, mesa XY e uma Parafusadeira Pneumática, permitindo selecionar o local para o qual as peças serão enviadas, soltando no local correto ou então mandando de volta para o almoxarifado.
Em a PUCRS foi desenvolvido um simulador textual, capaz de compilar os programas e simular a execução sem representação gráfica.
Um dos objetivos deste simulador é eliminar os erros de sintaxe do programa antes de submeter- lo ao robô.
Este programa possui também um terminal, que pode trabalhar em dois modos, sendo o primeiro de eles conectado ao robô real, enviando os comandos digitados por o usuário e exibindo as respostas do robô, e o segundo modo consiste em emular o terminal do robô real, através de uma simulação sem visualização gráfica.
Em a escola do SENAI de Gravataí, além de dois robôs Scorbot Er-VII, fabricados por a empresa israelense Eshed Robotec, existem duas esteiras, que podem ser controladas por os robôs, através dos programas em ACL, sendo ligados a uma saída do robô, e uma mesa de experiência fabricada na própria escola, que possui quatro saídas e também é ligada ao robô, indicando se existe ou não um objeto sobre cada um de seus sensores.
A título de exemplo, no Anexo B existe uma tabela que mostra o conteúdo de robótica ensinado nesta escola, mostrando os objetivos, assuntos tratados e os recursos didáticos utilizados em cada aula.
De um curso de vinte e sete aulas, quatro são dedicadas ao conhecimento do TP e a marcação de pontos e doze (44%) são dedicadas à programação, o que indica que a ênfase está na programação do robô com programas em linguagem ACL, a fim de controlar o robô e os periféricos a ele associado.
Apesar de ser ensinada programação nas aulas posteriores ao ensino do uso do TP, a partir de o início do uso deste dispositivo, sempre será necessário usar- lo para viabilizar a programação, pois os exercícios passados exigem a manipulação de peças e controle de periféricos ligados ao robô, sendo que a posição para buscar as peças é descoberta com o TP.
Praticamente todas escolas de robótica do SENAI utilizam robôs da linha Scorbot.
Apesar de o uso de um simulador enriquecer o ensino, muitas escolas não incluíram sua utilização na metodologia de ensino, utilizando apenas a chamada programação Off-LINE, que consiste em criar o programa num editor de texto qualquer, realizando o envio ao robô através de um computador conectado à ele.
Isto acontece porque o programa que acompanha os robôs da linha Scorbot, chamado Scorbase, permite a criação de programas somente numa linguagem semelhante à língua inglesa (ou portuguesa ao se trocar o idioma), não permitindo a programação em ACL, linguagem nativa dos robôs Scorbot, que é ensinada nestas escolas.
O programa não possui uma visualização gráfica, e o TP comanda diretamente o robô real.
Uma alternativa seria adotar o simulador RoboCell, porém o alto valor das licenças inviabiliza sua adoção.
Para tentar resolver este problema, o SENAI-RS optou por desenvolver seu próprio simulador de robótica com visualização 3D.
Este simulador, chamado de Asimov, foi desenvolvido durante o ano de 2001, no Núcleo de Informática Educacional -- NIED, e pode ser visto na Figura 19.
Este simulador será detalhado aqui por ter servido de modelo para o desenvolvimento do VR-Robotics, que procurou solucionar alguns problemas apresentados por o O Asimov possui quatro ambientes:
Visualização 3 D, Teach Pedant, Editor de Células e Cenários e o Terminal de Programação ACL.
Em a Visualização 3D é exibido o AV 3D, contendo o robô e os outros objetos, conforme o ambiente atual.
O Teach Pendant, permite manipular o robô e seus periféricos e gravar posições de memória.
O Editor de Células permite criar e editar novos cenários e o Terminal de Programação em ACL é composto por o terminal de controle do robô e por o editor de programas, sendo que um programa deve ser escrito no editor e enviado ao robô por o terminal, que ainda possui os comandos adicionais do robô real, como listar e executar programas, declarar variáveis globais, etc..
Nenhuma escola do SENAI adotou o Asimov como ferramenta nos cursos, devido a alguns problemas que dificultam seu uso, como segue:·
problemas na execução de comandos no Terminal de Programação ACL;·
tamanho reduzido da área de Visualização 3 D, com percepção tridimensional pobre;·
dificuldade de navegação no cenário, misturando o uso de mouse e barras de rolagem, e não permitindo o deslocamento lateral do usuário;
A conjugação de todos estes problemas inviabilizou o uso do Asimov nas escolas, pois havia grande dificuldade para marcar os Pontos de Referência utilizando o software.
Em o SENAI de Gravataí, por não adotar o Asimov, ainda ensina- se os alunos a programarem no modo Off-LINE.
Esta metodologia mostra- se bem mais trabalhosa, pois os alunos possuem pouco tempo para operar o robô, sendo que no caso de o programa conter erros, os alunos precisam consertar- los e esperar novamente para testar no robô.
Em face de os problemas apresentados para adoção de um simulador gráfico nas escolas do SENAI, inicialmente se pretendia solucionar os problemas adaptando o simulador ASIMOV e inserindo em ele recursos de RV, mas isto não foi possível pois exigiria uma remodelagem completa do programa, além de exigir o uso de placas de vídeo especiais com suporte a estereoscopia, custando mais caro que uma licença do RoboCell.
Constatou- se então a necessidade do desenvolvimento de um novo simulador, capaz de reduzir os problemas citados acima, em especial, no que diz respeito à forma de navegação e ao posicionamento da garra de maneira mais precisa.
Como visto, as escolas de robótica em sua maioria possuem necessidade de um simulador gráfico eficiente e barato.
Para tentar resolver este problema, foi desenvolvido um simulador, apresentado no capítulo seguinte.
O AV denominado VR Robotics, visto na Figura 20, foi desenvolvido com o objetivo de criar um simulador que pudesse ser empregado nas escolas de robótica, possuindo uma visualização adequada e uma forma de interação simples e intuitiva.
Isto porque simuladores disponíveis nas escolas apresentaram problemas de visualização e navegação, por isto este simulador foi criado utilizando técnicas para melhorar a visualização e navegação por o ambiente, empregando diversos dispositivos, para que fosse possível testar a melhor forma de visualização e rastreamento, permitindo assim que se avaliasse qual conjunto de dispositivos melhor resolvia cada problema.
Em o VR Robotics o aluno pode basicamente encontrar os pontos de referência, movendo o robô com o TP até atingir a posição desejada, que é então gravada numa posição de memória do controlador do robô, podendo ser utilizada posteriormente nos programas ACL.
Este ambiente foi desenvolvido com base no Asimov, descrito no capítulo anterior e também simula o braço mecânico Scorbot Er-VII.
Este robô utiliza motores elétricos como tecnologia de movimento e possui duas formas de programação, a forma não textual, que é do tipo Leadthrough (através do Teach Pendant) e a forma textual, com a linguagem ACL, que é orientada a manipuladores.
Porém, no VR Robotics a operação do robô é feita apenas através do TP, pois não foi implementada a execução de programas ACL nem o terminal do robô, sendo necessário a existência de uma integração entre o VR Robotics e o Asimov, que é capaz de realizar estas duas tarefas.
Para isto, os pontos gravados com o TP utilizando o VR Robotics são salvos num arquivo, sendo então utilizados nos programas ACL simulados no Asimov.
Além de o VR Robotics foram desenvolvidas aplicações adicionais para auxiliar seu uso, que podem ser vistas no Anexo A. A principal destas aplicações é o Config, que permite informar o conjunto de dispositivos que serão utilizados com o VR Robotics.
As outras duas aplicações servem para rastreamento remoto, sendo uma de elas com uma câmera e outra com um rastreador magnético.
Para tentar resolver o problema existente no Asimov, referente a a área de visualização 3D pequena e com percepção tridimensional pobre, no VR Robotics foi empregado o uso de estereoscopia, que pode ser utilizada com três dispositivos de visualização diferentes.
Já a questão da locomoção e orientação do usuário dentro de o AV foi tratada possibilitando a interação tanto com um mouse quanto com um teclado ou um joystick, sendo que qualquer um destes dispositivos possui acesso às principais funções para posicionamento do usuário e manipulação do robô.
Notou- se durante a feira Globaltech 2006, onde o VR Robotics esteve em teste, que usuários que não possuem conhecimentos de informática, mas conhecem algum videogame, conseguem aprender facilmente a se deslocar por o ambiente e manipular o TP utilizando um joystick.
Em as seções a seguir são apresentados a interface do VR Robotics e os dispositivos utilizados para rastreamento e visualização.
Interface do VR Robotics O VR Robotics possui como janela principal o cenário 3 D, existindo ainda outras duas janelas, uma para o Editor de Cenários, na janela superior esquerda e outra para o TP 2D, na janela superior direita.
Em as seções a seguir serão explicadas as funções destas janelas.
O ambiente 3D pode ser exibido numa janela ou em tela cheia.
Em o ambiente é possível navegar utilizando um joystick, mouse ou teclado, com comandos de deslocamento, rotação e troca de vistas pré-definidas.
Para permitir a criação de novos ambientes, ou a edição dos ambientes já existentes no VR Robotics, foi criado um Editor de Cenários, que permite adicionar /remover/posicionar no ambiente elementos como robô, peça, esteira, mesa giratória, escaninho, mesa de experiência e torno CNC, cujas representações 3D podem ser vistas na figura 21, sendo que cada objeto está identificado na figura.
Para permitir uma simulação correta, cada ambiente deve possuir somente um robô, que pode ser associado, neste editor, a periféricos como a esteira e a mesa giratória, sendo então acionados através do TP.
Este editor de cenários é semelhante ao do Asimov, e os ambientes gerados no VR Robotics podem ser utilizados no Asimov e vice-versa, permitindo assim uma integração entre estas duas ferramentas.
Teach Pendant 2D Este controle, visto na Figura 22, foi criado para permitir a manipulação do robô e obtenção dos pontos de referência.
O TP é exibido numa janela 2 D, e permite a movimentação dos eixos do robô, das mesas e das esteiras, permitindo também a alteração na velocidade de movimentação destes dispositivos.
Sua imagem é idêntica a do TP real.
Com este controle também é possível gravar a posição atual do robô numa posição de memória, bem como enviar o robô à uma posição previamente gravada.
Além de isto, é possível alterar a forma de movimentação do robô, que pode ser por juntas ou por eixos cartesianos X, Y, Z. Rastreamento Para resolver o problema de navegação pouco intuitiva existente no Asimov, foi utilizado rastreamento do usuário, como ferramenta para tornar mais intuitiva a interação com um AV.
Com o rastreamento da cabeça do usuário, o mesmo pode mudar sua orientação e até mesmo seu posicionamento no AV apenas movimentando a cabeça, sem a necessidade de pressionar tecla alguma, auxiliando na visualização do ambiente de forma semelhante à real.
Já com o rastreamento da mão do usuário, é possível movimentar um apontador, que pode ser usado, por exemplo, para selecionar um botão do TP.
Para testar qual dos dispositivos de rastreamento traz melhor resultado, no VR Robotics foram utilizadas três formas de rastreamento, como visto nas seções a seguir.
O rastreador Polhemus Isotrack II possui dois sensores, podendo- se utilizar um de eles para rastrear a cabeça do usuário e outro para a mão, como visto na Figura 23.
Cada sensor trabalha com seis graus de liberdade, fornecendo posição e orientação nos três eixos coordenados, porém alguns movimentos foram limitados.
Para a cabeça do usuário foi desabilitada a translação no eixo vertical, enquanto que para a mão foi utilizada apenas a translação nos eixos vertical e horizontal, evitando que os usuários realizem movimentos que os façam perder a orientação no AV.
Outro tipo de rastreador magnético suportado é o rastreador de giro, que vem embutido em alguns modelos mais antigos de óculos Head Mounted Display (HMD).
Este rastreador não permite a locomoção do usuário, mas reconhece o giro com boa precisão, permitindo que o usuário olhe em qualquer direção do cenário.
Um terceiro rastreador é o Cyber Track II, que tem características semelhantes ao rastreador do HMD.
Este dispositivo pode ser usado apenas para rastreamento da cabeça do usuário, pois a seleção de um botão do TP exige o deslocamento da mão.
Para utilizar este dispositivo, é aconselhável acoplar- lo ao óculos HMD, para que ele gire junto com a cabeça do usuário.
O rastreamento ótico é feito com o uso de uma câmera, como visto na Figura 24 e foi implementado utilizando- se a biblioteca ARToolkit.
Esta biblioteca faz o reconhecimento de marcadores (etiquetas), que devem ser presos nos pontos que se deseja rastrear.
Em o caso foram usadas duas etiquetas, uma para o movimento da cabeça do usuário e outra para o movimento da mão.
Cada sensor trabalha com seis graus de liberdade, porém se o sensor sair do foco da câmera, perde- se as informações de rastreamento.
Por isto, ao utilizar esta forma de rastreamento deve- se evitar a locomoção dos usuários fora de o campo de visão da câmera.
O monitor foi utilizado por ser um dispositivo que está presente em qualquer computador, permitindo a utilização do simulador sem o uso de nenhum equipamento especial.
A ativação da estereoscopia é feita através de um Shutter Glasses, como visto na Figura 25.
Uma vantagem deste dispositivo é o uso do simulador num ambiente em que os usuários já estão acostumados a trabalhar.
Além de isto, o monitor permite o uso da maior resolução de vídeo suportada por o computador, o que nos outros dispositivos pode não ser viável.
O HMD foi utilizado por ser o dispositivo que proporciona uma maior imersão do usuário no AV, uma vez que a visão do mundo real fica bloqueada.
Este equipamento, visto na Figura 26, permite que a visualização seja feita diretamente em ele, utilizando ou não estereoscopia, pois possui um visor para cada olho.
Isto possibilita maior interação, considerando que o usuário fica livre para girar a cabeça e até mesmo realizar pequenos movimentos sem perder a visualização.
Com o uso do HMD, a visualização do ambiente é feita em primeira pessoa, dessa forma, os movimentos do usuário são refletidos no ambiente como se o mesmo estivesse dentro de o cenário virtual, podendo- se, dependendo do tipo de rastreamento, olhar em qualquer direção e também locomover- se.
A vantagem de uso desta configuração está na facilidade de interação, sendo a mais intuitiva no deslocamento e orientação do usuário, uma vez que a visualização está no próprio óculos e o rastreamento adapta o vídeo do usuário de acordo com o movimento da cabeça.
A desvantagem desta configuração está na resolução da imagem, que não pode ser muito alta por limitações do HMD.
A maioria dos modelos de HMD trabalham com uma resolução fixa, de 640x480 ou 800x600 pontos.
A tela de projeção foi testada como dispositivo de visualização por permitir a geração de imagens que podem ser visualizadas por várias pessoas ao mesmo tempo, como visto na Figura 27, porém, apenas um usuário pode utilizar um teclado, mouse ou joystick para comandar o robô.
Para ativar a estereoscopia neste dispositivo é necessário o uso de dois projetores em conjunto com lentes polarizadoras, de forma que as duas imagens sejam projetadas uma sobre a outra, numa tela especial, que não desfaz a polarização quando recebe a projeção, permitindo que cada olho receba a imagem de apenas um dos projetores com o uso de um óculos polarizado de papel.
Escolha da configuração ideal Cada um dos recursos apresentados neste capítulo tem vantagens e desvantagens.
Uns são mais fáceis de usar mas tem um custo elevado, outros permitem que vários usuários observem o ambiente e outros são restritos a apenas um usuário.
Além de isto, há a possibilidade de várias combinações entre dispositivos de rastreamento e dispositivos de visualização.
Para avaliar estas diversas alternativas tanto sob o aspecto de eficiência (precisão e rapidez para a obtenção dos pontos de referência) quanto de aplicabilidade (viabilidade econômica e didática) decidiu- se realizar um conjunto de testes com usuários.
Em estes testes foram feitas comparações de diversas configurações do VR Robotics entre sí, bem como comparações do VR Robotics com o Asimov.
O detalhamento dos testes é apresentado no próximo capítulo.
Aspectos de implementação O simulador VR Robotics foi implementado em C+, utilizando a biblioteca OpenGL para desenhar o cenário virtual, juntamente com a GLUT para criação da janela principal do programa.
A biblioteca SmallVR1 foi utilizada para o gerenciamento dos objetos no cenário virtual, carregamento dos modelos 3D e comunicação com alguns dos equipamentos de RV.
A biblioteca ARToolkit foi utilizada para o rastreamento ótico, exigindo ainda a utilização das bibliotecas DirectShow Video Processing Library (DSVL) 2 e DirectX para comunicação com a câmera.
Para comunicação com o rastreador interno foi utilizada a biblioteca World Toolkit (WTK).
Para a criação das janelas exibidas no cenário virtual foi desenvolvida uma biblioteca, pois nenhuma das bibliotecas encontradas atendia os requisitos necessários.
O diagrama de classes simplificado do VR Robotics é exibido na Figura 28 e o diagrama de atividades simplificado é apresentado na Figura 29.
Para a resolução do problema da cinemática inversa foi realizada uma conversão da função existente no Asimov, que é desenvolvido em Delphi e resolve este problema corretamente.
Para facilitar esta conversão, o modelo 3D do robô utilizado no VR Robotics possui os eixos com as mesmas dimensões do robô utilizado no Asimov.
Além de o VR Robotics foram desenvolvidas aplicações auxiliares, sendo a principal de elas a «config.
Exe», criada para permitir a escolha dos parâmetros de execução do programa principal.
Para executar o rastreamento por câmera no modo remoto foi criado o programa «server_ camera.
Exe», cuja função é fornecer a posição dos padrões para o programa principal.
Já para o rastreamento com o Polhemus Isotrack Interno foi criado o programa «server_ internal_ track.
Exe», cuja função é fornecer as informações de rastreamento.
Estas aplicações são melhor detalhadas no Anexo A. Objetivos O objetivo geral deste trabalho foi realizar um estudo de técnicas de robótica e de RV para desenvolver um simulador que possa ser empregado nas escolas de robótica, possuindo uma visualização adequada e uma forma de interação simples e intuitiva.
Para concretizar este objetivo foi construído um simulador do robô Scorbot Er-VII.
Em este simulador o usuário controla um robô virtual dentro de uma célula de manufatura1, utilizando recursos de RV, como estereoscopia e rastreamento de posição.
Em seqüência ao desenvolvimento desta aplicação procedeu- se a realização de um conjunto de testes com o intuito de avaliar o desempenho do software, dadas várias configurações de dispositivos possíveis.
Este capítulo apresenta a metodologia usada nestes testes, bem como os resultados obtidos.
Plataforma de testes Para realizar os testes foi criado um AV que representa uma célula de manufatura em o qual um usuário controlando um braço robótico deveria mover um conjunto de peças.
Este ambiente foi testado com o Asimov e com o VR Robotics e possui do lado esquerdo duas mesas giratórias, uma esteira e uma mesa de experiência.
Sobre as mesas encontram- se cinco peças, todas ao alcance do robô, que está no centro do AV, sobre uma esteira que foi utilizada para posicionar- lo perto de qualquer uma das peças.
Existem ainda outras cinco mesas giratórias posicionadas no lado direito do ambiente.
O ambiente de testes foi criado de forma que exigisse a movimentação do robô sobre a esteira, pegando peças em diferentes alturas, profundidades e distâncias e soltando as mesmas em diferentes distâncias, fazendo com que o braço robótico tivesse que ser completamente esticado em alguns momentos ou fechado em outros.
Também houve a preocupação de posicionar algumas peças em locais de difícil visualização, para que o usuário fosse obrigado a navegar no AV e posicionar- se perto de a peça que pretendia pegar.
A tarefa executada consistiu em pegar cada uma das cinco peças do lado esquerdo da célula, Célula de Manufatura consiste num ambiente de produção automatizado, com o uso de um ou mais robôs e periféricos adicionais, que são controlados por os robôs.
Para que a tarefa fosse realizada com a maior precisão possível, aconselhou- se os usuários para que adotassem as seguintes diretrizes:·
fechar a garra do robô somente quando desejassem pegar uma peça;·
soltar as peças o mais próximo possível do centro das mesas (realçados com um retângulo preto);·
abrir a garra do robô somente quando a tentativa de pegar uma peça falhasse ou para soltar uma peça sobre uma mesa do lado direito do cenário;·
não pegar novamente uma peça que foi solta, mesmo que o posicionamento final não tenha sido satisfatório;·
realizar a tarefa o mais rapidamente possível, porém sem interferir nas regras anteriores.
A tarefa realizada exigiu que fossem criadas trajetórias para pegar e soltar as peças, sendo este o mesmo procedimento adotado para obtenção dos pontos de referência, utilizados para ensinar robótica nas escolas, levando o usuário à realização desta atividade de forma implícita.
Com a realização dos testes foram coletados dados quantitativos através de um relatório gerado automaticamente e dados qualitativos através dos questionários pré-teste e pós-teste, preenchidos por os usuários.
Estes questionários estão disponíveis nos Anexos C e D, e no Anexo F estão as estatísticas coletadas para obtenção dos resultados.
Testes-piloto Com o objetivo de avaliar de forma geral as ferramentas de interação utilizadas no VR Robotics, primeiramente foram realizados testes piloto, utilizando quatro diferentes configurações para estes testes:
Monitor com e sem estereoscopia, HMD com estereoscopia e rastreamento, e tela de projeção com estereoscopia.
Cada configuração foi testada com pelo menos três usuários.
Em estes primeiros testes havia dois tipos de TP, o 3 D, que ficava dentro de o AV (como um objeto virtual preso ao usuário) e o 2 D, que ficava numa janela da aplicação, sem sofrer movimentações em função de os movimentos do usuário.
Em as versões com RV, os usuários manipulavam o TP 3D utilizando um joystick, que controlava o movimento de um cursor sobre o TP, como visto na Figura 32.
Para selecionar um comando, primeiro era necessário posicionar o apontador sobre o botão desejado, e acionar- lo com um botão do joystick.
Esta forma de interação, apesar de simples, mostrou que os usuários que a utilizavam levaram em média 80% mais tempo para executar a tarefa do que aqueles que utilizavam a versão com o TP fixo.
Além de isto, alguns usuários responderam nos questionários que o joystick gerava confusão por exigir o uso de muitos botões.
Outros usuários responderam que eventualmente o robô ocultava parte do TP 3D, prejudicando a visão do mesmo.
Já na versão sem estereoscopia, os usuários manipulavam o TP 2D, visto na Figura 22, clicando com o mouse sobre os botões do mesmo, sem se preocupar com o botão selecionado.
A solução para reduzir o tempo de teste, além de resolver o problema da oclusão seria utilizar sempre o TP 2D, porém, o uso de janelas não é possível no modo tela cheia.
Para resolver este problema foi criado um gerenciador de janelas em OpenGL, com o qual foram recriadas as janelas do editor de cenários e do TP, tornando a interação exatamente igual nas versões com ou sem RV, permitindo uma comparação mais precisa entre todas configurações do programa.
De essa forma, os testes com RV feitos antes desta conversão foram descartados, e os testes da versão sem RV foram mantidos, pois já utilizavam um TP acionado por clique do mouse.
Variáveis dos Testes Para realização dos testes foram considerados dois tipos de variáveis, as independentes de usuário e as dependentes de usuário.
As variáveis independentes de um teste definem os aspectos destes que não dependem do desempenho do usuário.
Em o caso deste projeto, são as configurações de testes possíveis, que no caso, dizem respeito ao conjunto de dispositivos utilizados, ao uso ou não de estereoscopia e ao uso do VR Robotics ou do Asimov.
As variáveis independentes dos testes foram:·
tipo de dispositivo de visualização:
Monitor, HMD ou tela de projeção;·
uso de estereoscopia;·
uso de rastreamento da cabeça do usuário;·
utilização do VR Robotics ou do Asimov.
Os comandos de movimentação do usuário e controle do robô foram realizados sempre com o mouse, pois durante a realização dos testes-piloto o uso do joystick exigiu maior tempo para a realização da tarefa, apesar de ter sido simples e de fácil aprendizagem por parte de os usuários.
De essa forma, como pode ser visto na Tabela 1, foram utilizadas sete configurações de ambiente para realização dos testes.
Não foram utilizadas todas combinações de configurações possíveis, pois algumas não faziam sentido ou eram semelhantes a outras exitentes.
O rastreamento da cabeça do usuário foi utilizado apenas com o HMD, pois é o único dos dispositivos de visualização utilizados em que é natural a mudança na orientação da visualização do ambiente conforme a orientação cabeça do usuário.
O HMD foi utilizado apenas com a estereoscopia ativada, pois sem o uso de estereoscopia a imagem seria semelhante à gerada no monitor, não obtendo melhora na qualidade.
As variáveis dependentes são os parâmetros medidos a partir de o desempenho dos usuários.
Em este trabalho este parâmetros foram divididos em duas categorias, de acordo com seu objetivo.
Cada vez que a garra do robô é fechada, é registrada uma tentativa de pegar a peça mais próxima à garra A posição (X, Y, Z) da peça no momento em que a garra do robô foi aberta.
A peça cai verticalmente, e a posição (X, Z) final foi utilizada para medir a distância em relação a a posição correta (o centro da mesa giratória) A distância de erro entre a garra e a peça ao tentar pegar- la, sendo zero quando a mesma foi pega O número de peças que ao final da tarefa o usuário não conseguiu pegar A distância entre o usuário e a peça que tentou pegar, para avaliar se os erros tem relação com a distância da câmera Estes dados foram obtidos de maneira automática, tanto no VR Robotics quanto no Asimov, gerando- se um relatório no final da execução.&amp;&amp;&amp;
Para medir estes parâmetros no Asimov foi necessário alterar o programa, mediante autorização do SENAI, onde o mesmo havia sido desenvolvido.
A precisão na colocação das peças foi calculada medindo- se a distância entre a posição correta, que é o centro das mesas giratórias, e a posição registrada no relatório gerado por o programa.
Algumas pessoas realizaram o teste em mais de uma configuração de dispositivos.
Para isto, procurou- se alternar a ordem de configurações para estes usuários, a fim de não gerar um falso resultado, caso o segundo teste ficasse sempre mais rápido do que o primeiro.
Protocolo de realização dos testes Os experimentos com os simuladores foram realizados dentro de um protocolo que objetivou dar um tratamento uniforme a todos participantes.
Foram realizados 29 testes no total, com 15 indivíduos, sendo que cada usuário realizou dois testes, à excessão de um usuário, que realizou apenas um, sendo a distribuição destes testes apresentada na Tabela 3.
A maioria dos usuários era formada por alunos de cursos de Ciência da Computação em nível de Graduação ou Mestrado, tendo, portanto, bons conhecimentos prévios de Informática.
As etapas do protocolo, apresentadas a seguir, não tinham uma duração máxima ou mínima pré-estabelecida, porém o tempo total da realização de cada experimento ficou sempre entre 15 e 45 minutos.
As cinco etapas do protocolo são descritas a seguir.
Em a primeira etapa, aplicação do questionário inicial, os usuários recebiam um questionário com perguntas sobre sua idade, freqüência de utilização semanal de computadores e categorias de programas mais utilizados.
Em o Anexo C pode- se observar a íntegra deste questionário.
A apresentação do experimento e dos equipamentos de RV era a segunda etapa do protocolo.
Após responder ao questionário os usuários recebiam uma folha com a descrição do experimento e seus objetivos, vista no Anexo E. Após a leitura do documento procedia- se a apresentação dos equipamentos a serem usados durante os experimentos.
Em a sessão introdutória ao AV, terceira etapa do protocolo, os usuários vestiam os equipamentos de RV, dependendo da configuração utilizada e recebiam algumas instruções básicas, a fim de permitir a interação com o ambiente e a manipulação do robô com o TP.
Em seguida podiam interagir livremente num AV criado para a ambientação.
Esta fase durava, em média, cinco minutos e encerrava- se quando os usuários assim desejassem.
Em a etapa quatro, onde se realizavam os testes propriamente ditos, os usuários eram inseridos no AV e a tarefa que deveria ser executada era novamente apresentada.
A coleta das variáveis dependentes durante a execução da tarefa era feita automaticamente.
Após a conclusão da tarefa os usuários eram solicitados a retirar os equipamentos de RV e a responder o questionário de avaliação (Anexo D), em que podiam informar entre outras coisas, se haviam sentido algum tipo de desconforto durante a execução do mesmo, ou se havia algum comentário adicional.
Em as seções a seguir, são apresentados os resultados dos experimentos com todas configurações utilizadas.
Resultados dos testes Em as seções seguintes são apresentados os resultados obtidos com base nas variáveis dependentes de usuários.
As tabelas completas com estes dados estão no Anexo F. A Figura 33 mostra uma comparação do tempo médio para realização da tarefa em todas configurações testadas.
Analisando o gráfico é possível notar que o uso de estereoscopia diminuiu o tempo para realização da tarefa utilizando tanto um monitor quanto uma tela de projeção.
O rastreamento da cabeça do usuário, utilizado apenas com o HMD, também diminuiu o tempo de realização da tarefa.
A tela de projeção foi o dispositivo que obteve maior tempo para realização da tarefa, contudo este foi o dispositivo com a maior precisão, como pode ser comprovado na próxima seção.
A média de tempo para pegar as peças apresentou comportamento idêntico à média de tempo total da tarefa, como visto na Figura 34.
Isto indica ser o monitor com estereoscopia a configuração que possibilita a realização da tarefa mais rapidamente.
Um dos objetivos da construção do VR Robotics foi a tentativa de diminuição do erro no posicionamento do braço robótico.
Conforme pode ser visto na Figura 35 a configuração que apresentou a maior precisão foi a tela de projeção com estereoscopia.
Já o HMD com rastreamento da cabeça do usuário foi a configuração com maior erro, o que pode indicar que mesmo que o tempo de realização da tarefa com rastreamento tenha sido menor, quando a interação é realizada com o mouse este dispositivo não ajuda, pois o usuário fica parado em frente ao monitor.
No geral a precisão na posição final das peças foi maior no VR Robotics do que no Asimov, o que indica que o objetivo de melhorar a precisão foi alcançado.
Outro fator que deve ser considerado ao analisar a qualidade da visualização é a distância da garra à peça quando se tenta pegar uma peça.
Analisando a Figura 36 podemos perceber que o dispositivo que apresentou o pior resultado foi a tela de projeção sem estereoscopia, porém, neste mesmo dispositivo quando foi utilizada estereoscopia praticamente não houve erro ao pegar as peças, indicando que a estereoscopia auxiliou na realização da tarefa, o que é confirmado por as respostas dos usuários nos questionários pós-teste.
O número de tentativas para pegar as peças pode indicar a qualidade na visualização, pois tentativas erradas indicam que o usuário não conseguiu perceber que a garra não estava sobre a peça.
Em a Figura 37 podemos perceber que na metade das configurações com o VR Robotics foi necessário apenas uma tentativa para pegar as peças, mas a configuração da tela de projeção sem estereoscopia e sem rastreamento necessitou um número maior de tentativas, o que indica que a tela de projeção deve ser utilizada com a estereoscopia ativada, para que a visualização seja adequada.
O tempo de realização da tarefa foi reduzido consideravelmente após a mudança na forma de interação do joystick para o mouse, mas ainda assim alguns usuários comentaram nos questionários que a navegação com o mouse ficou um pouco confusa no início, porém o tempo de aprendizado da navegação com o mouse foi menor.
O monitor com estereoscopia ativada foi o dispositivo que apresentou melhores resultados, obtendo menor tempo para realização da tarefa e também para pegar as peças, necessitando do menor número de tentativas para esta tarefa e obtendo boa precisão na posição final das peças.
Acredita- se que este dispositivo é o que melhor se adapta à interação com o mouse, e por isto obteve este resultado.
Além de isto, o monitor é o dispositivo que exige menor gasto para implantação, exigindo apenas uma placa de vídeo simples e um óculos do tipo shutter, sendo que a aquisição de ambos pode ser feita a partir de R$ 670, como pode ser visto nas Tabelas 4 e Acredita- se que a tela de projeção seja uma opção interessante, apesar de os resultados apresentados, pois o grupo de usuários que realizaram o teste com este dispositivo foi pequeno, e apenas um destes usuários conhecia o TP, exigindo um tempo para conhecimento das funções deste dispositivo.&amp;&amp;&amp;
Quanto a o custo para implantação, deve ser considerado que a maioria das escolas possui dois projetores iguais, e o custo do restante de equipamentos a serem adquiridos é praticamente igual ao obtido na configuração mais barata.
O HMD foi o dispositivo que apresentou a menor precisão na posição final das peças.
Este dispositivo foi considerado desconfortável por praticamente todos usuários, o que prejudicou a realização da tarefa e pode ter sido responsável por o resultado.
O uso de rastreamento com este dispositivo também não ajudou no processo interativo, o que indica que não é necessário rastreamento quando for utilizado o mouse como dispositivo de interação.
Analisando- se a Tabela 5 é possível notar que quando se utilizam vários computadores as configurações com HMD se tornam praticamente inviáveis, pois o custo sem rastreamento equivale a 207% do custo do RoboCell, chegando a 293% quando for utilizado rastreamento.
As configurações com tela de projeção mantém praticamente o mesmo valor, pois foi considerado o uso de apenas uma tela, aumentando- se apenas os equipamentos necessários para possibilitar um número maior de expectadores, dessa forma, para vinte alunos temos um custo de implantação equivalente a 14% do custo para o RoboCell.
Nota- se ainda que a configuração do monitor com estereoscopia, que foi a que obteve melhores resultados, possui um custo de implantação equivalente a 30% do custo para o RoboCell, sendo considerada a melhor alternativa.
Após a realização deste trabalho, constatou- se que a melhor opção para ensinar robótica nas escolas, utilizando recursos de RV, é através do uso de um monitor com estereoscopia, pois esta opção apresentou melhora na realização da tarefa, aumentando a precisão e diminuindo o tempo total.
Em escolas que possuem turmas com muitos alunos, pode ser interessante utilizar a opção de projeção com estereoscopia, pois apenas um equipamento pode ser utilizado por todo grupo de alunos.
Constatou- se que não é necessário utilizar rastreamento com o VR Robotics, devido a a forma de interação adotada, que utiliza principalmente o mouse como dispositivo de interação.
Com isto conclui- se também que o HMD não oferece ganho na execução da tarefa, sendo mais apropriado para outros tipos de ambientes virtuais.
Para que sejam obtidos resultados mais concretos, seria necessária a realização de novos testes, com um grupo maior de usuários, e principalmente, utilizando mais usuários ligados à robótica, pois notou- se que o desempenho de alguns usuários não foi melhor por o desconhecimento do uso de um TP para comandar um robô, inclusive alguns usuários sugeriram nos questionários que antes da realização do teste fosse apresentado um manual explicando as funções do TP.
Além de isto, notou- se que será necessário realizar um trabalho de conscientização de professores de robótica e diretores nas escolas, para a adoção de um simulador com RV, para que não aconteça como ocorreu com o Asimov, que acabou não sendo utilizado nas escolas por resistência dos próprios professores.
Sabe- se que a adoção do Asimov não ocorreu também por conta de problemas do simulador, mas algumas escolas do SENAI sequer chegaram a conhecer este aplicativo.
Como trabalhos futuros, sugere- se a implementação de um ambiente para criação e compilação de programas em linguagem ACL, para que o simulador VR Robotics se torne completo.
Também seria interessante a implementação da comunicação com o robô real, permitindo o envio de programas e até mesmo uma simulação sincronizada com a execução no robô real.
Conforme os resultados apresentados acredita- se objetivo de desenvolver uma aplicação que melhore a tarefa de obter os pontos de referência foi alcançado.
