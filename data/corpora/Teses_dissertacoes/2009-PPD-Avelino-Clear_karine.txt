Com a expansão dos sistemas computacionais e com a popularização dos serviços providos por a Internet, é crescente a preocupação dos engenheiros de software com a segurança dos sistemas que desenvolvem.
O volume de informações confidenciais que trafega por a Internet é cada vez maior, tornando essencial a avaliação de segurança destes sistemas antes de entregálos a seus usuários.
Entretanto, o tempo que dedicam em seus projetos à realização de testes para avaliar este aspecto é pequeno, fazendo com que softwares inseguros sejam liberados no mercado.
Verificar o nível de segurança de um software não é trivial.
É preciso considerar este aspecto desde a fase de projeto do sistema, quando o modelo ainda está sendo elaborado.
Uma limitação é a deficiência existente na área de segurança, seja em relação a os modelos, que provêem poucas estruturas para representar este aspecto, ou à pouca quantidade de ferramentas, documentos e checklists explicando como conduzir a execução de testes de segurança.
Em este contexto, vem se tornando popular uma técnica conhecida como teste baseado em modelos.
Em esta, os testes a serem realizados são definidos automaticamente a partir de o modelo da aplicação, de acordo com os aspectos desejados.
Diversos trabalhos propõem modelos para especificar os mais variados requisitos, como funcionais e de desempenho, mas poucos se dedicam a definir uma forma de descrever aspectos de segurança.
Sendo assim, este trabalho propõe alguns estereótipos UML para especificar situações que podem comprometer a segurança de um software, além de um algoritmo que analisa estes e gera, automaticamente, casos de teste a partir de o modelo.
Desta forma, é possível assinalar, através da inserção de estereótipos no modelo, partes do sistema que podem conter vulnerabilidades, e, posteriormente, executar os casos gerados para verificar a ocorrência destas no software final.
A elaboração deste trabalho tem dois objetivos principais:
Auxiliar durante a fase de implementação do software, prevendo situações que possam comprometer sua segurança e orientando os desenvolvedores, e permitir a geração automatizada de casos de teste de segurança a partir de as informações inseridas.
Palavras-chave: Segurança.
Teste Baseado em Modelos.
UML. Geração de Casos de Teste.
Com o crescente número de serviços providos por a Internet, é considerável o aumento na quantidade de dados trocados entre computadores e usuários.
A expansão da Web é tamanha que superou seu objetivo inicial, o de ser apenas uma forma de conectar informações armazenadas em diferentes locais.
Hoje em dia já é possível fazer compras, transações bancárias e inclusive declarar Imposto de Renda através da Internet, o que faz com que dados confidenciais sejam transmitidos por a rede.
Devido a esta característica, a área de tecnologia de informação deparouse com uma nova preocupação de seus usuários:
A segurança e confidencialidade dos dados enviados.
Baseando- se nos princípios de teste de software, que visam encontrar problemas nos mais variados sistemas, foi criada uma área dedicada apenas à realização de testes de segurança em softwares.
Esta visa avaliar componentes que podem comprometer a segurança do sistema, como entradas de dados, interfaces e protocolos de comunicação.
Entretanto, definir manualmente os testes que devem ser realizados demanda tempo e esforço dos engenheiros de teste, que devem conhecer detalhadamente a aplicação a ser testada, bem como o modo que ocorre a troca de dados.
Caso contrário, o conjunto de casos de teste escolhido pode não encontrar falhas críticas no sistema, que serão descobertas apenas após a implantação deste num ambiente real.
Desta forma, nos últimos anos vem sendo empregada uma abordagem diferente para a realização de testes, denominada teste baseado em modelos.
Em esta, a partir de o modelo formal de uma aplicação e da especificação dos critérios que se deseja testar, uma série de casos de teste são gerados, na maior parte das vezes de forma automatizada.
Entretanto, apesar de a popularização desta técnica, ela ainda não é amplamente empregada para analisar aspectos de segurança, área de estudo deste trabalho.
O principal motivo se deve à dificuldade de especificar critérios de segurança utilizando modelos, devido a variedade de detalhes associados à área que devem ser modelados.
Para se definir um modelo que especifique segurança, é de suma importância conhecer diversos ataques e vulnerabilidades, a fim de propor um que permita descrever a maior parte dos comportamentos.
O primeiro passo para se propor um novo modelo, ou mesmo para avaliar os existentes, é estudar algumas taxonomias de segurança.
Isto auxilia a identificar padrões de comportamentos entre ataques ou vulnerabilidades, permitindo a construção de modelos coerentes e precisos.
Após a definição do modelo, é preciso extrair as informações relevantes deste e gerar, ao término da análise, os casos de teste que devem ser aplicados ao software quando este estiver pronto.
Sendo assim, este trabalho propõe uma estratégia para especificar aspectos de segurança durante a elaboração do modelo da aplicação, bem como automatizar o processo de teste de software provendo uma forma de gerar os casos de teste a partir deste modelo.
O trabalho tem dois objetivos principais:
Auxiliar durante a fase de desenvolvimento do software, prevendo situações que possam comprometer sua segurança, e permitir a geração de casos de teste a partir de as informações inseridas.
Para descrever os aspectos de segurança, foram definidos alguns estereótipos UML representando vulnerabilidades de segurança.
Para auxiliar este processo, utilizou- se como base uma lista com as dez vulnerabilidades mais críticas para aplicações Web, conhecida como Top Ten List e elaborada por o projeto OWASP.
Já na parte de geração dos casos de teste, utilizou- se o método conhecido como Unique Input Output (UIO), que utiliza uma máquina de estados finitos com entrada e saída cujo resultado são seqüências descrevendo os passos a serem seguidos por o testador.
Este trabalho está estruturado da seguinte forma.
O Capítulo 2 descreve aspectos relacionados à área de teste de software, tais como a sua importância e os tipos de teste existentes, enquanto que o Capítulo 3 apresenta alguns modelos formais e ressalta as características, vantagens e desvantagens de cada.
O Capítulo 4 explica as taxonomias de segurança estudadas ao longo de o trabalho e que auxiliaram no processo de especificação dos estereótipos de segurança, enquanto que o Capítulo 5 compara o trabalho aqui apresentado, com outros da área de modelagem e de automatização de teste.
O Capítulo 6, por sua vez, descreve o trabalho desenvolvido, explicando a contribuição do trabalho, a motivação e objetivos de ele, bem como os passos seguidos para especificar os estereótipos de segurança e gerar os casos de teste equivalentes.
O softwares.
Por fim, o Capítulo 8 apresenta as conclusões obtidas com este trabalho, bem como identifica situações não abordadas em seu escopo e as sugere como trabalhos futuros.
Em os últimos anos, a busca por a excelência no desenvolvimento de software vem preocupando os mais diversos tipos de empresas da área de Informática.
Visando produzir software com qualidade, as empresas têm implantado em suas dependências equipes voltadas exclusivamente ao teste de software.
Em função de o tamanho dos sistemas desenvolvidos ultimamente, bem como a complexidade destes e o número de pessoas envolvidas, dividir a etapa de produção de um software em fase de desenvolvimento e fase de testes torna- a mais eficaz, mais rápida e mais confiável.
A área de teste de software pode ser subdividida em diversas outras menores, como na execução de testes funcionais, de usabilidade ou de desempenho, por exemplo, aplicadas de acordo com as necessidades do usuário.
Em este trabalho, será abordada a de segurança, escolhida por diversos motivos.
Com a quantidade de serviços prestados via Internet e com o alto grau de confidencialidade das informações trocadas, um pré-requisito de algumas aplicações é que sejam seguras, e uma das formas de se verificar esta característica é realizando testes de segurança.
Sendo assim, este capítulo tem como objetivo abordar questões referentes a teste de software.
Em as próximas seções serão apresentados alguns conceitos relacionados, as vantagens em se executar testes (e testes baseados em modelos), além de fundamentar a importância de se avaliar a segurança de um sistema antes de colocar- lo em fase de produção.
Existe uma série de conceitos semelhantes na área de teste de software, mas os que mais se confundem são as definições de falha, erro e defeito.
Embora para alguns tenham o mesmo significado, eles possuem características que os diferem.
Uma breve definição de cada um destes conceitos pode ser vista a seguir.·
Falha (fault):
Uma falha é a causa hipotética de um erro.
Quando provoca um erro é chamada de ativa (active fault);
Caso contrário, é chamada de adormecida (dormant fault).·
Erro (error):
Um erro é o desvio que faz com que o serviço entregue seja diferente do especificado, ou seja, ele é a parte do estado total do sistema que pode levar a subseqüentes defeitos no serviço.
Entretanto, é importante dizer que nem todo erro causa um defeito.
Isto acontece apenas quando ele alcança algum estado externo do sistema.·
Defeito (failure):
Um defeito é quando o serviço entregue é diferente do esperado.
Ele pode ocorrer simplesmente porque o resultado não confere com o descrito na especificação ou porque a especificação não descreve adequadamente o funcionamento do sistema.
Quando se decide testar um software, a primeira tarefa é fazer uma análise do sistema em questão e definir quais itens serão testados.
Feito isso, para cada item devem ser elaborados casos de teste.
Casos de teste, ou test cases, servem para definir um teste e o que será testado com ele, como um roteiro a ser seguido por o testador.
Para garantir o bom funcionamento de um software, inúmeros casos de teste devem ser criados, um complementando o outro, a fim de cobrir todas as situações possíveis de execução.
A documentação de um caso de teste deve compreender uma série de dados.
Estão entre estes um identificador do caso de teste, um estado inicial, uma seqüência de operações de teste e os resultados esperados.
Dependendo do estado em que se encontra a fase de desenvolvimento de um software, diferentes tipos de teste podem ser realizados em ele.
Os níveis de teste, como são chamados, podem ser classificados da seguite forma:·
Teste Unitário:
Este nível consiste em testar cada um dos módulos de maneira separada;
Tem por objetivo verificar a correta implementação de cada um;·
Teste de Integração:
Consiste em testar um grupo de componentes ou módulos, visando validar tanto a interface de comunicação entre eles, como a capacidade de trabalharem juntos;·
Teste de Sistema:
Consiste em realizar testes no sistema como um todo, comparando o funcionamento observado com o descrito na especificação;·
Teste de Aceitação:
Consiste em realizar testes no sistema como um todo, mas comparando com os requisitos fornecidos por o usuário a fim de verificar se o produto final atende às exigências deste.
Um teste pode ser aplicado a um sistema por diversos motivos:
Buscar por problemas, verificar a eficiência, o desempenho, etc..
Dependendo da finalidade com que é executado, um teste pode ser classificado e, em categorias, algumas descritas a seguir:·
Teste Funcional:
Conhecido também como teste de caixa-preta, ou black-box, baseiase na especificação do software e é aplicado ao sistema como um todo.
O testador tem conhecimento apenas das entradas e saídas do sistema, e a partir de um oráculo1 avalia se o software funciona de acordo com o esperado ou não;·
Teste Estrutural: Ao contrário de o teste funcional, no teste estrutural o testador tem conhecimento do código-fonte do sistema testado.
Por este motivo é conhecido como teste de caixa-branca, ou white-box.
Pode ser realizado enquanto o software ainda está em desenvolvimento;·
Teste Baseado em Falhas:
Esta técnica baseia- se em inserir, intencionalmente, um conjunto de falhas no software, com o objetivo de definir um critério de parada para a execução dos testes.
Assume- se que este conjunto equivale a falhas típicas, ou seja, que sejam do mesmo tipo, ocorram na mesma freqüência e possuam as mesmas características que as falhas reais.
Uma forma de selecionar este conjunto é utilizar dados históricos obtidos a partir de versões anteriores ou projetos similares.
Com o grande número de aplicações comerciais na Internet, garantir que um software é seguro tornou- se essencial.
A fim de buscar por possíveis vulnerabilidades nestes sistemas, criou- se um novo ramo na área de teste voltado exclusivamente para a realização de teste de segurança em software.
Teste de segurança é classificado como um teste de aspectos não funcionais (uma subdivisão do teste de sistema), assim como os testes de desempenho e stress.
Especialistas deste ramo devem possuir um conhecimento aprofundado sobre redes de comunicação, arquitetura de computadores, protocolos, programação e vulnerabilidades.
Além disso, devem ser persistentes, visto que muitas vezes um defeito só acontece em decorrência da combinação de uma série de outros ataques menores.
Uma técnica interessante para se explorar a segurança de um sistema é dividir- lo em áreas, focando em partes onde uma vulnerabilidade tem mais chances de ocorrer.
Esta abordagem provê um nível mais alto de segurança do que o clássico modelo de teste de caixa-preta.
Dizer que uma aplicação é segura requer a execução de uma série de testes de forma exaustiva e repetitiva, buscando por conexões suscetíveis a roubo de dados e informações.
Outra software de tal forma que podem resultar na negação de algum serviço ou até mesmo dar privilégios de acesso a usuários que não o possuem.
Softwares podem tornar- se vulneráveis em função de diversos fatores, tais como:·
Intenção criminosa de algum hacker em danificar o sistema, roubar informações, causar uma negação de serviço, invadir a privacidade do usuário;·
Erros cometidos por pessoas responsáveis por a manutenção do sistema que modificam, destroem ou comprometem dados devido a má informação ou pouco conhecimento.
Para identificar vulnerabilidades, a equipe de teste deve fazer- se passar por um hacker e atacar o sistema, explorando todas as brechas possíveis.
Entretanto, é preciso seguir uma metodologia previamente definida, a fim de cobrir a maior parte de protocolos e funcionalidades do software.
Uma estratégia possível é fazer um levantamento das camadas, protocolos e módulos presentes no sistema e, a seguir, estudar minuciosamente a especificação de cada um destes.
Durante este estudo devem ser destacados mecanismos que possam ter sido mal implementados ou que possam apresentar problemas sob determinadas condições.
Concluída esta etapa, é preciso implementar programas de teste para avaliar cada uma das possíveis vulnerabilidades, tendo como alvo o sistema em questão.
Por fim, os testadores devem analisar o comportamento do sistema e concluir se o sistema foi atacado ou não.
É importante dizer que mesmo com a execução exaustiva de testes de segurança, não é possível assegurar que um software é totalmente seguro.
Isto por que o tempo dedicado a realização de testes deste tipo não permite cobrir todas as possibilidades e combinações de ataques.
Sabendo da quantidade de problemas de segurança que as aplicações apresentam, bem como da dificuldade em testar- las, este trabalho visa integrar as práticas de teste de software com a capacidade de representação de modelos formais, a fim de automatizar o processo de teste de segurança.
Sendo assim, o próximo capítulo deste trabalho descreve alguns modelos formais com aplicação na área de teste, com o objetivo de auxiliar na escolha do mais indicado para representar os aspectos de segurança.
Com a evolução dos sistemas de computadores e a quantidade de funcionalidades providas por estes, os softwares tornaram- se estruturas tão complexas que mesmo testar- los tornou- se difícil.
Como conseqüência, versões instáveis têm sido liberadas para os usuários finais, contendo inúmeros problemas de implementação.
Diversos motivos justificam este comportamento, tais como o curto prazo dispendido com a fase de testes e a má especificação da arquitetura.
O curto prazo faz com que as aplicações sejam desenvolvidas e testadas com pressa, fazendo com que uma série de falhas sejam ignoradas.
Já os problemas com a especificação, como por exemplo uma especificação confusa, superficial ou ambígua, pode resultar em divergências que serão descobertas apenas ao final da fase de desenvolvimento, quando corrigir- las custa caro.
A fim de resolver problemas como estes, algumas empresas têm mudado a forma como descrevem os requisitos e a arquitetura de seus sistemas.
Eles vêm substituindo a descrição em linguagem natural, comumente usada, por uma abordagem mais consistente, utilizando modelos formais.
Um modelo formal nada mais é do que uma forma de representar, através de uma linguagem formal específica, uma outra entidade, podendo esta ser um objeto físico ou mesmo outro modelo.
São utilizados para comunicar percepções e transferir conhecimento a outras pessoas, sendo que esta formalização pode ser representada através de desenhos, gráficos e até mesmo equações matemáticas.
Quando aplicados ao desenvolvimento de software, servem para descrever propriedades e para assegurar a integridade do sistema, caso a implementação baseie- se na modelagem previamente realizada.
Mais do que isto, a partir de a descrição de um modelo formal é possível simular o comportamento de um sistema, identificar padrões e necessidades deste, além de poder detectar possíveis falhas na especificação.
Um modelo formal é descrito através de uma notação própria, também conhecida como linguagem formal.
Com o número de notações existentes, a escolha de uma que atenda aos requisitos do projeto e consiga representar o que se deseja é crucial.
Uma observação a ser feita é que a grande variedade de notações dificulta a popularização dos modelos formais, já que, por não haver uma padronização, é necessário realizar um estudo prévio dos existentes antes de optar por qual será utilizado.
Sabendo- se da importância do uso de modelos formais, este capítulo tem como objetivo ressaltar as vantagens de se empregar- los durante o ciclo de desenvolvimento de software, bem como apresentar como eles podem auxiliar as áreas de teste de software e de segurança, foco deste trabalho.
Conforme mencionado, modelos formais são metodologias utilizadas para especificar determinadas características de um sistema, podendo representar, por exemplo, o comportamento esperado do software, as estruturas existentes neste ou até mesmo como ele deve ser testado.
Por serem precisos, podem ser utilizados em diversas etapas do processo de desenvolvimento de software, desde sua especificação até o levantamento dos casos a serem testados.
A principal vantagem de aplicar- los é que, como são fortemente baseados em matemática e lógica formal, permitem validar, por exemplo, se uma especificação foi elaborada corretamente ou se apresenta alguma ambigüidade.
Outras vantagens obtidas com o uso de modelos formais são que eles ajudam a melhorar a qualidade do software, tornando- o mais robusto se aplicados de maneira correta, e levam a uma redução nos custos do projeto, já que detectam uma grande quantidade de erros já na fase de especificação.
A aplicação de modelos formais pode ser muito útil para diversas áreas da computação, mas uma das mais importantes, sem dúvidas, é a de segurança de redes.
Hoje em dia, a maior parte das empresas presta serviços via Internet, sendo que a quantidade de dados confidenciais trocados é muito grande.
Para poder lidar com esta situação, as aplicações e protocolos responsáveis por a comunicação devem ser os mais robustos possíveis, evitando assim o roubo de informações e diversos outros ataques.
Como dito anteriormente, o uso de modelos formais garante que não existem ambigüidades em especificações.
Desta forma, utilizar- los como base para descrever aplicações, ou mesmo requisitos de segurança, auxilia na identificação de muitas vulnerabilidades antes da implementação, quando corrigir- las é mais rápido e barato.
A construção de um modelo formal do sistema desejado durante a fase de projeto de software pode melhorar a qualidade do produto final, pois fornece uma estrutura passível de análise e que permite a detecção de alguns defeitos.
Ele descreve características do sistema através de uma linguagem própria, conhecida como linguagem formal ou notação formal.
Existem diversas notações para se descrever um modelo formal, cada uma com suas peculiaridades.
Considerando a complexidade e a limitação de algumas destas, a escolha da linguagem apropriada é fundamental para o sucesso do projeto, sendo preciso avaliar diversos antes de decidir qual será utilizado.
Inúmeros fatores devem ser considerados durante a escolha de uma notação, tais como o vocabulário proposto, a capacidade de representação da linguagem e a clareza com que esta expõe as informações.
Sendo assim, o objetivo desta seção é apresentar algumas notações já conhecidas e que podem, de alguma forma, representar características de segurança, bem como auxiliar durante o processo de teste de software.
Testing and Test Control Notation version 3 (TTCN-3) é uma linguagem de teste de padrão internacional desenvolvida por o European Telecommunication Standards Institute (ETSI).
Foi projetada com o objetivo de permitir a execução de diversos tipos de testes para uma série de aplicações, independente de plataforma.
Para avaliar os sistemas, baseia- se na troca de mensagens (requisições e respostas), o que faz com que seja amplamente utilizada na área de telecomunicações no teste de dispositivos de rede e de protocolos de comunicação.
Um exemplo é o teste do recente protocolo Internet Protocol version 6 (IPv6), cujos resultados modularidade, a facilidade de descrição de testes e a semelhança com as demais linguagens de programação.
Um exemplo de uso da linguagem TTCN-3, apresentado por Stepien, descreve o teste de um serviço meteorológico.
Conforme mencionado, o sistema é avaliado de acordo com as informações fornecidas em resposta às requisições feitas por a suite de teste.
Desta forma, quando a suite de teste é elaborada, inicialmente devem ser descritas as estruturas de dados utilizadas, bem como as regras de validação dos parâmetros.
A seguir, deve- se especificar os casos de teste que serão executados, indicando as seqüências de mensagens que devem ser enviadas para e recebidas do SUT.
Por último define- se a ordem de execução dos vários casos de teste.
Em o sistema em questão (serviço meteorológico), o testador deve enviar uma requisição contendo a localidade, a data e o tipo de relatório desejado, e receber como resposta a confirmação dos parâmetros enviados acrescidos da temperatura no local, a velocidade do vento e as condições do tempo.
A Figura 3 apresenta o formato, os dados inseridos nas mensagens e as regras para avaliação das respostas, enquanto a Figura 4 descreve a seqüência de execução das mensagens.
Após a execução dos testes, é gerado um arquivo contendo os resultados obtidos, informando se eles foram executados com sucesso, se falharam ou se algum erro ocorreu durante o processo.
Com a quantidade de funcionalidades providas, os softwares tornaram- se estruturas tão complexas que mesmo testar- las tornou- se difícil.
Esta situação é agravada por o pouco tempo normalmente dedicado às atividades de teste, já que não é suficiente prever apenas alguns casos e testar- los.
É preciso analisar o sistema e concluir quais são as partes mais utilizadas e mais críticas, a fim de pelo menos explorar- las mais do que módulos não tão comprometedores.
A fim de permitir este tipo de análise, foi desenvolvida a técnica de teste de software estatístico baseado em modelos.
Com esta estratégia é possível descrever um modelo do sistema utilizando, por exemplo, Cadeias de Markov ou Redes de Autômatos Estocásticos (Stochastic Automata Networks, SANs), e atribuir probabilidades às transições de um estado para outro.
A partir de estas probabilidades são gerados automaticamente casos de teste para os caminhos mais utilizados do software, tornando- o assim mais robusto.
O teste estatístico pode ser considerado um guia sobre como o software será testado, baseado em distribuições de probabilidades, populações e amostras.
A Figura 5 apresenta um exemplo de descrição utilizando autômatos finitos.
Uma ferramenta desenvolvida para auxiliar no processo de teste estatístico é o STAte-based GEnerator (STAGE).
O objetivo desta é gerar casos de teste funcionais e scripts a partir de o modelo da aplicação, descrito através de autômatos finitos.
Com base neste modelo e nas probabilidades associadas às transições entre os estados, o STAGE identifica os caminhos que podem ser percorridos por o software e determina que combinações devem ser testadas.
Conforme mencionado, a geração dos casos de teste é feita de acordo com os caminhos que podem ser percorridos por o software.
A ferramenta verifica, desde o estado inicial, todas as formas de se chegar ao estado final, garantindo assim que todos os caminhos tenham sido cobertos.
Cada caminho equivale a um caso de teste diferente.
Por fim, a ferramenta ainda permite gerar scripts de teste para determinados software, visando automatizar também o processo de execução dos testes.
Maiores detalhes sobre a ferramenta STAGE estão no Capítulo 5.
A notação Z é uma especificação formal utilizada para descrever sistemas de computadores baseada na teoria dos conjuntos proposta por Zermelo--Frankel e em lógica de primeira ordem.
O principal problema associado ao uso de especificações formais é que, quanto maior é o sistema que se quer representar, mais complexas e incompreensíveis elas se tornam.
A fim de resolver este problema, a notação Z utiliza um modelo previamente definido que auxilia na construção da especificação, pois permite combinar diferentes seções de esquemas matemáticos através de descrições formais de texto.
Este modelo que auxiliará na descrição através da notação Z pode ser construído de diversas maneiras.
A mais conveniente utiliza modelos baseados em estados, devido a facilidade de descrição e compreensão.
Uma descrição aceitável de um modelo, por exemplo, é a presença de um estado abstrato e uma seqüência de transições representando as operações dentro de ele.
Mesmo que pareça simples demais, é possível especificar o comportamento de uma série de sistemas utilizando apenas esta notação.
O modelo não deve ser influenciado por questões referentes à implementação, e nem deve ser formal demais que comprometa o seu entendimento.
Ele deve ser simples o bastante para representar apenas o funcionamento e as restrições desejadas do sistema.
Um exemplo simples apresentado no manual de referência da Notação Z propõe a implementação de um sistema para armazenar as datas de aniversário de algumas pessoas.
O primeiro passo para modelar este sistema é definir os tipos básicos a serem utilizados (conjuntos), bem como definir as variáveis e condições de operabilidade.
Em este caso, temos dois conjuntos principais de dados, os nomes dos aniversariantes e suas respectivas datas de aniversário.
Além disso, é preciso definir os tipos de cada variável e estabelecer que o número de nomes da lista deve ser igual ao número de aniversários armazenados.
Caso contrário, o sistema será considerado inconsistente.
A Equação 3.1 apresenta a descrição dos tipos básicos de dados, enquanto que a Equação 3.2 demonstra a declaração de um conjunto (known), uma função de mapeamento utilizando este conjunto (birthday) e a relação de igualdade entre estes (o tamanho do conjunto known é igual ao domínio da função de mapeamento birthday).
Um possível preenchimento deste sistema poderia ser feito com os registros John -- 25/03, Mike -- 20/12 e Susan, 20/12.
O formato de declaração dos registros pode ser visto na Equação M ike 20/12, Usando a notação Z, é possível também formalizar o comportamento das operações do sistema, como por exemplo o de adicionar um novo aniversariante ao catálogo.
Para descrever esta atividade, o primeiro passo é estabelecer uma pré-condição determinando que o novo nome não pode existir na base de dados.
Caso contrário teríamos uma ambiguidade nesta, pois para uma mesma pessoa seriam atribuídas duas datas de aniversário diferentes.
A partir de então, caso esta pré-condição seja satisfeita, a base de dados deve ser expandida através da união deste novo registro.
A Equação 3.4 apresenta a descrição desta etapa do processo.
Como é possível perceber, a notação Z não foi desenvolvida com o intuito de descrever testes, foco deste trabalho, mas de modelar formalmente os sistemas em si.
Entretanto, diversos trabalhos já experimentaram utilizar a notação Z para formalizar os critérios de teste de software.
Um exemplo é o trabalho de Vilkomir e Bowen, que propõe algumas estruturas descritas usando esta notação para formalizar os critérios de teste que avaliam o fluxo de controle do software.
A principal vantagem do uso da notação Z para formalização de critérios de teste é a unicidade, já que o nível de detalhamento permitido evita que uma descrição seja compreendida de diferentes formas, como acontece com a linguagem natural.
Em lógica, o termo lógica temporal significa representar proposições qualificadas em relação a o tempo, utilizando- se de regras e simbolismos.
Com esta abordagem, é possível expressar sentenças tais como &quot;determinado fato sempre acontece», &quot;determinado fato acontece eventualmente «ou &quot;determinado fato acontece até que tal medida seja tomada».
Em a área da computação, a lógica temporal possui uma grande aplicação na descrição de requisitos de hardware ou software.
Através de ela é possível especificar comportamentos do software de forma precisa, estabelecendo restrições e pré-condições para que determinada operação ocorra.
Desta forma, com a descrição em lógica temporal pode- se descrever situações como &quot;nunca haverá dois dispositivos acessando o mesmo recurso simultaneamente «e &quot;sempre se passa por um estado A antes de ir para um estado B».
Devido a capacidade de representar casos como estes, lógica temporal vem sendo amplamente utilizada não apenas durante o desenvolvimento de software, mas também durante a fase de teste de software.
O processo de teste com lógica temporal pode ser dividido em duas etapas:
Em a primeira, é elaborado um documento contendo a descrição funcional do sistema;
Um exemplo do uso de lógica temporal na área de segurança é o framework Monitoring based Intrusion Detection tool (MONID).
Seu objetivo é detectar intrusões através da comparação do comportamento do sistema real com o do esperado, previamente descrito através de lógica temporal.
Para tanto, foi implementado um algoritmo que captura o comportamento do sistema, o transforma numa fórmula e a compara com a fórmula previamente feita da especificação.
Sempre que a especificação for violada (isso acontece quando a fórmula lógica retorna valor falso), deve ser disparado um &quot;alarme «indicando desvio de comportamento.
Suponha uma restrição que estabeleça que sempre que um usuário conecta- se ao sistema, ele demora até 100 unidades de tempo para se desconectar.
A Equação 3.5 demonstra como seria a especificação desta regra que se deseja monitorar.
EvT imedLogout (k, t,) mon M1 = always (action $= login) EvT imedLogout (userId, time, 100) Após a descrição da regra, é preciso analisar o comportamento do sistema real.
Para tanto, será considerada a seguinte sequência de eventos e1 e e2:
Para as seqüências e1 e e2, a fórmula final M1 ficaria como descrito por a Equação 3.6.
Eval $= EvT imedLogout Always (action $= login) EvT imedLogout (userId, time, 100) Analisando- se a Equação 3.6, percebe- se que os parâmetros informados durante o evento e1 foram substituídos na fórmula original.
Durante a execução do segundo evento e2, o predicado (time -- t) foi instanciado como (150.0 -- 17.0 100), o que é falso.
Desta forma, toda a sentença é considerada falsa, e o comportamento considerado uma tentativa de intrusão.
Por fim, o uso de lógica temporal não garante que a implementação do sistema está de acordo com o modelo, mas provê uma forma de avaliar se a especificação deste não é ambígua ou se não fere as restrições impostas.
Sendo assim, após a implementação do sistema, é preciso executar novos testes na aplicação e comparar com os resultados previamente obtidos, a fim de validar se o sistema implementado é vulnerável ou não.
A Unified Modeling Language1 (UML) é uma linguagem padrão de modelagem mantida por o Object Management Group (OMG), amplamente utilizada para especificar sistemas orientados a objeto, seu comportamento e interação.
Ela define notações para construir diferentes diagramas, cada qual representando uma visão particular de um artefato a ser modelado.
Devido a sua simplicidade, abrangência e flexibilidade, já que é possível expandir a testes baseados em modelo.
Isto porque, além de descrever o comportamento do sistema, a UML também permite inserir restrições ao modelo através de uma linguagem própria para invariantes, pré e pós-condições, definindo precisamente como devem ser alguns estados do sistema.
Originalmente, a UML foi desenvolvida com o objetivo de ser apenas um instrumento para representar características do sistema.
Entretanto, com o aumento da complexidade destes, surgiu a necessidade de integrar- se à modelagem o conceito de teste de software.
Em este contexto, seguindo o modelo UML.
O U2TP define uma linguagem para projeto, visualização, especificação, análise, construção e documentação das características do sistema testado.
Pode ser utilizado sozinho, para especificar apenas os pontos do sistema que serão testados, ou de forma integrada com a UML, para descrever tanto o sistema, como os casos de teste.
Um exemplo do uso do U2TP pode ser visto nas Figuras 6 e 7, extraídas do trabalho apresentado por Biasi e Becker.
A Figura 6 apresenta a modelagem UML de um sistema de vendas, com a inserção do estereótipo &quot;sut», do U2TP, destacando as classes do software que serão testadas.
Já a Figura 7 ilustra o modelo U2TP que descreve como o sistema será avaliado, incluindo os estereótipos &quot;testcontext», que representa a definição do pacote de teste, &quot;testcase», que indica a instância de cada um dos casos de teste a serem executados, e &quot;setup», que permite associar à operações definidas por um diagrama de seqüência externo.
Em função de a quantidade de funcionalidades providas por os sistemas, e do curto período de tempo dedicado à fase de testes dentro de o ciclo de desenvolvimento, o comportamento dos softwares tem sido analisado de forma cada vez mais deficiente.
Normalmente, apenas um pequeno conjunto de testes é aplicado ao sistema, em sua maioria testes funcionais.
Desta forma, muitos outros aspectos deixam de ser avaliados, como por exemplo, segurança.
Para auxiliar neste processo, a técnica de teste baseado em modelos vem tornando- se popular.
Com esta, é possível gerar casos de teste a partir de a extração de informações específicas do modelo, de acordo com o aspecto que deseja- se avaliar.
É importante salientar que existe outra técnica de teste utilizando modelos, conhecida como model-- checking.
Diferente da técnica de teste baseado em modelos, cujo objetivo é automatizar o processo de geração de casos de teste, a técnica de model-- checking visa validar o modelo.
Para tanto, algumas regras são aplicadas ao modelo, que são posteriormente verificadas através de um analisador formal.
A maior vantagem desta abordagem é a possibilidade de se detectar algumas inconsistências ainda na fase de projeto do software, quando a correção dos problemas é mais rápida e barata do que se realizada após a etapa de implementação.
Entretanto, apesar de as vantagens relacionadas ao uso de model-- checking, a técnica utilizada neste trabalho é a de teste baseado em modelos.
Um dos modelos mais utilizados para auxiliar no processo de teste baseado em modelos é a linguagem UML, e isto se deve a diversos motivos.
Ela é uma notação fácil de utilizar, simples e grande parte dos engenheiros de software possui algum tipo de treinamento a respeito de ela.
Além disso, UML é flexível, sendo possível estender- la para modelar aspectos específicos, o que contribuiu para sua popularização e posição de modelagem padrão da indústria.
Por estes motivos, apesar de o estudo de outros modelos formais e do reconhecimento de que estes também podem ser aplicados à área de teste, optou- se por utilizar a linguagem UML como base para este trabalho.
Considerando que o objetivo deste é automatizar o processo de geração de casos de teste de segurança a partir de modelos formais, é preciso primeiramente inserir informações de segurança no modelo, o que será feito através do uso de estereótipos.
Em a seqüência, é preciso interpretar o modelo e extrair as informações relevantes à geração dos casos de teste.
Isto é feito através da análise do arquivo XML Metadata Interchange (XMI), um documento que descreve tanto a organização dos diagramas do sistema, como as informações inseridas através dos estereótipos.
Conforme mencionado no Capítulo 2, realizar testes de segurança numa aplicação ou protocolo implica em analisar o software, fazer o levantamento das possíveis vulnerabilidades que podem afetar- lo e executar os testes.
Entretanto, devido a a variedade de ataques existentes, este processo torna- se demorado, extrapolando o curto prazo que normalmente é dedicado à fase de testes.
Além de o tempo, outro fator que dificulta a execução de testes de segurança é a falta de experiência dos testadores, que precisam conhecer a maioria dos ataques (ou pelo menos o comportamento padrão de estes), bem como estruturas e protocolos que podem ser explorados.
Considerando que o conhecimento sobre ataques e vulnerabilidades é essencial para qualquer estudo relacionado a teste de segurança, este capítulo tem como objetivo apresentar algumas taxonomias de segurança propostas por pesquisadores da área.
Elaborar uma taxonomia significa dividir um conjunto de objetos em classes, onde os objetos pertencentes a uma mesma classe possuem características em comum se analisado determinado critério.
Desta forma, o estudo de taxonomias de segurança é importante pois permite analisar e compreender o comportamento dos ataques, identificando similaridades entre eles.
Além disso, ele auxilia na escolha de um modelo que permita representar adequadamente os padrões dos ataques, permitindo que os requisitos de segurança sejam considerados desde a fase de projeto do software.
Sendo assim, durante este capítulo serão apresentadas as características e os critérios de classificação de algumas taxonomias de segurança, extraídas da compilação feita por Undercoffer.
A o final, será feita uma comparação entre elas, visando concluir a que melhor descreve os tipos de falha que comprometem a segurança de um software e que servirá como guia para o resto do trabalho.
Visando auxiliar o processo de detecção de intrusão em sistemas, a Defense Advanced Research Projects Agency (DARPA) desenvolveu uma taxonomia de ataques relativamente simples, composta por apenas quatro classes.
Para elaborar- la, o primeiro passo foi selecionar que ataques os sistemas de detecção de intrusão conseguiam identificar (objetivo final do trabalho), e então agrupar- los de acordo com as características em comum.
Ao todo foram escolhidos 38 ataques, divididos entre as seguintes categorias:·
Usuário remoto para local (Remote to local);·
Usuário comum para super usuário (User to root);·
Ataques de vigilância (Surveillance/ probing).
Conforme mencionado, a DARPA baseou- se numa série de ataques conhecidos, divididos de acordo com os sistemas operacionais que afetavam.
A Tabela 1 apresenta que ataques são estes e em que categorias eles foram classificados.
Classificam- se como ataques de Denial of Service (DoS) aqueles que, como resultado, tornam indisponível um serviço provido por um host ou por a rede.
A segunda categoria refere- se aos ataques conhecidos como Remote to Local (R2L), ou seja, aqueles cujo objetivo é prover acesso local a um usuário malicioso que está conectado à rede remotamente.
A terceira classe definida por a taxonomia abrange os ataques que garantem privilégios de super usuário a um usuário local da máquina, conhecidos como User to Root (U2R).
A última categoria apresentada por a taxonomia refere- se aos ataques de vigilância (surveillance).
Ataques desta classe aproveitam- se das informações coletadas por os softwares de varredura da rede (scans) para explorar as vulnerabilidades apontadas por estes.
Como é possível perceber, a taxonomia proposta por a DARPA é relativamente genérica, tendo como critério de classificação o objetivo ou resultado do ataque.
Devido a sua superficialidade, ela não consegue representar diversos tipos de ataque, como os que aproveitam- se de problemas existentes em protocolos de comunicação ou em algoritmos ruins para criptografia.
Por este motivo, definir um modelo para segurança baseado nesta classificação torna- se inviável, pois o resultado final não abrangerá diversos ataques.
A segunda taxonomia abordada é de autoria de Taimur Aslam.
Assim como a proposta por a DARPA, a construção desta taxonomia também foi baseada nas falhas de segurança que afetavam sistemas operacionais.
Entretanto, ao invés de considerar falhas de diversos sistemas operacionais, Aslam analisou apenas as falhas que afetavam o sistema operacional Unix.
Após identificar- las, ele buscou informações sobre como cada falha era explorada, que área funcional do sistema que ela afetava, em que versões estavam presentes e as conseqüências atribuídas a cada uma.
De este estudo, concluiu- se que as falhas poderiam ser classificadas em três categorias maiores.
São elas:·
Falhas de codificação;·
Falhas operacionais;·
Falhas de ambiente.
É importante ressaltar que esta taxonomia aborda apenas as falhas que afetam diretamente o software, desde a sua implementação até a sua instalação.
Em este caso, não são previstos os casos de exposição de informações confidenciais por parte de os funcionários, problemas na comunicação, problemas de acesso físico e uso de softwares para captura de informações.
A primeira categoria proposta refere- se às falhas de codificação, que ocorrem durante o ciclo de desenvolvimento do software.
Visando refinar esta categoria, foi feito um estudo aprofundado das falhas que normalmente comprometem o funcionamento do software, para que fosse possível identificar que parte específica no código provocava a vulnerabilidade.
A segunda classe engloba as vulnerabilidades provenientes de falhas operacionais, resultantes de problemas com a instalação do software.
O mesmo processo de detalhamento foi usado, ou seja, tentou- se identificar que operações levavam àquela falha e então utilizar esta informações para criar subcategorias.
A terceira e última categoria refere- se às falhas de ambiente.
Falhas deste tipo podem ocorrer devido a limitações no sistema onde o software está sendo executado, a problemas no compilador ou no sistema operacional utilizado ou em função de problemas de comunicação existentes entre os módulos do sistema.
Por os fatores considerados e por a forma como foram divididos, a taxonomia é abrangente e não-ambígua.
Além disso, a estrutura em árvore permite identificar aos poucos as características do problema existente, chegando- se a um nodo folha com maior precisão.
Para facilitar este processo, Aslam ainda define uma árvore de critérios de seleção, que indica aos poucos como as características da falha devem ser analisadas.
Concluindo, outra vantagem desta taxonomia é que ela é expansível, ou seja, ela pode ser estendida para abranger outros sistemas operacionais ou mesmo incluir novas categorias de falhas.
A terceira taxonomia aqui apresentada foi proposta por Anil Bazaz et al.,
e possui como objetivo identificar recursos do software que podem ser afetados por ataques.
A partir de esta identificação, os pesquisadores elaboraram uma série de restrições e cuidados que os programadores devem ter durante o desenvolvimento do software.
Através da análise de exploits de segurança, obtidos a partir de livros, listas de e-mail e websites, foram identificados os recursos que são os alvos mais comuns de ataques de segurança.
São eles:·
Memória principal;· Entrada/ saída de dados;·
Recursos de criptografia.
Considerando estes três recursos como os de maior necessidade para um software, eles tornaram- se a base da taxonomia, sendo convertidos em classes genéricas.
A partir de então as características particulares de cada ataque foram sendo identificadas, refinando a taxonomia e criando subclasses.
A árvore final da taxonomia pode ser vista na Figura 9.
Como a classificação é baseada nos recursos utilizados, o desenvolvedor pode utilizar- la para identificar os que ele utiliza e, então, prever que ataques podem ocorrer e empregar políticas para evitar- los.
A elaboração destas práticas é o objetivo final dos autores da taxonomia, mas até o momento foram apresentadas apenas boas práticas associadas à memória dinâmica.
Enfim, a abordagem difere das outras pois ela não visa identificar a causa ou a conseqüência de um ataque, mas sim o recurso que será utilizado por o software.
Portanto, é mais sistemática, pois permite visualizar previamente os possíveis pontos de vulnerabilidade e desenvolver- los com cuidado, evitando assim que futuras vulnerabilidades afetem o software sob implementação.
A taxonomia proposta por Weber utiliza como critério de classificação os tipos de falhas que podem afetar um software.
Esta abordagem é útil para engenheiros de software e desenvolvedores, que devem prever e evitar problemas de projeto e implementação.
A Tabela 2 demonstra como ela está organizada.
A primeira divisão utiliza, como critério de classificação da taxonomia, a forma como a falha foi inserida no software.
As falhas podem ser inseridas de forma intencional, quando deseja- se acrescentar alguma funcionalidade ao software, ou de forma acidental, que ocorre durante o desenvolvimento normal do software.
Segundo a taxonomia, as falhas intencionais podem ser de duas formas:
As inseridas de forma maliciosa, como as que abrem portas indevidas no sistema, e as inseridas de forma não-maliciosa, como as que alteram a estrutura de diretórios, tornando inválidos os caminhos de acesso aos arquivos.
Em relação a as falhas acidentais, a taxonomia identifica diversas categorias de problemas de implementação do software.
A primeira refere- se aos erros de validação dos dados, ou seja, falhas que ocorrem em função de os dados de entrada não terem sido validados corretamente.
Alguns ataques que utilizam- se das vulnerabilidades classificadas nesta categoria são:
Buffer overflow e acesso a posições inexistentes (erros de endereçamento), atribuição de valores inexistentes a uma variável (erros de validação de parâmetros) e execução indevida de alguma operação (identificação/ autenticação inadequada).
A segunda classe corresponde aos erros de abstração, também conhecidos por erros de domínio.
Ocorrem em sistemas onde um módulo, que deveria visualizar apenas um modelo abstrato dos outros módulos, consegue manipular ou acessar informações internas destes.
Vulnerabilidades deste tipo permitem, por exemplo, que o atacante recupere senhas ou documentos (para o caso de reuso de objetos) ou consiga privilégios através da modificação de algum bloco de controle crítico (exposição da representação interna).
A terceira categoria refere- se às falhas assíncronas, ou seja, que permitem que o atacante utilize- se de problemas existentes no controle dos processos para danificar o sistema.
Encontramse nesta categoria as falhas de concorrência, como deadlocks e ataques de race condition, e as falhas de inconsistência de nomenclatura, como usar diferentes nomes para referir- se ao mesmo objeto.
A quarta classe de falhas corresponde ao mau uso ou defeito dos subcomponentes.
Acontece quando o sistema não gerência de forma adequada os recursos, como por exemplo, quando a memória alocada por o sistema não é liberada corretamente.
Este tipo de falha é classificado na taxonomia como estouro de recursos, e pode ser explorado, por exemplo, com um ataque de flooding de conexões.
A outra subdivisão desta categoria chama- se falhas de responsabilidade.
Em esta, devido a inconsistências presentes nas interfaces dos subcomponentes, o sistema tornase vulnerável.
Assim, de acordo com a operação executada, é possível, por exemplo, elevar os privilégios de um usuário após um ataque de buffer overflow.
A quinta e última divisão corresponde aos erros de funcionalidade, ou seja, que estão diretamente relacionados à implementação das funcionalidades do sistema.
Divide- se em duas categorias:
Defeito na manipulação de erros, que ocorre quando as exceções do sistema são manipuladas de forma incorreta, e em outros erros de funcionalidade, onde podem ser classificados os outros problemas de implementação, tais como o armazenamento inseguro de informações.
Sendo assim, como é possível perceber, esta taxonomia é mais completa que as demais, pois permite classificar qualquer tipo de falha ocorrida durante o processo de desenvolvimento do software.
Apesar de ser ambígua, já que permite classificar o mesmo tipo de vulnerabilidade em diferentes categorias, a taxonomia de Weber é a mais atual e mais citada por os autores, pois orienta para uma implementação segura e tem a capacidade de representar falhas atuais, como por exemplo Cross-Site Scripting (XSS).
Quando um analista define que casos de teste serão aplicados num software, ele deve seguir um plano que permita avaliar a maior parte do sistema, na tentativa de identificar o máximo de defeitos possível.
Entretanto, diferentemente dos outros tipos de teste que possuem técnicas consolidadas para critérios de cobertura, não existem métricas para avaliar a eficácia dos testes de segurança.
Desta forma, quando se deseja determinar cientificamente que vulnerabilidades ou ataques podem afetar um sistema, utilizam- se taxonomias de segurança.
A existência destas taxonomias permite ter um panorama geral dos aspectos de segurança que se deseja analisar.
Normalmente, o critério de classificação utilizado é o de vulnerabilidades conhecidas, mas também existem trabalhos que baseiam- se em tipos de ataques ou recursos afetados do sistema.
Após definir a taxonomia que será utilizada como guia, resta ao analista avaliar que casos podem afetar o sistema e definir que testes serão realizados para verificar a existência destes.
Diversas taxonomias de segurança foram estudadas durante este trabalho.
Entretanto, grande parte destas foi elaborada há bastante tempo, estando desatualizada.
Sendo assim, a taxonomia escolhida para ser utilizada como base foi a proposta por Weber.
Como critério de classificação, ela utiliza os tipos de falhas que podem afetar um software, o que a torna simples e abrangente, já que consegue representar a maior parte das vulnerabilidades.
Para complementar o estudo sobre falhas e vulnerabilidades, avaliou- se, além de a taxonomia, a base de dados desenvolvida por o projeto The Open Web Application Security Project (OWASP), que mantém uma lista com as 10 vulnerabilidades mais críticas para aplicações Web.
Associada à taxonomia, esta lista foi utilizada para destacar os problemas mais comuns de segurança, permitindo, inclusive, concluir sobre a viabilidade de representar estes através de estereótipos UML.
Sendo assim, devido a sua simplicidade e capacidade de representação, estas foram as estruturas escolhidas para inserir as informações relevantes aos casos de teste no modelo do sistema a ser testado.
A dinâmica do mercado de Tecnologia da Informação exige a liberação constante de novas versões de software, estipulando prazos cada vez menores para isso.
Esta pressa reduz o tempo dedicado à execução de testes no software, comprometendo não apenas o funcionamento deste, mas também outros aspectos importantes, como segurança.
Em este contexto foi proposta, nos últimos anos, uma nova técnica de teste, denominada teste baseado em modelos.
O objetivo desta técnica é gerar casos de teste automatizados a partir de o modelo do sistema, de acordo com o aspecto que se deseja testar.
O processo para utilizar- la pode ser dividido em duas etapas:
A primeira consiste em especificar no modelo as informações relevantes sobre o aspecto testado;
A segunda, em desenvolver um algoritmo de geração de casos de teste a partir de estas informações.
Considerando que o contexto deste trabalho é automatizar o processo de geração de casos de teste voltados à segurança, foram estudados alguns trabalhos já existentes na área a fim de verificar a eficiência e as limitações destes.
Sendo assim, este capítulo está dividido em duas seções:
A Seção 5.1 refere- se aos trabalhos focados na área de modelagem de aspectos de segurança, enquanto que a Seção 5.2 apresenta algumas ferramentas e algoritmos para geração de casos de teste.
Conforme mencionado anteriormente, o primeiro passo para viabilizar a técnica de teste baseado em modelos é inserir, no modelo, as informações relevantes sobre o aspecto que se deseja avaliar.
Devido a sua simplicidade e capacidade de representação, optou- se por utilizar como base deste trabalho o modelo UML.
Embora a inserção de restrições OCL nos diagramas da UML permita descrever, de forma precisa, diferentes características do sistema, ela é uma linguagem de difícil compreensão.
Este fato fez com que os engenheiros de software estendessem a UML utilizando uma terceira representação, baseada em estereótipos e tags.
UMLSec. Ele foi criado para modelar e avaliar aspectos de segurança, visando garantir alguns princípios básicos da área, tais como descrever operações confiáveis e marcar links seguras.
Estereótipo Internet encrypted Classe Base link Tags link subsystem assinalado em links secure links secrecy Restrições dependency subsystem &quot;call «e &quot;send «secure dependency critical no down-flow object subsystem data security package fair exchange após o estado start, eventualmente alcanço estado stop Descrição Conexão à Internet Conexão criptografada Conexão LAN Reforça a segurança dos links de comunicação Sigilo de informações Interação estrutural sobre segurança de dados Objetos críticos Fluxo de informações Requisitos básicos de segurança de dados Reforçar operação de troca justa A explicação de cada estereótipo pode ser visto a seguir.&amp;&amp;&amp;·
Os estereótipos &quot;Internet», &quot;encrypted «e &quot;LAN «são utilizados nos links do diagrama de implantação.
Denotam o tipo de link de comunicação;·
O estereótipo &quot;secure links «é usado para marcar susbsistemas onde é preciso garantir que os requisitos de segurança da comunicação estão sendo atendidos por a camada física;·
O emprego do estereótipo &quot;secrecy «assinala objetos ou diagramas de componentes em que as dependências devem prover o sigilo dos dados enviados como argumento ou retorno de operações;·
O estereótipo &quot;secure dependency «pode ser inserido em subsistemas contendo diagramas de objetos ou estruturais.
Visa garantir que as dependências &quot;call «ou &quot;send «respeitem os requisitos de segurança dos dados enviados através de eles;·
O estereótipo &quot;critical «marca objetos cujas instâncias são consideradas críticas para o sistema;·
O estereótipo &quot;em o down-flow «é utilizado para assinalar subsistemas e é usado para melhorar a segurança do fluxo de informações do sistema;·
O estereótipo &quot;data security «marca subsistemas cujo comportamento deve respeitar os requisitos de segurança de dados destacados por o estereótipo &quot;critical «e tags associadas;·
O estereótipo &quot;fair exchange «é utilizado para formalizar os requisitos de troca justa.
Com as tags &quot;start «e &quot;stop «é possível definir um comportamento em que, se uma função alcança o estado S1 marcado por &quot;start», então ele chega ao estado S2 marcado por &quot;stop».
SecureUML propõe uma extensão da linguagem UML para especificar políticas de acesso baseadas em papéis, conhecidas como role-based Access Control (RBAC).
O objetivo desta é descrever estruturas de controle de acesso ao sistema, ainda no modelo UML, agregando a simplicidade da notação gráfica utilizada por o modelo RBAC ao formalismo associado as restrições lógicas especificadas com OCL.
Como mencionado anteriormente, a linguagem SecureUML é baseada numa extensão do modelo RBAC.
Mesmo que este modelo de controle de acesso seja bem estabelecido, com inúmeras vantagens reconhecidas e suportado por diversas plataformas, ele possui algumas limitações.
Um exemplo é a deficiência em expressar condições de acesso referentes aos estados do sistema, tais como o acesso à recursos protegidos, hora ou data.
A fim de solucionar estes problemas, introduziu- se, no SecureUML, o conceito de restrições de autorização, ou seja, précondições que garantem acesso a algumas operações.
A definição destas restrições é feita através da linguagem OCL.
Com esta estrutura, é possível especificar as políticas de acesso simples através de permissões baseadas em papel, através do modelo RBAC, enquanto que as mais complexas podem ser descritas adicionando- se restrições de autorização.
A Figura 11 apresenta o metamodelo que define a sintaxe abstrata do SecureUML.
A fim de provar que é possível gerar estruturas de segurança para controle de acesso usando o modelo proposto, foi implementado um gerador de componentes para a arquitetura EJB utilizando os estereótipos propostos por o SecureUML.
A Figura 12 demonstra um exemplo de aplicação do SecureUML num sistema com dois componentes:
Um Calendário e um Registro.
Um calendário pode conter diversos registros, todos contendo uma data de início, término, localização e pertencer a um dono.
As demais estruturas são usadas para expressar informações sobre controle de acesso através do SecureUML.
Após a análise do modelo, foram obtidas aplicações EJB com controles de acesso já configurados, incluindo definição de papéis, permissões e restrições de autorização.
Cada elemento modelado é convertido em políticas de segurança para um componente EJB.
Alguns exemplos de código gerado a partir de estas definições podem ser vistos na Figura 13.
A partir de o que foi descrito, é possível concluir que o uso do SecureUML permite especificar políticas de controle de acesso de forma precisa, ainda na fase de projeto de software, através de diagramas UML.
Por ser genérico, pode ser utilizado com qualquer arquitetura de segurança que suporte o acesso baseado em papéis, entretanto não consegue especificar outros aspectos que não estejam relacionados ao controle de acesso.
Sendo assim, esta proposta pode ser utilizada, por exemplo, quando é preciso configurar aplicações responsáveis por o acesso ao software, mas não para descrever outros aspectos de segurança, tais como estouro de buffer ou uso de protocolos inseguros.
Como parte da técnica de teste baseado em modelos, além de a especificação de aspectos de segurança, também é preciso automatizar o processo de teste de software.
Este pode ser dividido em duas etapas:
A de geração dos casos de teste a partir de o modelo e a de execução dos testes, seja através de drivers de teste ou scripts próprios.
Existem diversos trabalhos e ferramentas cujo objetivo é auxiliar no processo de teste.
A descrição de alguns pode ser vista nas seções seguintes.
O Apache JMeter é uma ferramenta projetada para executar testes funcionais e de desempenho de forma automatizada.
Originalmente foi desenvolvida para avaliar sistemas Web, mas devido a sua eficiência e simplicidade foi expandida para suportar outros tipos de aplicações, tais como o teste de servidores FTP, arquivos e scripts em Perl.
De entre suas funcionalidades, está a capacidade de simular grandes quantidades de tráfego para servidores e redes, a fim de avaliar o desempenho destes.
Ele também disponibiliza diversos tipos de gráficos como saída, o que facilita a análise dos resultados obtidos com os testes.
Diferentemente de outras ferramentas voltadas a área de teste, o Apache JMeter exige poucas configurações para executar um caso de teste.
Por sua arquitetura ser baseada em plug-ins, ele possui um núcleo básico que contém algumas funções já implementadas, tais como o envio de pacotes Http e FTP, restando ao usuário apenas definir alguns parâmetros.
Além disso, a ferramenta é extensível, sendo possível adicionar novas funcionalidades a ela desenvolvendo plug-ins específicos para as necessidades dos usuários.
A Figura 14 apresenta como seria a definição dos parâmetros para executar um teste de requisições FTP.
Analisando- se a estrutura do teste, é possível perceber que o caso a ser executado aparece na árvore a esquerda da tela, abaixo de o nodo Thread Group.
O Apache JMeter possui uma série de elementos que permitem estruturar os casos de teste, e Thread Group é um de eles.
É este elemento que define a seqüência em a qual os testes serão executados.
A execução de uma Thread Group dispara todos os testes associados a ela, independente da existência de outras threads.
Outros elementos amplamente utilizados são:·
Samplers, que definem o tipo de teste que vai ser realizado (ex.:
Http Request e FTP Request);·
Logical Controllers, que permitem configurar a lógica utilizada no envio de requisições (ex.:
While Controller);· Listeners, que permitem visualizar os resultados obtidos com a execução dos testes (ex.:
View Results Tree);· Assertions, que permitem verificar se os valores retornados por a aplicação sob teste são realmente válidos.
A Figura 15 utiliza alguns destes elementos para demonstrar os resultados obtidos com o envio de uma mensagem FTP Request.
Apesar de as inúmeras funcionalidades providas por a ferramenta Apache JMeter, ela não possui suporte a teste de segurança.
Considerando que um de seus objetivos é realizar testes de desempenho, uma das poucas aplicações na área de segurança seria o envio excessivo de requisições, simulando um ataque de flooding.
Em este, um usuário malicioso envia um número maior de mensagens do que a máquina destino pode processar, resultando no esgotamento de recursos de memória, processador ou até mesmo numa negação de serviço.
Outros ataques relacionados à conexão e envio de dados também poderiam ser executados, desde que fossem incluídas algumas funcionalidades extras na ferramenta.
Entram nesta categoria os ataques de adivinhação de senhas, inconsistência no formato dos dados, bem como os de tentativa de roubo ou dano à conexão.
Desta forma, apesar de não ser voltado ao teste de segurança, a ferramenta Apache JMeter pode ser utilizada para executar alguns casos, desde que incluídas as devidas funcionalidades.
Diferentemente da ferramenta Apache JMeter, descrita na Seção 5.2.1, o STAte-based Test GEnerator (STAGE) é um gerador de casos de teste e scripts funcionais a partir de o modelo da aplicação a ser testada, descrita através de autômatos finitos.
Ela permite utilizar um dos seguintes modelos de autômatos:
Máquina de estados finitos (Finite State Machine, FSM), máquina de estados finitos virtual (Variable Finite State Machine, VFSM) ou cadeias de Markov.
Com base neste modelo, a ferramenta identifica os caminhos que podem ser percorridos por o software e determina que combinações devem ser testadas.
A Figura 16 apresenta um exemplo de modelo de aplicação através de autômatos finitos.
Como mencionado anteriormente, a ferramenta identifica, a partir de o modelo da aplicação, quais são os caminhos que podem ser percorridos durante a execução da ferramenta.
Cada caminho representa um caso de teste, e a geração destes é feita por um módulo denominado Test Case Generator, ou simplesmente TCG.
Ele verifica, desde o estado inicial, todas as formas de se chegar ao estado final, garantindo assim que todos os caminhos do software tenham sido cobertos.
A forma como os casos de teste são descritos pode ser vista na Figura 17.
Como o objetivo do STAGE é gerar os possíveis caminhos que podem ser executados por o software, ele não se preocupa em considerar outros aspectos, como segurança.
Entretanto, é possível adaptar os testes aplicados na interface e utilizar- los para avaliar alguns casos desta área.
Um exemplo é o mapeamento dos componentes para entradas de dados, que se mal implementados podem comprometer a segurança do aplicativo devido a um problema de estouro de buffer ou inconsistência de dados.
Outro exemplo são os casos de falhas de autenticação (By Passing), onde a partir de um estado chega- se a outro sem passar por um intermediário, responsável por validar a identidade do usuário.
Portanto, apesar de não possuir nenhuma estrutura especialmente dedicada a segurança, é possível utilizar alguns dos casos de teste de interface gerados, para analisar este aspecto.
O teste de alguns casos, como o roubo de conexão entre duas máquinas, por exemplo, é inviável, mas com algumas modificações é possível ao menos ampliar o número de situações que podem ser transformadas em casos de teste de segurança mapeadas por o STAGE.
A Hp QAInspect é uma ferramenta de uso simples e que oferece uma solução totalmente automatizada para a realização de testes de segurança em aplicações Web.
Ela foi desenvolvida com o objetivo de auxiliar os profissionais de teste de software a avaliar aspectos de segurança, tenham eles conhecimento desta área ou não.
A ferramenta é integrada ao Hp Quality Center, um ambiente de gerenciamento que permite integrar diferentes tipos de testes, como funcionais e de desempenho.
Para avaliar uma aplicação utilizando o software QAInspect, é preciso ter uma licença de uso deste e do Quality Center.
Entretanto, é disponibilizada uma licença de avaliação cuja duração é de 15 dias e que permite realizar testes sobre uma aplicação única.
Os testes realizados por o QAInspect podem ter caráter unitário, sendo voltados a um cenário ou página, ou integrados, e realizados sobre a aplicação como um conjunto de páginas.
Também podem ser do tipo Crawl que gera e estuda a estrutura tanto das informações como da plataforma da aplicação, e/ ou do tipo Audit que verifica a existência de uma vulnerabilidade e determina uma prioridade para a mesma.
Antes de executar um teste, é preciso configurar uma série de parâmetros, tais como o endereço e tipo de aplicação Web, e a política de segurança utilizada.
O QAInspect possui uma série de testes já definidos, e a escolha dos casos que serão testados acontece de acordo com a política de segurança selecionada.
Entre as políticas disponíveis encontram- se a SarbanesOxley, a ISO 17799, a PCI Data Security Standard e a OWASP Top Ten, um projeto que mantém uma lista com as 10 vulnerabilidades mais críticas para aplicações Web.
Após a execução dos testes, é possível analisar todas as vulnerabilidades encontradas por o QAInspect na aplicação testada.
Uma vantagem deste software é que os detalhes dos testes são exibidos de forma detalhada, apresentando dados sobre o nome da página avaliada, o tipo de irregularidade encontrado e o quão crítico é o problema.
Ela também apresenta uma descrição da vulnerabilidade encontrada, além de dicas sobre como executar o teste manualmente e como evitar que a vulnerabilidade aconteça.
Como exemplo, vamos analisar a vulnerabilidade de número 93, que refere- se à execução de um ataque de SQL Injection.
Este consiste na execução de comandos SQL no banco de dados através de caixas de texto.
É um falha de implementação que extrai a informação diretamente das caixas de texto e a preenche na consulta SQL.
Analisando- se os resultados apresentados para o caso de SQL Injection, é possível ver como o QAInspect executou o teste.
O primeiro passo consiste em enviar uma consulta SQL no campo de login da página login.
Asp, através de uma mensagem Http Request.
Em a seqüência, é preciso analisar a mensagem Http Response obtida como resposta ao código malicioso enviado para a aplicação Web.
As Figuras 19 e 20 apresentam o conteúdo das mensagens Http Request e Http Response, respectivamente.
Analisando- se a mensagem de resposta, é possível perceber que o teste não foi executado com sucesso, já que a tabela &quot;spitable «não foi encontrada.
Entretanto, apesar de o ocorrido, é possível concluir que a aplicação aceitou o código SQL enviado, já que avaliou os parâmetros enviados.
Se o nome da tabela estivesse correto, seria possível consultar- la, alterar- la ou mesmo deletar- la do sistema.
Sendo assim, o uso do QAInspect auxilia no processo de teste, pois executa, de forma automatizada, testes que exigiriam pessoas qualificadas para executar- los.
Além disso, o tempo despendido com a execução dos testes é menor do que se estes fossem realizados de forma manual, já que diversos casos podem ser verificados paralelamente.
Uma limitação do software é que ele consegue executar apenas os casos pré-descritos por as políticas de segurança, não sendo possível expandir- lo para suportar outros testes.
Desta forma, se algum usuário malicioso criar um novo tipo de ataque, será preciso esperar até que uma nova versão do software seja disponibilizada, já que ele é comercial e de código fechado.
Mesmo sendo possível descrever características de segurança usando apenas UML e OCL, com o objetivo de garantir princípios básicos ao sistema, como marcar links seguros e descrever a operação de troca justa.
Lodderstedt et al.
Propuseram o SecureUML, uma extensão da UML para especificar políticas para controle de acesso através de notações gráficas e restrições OCL.
Outros trabalhos também propõem a expansão do modelo UML para representar políticas propôs um framework para integrar políticas de segurança e de validação de acesso no modelo, com o objetivo de orientar os desenvolvedores.
O segundo utiliza técnicas de visualização para representar a violação de restrições de controle de acesso, ao invés de descrever- las usando OCL.
Para auxiliar no processo de geração de casos de teste de segurança, objetivo deste travalho, é preciso um modelo que represente as vulnerabilidades que podem afetar o software, bem como em que partes deste elas podem ocorrer.
Além disso, deve conter informações necessárias ao processo de teste, para que seja possível definir os casos que devem ser executados e qual o comportamento esperado.
Apesar de a quantidade de trabalhos encontrados sobre modelagem de aspectos de segurança, nenhum representa estas informações.
Sendo assim, optou- se por descrever um conjunto de estereótipos próprios para representar estas características.
A descrição de cada estereótipo, bem como a forma de uso, podem ser vistos no Capítulo 6.
Além de as técnicas de modelagem de aspectos de segurança, também foram estudadas algumas ferramentas de geração e execução de casos de teste.
Para tanto, foram analisadas as ferramentas Apache JMeter, STAGE e Hp QAInspect.
O objetivo da ferramenta Apache JMeter é realizar testes de desempenho e funcional em aplicações Web.
Ela implementa uma série de funcionalidades que permitem fazer requisições para uma aplicação, ou mesmo enviar grandes quantidades de conteúdo para ela.
Apesar de ser possível utilizar- la para executar ataques de segurança baseados em requisições, ela não foi desenvolvida com este propósito, apresentando limitações em executar casos simples, como estouro de buffer.
Ela também não possui a funcionalidade de gerar casos de teste a partir de modelos, outra área de interesse deste trabalho.
A segunda ferramenta estudada, o STAGE, tem como objetivo gerar e executar casos de testes funcionais.
Baseando- se no modelo da aplicação, descrito através de autômatos, a ferramenta retorna todas as combinações de caminhos possíveis e ainda gera a implementação destes no formato de entrada das ferramentas Rational XDE Tester e HttpUnit, ambas para automação de teste.
A proposta da ferramenta é interessante, pois permite a geração de casos de teste a partir de o modelo, mas possui duas limitações.
A primeira é o tipo de modelo utilizado, autômatos finitos ao invés de UML, base deste trabalho.
A segunda é o tipo de teste executado.
Apesar de ser possível executar alguns casos de segurança como se estes fossem funcionais, grande parte dos testes exige informações adicionais, como os ataques de flooding e roubo de informações.
A última ferramenta avaliada foi a Hp QAInspect.
Apesar de esta ser voltada à área de segurança, ela possui algumas limitações.
Uma de elas é o fato de ela não pode ser expandida, o que significa que apenas os casos já existentes podem ser executados.
Além disso, ela não trabalha com o modelo do sistema, mas diretamente na aplicação real.
O principal problema associado a este fato é a falta de garantia de que todo o software foi coberto por os casos executados, o que é facilmente visualizado através de modelos.
Considerando as limitações encontradas por as ferramentas, optou- se por implementar um algoritmo que interprete o modelo UML com os estereótipos de segurança e gere os casos de teste automaticamente.
Com os estereótipos é possível assinalar as partes do sistema que devem ser desenvolvidas cuidadosamente, caso contrário podem tornar- se vulneráveis.
Já os casos de teste servem para indicar os passos que os testadores devem seguir para verificar a existência da vulnerabilidade.
A descrição destas duas etapas do trabalho podem ser vistas no Capítulo 6.
Devido a evolução dos sistemas de computadores e à quantidade de funcionalidades que estes provêem, os softwares adquiriram tamanha complexidade que mesmo testar- los tornou- se uma tarefa complicada.
A dinâmica do mercado de tecnologia da informação exige a liberação de novas versões constantemente, estipulando prazos cada vez menores para isso.
Esta pressa reduz o tempo dedicado à execução de testes no software, comprometendo não apenas o funcionamento deste, mas também outros aspectos importantes como segurança.
Em este contexto, uma outra abordagem de teste vem se tornando popular, denominada de teste baseado em modelos.
O uso desta técnica auxilia o processo de teste de software pois permite gerar, automaticamente, casos de teste a partir de o modelo da aplicação.
Dois elementos são necessários para utilizar- la:
Um modelo do software, contendo as informações sobre o aspecto que será testado, e um gerador de casos de teste, que extrairá estas informações do modelo e as converterá em etapas do teste.
Além de permitir a geração dos casos de teste, o modelo também serve para orientar os desenvolvedores, destacando as partes do software que podem tornar- se vulneráveis se não implementadas cuidadosamente.
Ao mesmo tempo, os casos de teste gerados indicam os passos que os testadores devem executar para verificar se o uso do modelo foi efetivo e se as vulnerabilidades demarcadas realmente não afetam o software.
O objetivo deste trabalho não é validar o modelo, técnica conhecida como model-- checking, mas utilizar- lo como base para gerar casos de teste e aplicar- los ao produto final, processo denominado de teste baseado em modelos.
Para elaborar- lo, ele foi dividido em duas partes:
A primeira consiste na definição de estereótipos para representar informações de segurança em modelos UML.
A segunda é um algoritmo que analisa estes estereótipos, extrai as informações relevantes do modelo e gera os casos de teste.
Sendo assim, este capítulo apresenta a motivação e objetivos deste trabalho, bem como descreve o funcionamento das etapas de especificação de aspectos de segurança e geração de casos de teste.
Durante a elaboração deste trabalho, diversas áreas correlatas foram estudadas, como teste de software, no Capítulo 2, modelos formais, no Capítulo 3 e taxonomias de segurança, em o· De entre os modelos formais estudados no Capítulo 3, o mais popular é o modelo UML.
Isto se deve ao fato desta notação ser simples, abrangente e flexível, pois pode ser possui algum tipo de treinamento nesta linguagem, o que facilita o seu uso.
A UML também permite inserir restrições ao modelo através de uma linguagem própria para isto, chamada OCL.
Embora com esta seja possível representar diferentes características de um sistema, sua compreensão é difícil, o que faz com que os engenheiros de software estendam a UML através de estereótipos próprios, que representam as informações que se queira adicionar ao modelo.·
Sobre as três primeiras taxonomias estudadas (DARPA, Aslam e Bazaz), devido a o fato de abordarem características amplas dos objetos estudados, não contribuem com a identificação de um padrão de comportamento dos ataques e nem de estruturas que devam ser representadas por os modelos.
Em este sentido, escolheu- se como guia a taxonomia proposta por Sam Weber.
Ela é atual e utiliza como critério de classificação os tipos de falhas existentes, auxiliando a identificar que ataques podem derivar de uma falha específica.
Para complementar as informações providas por a taxonomia de Weber, considerou- se a lista de vulnerabilidades disponibilizada por a OWASP.
Denominada Top Ten List, esta apresenta as 10 vulnerabilidades mais críticas para aplicações Web.
Ela foi escolhida por ser a mesma base de dados de segurança utilizada por Weber para verificar a capacidade de classificação e abrangência de sua taxonomia.
Desta forma, com o auxílio da taxonomia de Weber e com as informações disponibilizadas por a base de dados da OWASP, foram especificados alguns estereótipos para representar as vulnerabilidades que podem comprometer a segurança do sistema.
A lista foi utilizada tanto para fornecer informações a respeito de as vulnerabilidades, como para identificar quais de elas seria possível representar através de estereótipos e quais iriam requerer uma estrutura mais complexa.
O emprego destes estereótipos possui dois objetivos:
Orientar os desenvolvedores durante o processo de concepção do software, destacando partes do modelo que podem tornar- se vulneráveis se não implementados corretamente, e prover informações necessárias à geração automatizada de casos de teste.
Este último indica os passos que devem ser executados por o testador, a fim de verificar se a vulnerabilidade previamente assinalada no modelo afeta o software ou não.
Para analisar o modelo e extrair as informações relevantes, utilizou- se o algoritmo Unique Input/ Output (UIO), que utiliza uma máquina de estados finitos com entradas e saídas para montar a seqüência de execução do software e gerar os casos de teste.
A Figura 21 apresenta a arquitetura geral deste trabalho, descrevendo os passos seguidos desde a fase de modelagem dos estereótipos (destacados por o quadro da esquerda), até a de geração dos casos de teste (destacados por o quadro da direita).
Após a inserção dos estereótipos propostos no modelo UML da aplicação, é gerado um arquivo XMI correspondente, descrevendo a estrutura do sistema, atividades, casos de uso e estereótipos.
Este arquivo é utilizado como entrada para a segunda parte do trabalho, demarcada por o quadro da direita da Figura.
O arquivo XMI é analisado e convertido numa máquina de estados finitos com entradas e saídas.
Em esta, por sua vez, é aplicado o método UIO, cujas saídas são seqüências de passos que, após serem manipuladas, equivalem a casos de teste em linguagem natural.
Além disso, é preciso ressaltar que o processo de especificação dos estereótipos associou a flexibilidade provida por os estereótipos UML, ao conhecimento proveniente da base de dados do projeto OWASP.
Sendo assim, para expandir o conjunto proposto e adicionar estereótipos capazes de representar outras vulnerabilidades, basta analisar uma base de segurança, extrair as informações necessárias ao teste e propôr o caso.
A partir de a análise das taxonomias de segurança foi possível concluir que existem diversos tipos de vulnerabilidades que podem afetar uma aplicação.
Ao mesmo tempo, o estudo dos trabalhos relacionados revelou que a maioria dos autores que define estratégias para especificar aspectos de segurança durante a fase de modelo estão focados em características específicas, como por exemplo controle de acesso.
Visando representar características mais amplas de segurança, este trabalho propõe alguns estereótipos que permitem identificar partes do modelos que podem tornar- se vulneráveis caso sejam mal implementados, ou especificar alguns requi-sitos de segurança, como criptografia.
A inserção destes estereótipos no modelo tem como objetivos orientar os desenvolvedores para que estes evitem algumas falhas, bem como prover informações necessárias à geração automatizada de casos de teste.
Sendo assim, os estereótipos definidos correspondem ao conjunto de testes que será aplicado no software sob avaliação.
Entretanto, antes de se definir os testes, é preciso considerar o tipo de aplicação que está sendo testada.
Isto por que o conjunto utilizado para avaliar um sistema Web, por exemplo, é diferente do aplicado num sistema operacional ou num software para gerenciamento de banco de dados.
Para tanto, existem diversas bases de dados de segurança que elaboram, regularmente, listas com as vulnerabilidades mais críticas para cada tipo de aplicação.
Exemplos destas bases são as do projeto OWASP, do Instituto NIST, do Instituto SANS e do grupo SecurityFocus.
A associação das informações disponibilizadas por estas bases de dados, com a flexibilidade provida por os estereótipos UML, nos permitiu definir estereótipos específicos para representar as informações de segurança.
Considerando a quantidade de serviços disponibilizados por a Internet e o volume de informações enviados através desta, os estereótipos propostos neste trabalho estão voltados à aplicações Web.
Obviamente alguns casos podem ser aplicados em outros tipos de software, mas o foco abordado por este trabalho, bem como os estudos de caso utilizados, serão aplicações Web.
Para auxiliar o processo de definição dos estereótipos, a base de dados utilizada foi a disponibilizada por o projeto OWASP.
Este projeto mantém uma lista com as 10 vulnerabilidades mais críticas que afetam aplicações Web, conhecida como Top Ten List.
Além de indicar as vulnerabilidades, a lista também apresenta uma breve descrição de cada uma e explica como verificar a existência destas, o que foi útil tanto para a geração dos casos de teste, como para definir que vulnerabilidades seria possível especificar através de estereótipos e quais iriam requerer uma estrutura mais complexa.
A Tabela 4 apresenta as vulnerabilidades descritas por esta lista nas duas versões existentes, a de 2004 e de 2007.
De acordo com as categorias apresentadas por a taxonomia de Weber e com as vulnerabilidades extraídas da base de dados do projeto OWASP, apresentados na Tabela 4, os seguintes estereótipos foram definidos:·
Caso 1 -- Buffer Overflow:
Esta vulnerabilidade consiste em atribuir a uma variável um dado cujo comprimento é maior do que a estrutura pode receber.
Em este caso, serão considerados apenas os campos de texto que exigem interação do usuário, como nome e senha, por exemplo.
O estereótipo deve ser inserido na atividade do diagrama onde ocorre a entrada dos dados do usuário.
Estereótipo: &quot;BufferOverflow «onde é o nome do campo para inserção dos dados e é o tamanho máximo de caracteres permitido para este campo.·
Caso 3 -- Criptografia (Conexões):
Esta vulnerabilidade consiste em enviar dados sensíveis através da rede, sem criptografar a conexão.
Em este caso, a fim de auxiliar no processo de geração de casos de teste, devem ser indicados os campos que necessitam de criptografia.
O estereótipo deve ser inserido na atividade do diagrama responsável por o envio dos dados por a rede.
Estereótipo: &quot;Encrypt «onde é o nome do campo a ser criptografado.·
Caso 4 -- Controle de Acesso (By Passing):
Esta vulnerabilidade consiste em solicitar os dados de login do usuário apenas na página inicial, não sendo requisitado caso o usuário acesse um link interno do sistema diretamente.
Para auxiliar na geração de casos de teste, é preciso inserir três tipos de tags nos diagramas, todas integrantes do estereótipo &quot;ByPassing».
Em primeiro lugar deve ser feita a identificação dos usuários do sistema.
Para tanto, é preciso inserir, nos atores do diagrama de caso de uso, o estereótipo &quot;ByPassing «com a tag O próximo passo é mapear os links das páginas protegidas por o sistema de login.
Este procedimento é feito através da inserção do mesmo estereótipo, mas usando a tag Por último, é preciso identificar a partir de que ponto os demais usuários não podem acessar o sistema.
Para tanto, pode- se optar por o uso da tag\&gt;, para indicar que usuários podem acessar o sistema, ou da tag para indicar que usuários não podem acessar o sistema.
Estereótipo: &quot;ByPassing «sem valores, pois é apenas para marcar o ator.
Estereótipo: &quot;ByPassing «onde é o endereço a ser acessado.
Estereótipo: &quot;ByPassing «onde é o ator que tem acesso ao sistema.
Estereótipo: &quot;ByPassing «onde é o ator que não tem acesso ao sistema.·
Caso 5 -- Controle de Acesso (Expiração de sessão):
Esta vulnerabilidade acontece quando a sessão do usuário não expira após determinado tempo sem interação deste.
Pode ocorrer também caso o tempo de expiração seja relativamente grande que possa comprometer a segurança do usuário, mas este tempo deve ser previsto por o engenheiro do software.
O estereótipo deve ser inserido após a atividade do diagrama que representa o login bem sucedido do usuário.
Estereótipo: &quot;Expiration «onde indica o intervalo de tempo que a sessão deve expirar e a unidade de medida, que pode ser` s' (segundo),` m' (minuto),` h' (hora) ou` d' (dia).·
Caso 6 -- SQL Injection:
Esta vulnerabilidade acontece quando o sistema não faz validação dos dados de entrada antes de atribuir- los a uma query SQL.
Desta forma, o usuário malicioso insere no campo de dados uma outra query SQL, ao invés de o nome de usuário ou senha, por exemplo.
A execução deste caso de teste exige mais conhecimento do testador, que precisa avaliar os resultados obtidos do sistema para elaborar novos casos de teste.
Para auxiliar- lo, serão fornecidos junto com o caso algumas sugestões de querys de busca.
A execução deste teste tem como objetivo detectar duas vulnerabilidades:
A susceptibilidade do sistema a execução de códigos SQL (SQL Injection) e a exposição de informações sensíveis, que podem ser senhas de outros usuários, informações pessoais ou mesmo nomes das estruturas internas do sistema.
O estereótipo deve ser inserido nas atividades do diagrama que possuem captura de dados provenientes do usuário.
Estereótipo: &quot;SqlInjection «onde é o campo para inserção de dados.
Considerando a quantidade de vulnerabilidades existentes, apenas algumas foram mapeadas.
Para simplificar a modelagem, foram utilizados apenas diagramas de atividades para inserir as informações (exceto no caso de o estereótipo &quot;ByPassing», que exige a marcação também no diagrama de casos de uso).
Por último, é importante ressaltar que os estereótipos apresentados neste trabalho foram publicados na forma de um artigo estendido.
Após a modelagem, deve- se gerar o arquivo XMI.
Este será utilizado como entrada do gerador de casos de teste, que irá interpretar- lo e extrair as informações necessárias aos testes.
A descrição do funcionamento do gerador de casos de teste pode ser vista na seção seguinte.
Conforme mencionado, a segunda parte deste trabalho consiste na geração de casos de teste de segurança a partir de os estereótipos adicionados ao modelo.
O objetivo destes casos é indicar ao testador os passos que este deve executar para alcançar a parte da aplicação que poderia tornar- se vulnerável caso não fosse implementada cuidadosamente.
Sendo assim, é preciso adicionar os estereótipos propostos a algum diagrama da UML que descreva o modelo comportamental do software, tais como diagramas de atividades, estados ou de seqüência.
De posse desta representação, resta apenas interpretar o modelo e gerar os casos de teste.
Uma das vantagens em se utilizar modelos comportamentais que descrevam uma seqüência de passos, é a facilidade em converter- los em máquinas de estados finitos.
Também existem inúmeras técnicas para percorrer estas estruturas e gerar, automaticamente, casos de teste.
Uma destas utiliza o algoritmo Unique Input/ Output (UIO), que permite identificar o estado particular em que a máquina de estados finitos se encontra baseando- se apenas nas entradas e saídas deste.
Com esta técnica, é possível definir uma seqüência de passos que conduza a máquina desde o estado inicial s0 até determinado estado si, aplicar o símbolo de entrada para aquele estado e, por fim, calcular o estado de saída que deveria ser atingido.
Após o cálculo de todas as seqüências de entradas e saídas, é preciso gerar os casos de teste e aplicar estes ao software, verificando se a implementação é fiel ou não ao comportamento descrito por a máquina.
Para implementar o gerador da casos de teste, o primeiro passo foi desenvolver um parser que avaliasse o arquivo XMI gerado a partir de o modelo UML com os estereótipos, extraísse as informações necessárias e elaborasse uma máquina de estados finitos com entradas e saídas.
Considerando que o método UIO utiliza as transições da máquina para determinar o estado que deve ser alcançado, o conteúdo dos estereótipos deve ser inserido nestas, como entrada dos estados, dando origem assim a uma máquina de Mealy.
A Figura 22 apresenta um exemplo de diagrama de estados com estereótipo, enquanto que a Figura 23 demonstra a máquina de estados finitos equivalente ao diagrama.
É importante ressaltar que, para o correto funcionamento da máquina, é preciso incluir um estado inicial e conectar todos os outros nodos a ele, permitindo assim que ela seja reiniciada.
A partir de esta máquina, serão geradas as seqüências UIO para cada estereótipo, que indicam o caminho para acessar os estados.
Por fim, com base nestas seqüências é que são gerados os casos de teste, que no escopo deste trabalho estão descritos em linguagem natural, mas que podem ser adaptados e utilizados como entrada de alguma ferramenta de execução de scripts de teste.
É importante salientar que, para cada estereótipo adicionado ao modelo, é gerado um caso de teste, com exceção dos casos de &quot;BufferOverflow «e &quot;Flooding», que geram três casos, um para o limite inferior, um para o limite exato e um para o limite superior.
O formato de geração dos casos de teste, para cada estereótipo, pode ser visto na Tabela 5.
Conforme mencionado, o objetivo deste trabalho é especificar aspectos de segurança em modelos UML e permitir a geração de casos de teste a partir deste.
Para tanto, ele foi dividido em duas partes:
A primeira consiste em definir um conjunto de estereótipos UML capazes de indicar vulnerabilidades de segurança que podem afetar o software, enquanto que a segunda visa extrair informações do modelo contendo estes estereótipos e gerar casos de teste automaticamente, permitindo que um testador verifique a existência das vulnerabilidades assinaladas.
1. Executar as atividades até a atividade que contém o estereótipo.
Para o limite superior.
Injeção de Falhas, considerado a segunda vulnerabilidade mais crítica da lista de 2007.
Com os estereótipos apresentados na Seção 6.2, foi possível representar os casos de número 1, 2, 3, 5, 6, 7 e 9, da lista de 2004, e os de número 2, 6, 7, 9 e 10 da lista de 2007.
Em o total, dos 16 casos apresentados por ambas as listas (4 são casos repetidos), 9 puderam ser modelados com os estereótipos, o que significa que mais de 50% das vulnerabilidades consideradas críticas foram representadas.
Concluída esta etapa, é preciso analisar os demais casos, identificar as características essenciais aos testes e, por fim, expandir o conjunto de estereótipos, sendo possível representar também casos como os de Cross Site Scripting (XSS), Execução Maliciosa de Arquivos e Armazenamento Inseguro, por exemplo.
Em relação a a segunda etapa do trabalho, existem diversos outros métodos para geração de seqüências de teste a partir de máquinas de estados finitos, tais como o Método Transition Tour (Método TT), Método Distinguishing Sequence (Método Ds) e o Método Characterizing Sets (Método W).
Entretanto, comparado às outras técnicas, o método UIO vem se tornando popular por dois motivos principais:
Ele auxilia na detecção de falhas na transição de estados, mesmo de máquinas parcialmente especificadas, e produz as seqüências de teste mais curtas que os outros métodos.
A fim de verificar a capacidade dos estereótipos em representar aspectos de segurança, e a clareza com que os casos de teste especificam os passos a serem seguidos, foram selecionados quatro estudos de caso.
A descrição dos sistemas, bem como a modelagem de cada um, os casos gerados para cada requisito e os resultados obtidos com a execução manual destes podem ser vistos no capítulo a seguir.
Para verificar a eficiência de representação dos estereótipos propostos, bem como avaliar se os passos descritos por o gerador de casos de teste permitem identificar vulnerabilidades num sistema, é preciso aplicar a estratégia proposta em alguns estudos de caso.
Considerando que a base de dados utilizada como guia é voltada a aplicações Web, os estudos de caso escolhidos devem ser softwares deste tipo, como por exemplo sistemas de e-commerce.
Além disso, a aplicação avaliada deve ser open-source, para que se possa identificar as causas das vulnerabilidades, e conter a modelagem UML do sistema, onde serão adicionados os estereótipos.
Quatro aplicações foram selecionadas como estudo de caso.
As duas primeiras, OSCommerce e TPC-W, reproduzem o comportamento de um site de e-commerce.
A terceira, conhecida como Moodle, é um software de apoio à aprendizagem que permite a criação de cursos on-line e disponibiliza uma série de recursos a serem utilizados por professores e alunos.
A última, denominada CesarFTP, é um servidor de FTP gratuito e fácil de utilizar e de configurar.
Para avaliar- los, inicialmente foi realizada uma análise dos requisitos dos softwares e identificados os que poderiam ser representados por os estereótipos propostos.
Após, estes estereótipos foram inseridos nos respectivos modelos UML, permitindo que a partir destes fossem gerados os casos de teste correspondentes.
Por fim, executou- se os testes sugeridos para verificar se nenhuma das vulnerabilidades assinaladas no modelo existiam de fato, ou seja, se os requisitos de segurança foram respeitados.
É importante ressaltar ainda que, para fins de validação, foram utilizados apenas diagramas de atividades (exceto durante a representação do estereótipo &quot;ByPassing «que exige um diagrama de casos de uso para identificação dos atores do sistema).
As seções seguintes apresentam uma breve descrição de cada uma destas ferramentas, bem como demonstram a inserção dos estereótipos de segurança na modelagem dos sistemas, os casos de teste gerados a partir destes e, ao final, os resultados obtidos quando executou- se manualmente os casos.
O OSCommerce, ou Open- Source Commerce, é um software que agrega funções tanto de comércio eletrônico, como de gerenciamento de lojas online.
Ele provê um conjunto básico de funcionalidades que vão ao encontro de as necessidades da maioria dos comerciantes online, sendo possível configurar, executar e atualizar lojas online com o mínimo de esforço, sem cus- tos, taxas ou limitações.
Entre os recursos disponibilizados por o software estão o cadastro de clientes, o carrinho de compras, opções de pagamento (boleto, cartão, depósito bancário, contra entrega), opções de entrega (encomenda normal, registrada e Sedex) e página administrativa.
Considerando o vasto conjunto de funcionalidades providas por o software, bem como a importância de se avaliar aplicações deste tipo (e-commerce), o OSCommerce foi escolhido como um dos estudos de caso deste trabalho.
Para tanto, inicialmente foi realizada uma análise dos requisitos do software e identificados os que poderiam ser representados por os estereótipos.
A seguir, foram gerados e executados os casos de teste correspondentes, a fim de identificar o atendimento ou não dos requisitos previamente estabelecidos.
Considerando que a configuração de alguns parâmetros da aplicação é feita por o administrador do sistema, foram definidas as seguintes características:·
Requisito 1: O nome dos fabricantes, adicionado por o administrador, deve possuir no máximo 15 caracteres.·
Requisito 2: O envio de senhas, durante o processo de autenticação do usuário, deve ser criptografado.·
Requisito 3: O sistema deve fazer logoff do usuário quando não houver interação deste com o sistema num período de 180 segundos.·
Requisito 4: As informações inseridas no campo de busca por produtos devem ser analisadas previamente a fim de evitar ataques do tipo SQL Injection.·
Requisito 5: O acesso ao carrinho de compras deve ser feito apenas por clientes cadastrados.
Após a modelagem dos requisitos, gerou- se o arquivo XMI correspondente, o qual foi utilizado como entrada para o algoritmo de geração de casos de teste.
Como resultado obteve- se os passos necessários para verificar a parte do sistema que pode conter uma vulnerabilidade, e então avaliar- lo.
Para cada estereótipo inserido foi gerado um caso de teste equivalente (exceto nos casos de BufferOverflow e Flooding que realizam testes com os valores limites).
Tabela 7 ­ Casos de Teste Gerados para o OSCommerce &quot;Estereótipo Encrypt Expiration BufferOverflow «&quot;SqlInjection ByPassing «Caso de Teste ser visualizado.
O sistema aceitou o cadastro de fabricantes quando o comprimento do nome foi maior que 15 caracteres.
Entretanto, nenhuma instabilidade foi detectada no comportamento do software.
Apesar de o uso do protocolo SSL estar habilitado, o envio das informações de login do usuário foi feita de forma aberta por a rede, sendo possível capturar a senha de administrador usando um analisador de tráfego.
Mesmo configurando a aplicação para expirar a sessão do usuário após 3 minutos de inatividade, esta não comportou- se como esperado.
Entretanto, vale ressaltar que após aproximadamente 15 minutos de inatividade o software solicitou novamente os dados de login do usuário.
A aplicação não foi vulnerável a ataques de SQL, ignorando os comandos enviados no campo de busca por produtos.
O sistema mostrou- se vulnerável apenas quando o usuário real está conectado ao sistema em outra máquina.
Em este caso foi possível acessar o link interno do carrinho de compras a partir de outra máquina.
Entretanto, quando o usuário real desconecta- se do sistema, o acesso direto ao link é negado, sendo solicitados os dados de login novamente.
Sendo assim, a avaliação do software OSCommerce expôs uma série de vulnerabilidades.
De os cinco casos de teste aplicados, quatro revelaram defeitos na aplicação, representando um risco ao sistema e aos seus usuários.
Considerando que a aplicação é um site de e-commerce, um dos casos mais importantes é o de criptografia, que mesmo com o uso do protocolo SSL habilitado, enviou as informações de usuário e senha em texto puro por a rede.
Em um primeiro momento, existem duas possibilidades para a existência desta vulnerabilidade:
Ou o protocolo SSL ainda não está implementado na versão testada (versão 2.2 M2), ou existe um problema na utilização deste com o software.
Outra vulnerabilidade crítica do sistema é a deficiência na expiração da sessão do usuário, que pode expor informações confidenciais do usuário, como número de cartão de crédito, ou permitir que um usuário malicioso assuma a identidade de um verídico.
Diversos motivos podem estar provocando este problema, desde o uso de um valor padrão de tempo, desconsiderando a configuração do administrador, até a incapacidade em alterar o tempo de inatividade no servidor PHP, que pode controlar as sessões.
Por último, vale ressaltar a vulnerabilidade de By Passing, que permite que um link interno seja acessado a partir de outra máquina se o usuário em questão estiver conectado ao servidor.
Provavelmente a permissão de acesso do usuário é armazenada diretamente no servidor, e não na máquina do usuário.
Sendo assim, enquanto o usuário estiver autorizado no servidor, seu identificador (Id) é considerado válido, podendo ser acessado independentemente da máquina onde esteja.
O TPC-W é um software desenvolvido para realizar testes de desempenho em infraestruturas.
Ele pode ser utilizado, por exemplo, para verificar o número máximo de usuários que um ambiente pode suportar, ou se este dispõe da quantidade de recursos necessária para prover um serviço.
Para desempenhar esta função, ele simula o comportamento de um site de ecommerce, disponibilizando operações como buscar produtos, adicionar ao carrinho de compras e conectar- se ao sistema.
De acordo com Sopitkamol e Menascè, é muito difícil, se não impossível, conduzir experimentos em sites de e-commerce reais, o que faz do uso do TPC-W uma boa opção.
Além disso, existe uma grande quantidade de informações sobre este software, o que inclui um documento de especificação completo e alguns diagramas UML construídos por os desenvolvedores.
Apesar de ser considerado um padrão para fazer avaliação de desempenho, sua capacidade em simular o comportamento de uma aplicação Web comum permite que outros tipos de teste sejam executados em ele, como segurança.
Por este motivo, o TPC-W não será utilizado neste trabalho como um &quot;benchmark», mas como uma aplicação Web comercial onde serão avaliados alguns aspectos de segurança.
De a mesma forma que o OSCommerce, o primeiro passo foi fazer um levantamento dos requisitos de segurança do TPC-W e modelar- los através dos estereótipos propostos na Seção TPC-W provê uma série de ações ao usuário, reproduzindo as principais operações realizadas durante a visita a um site de e-commerce.
Em o contexto, é simulado um site para compra de livros.
Analisando- se seu documento de especificação, foram extraídos quatro requisitos de segurança, que se não implementados podem comprometer a segurança do sistema.
São eles:·
Requisito 1: O campo de primeiro nome do cliente, preenchido durante o cadastro deste, deve ter no máximo 15 caracteres.·
Requisito 2: O envio da página que contém as informações da compra deve criptografar o número do cartão de crédito do cliente.·
Requisito 3: A alteração de preço dos livros deve ser feita por um usuário administrador conectado ao sistema.·
Requisito 4: As bases de dados devem ser protegidas de usuários não autorizados, como no caso de atualização de preços.
A Tabela 9 apresenta a modelagem destes requisitos utilizando os estereótipos, enquanto que as Figuras 27, 28 e 29 demonstram a inserção destes no modelo UML.
Figura 29 ­ Diagrama de Casos de Uso do TPC-W Assim como no OSCommerce, após a modelagem dos requisitos foram gerados os casos de teste.
Para cada estereótipo inserido foi gerado um caso de teste, descritos na Tabela 10.
4. Inserir no campo` FNAME' um valor com comprimento menor que 15 caracteres.
Os resultados obtidos com a execução manual dos casos de teste gerados podem ser vistos na Tabela 11.
O TPC-W aceitou o cadastro do usuário com o primeiro nome sendo de comprimento maior que 15 caracteres, mas nenhum comportamento anormal foi detectado no software.
O software não criptografou o número do cartão de crédito do usuário antes de enviar- lo por a rede, sendo possível roubar- lo usando um analisador de tráfego.
O software não foi vulnerável aos ataques de SQL.
O sistema não solicitou o login do usuário antes de atualizar o preço dos livros, aceitando o novo valor.
Analizando- se a Tabela 11, é possível concluir que o TPC-W não é uma aplicação segura.
Se fosse um sistema de e-commerce real, informações pessoais dos usuários seriam enviadas sem criptografia e usuários maliciosos poderiam modificar os preços dos produtos.
Uma observação a ser feita é que o software utiliza consultas SQL pré-compiladas, evitando assim que a estrutura da consulta original seja modificada e impedindo que ataques de SQL Injection ocorram.
O Moodle, ou Modular Object--Oriented Dynamic Learning Environment, é um sistema de gerenciamento de cursos projetado para auxiliar os educadores a criar comunidades efetivas de aprendizado online.
Ele constitui- se num sistema de administração de atividades educacionais, destinado à criação de comunidades em ambientes virtuais voltados à aprendizagem colaborativa.
Para tanto, utiliza- se de diversos recursos, tais como áreas para download, chats, fóruns de discussão, calendário e questionários.
A plataforma Moodle vem sendo aplicada em diversas instituições de ensino, tanto nas que utilizam o sistema de educação a distância, como as de cursos presenciais.
Além disso, já vem sendo utilizada por outros setores não ligados à educação, como empresas privadas e ONGs.
Por ser uma aplicação Web e conter informações pessoais de seus usuários, é essencial que implemente algumas diretrizes básicas de segurança.
Sendo assim, considerando a sua complexidade e ampla utilização, o Moodle também foi utilizado como um dos estudo de caso deste trabalho.
De a mesma forma como nos outros casos, o primeiro passo para avaliar a segurança do software foi fazer um levantamento dos requisitos de segurança deste, para então representar- los através dos estereótipos de segurança propostos.
Como no OSCommerce, as restrições do software são configuradas por o administrador.
Foram especificados cinco requisitos de segurança:·
Requisito 1: A senha do usuário deve ter no máximo 32 caracteres de comprimento.·
Requisito 2: Durante o login, o envio da senha do usuário deve ser criptografado.·
Requisito 3: Iniciada uma sessão, o usuário pode ficar no máximo 5 minutos sem interagir com o sistema.
Após este tempo, a sessão deve expirar.·
Requisito 4: Para selecionar um curso, o usuário deve ser cadastrado no sistema.·
Requisito 5: As bases de dados devem ser protegidas de comandos SQL.
A modelagem dos requisitos descritos acima pode ser feita conforme a Tabela 12.
A Figura 30 demonstra a inserção dos estereótipos de &quot;BufferOverflow», &quot;Expiration», &quot;Encrypt», &quot;SqlInjection «e &quot;ByPassing», enquanto que a Figura 31 apresenta o diagrama de casos de uso identificando os atores do sistema.
Assim como nos estudos de caso apresentados anteriormente, após a modelagem dos requisitos foram gerados os casos de teste referentes a cada um dos estereótipos inseridos nos diagramas do sistema.
Desta forma, os casos gerados para avaliar a segurança da aplicação Moodle podem ser vistos na Tabela 13.
2. Inserir no campo` password' um valor com comprimento menor que 32 caracteres.
Após a execução manual dos testes descritos anteriormente, foram observados os seguintes resultados, apresentados na Tabela 14: O Moodle aceita uma senha com comprimento maior que 32 caracteres apenas se a checkbox &quot;mostrar «estiver marcada.
Caso contrário, o software não permite configurar senhas cujo comprimento é maior que 32 símbolos.
Entretanto, apesar de a vulnerabilidade, nenhum comportamento anormal foi detectado.
O software criptografou corretamente as informações do usuário, não sendo vulnerável a roubos de senha através de analisadores de pacotes.
A aplicação não expirou a sessão do usuário após 5 minutos de inatividade, como configurado por o administrador.
O sistema não foi vulnerável aos ataques de By Passing, solicitando as informações de login do usuário quando os links internos foram acessados diretamente.
O software não foi vulnerável a ataques de SQL Injection, ignorando os comandos inseridos no campo de busca.
Analisando- se os resultados obtidos, é possível concluir que o software contém alguns problemas de interface, como no caso de buffer overflow, onde ao marcar a checkbox &quot;mostrar «torna- se possível adicionar senhas de comprimento maior que o permitido.
Além de esta vulnerabilidade, a aplicação não expirou a sessão do usuário corretamente, comprometendo a identidade deste.
Se considerarmos o uso do software em computadores compartilhados, como por exemplo em laboratórios de uma Universidade, um aluno mal intencionado consegue facilmente fazer uso da conta de outro aluno, desde que este não tenha encerrado a sessão através do link &quot;Sair».
A expiração de sessão ainda é um dos métodos mais eficentes de se adicionar segurança à sistemas que utilizem esta estrutura para identificar seus usuários, pois apesar de aumentar o tráfego no servidor, é uma forma de corrigir alguns erros cometidos por o usuário, como por exemplo esquecer de desconectar- se do sistema antes de liberar o computador para outro usuário.
O CesarFTP é um servidor FTP leve, gratuito, fácil de utilizar e simples de configurar.
Ele suporta um sistema virtual de arquivos completo, o que preserva a estrutura do disco no servidor.
Outras configurações deste software permitem negar o acesso a determinados usuários, limitar a velocidade de downloads, limitar o número de conexões ao site e expirar sessões.
Considerando estas últimas características, o CesarFTP foi considerado um bom exemplo para verificar a aplicabilidade do estereótipo &quot;Flooding», não considerado nas outras aplicações, já que estas não permitiam configurar o número máximo de usuários que poderiam estar conectados ao sistema simultaneamente.
Sendo assim, após configurar o software, foram definidos três requisitos de segurança:·
Requisito 1: O número máximo de usuários conectados ao sistema simultaneamente é 5.·
Requisito 2: A sessão do usuário, quando inativa, deve expirar em 20 segundos.·
Requisito 3: O acesso a um arquivo só pode ser feito por usuários autorizados.
Caso contrário o servidor deve negar o acesso do visitante.
As Figuras 32 e 33 apresentam a modelagem do sistema e a inserção dos estereótipos referentes aos casos descritos na Tabela 15.
A Figura 32 demonstra a inserção dos estereótipos de &quot;ByPassing», &quot;Flooding «e &quot;Expiration», enquanto que a Figura 33 apresenta o diagrama de casos de uso identificando os atores do sistema.
Após a modelagem dos requisitos, foi gerado o arquivo XMI, que deu origem aos casos de teste relacionados a cada estereótipo.
Os casos de teste gerados para avaliar os aspectos de segurança do servidor de FTP CesarFTP podem ser vistos a seguir, na Tabela 16.
2. Repetir o procedimento de login até que 4 usuários estejam logados.
A Tabela 17 apresenta os resultados obtidos após a execução manual dos casos de teste gerados:
O CesarFTP negou qualquer acesso de usuário não conectado ao sistema, não sendo vulnerável a ataques de By Passing.
O software impediu, corretamente, a conexão de um sexto usuário, considerando que o limite imposto no software eram de 5 usuários.
Após 20 segundos de inatividade, a aplicação expirou a sessão do usuário, funcionamento de acordo com a restrição imposta durante a configuração do servidor.
Analisando- se os resultados obtidos, é possível concluir que o servidor CesarFTP não apresentou nenhuma vulnerabilidade de segurança para os casos avaliados.
Em princípio, o software comporta- se de forma adequada, negando o acesso de usuários além de o número máximo suportado, expirando as sessões inativas e protegendo os arquivos hospedados de usuários nãoautorizados.
É importante ressaltar que os valores utilizados durante os testes foram baixos devido a a praticidade na execução dos testes, que ainda estão sendo feitos manualmente.
Para o caso de Flooding, por exemplo, foi preciso instanciar seis usuários manualmente e conectar- los ao sistema, controlando o comportamento deste durante o processo de conexão do último usuário, que deveria ser impedido.
Entretanto, considerando que um dos próximos passos para dar continuidade a este trabalho é promover a automatização dos testes, será possível avaliar aplicações como o CesarFTP com um número maior de usuários, permitindo inclusive determinar o máximo de usuários que o sistema comporta.
Conforme visto durante o Capítulo 7, a execução dos testes revelou uma série de vulnerabilidades.
De as aplicações avaliadas, apenas o CesarFTP não foi vulnerável a nenhum dos casos executados, seguindo corretamente as configurações especificadas no servidor.
Os softwares OSCommerce e Moodle, cujas restrições de segurança são especificadas por o administrador do software, apresentaram algumas vulnerabilidades críticas.
O OSCommerce, por exemplo, mesmo estando com o protocolo SSL habilitado, faz o envio das informações do usuário de forma aberta por a rede, permitindo que um usuário malicioso roube estas informações utilizando um analisador de tráfego.
Já o Moodle obteve melhores resultados diante de os testes, pois não foi vulnerável aos casos considerados mais críticos.
Entretanto, apresentou problemas durante o teste de expiração da sessão do usuário, que deveria ser encerrada após 5 minutos de inatividade.
Por fim, o TPC-W, apesar de ser uma aplicação de e-commerce de teste, também apresentou vulnerabilidades, como a que permite alterar o valor de um produto sem estar conectado ao sistema como administrador.
Se este software fosse uma aplicação real, um usuário qualquer poderia modificar o valor de um produto na hora da compra, escolhendo o valor que deseja pagar por ele.
Sendo assim, a solução para os problemas encontrados nos softwares é aparentemente simples, pois consiste em corrigir erros de implementação no gerenciamento de sessões, no uso de protocolos de segurança (Secure Socket Layer, SSL) e no controle de acesso dos usuários.
Esta é outra vantagem no uso dos estereótipos de segurança no modelo, que além de permitir a geração automatizada dos casos de teste, ainda servem como guia para os desenvolvedores, destacando as partes do modelo que podem conter vulnerabilidades e que devem ser implementados cautelosamente.
Durante o ciclo de desenvolvimento de um software, uma das etapas é avaliar se este atende aos requisitos especificados no início do projeto.
Esta análise é realizada durante a fase de teste de software, responsável por verificar tanto aspectos funcionais, como não-funcionais.
Em esta última categoria encontra- se o teste de segurança, que vêm tornando- se importante a medida que o número de serviços prestados via Internet cresce.
Entretanto, avaliar a segurança de um software apenas quando ele já está concluído não é eficiente.
É preciso mapear estes requisitos antes de implementar- los, orientando todo o processo de desenvolvimento.
A o final deste, aplica- se o teste como uma rotina complementar, com o objetivo de verificar se os requisitos de segurança foram considerados ou não.
Apesar de a simplicidade desta abordagem, colocar- la em prática é uma tarefa difícil.
Poucas referências utilizam modelos UML para descrever aspectos de segurança, o que dificultou a condução desta pesquisa.
Isto se deve, principalmente, ao fato das vulnerabilidades de segurança possuírem características próprias, dificultando a elaboração de um modelo genérico que represente todas.
Por este motivo, a maioria dos trabalhos relacionados está focada num determinado aspecto, normalmente sobre políticas de controle de acesso (RBAC).
Sendo assim, o objetivo deste trabalho é disponibilizar uma forma de descrever aspectos de segurança ainda na fase de projetos, e adicionar- los ao modelo UML.
A representação deste aspecto desde a fase de modelagem possui duas vantagens principais:
Orientar o trabalho dos desenvolvedores, destacando as partes que podem se tornar vulneráveis se mal implementadas;
O desenvolvimento deste trabalho foi dividido em duas etapas, uma para definição de alguns estereótipos de segurança, e outra para análise destas informações e geração dos casos de teste.
Com o auxílio da taxonomia de Weber e da lista de vulnerabilidades provida por o projeto OWASP, estipulou- se um conjunto de estereótipos capazes de representar os casos mais comuns de segurança.
Apesar de alguns trabalhos proporem formas de especificar aspectos de segurança, nenhum consegue representar as vulnerabilidades aqui apresentadas.
Com estes estereótipos é possível representar casos de estouro de buffer, necessidade de criptografia, controle no número de conexões aberta, acesso a links internos sem permissão, gerenciamento de sessões e prevenção a ataques de SQL Injection.
Após a definição destes, construiu- se um algoritmo para analisar o arquivo XMI que descreve a estrutura do modelo UML do sistema, e extrair as informações relevantes deste.
Este é outro diferencial deste trabalho, já que nenhum dos trabalhos relacionados modela características de segurança com o objetivo de permitir a automatização do processo de teste.
Durante a geração dos casos de teste, aplicou- se o método conhecido como UIO, que utiliza uma máquina de estados finitos com entradas e saídas para identificar os possíveis caminhos de execução.
Por fim, a interpretação das seqüências geradas por o método deu origem aos casos de teste em linguagem natural, descrevendo os passos que o testador deve executar para verificar a existência da vulnerabilidade ou não.
Entretanto, é importante ressaltar que nem sempre a execução de um caso básico é suficiente para atacar um sistema ou revelar uma vulnerabilidade.
As vezes é preciso elaborar, ou mesmo unir ataques, para realizar o ataque com sucesso.
Sendo assim, um dos trabalhos futuros relacionados a esta pesquisa refere- se à geração de casos de teste mais complexos, juntamente com a representação dos demais casos apresentados por a lista de vulnerabilidades do projeto OWASP, como XSS, Execução Maliciosa de Arquivos e Armazenamento Inseguro de Informações.
Outro aspecto que se deseja incluir no trabalho é a geração de scripts de teste no formato de alguma ferramenta, ao invés de ser em linguagem natural.
Desta forma é possível automatizar todo o processo de teste, desde a fase de geração a partir de o modelo, até a parte de execução do teste, utilizando ferramentas como o JUnit, o JMeter e o WebLOAD.
Por último, é preciso mencionar que este trabalho não foi conduzido individualmente.
Ele está integrado a uma linha de produto de teste, descrita por Orozco et al.,
cujo objetivo é gerar ferramentas capazes de aplicar testes específicos num software, de acordo com a necessidade do usuário.
Em esta ferramenta, o usuário pode escolher se quer executar apenas testes funcionais em seu software, ou se pretende associar- lo a algum outro tipo de teste, como segurança (apresentado neste trabalho) ou desempenho (apresentado por Rodrigues et al.).
Após concluir a etapa de configuração, a linha de produto de teste produzirá como resultado uma segunda ferramenta, contendo apenas as funcionalidades escolhidas por o usuário e os módulos necessários para executar os tipos de teste escolhidos.
Em este contexto, a ferramenta de teste de segurança descrita neste trabalho é um dos módulos da linha de produto de teste, colaborando com as atividades de avaliação do modelo UML, extração das informações relevantes e geração de casos de teste em linguagem natural.
Posteriormente, com a construção de um processo de geração de scripts, será possível adicionar mais um produto à linha, permitindo que o usuário escolha se quer gerar os casos em linguagem natural ou como entrada para alguma ferramenta de automação de teste.
