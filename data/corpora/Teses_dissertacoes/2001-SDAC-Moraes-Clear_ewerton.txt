Esta dissertação apresenta o projeto de um módulo de hardware reutilizável, soft core, para a implementação do padrão PCI, 32 bits -- 33 MHz.
A principal motivação para o desenvolvimento deste soft core é prover aos projetistas de hardware um módulo que aumente a largura de banda na interação hardware/ software.
O trabalho apresenta as características gerais do padrão PCI, seguindo- se com a definição, na forma de diagrama de blocos, da arquitetura do core.
A implementação deste core é feita utilizando- se a linguagem de descrição de hardware VHDL, validando- o através de simulação funcional.
A simulação testa os ciclos básicos de leitura e escrita, tanto em modo simples quanto em rajada.
Resultados preliminares de consumo de área e timing são apresentados.
Apresenta- se também um ambiente de prototipação conectado ao barramento PCI, onde é mostrado o fluxo de projeto em aplicações que possuem componentes software e hardware.
Palavras-chave: PCI, FPGAs, cores, prototipação, arquiteturas reconfiguráveis, interação hardware/ software.
Os projetistas de sistemas digitais enfrentam sempre o desafio de encontrar o balanço correto entre velocidade e generalidade de processamento do seu hardware.
É possível desenvolver um chip genérico que realiza muitas funções diferentes, porém com sacrifício de desempenho (por exemplo:
Microprocessadores), ou chips dedicados a aplicações específicas, estes com uma velocidade muitas vezes superior aos chips genéricos.
Circuitos Integrados de Aplicação Específica (ASICs), têm como características a ocupação mínima de área de silício, alto custo em relação a os chips genéricos, rapidez e um menor consumo de potência comparados com processadores programáveis.
Um fator importante na escolha entre versatilidade e velocidade é o custo.
Um ASIC executa a função para qual foi concebido de uma forma otimizada, porém uma vez desenvolvido o chip, alterações na funcionalidade do circuito integrado não são possíveis.
Logo, todo esforço despendido no seu projeto e implementação deve ser amortizado num número elevado de unidades.
Uma solução intermediária, que representa um balanço entre custo versus versatilidade, são os Field- Programable Gate Arrays -- FPGAs.
Estes circuitos integrados configuráveis podem ser personalizados como diferentes ASICs.
Esta tecnologia permite o projeto, teste e correção de circuitos integrados dedicados com um baixo custo de prototipação.
Um FPGA é programado com o uso de chaves eletrônicas programáveis.
As propriedades destas chaves, tais como tamanho, resistência de contato e capacitâncias definem os compromissos de desempenho da arquitetura interna do FPGA.
Existem também diferentes tecnologias de programação de chaves eletrônicas que são:
SRAM, anti-fusível, porta flutuante e flash RAM.
No caso de os FPGAs Xilinx, Altera, Plessey, Algotronix, Concurrent Logic e Toshiba, a tecnologia de programação utiliza Static RAM-SRAM.
Sendo as SRAM voláteis, o FPGA deve receber seu arquivo de configuração toda vez que o circuito for ligado.
Isto requer memória externa e permanente para armazenar os bits de configuração, podendo ser empregadas Programmable Read-Only Memory -- PROM, Erasable PROM -- EPROM, Electrically EPROM -- EEPROM ou discos magnéticos.
A maior desvantagem das SRAM é a área ocupada.
São necessários pelo menos 5 transistores para implementar um célula SRAM e pelo menos mais um transistor para servir de chave programável.
Apesar de a desvantagem de maior área ocupada e necessidade de memória externa para configuração, esta é a tecnologia que domina hoje o mercado de FPGAs, pois permite prototipação de sistemas digitais e reconfiguração de arquiteturas, tanto estática quanto dinamicamente.
Como exemplo de arquitetura de um FPGA, podemos ilustrar os dispositivos Xilinx da família 4000, conforme a Figura 1.
A estrutura dos FPGAs é similar aos Mask--Programmable Gate Array -- MPGAs, consistindo de um arranjo de blocos lógicos que podem ser interconectados através de uma configuração para executar diferentes tarefas.
A maior diferença entre os FPGAs e MPGAs é que o MPGA tem suas interconexões produzidas através da especificação de uma camada de metalização que necessita ser feita numa foundry, enquanto que um FPGA é programado via chaves eletricamente programáveis.
Os FPGAs podem alcançar níveis de integração muito mais elevados que os PLDs, embora possuam o roteamento de sua arquitetura e a implementação lógica mais complexos.
A arquitetura de um FPGA está dividida em 3 partes:
Blocos Lógicos Configuráveis:
Um bloco lógico de um FPGA pode ser tão simples como um transistor ou tão complexo quanto um microprocessador.
Ele é capaz de implementar várias funções lógicas combinacionais (tipicamente através de look-up tables) ou seqüenciais (através de flip-flops).
Interconexões Programáveis:
SRAM ­ em a qual a chave é um transistor de passagem controlado por um bit de RAM estática, Antifusível ­ quando eletricamente programado forma um caminho com baixa resistência e EPROM ­ quando a chave é um transistor com porta flutuante, que pode ser desligado ao se injetar uma carga em sua porta.
Blocos de Entrada/ Saída Configuráveis:
Os FPGAs possuem componentes de entrada/ saída chamados I/ O Blocks, formados por estruturas bidirecionais que incluem buffer, flip-flop de entrada, buffer tri-state e flip-flop de saída.
Ferramentas de CAD já disponíveis permitem implementar, testar, simular e corrigir projetos eletrônicos computacionais com grande facilidade sem que se tenha gastos elevados como no desenvolvimento de ASICs.
É possível simular a funcionalidade do projeto antes de produzir- lo, evitando assim desperdícios de recursos.
A computação com FPGAs é denominada configurável devido a o fato de ser definida por a configuração de bits no FPGA, a qual define a função dos blocos lógicos e a interconexão entre estes.
Como nos processadores, FPGAs são programados após a fabricação para solucionar virtualmente qualquer tarefa computacional, isto é, qualquer tarefa que caiba nos recursos finitos do dispositivo.
Esta padronização pós-fabricação distingue processadores e FPGAs de blocos funcionais padronizados, os quais têm suas funções definidas durante a fabricação e implementam somente uma função ou um pequeno número de funções.
Diferentemente dos processadores, os FPGA implementam o equivalente a uma única, e poderosa, instrução.
Em os dispositivos configuráveis as operações são implementadas de forma espacial, explorando- se o paralelismo inerente das aplicações alvo.
Já nos processadores, as instruções são organizadas seqüencialmente para executarem a mesma função.
A Figura 2 compara a implementação de um filtro digital, utilizando- se dispositivos programáveis e microprocessadores.
Para a implementação FPGA, observa- se que operadores aritméticos e registradores são replicados, resultando em solução com uma alta taxa de saída (um bit processado por ciclo de clock).
Já na implementação com microprocessador, temos um conjunto seqüencial de operações, o que resulta numa taxa de processamento inferior aos dispositivos programáveis.
O advento de FPGAs complexos, possibilitou retomar o trabalho proposto no início da década de 60 por Gerald Estrin.
Estrin propôs um &quot;computador com uma estrutura fixa e uma estrutura variável», em o qual o hardware era dedicado tanto à abstração de um processador programável (inflexível) quanto a um componente que implementava a lógica digital (flexível).
Esta arquitetura básica, que dá suporte a hardware programável e software, é o núcleo de muitos sistemas computacionais configuráveis subseqüentes.
Muitos dos conceitos aplicados atualmente em computação reconfigurável têm como base o trabalho de Estrin.
A o final dos anos 80 e início dos anos 90, várias arquiteturas reconfiguráveis foram propostas e desenvolvidas.
Entre os exemplos mais significativos estão Os FPGAs têm sido utilizados num crescente número de sistemas digitais.
Equipamentos computacionais baseados em FPGAs, também denominados Máquinas Computacionais Especializadas ­ CCMs, são eficientes e apresentam alto desempenho na solução de problemas computacionais complexos.
Em muitos casos, um simples arranjo de FPGAs supera o desempenho de uma estação de trabalho ou até mesmo um supercomputador.
Um bom desempenho e eficiência são alcançados por arquiteturas computacionais especializadas desenvolvidas para solucionar problemas específicos.
As técnicas de especialização de arquiteturas computacionais incluem a otimização dos elementos processadores e armazenamento, conduzindo à solução adequada para um domínio limitado de problemas.
Limitando- se uma arquitetura a uma certa aplicação específica permite- se aos recursos de hardware serem utilizados mais eficientemente se comparados a arquiteturas de propósito geral.
Muitos exemplos de CCMs apresentam incremento significativo de desempenho devido a a personalização da arquitetura a uma área específica de aplicação.
Pode- se citar como exemplo, a pesquisa num banco de dados de genética realizada por a CCM SPLASH-2.
Para esta aplicação (na data de publicação da referência), o SPLASH-2 superava, em velocidade, um supercomputador em duas ordens de grandeza.
O SPLASH-2 alcança este alto nível de desempenho replicando o processamento de casamento (matching) de caracteres através de sua arquitetura reconfigurável.
Como outro exemplo, pode- se citar a implementação do circuito de criptografia RSA na CCM DECPeRLe-1 que apresenta, na decodificação criptográfica, desempenho superior ao estado-da-arte na data de sua publicação.
Este sistema alcança altas taxas de decodificação utilizando multiplicadores de inteiros longos dedicados e módulos de exponenciação, ambos implementados em FPGAs.
Em sistemas computacionais tradicionais a especialização arquitetural é alcançada ao custo da flexibilidade.
Arquiteturas computacionais projetadas para uma área de aplicação são geralmente muito ineficientes ou impróprias para outras áreas de aplicação.
A necessidade de flexibilidade dos sistemas de propósito específico inibe seu emprego mais amplo.
Em sistemas baseados em FPGAs, a especialização da arquitetura não sacrifica sua flexibilidade.
Devido a a possibilidade de reconfiguração dos circuitos, um FPGA pode operar como uma variedade de arquiteturas computacionais específicas.
Esta flexibilidade torna um sistema CCM uma alternativa atraente para muitas aplicações específicas.
A ampla variedade de problemas computacionais solucionados por o DECPeRLe demonstra esta flexibilidade.
Exemplos de aplicação que demonstram altos níveis de desempenho alcançados por o DECPeRLe incluem:
Multiplicação de números longos, criptografia RSA, compressão de dados, casamento de cadeias de caracteres, equações de Laplace, mecânica de Newton, convolução em duas dimensões, máquina de Boltzman, geometria em três dimensões e a transformada discreta do coseno (DCT).
Com uma arquitetura fixa não há como atingir um bom desempenho em tal variedade de problemas computacionais.
Um ASIC projetado para realizar todas as tarefas do DECPeRLe, por exemplo, apresentaria níveis de desempenho muito mais baixos, pois teria que ser implementado praticamente como um processador genérico.
A maior causa da redução do desempenho em sistemas computacionais é o tempo gasto em ler/ escrever dados de/ para memória e de/ para periféricos (entrada/ saída).
Uma largura de banda de comunicação de dados pequena reduz o desempenho no processamento dos dados.
Os sistemas operacionais multi-tarefas atuais e suas aplicações sofisticadas não requerem apenas processadores rápidos, exigem também uma maior vazão de dados de/ para periféricos tais como discos rígidos e hardware de vídeo.
Sendo assim, o barramento ISA usado em computadores pessoais, tornou- se um gargalo que se opõe ao aumento do desempenho geral do sistema.
A forma encontrada para continuar desenvolvendo processadores cada vez mais rápidos, cuja freqüência de operação muitas vezes é superior a dos componentes restantes do sistema, foi isolar o sub-sistema de entrada/ saída do sub-sistema processador/ memória/ cache.
Em este contexto, foi desenvolvido o barramento Peripheral Component Interconnect -- PCI, o qual aumenta a largura de banda provendo uma via para os dados capaz de transmitir até 528 MB/ s (a 66 MHz, largura de barramento de 64 bits).
Adicionalmente a essa otimização, o PCI também permite acesso direto à memória cache e dá suporte a uma arbitragem distribuída de barramento.
Os componentes do barramento PCI e a interface das placas PCI são também independentes do processador.
Outra tendência observada hoje é o desenvolvimento de SoCs, onde o processador e a lógica programável são implementados no mesmo circuito integrado, minimizando assim o custo de transferência de dados.
Pode- se citar como exemplo comercial a iniciativa Excallibur, da Altera.
O mercado atual de sistemas digitais é caracterizado por a necessidade de um reduzido tempo para colocação de novos produtos em comercialização (time- to-- market), conter um elevado número de portas lógicas, além de terem que apresentar alto desempenho e baixo consumo de potência.
Apesar de a necessidade de um reduzido time- to-- market, a qualidade dos produtos não pode ser comprometida, correndo- se o risco de se chegar ao mercado com um produto não competitivo.
Este ambiente competitivo induz mudanças fundamentais nos métodos de projeto de sistemas digitais VLSI.
A utilização de módulos pré-projetados e pré-validados de hardware, denominados cores permite o desenvolvimento de circuitos muito mais complexos num tempo de projeto muito mais reduzido.
As empresas especializam- se numa determinada área, por exemplo telecomunicações, e os módulos em que a empresa não é especialista são comprados de terceiros, por exemplo, núcleos de processadores.
Estes cores são protegidos por leis de Propriedade Intelectual (Intelectual Propriety ­ IP).
Outra tendência observada no projeto de circuitos VLSI é a integração completa de sistemas digitais num único chip (Sistem-on-Chip ­ SoC).
Estes sistemas integrados num único chip são implementados utilizando- se cores, apresentando a vantagem da redução do tempo entre a comunicação hardware/ software, uma vez que o núcleo processador e o hardware estão integrados no mesmo dispositivo.
Apresentou- se nas Subseções anteriores os temas que motivaram o desenvolvimento deste trabalho:
FPGAs, arquiteturas reconfiguráveis, interação hardware/ software e cores.
Para a implementação eficiente de arquiteturas reconfiguráveis é necessário que haja um meio rápido e eficiente para a comunicação hardware/ software.
Este meio de comunicação pode ser implementado como um core para FPGA, disponível para a comunidade acadêmica.
Esta dissertação versa sobre o desenvolvimento de um módulo pré-projetado e reutilizável de hardware, core, que implementa o padrão de barramento PCI.
O objetivo é permitir uma rápida comunicação software/ hardware através da utilização deste core.
A utilização do padrão PCI reduz o tempo de transferência de dados entre os componentes hardware e software de um sistema digital, aumentando o desempenho global do sistema.
Na medida em que se disponibilizam cores PCI, aplicações que necessitam de um protocolo ou interface de alto desempenho podem agregar à sua estrutura este core para conectarem- se ao barramento PCI de computadores hospedeiros.
Entre as aplicações pode- se citar, por exemplo, a aceleração de algoritmos que possuem gargalos de desempenho.
O gargalo de desempenho pode ser migrado para o hardware, e a interface PCI realiza a comunicação entre a aplicação do usuário, em software, e a parte crítica da aplicação, em hardware.
Outro fator a ser considerado é o alto custo financeiro para a aquisição de um core PCI.
Por exemplo, a empresa XILINX comercializa um firm core PCI por cerca de US$ 10.000,00.
Além de isto, projetar e construir um core PCI é um excelente meio de dominar a tecnologia de projeto de sistemas digitais com especificação de temporização muito estritas, implicando no uso de tecnologia no estado da arte para projeto, validação funcional, validação de temporização e validação de protótipo.
Esta dissertação está organizada da seguinte forma.
O Capítulo 2 apresenta a descrição do barramento PCI, detalhando suas caraterísticas arquiteturais e os ciclos básicos de operação.
Uma vez o barramento PCI descrito, o Capítulo 3 apresenta o core desenvolvido, além de outros encontrados na bibliografia.
Este Capítulo é a contribuição maior deste trabalho, pois detalha o sistema digital implementado.
O Capítulo 4 apresenta um ambiente para desenvolvimento de aplicações que utilizam o barramento PCI como meio de comunicação.
Como plataforma de desenvolvimento, apresentaremos o ambiente HOT II-XL.
Finalmente, o Capítulo 5 apresenta as conclusões deste trabalho, assim como sugestões de trabalhos futuros.
Este Capítulo tem por objetivo apresentar as características do barramento PCI.
Serão apresentadas, inicialmente, as características gerais deste, comparando- o com outros padrões de barramento.
A seguir, o conjunto de sinais presentes no barramento PCI é listado, detalhando- se a função de cada sinal.
A parte final deste Capítulo detalha os ciclos de operação do barramento, como leitura e escrita, em modo simples e rajada.
A compreensão do funcionamento do barramento PCI é de fundamental importância para o desenvolvimento do core, o qual será apresentado no O Peripheral Component Interconnect -- PCI é um barramento de alto desempenho, empregado para conectar componentes de uma placa mãe, bem como componentes destas à placas de extensão de um computador.
Este barramento foi proposto, primeiramente, por a empresa INTEL em dezembro de 1991 durante o Intel Technical Forum, e a primeira versão de sua especificação data de junho de 1992.
Os membros do PCI Steering Committee que desenvolveram a primeira versão da especificação PCI foram a Compaq, DEC, IBM, INTEL e NCR.
Em junho de 1992, o PCI tornou- se um padrão industrial aberto, orientado por o PCI Special Interest Group ­ PCI SIG (www_ Pcisig_ Com).
Em abril de 1993, chega a versão V2.
0 do PCI.
A revisão desta especificação, denominada V2.
1, data de O protocolo Extended PCI ­ PCI-X é um projeto avançado do padrão de barramento PCI.
Permite que projetos com 64 bits de largura de barramento operem com freqüência de até 133 MHz.
Este desempenho é alcançado por a implementação de um protocolo registrador-a-registrador.
O PCI-X opera indistintamente no protocolo PCI V2.
2 ou no próprio padrão PCI-X..
A Tabela 1 apresenta as principais características de algumas arquiteturas que antecederam o padrão PCI.
A Tabela 2 apresenta o desempenho do padrão PCI para diferentes larguras de barramento e freqüências de operação.
Apesar de haver a norma para freqüência de operação a 133 MHz, no decorrer de o texto mencionaremos apenas as freqüências 33 e 66 MHz.
Os protocolos de barramentos anteriores ao PCI permitiam apenas ciclos de acessos simples de leitura e escrita.
Diferentemente, o PCI permite uma transferência de dados (leitura/ escrita) em modo burst (rajada), o que melhora o seu desempenho.
Em um acesso simples dos outros barramentos, há necessidade de se informar um novo endereço a cada transferência.
Em o modo burst, múltiplas transferências para/ de endereços consecutivos são realizadas, tendo um comprimento indefinido.
A transferência em modo burst continua até que algum dispositivo PCI no barramento solicite o final da transferência.
O barramento PCI possui as seguintes características:
Dados e endereços são multiplexados nas mesmas linhas de sinal (Ad), e os comandos de barramento e largura dos dados são multiplexados nas mesmas linhas de sinal (C/ BE&amp;).
Isto traz como conseqüência a divisão dos ciclos de acesso em fases de endereçamento de dados.
Durante a fase de endereçamento o endereço do dispositivo alvo e o comando a ser executado são colocados no barramento.
Durante a fase de dados, os dados e a indicação de quantos bits se pode utilizar são colocados no barramento.
A indicação do número de bits a ser utilizado na fase de dados é especificada por o sinal C/ BE&amp;.
O espaço de endereçamento é de 32 bits com opção de ser estendido para 64 bits.
A largura do barramento de dados é definida com 32 bits com opção de ser estendido para 64 bits.
O padrão de acesso aos dispositivos conectados ao barramento PCI é em modo burst (rajada), o qual permite múltiplos acessos a dados numa única operação de escrita ou leitura.
Enquanto nenhuma operação ocorre no barramento PCI, as linhas de sinal são mantidas em nível lógico alto devido a resistores pull-up ou num nível estável por o master.
Geração e verificação de paridade para endereços, dados e sinais de controle.
Com exceção do sinais SERR&amp;, RST&amp; e INT&amp;, todos os sinais são síncronos em relação a o clock (CLK).
O termo Plug-and-Play -- PNP, refere- se à capacidade do sistema computacional de determinar automaticamente os recursos necessários para cada dispositivo instalado no barramento PCI.
Estes recursos são mapeados de forma a evitar conflitos no sistema, o que acontece com os dispositivos que não são PNP, os chamados legacy (legados), que necessitam ser configurados por jumpers.
São exemplos de dispositivos legados os controladores de portas serial/ paralela e os controladores conectadas aos slots ISA.
A especificação PCI define registradores de configuração que devem estar presentes em cada dispositivo PCI.
Estes registradores têm por objetivo portar informações acessíveis por o mecanismo PNP do sistema hospedeiro para alocar recursos a cada dispositivo conectado ao barramento PCI.
São três os componentes necessários para um sistema PCI PNP:
Registradores de configuração;
PCI Basic Input and Output System -- PCI BIOS;
Software para componentes PNP.
Segundo a especificação do padrão PCI, cada dispositivo compatível com este barramento contém uma memória de 256 bytes, utilizada por os registradores de configuração.
O conjunto completo destes registradores está apresentado na Tabela 3.
Existem quatro tipos de registradores que são importantes para o sistema PNP que são:·
Device e Vendor Id..
São empregados juntos para identificar o fabricante de um dispositivo em particular.
O Vendor Id é atribuído por o PCI SIG, o que garante um único número de identificação para cada fabricante.
Cada fabricante atribui a seu Device Id valores que garantem um único identificador para cada um de seus produtos.·
Bar. Possui um duplo propósito.
A partir de o power on, o Bar identifica os recursos do sistema necessários para cada dispositivo.
Cada dispositivo pode utilizar até seis registradores Bar para identificar até seis espaços de endereços individuais de vários tamanhos para serem empregados por o dispositivo.
O valor inicial armazenado em cada bit menos significativo classifica o dispositivo como sendo de entrada/ saída ou um espaço de memória.
Os bits restantes indicam quanto espaço é solicitado.
Para completar a configuração PNP o host escreve o valor do endereço base para o dispositivo no Bar.·
Interrupt Line Register.
Este registrador é utilizado para identificar a linha de interrupção a ser utilizada por o dispositivo PCI compatível.
Em sistemas Personal Computer ­ PC, este registrador recebe o valor da interrupção de hardware utilizada por o dispositivo.
Outros registradores do espaço de configuração contêm outras informações como Class Code, que serve para identificar o tipo de dispositivo, e registradores para a requisição do barramento, como Minimum Grant e Latency timer (temporizador de latência) que são parâmetros necessários para o arbitramento do barramento PCI.
Estes 3 registradores supra definidos, bem como outros parâmetros, não são necessários para as funções PNP.
Os dispositivos PCI reconhecem três espaços de endereçamento diferentes:
Endereçamento de Memória (Memory Address);
Endereçamento de Entrada/ Saída (I/ O Memory);
Endereçamento de Memória de Configuração (Configuration Memory).
Os espaços de endereçamento de memória e de entrada/ saída são definidos como nos processadores Intel e utilizados em acessos normais de dados.
Todos os dispositivos conectados ao placa mãe de um computador hospedeiro, possuem uma Memória de Configuração (Configuration Memory).
Esta Memória de Configuração tem um tamanho de 256 bytes, e armazena informações sobre os recursos dos dispositivos PCI presentes no sistema.
A Memória de Configuração possui uma parte pré definida, que é formada por os seus primeiros 64 bytes e os 192 bytes restantes formam a parte dependente do dispositivo.
A Figura 4 ilustra a parte pré-definida da Memória de Configuração.
O conteúdo destes registradores corresponde ao apresentado na Tabela 3.
Estes registradores são acessados por seus endereços nos ciclos de acesso à configuração, como por exemplo, a inicialização do computador.
A Memória de Configuração deve estar sempre acessível e, quando lida, todas as 256 posições de memória devem retornar dados válidos.
As posições de memória destacadas na Figura 4 devem sempre conter dados referentes ao dispositivo em questão.
Para dispositivos multifunção, devem ser implementadas memórias de configuração separadas para cada função.
A configuração PNP dos dispositivos conectados ao barramento PCI é controlada por o PCI BIOS no momento da inicialização do sistema (boot time).
A Figura 5 apresenta o diagrama do PCI Boot Incrementa Número do Slot Número do Slot $= 0 Ler Vendor Id Não Válido Não Sim Ler Recursos Último Slot Sim Montar Mapa de Recursos Indexar Primeiro Id Válido Escrever Recurso Disp.
O BIOS inicia a seqüência de configuração PNP endereçando individualmente cada slot PCI de um conector PCI da placa mãe, de maneira a determinar se um dispositivo válido está em ele inserido.
A verificação do dispositivo é feita através da leitura do registrador Vendor Id..
Um valor FFFF (HEX) (devido a resistores pull up) indica um componente inválido, ou nenhum instalado.
Se outro valor for retornado por o registrador Vendor Id, o sistema fará a leitura do Bar e do Interrupt Register do dispositivo.
Este procedimento se repete até que todos os slots PCI tenham sido acessados, e com isso o sistema torna- se informado sobre I/ O, memória e interrupções solicitados individualmente por os dispositivos conectados ao barramento.
Assim, o sistema gera um mapa para cada dispositivo, garantindo a exclusividade deste espaço a cada um de eles, evitando assim conflitos.
O PCI BIOS escreve o endereço base de cada espaço atribuído no Bar apropriado e a interrupção é escrita no Interrupt Register.
Terminadas estas tarefas, encerra- se a configuração PNP do hardware.
O software a nível de sistema utilizado para operar um dispositivo necessita de informações como endereços de I/ O, endereços de memória e interrupções.
Em sistemas não PNP, os recursos necessários são determinados por o hardware.
Historicamente, vários métodos têm sido utilizados para definir o espaço de endereços do hardware tais como jumpers e dip switches.
Em este caso o software é direcionado para utilizar endereços pré determinados.
Isto permite ao hardware operar assumindo que não há outro dispositivo configurado com os mesmos recursos.
O PNP pressupõe uma abordagem diferente para o software.
Em os dispositivos PNP, o mapeamento dos recursos de hardware dentro de o espaço do sistema não é pré determinado por o hardware.
O espaço alocado para cada dispositivo depende de vários fatores, incluindo a arquitetura do sistema, o PCI BIOS e a presença de outros dispositivos PNP conectados ao sistema.
Devido a estes fatores, os controladores (drivers) de hardware são os responsáveis por determinar os recursos a serem alocados para cada dispositivo a partir de a inicialização do sistema.
A Figura 6 mostra o fluxograma do algoritmo a ser executado na inicialização do computador em sistemas PNP.
A primeira tarefa a ser realizada por a BIOS num sistema PNP é verificar a presença do PCI BIOS.
Isto é feito com o emprego de uma função de baixo nível da BIOS, a qual verifica a presença de uma PCI BIOS.
A função do BIOS determinará o número da revisão do barramento PCI bem como, se há mais de um barramento PCI presente no sistema, o numero do último barramento.
O número da revisão PCI refere- se à PCI Local Bus Specification (Especificação PCI do Barramento Local) utilizada no projeto da BIOS.
O número do último barramento PCI refere- se ao fato que, embora seja transparente ao usuário, muitos sistemas contêm mais do que um barramento PCI em sua placa mãe.
Ligado a isto está, também, a limitação que a especificação impõe de quatro slots PCI por barramento.
Logo, se o sistema for dotado de mais slots, ele certamente estará separado em mais de um barramento.
A segunda tarefa é a localização dos dispositivos PCI conectados ao sistema.
Isto se faz através da chamada de uma função PCI BIOS e especificando um Vendor Id e um Device Id únicos e um valor de índice.
Dado que cada tipo de dispositivo conectado ao barramento PCI contém uma única combinação, estes identificadores podem ser utilizados para localizar um dispositivo desejado num sistema.
O valor do índice é necessário devido a o fato de que o barramento pode possuir múltiplas ocorrências de um mesmo dispositivo.
O índice identifica cada dispositivo a ser acessado de forma unívoca.
A função do PCI BIOS retorna o número do barramento e o índice do dispositivo localizado.
Estes dois parâmetros são utilizados para garantir um acesso único aos registradores de configuração de um dispositivo particular.
A tarefa final do nível de software é a de determinar os recursos atribuídos a cada dispositivo.
Isto é feito através da leitura de valores armazenados nos Bar de cada dispositivo.
Há outra função do PCI BIOS que retorna o valor do Bar baseado no número do barramento e no valor da função do dispositivo determinados na tarefa anterior.
Os dispositivos PCI não utilizam todos os espaços disponíveis no Bar.
Um valor igual a zero no Bar indica que o dispositivo não solicitou qualquer recurso a ser atribuído ao Bar.
Uma leitura de um Bar que retorna o valor padrão zero, indica que o sistema PNP não atribuiu nenhum espaço ao Bar.
Caso contrário, o valor retornado por o Bar indica qual o tipo de recurso, I/ O ou memória foi atribuído, e o endereço base do início do espaço que será utilizado por o dispositivo.
O nível de software deve, então, utilizar estes endereços para acessar o dispositivo.
Na medida em que os barramentos aumentam sua largura, os conectores, circuitos integrados e trilhas na placa mãe aumentam, elevando assim os custos de produção.
O padrão PCI, para reduzir custos, multiplexa endereços e dados.
A primeira versão do barramento PCI trabalhava com uma tensão de 5 Vcc.
A partir de a versão V2.
0, de junho de 1995, ficou determinado que a alimentação das placas periféricas PCI fosse de 3,3 Vcc.
A Figura 7 apresenta detalhes quanto a tensão de alimentação.
Quanto a as dimensões físicas, dois tamanhos de placas podem ser encontrados:
12 «(tamanho padrão) e 7 «de comprimento.
A Figura 8 ilustra estas medidas.
Uma outra especificação, denominada SPCI, originalmente chamada de Small Form Factor ­ SFF PCI, é uma definição mecânica para um tipo de placa e conector com dimensões de um cartão de crédito para ser empregado em espaços reduzidos e/ ou equipamentos portáteis.
O padrão é funcionalmente compatível com o protocolo PCI Revisão 2.1.
A Revisão 1.0 do SPCI foi editada por o PCI-SIG em 1° de maio de 1996.
Há muitas semelhanças físicas entre o SPCI e os Personal Computer Memory Card International Association ­ PCMCIA.
As dimensões são as mesmas, porém o SPCI utiliza um conector com 108 pinos contra os 68 do PCMCIA.
Existem duas espessuras para os cartões SPCI:
Tipo A, com 5,0 mm e Tipo B com 10,5 mm, correspondendo aos padrões Tipo II e Tipo III do padrão PCMCIA, respectivamente.
Todas as publicações referentes ao padrão PCI estão disponíveis no endereço características elétricas e mecânicas do padrão PCI.
Toda operação PCI ocorre entre dois componentes distintos:
O master e o target.
O master é o dispositivo que inicializa e gerência o barramento PCI, podendo ser o processador ou uma bridge.
Já o target é o dispositivo alvo, aquele que responde a um acesso, como por exemplo uma controladora de vídeo, memórias e I/ O. A Figura 9 ilustra estes componentes.
Somente um master pode controlar o barramento PCI em cada ciclo de barramento que esteja sendo executado.
Outro master, que não aquele ativo no momento, pode solicitar a arbitragem através do sinal LOCK&amp;.
Dá- se o nome de arbitragem ao controle e gerenciamento do barramento PCI durante os ciclos de barramento.
Esta arbitragem ser feita por qualquer dispositivo master que necessite do barramento.
Esta solicitação é feita para o árbitro central, que é a entidade que está gerenciando o barramento no momento da solicitação.
Dois sinais estão envolvidos na solicitação da arbitragem do barramento:
REQ&amp; e GNT&amp;.
O sinal REQ&amp; é o sinal utilizado por um master para solicitar o barramento, que recebe como resposta positiva à solicitação a ativação do sinal GNT&amp;.
O dispositivo master que deseja gerenciar o barramento deve ativar o sinal REQ&amp; somente quando ele estiver pronto para iniciar, imediatamente, um novo ciclo.
As linhas dos sinais REQ&amp; e GNT&amp; são individuais para cada dispositivo e roteadas ponto a ponto até o árbitro central, que é uma bridge.
A ativação dos sinais REQ&amp; e GNT&amp; é sincronizada com o sinal de CLK.
Existe mais de um algoritmo de distribuição de arbitragem por a bridge no PCI.
Por exemplo, supondo que existem 3 dispositivos que podem operar como master (A, B e C).
O árbitro central garantirá primeiramente ao dispositivo A o acesso ao barramento.
Se A não quiser assumir o barramento ou já concluiu sua utilização, o árbitro central passará o controle para B. Após A e B concluírem suas tarefas o árbitro passará o controle para C. Dado que A, B e C já utilizaram o barramento, o ciclo volta para A, e assim por diante, como se executasse um pooling.
Outro algoritmo associa a cada dispositivo um nível de prioridade.
Quando dois masters requisitarem o barramento simultaneamente, aquele que tiver a maior prioridade assume o controle do barramento.
Para garantir que os outros masters tenham seu direito garantido, o árbitro central não cede a um master o controle do barramento sem que todos os outros tenham sido servidos.
Existem outros protocolos de arbitragem, porém todos tem o cuidado de não deixar de atender a solicitação de algum master (latência muito grande), de garantir o tempo necessário na utilização do barramento (garantir latência) e de, independente da solicitação, oferecer o controle do barramento a qualquer master.
O PCI tem duas larguras de barramento, 32 e 64 bits, e freqüências de operação de 33 MHz e 66 MHz, respectivamente.
Os dispositivos PCI com barramento de 32 bits possuem 124 pinos, e os com barramento de 64 bits tem 188 pinos.
Um dispositivo target, 32 bits, deve possuir no mínimo 47 pinos disponíveis à interface do barramento (todos os pinos obrigatórios menos GNT&amp; e REQ&amp; estes sinais serão definidos na Seção seguinte), e um dispositivo master deve ter um mínimo de 49 pinos (todos os pinos obrigatórios).
Para se chegar ao número total de pinos, devem ser considerados diversos pinos de alimentação 3,3 Vcc, 5,0 Vcc e terra.
A Figura 10 ilustra os sinais obrigatórios (para master e target), bem como os sinais para operação em barramento de 64 bits.
Os sinais marcados com&amp; são ativos em nível lógico 0, e os que estão em negrito fazem parte do conjunto mínimo de sinais que um dispositivo compatível com o padrão PCI deve manipular em modo target.
CLK: Clock do sistema (33/66 MHz).
O protocolo do barramento PCI é definido como síncrono e todos os sinais no barramento PCI são sensíveis à borda de subida do pulso de clock, exceto os sinais SERR&amp; (system error), RST&amp; (reset) e as linhas de sinal de INT&amp; (interrupt).
RST&amp;: Inicializa todos os registradores de configuração.
Sinal assíncrono em relação a o clock do sistema.
Ad: O barramento de endereços é multiplexado com o de dados.
Uma transação de barramento se inicia com uma fase de endereçamento seguida por uma ou várias fases de dados.
O barramento PCI suporta leitura/ escrita em modo burst.
C/ BE&amp;:
Command/ Byte Enable ­ sinais multiplexados.
Durante a fase de endereçamento de uma transação de barramento, este sinal possui um comando (C) que identifica qual a operação que se inicia;
Durante a fase de dados de uma transação determina qual (is) a (s) via (s) do barramento de dados que possuem dados válidos (Be&amp;).
Par: Paridade ­ paridade par associada à concatenação de Ad e C/ BE.
Frame&amp;: Indica o início e o fim de uma transação de barramento.
É comandado por o master.
Frame&amp; vai a nível lógico 1 quando o master está pronto para completar a fase final da transação.
IRDY&amp;: Initiator Ready ­ durante uma transação de escrita, o master do barramento aciona este sinal colocando- o em &quot;0», indicando que um dado válido está disponível no barramento.
Durante uma transação de leitura, o master do barramento aciona este sinal, indicando que está pronto para receber um dado do target.
Durante transações de leitura e escrita, wait states podem ser acrescentados no IRDY&amp; enquanto estiver ativo.
TRDY&amp;: Target ready ­ Durante uma transação de leitura, o target aciona este sinal para indicar que ele disponibilizou um dado válido no barramento PCI.
Durante uma transação de escrita, o target aciona este sinal para indicar que ele está pronto para receber um dado do barramento PCI.
Durante transações de leitura e escrita, wait states podem ser acrescentados no TRDY&amp;, enquanto estiver ativo.
Idsel: Initialization Device Select -- Utilizado na inicialização do sistema (boot) como um chip select durante o acesso aos registradores de configuração (leitura ou escrita).
Devsel&amp;: Sinal gerado por o target quando seu endereço é decodificado.
Se este sinal permanecer inativo durante 6 ciclos de clock após a transferência de dados ter iniciado, o master aborta a transferência de dados.
STOP&amp;: Sinal gerado por o target para solicitar ao master o fim de uma transação.
PERR&amp;: Parity error ­ Sinaliza erro de paridade de dados durante as transações do barramento, exceto quando em Special Cycle.
SERR&amp;: System error ­ Sinaliza erro de paridade de endereçamento, paridade de dados ou qualquer erro severo.
GNT&amp;: Grant -- Sinaliza ao master que o controle do barramento está garantido.
REQ&amp;: Request -- Sinaliza ao árbitro atual do barramento que um novo master necessita acesso ao barramento.
Uma importante observação quanto a a multiplexação das linhas de dados e endereços é que quando o master solicita dados do target, necessita- se de um ciclo extra no protocolo para a inversão da direção do barramento.
Este fato fica mais claro na discussão sobre os ciclos de escrita e leitura, abordados na Seção 2.8.
A especificação PCI permite que o tamanho dos dados em suas vias seja identificado dinamicamente.
Não há troca de dados (swap) nas vias de dados.
Logo, todos os dispositivos PCI compatíveis devem dar suporte a uma largura de barramento de dados de 32 bits.
O barramento Ad contém 4 vias de dados com largura de um byte.
Ad compreende a primeira via, Ad a segunda, Ad a terceira e Ad a quarta via.
Estas vias podem ser acessadas independentemente, conforme o valor especificado em C/ BE&amp;.
A especificação do padrão PCI provê uma capacidade de detecção de erros limitada.
As linhas C/ BE&amp; e Ad são protegidas com paridade par sinalizadas por os sinais Par e PAR64, sendo que Par é para a versão 32 bits, e PAR64 é utilizado nas operações em 64 bits.
As linhas PERR&amp; e SERR&amp; são utilizadas para sinalizar erros de paridade e erros com a plataforma hospedeira.
As informações de erro são armazenadas em registradores e podem ser acessadas por o BIOS, por o sistema operacional e por o software de aplicação.
A paridade é utilizada em todos os ciclos do barramento PCI.
A geração da paridade não é opcional e deve ser computada e sinalizada numa das linhas Par/ PAR64.
Contudo, a paridade não precisa ser verificada por todos os dispositivos conectados ao barramento.
Os dispositivos que não verificam e reportam erros de paridade são aqueles que satisfazem as seguintes condições:
Recursos que estão inseridos diretamente na placa mãe e não em placas de inserção (add-on cards), ou Recursos que não processam dados permanentemente, por exemplo, placas de vídeo.
Em outras palavras, recursos que não causarão perda no desempenho no processamento da plataforma quando um erro de paridade ocorrer e não suportam verificação de paridade.
A primeira fase de uma transação de barramento chama- se de fase de endereçamento, em a qual o master coloca um endereço nas linhas Ad e um comando nas linhas C/ BE.
Um ciclo de clock depois, o master coloca na linha Par o bit de paridade correspondente, calculado sobre os bits de Ad e C/ BE&amp;.
Este atraso de um ciclo de clock deve- se ao fato de que o target precisa calcular a paridade entre Ad e C/ BE recebidos e depois receber o sinal Par para poder comparar com a paridade que calculou.
Se o bit recebido na linha Par for igual ao da paridade calculada por o target, a linha PERR&amp; (Parity Error) é mantida desativada, isto é, em nível lógico 1.
A segunda fase de uma transação de barramento é a fase de dados.
A partir de esta fase a paridade é calculada entre os dados colocados em Ad e os sinais de byte enable colocados em C/ BE.
Para cada dado e byte enable, a paridade é calculada e um sinal Par é gerado, seja em ciclos de leitura ou de escrita.
Em as figuras da Seção 2.8 está ilustrado o funcionamento do cálculo da paridade.
Os comandos de barramento indicam ao target o tipo de transação que o master está requisitando.
Em o início de cada fase de endereçamento, as linhas C/ BE&amp; carregam o código do comando.
A Tabela 4 apresenta os tipos de comando, seguida por uma breve descrição de cada um.
Interrupt Acknowledge: Este comando faz uma requisição ao controlador de interrupções do sistema.
Special Cycle: Este comando provê um mecanismo de broadcast no PCI.
I/ O Read:
Comando utilizado para ler dados de um dispositivo mapeado no espaço de endereçamento I/ O. I/ O Write:
Comando utilizado para escrever dados num dispositivo mapeado no Espaço de Endereçamento de I/O. Reserved:
Para utilização futura.
Caso o código deste comando seja utilizado no barramento, o acesso do dispositivo PCI target será abortado por o master.
Memory Read: Comando utilizado para ler dados de algum dispositivo mapeado no Espaço de Endereçamento de Memória.
Memory Write: Comando utilizado para escrever dados de algum dispositivo mapeado no Espaço de Endereçamento de Memória.
Configuration Read: Este comando é utilizado para ler o Espaço de Configuração de cada dispositivo PCI.
Um dispositivo PCI é selecionado durante um acesso de configuração quando o sinal IDSEL é ativado e Ad é &quot;00».
Configuration Write: Comando utilizado para a transferência de dados ao Espaço de Configuração de cada dispositivo PCI.
O endereçamento para transações de escrita de configuração é o mesmo que para transações de leitura de configuração.
Memory Read Multiple: Este comando é semanticamente idêntico ao comando Memory Read, exceto que adicionalmente indica que o master pretende fazer buscas a mais de uma linha de memória antes de desconectar.
Dual Address Cycle: Comando empregado na transferência de endereços de 64 bits para dispositivos que suportam 64 bits de endereçamento quando o endereço não se encontra no espaço de endereços abaixo de 4 GB, ou seja, possui pelo menos 1 dos 32 bits mais significativos em &quot;1».
Os dispositivos target que suportam somente 32 bits de endereçamento devem tratar este comando como reservado, não podendo responder a este comando.
Memory Read Line:
Este comando é semanticamente idêntico ao comando Memory Read, exceto que adicionalmente indica que o master pretende fazer uma busca completa à memória cache do host.
Memory Write and Invalidade: Este comando é semanticamente idêntico ao comando Memory Write, exceto que adicionalmente garante uma transferência mínima de uma linha completa de cache, isto é, o master pretende escrever todos os bytes na linha de cache endereçada numa única transação de barramento sem interrupção por o target.
Todos os dispositivos PCI (com exceção das bridges do barramento hospedeiro) devem responder como target no comando configuração (escrita ou leitura).
Todos os outros comandos são opcionais.
A Tabela 5 apresenta os comandos mínimos para um dispositivo operar somente como target.
O barramento PCI suporta transferências de dados em modo burst (rajada), que consistem numa fase de endereçamento seguida por uma ou mais fases de dados.
O modo de transferência usuário), ou para os registros de configuração.
Uma alta taxa de transferência é alcançada devido a o fato de que múltiplas fases de dados são realizadas para cada fase de endereçamento, ao invés de uma fase de dados para uma fase de endereçamento para o modo não burst (simples).
Os ciclos descritos a seguir são:
Ciclo de acesso de Leitura em Modo Simples;
Ciclo de acesso de Escrita em Modo Simples;
Ciclo de acesso de Leitura em Modo Burst;
Ciclo de acesso de Escrita em Modo Burst;
Ciclo de acesso à Configuração e Ciclo Especial.
A Figura 11 apresenta os sinais durante este ciclo.
Um ciclo de acesso simples de leitura inicia quando o master do barramento PCI ativa o sinal Frame&amp;, colocando um tipo de comando (COMMAND) válido nas linhas C/ BE&amp; e um endereço válido de dispositivo nas linhas Ad.
Esta fase denomina- se fase de endereçamento (ADDRESS PHASE) do ciclo de acesso e dura um ciclo de clock.
Completada esta fase o master ativa o sinal IRDY&amp; (initiator ready) indicando que está pronto para começar a ler os dados do target.
Em o mesmo instante o sinal Frame&amp; é desativado.
O dispositivo que contiver o endereço colocado por o master em Ad, indica que foi selecionado ativando o sinal DEVSEL&amp; (device selected) (3).
Imediatamente após a fase de endereçamento segue- se a fase de dados (Data PHASE).
Em o início desta fase o master do barramento habilita um subconjunto de bytes válidos por o sinal C/ BE&amp; e coloca as linhas Ad em alta impedância, pois o barramento deve ter sua direção invertida (o master enviou o endereço e o target enviará seus dados ­ barramento bidirecional) (4).
Quando o target estiver pronto para enviar os dados ele ativa o sinal TRDY&amp; (target ready) e os dados são enviados (5).
Este ciclo termina com o master desativando o sinal IRDY&amp; e os sinais de controle são removidos por o target.
Observar que ao final da fase de endereçamento e da fase de dados do ciclo de leitura, há o cálculo da paridade entre C&amp;A (command e address) e Be &amp; D (byte enable e data) (7).
Os sinais deste ciclo são mostrados na Figura 12.
Um ciclo de acesso de escrita em modo simples inicia similarmente ao ciclo de leitura simples.
Inicia quando o master do barramento PCI ativa o sinal Frame&amp;, colocando um tipo de comando (COMMAND) válido nas linhas C/ BE&amp; e um endereço válido nas linhas Ad.
Esta fase denomina- se fase de endereçamento (ADDRESS PHASE) do ciclo de acesso.
Completada esta fase o master ativa o sinal IRDY&amp; (initiator ready) indicando que está pronto para começar a ler os dados do target.
Em o mesmo ciclo o sinal Frame&amp; é desativado.
O dispositivo que contiver o endereço colocado por o master em Ad, indica que foi selecionado ativando o sinal DEVSEL&amp; (device selected) (3).
Quando o target estiver pronto para receber os dados ele ativa o sinal TRDY&amp; (target ready) e os dados são enviados.
Este ciclo termina com o master desativando o sinal IRDY&amp; e os sinais de controle são removidos por o target.
Observar que ao final da fase de endereçamento e da fase de dados do ciclo de escrita há o cálculo da a paridade entre C&amp;A (command e address) e Be &amp; D (byte enable e data) (6).
Uma transação de escrita é similar à transação de leitura, exceto que não há a necessidade da inversão do barramento, durando um ciclo de clock a menos.
Um dado válido poderá não estar presente a cada início de uma fase de dados, pois o target pode não estar pronto.
Em este caso são inseridos wait states por o target.
A Figura 13 mostra os sinais para um ciclo de leitura em modo burst.
O modo burst permite que o master acesse o target através de uma seqüência de micro acessos.
O ciclo inicia quando o master ativa o sinal Frame&amp;, coloca a informação de comando do ciclo em C/ BE&amp; e um endereço válido nas linhas de sinal Ad.
Este endereço estabelece o endereço base para todos os micro acessos.
Um ciclo de clock depois, o master ativa o sinal IRDY&amp; (initiator ready) indicando que está pronto para começar a ler os dados do target (2).
A partir deste ponto inicia a fase de dados.
Em o início desta fase, o master do barramento habilita um subconjunto de bytes válidos por o sinal C/ BE&amp; e coloca as linhas Ad em alta impedância, pois o barramento deve ter sua direção invertida (o master enviou o endereço e o target enviará seus dados ­ barramento bidirecional) (3).
Quando o target selecionado estiver pronto para enviar os dados ele ativa os sinais DEVSEL&amp; e TRDY&amp;, respectivamente.
A partir deste momento os dados são enviados.
Este ciclo termina com o master desativando o sinal IRDY&amp; um ciclo de clock após o Frame&amp; ter sido desativado, e os sinais de controle são removidos por o target.
Observar que ao final da fase de endereçamento e da fase de dados do ciclo de leitura, há sempre o cálculo da a paridade entre C&amp;A (command e address) e Be &amp; D (byte enable e data) para cada micro acesso.
O que diferência um acesso de leitura no modo simples do acesso de leitura no modo burst é o tempo de permanência do sinal Frame&amp; ativado.
Em o exemplo de transação de barramento ilustrado na Figura 13, verifica- se que no master desabilita por um ciclo de clock o sinal IRDY&amp; caracterizando um ciclo de wait state (estado de espera).
Em este caso, o master está indicando que não está apto a receber dados.
O target suspende então, o envio de dados até que o master acione o sinal A Figura 14 mostra os sinais para um ciclo de escrita em modo burst.
O modo burst permite que o master acesse o target através de uma seqüência de micro acessos.
O ciclo inicia quando o master ativa o sinal Frame&amp;, coloca a informação de comando do ciclo em C/ BE&amp; e um endereço válido nas linhas de sinal Ad.
Este endereço da fase de endereçamento estabelece o endereço base para todos os micro acessos.
Quando o target selecionado estiver pronto para enviar os dados ele ativa os sinais DEVSEL&amp; e TRDY&amp;, respectivamente.
Ativando o sinal IRDY&amp; (initiator ready) o master indica que está pronto para começar a enviar os dados para o target.
A partir deste ponto inicia a fase de dados.
Em o início desta fase, o master do barramento habilita um subconjunto de bytes válidos por o sinal C/ BE&amp; e coloca nas linhas Ad o dado a ser enviado.
A partir deste momento os dados são enviados.
Este ciclo termina com o master desativando o sinal IRDY&amp; um ciclo de clock após o Frame&amp; ter sido desativado, e os sinais de controle são removidos por o target.
Observar que ao final da fase de endereçamento e fase de dados do ciclo de escrita, há sempre o cálculo da paridade entre C&amp;A (command e address) e Be &amp; D (byte enable e data) para cada micro acesso (7).
A desativação do sinal TRDY&amp; (8) por o target caracteriza um ciclo de wait state (ciclo de espera) necessário para poder atender o mestre.
Tal procedimento pode ocorrer devido a o fato de que um dispositivo que esteja sendo acessado ser mais lento que o master.
O que diferência um acesso de escrita no modo simples do acesso de escrita no modo burst é o tempo que o sinal Frame&amp; permanece ativado.
A especificação do protocolo PCI suporta registradores de configuração em cada dispositivo PCI (PCI bus master, target ou bridge são definidos como dispositivos).
Este ciclo executa seus acessos da mesma forma que os ciclos de leitura e escrita, podendo ser, também, em modo simples ou burst.
Todo dispositivo PCI que é acessado por um ciclo de acesso à configuração possui 64 registradores de 4 bytes conforme mostrado na Seção 2.2.1.
Estes registradores são acessados através das linhas Ad (Initialization Device Select -- IDSEL), que atuam como um chip select tradicional.
Durante os ciclos de configuração, o dispositivo alvo do acesso corrente pode não saber seu endereço, dado que ainda não foi configurado.
Em este caso, o target é selecionado através do sinal IDSEL na inicialização (power up) do computador hospedeiro.
O ciclo de acesso à configuração tem como objetivo determinar as necessidades de cada dispositivo PCI conectado ao sistema.
Existem dois tipos de ciclos de acesso à configuração:
Tipo 0 e Tipo 1.
O Tipo 0 é efetuado num dispositivo que se encontra no mesmo barramento em que o ciclo de configuração está sendo executado.
O Tipo 1 é executado somente entre PCI/ PCI bridge.
O ciclo de acesso à configuração começa por iniciativa de a unidade central de processamento do computador hospedeiro, tendo como componente ativo as bridges, que funcionam como conexão entre os barramentos PCI, operando assim como masters.
O ciclo inicia com o master (bridge) ativando o sinal Frame&amp;, colocando um comando válido em C/ BE&amp; e estabilizando as linhas Ad&amp;.
Para um acesso à configuração, sinais em Ad são anexados à linhas IDSEL de cada dispositivo.
Durante a fase de endereçamento, somente um dispositivo é selecionado por IDSEL.
Logo após a fase de endereçamento vem a fase de dados.
O protocolo da fase de dados, tanto para o modo de acesso simples ou em modo rajada, é o mesmo que nos acessos à memória ou A ativação do sinal Frame&amp; no ciclo de configuração ocorre mais tarde do que nos ciclos de acesso à memória ou I/ O, o que leva as linhas IDSEL do target acessado anteriormente a um estado de alta impedância antes de utilizar estas linhas para o target atual.
O protocolo PCI define uma versão do ciclo de escrita chamado Ciclo Especial.
Este ciclo é direcionado a todos os recursos disponíveis no barramento PCI, isto é, permite escrita simultânea em todos os dispositivos instalados neste barramento.
Logo, o Ciclo Especial ocorre no mesmo barramento PCI em que o master que está executando o ciclo está instalado.
Uma bridge não tem condições de propagar o Ciclo Especial entre dois barramentos.
Nenhum dispositivo PCI solicita o Ciclo Especial, logo o sinal TRDY&amp; não é ativado por dispositivos target e a duração do ciclo é controlada por o master do barramento via sinal IRDY&amp;.
Também, quando um Ciclo Especial é executado, nenhum dispositivo (master) pode solicitar o barramento.
Os sinais deste ciclo são mostrados na Figura 15.
Um Ciclo Especial inicia com o master do barramento ativando a linha de sinal Frame&amp;, colocando um comando válido em C/ BE&amp; e levando as linhas Ad a um nível estável.
Um ciclo de clock depois, aciona o sinal IRDY&amp; indicando que está pronto para este ciclo.
A colocação do sinal Frame&amp; em nível lógico &quot;1 «indica que a transação será no modo simples.
Esta atividade compreende a fase de endereçamento do Ciclo Especial.
Imediatamente após a fase de endereçamento vem a fase de dados.
Em e há o cálculo da paridade entre C&amp;A (command e address) e Be &amp; D (byte enable e data), respectivamente.
O ciclo termina com a desativação do sinal IRDY&amp; por o master.
O protocolo da fase de dados em modo simples ou burst para Ciclos Especiais é o mesmo que os de ciclos de acesso a memória ou I/ O para os mesmos dois modos de acesso.
Ao contrário de um ciclo de acesso, os sinais TRDY&amp;, DEVSEL&amp; e STOP&amp; permanecem desativados durante toda a fase de dados.
O mínimo período de um ciclo especial é de cinco períodos de clock.
Este Capítulo define e classifica módulos de hardware denominados cores.
Inclui também exemplos de cores que implementam o padrão PCI, descrito no Capítulo anterior.
O objetivo principal deste Capítulo é o de apresentar o desenvolvimento de um core, principal contribuição deste trabalho, para arquiteturas reconfiguráveis, a ser disponibilizado para aplicações que necessitem bom desempenho na interação hardware/ software.
Cada etapa do desenvolvimento do core está acompanhada de seu código em VHDL e de sua simulação.
A complexidade atual dos circuitos digitais induz os projetistas de hardware a utilizarem módulos pré-projetados, denominados cores.
Muitos cores atualmente existentes são protegidos por leis de propriedade intelectual e só podem ser adquiridos com um alto investimento financeiro.
Além de isto estes cores são vendidos em forma de &quot;caixa preta», muitas vezes não permitindo acesso a seu código fonte.
Sistemas baseados em cores apresentam benefícios tais como:
Redução do tempo de desenvolvimento de projetos por o reuso de propriedade intelectual, diminuição do risco de inserção de erros ao longo de o projeto e desenvolvimento de sistemas mais complexos.
Os cores podem ser classificados em 3 categorias:
Hard cores.
São otimizados para uma tecnologia específica e não podem ser modificados por o projetista.
Possuem a vantagem de garantir o desempenho do circuito.
Sua desvantagem é a de não permitir qualquer tipo de modificação ou personalização já que estes cores possuem um layout pré definido.
Este tipo de core é o que apresenta o melhor nível de proteção da propriedade intelectual, pois o core é uma descrição do layout, o que o torna praticamente impossível de reproduzir.
Firm cores.
São um misto de código fonte e netlist gerado para a tecnologia empregada (que muda de fabricante para fabricante).
Este tipo de core permite que a parte visível do código fonte seja modificada por o projetista de hardware, podendo assim, ser adaptada ao projeto.
Este tipo de core é o mais difundido hoje, pois representa um bom compromisso entre proteção da propriedade intelectual e desempenho.
Soft cores.
São descritos com o emprego de linguagens de descrição de hardware, como VHDL ou Verilog, oferecendo máxima flexibilidade e independência de tecnologia.
Os soft cores apresentam baixa proteção da propriedade intelectual por serem uma descrição aberta, além de raramente se poder garantir seus parâmetros de desempenho, pois o core não teve a síntese realizada, ou pelo menos não teve a síntese realizada no exato ambiente do usuário final.
Esta Seção apresenta um fluxo de projeto para cores.
Esta metodologia vem de encontro a permitir que sejam alcançados os benefícios que as arquiteturas reconfiguráveis propiciam na implementação de cores.
O sucesso da implementação de um core PCI em arquiteturas reconfiguráveis requer mais do que um dispositivo compatível para este fim.
Uma boa metodologia de projeto é igualmente importante para garantir o sucesso deste.
As restrições de temporização (timing) têm sido e continuarão a ser o maior desafio, ainda mais com a indústria desenvolvendo produtos PCI para barramento de 64 bits e clock a 66 MHz e freqüências ainda mais altas.
Um fluxo de projeto de um sistema digital mediante o emprego de cores consiste de 3 estágios fundamentais:
Captura do Projeto.
A Captura do Projeto consiste no projeto e síntese do nível mais alto de hierarquia do sistema, no projeto e síntese da aplicação do usuário e na integração deste com o core.
A simulação funcional, que é parte da Verificação do Projeto, é executada durante este estágio.
O core é tratado, nesta etapa, como uma caixa preta e não será um elemento sintetizável.
Um modelo funcional do core é provido para que a simulação funcional possa ser feita.
Implementação do Projeto.
O segundo estágio é o de Implementação do Projeto.
Durante este estágio, tarefas de síntese e tradução são executadas.
Em esta etapa é importante inserir restrições de timing referentes aos atrasos dos caminhos críticos, de forma a guiar o posicionamento e o roteamento.
Uma vez obtido o netlist da etapa de Captura do Projeto e o netlist do core unidos, executa- se o posicionamento e o roteamento do sistema, obtendo- se a descrição física do mesmo.
Verificação do Projeto.
O estágio final do fluxo de projeto é a Verificação do Projeto.
Este estágio consiste em duas etapas principais:
Verificação e Simulação.
Em a Verificação, a análise de timing estático determina se o projeto alcança o desempenho desejado.
A Simulação verifica o timing e a funcionalidade do sistema.
A análise de timing estático é executada para um levantamento de caminhos críticos que são restringidos por os parâmetros de desempenho do projeto.
Por exemplo, nas ferramentas Xilinx, a análise de timing estático de um projeto em FPGA pode ser feita com o uso de restrições A simulação é executada durante a Captura do Projeto, para verificar a funcionalidade com atrasos unitários (ou nulos), e após o posicionamento e roteamento para verificar a temporização de uma forma detalhada e mais precisa.
Estas etapas são, normalmente, adotadas em qualquer projeto envolvendo dispositivos reconfiguráveis.
No caso de um componente PCI operar em 33 MHz, o período de clock é de 30 ns, e pode variar ao longo de a operação.
Durante os 30 ns de período do clock, a especificação permite 10 ns de propagação do sinal.
Adicionado a esta propagação, também permite um clock skew (escorregamento de clock) de 2 ns entre dois componentes PCI.
Isto significa que pode haver uma perda de até 40% do tempo de ciclo resultante da distribuição do sinal.
Os 18 ns restantes são divididos entre duas restrições:
Clock-to-out e setup.
O valor de Tckq, que representa o valor máximo de clock-to-out, deve ser de 11 ns.
Isto significa que dados válidos devem estar disponíveis no pino de saída do dispositivo de acesso ao barramento PCI no máximo 11 ns depois de receber o sinal de clock.
O valor Tsu, que representa o valor máximo do tempo de setup, deve ser de 7 ns, isto é, dados válidos devem estar presentes pelo menos 7 ns antes da borda do clock.
A especificação PCI exige uma distribuição dos pinos do componente que implemente a interface PCI.
O comprimento do condutor do sinal desde o conector até o componente deve ser menor que 1.5», com exceção do sinal de clock que pode ser um pouco maior.
Todos estes requisitos são especificados para que os efeitos nas linhas de transmissão sejam controláveis, mas dificultam o projeto do circuito impresso e do projeto lógico no FPGA.
Deve- se ter o cuidado de, no momento de implementar o core no FPGA, especificar a posição relativa deste na periferia do circuito, junto aos pinos de entrada/ saída do core, de forma a minimizar o comprimento das linhas de conexão, e assim atender aos requisitos temporais.
Esta Seção apresenta quatro exemplos de cores PCI disponíveis comercialmente.
A Figura 18 apresenta a estrutura em diagrama de blocos do core PCI desenvolvido por a empresa Xilinx (LogiCORETM PCI XILINX).
Este core pode operar tanto como master ou target.
O LogiCORETM PCI é pré-implementado e testado em dispositivos FPGAs XilinxXC4000XLT.
A pinagem e distribuição interna dos CLBs são pré-definidas.
Caminhos críticos são controlados para garantir que os critérios de timing sejam sempre alcançados.
Isto reduz significativamente o tempo na implementação do bloco PCI do projeto.
Como resultado reduz significativamente o tempo global do projeto.
Este LogiCORETM é dividido em cinco blocos que são:
PCI I/ O Interface Block.
Este bloco provê a conexão física do core com o barramento PCI, incluindo todos os sinais, sincronização entre entrada/ saída e controle de saídas em alta impedância.
Parity Generator/Checker. Gera e verifica a paridade entre o barramento Ad (address/ data), entre C/ BE&amp; (command/ byte enable) e o sinal Par.
Sinaliza erros de paridade via PERR&amp; (parity error) e erros de endereçamento via SERR&amp; (system error).
A paridade em todas as transações de barramento deve ser par.
Target State Machine (Máquina de Estados do Target).
Este bloco gerência e controla as funções de um dispositivo target.
Initiator State Machine. Gerência e controla o barramento PCI nas funções de inicialização.
PCI Configuration Space.
Este bloco provê os primeiros 64 bytes do Configuration Space Header (CSH) para suportar a inicialização PNP.
Este espaço inclui os registradores Command, Status e 2 Base Address Register (Bars).
Os Bars são responsáveis por a implementação de espaços de endereçamento de memória ou de entrada/ saída (I/ O).
Cada Bar define o endereço base para a interface e permite ao software do sistema determinar a faixa de valores de endereços disponível à interface.
A Tabela 6 apresenta as características do LogiCORETM e a quantidade de pinos e CLBs restantes para diferentes versões dos FPGAs da família 4000 e a Tabela 7 apresenta as características da implementação do core para a família Virtex.
Tabela 7 ­ Implementação do LogiCORE em dispositivos Xilinx da família Virtex.
Especificação do Core Família de dispositivos Virtex Slices utilizados IOBs utilizados Freqüência de trabalho 0 ­ 66 MHz Barramentos de dados bi-direcionais Características utilizadas dos dispositivos Select IO Block Select RAM+ Boundary Scan (opcional) Dispositivos compatíveis Percentual de recursos utilizados Slices A empresa Altera (www_ Altera_ com) produz IP cores que implementam uma interface PCI, de entre eles o pci_ mt32 (PCI Master/ Target 32 Bits).
Empregando as famílias de dispositivos Altera® APEX 20K, FLEX 10K, e FLEX 8000, o pci_ mt32 suporta transações de configuração, de I/ O e de memória.
Devido a a alta densidade dos dispositivos FPGA da Altera empregados, os projetistas contam com muitos recursos de espaço após a implementação lógica da interface PCI.
O pci_ mt32 pode operar com freqüências de clock de 33 MHz ou 60 MHz, alcançando a vazão de dados de 132 MB/ s em 32 bits/ 33 MHz, até 528 MB/ s em 64 bits/ 66 MHz.
A Figura 19 mostra o diagrama funcional do pci_ mt32 da Altera, e a Tabela 8 apresenta as características dos diversos tipos de implementações de cores PCI com dispositivos Altera.
A empresa Altera permite ao projetista testar um modelo funcional de seus cores através de um &quot;test-drive», ou seja, uma pré-avaliação do core antes de adquirir- lo.
Os cores desenvolvidos por a inSilicon (www_ Insilicon_ com) são módulos RTL sintetizáveis que possibilitam a interface entre a aplicação do usuário e o barramento PCI.
A família de cores PCI inSilicon foram desenvolvidas para operar em 33 MHz e 66 MHz (32/64 bits).
Estas freqüências de operação são alcançadas através da combinação da síntese lógica, planta baixa, posicionamento, interconexão e verificação post layout.
A Powerful Logic Design -- PLD Applications (www_ Plda_ com) produz um core PCI master/ target para barramentos de 32/64-bit, 33/66-MHz.
Este core prevê também uma interface entre o barramento PCI e o projeto da aplicação final do usuário (back-end).
Este produto traz com si um conjunto de projetos para aplicações de usuário em VHDL, que o projetista poderá utilizar ou personalizar se assim necessitar.
As referências destes projetos incluem interfaces que utilizam a família FLEX 10K da Altera, empregando seus embedded array blocks (EABs) como buffer de SRAM ou como buffer FIFO.
A interface do core PCI master/ target da PLD Applications é totalmente parametrizável.
A Figura 21 apresenta um diagrama de blocos da interface PL D32/ 64-bit PCI master/ target, e a Tabela 9 traz dados referentes à utilização dos recursos dos FPGAs.
Notas: Compatibilidade com 66 MHz somente com dispositivos da linha FLEX 10KE-1.
Mesmo desempenho no modo 64 bits.
Esta Seção apresenta a contribuição maior desta dissertação, que é o projeto de um módulo de hardware reutilizável, soft core, para a implementação do padrão PCI.
A implementação deste core é feita utilizando- se a linguagem de descrição de hardware VHDL, validando- o através de simulação funcional.
A simulação testa os ciclos básicos de leitura e escrita, tanto em modo simples quanto em rajada.
A etapa seguinte deste trabalho é a validação do core num ambiente de prototipação composto de FPGA e barramento PCI.
O core desenvolvido é compatível com a especificação PCI para um dispositivo funcionar como target, para uma freqüência de 33 MHz e largura de barramento de 32 bits.
Optou- se por um dispositivo target com estas características devido a o fato de ser o que apresenta menor complexidade de operação e implementação no PCI.
A Figura 22 apresenta, em forma de diagrama de blocos genérico, a composição básica de um core PCI, representado por os conteúdos do retângulo pontilhado.
Esta estrutura é a adotada por o Core PCI desenvolvido.
Descrição dos módulos do Core PCI desenvolvido:
Máquina de Estados de Controle.
Um dispositivo PCI compatível pode, se assim for projetado, funcionar como master (assume o controle da transação do barramento:
Leitura, escrita ou acesso às configurações) ou como target (dispositivo alvo de alguma transação de barramento), ou até mesmo com as duas funções.
Se o dispositivo for sempre passivo, apenas a máquina de estados target necessita ser implementada.
Gerador e Verificador de Paridade.
Faz a geração e verificação da paridade sobre o barramento de endereços e dados, linhas de comando e os sinais de paridade gerados ao longo de as transferências de dados numa transação de barramento.
Em caso de erros de paridade este bloco os sinaliza.
Registradores do Espaço de Configuração. Este bloco provê os registradores do Configuration Space Header (CSH).
Em este espaço, estão informações necessárias para a inicialização e configuração plug-and-play.
Fazem parte destas informações comandos, status e os registradores de endereços base (Base Address Register Bar).
O Bar indica como implementar espaços de memória ou espaços de endereçamento de I/ O no host.
Também é função deste módulo realizar a comparação dos endereços de dispositivo com o endereço colocado no barramento de endereços.
A máquina de estados de controle do core operando como target está ilustrada na Figura 23.
Esta máquina tem por função gerar os sinas de controle para ciclos de leitura, escrita e espera.
O target captura os sinais do barramento para determinar quando o master está requerendo um acesso à configuração ou entrada/ saída de dados.
Este é o estado inicial.
Quando uma transação inicia, o endereço presente no barramento é comparado com o espaço de endereços (contidos nos Bar) do dispositivo PCI.
Se este endereço estiver contido neste espaço, o target vai para o estado WRITE_ DATA (S4) se o comando enviado por o master for de escrita ou para READ1 (S2) se o comando for de leitura (C_ BE $= C_ IO_ READ and Hit $= '1' or C_ BE $= C_ CONFIGURATION_ READ and IDSEL $= '1').
Se o endereço não for igual ao do dispositivo vai para o estado BUSY (S5).
Este estado é necessário para que seja feita uma inversão do barramento de dados e endereços.
Em este estado o master envia dados para o target (escreve).
Enquanto o sinal de Frame estiver ativo (nível baixo) o target é mantido no estado de escrita, caracterizando uma transferência de dados em modo burst.
A o término do ciclo de escrita o dispositivo vai para o estado IDLE.
Em este estado o master solicita dados para o target (lê).
Enquanto o sinal de Frame estiver ativo (nível baixo) o target é mantido no estado de leitura, caracterizando uma transferência de dados em modo burst.
De este estado, o target automaticamente retorna ao estado IDLE.
Enquanto uma transação está acontecendo (Frame ativo), o dispositivo que não foi selecionado por o master mantém- se neste estado.
Quando a transação se completar (Frame desativado), o target retorna ao estado IDLE para aguardar por uma fase de endereçamento da próxima transação.
O código em VHDL, referente a a máquina de estados do target é o seguinte:
A informação &quot;3 «na linha C/ BE (C_ IO_ WRITE) (1), associada à seleção do dispositivo target com endereço &quot;00000010», gera a troca de estado.
Após o dado ser recebido por o target, a máquina de estados volta para S1.
O barramento de dados/ endereço quando não é acionado nem por o target nem por o master fica em nível lógico` 1 'devido a a um resistor de pull-up, ou seja,` 1' fraco.
Este nível é representado por` H'na simulação.
A informação &quot;2 «na linha C/ BE (C_ IO_ READ) (1), associada à seleção do dispositivo target com endereço &quot;00000010», gera, inicialmente, a troca de estado de S1 para o S2 (necessário para a inversão da direção dos dados no barramento Ad) (2).
Em a próxima descida do sinal de clock, a máquina de estados chega a S3.
Após o dado ser recebido por o master, a máquina de estados volta para S1.
Como não houve um casamento entre o endereço colocado por o master em Ad, com o endereço interno do dispositivo target, o sinal Hit não foi ativado.
Sendo assim, a máquina de estados vai para o estado BUSY até que a transação de barramento se encerre.
Em toda transação de barramento PCI há geração e verificação de paridade entre as linhas Ad e C/ BE, sendo que a paridade deve ser par.
O bit de paridade é sinalizado por o sinal Par.
A primeira fase de uma transação de barramento chama- se de fase de endereçamento, em a qual o master coloca um endereço nas linhas Ad e um comando nas linhas C/ BE.
Um ciclo de clock depois, o master coloca na linha Par o bit de paridade correspondente, calculado entre Ad e C/ BE.
Este atraso de um ciclo de clock deve- se ao fato de que o target precisa calcular a paridade entre Ad e C/ BE recebidos e depois receber o sinal Par para poder comparar com a paridade que calculou.
Se o bit recebido na linha Par for igual ao da paridade calculada por o target, a linha PERR&amp; (parity error) é mantida desativada, isto é, em nível lógico 1.
A segunda fase de uma transação de barramento é a fase de dados.
A partir de esta fase, a paridade é calculada entre os dados colocados em Ad e os sinais de byte enable colocados em C/ BE.
Para cada dado e byte enable, a paridade é calculada e um sinal Par é gerado, seja em ciclos de leitura ou escrita.
O código em VHDL, referente a a máquina de estados do bloco gerador/ verificador de paridade é o seguinte:
par16 par8 par4 par0 parout process (CLK) begin process (CLK) begin if (par_ interno/ $= PAR and eant $= WRITE_ DATA) then if) then As Figuras seguintes apresentam os sinais de duas simulações em as quais se verificam duas situações diferentes com relação a o cálculo de paridade e a sinalização de um eventual erro de paridade sinalizado por o sinal PERR&amp; (parity-- error).
A Figura 27 mostra um ciclo de leitura onde, em, está presente o valor do bit de paridade, determinado por o cálculo da paridade entre as informações de endereço e comando (A &amp; C) colocados por o master no ciclo anterior (fase de endereçamento).
O valor do bit de paridade presente em, foi determinado por o cálculo da paridade entre as informações presentes nas linhas de dados e habilitação de byte (D&amp; BE), um ciclo após estas informações terem sido colocadas nestas linhas (fase de dados), também por o master.
Observa- se que a linha PERR&amp;, que normalmente se encontra em nível` 1 fraco' (devido a um resistor de pull-up), em (3) teve seu nível lógico levado a a` 0', sinalizando um erro de paridade ocorrido entre D&amp;BE.
A Figura 28 mostra um ciclo de escrita onde, em, está presente o valor do bit de paridade, determinado por o cálculo da paridade entre as informações de endereço e comando (A &amp; C) colocados por o master no ciclo anterior (fase de endereçamento).
O valor do bit de paridade presente em (calculado após a inversão do barramento), foi determinado por o cálculo da paridade entre as informações presentes nas linhas de dados e habilitação de byte (D&amp; BE), um ciclo após estas informações terem sido colocadas nestas linhas (fase de dados), também por o master.
Observa- se que a linha PERR&amp;, que normalmente se encontra em nível` 1 fraco' (devido a um resistor de pull-up), em nenhum momento teve seu nível lógico levado a a` 0', caracterizando uma transação de barramento sem erro de paridade.
Este bloco provê os registradores do Configuration Space Header (CSH).
A Figura 4, da Página 14, apresenta a estrutura dos primeiros 64 bytes dos registradores de configuração.
O PCI reconhece três diferentes espaços de endereços:
Endereços de memória (memory address), endereços de I/ O (I/ O address) e memória de configuração (configuration memory).
Os dois primeiros, como nos microprocessadores da Intel, são para acessos normais de dados.
O terceiro, que fica localizado em todas as placas de extensão (add-on cards) e outros componentes conectados ao barramento PCI, contém as configurações do dispositivo ajustadas por a PCI BIOS.
O código em VHDL do banco de registradores que compõe o Espaço de Configuração do Core PCI desenvolvido é o seguinte:
IO_ space_ control PERR_ response SERR_ control data_ parity_ status sign_ SERR_ status detected_ PERR_ status if (ESTADO $= WRITE_ DATA) then IO_ space_ control PERR_ response SERR_ control data_ parity_ status sign_ SERR_ status detected_ PERR_ status Ad_ TEMP '0'&amp; PERR_ response&amp; &quot;00000&quot;&amp; IO_ space_ control&amp; &quot;0000000&quot;&amp; SERR_ control&amp; &quot;00000000&quot;&amp; detected_ PERR_ status&amp; sign_ SERR_ status&amp; &quot;00000&quot;&amp; data_ parity_ status;
Em o banco de registradores do espaço de configuração existem registradores de leitura/ escrita e somente leitura.
Os registradores só de leitura são implementados com constantes no código VHDL.
Se num ciclo de leitura um destes registradores for lido, será retornada a constante correspondente a ele.
Já os registradores de leitura/ escrita são implementados como registradores convencionais.
Eles recebem um valor inicial no reset.
Observa- se que BAR0 e BAR1 recebem uma codificação no reset que significa que estão alocando 128 bytes de espaço de I/ O.
Todos os valores do espaço de configuração estão armazenados em formato little-endian.
Para que seja possível utilizar operadores relacionais em VHDL, os valores são convertidos para big-endian.
Esta conversão se dá nos sinais BAR0BE e BAR1BE.
A Figura 29 apresenta uma simulação de dois ciclos de escrita no espaço de configuração a e a).
Ambos iniciam com o sinal Frame&amp; sendo ativado no mesmo instante em que é colocado o comando C_ CONFIGURATION_ WRITE (B) nas linhas C/ BE&amp;.
As linhas Ad recebem um conjunto de bits que seleciona qual registador do dispositivo será escrito.
O dispositivo é selecionado por o sinal IDSEL, pois ainda não foi configurado um endereço para o dispositivo se comunicar com o host.
Os bits 7 a 2 representam o registrador do espaço de configuração que será escrito enquanto que os bits 10 a 8 especificam qual a função dentro de o dispositivo target (o dispositivo pode ter várias funções, cada uma com seu próprio espaço de configuração).
Entre os bits 31 a 11 está a linha IDSEL que está sendo utilizada para acessar o dispositivo target.
O dado colocado nas linhas Ad em será escrito no registrador BAR0, já o dado colocado em será escrito no BAR1.
Este valor indica o endereço inicial deste espaço de endereçamento do dispositivo.
Pode- se ter até 8 espaços de endereçamento, um para cada Bar, que podem ser de I/ O ou I/ O mapeado em memória.
Em o reset os registradores Bar devem ser inicializados por o dispositivo, para um valor que indica o tipo de I/ O que o dispositivo está requisitando e a quantidade de espaço.
O host deve se encarregar de ler os registradores Bar do dispositivo antes de escrever- los para saber estas informações.
As Subseções seguintes apresentam os resultados de simulação do soft core implementado.
Este core está completamente descrito em VHDL, contendo a máquina de estados de controle (target), o bloco de geração/ verificação de paridade, os registradores de configuração e uma pequena aplicação back-end.
A Figura 30 apresenta os sinais durante este ciclo.
Um ciclo de acesso simples de leitura inicia quando o master do barramento PCI ativa o sinal Frame&amp;, colocando um tipo de comando (COMMAND) válido nas linhas C/ BE&amp; e um endereço válido nas linhas Ad.
Esta fase denomina- se fase de endereçamento (ADDRESS PHASE) do ciclo de acesso.
Completada esta fase o master ativa o sinal IRDY&amp; (initiator ready) (2) indicando que está pronto para começar a ler os dados do target.
O dispositivo que contiver o endereço colocado por o master em Ad, indica que foi selecionado ativando o sinal DEVSEL&amp; (device selected).
Imediatamente após a fase de endereçamento vem a fase de dados (Data PHASE).
Em o início desta fase o master do barramento habilita um subconjunto de bytes válidos por o sinal C/ BE&amp; e coloca as linhas Ad em alta impedância, pois o barramento deve ter sua direção invertida (o master enviou o endereço e o target enviará seus dados ­ barramento bidirecional).
Quando o target estiver pronto para enviar os dados ele ativa o sinal TRDY&amp; (target ready) (3) e os dados são enviados.
Este ciclo termina com o master desativando o sinal IRDY&amp; e os sinais de controle são removidos por o target.
Observar que ao final do ciclo de leitura é calculada a paridade (sinal Par).
Os sinais deste ciclo são mostrados na Figura 31.
Um ciclo de acesso de escrita simples inicia similarmente ao ciclo de leitura simples.
Uma transação de escrita é similar à transação de leitura, exceto que não há a necessidade da inversão do barramento, durando um ciclo de clock a menos.
Imediatamente após a fase de endereçamento vem a fase de dados.
Em o início da fase de dados, o master habilita um subconjunto de bytes válidos em C/ BE&amp; e aciona as linhas Ad.
Um dado válido nem sempre está presente a cada início de uma fase de dados, pois o target pode não estar pronto.
Em este caso são inseridos wait states por o target.
Esta característica ainda não está implementada.
A fase final do ciclo de escrita simples encerra- se com a desativação do sinal IRDY&amp; e os sinais de controle são removidos.
IRDY&amp; é desativado um ciclo de clock após o sinal Frame&amp; ter sido desativado.
O que diferência um acesso no modo simples do acesso no modo burst é o tempo de permanência do sinal Frame&amp; ativado.
IRDY&amp; um período de clock após o sinal Frame&amp; ter sido desativado.
Em o ciclo ilustrado na Figura 32, 9 palavras com 32 bits de largura são transferidos.
A transferência segue até a desativação do sinal IRDY&amp;.
Em este ciclo, o sinal C/ BE&amp; $ ` 0' indica que o byte menos significativo de cada palavra contém dado válido.
A Figura 33 mostra os sinais para um ciclo de leitura em modo burst.
O modo burst permite que o master acesse o target através de uma seqüência de micro acessos.
O ciclo inicia quando o master ativa o sinal Frame&amp;, coloca uma informação de controle do ciclo em C/ BE&amp; e um endereço válido nas linhas de sinal Ad.
Este endereço estabelece o endereço base para todos os micro acessos.
Imediatamente após a fase de endereçamento, as linhas Ad são colocadas em alta impedância para a inversão do sentido do fluxo de dados no barramento Ad.
Logo após, vem a fase de dados, quando o target envia os dados ao master.
O ciclo de leitura em modo burst tem o seu término quando o sinal IRDY&amp; é desativado um ciclo de clock após o sinal Frame&amp; ter sido desativado.
O que diferência um acesso no modo simples do acesso no modo burst é o tempo de permanência do sinal Frame&amp; ativado.
IRDY&amp; um período de clock após o sinal Frame&amp; ter sido desativado.
Em o total, 9 palavras de 32 bits são transferidas.
Conforme ilustrado no Anexo I, o circuito &quot;corePCI «contém, além de os módulos especificados nas Seções anteriores, uma aplicação back-end.
Os resultados da síntese conterão a área deste módulo.
Xilinx. LUT RAM é um mecanismo que permite a utilização das LUTs, que compõem os CLBs, como memória RAM.
Cada LUT RAM de 4 entradas é capaz de armazenar 16 bits, e cada CLB contém 2 LUTs de 4 entradas.
Logo, cada CLB pode armazenar 32 bits, o que é mais eficiente do que implementar registradores utilizando process com clock na lista de sensitividade, onde 1 bit utiliza um flip-flop do CLB, chegando a um máximo de 2 bits de registrador por CLB.
O código abaixo apresenta uma parte da aplicação back-end.
Em este código é apresentado o componente RAM 32 x1S, que é uma memória de 32 bits, com largura de 1 bit e porta simples.
Esta bits.
O primeiro conjunto de registradores é apresentado neste código (laço for-generate).
Logo o consumo de área desta aplicação é de 64 CLBs.
Os primeiros resultados de síntese resultaram num consumo excessivo de área, quando comparada à referência Xilinx, que é de 178-308 blocos lógicos.
Este consumo ficou em 307 blocos lógicos.
Com o auxílio da ferramenta de planta baixa (floorplanning), observou- se que a maior parcela de área consumida era na região dos registradores do espaço de configuração.
Com esta restrição preliminar, a freqüência de operação passou de 16 MHz para 24 MHz (41.832 ns de período).
Esta freqüência ainda é insuficiente para o padrão PCI, e mostra claramente a dificuldade em implementar este tipo de norma em FPGAs, apesar de que a especificação 32 bits/ 33 MHz permite operar entre 0 e 33 MHz.
Para que a freqüência passe para 33 MHz, serão necessárias mais iterações com a ferramenta de floorplanning, impondo também restrições na síntese lógica.
Cabe ressaltar que esta implementação preliminar não fixou a posição dos pinos de entrada e saída.
Uma fixação cuidadosa destes pinos contribuirá também para aumentar a freqüência de funcionamento.
Os resultados apresentados na Tabela 10 foram obtidos após a imposição de restrições de timing.
Com estas restrições, a freqüência de operação do core chegou a 40,783 MHz, acima de os 33 MHz esperados.
As Figura 35 e Figura 36 mostram, respectivamente, os resultados da distribuição dos blocos lógicos no FPGA e a distribuição das linhas de clock para que a restrição temporal fosse alcançada.
Mesmo que haja escorregamento do sinal de clock ao longo de a estrutura, os componentes dispostos numa mesma região vertical receberão o sinal de clock ao mesmo tempo, isto é, com o mesmo atraso.
Esta técnica de distribuição aumenta o desempenho em velocidade do circuito.
Os Capítulos anteriores detalharam o padrão de barramento PCI e a implementação de um core para operar conforme as normas deste padrão.
Este Capítulo tem por objetivo mostrar o desenvolvimento de aplicações em FPGAs comunicando- se com um computador host, utilizando para tal fim um core PCI.
O core utilizado para este fim é o core da empresa XILINX -- Xilinx PCI32 LogiCORE, do tipo firm core, descrito em formato EDIF.
O core desenvolvido não é utilizado neste Capítulo devido a o fato da placa empregada não permitir em seu uso outro core que não seja o pertencente ao sistema de hardware/ software desenvolvido por o fabricante.
Arquitetura da Hardware Object Technology ­ H_ O_ T_ II-XL A placa de prototipação que é empregada para a implementação de sistemas computacionais compostos por parte em hardware e parte em software é a HOT II-XL.
A comunicação entre a parte hardware e a parte software é feita por o barramento PCI.
A comunicação entre a parte software e o barramento PCI é provida por um driver de comunicação e a comunicação entre a parte hardware e o barramento PCI é feito por um core, disponibilizado juntamente com a plataforma de prototipação.
A Figura 37 ilustra a arquitetura da placa de prototipação HOT II-XL.
Os principais componentes desta placa de prototipação são:
Configuration Flash. Guarda de forma não volátil configurações para o FPGA.
Configuration Cache. Armazena configurações para o FPGA em memória SRAM.
Logo, se o sistema for reinicializado perde- se as configurações lá armazenadas.
Configuration Manager. Gerência a configuração do FPGA.
A reconfiguração pode ser feita partindo de uma configuração armazenada na flash, ou na cache de configuração.
O CPLD XC95108 é responsável por este gerenciamento RAM Bank A and Bank B. Dois bancos de memória para serem usados por a aplicação do usuário.
FPGA. Dispositivo XC4062XL.
Em este dispositivo é carregada a aplicação do usuário (parte hardware) e o core PCI.
A interface da aplicação do usuário com o core é descrita posteriormente.
Clock Programável. Freqüência programável por o usuário no intervalo entre 360 kHz e 100 MHz.
A comunicação entre o host (PC) e a placa HOT II-XL é feita através de uma Application Program Interface ­ API.
Esta API é uma biblioteca de objetos (e métodos) de comunicação, permitindo reconfigurar a placa e comunicar- se com o circuito implementado na mesma.
A comunicação entre a placa HOT II-XL e o host (PC) é feita através de uma biblioteca do símbolo deste para ser utilizado nos projetos no sistema de CAD Foundation.
Esta biblioteca realiza, também, a comunicação da aplicação do usuário (dispositivo back-end) com o barramento PCI e as funções da placa (basicamente bancos de RAM).
Uma importante característica deste ambiente de prototipação é a possibilidade de armazenar diferentes circuitos de configuração numa memória flash.
Até três diferentes configurações são armazenadas simultaneamente, permitindo carregar circuitos com funções diferentes durante a execução de uma dada aplicação.
A Figura 39 ilustra o modelo de execução hardware/ software.
Em este modelo, a execução da parte de o sistema que é crítica em termos de desempenho, é implementada em hardware (FPGA), e a parte não crítica, ou que requer uma maior quantidade de entrada/ saída, é implementada em software (processador do host).
O maior gargalo deste ambiente de prototipação é o tempo gasto para transmitir dados entre o processador e o dispositivo, o qual pode ser superior ao ganho de desempenho estimado.
Em a parte software utiliza- se programas escritos em linguagem C+, com funções para acessar os recursos da placa de prototipação (FPGA, memória RAM, cache de configurações, flash).
Essas funções pertencem a uma API proprietária da plataforma HOT II-XL.
A parte hardware é composta por o hardware do usuário (back-end) e um módulo de comunicação com o barramento -- biblioteca de hardware.
A HOT II-XL possibilita a reconfiguração do FPGA (PCI core+ back-end) através de funções da API, escritas em C+.
Esta API permite comunicação, através de uma interface de alto nível, com o core implementado no FPGA.
Desta forma é possível fazer com que o hardware comunique- se com o software sem a necessidade de se programar um driver de dispositivo.
Para carregar o bitstream contendo a configuração do FPGA a partir de um programa executável, é necessário que o bitstream seja convertido para um formato denominado de run-time (que gera um arquivo com extensão.
Hot). Este formato é chamado de Hardware Object.
Desta forma, ao gerarmos o executável, este conterá o código C+ compilado e o bitstream num único arquivo.
Toda interface com a placa é feita através de uma classe C+ denominada Hot2.
O construtor do objeto é responsável por a comunicação com o driver da placa.
Para verificar se o objeto foi corretamente inicializado utiliza- se o método CheckBoard, da classe HOT II.
Se todos os recursos foram inicializados corretamente, é retornada a constante EHOT2_ SUCCESS.
Os principais métodos da classe Hot2 são:
Reset: Inicializa a placa para a configuração n..
Se n for omitido, o default é 0.
LoadCache (s_ HOTConfig* config, word location):
Carrega uma configuração (contida na estrutura config), para a posição especificada da cache de configuração.
RtrCache: Reconfigura o FPGA da placa com a configuração contida no slot n da cache.
Write (word addr, word data):
Escreve um dado na placa num dado endereço (ver na Tabela 11 os endereços dos periféricos da placa).
A comunicação entre o dispositivo back-end e o barramento PCI é feita através do core PCI.
O acesso a este core é feito a partir de um símbolo no editor de esquemáticos.
Não há forma direta de se trabalhar com este core a partir de VHDL.
A Tabela 12 apresenta os sinais aos quais o usuário tem acesso.
A HOT II-XL contém 4 MB de memória SRAM, organizado em dois bancos de memória independentes:
Banco A e Banco B, cada um com 2 MB (com largura de 32 bits).
O acesso a estes bancos de memória se dá da seguinte maneira:
O sinal MA_ ON habilita a memória.
Deve estar em` 1' para que se possa realizar operações com a memória.
Esse sinal interfere na comunicação com o host.
Se MA_ ON estiver em` 0' o driver da HOT vai colocar num buffer os valores a serem escritos na memória.
Os sinais MA_ OE e MA_ WE definem se a operação com a memória será de leitura ou escrita.
Quando MA_ OE for` 0 'e MA_ WE for` 1' os dados que estiverem em MAD_ OUT serão escritos no endereço selecionado por MAD_ ADR.
Quando MA_ OE for` 1 'e MA_ WE for` 0' MAD_ IN receberá da memória o valor armazenado no endereço selecionado por MAD_ ADR.
O primeiro passo para implementar uma aplicação na plataforma de prototipação HOT IIXL é a criação da aplicação do usuário (dispositivo back-end).
Para isso há no sistema de desenvolvimento um projeto padrão, que é utilizado como modelo.
Este projeto padrão contém a interface externa que da aplicação do usuário deve possuir.
A Figura 40 ilustra o código VHDL que é utilizado como modelo para o desenvolvimento da aplicação do usuário.
O conjunto de pinos externos deve corresponder ao conjunto de sinais descritos na Tabela (posicionamento e roteamento).
A única etapa realizada é a síntese lógica.
O resultado desta síntese é um netlist em formato EDIF, que é posteriormente utilizado, juntamente com o core PCI para a síntese física.
Comparando- se este fluxo de projeto com o fluxo apresentado na Seção 3.2, observa- se que o ambiente de prototipação não dispõe de um modelo funcional do core para simulação, o que dificulta a validação das aplicações desenvolvidas.
Tipicamente, o usuário descreve sua aplicação sem preocupar- se com o core PCI, validando- a por simulação.
Uma vez sua aplicação desenvolvida, é feita a integração aos pinos do core.
Uma vez obtido o netlist EDIF, deve- se copiar este netlist para o local onde se encontra o netlist do core, o esquemático que une os netlists (usuário e core) e o arquivo contento as restrições de temporização e posicionamento do core no FPGA.
Uma vez obtido um diretório de projeto contendo os dois netlists e o arquivo com as restrições, procede- se à ultima etapa no fluxo da síntese de hardware, que é a síntese física.
É importante comentar que o arquivo de restrições contém três partes principais, localização dos pinos de entrada e saída na periferia do FPGA, restrições de temporização e posicionamento dos elementos do core no interior do FPGA.
Este posicionamento é importante para que o circuito alcance o desempenho esperado, que é a freqüência de operação em 33 MHz.
O arquivo resultante da síntese física, em formato binário padrão XILINX (arquivo com extensão.
Bit), é convertido para um formato denominado run-time.
Uma vez que o arquivo de configuração do FPGA está em formato run-time, é possível utilizar- lo num programa (parte de software).
O ambiente Microsoft Visual C+ 6.0 é exigido por a plataforma HOT II-XL.
O código C+ apresentado a seguir demonstra a interação hardware/ software com a placa HOT II-XL.
A aplicação reconfigura o FPGA da HOT II-XL, e a seguir faz algumas operações de leitura e escrita, tanto nos bancos de memória quanto no espaço de endereçamento do usuário.
Uma vez o código C+ corretamente descrito, compila- se este, gerando- se um executável.
Conforme visto no exemplo acima, o executável carrega o bitstream.
Há um segundo método de configuração, que é compilar o fonte C+ juntamente com o bitstream (como um header), gerandose um arquivo executável único.
A Figura 43 apresenta os relatórios de utilização de área e freqüência de operação para uma aplicação do usuário utilizando o core Xilinx (teste de acesso à memória RAM).
O consumo total de área foi de 471 CLBs, mostrando que este core tem um pequeno consumo de área, deixando a maior parte da área de lógica programável para a aplicação do usuário.
Outro ponto importante é a freqüência de operação que foi atendida, 33 MHz.
Para que esta restrição de freqüência seja atendida, a síntese deve ter esforço máximo em todas as etapas, podendo consumir até 20 minutos de processamento.
Este trabalho detalhou o funcionamento e as operações do barramento PCI, assim como mostrou a importância da utilização de cores em sistemas digitais complexos.
A principal contribuição deste trabalho foi o desenvolvimento de um soft core VHDL para possibilitar aos projetistas de hardware um meio de acesso ao barramento PCI a partir de aplicações target.
Este trabalho foi um excelente meio de aprimorar o uso das técnicas de projeto de sistemas digitais com dispositivos programáveis, implicando no uso de tecnologia no estado da arte para projeto, validação funcional, validação de temporização e validação de protótipo.
O soft core desenvolvido está funcionalmente de acordo com o padrão estabelecido por a norma do barramento PCI e resultados preliminares indicam um baixo consumo de área, sendo possível através da inserção de restrições de timing alcançar 33 MHz (obteve- se 24 MHz apenas restringindo a posição dos blocos, sem impor freqüência de operação).
Os resultados obtidos após a imposição de restrições de timing, a freqüência de operação do core chegou a 40,783 MHz, acima de os 33 MHz esperados.
No decorrer de o trabalho também foi utilizado um ambiente de prototipação comercial (HOT II-XL), contendo um firm core.
A partir de o uso deste ambiente, foram observadas carências existentes em termos de software para projeto de sistemas digitais que utilizam cores.
O ambiente utilizado, um dos poucos disponíveis comercialmente, não tem um ambiente integrado de software nem o modelo funcional de simulação.
O projeto deve ser integrado ao barramento PCI, supondo- se correta a descrição fornecida por o fabricante.
Outra lição oriunda da utilização deste ambiente é a dificuldade em se obter o atendimento das restrições temporais (o tempo de síntese é muito grande).
Como o core desenvolvido é um soft core, não há a necessidade de um modelo funcional de simulação.
A aplicação do usuário pode ser simulada diretamente com o core, sendo necessário apenas desenvolver o test-bench.
A seguir relacionam- se os trabalhos que podem ser feitos como continuidade desta Dissertação:
A validação e a implementação do core e a aplicação do usuário numa plataforma de prototipação.
Esta etapa necessita de uma plataforma flexível, que permita experimentos com diversos cores, o que não é o caso da HOT-II.
É necessário adquirir, ou desenvolver, tal ferramenta.
Ampliar a máquina de estados para que o core possa operar como master do barramento.
Desenvolver uma interface simples entre o core e a aplicação back-end, disponibilizando ao projetista os sinais necessários à conexão da sua aplicação ao core.
Isto corresponde a definir uma interface semelhante à Figura 41.
O ambiente de desenvolvimento deve ser todo em VHDL, sem utilização de esquemáticos, para uma maior facilidade de uso por parte de o usuário, já que linguagens de descrição de hardware permitem aumentar o nível de abstração de projeto.
Desenvolver drivers em software para acesso ao dispositivo PCI.
Este trabalho já foi iniciado e será desenvolvido no sistema operacional Microsoft Windows NT 4.
0, devido a sua disponibilidade e ampla utilização, além de uma certa facilidade de obtenção de documentação sobre o mesmo.
Para a realização desta tarefa está sendo utilizado o sistema denominado Windows NT Driver Development Kit ­ DDK, que possui as ferramentas necessárias para a criação de drivers, contendo desde bibliotecas até ferramentas de montagem de drivers, depuradores e gerenciadores de kernel.
