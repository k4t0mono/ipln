Atualmente, diversos serviços são disponibilizados por a Internet e há uma crescente demanda por estas aplicações.
Considerando que a Internet não é uma rede segura, a confidencialidade de informações que circulam na rede é um fator de importância cada vez maior.
Visando solucionar este problema, várias técnicas de segurança surgiram e cada empresa as adotou em suas políticas de uma forma diferente.
Porém com a tendência de adoção do modelo de Arquiteturas Orientadas a Serviços, diferentes serviços com diferentes políticas de segurança necessitaram ser agrupados para que pudessem trabalhar em conjunto, o que acabou dificultando a criação de uma aplicação que segue um determinado padrão.
Uma nova abordagem se faz necessária para facilitar a coexistência destas técnicas de segurança de uma forma produtiva.
Assim, este trabalho apresenta um modelo voltado ao tratamento automático de características de segurança para serviços ordenados em Arquiteturas Orientadas a Serviço.
Este modelo atua como um sistema intermediário capaz de &quot;traduzir «as técnicas de segurança para um formato determinado.
Com base neste modelo é apresentado um protótipo capaz de tratar automaticamente diferentes algoritmos de criptografia assimétrica, entre eles RSA, DSA e ECDSA.
O objetivo do trabalho é testar a efetividade do modelo por meio de um estudo de caso, apresentando uma situação que este pode ser adotado por aplicações reais.
Palavras-chave: Web Service, Segurança, Proxy, Soa.
Sistemas computacionais estão se tornando cada vez mais indispensáveis à sociedade.
Há várias décadas estes sistemas são responsáveis por atividades importantes como sistemas bancários e de gerenciamento de empresas.
Com a expansão do uso da Internet, permitir que muitas outras aplicações como estas estejam acessíveis de qualquer lugar é uma necessidade e, portanto uma tendência.
O mercado de software tem realmente seguido a tendência, disponiblizando uma grande variedade de aplicações por a Internet.
Entre as várias tecnologias existentes para a composição deste tipo de aplicação, Web Services tem se consolidado como um padrão utilizado por um grande número de aplicações disponíveis na rede.
Porém, a migração de aplicações para a Internet traz alguns problemas, entre eles está a segurança.
Para utilizar determinados serviços é necessário efetuar cadastros, pagar com cartões de crédito e estas informações não podem ser de domínio público.
Para contornar este problema foram criadas várias técnicas de segurança, como diferentes formas de autenticação e de criptografia.
As aplicações disponíveis através da Internet podem ser combinadas de diferentes formas, permitindo seu trabalho em conjunto e apresentando o conceito de Arquiteturas Orientadas a Serviço que é utilizado em Web Services.
Por exemplo, um sistema de pagamento num Web Site de compras se comunica com o sistema de uma operadora de cartões de crédito, ambos os lados da operação devem codificar os dados utilizando o mesmo algoritmo de criptografia.
Caso o algoritmo não seja o mesmo, não é possível que os dados sejam decodificados e devidamente compreendidos, impossibilitando desta forma a comunicação entre estes serviços.
Com base nas incompatibilidades entre algoritmos de criptografia para Web Services, este trabalho tem por objetivo propor um modelo que permita a integração de serviços, mesmo que possuam diferentes características de criptografia, de modo a tornar possível a comunicação entre eles de forma transparente, sem a necessidade de alteração.
Para a realização desta tarefa, foi conduzido um estudo de várias tecnologias relacionadas com segurança para Web Services, bem como um levantamento do estado-da-arte nesta área de pesquisa.
Em a análise dos trabalhos relacionados, foram levantadas muitas informações relevantes para a definição e andamento desta pesquisa.
As principais necessidades e características encontradas com relação a segurança de Web Services foram:
Interoperabilidade entre padrões já existentes;
Desacoplamento dos requisitos de segurança tanto do cliente quanto do servidor;
Um middleware auto-customizável foi a solução encontrada em diferentes casos para a interoperabilidade e também poderia ser aplicado a esta situação;
E a falta de segurança na composição de serviços como um todo.
O estudo realizado indicou principalmente, que a flexibilidade do modelo Web Services, uma das suas principais vantagens, é uma das suas desvantagens também, isto se aplica ao modelo como um todo, porém no campo da segurança ela permite que uma variedade muito grande de técnicas sejam utilizadas de uma forma muito variada.
Isto acaba por dificultar o processo de implementação de aplicações compostas por vários serviços.
Visando manter a flexibilidade proposta por o modelo Web Services, permitindo que cada serviço defina as políticas de segurança da forma que desejar, foi proposto um modelo denominado Proxy--Based Security (PBSec), que prevê a conversão das políticas de segurança para apenas um formato, ele efetua esta conversão através de um serviço intermediário que é executado entre o cliente e o servidor.
A partir de o PBSec, foi implementado um protótipo que prevê o tratamento automático de algoritmos de criptografia, permitindo que mesmo que a aplicação cliente não preveja o uso de determinado algoritmo o uso do serviço desejado seja possível.
Para testar a efetividade do modelo e do protótipo foi efetuado um estudo de caso, em que uma aplicação orientada a serviço foi desenvolvida utilizando serviços com diferentes políticas de segurança.
Considerando as etapas de pesquisa realizadas, este trabalho está dividido em 5 capítulos.
Em o Capítulo 2 é feita uma conceituação das tecnologias que serão abordadas.
O feitas as conclusões e apresentados os trabalhos futuros.
Este capítulo apresenta uma descrição dos principais conceitos e trabalhos relacionados com a proposta desta dissertação.
A Seção 2.1 descreve o conceito de Arquiteturas Orientadas a Serviço;
Em a Seção 2.2 é descrita a tecnologia Web Services e as especificações das tecnologias que a compõem;
A Seção 2.3 descreve as tecnologias de segurança envolvidas neste trabalho;
A Seção 2.4 lista e comenta os trabalhos relacionados e, finalizando este capítulo, são feitas as considerações finais relacionando as tecnologias com a pesquisa a ser apresentada.
Arquitetura Orientada a Serviço Soa (Service-Oriented Architecture) é um tipo de arquitetura de software que utiliza processos de negócio e distribui funções em forma de serviços.
Esta arquitetura fornece um conjunto de princípios que regem os conceitos utilizados durante as fases de desenvolvimento de sistemas e integração, tornando o resultado um pacote de funcionalidades baseadas em serviços interoperáveis.
Soa é outra forma de integração entre módulos de software, ao invés de definir uma API, é definida uma interface que permite estabelecer a comunicação entre serviços e clientes.
As principais características de Soa são:·
Serviço -- é uma função de um sistema computacional, disponibilizada para outro através de uma interface bem definida.·
Sem Estado (Stateless) -- é a não-dependência de um serviço para com outro (exceção para serviços coordenados).·
Descoberta -- é a capacidade de localizar e identificar os serviços através de um repositório central.·
Coordenação -- é a capacidade de organizar os serviços numa sequência de modo a realizar uma determinada atividade (e.
g processos de negócio).·
Binding -- é a forma de conexão dinâmica entre o cliente e o serviço.
Soa prevê que os provedores de serviço registrem as suas informações num repositório central, incluindo as suas características, dados da empresa e uma descrição da interface de acesso.
Este repositório deve ser utilizado por o cliente para determinar as características dos serviços que procura, podendo, a partir deste momento, contratar- lo para iniciar a sua utilização.
Este processo é análogo a um catálogo de serviços.
O conceito de Soa está fortemente ligado com o de Web Services, pois o seu modelo é um ótimo exemplo de Soa, uma vez que possui as características desta arquitetura e é a tecnologia mais aplicada para este caso.
Porém, a implementação de um sistema Soa pode ser realizada utilizando qualquer tecnologia padronizada para Web, como CORBA (Common Object Request Broker Architecture), RMI (Remote Method Invocation), DCOM (Distributed Component Object Model) e REST (Representational State Transfer).
Uma boa comparação para esta situação é mostrar Soa como se fosse um algoritmo.
Ambos não pressupõem o uso de nenhuma tecnologia ou linguagem de programação específica, permitindo a implementação da forma como o desenvolvedor desejar.
Em soluções orientadas ao serviço cada tarefa pode envolver um número qualquer de serviços, gerando inclusive interdependência.
Por exemplo, num sistema de compra de passagens, um Serviço A fornece os destinos, horários e disponibilidades, um serviço B efetua as transações de pagamento e o serviço C emite as reservas.
Desta forma, B depende da conclusão do serviço A para autorizar o pagamento e C depende de A e B para emitir e confirmar a reserva.
O escopo de uma atividade Soa pode variar bastante, indo de uma atividade simples, onde dois serviços se comunicam de forma síncrona utilizando mensagens, até uma atividade mais complexa, onde muitos serviços colaboram assincronamente para completar uma mesma tarefa.
A Figura 2.1 ilustra a composição de serviços complexos, onde existem vários serviços que estão registrados num servidor, a partir de o qual é possível pesquisar- los e compor várias aplicações diferentes.
Como pode ser visto na Figura 2.1, algumas aplicações podem ser formadas por serviços que geram uma dependência entre elas, enquanto outras ficam independentes (A2).
Web Services Web Services será a tecnologia utilizada para implementar o modelo descrito no Capítulo 3.
A escolha por Web Services foi feita em virtude de ser o meio mais difundido para uma implementação Soa.
Esta seção e as próximas subseções descrevem a tecnologia Web Services e as suas especificações adjacentes.
&quot;Um sistema projetado para apoiar interações máquina/ máquina através de uma rede.
Deve possuir uma interface descrita num formato compreensível por as máquinas (especificamente WSDL (Web Service Description Language)).
Outros sistemas interagem com Web Services de maneira pré-definida a partir de a sua descrição, através de mensagens SOAP (Simple Object Access Protocol), tipicamente transportadas por Http com serialização XML em conjunto com outros padrões para Web.»
Basicamente, Web Services são funcionalidades de aplicações especificadas em XML (Extensible Markup Language) para outras aplicações, objetos ou bases de dados.
Desta forma, ao utilizar XML, um programa envia uma solicitação a outro programa através de uma rede (normalmente a Internet) e recebe como resposta os dados solicitados.
Os padrões para Web Services definem os formatos para as mensagens e especificam como a mensagem será enviada.
Estes padrões também descrevem as convenções de mapeamento de conteúdo das mensagens dentro e fora de os programas que implementam o serviço, também definem mecanismos para publicar e descobrir interfaces de Web Services.
Web Services podem ser executados tanto em computadores desktops como em handhelds.
Podem ainda ser utilizados para integração business- to business (B2B), conectando aplicações que estão rodando em várias organizações num mesmo aplicativo.
Os Web Services surgiram da necessidade de padronizar a comunicação entre plataformas distintas e linguagens de programação.
Anteriormente, houveram tentativas de criar padrões como, por exemplo, o CORBA, entretanto não tiveram êxito suficiente.
Um problema nas comunicações foi o uso de RPCs (Remote Procedure Call) para realizar a comunicação entre os diferentes nodos.
Além de apresentar certos problemas de segurança, possuía a desvantagem da dificuldade de implementação num ambiente como a Internet, principalmente por causa de os firewalls.
Em 1999, foi proposto um padrão que para permitir a comunicação entre diversas plataformas.
Através de um consórcio entre empresas, foi desenvolvido o modelo Web Services.
Após uma adoção significativa deste modelo, surgiu a iniciativa UDDI.
O UDDI (Universal Description Discovery and Integration) é um diretório universal de descrição de serviços.
Como o próprio nome sugere, tal iniciativa se propõe a listar todos os Web Services disponíveis na Internet.
Em os anos seguintes, muitas linguagens de programação por tornar Web Services uma tecnologia cada vez mais sólida.
A Figura 2.2 mostra como é formada a estrutura básica de um Web Service, ela é composta por:
Cliente, Web Service e diretório de registro de serviços, de forma que o cliente acessa o diretório de registro de serviços para escolher qual serviço deseja.
A o escolher o serviço, ele obtém um arquivo com a descrição da sua interface numa linguagem apropriada e a partir de esta descrição o serviço é solicitado.
Após processar a informação desejada, o serviço retorna o resultado ao cliente.
A arquitetura básica de um Web Service utiliza os seguintes formatos/ serviços:·
XML: Formato de descrição das mensagens entre o cliente e o Web Services;·
SOAP: Encapsula as mensagens XML em pacotes;·
Http: Transporte dos pacotes SOAP;·
WSDL: Linguagem responsável por descrever a interface do serviço;·
UDDI: Responsável por armazenar a descrição do serviço.
Extensible Markup Language -- XML XML representa uma família de especificações relacionadas que são publicadas e mantidas por a W3C.
Pode- se considerar o XML como a base sobre a qual os Web Services estão construídos, pois provê o armazenamento de descrições e determina o formato de transmissão para a troca de todos os dados via Web Services.
XML foi desenvolvida para superar as limitações do Html (HyperText Markup Language), especialmente para melhorar o suporte à criação e gerenciamento de conteúdo dinâmico.
O Html é bom para definir e manter conteúdo dinâmico, mas não quando envolve uma plataforma de software em a qual os dados associados necessitam ser gerados e compreendidos dinamicamente.
Usando XML, pode- se definir qualquer número de eventos que associam significado aos dados, isto é, o dado é descrito e, em seguida, processado da forma desejada.
Esta grande flexibilidade implica em alguns problemas, pois permite a definição de esquemas por o cliente, por isso é difícil assegurar que todos usarão os mesmos elementos da mesma maneira e com o mesmo significado.
É exatamente nesta parte que é necessária a adequação a modelos.
Se dois computadores trocam dados XML, eles podem interpretar elementos da mesma forma se compartilharem as mesmas definições.
Se dois nodos que compartilham um documento XML também compartilham o mesmo esquema, estes podem, certamente, dar o mesmo significado para os mesmos elementos da mesma forma.
O XML é uma família de tecnologias:
Uma linguagem de marcação de dados, vários modelos de conteúdo, modelos de linking, modelos de namespaces e vários mecanismos de transformação.
Seguem abaixo os membros mais significantes desta família, para os Web Services:·
XML: É um formato para definição de elementos, atributos e tags dentro de um elemento no documento central, proporcionando um modelo de dados abstrato e um formato de serialização.·
XML schema: São documentos XML que definem os tipos de dados, conteúdo, estrutura e permitem elementos associados num documento XML.
Também é usado para descrever instruções de processos semânticos associados com documentos de elementos.·
XML namespaces: Sua função é unicamente qualificar nomes para elementos e aplicações de documentos XML.·
XPointer, Xpath, XLink:
O Xpointer é um ponteiro para uma parte específica num documento;
O XPath são expressões para pesquisar em documentos XML;
E o XLink serve para buscas múltiplas em documentos XML.
Uma das principais características da XML é possuir uma estrutura de documentos hierárquica.
Um dos principais requisitos em Web Services é o reconhecimento da hierarquia XML e o mapeamento dos dados existentes dentro de esta estrutura XML.
A conversão de dados para XML é outro grande requisito da arquitetura XML.
A Figura 2.3 ilustra a estrutura hierárquica de um documento XML.
Através da interpretação dessa estrutura, os dados podem ser mapeados e transformados em outras estruturas diferentes.
Este é o grande benefício para os Web Services, pois através deste recurso os dados de diferentes aplicações podem ser mapeados e agrupados dentro de uma aplicação maior, de forma a abrir portas para a arquitetura orientada a serviço (Soa).
Atualmente, o XML é uma tecnologia amplamente adotada, principalmente em grandes sistemas como os ERPs, onde é necessária a adaptação da aplicação para cada empresa.
Podemos considerar, então, que o XML pode ser utilizado numa grande variedade de aplicações, como na formatação, serialização e transformação de dados.
Web Services se comunicam trocando instâncias formatadas em documentos XML que contêm os dados e Web Services são descritos utilizando XML Schemas que definem os tipos de dados, estrutura e semântica envolvidos.
Assim pode- se afirmar que o principal benefício proporcionado por o XML aos Web Services é a independência das estruturas e dos tipos de dados, deixando livre a intercomunicação entre aplicativos.
Web Service Definition Language -- WSDL WSDL foi originalmente criada por a IBM, Microsoft e Ariba, através do união de 3 propostas anteriores:
Microsoft's SOAP Contract Language, Service Description Language e o Network Accessible Service Specification Language.
Atualmente a WSDL está na versão A WSDL estabelece um formato comum para descrever e publicar informações de serviços na Web.
Utiliza elementos que contêm uma descrição de dados, que tipicamente utiliza um ou mais esquemas XML, de modo a tornar as informações compreensíveis de ambos os lados da comunicação.
A especificação WSDL é frequentemente caracterizada por uma parte abstrata, conceitualmente análoga a IDL (Interface Description Language) convencional, e uma parte concreta, que define protocolos de conexão e outras informações, conforme a Figura 2.4.
A parte abstrata é feita de definições do port type.
Cada port type é uma coleção lógica de operações relacionadas.
Cada operação define uma troca de mensagens simples.
A mensagem é uma unidade de comunicação com um Web Service, representando os dados trocados numa transmissão lógica simples.
No caso de outros padrões Web Services, estas construções todas são definidas no XML.
Pode- se ainda acrescentar que WSDL é um padrão que pode ser utilizado com uma grande variedade de configurações.
Por ser uma linguagem de descrição genérica, pode ser utilizada independentemente do sistema.
Apesar de ser apontado como padrão, isto não significa que ele seja único.
Podemos citar o EDI (Electronic Data Interchange) como exemplo de outra linguagem de descrição, neste caso utilizada para descrição de atividades de manufatura.
Universal Description Discovery and Integration -- UDDI O UDDI (Universal Description Discovery and Integration) tem dois objetivos principais a respeito de a descoberta de serviço.
Primeiramente, apoia a pesquisa de informações por desenvolvedores, de forma que este saiba como escrever programas clientes que irão interagir com o serviço.
Em segundo lugar, estabelece uma conexão dinâmica, permitindo que clientes solicitem o registro e obtenham as referências do serviço de interesse.
Pode- se citar como objetivo do consórcio inicial a criação de um diretório mundial de descrição de serviços gratuito, onde todos poderiam publicar os seus serviços e pesquisar- los.
Com o tempo, esta iniciativa não teve muito sucesso e uma nova abordagem foi introduzida.
Agora o UDDI caminha em direção a sua implementação em ambientes mais variados, de modo a permitir implementações locais (privadas) ou na Internet (normalmente públicas).
O UDDI proporciona uma maneira muito simples de pesquisa a seus dados.
O diretório categoriza a informação contida em termos de acordo com o conteúdo do serviço, desta forma os dados podem ser localizados mais facilmente.
A analogia normalmente feita é com uma lista telefônica, onde as páginas brancas possuem uma lista de organizações, informações de contato e de serviços que estas organizações proporcionam.
Em as páginas amarelas, há uma classificação dos serviços e das empresas de acordo com o tipo de serviço que oferecem.
Já as páginas verdes descrevem como os serviços devem ser invocados.
Esta organização normalmente é muito flexível e permite a fácil consulta de Web Services, bem como possibilita um fácil comparativo entre serviços similares oferecidos por uma mesma empresa.
A proposta do UDDI é que ele proporcione flexibilidade e extensibilidade para o registro e descoberta de serviços.
Ele representa uma estrutura de dados que pode armazenar informações sobre diversas empresas e serviços, se instalado na Internet, ou apenas dos serviços privados, quando instalado dentro de a rede interna de uma empresa.
Portanto, o UDDI é a forma padronizada de se gerenciar metadados de Web Services.
Hypertext Transfer Protocol -- Http Http é um protocolo de transferência amplamente utilizado na Internet.
Basicamente, ele especifica as mensagens que os clientes podem enviar aos servidores e quais as respostas que eles receberão.
Por usar TCP (Transmission Control Protocol), o controle das mensagens (confirmações de entrega, reenvio de mensagens) é feito por este protocolo, deixando o Http livre para tratar melhor de outros assuntos.
Ainda podemos acrescentar que a partir de a versão 1.1, foi adicionada a função de conexões persistentes, que permite que mensagens adicionais sejam trocadas através de uma mesma conexão a TCP.
Este tipo de conexão diminui o overhead das conexões.
Serve para uso com um proxy que possa se tornar um túnel Consulta certas opções alguns quesitos de segurança, como o provido por o cabeçalho Authorization, que faz com que o cliente se identifique em páginas protegidas.
Em Web Services, Http é o protocolo mais utilizado.
Ele é o grande facilitador que permite que os Web Services se comuniquem de forma transparente através de firewalls.
É também através de ele que se acrescenta um protocolo de segurança muito importante, o Https (HyperText Transfer Protocol Secure), que será abordado em mais detalhes mais à frente.
Deve- se deixar claro que o uso do Http não é obrigatório quando falamos de Web Services, conforme pode ser visto em, pode- se ainda utilizar SMTP (Simple Mail Transfer Protocol), Beep (Block Extensible Exchange Protocol) e diversos outros.
O Https (HyperText Transfer Protocol Secure) é uma implementação do protocolo Http que adiciona uma camada de segurança, normalmente SSL, e permite que os dados sejam transmitidos numa conexão criptografada.
Ainda é possível verificar a autenticidade do servidor e do cliente através de certificados digitais.
Esta extensão do protocolo Http é utilizada normalmente quando os dados da conexão não podem ser vistos (e.
g compras, cartão de crédito, dados pessoais).
A porta padrão para este protocolo é a 443.
Simple Object Access Protocol -- SOAP SOAP é uma das tecnologias mais importantes que fazem parte do padrão Web Services.
Os Web Services não podem existir sem uma maneira abstrata de representar os dados e publicar as definições de interface.
O SOAP tem uma das funções mais importantes:
Obter os dados de um local para outro sobre uma rede.
Este protocolo permite que o transmissor e o receptor de documentos XML tenham um suporte comum para o protocolo de transferência de dados para que, desta forma, haja uma comunicação efetiva.
Esta tecnologia é como se fosse uma pequena extensão do Http que suporta mensagens XML.
A especificação SOAP define como organizar informações utilizando XML de uma maneira estruturada e escrita que possa ser trocada entre pontos.
Em pode- se encontrar a seguinte definição:
&quot;Um grupo de regras que qualquer entidade que processe uma mensagem SOAP deve estar de acordo, definindo em particular os elementos XML que uma entidade deve ler e entender, bem como ações que estas entidades devem tomar se eles não entenderem o conteúdo.»
Como um protocolo de comunicação, SOAP é desprovido de estado e mão única.
Ele também ignora a semântica das mensagens que estão sendo trocadas através de ele.
A interação atual entre dois locais (sites) deve ser codificada dentro de um documento SOAP e qualquer padrão de comunicação, incluindo solicitação/ resposta.
Isto significa que o SOAP é criado para suportar aplicações fracamente acopladas que interagem através da troca de mensagens assíncronas em mão única com os outros.
Qualquer complexidade adicional no padrão de comunicação, como mensagens síncronas em mão dupla ou interação estilo RPC requerem SOAP para serem combinadas com outros protocolos ou middlewares que possuem as propriedades adicionais.
Por exemplo, para implementar uma chamada RPC convencional que toma parâmetros de entrada e retorna alguma saída usando SOAP, primeiro terá que codificar os parâmetros de entrada e a chamada para o procedimento dentro de uma mensagem SOAP.
A resposta do procedimento deve também ser codificada dentro de outra mensagem SOAP.
Finalmente, um protocolo de transporte síncrono como o Http deve ser utilizado para transportar as duas mensagens.
Ele descreve como documentos devem ser escritos e organizados para que eles possam capturar a interação (e.
g RPC) e como mapear os documentos para os protocolos (e.
g Http).
A troca de informações em SOAP acontece através de mensagens.
Essas mensagens são utilizadas como um envelope onde a aplicação encapsula qualquer informação necessária para ser enviada.
Cada envelope contêm duas partes, um &quot;cabeçalho «e um &quot;corpo».
O cabeçalho é opcional, isto é, pode ou não estar presente numa mensagem SOAP, e o corpo é obrigatório.
Ambos, cabeçalho e corpo tem múltiplas sub-partes em forma de &quot;blocos do cabeçalho «ou &quot;blocos do corpo».
Um bloco de cabeçalho (ou corpo) é qualquer filho de primeiro nível do elemento cabeçalho (ou corpo) de uma mensagem.
O último passo para tornar o SOAP funcional é definir como ele será transportado por a rede.
Nenhum protocolo é imposto, no entanto ele é tipicamente associado ao Http.
Para que esta comunicação funcione de forma efetiva é necessário determinar como a mensagem SOAP será empacotada e quais regras do protocolo de transporte são necessárias.
Para SOAP sobre Http, os modos mais comuns são o Http GET e o Http POST.
A identificação do endereço de destino é necessária, para isto uma parte da mensagem SOAP é interpretada e incluída no Http, de forma que ele saberá o destinatário da mensagem.
Um processo semelhante acontece quando é necessário o roteamento de mensagens SOAP.
Os nodos por o qual a mensagem deve ser roteada estão descritos num path na mensagem SOAP e são interpretados para que seja possível o roteamento.
Segurança Esta seção tem o objetivo de ligar os conceitos de segurança com os conceitos de Web Services apresentados na Seção 2.2.
Serão abordadas algumas das tecnologias que estão atualmente em utilização para Web Services.
São elas:
Criptografia XML e Web Services Security.
Inicialmente, esta seção descreverá rapidamente alguns conceitos sobre algoritmos de criptografia.
Algoritmos de Criptografia Normalmente, algoritmos criptográficos são necessários para manter um sistema seguro, principalmente quando a comunicação acontece numa rede não segura como a Internet.
Há duas formas de criptografia mais comuns:
As que utilizam algoritmos simétricos e as que utilizam algoritmos assimétricos.
Ainda pode- se citar a funções hash como outra forma de criptografia.
Algoritmos Simétricos Algoritmos de chave simétrica fazem referência a métodos de criptografia onde o transmissor e o receptor compartilham a mesma chave.
Deve- se ressaltar que é possível que utilizem chaves diferentes, mas estas frequentemente estão relacionadas de uma maneira simples.
Este tipo de algoritmo é dividido em cifras de fluxo ou em cifras por bloco.
As cifras de fluxo cifram os bits da mensagem individualmente, enquanto as cifras por bloco criptografam vários bits como se fossem um.
A cifragem por blocos é mais frequente, normalmente são utilizados blocos de 64, 128 e 256 bits, sendo que este número pode variar indefinidamente.
Os algoritmos simétricos são mais rápidos, devido a a menor complexidade das operações necessárias para decriptografar os dados.
Podemos citar como exemplos de algoritmos simétricos:
Des (Data Encryption Standard), Triple-DES, AES (Advanced Encryption Standard), TwoFish e BlowFish.
Algoritmos Assimétricos Algoritmos assimétricos, ou algoritmos de chave pública, utilizam um par de chaves:
Uma pública e outra privada.
A chave pública é distribuída para os transmissores da mensagem (e.
g pessoa, sistema), já a chave privada é mantida apenas por o receptor, sendo que apenas o proprietário desta chave é capaz de decriptografar a mensagem codificada a partir de a chave pública.
É possível que este tipo de algoritmo seja utilizado de duas formas:
Para confidencialidade (conforme exemplo citado no parágrafo anterior), a chave pública é utilizada para cifrar a mensagem, sendo que apenas a chave privada pode decifrar- la;
E para autenticidade, a chave privada é utilizada para criptografar a mensagem.
Isto garante que apenas o dono desta chave poderia ter cifrado a mensagem que será decifrada com a chave pública.
Os principais algoritmos de criptografia assimétrica são RSA (Rivest, Shamir e Adleman), Diffie-Hellman, DSA (Digital Signature Algorithm) e a sua variação com curvas elípticas ECDSA (Elliptic Curve Digital Signature Algorithm).
Apesar de haver vários algoritmos de criptografia assimétrica, os três seguintes foram escolhidos por serem suportados por o BouncyCastle (API de criptografia que será introduzida juntamente com a explicação do protótipo na Seção 3.3):·
RSA é um algoritmo de chaves assimétricas que fundamenta- se em teorias clássicas dos números.
Seu nome vem das iniciais dos nomes do professores que inventaram o algoritmo, Rivest, Shamir e Adleman.
RSA utiliza um par de chaves, uma pública e outra privada.
Todas as mensagem são criptografadas com a chave pública e só podem ser lidas com a chave privada.
Este algoritmo é considerado uma das melhores implementações de criptografia assimétrica.·
ECDSA (Elliptic Curve Digital Signature Algorithm) é uma variante do algoritmo DSA que utiliza criptografia através de curvas elípticas.
Está contida na proposta do NIST que também abrange o DSA.
A diferença entre os algoritmos está na quantidade de bits utilizados por a chave pública, o que proporciona o dobro de segurança em relação a o DSA.
Criptografia XML A criptografia XML é uma das melhores formas de garantir a confidencialidade das informações durante o seu trânsito numa rede.
A grande vantagem da Criptografia XML, se comparada a outras formas como SSL (Secure Sockets Layer), é que ela permite que os dados sejam criptografados mesmo que a transação SOAP tenha que ser roteada durante o caminho, além de manter- se criptografada após ser processada num Web Service.
A W3C ressalta duas funcionalidades da criptografia XML.
A primeira é que os dados criptografados podem ser expressos utilizando XML, e a segunda é que apenas partes do documento podem ser criptografadas.
Para que esta criptografia seja feita, vários algoritmos bem conhecidos podem ser utilizados, como Des, Triple-DES e RSA.
Segundo os seguintes tipos de informações podem ser expressos utilizando Criptografia XML:·
Detalhes do tipo de dados contidos no documento criptografado (por exemplo, JPEG· Uma chave criptografada (por exemplo, um par de chaves assimétricas);·
Informações sobre o algoritmo da chave que foi escolhida (por exemplo, Diffie-Hellman);·
Referência a os dados criptografados;·
O método de criptografia utilizado.
O trecho de um arquivo XML, representado na Figura 2.5, possui informações sobre uma compra através de cartão de crédito e necessita que seus dados sejam criptografados para que ninguém tenha acesso a estas informações indevidamente.
Como podemos ver na Figura 2.6, o trecho que possuía informações sobre o cartão de crédito foi substituído por um campo que está criptografado.
Dentro deste campo, temos o campo que possui os dados cifrados, propriamente ditos.
Desta forma, é possível transferir os dados de uma maneira segura.
Caso alguém intercepte este arquivo, não terá acesso aos dados, pois para visualizar- los é necessária a chave criptográfica.
Vejamos quais são os passos para que a criptografia descrita no exemplo seja realmente executada:
Este passo é necessário para que o destinatário possa decriptografar o arquivo.
Para tanto, é necessário o envio, através de um meio seguro, da chave de criptografia.
Para que se possa criptografar os dados, é necessário que eles estejam organizados em octetos, caso não estejam, deve ser aplicada a codificação UTF-8 para que eles fiquem organizados de acordo com a necessidade.
Tendo feito todos os passos anteriores, agora já é possível executar o processo de criptografia.
A especificação dos dados não é obrigatória, mas é muito recomendada para que o receptor saiba que dados ele está decriptografando.
Segue abaixo a descrição do processo de decodificação.
Este item não é obrigatório, pois normalmente o decodificador já tem conhecimento destas informações.
Para localizar a chave, é necessário analisar o corpo da mensagem SOAP onde estão as informações sobre como aquela chave foi enviada.
Neste passo, é possível decodificar os dados contidos no campo Este processo transforma os dados obtidos novamente em arquivos XML;
Caso os dados não sejam XML, este passo pode ser omitido.
Finalmente, os dados então são repassados para a aplicação final, que pode interpretálos.
Para encerrar a seção sobre Criptografia XML, ressalta- se que esta é uma tecnologia relativamente fácil de ser implementada, pois possui o apoio de diversas bibliotecas e softwares, como o IBM XML Security Suite e o Microsoft Web Services Enhancements.
Apesar de ser de fácil implementação, a criptografia XML não é ideal para todas as situações, pois o overhead causado por este modelo pode ser considerado alto, o que pode inviabilizar o projeto.
Web Service Security -- WSS O principal objetivo dos Web Services é a comunicação entre sistemas de diferentes empresas.
Conforme mencionado anteriormente, esta é uma questão muito sensível, pois empresas utilizam diferentes plataformas, linguagens de programação e tecnologias de segurança.
A diversidade de sistemas operacionais e linguagens de programação é aceita em Web Services através de XML.
Desta forma, o padrão WSS estabelece alternativas de segurança mais complexas que as tradicionalmente utilizadas com Web Services, proporcionando mais segurança na comunicação em nível de mensagens.
O WSS foi inicialmente proposto por a Microsoft em 2001, sendo que a sua principal característica é segurança em mensagens SOAP, o que difere este dos outros padrões de segurança apresentados anteriormente.
Desde a sua proposição, outros padrões entraram nesta especificação, como o Ws--Trust e o Ws--Federation.
Estes padrões posteriores normalmente são chamados &quot;Ws- «e serão abordados nesta seção.
Desde 2002 é um padrão gerenciado por a OASIS.
WSS define a forma como os tokens de segurança podem ser incluídos em mensagens SOAP e como especificações de segurança XML podem ser utilizadas para criptografar estes tokens.
Conforme pode ser visto na Figura 2.7, o WSS está situado sobre a camada SOAP.
Para isto, as características providas (criptografia e autenticação) são proporcionadas utilizando Assinaturas XML e Criptografia XML (abordado na Seção 2.3.2).
Para facilitar o entendimento, seguem breves explicações individuais das especificações da pilha WSS.
Ws--Policy A especificação Ws--Policy permite que organizações que estão publicando os seus Web Services especifiquem seus requisitos de segurança.
Estes requisitos incluem algoritmos de criptografia, assinaturas digitais e a forma como estas informações devem ser integradas ao Web Service.
O Ws--Policy permite que os requisitos de segurança sejam descritos.
Função semelhante a WSDL que ao invés de a segurança descreve o próprio Web Service.
Desta forma, as empresas podem entender os pré-requisitos necessários para a utilização do seu Web Service.
Ws--Trust O Ws--Trust define como relacionamentos confiáveis podem ser estabelecidos.
Este relacionamento pode acontecer de duas formas:
Direto ou intermediado.
No caso de relacionamento intermediado, um proxy é utilizado para avaliar as necessidades impostas por o Ws--Policy e solicitar- las às entidades que desejam utilizar- lo como ponto intermediário.
Este proxy é considerado uma entidade confiável, que verifica os tokens de segurança, já o WSS é utilizado para transferir estes tokens utilizando assinatura e criptografia XML para garantir a confidencialidade.
Este modelo permite delegação de responsabilidades, pois quando recebe uma mensagem SOAP, ele age como se fosse o usuário final, garantindo assim que os requisitos mínimos estejam especificados.
Ws--SecureConversation permite que o solicitante e o Web Service se autentiquem utilizando mensagens SOAP e, desta forma, estabeleçam um contexto de segurança, onde estão mutuamente autenticados.
Esta especificação funciona de forma similar ao SSL para o Http, porém, é utilizado com o protocolo SOAP.
Ws--Privacy O Ws--Privacy utiliza- se da combinação de Ws--Policy, Ws--Security e do Ws--Trust para comunicar quais são as políticas de privacidade.
Estas políticas de privacidade são definidas por a empresa que desenvolve o Web Service.
Este padrão especifica como os requisitos podem ser incluídos nas descrições WSPolicy.
Utiliza o Ws--Trust para avaliar os dados encapsulados dentro de mensagens SOAP.
Estas relações entre padrões significa que todas as especificações WSS têm dependência entre si.
Ws--Federation A Ws--Federation é uma especificação composta por o Ws--Security, Ws--Policy, Ws--Trust e por o Ws--SecureConversation.
A função é criar uma federação que permita a interação entre partes que não possuem as mesmas regras de autenticação.
Por exemplo, um domínio autentica apenas utilizando Kerberos e outro domínio apenas utilizando X. 509;
a federação permitiria que um usuário se autentique num domínio e utilize o serviço em outro domínio Ws--Authorization O Ws--Authorization descreve como políticas de acesso para um Web Service são especificadas e gerenciadas.
Para a realização deste serviço é utilizado um formato de autorização e uma linguagem de autorização, tais como:
ACL-Based Authorization (Access Control List) e RBAC-based Authorization (role-based Access Control).
Trabalhos Relacionados Com o objetivo de entender e levantar o estado da arte no quesito segurança em Soa foram analisadas diversas iniciativas de pesquisa, direta e indiretamente relacionadas com este trabalho.
Existem diversas pesquisas na área de Web Services, mas poucas são relacionadas com a interoperabilidade entre serviços com diferentes características de segurança:·
Em, os autores propõem a discussão de interoperabilidade entre diferentes arquiteturas de federações, que são mecanismos que permitem que diferentes domínios compartilhem a confiança na autenticação de identidade e atributos.
É realizando um comparativo entre dois modelos (SAML (Security Assertion Markup Language) e Ws--Federation) que permite definir uma forma de convergência entre eles.
Esse artigo possui um objetivo semelhante ao que é utilizado por esta pesquisa, porém os alvos são diferentes:
Ele trata de interoperabilidade em federações com tokens de autenticação, enquanto tratamos de interoperabilidade de algoritmos de criptografia em· Em é proposto um framework orientado a aspectos para Web Services, onde seria possível tornar a implementação de características de segurança mais flexível.
O proposto por esse artigo difere do proposto nesta pesquisa, pois trata de uma forma diferente de desenvolvimento de Web Services visando o reuso de código e não uma forma de interoperabilidade de especificações.
Apresenta idéias interessantes, como a separação da aplicação em si de quesitos de negócio como segurança e autenticação.
A relação do artigo com o trabalho que será apresentado acontece através da busca por uma separação similar, porém a aplicação será separada da segurança através da utilização de serviços diferentes e não de programação por aspectos.·
Em, os autores utilizam a mesma técnica de, ao aplicar aspectos com o objetivo de separar o controle da segurança de outros requisitos funcionais da aplicação.
Segundo o autor, esta separação torna a composição de Web Services mais flexível e dinâmica.
Porém, a separação em aspectos visa o reuso e busca facilitar o desenvolvimento de aplicações com segurança através da separação das características de segurança.·
Em, são apresentadas deficiências nas especificações Web Services em composição de serviços.
É citado que a linguagem BPEL (Business Process Execution Language), que especifica interações entre Web Services, não suporta propriedades como:
Segurança, confiabilidade e persistência.
Como solução para este problema é apresentado um middleware de integração transparente que expande a especificação BPEL, provendo estas propriedades ao protocolo.
O conceito de um sistema intermediário, transparente ao usuário capaz de tratar dificuldades com políticas de segurança, é útil para a composição do modelo a ser apresentado.·
Em, os autores apresentam um middleware que permite a auto-adaptação de políticas de composição de serviços permitindo, desta forma, que ele seja autocustomizável independentemente das políticas utilizadas.
Este conceito é interessante, pois pode ser estendido a algoritmos de criptografia, de maneira que o sistema permitiria que, apesar de diferentes algoritmos estarem sendo utilizados, o sistema seria capaz de se auto-configurar permitindo a comunicação entre eles.·
Utilizando os conceitos apresentados em e, em é apresentado um modelo de segurança baseado em proxy similar ao modelo que será apresentado no próximo capítulo.
Em, os autores propõem a implementação de um sistema intermediário capaz de tratar diferentes características de segurança, como formas de criptografia e autenticação.
Porém, para que o sistema funcione corretamente, é necessário que o mesmo esteja instalado em ambos os lados da conexão (cliente e servidor).
A forma de interação com os serviços é através da captura do fluxo de dados da placa de rede.
Os resultados apresentados não descrevem testes com diferentes algoritmos de criptografia e os algoritmos utilizados não são mencionados o que dificulta uma comparação com os seus resultados.
Porém, o modelo é muito similar com o que será proposto aqui, testando a efetividade do mesmo.·
Em, é descrito um método de segurança para Web Services que visa proteger o artigo, a maior parte das Apis SOAP oferecidas com os browers não são compatíveis entre si, dificultando uma solução uniforme para a segurança na comunicação.
O artigo apresenta um método através de o qual a comunicação entre o browser e o cliente é protegida fim-a-fim utilizando WSS.
A utilização do WSS e de um sistema externo ao serviço principal para prover segurança são as principais contribuições do artigo para com o trabalho que será apresentado nos próximos capítulos.·
Em, são descritas diversas vulnerabilidades da arquitetura Soa, de modo que divide- os em níveis de segurança e ressalta seus riscos.
Aborda soluções apenas no nível que considera menos estudado, o nível de negócio, e propõe novas abordagens de segurança através da linguagem BPEL.
Isto significa que a segurança é mais crítica na composição de serviços, o que contribui com este trabalho uma vez que corrobora o nicho escolhido.
Tal nicho é o tratamento de características de segurança em Web Services complexos, ou seja, compostos por vários serviços.
A Tabela 2.2 apresenta concisamente as contribuições feitas por cada um dos artigos analisados nesta seção.
Os campos são marcados de acordo com a relevância da contribuição para com esta dissertação.
De entre todos os assuntos abordados foram selecionados os 4 tópicos de maior relevância para o andamento deste trabalho de pesquisa.
O objetivo deste capítulo foi realizar um estudo direcionado às tecnologias relacionadas com Web Services e suas formas de segurança, de modo a servir de referência para o modelo, protótipo e estudo de caso, apresentados nos Capítulos 3 e 4.
O primeiro passo do trabalho foi identificar a tecnologia Web Services, arquitetura de referência em a qual está baseada (Soa), e tecnologias que o compõem, fazendo referência as características que puderam ser consideradas relevantes na identificação do problema a ser apresentado na Seção 3.1.
Foram avaliadas as tecnologias relacionadas com Web Services e Soa, buscando diferenciar conceitos e tornar claro que Soa é uma arquitetura de referência e que Web Services não são sua única forma de implementação, pode- se ainda usar CORBA, RMI, entre outros.
O passo seguinte foi identificar formas de estabelecer segurança durante a comunicação de serviços.
Considerando que a forma mais comum de segurança é a criptografia, foram levantadas as suas formas possíveis.
A o estudar a Criptografia XML, chegamos a um padrão que a contêm, porém muito mais complexo:
O Web Services Security (WSS).
O WSS é composto por vários outros padrões, que estabelecem convenções e especificam formas de uso para diferentes formas de segurança.
Durante o estudo destas tecnologias foram identificadas dificuldades de desenvolvimento de aplicações que utilizam estes padrões de segurança.
Mesmo seguindo as especificações, o desenvolvedor deve fazer muitas escolhas, entre as quais está o variado número de algoritmos de criptografia, o que permite que as empresas criem políticas de segurança diferentes.
A maior dificuldade, no entanto, está em utilizar aplicações com diferentes políticas de segurança numa arquitetura Soa, onde múltiplos serviços são orquestrados para comporem diferentes aplicações.
A complexidade de diferentes políticas de segurança acaba por tornar difícil o gerenciamento de vários certificados de segurança, principalmente quando serviços precisam ser substituídos.
Durante o processo de substituição de serviços, percebe- se que através de Soa encontram- se serviços com a mesma interface que poderiam substituir de forma transparente o serviço inativo, porém diferenças nas políticas de segurança acabam se tornando um problema.
Utilizando os padrões e especificações estudados neste capítulo procurou- se uma forma de facilitar a implementação de criptografia em serviços que compõem arquiteturas Soa.
O próximo capítulo apresenta o problema identificado, bem como a solução encontrada.
Ainda é apresentado um modelo e um protótipo do mesmo.
Este capítulo apresenta mais detalhadamente o problema a ser solucionado, aplicando os conceitos fundamentados no Capítulo 2.
A Seção 3.1 descreve o problema encontrado, e ilustra as suas formas de ocorrência visando encontrar uma solução.
A Seção 3.2 apresenta a solução encontrada e a propõe através de um modelo UML.
A Seção 3.3 apresenta um protótipo do modelo discutido na Seção 3.2, com o objetivo de testar a sua composição, capacidades e limitações.
Problema Esta seção apresenta as dificuldades encontradas ao tratar de criptografia XML em serviços de aplicações baseadas em Soa.
Conforme o problema também abordado em, a variedade de algoritmos de criptografia pode tornar o desenvolvimento de aplicações compostas por vários serviços uma tarefa complexa.
Como os serviços que compõem uma aplicação geralmente são providos por terceiros, as vezes é necessário que um serviço seja substituído por outro devido a vários motivos, como por exemplo desativação do serviço ou alto custo.
Caso um dos serviços originais de uma aplicação Soa fique indisponível, a sua substituição pode ser uma tarefa relativamente complexa, principalmente se o serviço substituto utilizar algoritmos de criptografia diferentes.
Mesmo possuindo interfaces compatíveis, é necessário recodificar a aplicação cliente para tornar possível a comunicação através do novo algoritmo de criptografia.
A Figura 3.1 ilustra a situação onde um dos serviços de uma aplicação fica indisponível e é necessário substituir- lo por outro.
Dentro de o repositório UDDI, temos cadastradas descrições de serviços disponibilizados por duas empresas A e B. Ambas oferecem serviços similares, S1, S2 e S3.
A aplicação representada utiliza inicialmente os serviços providos por A, que em suas políticas de segurança prevê o uso do algoritmo de criptografia RSA para criptografar os arquivos XML transmitidos por a rede.
Porém, a empresa A está descontinuando o serviço S1 e a aplicação passará a utilizar o serviço S1 da empresa B, que utiliza DSA.
Esta nova conexão está representada por a linha azul na figura.
Com base nestes dados, será necessário recodificar parte da aplicação para que se torne compatível com o novo padrão de criptografia.
Em as Figuras 3.2 e 3.3, mostramos um exemplo com parte do arquivo de descrição da interface (WSDL) de dois serviços similares.
Ambos estão cadastrados num repositório UDDI e o desenvolvedor da aplicação é livre para escolher qual deseja.
Ambos os serviços estão de acordo com Ws--Policy, que descreve os requisitos de segurança em conjunto com a interface.
Podemos visualizar entre as linhas 1 e 18 das Figuras 3.2 e 3.3 que as interfaces são exatamente iguais -- utilizam o mesmo tipo de inteiro -- porém, nas linhas 24 das Figuras 3.2 e 3.3 percebe- se a diferença quanto a os algoritmos de criptografia.
Apesar de ambos os serviços usarem RSA, eles não são compatíveis, pois os algoritmos simétricos que criptografam as chaves não são iguais.
Conforme exemplificado por a Figura 3.1, mesmo sendo compatíveis, a substituição destes serviços pode não ser trivial.
Modelo Com base nas necessidades previamente identificadas durante o processo de pesquisa e apresentado nos capítulos anteriores, foi desenvolvido um modelo capaz de apresentar uma solução para o problema proposto na Seção 3.1.
Em este caso, S2 deve ser substituído por S3.
Como vemos, as suas políticas de segurança são diferentes e o cliente necessita ser recodificado (com o algoritmo x, e não mais com o DSA) para tornar a comunicação com S3 possível.
O modelo propõe que a estrutura seja conforme a Figura 3.4 b, onde há um intermediário.
Considerando esta nova estrutura, o sistema cliente pode ser codificado pensando apenas em 1 ou em nenhum algoritmo de criptografia, o intermediário se torna o responsável por criptografar os dados com outros algoritmos, de modo a facilitar a codificação e a manutenção da aplicação cliente.
O sistema implementado com base no modelo deve ser capaz de receber as mensagens de um serviço, decodificar- las e recodificar- las utilizando o algoritmo de criptografia apropriado e, então, encaminhar- las para o serviço destinatário.
Conforme a Figura 3.5, o modelo do sistema prevê alguns casos de uso através de o qual é permitido ao usuário:
Fazer login, listar, excluir e cadastrar serviços.
Cada Caso de Uso é descrito abaixo:·
FazLogin: Está previsto que o cliente deve ser cadastrado no sistema com login e senha desta forma, o sistema pode confirmar a identidade do usuário e relacionar os serviços com o seu perfil.
Sugere- se a utilização de certificados X. 509 para a autenticação dos usuários.
Permitir ao usuário cadastrado no sistema acessar as suas funcionalidades.
4 a..
Login e senha não são válidos.·
ListaServiços: O usuário pode listar todos os seus serviços cadastrados.
Desta forma o sistema consulta o banco de dados buscando as informações dos serviços previamente listados (Tabela 3.2).
1. O usuário acessa no menu a opção Listar Serviços.
3 a..
Detalhes dos Serviços.·
ExcluiServiços: Entre os serviços listados, este caso de uso prevê a exclusão de qualquer um dos serviços, eliminando as suas possibilidades de uso (Tabela 3.3).·
CadastraServiço: É o responsável por interpretar o arquivo WSDL que descreve o serviço, gerar as chaves de criptografia corretas e gerar o código do sistema intermediário (Tabela 3.4).
1. O usuário acessa no menu a opção Excluir Serviço.
4 a..
Serviço não pode ser excluído.
1. O usuário acessa no menu a opção Cadastrar Serviço.
4 a..
Os dados do arquivo WSDL não são válidos.
A Figura 3.6 representa, através de um diagrama de sequência, como o usuário interage com o sistema durante o processo de Cadastro de Serviço.
Primeiramente é necessário que o usuário efetue o login;
Após o sistema autenticar o usuário, se torna disponível a opção de cadastro de serviços;
Para cadastrar um serviço, é necessário efetuar o upload do arquivo WSDL contendo as especificações de comunicação e de segurança (Ws--Policy) do serviço.
Após efetuado o upload do serviço, é realizada a interpretação do arquivo para que sejam retiradas as informações necessárias para a geração do sistema de proxy.
Desta forma, o sistema pode ser gerado corretamente;
Uma vez com o sistema gerado, é devolvido ao usuário o caminho para que o serviço seja utilizado.
A Figura 3.7, apresenta através de um diagrama de sequência, o processo de comunicação completo entre um cliente e um servidor, tendo o sistema de proxy como intermediário.
Primeiramente o usuário solicita a chave ao sistema intermediário, este por sua vez devolve a chave.
Com a chave obtida o sistema pode criptografar a mensagem, e enviar- la ao intermediário que vai decriptografar e recriptografar utilizando a chave obtida a partir de o serviço final, enviando a mensagem para que o serviço possa analisar- la e calcular o resultado.
Protótipo O protótipo é baseado no padrão Web Services provido por a W3C utilizando, portanto, seus principais conceitos:
XML, SOAP, WSDL e UDDI.
Para este último, o próprio sistema atua como um repositório de cadastro e pesquisa.
O sistema foi desenvolvido em módulos e está organizado conforme a Figura 3.8.
O núcleo é responsável exclusivamente por a comunicação entre serviços;
A Interface Web permite o cadastro de serviços no núcleo através da interpretação dos arquivos WSDL;
O módulo de segurança é responsável por armazenar e gerenciar as chaves criptográficas;
A implementação foi realizada através da utilização das linguagens Java para o núcleo do sistema e PHP (PHP5) para o acesso Web, com banco de dados MySQL.
Os frameworks Web Services escolhidos para o sistema foram:
Axis2 para a comunicação e Rampart para o módulo de segurança.
Para o acesso Web, foi utilizado o framework PHP NuSoap, o qual é o responsável por a interpretação dos arquivos WSDL e Ws--Policy.
Para a geração e gerenciamento das chaves de criptografia foi utilizado o aplicativo BouncyCastle.
O servidor onde as aplicações executam é o TomCat O Axis2 versão 1.4.1 é uma engine para Web Services, baseada na linguagem de programação Java, porém está disponível também para C. Este framework prevê que as interfaces WSDL sejam adicionadas às aplicações, servindo também como um servidor de aplicações.
Para a utilização da especificação Ws--Security foi utilizado o módulo Rampart, pois este facilita a implementação das especificações WSS, uma vez que possui os algoritmos já implementados.
O BouncyCastle é um conjunto de Apis utilizadas para criptografia.
Ele implementa vários algoritmos de criptografia, conforme a Tabela 3.5.
Através do BouncyCastle é possível gerar e gerenciar as chaves de criptografia utilizando o keytool, disponível na JDK através das bibliotecas JCE (Java Cryptography Extension).
As chaves ficam armazenadas no formato PKCS12 (Public Key Cryptography Standards&amp; 12) e os algoritmos suportados estão na Tabela 3.5.
O núcleo da aplicação é responsável por o gerenciamento e compilação do código gerado por a Interface Web.
O processo de compilação é realizado através da aplicação Apache Ant1, que esquematiza todos os passos de compilação num arquivo XML, de forma similar a um script bat em computadores com sistema operacional Windows.
A o compilar os arquivos.
Java gerados e alterados por a Interface Web, o núcleo organiza os serviços de acordo com o usuário e com o serviço, criando uma hierarquia organizacional que facilita uma possível manutenção dos serviços.
Para a publicação dos serviços é necessário efetuar a geração de um pacote.
Aar com os arquivos.
Java compilados.
Este pacote é muito similar aos pacotes.
Jar, uma vez que são compostos por pastas e arquivos necessários para que o serviço seja executado corretamente.
Os arquivos de configuração utilizados na geração do pacote com os serviços, bem como o keystore que armazena as chaves, podem ser vistos em maiores detalhes no Apêndice A. O Apache Ant pode ser rodado a partir de a Web através da função &quot;PHP exec».
Interface Web A Interface Web é responsável por interpretar os arquivos WSDL, gravar as informações no banco de dados e gerar os arquivos necessários para o funcionamento do serviço no núcleo.
A Figura 3.9 ilustra a página inicial da aplicação logo após o login.
Conforme previsto no modelo é possível listar e cadastrar serviços.
Para a opção listar serviços é realizada uma busca no banco de dados, exibindo os serviços cadastrados.
Em a opção cadastrar é exigido do usuário que faça o upload do arquivo de descrição do serviço, o arquivo é interpretado automaticamente e executa as chamadas ao banco e a geração dos arquivos.
A Figura 3.10 apresenta o exemplo de um arquivo WSDL interpretado, exibindo na tela as suas informações básicas.
O serviço utilizado como exemplo é &quot;FibonacciService», sendo que este é capaz de calcular um determinado termo de uma sequência Fibonacci.
Em este caso, o arquivo WSDL foi enviado, tendo sido identificado apenas 1 método, o &quot;calculateFibonacci», o qual apresenta também o caminho do serviço no campo &quot;Endpoint», entre outras informações importantes para a geração do serviço intermediário.
Banco de Dados A estrutura do Banco de Dados que compõe o sistema PBSec é relativamente simples.
Ela é composta por 3 Tabelas responsáveis por armazenar os usuários, os serviços e as empresas que disponibilizam os serviços.
Os dados do banco são criptografados com a função hash SHA1, a qual garante a segurança das senhas e dos dados de acesso, enquanto elas estiverem armazenadas.
A Figura 3.11 apresenta a estrutura do banco de dados do sistema PBSec.
A Tabela Users, responsável por identificar os usuários, possui um campo Id, que é um identificador único do usuário e serve para relacionar os usuários com os serviços que ele cadastrou.
Ainda há os campos Nome e Sobrenome que identificam o usuário e também os campos Login e Passwrd responsáveis por garantir que apenas o usuário certo irá utilizar o serviço.
Em a Tabela Serviços há o campo Id que identifica os serviços de forma única e os relaciona com os usuários e com as empresas.
Os demais campos contêm os dados retirados do arquivo de descrição WSDL e também o caminho de acesso ao serviço, todas informações importantes para a utilização do sistemas PBSec.
Já na Tabela Empresas, existem os dados das empresas que disponibilizam os serviços, como por exemplo, formas de contato.
Segurança Por ser um sistema de segurança, as suas especificações devem ser garantia de confiabilidade para os clientes Estas especificações abrangem todo o sistema, desde a Interface Web até o Banco de Dados.
O núcleo do sistema possui proteção de variáveis, protegendo as informações que transitam por o sistema mesmo quando elas estejam armazenadas na memória local, uma vez que é necessário decriptografar os dados e criptografar novamente.
Com o auxílio do aplicativo BouncyCastle e da biblioteca JCE, o núcleo e o módulo de segurança gerenciam todas as chaves dos serviços que utilizam o PBSec.
As chaves criptográficas ficam armazenadas num formato seguro, chamado PKCS12, o qual é um padrão para armazenamento de chaves amplamente difundido.
Limitações do Protótipo Este protótipo está preparado para tratar apenas Criptografia XML.
A forma de geração dos arquivos intermediários não é capaz de contornar outras especificações de segurança, por exemplo autenticação.
Para contornar estas configurações é necessário corrigir o código manualmente.
Seria possível contornar esta deficiência utilizando um codificador automático, como o WSDL2Java contido no framework Axis2.
As limitações do protótipo dificultam o uso em algumas aplicações reais, pois normalmente existem várias outras especificações de segurança e orquestração suplementares, que podem tornar o sistema inoperante.
Outra limitação identificada é que as chaves criptográficas necessitam ser cadastradas no sistema manualmente através de um campo de upload disponível na página.
Esta troca poderia ser automática, o que torna o processo mais seguro e mais simples para o usuário.
Com base no protótipo apresentado neste capítulo, estamos aptos a demonstrar a efetividade do modelo através da sua aplicação num estudo de caso.
O Capítulo 4 apresenta um estudo de caso que utiliza aplicações reais e simula o sistema de uma agência de turismo, onde o sistema é composto por serviços providos por diferentes empresas, como companhias aéreas e, portanto, possuem diferentes pré-requisitos de segurança.
Para testar como um serviço de segurança baseado em proxy pode ser utilizado para construir aplicações Soa de uma maneira mais flexível, nós escolhemos como exemplo o sistema de uma agência de viagens, conforme já utilizado como estudo de caso em.
Este é um sistema típico e apresenta as principais características encontradas em sistemas reais.
Um sistema de agência de viagens normalmente é composto por vários serviços, como por exemplo, cruzeiros marítimos, passagens aéreas, hotéis e restaurantes.
Cada um destes serviços é provido por diferentes empresas.
No caso de as passagens aéreas, podemos ter um serviço disponibilizado por a Tam, outro por a Gol, outro por a Azul e assim sucessivamente.
Esta é, portanto, uma aplicação que tradicionalmente pode caracterizar uma Soa, pois os serviços que compõem a aplicação são disponibilizados por diferentes empresas através de um repositório e de interfaces bem definidas.
A Figura 4.1 representa como seria a estrutura desta aplicação.
Cada número representa uma empresa e cada cor um tipo de serviço:
Os azuis são companhias aéreas, os pretos restaurantes, os verdes hotéis e os laranjas companhias marítimas.
Como cada serviço é disponibilizado por uma empresa, eles possuem políticas de segurança diferentes, uma vez que não há um acordo formal entre as empresas.
Apesar disso, todas as interfaces são descritas com WSDL e as políticas de segurança com Ws--Policy seguindo o padrão Web Service.
Esta figura ilustra uma implementação similar existente no mercado, em a qual a implementação apresentada na Seção 4.1 será baseada.
As principais dificuldades em desenvolver uma aplicação baseada em Soa são a confiabilidade dos serviços e as diferentes políticas de segurança.
Relacionado diretamente com o nosso trabalho, devemos lidar com as diferentes tecnologias empregadas para proteção de dados, vários protocolos de criptografia, vários tokens de autenticação, entre outras.
Cada empresa é livre para escolher o que deseja exigir para a utilização do seu serviço.
Por exemplo, para integrar aplicações utilizando diferentes algoritmos para Criptografia XML é necessário tratar de cada algoritmo separadamente, gerando uma maior codificação.
Implementação A implementação do estudo de caso é composta por 3 serviços:
Um serviço (reserva de quartos) sem criptografia, disponível na Internet, um serviço (pagamento) com outras formas de segurança, como autenticação, disponível na Internet e um serviço com criptografia (reserva de passagens aéreas) desenvolvido para testes juntamente com o protótipo.
Estes serviços são providos por as seguintes empresas:·
Paypal: Fornece o seu serviço de pagamento também em forma de Web Service.
Este serviço faz parte da API de testes Sand
Box, a qual não tem valor real.
É possível acessar a sua descrição em:·
Hotel. De:
O site europeu Hotel.
De fornece o serviço de reserva de quartos para uma variedade de hotéis em diferentes cidades e países europeus.
A descrição do seu serviço está disponível em:·
Próprio: O Serviço de passagens aéreas foi desenvolvido em conjunto com o PBSec e é disponibilizado localmente na rede de testes.
A aplicação foi implementada em PHP para que pudesse ser utilizado através de um navegador Web, conforme a maioria dos portais de agencias de viagens.
Através desta página, o usuário é capaz de verificar a disponibilidade de hotéis e voos, adicionando ao seu &quot;carrinho de compras «os destinos desejados.
Após selecionar todos os dados necessários, é possível efetuar o pagamento, condicionalmente, se o pagamento for confirmado são liberadas as reservas.
Cadastro dos Serviços Para a utilização do PBSec, o primeiro passo é cadastrar os serviços desejados no sistema.
O cadastramento de serviços é relativamente simples, uma vez que se baseia principalmente no upload do arquivo de descrição de interfaces wsdl.
Com os serviços implementados podemos cadastrar- los no PBSec.
O primeiro serviço a ser castrado é o responsável por os hotéis.
A Figura 4.2 mostra a tela de retorno do sistema, imediatamente após o serviço ter seu arquivo de descrição de interfaces enviado e processado por o sistema.
Ainda podemos ver na Figura 4.2 que o serviço de reserva de quartos de hotéis se chama &quot;FreeHotelSearchWebService «e é composto por 14 métodos, os quais permitem ao usuário buscar hotéis disponíveis para uma determinada cidade, verificar a disponibilidade de quartos para cada hotel, entre outros métodos.
O segundo serviço cadastrado foi o serviço responsável por os pagamentos.
A Figura este serviço.
O serviço disponibilizado por a PayPal originalmente se chama &quot;PayPalAPIInterfaceService «e é composto por 48 métodos, sendo que apenas alguns destes aparecem listados na figura.
Entre as ações possíveis está efetuar pagamentos, pesquisar por pagamentos efetuados anteriormente, entre outros.
O último serviço a ser cadastrado foi o responsável por a reserva de passagens aéreas.
De a mesma forma como nas figuras anteriores, a Figura 4.4 apresenta os dados do arquivo de descrição de interfaces.
O serviço originalmente se chama &quot;FlightCompany «e é uma simplificação de um serviço real, sendo que este é composto por 3 métodos que permitem a busca por passagens, a busca por os valores e a reserva das mesmas.
Resultados Os resultados apresentados a seguir são baseados em testes realizados a partir de a implementação do estudo de caso e tem como objetivo analisar o overhead gerado por a inclusão do PBSec.
Os serviços foram executados considerando a infra-estrutura apresentada na Figura 4.5.
Considera- se como a primeira parte da conexão, o trecho entre o cliente e o sistema PBSec;
Consequentemente a parte entre o PBSec e o serviço final será chamada de segunda parte.
Para garantir a confiabilidade dos resultados foi utilizada a técnica de amostragem sim-ples.
Foram realizadas 1000 execuções com cada teste.
Com base nestes resultados foi calculado o desvio padrão, margem de erro, confiabilidade e tamanho da amostra.
Entre os 1000 resultados, o tamanho da amostra foi escolhido aleatóriamente através de um algoritmo de sorteio de números pseudo-randômicos.
Os resultados apresentados possuem uma confiabilidade de 95% e margem de erro de 5 milissegundos para mais ou para menos.
Os serviços foram testados individualmente, negociando diretamente com o serviço e utilizando o PBSec como sistema intermediário.
Todos os resultados estão expressados em milissegundos.
A Figura 4.6 apresenta os testes realizados apenas entre clientes e servidores, sem o PBSec.
A partir de isto, podemos estabelecer um parâmetro de qual seria o tempo de resposta dos serviços caso tenham sido implementados da maneira convencional, de forma a permitir que estes dados sirvam de base para o cálculo do overhead gerado por o PBSec.
A Tabela 4.1 apresenta estes mesmos valores e os seus dados estatísticos, como desvio padrão, confiabilidade e margem de erro.
Os testes foram separados em etapas, conforme as suas variações:·
Sem Criptografia -- A primeira parte da comunicação (entre o cliente e o PBSec) sem criptografia.·
Com Criptografia RSA -- Com a primeira parte da comunicação com criptografia RSA de 1024 bits.·
Com Criptografia DSA -- Com a primeira parte da comunicação com criptografia DSA de 1024 bits.·
Com Criptografia ECDSA -- Com a primeira parte da comunicação com criptografia ECDSA de 1024 bits.
Considera- se que a segunda parte do processo de comunicação não é possível variar devido as políticas de segurança disponibilizadas por cada empresa provedora dos serviços utilizados.
Também não estão sendo consideradas diferenças entre os algoritmos de criptografia, e.
g uma comunicação criptografada com algoritmo ECDSA de 512 bits seria equivalente a uma comunicação com RSA de 1024 bits.
É considerado apenas o tempo de comunicação para determinado tamanho de chave criptográfica e não a efetividade da força criptográfica entre os algoritmos testados.
Testes Sem Criptografia A Figura 4.7 ilustra os testes realizados com o sistema intermediário PBSec, considerando que a primeira parte da comunicação não utiliza criptografia.
Comparando os resultados apresentados nesta figura com os apresentados na Figura 4.6, podemos calcular o overhead causado por o PBSec.
A Tabela 4.2 apresenta o overhead para os serviços sem possuir a primeira parte da conexão criptografada.
A Tabela 4.3 apresenta os primeiros resultados utilizando o PBSec, tempo de execução, desvio padrão.
Comparativamente com resultados apresentados na Tabela 4.1, podemos perceber um overhead baixo, devido provavelmente ao não uso de criptografia na primeira parte da conexão e também do fato do serviço PBSec estar sendo executando localmente.
Os dados apresentados na Figura 4.8 ilustram os resultados de acesso aos serviços considerando o uso de criptografia RSA com chave de 1024 bits para a comunicação entre o cliente e o PBSec.
Os resultados apresentados na Tabela 4.4 contêm outras informações estatísticas sobre os resultados apresentados na Figura 4.8.
A Tabela 4.5 demonstra o overhead considerando uma conexão com a primeira parte criptografada.
Com base nos dados desta tabela e nos dados apresentados na Tabela comparado a conexão sem criptografia.
A Figura 4.9 demonstra os resultados considerando o uso de criptografia ECDSA com chave de 1024 bits.
A Tabela 4.6 apresenta outras estatísticas sobre os serviços.
A Tabela 4.7 apresenta o overhead da comunicação na primeira parte da conexão, utilizando criptografia ECDSA.
Se comparado com os resultados apresentados na Tabela 4.5, podemos perceber uma diferença de aproximadamente 30 milissegundos, o que ressalta a diferença entre tempos criptográficos entre diferentes algoritmos.
A Figura 4.10, demonstra os resultados considerando o uso de criptografia DSA com chave de 1024 bits.
Em a Tabela 4.8 temos outros dados estatísticos retirados para dos testes, com criptografia DSA.
Tabela 4.9: Overhead Com Criptografia DSA na Primeira parte da Conexão Serviço Tempo (ms) Hotel.
De PayPal FlightCompany Considerações Finais Com base no estudo de caso apresentado neste capítulo e de acordo com as situações propostas inicialmente nesta pesquisa, é possível perceber o impacto de um sistema intermediário no tratamento automático de políticas de segurança.
Pode- se ainda perceber a diferença não só da inserção do PBSec na comunicação, mas também da variação entre os próprios algoritmos de criptografia.
Através da Tabela 4.10, podemos perceber que o overhead causado por o PBSec varia entre 1 e 2 vezes o tempo de uma comunicação direta com o serviço, o que demonstra que a utilização de um sistema intermediário para estes casos não causa um overhead maior que duas vezes o tempo sem o sistema.
Deve- se considerar que estes resultados foram obtidos com o sistema PBSec instalado na mesma rede local que o cliente, o que acaba por minimizar o overhead causado na primeira parte da comunicação.
A situação representada por o serviço FlightCompany, visa demonstrar o uso do PBSec como uma extensão do cliente, onde todos os serviços estão rodando numa rede local, por este motivo os resultados divergem tanto dos apresentados por os outros serviços.
A Tabela 4.11 apresenta um comparativo entre os overheads dos diferentes algoritmos de criptografia testados para o Serviço Hotel.
De, demonstrando a quantidade de vezes que um é mais lento que o outro.
O cálculo é realizado da seguinte forma:
O item da linha X é dividido por o item da coluna Y.
Podemos visualizar nas Tabelas 4.10 e 4.11 que apesar de o overhead total do PBSec não ser superior a duas vezes o tempo normal, a diferença entre ter criptografia e não ter criptografia pode causar um overhead até cinco vezes maior.
Antes de apresentarmos as conclusões encontradas durante a pesquisa, é importante fazer algumas considerações quanto a os testes realizados no estudo de caso.
A implementação do estudo de caso apresenta limitações ao utilizar serviços reais, sendo que alguns dos serviços testados não funcionaram, devido a outras características de segurança não suportadas por o protótipo do PBSec.
O problema inicial foi encontrar serviços gratuitos com as características desejadas, os principais serviços encontrados são pagos.
O serviço Web Services para pesquisa e compra de passagens aéreas da Tam, é pago;
O serviço de cotações da bolsa é pago;
Alguns serviços de hotelaria pesquisados também eram pagos, o que acabou por inviabilizar a utilização destes.
Por este motivo, que serviços de testes (estes serviços são muito similares a suas versões pagas) foram adotados, como a API Sand
Box do PayPal e o serviço de passagens aéreas, desenvolvido em conjunto com o protótipo com o propósito de ser um serviço para testes iniciais.
Com base nos resultados apresentados ao longo de esta seção, podemos começar a realizar um comparativo entre as hipóteses levantadas inicialmente na Introdução e os resultados encontrados, demonstrando a efetividade ou não da pesquisa e do modelo proposto, estes comparativos são apresentados no Capítulo 5, neste mesmo capítulo também são apresentadas possibilidades para a expansão deste trabalho.
Uma vez coletados os dados durante testes realizados com o estudo de caso e apresentados na Seção 4.2, puderam ser realizadas as respectivas análises, obtendo- se os resultados que permitiram chegar ao seguinte conjunto de conclusões.
O presente trabalho utilizou como guia as seguintes hipóteses:·
Sistemas baseados em Soa possuem diversos algoritmos de criptografia que dificultam o desenvolvimento de aplicações clientes, principalmente por diferentes empresas possuírem diferentes políticas de segurança.·
Pode- se facilitar o desenvolvimento de aplicações clientes, através da automatização do processo de segurança através de um intermediário auto-customizável.·
Um sistema intermediário pode ser utilizado para automatizar políticas de segurança possuindo um aumento aceitável no tempo de resposta do serviço.·
O algoritmo de criptografia possui uma importância significativa no tempo de resposta de um serviço criptografado.
A o realizar uma avaliação considerando as hipóteses levantadas e os resultados obtidos, cada hipótese será abordada individualmente e os resultados serão utilizados para justificar as conclusões apresentadas.
Conforme o levantamento bibliográfico realizado e apresentado no Capítulo 2, é proposta da arquitetura Soa que as aplicações sejam compostas por serviços disponibilizados por diferentes empresas.
Cada empresa é responsável por prover/ requisitar segurança ao seu serviço, tendo em vista a existência de uma variedade muito grande de formas de se proporcionar segurança e que cada empresa pode adotar a sua sem restrições.
Mesmo utilizando Web Services para desenvolver seus serviços, a tarefa de integrar serviços pode ser considerada relativamente complicada.
A dificuldade na codificação e na manutenção de aplicações podem acabar determinando a profundidade da adoção da arquitetura ou modelo.
Este trabalho teve como um dos seus objetivos avaliar a hipótese que questiona se seria possível facilitar o desenvolvimento de aplicações clientes através de um serviço intermediário capaz de se adaptar automaticamente as características de segurança envolvidas, especificamente algoritmos de criptografia assimétricos.
Com base também nos trabalhos relacionados apresentados na Seção 2.4, outras pesquisas semelhantes apontam a possibilidade de auto-customização de características de serviços com base em sistemas intermediários.
Desta forma, foi proposto um modelo e elaborado um protótipo, apresentados no Capítulo 3, que demonstram a efetividade deste tipo de abordagem.
Com a confirmação desta hipótese, pode- se partir para a seguinte, a qual trata sobre a viabilidade de se empregar um sistema intermediário para tratar das características de segurança em aplicações Soa.
Com base nos resultados apresentados na Seção 4.2, principalmente na Tabela 4.10, podemos verificar que o overhead causado por o PBSec é de no máximo o dobro do tempo normal de resposta, o que significa que, para aplicações onde a demanda não é muito grande e o tempo de resposta da aplicação é variavel, esta abordagem é válida.
Finalizando a análise das hipóteses, pode- se afirmar que, a partir de a última hipótese, que trata da influência dos algoritmos de criptografia no tempo de resposta do serviço, podemos verificar na Seção 4.2, mais especificamente na Tabela 4.11, que existe uma variação entre os algoritmos de criptografia testados, mas que esta variância é sutil, algo entre 0,7 a 1,3 vezes mais rápidas que as outras.
Em esta hipótese, podemos ressaltar que a maior diferença no tempo de overhead é entre serviços com e sem criptografia.
Esta diferença pode aumentar o tempo de overhead de 3,8 a 5,5 vezes mais, apenas adicionando criptografia.
Ainda podemos afirmar que, entre os algoritmos testados, o que teve o melhor desempenho na questão menor tempo de resposta para criptografia com uma chave de 1024 bits foi o DSA, com um tempo 1,0076 vezes maior que o tempo da comunicação direta entre o cliente e o serviço.
Cabe dizer que este tempo somado ao desempenho normal é característico em todas as soluções que envolvem proxys, este custo pode aumentar conforme a demanda sobre o sistema.
Cabe ressaltar que as diferenças de overhead nos testes com PBSec e sem PBSec não são grandes devido a o fato de que o PBsec está na mesma rede dos clientes.
Se estivessem em redes diferentes o impacto seria maior.
Entretanto, o cliente pode instalar o PBSec na sua rede local para facilitar a implementação da sua aplicação, melhorando assim o tempo de resposta do sistema.
Além de a análise das hipóteses é possível comparar o modelo proposto com outros modelos já existentes e abordados no Capítulo 2.
Dentro de o principal framework de segurança para Web Services há uma sub-especificação, o Ws--Trust, que é responsável por garantir que os serviços possuam os requisitos de segurança solicitados por o servidor.
Comparativamente com o PBSec, eles não realizam exatamente a mesma função, o Ws--Trust poderia ser parte do PBSec verificando as políticas de segurança solicitadas, porém ele não seria capaz de realizar a conversão entre diferentes políticas, função esta que viabiliza a comunicação entre serviços com diferentes pre-requisitos.
Outra comparação interessante que pode ser realizada, é com o artigo analisado na Seção 2.4.
Este é um trabalho muito similar ao que foi proposto por a nossa dissertação.
Porém, apesar de ser um software intermediário é necessário ter acesso ao cliente e ao servidor para que o serviço possa funcionar, visto que a sua implementação prevê a captura do fluxo de dados das placas de rede.
Não existe o cadastro prévio dos serviços, sendo que desta forma é necessário estar nas duas pontas para efetuar as conversões.
Estas limitações acabam inviabilizando o seu uso em ambientes reais, onde os serviços são providos por terceiros e não se tem acesso ao lado de o servidor.
Por estar em ambos os lados o modelo apresentado neste artigo, prima por a automatização do processo, visto que um cadastro não é necessário.
Apesar de funcionar de maneira diferente do PBSec, a idéia básica por trás do modelo é a mesma, corroborando a sua usabilidade.
Com base nos resultados apresentados, podemos confirmar a efetividade do modelo.
Demonstrando a sua viabilidade através de testes de desempenho, deve- se considerar que a força criptográfica dos diferentes algoritmos não foi considerada.
Ainda é possível efetuar melhorias no protótipo e estender o modelo a outros casos.
Podemos citar como possíveis trabalhos futuros a extensão do modelo para tratamento de características de autenticação, como diversos tokens existentes.
Pode- se ainda estender a quantidade de algoritmos de criptografia suportados, aumentando desta forma a abrangência do protótipo já existente.
Entre melhorias diretas no protótipo, o processo de cadastramento e geração dos serviços intermediários através do arquivo de descrição da interface do serviço pode ser melhorado, incluindo uma nova abordagem para tratar de exceções.
Atualmente, as exceções devem ser contornadas manualmente, o que diminui a usabilidade do protótipo.
Tendo em vista ainda estender a análise com os dados já coletados, é possível considerar as forças criptográficas de diferentes algoritmos através da realização de uma comparação diferente entre estes.
Para exemplificar esta situação, podemos considerar que supostamente um algoritmo DSA de 1024 bits possui a mesma força criptográfica que um ECDSA de 512 bits.
Desta forma, poderia ser estabelecida uma comparação entre equivalência entre estes dois algoritmos, demonstrando realmente qual é o mais eficiente e rápido.
