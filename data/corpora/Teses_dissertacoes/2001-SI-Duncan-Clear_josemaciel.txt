Este trabalho, apresenta uma solução para mapeamento do comportamento de objetos, expresso através de diagramas de estados da UML para Bancos de Dados Relacionais fazendo uso do mecanismo de gatilhos.
Gatilhos em bancos de dados permitem a implementação de regras Evento ­ Condição ­ Ação (ECA) fazendo com que tais SGBDs ofereçam funcionalidades típicas de Bancos de Dados Ativos.
Por outro lado, os métodos de projeto de bancos de dados consideram, em sua maioria, que somente as propriedades estáticas são passíveis de serem implementadas no modelo de descrição do SGBD relacional escolhido.
Com isso, as propriedades dinâmicas das aplicações ficam necessariamente implementadas nos programas aplicativos.
A solução aqui apresentada considera que pelo menos as propriedades dinâmicas intra-objetos têm condições de serem implementadas adequadamente através de gatilhos, através da definição de padrões de implementação e regras de mapeamento.
Tais propriedades são descritas em UML através de Diagramas de Estados.
A contribuição desta pesquisa está no fato que uma maior parcela da realidade modelada pode ser implementada no respectivo banco de dados da aplicação e gerenciada por o correspondente SGBD, aliviando o volume de programação na aplicação e tornando tal banco de dados mais auto-suficiente.
Palavras-Chave: Bancos de Dados Relacionais, Bancos de Dados Ativos, Gatilhos, UML.
Durante as três primeiras décadas da era da computação, o desafio primário era desenvolver hardware que reduzisse o custo do processamento e armazenamento de dados.
A partir de a década de 80, avanços na microeletrônica resultaram em maior poder de processamento e de armazenamento a custos decrescentes.
Hoje o problema é diferente.
O desafio primário é reduzir o custo e melhorar a qualidade das soluções baseadas em computador -- soluções que são implementadas em software.
O paradigma da orientação a objetos, aplicado à Engenharia de Software, propõe- se a contemplar as necessidades de aumento de qualidade e produtividade no processo de desenvolvimento e manutenção de software e busca ocupar o lugar de sucessor dos métodos de análise e projeto estruturados.
Em apenas três anos, a Unified Modeling Language -- UML, emergiu como a linguagem dominante na indústria de software, tendo sido adotada recentemente por a OMG como um padrão para modelagem de objetos.
A UML oferece um conjunto de ferramentas notacionais que permitem representar e especificar sistemas de informação.
Em esse sentido, observa- se uma crescente utilização do paradigma Orientado a Objetos e, portanto, da UML, na modelagem de sistemas com persistência de dados.
Para obter tal persistência recomenda- se a utilização de alguma das tecnologias disponíveis para gerenciamento de dados.
Os Sistemas Gerenciadores de Bancos de Dados Orientados a Objetos representam a abordagem aparentemente mais indicada para a implementação de tais sistemas pois compartilham conceitos semelhantes dentro de o paradigma.
Entretanto, a abordagem Relacional para Banco de Dados é atualmente o padrão de fato para armazenamento de dados de pequenas a grandes corporações, por diversos motivos:
A necessidade de manter operacionais os bancos de dados legados e é uma tecnologia que vem sendo testada há vários anos e é, consequentemente, bem compreendida.
Uma evolução importante destes sistemas são os Bancos de Dados Objeto--Relacionais que conservam as propriedades dos consolidados sistemas relacionais e incorporam algumas características de linguagens orientadas a objetos.
Porém, essas características ainda são pouco utilizadas se comparadas com a base relacional instalada.
A perspectiva é de que os sistemas ObjetoRelacionais sejam a próxima grande onda da tecnologia de bancos de dados.
Mapear objetos para o modelo relacional é um problema que ocorre à medida em que projetistas de software usam modelos orientados a objetos no projeto do software e usam sistemas de banco de dados relacionais para prover a persistência dos dados.
A causa deste problema é o fato do paradigma orientado a objetos e o modelo relacional serem conceitualmente bastantes distintos.
Diversos autores têm se dedicado a descrever como efetuar a tradução de objetos para o modelo relacional sob diversas formas, e, mais recentemente, usando o formato de linguagens de padrões.
A grande maioria dos trabalhos possui atenção centrada somente aos modelos estáticos como.
Outros poucos trabalhos referem- se ao mapeamento comportamental, como que descreve o mapeamento do modelo dinâmico de objetos para uma linguagem orientada a objetos.
Outra proposta importante é que descreve uma linguagem de padrões genérica para mapeamento de diagramas de estados numa linguagem orientada a objetos.
Devido a crescente utilização da UML para modelagem de sistemas orientados a objetos, considera- se como importante o estudo de métodos de mapeamento de modelos UML para implementações em Banco de Dados especialmente no que se refere ao mapeamento de propriedades dinâmicas descritas por diagramas de estados.
Acredita- se que o mapeamento destas propriedades para o Banco de Dados permitirá que este torne- se seletivo com relação as modificações que lhe forem impostas, aceitando somente aquelas que tenham sido previamente modeladas e, consequentemente, consideradas adequadas.
Acredita- se que o mapeamento de modelos de comportamento é de grande valor para o projeto de bancos de dados, pois dessa forma pode- se acrescentar ao mesmo a semântica que de outra forma estaria presente somente nos programas da aplicação que manipulam estes dados.
Outras vantagens que podem ser obtidas com o uso do mapeamento são a agilidade na construção de aplicações com Banco de Dados, maior integridade dos Domínios de atributos e melhor representação da realidade nos programas da aplicação.
O objetivo deste trabalho foi desenvolver um método para auxiliar os projetistas de aplicações que utilizam diagramas de estados da UML para modelagem de propriedades dinâmicas, na tarefa de mapeamento destes modelos para implementação em bancos de dados relacionais.
Para tornar isso possível, foi utilizado o recurso de gatilhos existente em Bancos de Dados que estão em conformidade com o padrão SQL/ ANSI, como é o caso do Banco de Dados Oracle 8i release 8.0.5, que foi utilizado na etapa de validação de nosso método e na elaboração dos exemplos que estão presentes neste trabalho.
O restante deste documento está organizado como segue:
O Capítulo 2 apresenta um estudo sobre os recursos notacionais oferecidos por a UML para modelagem de estados de objetos;
Em o para implementação;
O Capítulo 4 discute os conceitos necessários ao entendimento do processo de mapeamento de diagramas de estados para implementação em gatilhos de um Banco de Dados Relacional;
Em o Capítulo 5 é apresentada a solução para mapeamento de diagramas de estados;
Em o Capítulo 6 demonstrado um estudo de caso da utilização de nossa solução de mapeamento e por fim, o Capítulo 7 apresenta a devidas considerações finais, conclusões e futuros trabalhos envolvendo este tema.
Sistemas de informação possuem aspectos estáticos e dinâmicos.
Em a notação UML[ RAT 99], os aspectos estáticos são representados por modelos de classes que descrevem os tipos de entidades de um sistema e seus relacionamentos entre si.
Por sua vez, os aspectos dinâmicos ou de comportamento do sistema se referem às modificações ocorridas nos objetos e seus relacionamentos em relação a o tempo.
Para representar este comportamento são utilizados diversos pontos de vista de representação, sendo que a grande parte das abordagens envolve os conceitos de estados, eventos, operações e interações, representados em diagramas de estados.
Os diagramas de estados fornecidos por a UML buscam representar o comportamento de entidades, bem como a seqüência de estados por o qual um objeto em particular pode passar durante o seu ciclo de vida.
Sua semântica e notação é baseada na notação denominada Stecharts definida por que, por sua vez, fundamenta- se na Teoria dos Autômatos Finitos.
Um estado é uma situação durante a vida de um objeto em o qual ele satisfaz alguma condição, executa alguma ação ou aguarda por algum evento.
Pode- se subdividir estados em ativos e passivos.
Um estado é dito inativo ou passivo quando está determinado por um conjunto de valores que com o decorrer de tempo não mudam.
Já um estado é dito ativo quando o objeto está envolvido em algum tipo de processo e mudanças no valor de um ou mais atributos podem ocorrer.
Uma transição de estados de um objeto corresponde à ocorrência de determinadas mudanças nos valores de seus atributos, de forma que o novo conjunto de valores passa a caracterizar um outro estado predeterminado do objeto.
Tais transições refletem os acontecimentos que podem ocorrer tanto dentro como fora de os objetos e são denominadas eventos.
Para modelagem do comportamento de um sistema, estes eventos devem ser identificados, principalmente os que produzem transições, bem como as seqüências consideradas corretas em que eles ocorrem.
A seguir, são abordados os diversos recursos notacionais oferecidos por os diagramas de estados apresentados por a UML versão 1.3.
Em a notação UML, um estado é representado por um retângulo com os cantos arredondados com o seu respectivo nome no centro, como demonstra a Figura 1.
Pode- se, opcionalmente, subdividir estados em compartimentos separados por uma linha horizontal.
Esses compartimentos poderão conter as seguintes informações:
Nome do estado:
Este compartimento contém o nome (opcional) do estado;
Transições internas:
Este compartimento contém uma lista de ações ou atividades internas que deverão ser executadas enquanto o objeto estiver no atual estado.
A notação para cada um destes itens deverá seguir o seguinte formato:
Nome da Ação`/' expressão da ação O Nome da ação especifica o evento que dispara a correspondente Expressão de ação.
Algumas descrições de ações são reservadas para objetivos especiais e não deverão ser usadas como nomes de eventos.
São elas:
Entrada: Esta ação especifica que a correspondente expressão de ação será executada ao entrar no estado (ação de entrada).
Saída: Esta ação especifica que a correspondente expressão de ação será executada ao sair do estado atual (ação de saída).
Faça: Especifica que a correspondente atividade que deverá ser executada.
Em todos os outros casos, a descrição da ação identifica o evento que dispara a correspondente expressão de ação.
O formato geral para um evento é:
Nome do evento`(` lista de parâmetros')'`' Para exemplificar o uso de compartimentos em estados, é apresentado na Figura 2 um estado possuindo dois compartimentos, um destes contendo o nome do estado e o outro contendo as transições internas do mesmo.
Para representar as transições de estados, utiliza- se linhas com setas indicando o sentido em que ocorre a transição.
As setas devem ser rotuladas com o nome do evento que causou a transição de estado.
Opcionalmente, pode- se acrescentar uma condição de guarda para esta mudança de estado que deverá aparecer entre colchetes.
Dois tipos de estados especiais tem notações específicas:
Estado inicial e estado final.
Um estado inicial é indicado por um círculo preenchido e o estado final representado por dois círculos concêntricos, sendo que o interno é totalmente preenchido e o externo é vazado.
Um exemplo de uso desta notação para estado inicial e final é mostrada na Figura 3, onde uma transição simples de um estado A para um estado B, causada por um evento y, ocorre somente se a condição especificada juntamente com o evento for verdadeira no instante da ocorrência.
Uma ação vinculada ao evento poderá também ser opcionalmente especificada.
Os recursos de agrupamento ou abstração permitem ao analista representar o comportamento de objetos a partir de vários níveis de abstração, bastante úteis para compreender o comportamento global do sistema.
Um estado também pode conter sub-diagramas de estados agrupando transições e eventos.
A divisão em níveis ou agrupamentos está baseada no conceito de higraphs que por sua vez incluem noções provenientes dos Círculos de Euler, Diagramas de Venn e hypergraphs O agrupamento consiste em capturar transições comuns entre vários estados e então originar um super-estado.
Para exemplificar este mecanismo, pode- se observar a Figura 4, que mostra um diagrama de estados composto dos estados A, B e C, sendo que os estados A e C compartilham um mesmo evento w que leva a uma transição para o estado B. Portanto, pode- se agrupar os estados A e C para que compartilham um mesmo evento w, formando um super-estado D e substituindo duas transições w por uma única transição, conforme demonstra a Figura 5.
Pode- se também afirmar que o novo estado D corresponde a uma abstração dos estados A e C. A semântica de um conjunto de estados agrupados é a do ou- exclusivo (XOR) dos estado componentes.
No caso de o exemplo acima, a semântica do estado D será a do ou- exclusivo de A e C, ou seja, para estar no estado D, o sistema deve estar ou no estado A, ou no estado C, e não em ambos.
Um estado padrão indica o primeiro estado a ser visitado entre um subgrupo de estados.
Para representar um estado padrão é utilizado um círculo preenchido com uma pequena seta apontada para o estado inicial como mostrado na Figura 6 (a).
No caso de o uso de agrupamento ou abstração, pode ainda ser utilizada a notação da Figura 6 (b) ou ainda, a forma em dois passos apresentada na notação da Figura 6 (c).
Esta última representação significa que B é o estado padrão de entre um grupo de estados e A é o estado padrão entre um subgrupo de estados de B. Outra forma de estado padrão utiliza o conceito de história de estados num grupo de estados.
Este conceito utiliza o mecanismo &quot;entre- por a história», ou seja, será visitado o estado mais recentemente acessado de um grupo de estados.
É representado por uma seta apontando para um pequeno círculo contendo a letra H em seu centro e se aplica somente no mesmo nível em que for encontrado o símbolo de história de estados.
Em a Figura 7 (a) demonstra- se um diagrama de estados, onde é aplicada a história ao nível do super-estado K que por sua vez, contém mais dois super-estados G e F. O sistema deverá entrar no estado B se o super-estado G tiver sido o último a ser visitado.
Caso o super-estado F tenha sido o último super-estado visitado, o sistema deverá entrar no último sub-estado visitado entre C, D e E ou em C caso seja a primeira entrada em F. Outra forma de utilização de história em estados é aplicação do mecanismo em todos os subníveis a partir de onde se encontra o símbolo de história.
Em a Figura 7 (b) pode- se observar o símbolo de história acrescido de um asterisco(*) significando que a história será aplicada em todos os subníveis a partir de onde ela se encontra.
De essa forma, o sistema irá entrar no mais recente estado visitado entre A até E sobrepondo todos os estados padrão.
A ortogonalidade é um mecanismo utilizado para dividir um estado de acordo com seus subsistemas.
A notação utilizada para representar a ortogonalidade é a divisão dos retângulos em componentes usando linhas tracejadas, conforme demonstra a Figura 8.
A semântica de um conjunto de estados ortogonais é a da decomposição &quot;E «(And).
Isto significa que, estando o sistema num estado, ele deverá estar em todos os seus componentes.
O mecanismo de ortogonalidade é exemplificado através da Figura 8, que nos mostra um estado Y consistindo de dois componentes A e D. Estando em Y, o sistema pode estar em alguma combinação de B ou C com E, F ou G. Por isso, Y pode ser chamado o produto ortogonal de A e D. Quando o sistema entra no super-estado Y, na falta de informação, o superestado Y inicia com a combinação (B, F) no seu interior através dos estados padrão.
Caso um evento venha a ocorrer, o sistema irá transferir do estado B para C e F para G simultaneamente, resultando numa nova combinação de estados (C, G).
Este exemplo ilustra um certo tipo de sincronização, ou seja, um único evento causa duas ações simultâneas em componentes ortogonais do mesmo super-estado.
Por outro lado, na ocorrência de um evento µ num estado inicial (B, F) acarretaria uma ação somente do componente D, resultando em (B, E), o que ilustra independência.
Ambos comportamentos são parte da ortogonalidade de A e D, que é o termo usado para descrever uma decomposição &quot;E».
Diagramas de estado constituem uma poderosa ferramenta para descrição do comportamento reativo de objetos.
Sua notação compacta e expressiva é apropriada para a descrição de sutilezas do comportamento de objetos componentes dos mais diversos tipos de sistemas de software e até mesmo de hardware.
Em este capítulo buscou- se sintetizar os recursos oferecidos por a notação de diagramas de estados, de forma a criar os alicerces necessários à discussão sobre o mapeamento destes diagramas para implementação.
O Capítulo a seguir irá discorrer sobre o estado da arte com relação a mapeamento destes modelos.
Depois de apresentar as principais características dos Diagramas de Estados bem como os seus diversos recursos de representação de comportamento de sistemas, este capítulo objetiva apresentar o estado da arte no que se refere ao mapeamento de modelos de comportamento de objetos para implementação.
Poucos autores se dedicaram a estudar mecanismos de implementação de modelos dinâmicos.
Os mais relevantes são o trabalho de Rumbaugh, que descreve como implementar um modelo dinâmico numa linguagem orientada a objetos e o trabalho de Yacoub, que por sua vez apresenta uma linguagem de padrões genérica para mapeamento de diagramas de estados, compartilhando dos mecanismos e conceitos apresentados anteriormente no trabalho de Rumbaugh.
Apresentaremos na seção seguinte uma síntese da proposta de implementação de modelos dinâmicos apresentada por Rumbaugh.
Segundo Rumbaugh, converter um modelo de objetos para um conjunto de declarações numa linguagem tipicamente orientada a objetos é relativamente simples para muitos programadores.
O fato é que declarações de classe correspondem diretamente a modelos de objetos porque as linguagens fornecem sintaxe para declarar- las juntamente com seus atributos e operações.
Associações podem ser implementadas como objetos isolados ou ponteiros de objeto para objeto.
Linguagens podem apresentar diferenças em detalhes de herança, criação de objetos e metaclasses.
No entanto, ocorre uma certa dificuldade por parte de os programadores em implementar um modelo dinâmico.
Alguns motivos para isso são:
O fato de que a maioria das linguagens não fornece suporte sintático para declaração de propriedades dinâmicas dos dados e a inabilidade da maioria dos programadores no entendimento de diagramas de estados.
Para facilitar a implementação do modelo dinâmico, o autor considera útil pensar no projeto de uma aplicação como contendo três tipos de objetos:·
objetos do mundo real, possivelmente representados como surrogates, que existem independentemente de qualquer aplicação;·
objeto dependentes da aplicação, que representam os aspectos externamente visíveis da aplicação;·
objetos internos de implementação puramente arbitrária e invisíveis ao mundo externo.
Os objetos dependentes da aplicação incluem:
Os surrogates são, portanto, objetos passivos utilizados internamente num sistema para representar objetos do mundo real e perceber as mudanças ocorridas neste objetos.
Os mesmos não deverão ser confundidos com objetos do mundo real pois estes geram eve ntos e possuem comportamento autônomo enquanto os surrogates, internos a uma aplicação, não geram eventos, mas meramente respondem a eles.
Os surrogates são portanto objetos passivos possuindo diagramas de estado que irão representar as mudanças experimentadas por os seus &quot;sósias «do mundo externo, mas ele não controlam a aplicação.
O controle de aplicação, por sua vez, está alojado nos controladores.
Um controlador é a interface entre um ator externo (como um usuário, por exe mplo) e a aplicação.
O propósito de um controlador é representar o controle de uma aplicação, portanto seu modelo dinâmico é muito importante.
Em a maioria dos casos as aplicações possuem um único controlador.
Uma aplicação deve ter diversas partes independentes e cada linha independente de controle deve ter um controlador.
As subseções abaixo abordam duas possibilidades distintas de implementação do comportamento de objetos que são o uso de um interpretador de diagrama de estados e a abordagem que considera estados como objetos.
Esta abordagem de implementação consiste em representar o diagrama de estados como uma tabela e escrever um programa interpretador para &quot;executar- la».
Em a Figura 9 é apresentado o modelo de objetos para o interpretador de máquina de estados, onde pode ser observada uma associação superestado-subestado que define uma árvore de estados onde cada subestado herda as transições de seus superestados.
Cada estado possui então uma tabela de transições indexada por o nome do evento, sendo que estas transições, por sua vez, possuem uma ação que pode ser executada e um próximo estado.
Todos os eventos são processados por a operação handleEvent no objeto controlador.
Esta abordagem para implementação de controle aproveita o mecanismo de h erança de uma linguagem orientada a objetos para encontrar transições.
Transições relacionam- se com estados num diagrama de estados exatamente como operações relacionam- se com classes num diagrama de objetos.
Para descrever e exemplificar a implementação de um modelo dinâmico, o autor utiliza um sistema de correio eletrônico para mensagens de voz.
A subseção a seguir apresenta os diagramas resultantes da modelagem deste sistema, iniciando com a descrição geral do mesmo.
Esta seção visa apresentar os respectivos diagrama de objetos e diagrama de estados, mostrados na Figura 10 e Figura 11 e descrever o funcionamento geral do sistema de Correio para Mensagens de Voz. Conforme
pode- se observar nas referidas figuras, as classes de domínio são MailCenter, Mailbox e Message e as classes da aplicação são Controller e AudioDevice.
Start de o:
Play Introduction Quit de o:
Disconnect Main current message[ more messages] Send Message Play Instructions Messages Waiting Em o Messages de o:
Play instructions Record Message de o:
Record&amp; or 2 min..
Address Message address: String entry/ reset address digit/ add to address exit/ deliver message Review Message 5/ properties 7/ erase message get next message Play Message de o:
Play message 1/ back 10 sec.
Paused 9/ save message 3-3 or message done Dispose Message 1-1 or 4/ restart message 1/ back 10 sec.
O sistema tem por objetivo receber ligações enquanto o usuário está fora, gravar as mensagens deixadas e permitir que ele as ouça quando voltar.
Para isso o sistema possui diversas &quot;caixas de correio», uma para cada linha telefônica.
Mesmo quando o usuário está, mas não responde as chamadas manualmente, o sistema responde a chamada e adiciona a mensagem, se esta for deixada, na caixa de correio do usuário.
O usuário pode acessar o sistema e abrir a sua caixa de correio através do próprio telefone, usando o teclado numérico.
Para entrar no sistema, o usuário deve teclar sua senha e então poderá escolher entre verificar mensagens e enviar uma mensagem (pressionar a tecla nº 2).
Enquanto uma mensagem está sendo executada algumas opções tornam- se operantes conforme demonstra a Tabela 1.
Pausar a execução da mensagem até pressionado novamente o botão 2 Avançar a mensagem 10 segundos Executar a mensagem mais devagar Fornecer informações sobre o remetente, data e duração da mensagem Executar a mensagem mais rápido Executar mais baixo Executar mais alto Avançar para a próxima mensagem Retornar ao menu principal Reiniciar a execução da mensagem corrente Avançar ao fim da mensagem Toda vez que uma mensagem é executada o usuário pode escolher o destino que ela terá.
Quando recebe uma mensagem, o sistema primeiramente dá instruções e a seguir inicia a gravação da mensagem, que terminará quando for pressionado o botão&amp; ou 2 minutos tenham transcorrido.
O usuário então tecla o endereço da caixa de correio e após pressiona o botão&amp; para a mensagem ser enviada.
Partindo dos diagramas de objetos e de estados do Sistema de Correio por Voz, é elaborado um modelo de implementação de estados como objetos, demonstrado na Figura 12, que correspondente ao diagrama de estados mostrado na Figura 11.
Este modelo é elaborado mapeando- se cada estado para dentro de uma classe, sendo que todos os estados são descendentes da classe controlador.
Cada entrada deve ser representada por uma operação como digit3 (pressionado botão 3), mdone (execução da operação finalizada).
Cada evento possível é definido como uma operação vazia no estado raiz que é sobreposta por qualquer subestado que possua uma transição no evento.
São definidas duas operações especiais em cada estado:
Entrar e sair, cada uma executa ações necessárias ­ uma ao entrar e a outra ao sair do estado.
Foi definida uma macro especial GO (uma porção de código para ser expandida como texto por o compilador) que deve ser incluída no código de ação de qualquer transição para um novo estado, com exceção das transições que ocorrem dentro de o mesmo estado que não necessitam de ela.
A macro GO realiza as seguintes tarefas:
Controllerstate: State State Got 1 Main ReviewM Got 3 PlayM MWaiting NoM DisposeM GO (NextM);
Quando 1 é pressionado, a execução da mensagem é paralisada e o controle vai para o estado GOT1 por um décimo de segundo.
Se outro 1 for recebido neste período de tempo, a mensagem retrocedida até o início, caso contrário ela é retrocedida 10 segundos por o método de ajuste.
O estado deve setar um timer ao entrar e destruir- lo se o dígito for recebido primeiro.
Após a transformação dos estado como objetos, o modelo de objetos inicial sofre mudanças de modo que todas as ações invocadas nas transições devem ser implementadas como métodos no controlador.
O diagrama resultante, mostrando uma Classe Controladora mantendo associações com mailbox, current message e audio device, acrescida dos métodos implementando ações invocadas nas transições é apresentado na Figura 13.
Este capítulo apresentou uma síntese do método de mapeamento de um modelo dinâmico para uma implementação numa linguagem orientada objetos apresentada por Rumbaugh.
Em esta proposta, é abordado apenas o mapeamento de um diagrama de estados plano, sendo que o autor também exclui explicitamente o tratamento de atividades.
Embora este método seja efetivo na realização da tarefa de mapeamento, sua complexidade pode ocasionar dificuldade no entendimento e, consequentemente, poderá constituir um obstáculo para sua utilização.
O capítulo a seguir irá discutir os principais conceitos necessários para o entendimento do processo de mapeamento de modelos de comportamento para bancos de dados com o uso de gatilhos.
Após apresentar o estado da arte em mapeamento de modelos dinâmicos para implementação em linguagens orientadas a objetos, este capítulo objetiva discutir conceitos necessários para o entendimento do processo de mapeamento destes modelos de comportamento para bancos de dados relacionais.
A implementação de modelos de comportamento de objetos em bancos de dados relacionais requer, primeiramente, que saibamos como traduzir determinados conceitos da orientação a objetos para a abordagem relacional.
De estes, os principais conceitos a serem compreendidos são os conceitos de estado, evento e transição.
Além destes conceitos fundamentais, é necessário conhecer o processo de transformação de objetos para relações de bancos de dados, de forma que a dimensão estática dos objetos seja bem representada.
As subsecções a seguir abordarão em maiores detalhes cada um destes conceitos.
Um estado é uma situação durante a vida de um objeto em o qual ele satisfaz alguma condição, executa alguma ação ou espera por algum evento.
Partindo do pressuposto que estamos querendo mapear objetos juntamente com o seu comportamento para relações de um banco de dados, esse conceito deverá tornar- se mais específico.
Em esse sentido, um estado pode ser definido como uma abstração dos valores de atributos e ligações de um objeto onde conjuntos de valores são agrupados num estado de acordo com as propriedades que afetam o comportamento geral do objeto.
O modelo relacional constitui- se de um conjunto de relações, onde cada relação é um conjunto de tuplas e cada elemento de uma tupla corresponde a um valor de atributo de um objeto.
Cada atributo possui um domínio, que especifica as características dos dados que poderão ser armazenados.
Um objeto tem, portanto, a definição de seu estado atual baseado nos valores de atributos contidos numa tupla dentro de uma relação.
Cada valor de atributo possui um valor atômico, o qual será enquadrado em subconjuntos de possíveis valores que caracterizam estados predefinidos deste objeto da relação.
As diferentes configurações de valores para os atributos devem ser mutuamente exclusivas.
Isso significa que não poderá haver uma configuração de atributos que poderá ser vista por dois estados distintos.
Caso isso ocorra, poderá haver ambigüidade em relação a os possíveis estados que um objeto pode ocupar num determinado instante do tempo.
Dentro de nossa proposta de mapeamento, um estado é conceituado como uma expressão em lógica, ou um predicado, que permite diferenciar quais são os subconjuntos de valores possíveis para cada um dos atributos, e a combinação destes que irão definir o estado do objeto através de seu conteúdo.
Em a definição do estado atual de um objeto podem também existir atributos cujos valores e as transformações sofridas não sejam importantes, ou não afetem o comportamento do objeto, e que deverão ser ignoradas.
Normalmente, todo atributo tem algum efeito sobre o comportamento, caso contrário perderia o significado em existir.
Mas muitas vezes alguns atributos não afetam o padrão de controle de um objeto.
De a mesma forma, poderão existir determinadas configurações de valores de atributos que não irão caracterizar nenhum estado previsto para o objeto, ou seja, esta configuração de valores não faz parte do subconjunto de valores previsto no diagrama de estados para o objeto em questão.
Em a ocorrência desta situação, o objeto deverá recusar as alterações propostas para seus valores de atributos e permanecer em seu estado atual.
A UML refere- se a um evento como algo que acontece num determinado instante do tempo e é reflexo de alguma ação ocorrida no mundo real, como uma interação do usuário com o sistema, por exemplo.
Em nosso processo de mapeamento, considera- se eventos como sendo subconjuntos de atualizações possíveis autorizadas no instante em que o objeto se encontrar num determinado estado.
Em bancos de dados relacionais as operações de atualização de dados existentes são a inclusão, alteração e a exclusão de tuplas dentro de relações.
Essas operações fazem com que os objetos mudem o valor de seus atributos.
Portanto, tais comandos de atualização podem ser vistos potencialmente como eventos atuando sobre os valores dos atributos contidos numa tupla dentro de uma relação.
Dentro de o processo de mapeamento, operações de atualização ocorrerão levando em consideração o estado atual do objeto e as alterações que estão sendo propostas nos valores de atributos.
Poderão ocorrer três situações distintas:
A) Considerando o estado atual do objeto e as alterações propostas, estas alterações não correspondem a nenhum evento previsto para o objeto em questão.
Isso significa que o novo conjunto de valores proposto não se insere no subconjunto de valores válidos previstos, portanto, não haverá um evento definido que reconheça este tipo de atualização.
Operações de atualização como esta não serão permitidas em nenhum momento por levarem a uma violação na integridade do objeto;
B) Considerando o estado atual do objeto são propostas alterações no valor de determinados atributos que não são significativas para a definição do estado do objeto.
Tais mudanças poderão ocorrer sem no entanto caracterizar a ocorrência de um evento;
C) Estando o objeto num determinado estado, são propostas alterações no valor de atributos que correspondem a um subconjunto de um outro estado predefinido para o objeto em questão.
Isso significa que, o novo conjunto de valores proposto se insere no subconjunto de valores válidos previstos e, portanto, poderá haver um evento definido que reconheça este tipo de atualização Partindo do princípio que os valores de atributos de um objeto definem seu estado, uma mudança no valor de qualquer um destes atributos pode representar uma mudança de estado deste objeto.
Uma mudança ou transição de estado subentende a presença de um evento válido, reconhecido por o estado atual do objeto em questão, que leva este objeto a aceitar uma nova configuração no valor de seus atributos prevista dentro de um subconjunto de configurações possíveis.
A Figura 14 exemplifica uma transição de estado, causada por um evento x, e que ocorre num determinado objeto cujo atributo1 determina o seu estado atual.
Um exemplo de semântica para os estados A e B é a seguinte:
O objeto estará no estado A caso o valor de seu atributo seja igual a zero e estará no estado B caso o valor de seu atributo seja maior que zero.
Um exemplo de semântica para o evento x, causador da transição do estado A para B, pode ser a mudança do valor do atributo de zero para qualquer valor maior que zero.
O modelo de objetos da UML representa os dados em classes persistentes que contém atributos e possíveis relacionamentos com outras classes.
O modelo relacional de banco de dados é composto por uma ou mais tabelas, sendo estas compostas por linhas e colunas.
Chama- se de mapeamento da dimensão estática de objetos ao processo de transformação de uma classe de objetos para relações de banco de dados.
Em esta transformação, colunas serão o equivalente físico aos atributos e linhas serão o equivalente físico a instâncias de objetos.
Diversos autores dedicaram- se a descrever regras ou sugestões para efetuar esta transformação, entre eles.
Heuser apresenta um conjunto de regras bastante abrangente para mapeamento de modelos entidade-relacionamento para banco de dados relacional que podem ser utilizadas neste tipo de transformação, tendo em vista que ambos os modelos de objetos e entidaderelacionamento compartilham de mecanismos semelhantes para representação de atributos.
Rumbaugh, por sua vez, demonstra a realização do mapeamento dos casos mais comuns de diagramas de classes para relações.
Devido a o fato de nossa solução de mapeamento atuar sobre o comportamento de somente um objeto, tornou- se necessária apenas uma abordagem superficial do mapeamento da dimensão estática de objetos para relações de banco de dados.
Portanto, não estamos considerando objetos com atributos multivalorados, nem outras características de modelagens avançadas de objetos.
Para realizar o mapeamento de diagramas de classes mais complexos, recomenda- se a leitura dos trabalhos acima referenciados.
A seguir é apresentada uma síntese da abordagem para mapeamento apresentada por Rumbaugh.
Justifica- se a escolha desta proposta, devido a simplicidade da mesma, e por tratar dos casos mais comuns do mapeamento.
Será usada a notação de atributos sublinhados para representação de chaves primárias das entidade e atributos identificados com sustenido(&amp;) para representar as chaves estrangeiras.
O primeiro passo para implementação da dimensão estática de objetos num banco de dados relacional é bastante direto:
Deve- se traduzir cada objeto para uma tabela com correspondência completa de atributos.
Julgou- se necessário também incluir um atributo identificador do objeto que será mapeado como chave primária e possuirá a finalidade de identificar unicamente cada instância de objeto, representada por uma linha da tabela.
Atributos identificadores num processo de mapeamento de objetos para o modelo relacional são discutidos em detalhes por.
A Figura 15 demonstra uma classe pessoa sendo mapeada para um tabela contendo todos os atributos do objeto com o acréscimo de um atributo identificador.
O código SQL correspondente será:
Create table Pessoa (IDPessoa char (5) not null, nome char not null, endereço char, Primary Key (IDPessoa));
Para mapeamento de associações entre classes de objetos precisamos primeiramente mapear cada uma das classes envolvidas na associação para tabelas relacionais distintas, recebendo cada uma dessas, um atributo de identificação.
A associação com atributos é mapeada para uma tabela de associações que conterá os atributos de associação e sua chave primária será composta por os identificadores dos objetos envolvidos.
Um exemplo deste tipo de mapeamento é mostrado na Figura 16, onde temos a modelagem da relação de trabalho de um empregado com sua empresa.
O código SQL correspondente será:
Create table Pessoa (IDPessoa char (5) not null, nome char not null, endereço char, Primary Key (IDPessoa));
Create table Empresa (IDEmpresa char (5) not null, nome char not null, endereço char, Primary Key (IDEmpresa));
Create table Trabalha (IDPessoa char (5) not null, IDEmpresa char, salario number (7,2) not null, Primary Key (IDPessoa, IDEmpresa), Foreign Key (IDEmpresa) references Empresa, Foreign Key (IDPessoa) references Pessoa);
O mapeamento de agregações segue praticamente as mesmas regras que o mapeamento de associações, mostrado no item anterior, onde cada classe é mapeada para uma tabela relacional e a agregação é mapeada com a adição de uma coluna na tabela agregada.
A Figura 17 demonstra um exemplo de modelagem de agregação, onde uma empresa é composta de um ou mais setores.
O código SQL correspondente será:
Create table Empresa (IDEmpresa char (5) not null, nome char not null, endereço char, Primary Key (IDEmpresa);
Create table Setores (IDSetor char, IDEmpresa char, descrição char, Primary Key (IDSetor) Foreign Key (IDEmpresa references Empresa);
Para efetuar o mapeamento de uma modelagem com uso de generalização, representa- se a superclasse e cada uma das subclasses como uma tabela.
A identidade dos objetos neste tipo de mapeamento é preservada com a utilização de um identificador compartilhado.
A Figura 18 apresenta um exemplo da modelagem de um equipamento, onde os seus componentes são uma bomba e um dispositivo de troca de calor.
O código SQL correspondente será:
Create table Equipamento (IDEquipamento char (5) not null, descrição char, preço number (7,2), Primary Key (IDEquipamento));
Create table Bomba (IDEquipamento char (5) not null, capacidade number (7,2), consumo number (7,2), Primary Key (IDEquipamento) Foreign Key (IDEquipamento) references Equipamento);
Create table Dissipador (IDEquipamento char (5) not null, superficie integer, Primary Key (IDEquipamento), Foreign Key (IDEquipamento) references Equipamento);
Este capítulo buscou abordar os conceitos necessários para o entendimento do processo de mapeamento de comportamento de objetos.
Primeiramente foram abordados os conceitos de estado, evento e transição e o seu significado quando empregados numa implementação em banco de dados relacional.
Por último, foi discutida de maneira condensada a realização do mapeamento da dimensão estática dos objetos para tabelas relacionais.
O processo de mapeamento do comportamento de objetos tem por objetivo incorporar ao banco de dados uma maior parcela da realidade em sistemas de informação, cuja dimensão estática esteja descrita através de diagramas de classes e sua correspondente parcela da dimensão comportamental que esteja descrita através de diagramas de estados.
Como conseqüência do mapeamento do comportamento do objeto para o banco de dados, somente os eventos definidos previamente durante a fase de modelagem do sistema poderão ser aceitos por o objeto em tempo de execução.
Para garantir que os objetos terão suas modificações de atributos monitoradas, foi utilizado o recurso de gatilhos presente em sistemas de bancos de dados relacionais padrão.
Este recurso de implementação permite a definição de procedimentos que são implicitamente executados no instante da ocorrência de uma operação de atualização (inserção, alteração ou exclusão de tuplas) sobre um determinada tabela associada a este gatilho.
O processo de mapeamento é composto de quatro etapas e cada etapa é composta por uma ou mais atividades.
A cada etapa do processo de mapeamento há uma maior aproximação entre o modelo conceitual e a implementação.
As quatro etapas do processo de mapeamento são:
A) mapeamento da dimensão estática dos objetos para relações;
B) identificação da semântica dos estados (que compõem o diagrama de estados do objeto);
C) identificação da semântica dos eventos (que ocorrem no diagrama de estados do objeto);
D) criação dos gatilhos do Banco de Dados Relacional.
A seguir, são descritas em detalhes cada uma das etapas do processo bem como as atividades que irão compor cada etapa.
Para auxiliar na descrição de cada etapa do processo, será utilizado como exemplo uma classe de objetos denominada Classe1 representada na Figura 19, e que possui um comportamento descrito por o diagrama de estados apresentado na Figura 20.
Esta etapa do processo de mapeamento consiste em traduzir a dimensão estática de cada classe de objeto para relações.
Nosso processo de mapeamento de comportamento se refere ao comportamento definido para cada uma das classes de uma aplicação;
Portanto, iremos nos concentrar na forma mais básica de mapeamento estático, descrita anteriormente no item 4.4.1.
Partindo do modelo estático do objeto cujo comportamento desejamos mapear, iremos então realizar a tradução deste objeto para uma tabela relacional com correspondência de atributos.
A identidade do objeto é mapeada através do acréscimo do atributo OID que constituirá a chave primária da tabela.
O código SQL correspondente a este mapeamento será:
Create table Classe1);
Portanto, a cada classe do modelo corresponderá uma relação na implementação.
Em essa etapa deve- se identificar a semântica de cada um dos estados que compõem o diagrama de estados de um determinado objeto.
Sendo que estados referem- se a configurações de valores de atributos, deve- se identificar as diferentes configurações de atributos que caracterizam cada estado previsto para um objeto.
Partindo do exemplo de uma classe de objetos nomeado Classe1, representada na Figura 19, que possui dois atributos e com base no diagrama de estados deste objeto demonstrado na Figura 20, pode- se então elaborar um dicionário em forma tabular que contém o nome de cada estado e o seu significado em termos de configuração de atributos.
A elaboração deste dicionário é importante na realização das etapas posteriores do mapeamento e irá facilitar a construção dos gatilhos do banco de dados.
A Tabela 3 exemplifica este dicionário de estados atribuindo a cada estado uma configuração distinta de atributos.
Para facilitar o entendimento, foram considerados nos exemplos deste trabalho apenas nulos e não nulos como possibilidades de valores de atributos.
De outra forma, poderiam ser utilizados quaisquer intervalos de valores possíveis de atributos.
Em modelagens de estados mais sofisticadas pode- se encontrar abstrações de estados (superestados) em vários níveis, contendo um ou mais subdiagramas de estados.
Em este caso, deve- se identificar cada um dos estados que compõem estes subdiagramas.
A Figura 21 apresenta um diagrama de estados com níveis que descreve uma alternativa de comportamento para a mesma Classe1 composta por dois atributos.
Após a investigação sobre a semântica de cada um deste estados pode- se então elaborar o correspondente dicionário de estados que é exemplificado na Tabela 4.
Em este trabalho, foi abordado o mapeamento de diagramas de estados planos e com o uso de agrupamento de estados.
Questões referentes a mapeamento de diagramas de estado com uso de recursos como paralelismo ou história serão tratadas em trabalhos futuros.
O dicionário de Estados deve obedecer às seguintes regras de consistência:
De uma linha do dicionário;
Em essa etapa deve- se identificar a semântica de cada evento que ocorre no diagrama de estados da classe.
Considerando que eventos referem- se a transformações ocorridas nos valores de um ou mais atributos de um objeto e estas transformações levam este objeto a uma mudança no seu estado atual, devemos identificar cada uma destas transformações que cada evento previsto representa.
Outro aspecto importante que também deverá ser identificado é o tipo de operação ocasionada por cada evento no banco de dados.
Esta identificação se dará da seguinte forma:
A) transições de estado causadas por eventos provenientes de um identificador de estado inicial serão consideradas operações de inclusão.
Significam o início do ciclo de vida do objeto;
B) transições de estado causadas por eventos que levam a algum estado final serão consideradas operações de exclusão do objeto;
C) quaisquer outras transições de estado que não sejam provenientes de identificadores de estado inicial ou que não levem a um identificador de estado final serão consideradas operações de atualização.
Em o processo de mapeamento descrito nesse trabalho optou- se por considerar transições de estado que levam a um estado final como operações de exclusão do objeto, devido a o fato do mesmo, a partir deste momento, não mais aceitar operações de atualização, tendo chegado ao fim de seu ciclo de vida.
Outra alternativa para este tipo de transição seria manter o objeto no banco de dados com um objeto em &quot;estado congelado «ou mover o mesmo para uma outra tabela contendo objetos &quot;inativos».
De a mesma forma, após a criação do dicionário de estados elabora- se um dicionário de eventos contendo o nome de cada evento, o estado em que se inicia a transição, o estado em que a transição termina e o tipo de operação ocasionada no banco de dados.
Em a Tabela 5, pode- se observar o dicionário correspondente aos eventos previstos por o diagrama de estados do Objeto1, representado na Figura 20.
O dicionário de eventos deverá ser utilizado posteriormente em conjunto com o dicionário de estados.
Ambos dicionários servirão de mecanismo de aproximação entre a implementação e os modelos conceituais de comportamento.
Para identificar a semântica de eventos presentes num diagrama de estados utilizando recursos de abstração de estados como níveis ou agrupamento, a atividade é bastante semelhante.
Além de os eventos que ocorrem no nível principal do diagrama de estados, deve- se também identificar a semântica dos eventos que ocorrem nos subdiagramas.
Deve- se, portanto, acrescentar ao dicionário de eventos o super-estado e sub-estado iniciais e o super-estado e subestado.
A Tabela 6 exemplifica o dicionário de eventos correspondente ao diagrama de estados com agrupamento da Figura 21.
O significado do símbolo&quot;?»,
eventualmente presente como indicador de um sub-estado, significa que o evento independe de qual sub-estado o objeto se encontra para ser considerado válido.
O dicionário de Eventos deve obedecer às seguintes regras de consistência:
Vezes; Exclusão;
Necessariamente Alteração;
Em esta etapa são implementados os gatilhos do banco de dados que irão associar procedimentos de avaliação de atributos com as operações de atualização do banco de dados.
Estes procedimentos de avaliação visam implementar a parte do controle do objeto que irá assegurar que somente eventos de atualização permitidos, ou seja, somente modificações previstas nos valores do atributos poderão ocorrer.
Em bancos de dados relacionais operações de atualização podem resultar na modificação de uma ou mais tuplas de uma tabela.
Para assegurar que os procedimentos de avaliação serão aplicados sobre todo o conjunto de dados proveniente de uma operação de atualização, deve- se definir gatilhos que serão executados para cada tupla modificada das relações.
Deve- se também dispor de mecanismos que nos permitam obter tanto os valores de atributos que estão sendo sugeridos para a operação de modificação como os atuais valores de atributos do objeto.
Para satisfazer os requisitos, utilizou- se os gatilhos de banco de dados do tipo BEFORE e registro do banco de dados.
Também foram usados qualificadores de atributos NEW e OLD que nos permitem obter os antigos valores de atributos do objeto, bem como os novos valores de atributos que estão sendo sugeridos para a operação de atualização.
Outro recurso que foi utilizado foi a identificação na declaração do gatilho dos atributos que terão seus valores monitorados através da clausula Of..
Este recurso é especialmente útil na ocorrência de modificações nos valores de determinados atributos que não fazem parte da definição do estado atual do objeto.
Deverão ser definidos três gatilhos, um para cada operação de atualização do banco de dados (inclusão, alteração e exclusão), com base nas informações contidas nos dicionários de estados e eventos, elaborados nas etapas anteriores desse processo.
O gatilho de alteração relaciona os atributos que ocorreram no dicionário de estados como definidores da semântica dos estados.
A sintaxe adotada para a construção do corpo dos gatilhos foi a da PL/ SQL do SGBD Oracle Para facilitar a localização e identificação dos mesmos, sugere- se a adoção de nomes compostos por o nome da operação+ nome do objeto monitorado.
A seguir é detalhado como essas informações devem ser utilizadas na criação dos gatilhos do banco de dados.
Para demonstrar a construção destes gatilhos serão utilizados os mesmos diagramas de estados para uma Classe1, apresentados anteriormente na Figura 19, Figura 20 e Figura 21.
O gatilho de inclusão será responsável por o monitoramento da criação de instâncias do objeto, portanto, deverá assegurar que essas instâncias somente sejam criadas com seu estado inicial correto.
Para isso, o gatilho deverá responder ao evento relacionado ao estado inicial do objeto descrito na modelagem de estados do sistema.
Será necessário identificar no dicionário de eventos o evento proveniente do identificador de estado inicial do diagrama de estados.
Este evento deverá possuir na coluna Estado Inicial do dicionário de eventos o valor &quot;Estado Inicial».
Este mesmo evento causará uma transição de estado levando o objeto a um estado inicial.
A partir de as informações obtidas sobre este evento, deve- se identificar no dicionário de estados a configuração de valores de atributos que corresponde a este estado inicial.
Caso os valores de atributos estejam fora de o domínio de valores de atributos correspondente ao estado inicial, o gatilho não deverá permitir que a operação de inclusão se concretize.
Caso contrário, a operação de inclusão poderá completar- se.
A seguir é exemplificado um gatilho para a operação de inclusão que foi construído com base no comportamento apresentado por o diagrama de estados demonstrado na Figura 20, cuja semântica dos estados é descrita na Tabela 3 e a semântica dos eventos é descrita por a Tabela 5.
O gatilho de exclusão será responsável por o monitoramento da destruição de instâncias do objeto, portanto, deverá assegurar que somente poderão ocorrer eliminações previstas das instâncias, isto é, se o objeto estiver num determinado estado anterior ao identificador de estado final.
Este gatilho deverá responder aos eventos que levam o objeto a um identificador de estado final.
Para construção deste gatilho será necessária a identificação no dicionário de eventos do evento causador da operação de exclusão no banco de dados.
Este evento deverá possuir na coluna Estado Final do dicionário de eventos o valor &quot;Estado Final «A partir de as informações obtidas sobre este evento deve- se também identificar no dicionário de estados a configuração de valores de atributos correspondente ao estado final.
Com base nessas informações pode- se então criar a estrutura de controle do gatilho para avaliação da configuração de valores de atributos que estão sendo sugeridos na operação de exclusão.
Caso os valores de atributos estejam fora de o domínio de valores de atributos permitidos para o evento que leva ao identificador de estado final, o gatilho não deverá permitir que a operação de exclusão se concretize.
Caso contrário, a operação de exclusão poderá completar- se.
Abaixo é exemplificado um gatilho para a operação de exclusão que foi construído com base no comportamento apresentado por o diagrama de estados demonstrado na Figura 20, cuja semântica dos estados é descrita na Tabela 3 e a semântica dos eventos é descrita por a Tabela 5.
O gatilho de alteração será responsável por o monitoramento da atualização dos valores de atributos do objeto, portanto, deverá assegurar que somente atualizações previstas nos valores de atributos poderão se concretizar.
Para isso, o gatilho deverá responder aos eventos que não são provenientes nem do identificador de estado inicial e nem levam a um identificador de estado final.
Para construção deste gatilho será necessária a identificação, no dicionário de eventos, dos eventos que causam a operação de atualização no banco de dados.
Cada evento de atualização partirá de um estado inicial e levará o objeto a um estado final (neste caso foram usados os termos estado inicial e final referindo- se ao escopo do evento somente).
A partir de as informações obtidas sobre os eventos, deve- se também identificar no dicionário de estados as configurações de valores de atributos correspondentes a cada estado por o qual o objeto poderá passar durante o seu ciclo de vida.
Com base nessas informações pode- se criar as estruturas de controle do gatilho para avaliação da configuração de valores de atributos que estão sendo sugeridos na operação de atualização.
Caso os valores de atributos estejam fora de o domínio de valores de atributos permitidos para o evento, o gatilho não deverá permitir que a operação de atualização se concretize.
Caso contrário, a operação de atualização poderá completar- se.
Para o diagrama de estados da Figura 21 o gatilho para a operação de alteração construído observando os requisitos acima descritos, ficaria na seguinte forma:
Pode- se identificar a estrutura básica de construção dos gatilhos:
Por o estado (global aos sub-estados), verificação do sub-estado atual, e dos eventos admissíveis nesse sub-estado;
O passo 3 é executado recursivamente até que sejam percorridos todos os níveis de subestados dos estados.
Em este capítulo foi elucidada a solução de mapeamento de diagramas de estados para banco de dados relacional fazendo uso de gatilhos.
A solução divide- se em quatro etapas:
A primeira trata da tradução da dimensão estática para relações do banco de dados;
A segunda e terceira etapas tratam da identificação da semântica de estados e eventos que compõe o diagrama de estados que está sendo mapeado e a quarta e última etapa trata da construção dos correspondentes gatilhos do banco de dados.
Em o Capítulo a seguir demonstraremos a aplicação deste processo de mapeamento através de um estudo de caso.
Este capítulo visa apresentar um estudo de caso de utilização de nossa solução de mapeamento como forma de experimentação da mesma.
Será usado como tema o sistema de preparação de documentos encontrado na Biblioteca Digital do projeto Campus Global da Pontifícia Universidade Católica do Rio Grande do Sul.
Este sistema tem por objetivo prover o acompanhamento do processo de preparação dos documentos que serão disponibilizados no acervo da Biblioteca Digital.
A escolha deste sistema é justificada por a presença de um objeto com um comportamento bastante interessante, apresentando diversas modificações nos valores de seus atributos e, consequentemente, caracterizando diversos estados por o qual este objeto deverá passar ao longo de o processo de preparação.
O restante deste capítulo irá demonstrar a aplicação do processo de mapeamento de estados de objetos ao Sistema de Controle de Preparação de Documentos da Biblioteca Digital da PUCRS.
O capítulo inicia com uma resumida descrição geral do sistema de preparação, apresentando a seguir a modelagem deste sistema e finalizando com a aplicação do processo de mapeamento.
O sistema de preparação de documentos tem por objetivo prover o acompanhamento do processo de preparação dos documentos, gerenciando e controlando as atividades envolvidas.
Estas atividades têm inicio no momento em que um documento é recebido por o responsável da Biblioteca Digital para ser incluído no acervo digital.
Este documento pode ser recebido em dois formatos diferentes, são eles:
Não digital (papel) e digital (arquivo).
Caso o documento não esteja em formato digital, deverá passar por a etapa de digitalização para dar subsídio às etapas seguintes.
Após concluída a etapa de digitalização, o documento deverá passar por a etapa de formatação.
Em esta fase, o documento será formatado seguindo os padrões previamente estabelecidos para documentos do acervo digital.
Após concluída a etapa de formatação, o documento seguirá para a fase de indexação, que deverá classificar- lo e também gerar índices para pesquisa do mesmo com base no autor, assunto, palavras-chave, etc..
O processo de digitalização de um documento poderá durar desde minutos até vários dias dependendo de diversos fatores como o tamanho e complexidade do documento.
Após ter atingido o estado final do processo de preparação (Digital, Formatado e Indexado) o documento será movido do sistema de preparação para o sistema de disponibilização de documentos digitais cuja funcionalidade não será discutida por medida de simplicidade.
O Objeto Documento se refere a uma classe de objetos que representa os documentos que encontram- se no processo de preparação e ainda não fazem parte do acervo de documentos da biblioteca digital.
A Figura 22 representa este objeto, composto apenas por seus atributos mais relevantes.
Os três últimos atributos se referem às etapas do processo de preparação e seu conjunto de valores possíveis será discutidos posteriormente durante o processo de mapeamento.
A Figura 23 apresenta o diagrama de estados UML representando o comportamento do objeto Documento, discutido na seção 6.1.
Em este diagrama é abordado apenas o ciclo de vida do documento, desde a recepção por a Biblioteca Digital até a última etapa de sua preparação, desconsiderando a etapa de publicação no acervo digital.
Pode- se observar, no diagrama de estados acima, que o objeto documento não possui definido um estado final.
Portanto, um objeto da classe documento não aceitará ser excluído.
A primeira etapa do processo consiste em mapear o Objeto Documento para uma tabela com correspondência de atributos e o acréscimo de um atributo adicional que identificará unicamente cada instância.
A tabela relacional resultante deste processo de mapeamento é a seguinte:
Em esta etapa identifica- se a semântica de cada um dos estados componentes do diagrama de estados da classe Documento em termos de valores de atributos.
Cada configuração de valores de atributos diferente será armazenada no respectivo dicionário de estados para a Classe Documento, correspondente a Figura 23, conforme demonstra a Tabela 7.
Em essa etapa, identifica- se a semântica de cada evento que ocorre no diagrama de estados.
Portanto, deve- se identificar o estado inicial do objeto, antes da ocorrência do evento, e o estado final após a ocorrência do evento.
Deve- se também associar cada evento com sua respectiva operação de atualização ocasionada no banco de dados, conforme descrito anteriormente.
O produto desta etapa, ao fim destas atividades, será o dicionário de eventos para a Classe Documento correspondente à Figura 23, conforme demonstra a Tabela 8.
Esta seção irá descrever a construção dos gatilhos para o Sistema de Preparação de Documentos.
Em os gatilhos construídos foram incluídas chamadas da função put_ line que permitem retornar mensagens ao ambiente de execução, com a finalidade de indicar as diferentes situações corretas identificadas por os gatilhos.
Tais chamadas foram incluídas somente com a finalidade de testes no estudo de caso.
Em implementações reais estas chamadas devem ser suprimidas.
O final do capítulo irá demonstrar o funcionamento destes gatilhos através da execução de declarações SQL que tentarão realizar atualizações válidas e inválidas no banco de dados.
A construção do gatilho de inclusão iniciamos com a consulta no dicionário de eventos da classe documentos na busca do evento proveniente do Estado Inicial do diagrama de estados.
Este evento irá indicar o estado ao qual o objeto deverá estar após o evento de inclusão.
De posse dessas informações, será criada a estrutura de controle que permitirá somente a criação de instâncias de objetos com os valores de atributos correspondentes ao estado inicial.
A seguir demonstramos o corresponde código SQL para o gatilho de inclusão da classe Documentos.
Para construir o gatilho de exclusão, deve- se consultar o dicionário de eventos da classe documentos na busca de o (s) evento (s) que levam este objeto ao estado final.
Com base nisso, deve- se elaborar a estrutura de controle que permitirá que somente operações de exclusão previstas no correspondente diagrama de estados do objeto possam ser realizadas.
Abaixo é demonstrado o código SQL correspondente para o gatilho de exclusão da classe Documentos.
Observa- se que, neste caso, não há previsão para exclusão de instâncias do objeto Documento, portanto, estas não são permitidas em forma alguma.
A construção do gatilho de alteração inicia com a consulta ao dicionário de eventos da classe documentos na busca dos eventos que não são provenientes do Estado Inicial e nem levam este objeto ao estado final.
De posse dessas informações, deverá ser elaborada uma lógica para a estrutura de controle que somente permitirá atualizações que estão previstas nos valores dos atributos dos objetos.
A seguir é demonstrado o corresponde código SQL para o gatilho de alteração da classe Documentos.
Em esta seção são mostrados alguns exemplos de execução sobre o banco de dados definido, com a implementação dos gatilhos e os correspondentes resultados.
Durante a etapa de elaboração desta experimentação, foi realizada uma verificação completa e exaustiva desta solução de mapeamento através da execução de um conjunto de comandos que realizam todas possíveis modificações no subconjunto de valores de atributos do objeto Documento, levando este a transições válidas e inválidas.
Por medida de economia de espaço, selecionamos algumas das mais significativas situações de atualização que poderiam ocorrer neste objeto.
O comando SQL abaixo cria uma instância da classe Documento no estado &quot;Não Classificado&quot;:
Como resposta do gerenciador de Banco de Dados, obtemos:
Transicão Estado Nao CLASSIFICADO 1 linha criada.
Como resposta do gerenciador de Banco de Dados, obtemos:
O comando SQL abaixo faz com que a instância da classe Documento mude do estado &quot;Não Classificado «para o estado &quot;NãoDigital «formatado $= Null, indexado $= Null Como resposta do gerenciador de Banco de Dados, obtemos:
O comando SQL abaixo tenta fazer com que o objeto mude seu estado de &quot;Não Digital «para outro estado diferente de &quot;Em Digitalização&quot;:
Como resposta do gerenciador de Banco de Dados, obtemos:
O comando SQL abaixo faz com que a instância da classe Documento mude do estado &quot;Não Digital «para o estado &quot;Em Digitalização «formatado $= Null, indexado $= Null Como resposta do gerenciador de Banco de Dados, obtemos:
Transicão Estado Em DIGITALIZACAO 1 linha atualizada.
O comando SQL abaixo tenta fazer com que o objeto mude seu estado de &quot;Em Digitalização «para outro estado diferente de &quot;Digitalizado e Não Formatado&quot;:
Como resposta do gerenciador de Banco de Dados, obtemos:
O comando SQL abaixo faz com que a instância da classe Documento mude para o estado &quot;Em Digitalização «para o estado &quot;Digital e Não Formatado «formatado $= 'NAO', indexado $= Null Como resposta do gerenciador de Banco de Dados, obtemos:
Transicão Estado Digital e Nao FORMATADO 1 linha atualizada.
O comando SQL abaixo tenta fazer com que o objeto mude seu estado de &quot;Digital e Não Formatado «para outro estado diferente de &quot;Digital e em Formatação&quot;:
Como resposta do gerenciador de Banco de Dados, obtemos:
O comando SQL abaixo faz com que a instância da classe Documento mude do estado &quot;Digital e Não Formatado «para o estado &quot;Digital e em Formatação «formatado $= 'FORMATANDO', indexado $= Null Como resposta do gerenciador de Banco de Dados, obtemos:
Transicão Estado Digital e Em FORMATACAO 1 linha atualizada.
O comando SQL abaixo tenta fazer com que o objeto mude seu estado de &quot;Digital e em Formatação «para outro estado diferente de &quot;Digital, Formatado e Indexado&quot;:
Como resposta do gerenciador de Banco de Dados, obtemos:
O comando SQL abaixo faz com que a instância da classe Documento mude do estado &quot;Digital e em Formatação «para o estado &quot;Digital, Formatado e Não Indexado «formatado $= 'SIM', indexado $= 'NAO' Como resposta do gerenciador de Banco de Dados, obtemos:
Transicão Estado Digital, FORMATADO e Nao INDEXADO 1 linha atualizada.
O comando SQL abaixo tenta fazer com que o objeto mude seu estado de &quot;Digital, Formatado e Não Indexado «para outro estado diferente de &quot;Digital, Formatado e em Indexação&quot;:
Como resposta do gerenciador de Banco de Dados, obtemos:
O comando SQL abaixo faz com que a instância da classe Documento mude do estado &quot;Digital, Formatado e Não Indexado «para o estado &quot;Digital, Formatado, Em Indexação «formatado $= 'SIM', indexado $= 'INDEXANDO' Como resposta do gerenciador de Banco de Dados, obtemos:
O comando SQL abaixo tenta fazer com que o objeto mude seu estado de &quot;Digital, Formatado e em Indexação «para outro estado diferente do estado final &quot;Digital, Formatado e Indexado&quot;:
Como resposta do gerenciador de Banco de Dados, obtemos:
Erro na linha 1: Ora-20507:
Transicão de Estados invalida Ora-06512:
Em &quot;MACIEL_ UPADTE_ DOCUMENTO», line 117 Ora-04088:
Erro durante a execução do gatilho 'MACIEL_ UPADTE_ DOCUMENTO'.
O comando SQL abaixo faz com que a instância da classe Documento mude para o seu último estado &quot;Digital, Formatado, Indexado «formatado $= 'SIM', indexado $= 'SIM' Como resposta do gerenciador de Banco de Dados, obtemos:
Transicão Estado Digital, FORMATADO e INDEXADO 1 linha atualizada.
Com a realização deste trabalho demonstramos um método para o mapeamento de propriedades dinâmicas descritas por diagramas de estados da UML para implementações em Bancos de Dados Relacionais com o uso do recurso de gatilhos.
Algumas características da presente contribuição são:
Redução do volume de programação por a implantação dos bancos de dados de uma parcela das propriedades dinâmicas das aplicações;
Maior robustez dos bancos de dados na medida em que uma maior parcela da realidade passa a poder ser gerenciada por os SGBD's.
Com isso aumenta- se a qualidade da solução computacional da implementação dos bancos de dados em SGBD's relacionais.
Em o processo de elaboração deste trabalho, foram necessários estudos acerca de diversos temas relacionados.
Em um primeiro momento, buscou- se compreender os diagramas de estados especialmente a notação adotada na UML e suas diferentes possibilidades de representação de comportamento de objetos.
Em seguida, procurou- se identificar o estado da arte no que se refere ao mapeamento de diagramas de estados para implementação através da busca de trabalhos relacionados seja em meios tradicionais ou em meios eletrônicos.
O mais relevante dos trabalhos encontrados apresenta uma solução para mapeamento de modelos dinâmicos o qual mostrou efetividade no mapeamento de diagramas de estado para linguagens orientadas a objetos.
Porém, devido a sua grande complexidade, a mesma é impraticável para uso junto de bancos de dados relacionais ou objeto- relacionais.
Constatada a impraticabilidade das soluções existentes, buscou- se investigar alternativas para implementação de propriedades dinâmicas em bancos de dados relacionais ou objeto- relacionais considerando as atuais funcionalidades oferecidas por este tipo de ferramentas.
A investigação tratou, em profundidade, de diagramas de estado simples e diagramas de estados com uso de agrupamento de estados.
Para estes tipos de construções de diagramas de estado, foram estudadas alternativas de implementação e propostos modelos de mapeamento das propriedades estáticas e propriedades dinâmicas.
Em especial, para propriedades dinâmicas, foram propostos padrões de implementação empregando gatilhos em bancos de dados relacionais conforme o padrão SQL mais recente.
A experimentação do método de mapeamento proposto foi feito através de um estudo de caso de razoável complexidade e a execução de testes exaustivos sobre a implementação.
Durante a investigação, foram também superficialmente estudados outros tipos de construções de diagramas de estados envolvendo recursos como história e concorrência e encontradas alternativas de implementação dos mesmos.
O resultado deste estudo preliminar, bem como os exemplos desenvolvidos encontram- se listados na forma de um anexo deste trabalho.
Diversos trabalhos podem originar- se a partir deste.
Por a pesquisa ter sido centrada nas construções da UML para diagrama de estados, é bastante interessante, estudar a possibilidade do desenvolvimento de estereótipos da UML para construção de gatilhos que implementem diagramas de estados.
O avanço desta idéia em implementar propriedades dinâmicas em bancos de dados relacionais e objeto-relacionais com o uso de gatilhos poderia ocorrer sobre outros modelos oferecidos por a UML tais como diagrama de atividades, colaboração, etc..
Outra sugestão é o estudo e implementação de uma ferramenta que possibilite a descrição do comportamento de um objeto através de diagramas de estados e posteriomente utilize esta descrição para construção do codigo dos gatilhos do banco de dados de maneira automática.
Esta ferramenta seria especialmente importante devido a o fato de que quanto maior a complexidade do diagrama de estados que descreve o comportamento de um objeto, maior a complexidade envolvida na tradução deste modelo de comportamento em gatilhos que irão implementar o controle do objeto.
