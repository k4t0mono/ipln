Em o contexto da engenharia de software, processos de desenvolvimento de software definem um conjunto de &quot;atividades», &quot;papéis», e &quot;artefatos «que são utilizados durante o ciclo de vida da construção de um produto de software.
Entretanto, tais processos representam artefatos como documentos monolíticos, que são compostos de informações fracamente estruturadas.
Isto ocorre dado o fato da construção dos artefatos ser feita a partir de processadores de textos, levando a um problema na computação da estrutura, da organização e do conteúdo, uma vez que limita a potencial formalização dos artefatos utilizados.
Diante deste contexto, o desafio é construir artefatos de software que podem ser controlados e gerenciados através de ferramentas que trabalhem com maior nível de formalização.
Em este sentido, apresentamos uma abordagem que visa à representação de artefatos de forma bem estruturada, separando artefatos em dois níveis:
&quot;estrutura «e &quot;conteúdo».
Além disso, este trabalho também auxilia na utilização de artefatos de forma genérica, independente de processo, o que é conhecido na literatura por camadas de &quot;definição «de artefatos e &quot;uso «em processos.
Desta forma, nossa abordagem consiste na utilização de um paradigma diferente de manipulação de artefatos, numa tentativa de melhoria no controle da informação desde a fase de autoria e definição do processo de desenvolvimento de software.
Palavras-chave: Artefatos de Software, Autoria, Processos de Desenvolvimento de Software, Metamodelo, SPEM v2, UML.
Como já era esperado, muitos processos de desenvolvimento de software encontrados na literatura, assim como Rational Unified Process (RUP) (Kruchten, 2000, Kroll &amp; Kruchten, 2003), Object-oriented Process, Environment and Notation (OPEN) (Graham 1997) e SCRUM (Schwaber, 2004), compreendem artefatos de forma monolítica.
A o analisarmos um processo específico é possível perceber a real importância dos artefatos para a obtenção do produto.
No caso de o RUP, são definidos aproximadamente 100 artefatos que, em sua grande maioria, são renderizados através de processadores de texto como o Microsoft Office WordTM ou Open Office Writer1.
Conforme já foi mencionado, ASs são utilizados à medida que um PDS é executado (enactment), porém eles são especificados durante a definição do PDS, ou seja, na autoria (authoring).
O nível de autoria de um PDS é realizado em duas fases, Definição de elementos do PDS e Uso dos elementos por o PDS.
Desta forma, pode- se consumir os elementos que forem necessários para projetar um PDS efetivo para um determinado domínio.
Definição dos Elementos de PDS.
Uso dos Elementos já criados por um PDS.
Em a Figura 1.2 estão o modelo conceitual de artefato e sua instância no que se diz respeito ao seu uso.
Em a estão os elementos Artefato e Informação, numa agregação n:
M ou seja, um artefato pode possuir muitos tipos de informação ou ao menos um, portanto, cada informação pode estar em mais de um artefato.
Em b pode ser observado como se dá a sua construção e, supostamente, a mesma informação pode ser repetida em I1, I2 e I3, estando dentro de os artefatos.
Não há rastreabilidade entre os artefatos e as informações, ou seja, difícil identificar se a mesma informação está disposta em diferentes artefatos.
Segundo, a demanda por softwares cada vez mais complexos é maior do que a capacidade de produzir- los através dos processos e metodologias conhecidas até então.
Baseados nesta idéia, muitos autores tenderam ao desenvolvimento de metodologias baseadas em casos de uso (use- case methodology) (Williams, 2004).
Portanto, houve mudança na construção dos processos de software.
Tal mudança foi feita para suportar uma nova metodologia dirigida por a documentação de um projeto.
Engenheiros do Software acreditam que a documentação de um produto ajuda no entendimento não só funcional, mas também em nível de projeto e em detalhes de implementação do mesmo.
Sem documentação, os Engenheiros de Software são forçados a confiar apenas no código-fonte do produto (Hartmann 2001).
Uma boa documentação com qualidade ajuda e facilita a conclusão das tarefas, em a qual várias e complementares perspectivas são fornecidas para melhor entendimento de um sistema.
Produzir o melhor software possível, juntamente com a melhor documentação possível é um dos principais objetivos da Engenharia de Software.
Para (Hartmann 2001), o controle de informações é feito a partir de um processo de documentação divido em três partes:
Coleta a partir de múltiplas fontes de informação, processamento de toda a informação coletada e publicação da mesma através de vários tipos de artefatos (geralmente documentos como manuais e descritores).
Entretanto, algumas vezes a documentação é considerada plano de fundo e não tão importante quanto o próprio software.
Para, a falta ou baixa qualidade da documentação é a maior causa de erros e necessidades de manutenção num produto de software.
Portanto, é notável a necessidade e a importância de documentação num processo de software.
Problematica 01 PDSs entendem artefatos como representações monolíticas, visto que todo o processo gira em torno de a produção de ASs ao invés de a informação contida no mesmo.
Sendo assim, ao se deparar com um As, não é possível saber como o mesmo está estruturado ou ao menos quais são as informações necessárias para preencher- lo.
Portanto, o processo enxerga a informação como um conjunto, não como os elementos de uma composição de várias estruturas de informação existentes.
Problematica 02 (P2) Linguagens de Modelagem de Processos não possuem os níveis de profundidade necessários para definir todos os elementos necessários de um PDS.
Sendo assim, dentro de o escopo de As mais especificamente, tais linguagens não determinam alguma representação em níveis de informação.
Isto demonstra que não é possível se obter o detalhamento do As, evitando que sua definição seja desmembrada de sua utilização.
Tal fato implica em ambigüidade e inconsistência.
Além disso, deixa dúvidas durante a execução do PDS, tais como:
Qual formato dos artefatos?
Como é sua estrutura interna?
Quais informações devem preencher- lo (e.
g gráficos, imagens, links)?
Como artefatos devem ser preenchidos ou gerados?
Existe alguma particularidade no estilo ou maneira de tornar um artefato mais familiar ou mais compreensível?
Como versionar o artefato identificando onde houve modificação e por quem?
Como identificar e evitar redundância tanto na estrutura quanto no conteúdo dos artefatos numa tentativa de reuso?
Problematica 03 (P3) Não existe uma maneira clara para (i) determinar e especificar ASs e (ii) definir qual o fluxo a ser realizado durante a definição e o uso de ASs.
Conforme visto anteriormente, processos como RUP, OPEN e SCRUM, comumente utilizados tanto na indústria quanto na academia, tratam seus artefatos de maneira monolítica.
Não obstante, linguagens para descrição de processos são bastante genéricas e tratam os componentes do processo da mesma forma.
Este tipo de prática pode levar a problemas como, por exemplo, ambigüidade e inconsistência na autoria dos artefatos e diminuição do grau de reuso de informação.
Como estes artefatos são, em sua maioria, semi-estruturados, a falta de um formalismo pode causar problemas ao se computar as informações existentes.
Portanto, surge a questão de pesquisa:
Como deve ser a autoria de Artefatos de Software de forma que estes não sejam monolíticos?
Embora artefatos sejam vistos como se fossem pedaços de informação sem estrutura ou forma definida, estes possuem estruturas lógicas internas e diferentes representações de informação.
Nem sempre é possível perceber ou verificar a existência de redundância sem entender o artefato como um todo.
Como existem diferentes ASs, a solução deste problema requer conhecimento sobre a estrutura de cada um de eles desde que cada um possua uma estrutura interna diferente.
Infelizmente, este tipo de tratamento não é verificado em linguagens de autoria ou execução de PDSs.
Em este contexto, alguns desafios são:
Como construir artefatos de forma que sua organização interna esteja bem estruturada, facilitando sua compreensão e manipulação?
Como definir diversas versões, autores e estruturas de informação aos artefatos durante sua autoria, evitando a redundância de informação, de estrutura e retrabalho?
Baseados nestas dúvidas nosso objetivo é desenvolver uma abordagem que provê a autoria de artefatos determinando maiores detalhes sobre suas estruturas de informação.
Diante de isto nossos objetivos específicos são:
Identificar o fluxo de atividades (ou passos) necessárias para a realização de autoria nos níveis de definição e uso de ASs.
Estruturar ASs para permitir o reuso estrutural e flexibilidade em sua autoria e produção.
Especificar ASs com versionamento, maturidade e controle estrutural para que seja possível o controle e o gerenciamento da informação.
Permitir o reuso de estrutura e conseqüentemente de conteúdo das informações existentes.
Adquirir conhecimento sobre a construção de ASs já na fase de autoria de um PDS, removendo esta responsabilidade da fase de execução.
Propor uma linguagem de autoria de ASs capaz de suprir as necessidades identificadas.
Desenvolver uma ferramenta de software e produzir um protótipo, tendo como base a linguagem desenvolvida.
Elaborar casos de testes envolvendo a autoria de artefatos para um processo real que utilize o protótipo da ferramenta a ser desenvolvida.
A abordagem em desenvolvimento representa esforços para a solução dos problemas apontados nas seções anteriores.
Além de isto, este trabalho apresentará contribuição para autoria de artefatos.
Um breve resumo das contribuições a serem geradas por a pesquisa descrita neste trabalho é apresentado a seguir:
Especificação de um Guia para a Autoria de Artefatos:
Conforme a necessidade de conhecer ASs e suas estruturas, foi desenvolvido um guia para definir a autoria de PDSs juntamente com a de ASs em detalhes, permitindo reuso de definição e uso dos mesmos.
Além disso é apresentado como elaborar o desenvolvimento de artefatos em partes menores, onde papéis atuarão nestes fragmentos.
Levantamento de estruturas de informações contidas em artefatos conhecidos:
Com a obtenção de conhecimento sobre o formato estrutural dos ASs e seu preenchimento será possível um melhor entendimento sobre o ciclo de produção do mesmo.
As informações que permeiam a forma do artefato poderão ser verificadas e avaliadas iterativamente, onde poderemos utilizar versionamento tanto na definição, quanto no uso dos artefatos.
Além de o mais, o aumento no compartilhamento de conteúdo e estrutura, baseado no reuso, poderá diminuir o tempo de elaboração e produção dos artefatos.
Criação de uma Meta-Linguagem:
Com uma linguagem de definição de ASs podemos construir- los em detalhes, utilizando estruturas lógicas e organização bem definida.
Portanto, criamos um metamodelo que permite a autoria e produção de ASs numa linguagem com vários níveis de formalismo, servindo como base para os esforços futuros na área de autoria de PDSs, assim como, para o desenvolvimento de aplicações neste contexto.
Em esse sentido, foram desenvolvidos:
Um metamodelo que define a sintaxe e semântica do problema e regras de boa formação que especificam as restrições necessárias;
Ferramenta Protótipo de Suporte: A implementação do metamodelo conforme um plugin construído com base no Eclipse Modeling Framework (EMF) (Duddy 2003) disponibilizará recursos para a autoria de ASs.
O trabalho está dividido em etapas que agrupam as atividades relacionadas.
Tais etapas se relacionam através de fluxo de atividade que pode ser visualizado na Figura 1.3 e serão descritas conforme a ordem em que foram realizadas:
Etapa 1: Realizar o levantamento bibliográfico sobre os PDSs.
Esta etapa foi contínua e visou verificar o impacto de outros trabalhos na área na abordagem proposta;
Fazer levantamento sobre tipologia de artefatos através de estudo teórico;
Fazer aprofundamento de estudos sobre os mecanismos de extensão de metas-linguagem baseadas em autoria de PDSs ou ASs.
Etapa 2: Identificar os artefatos mais utilizados nos PDSs analisados na Etapa 1;
identificar a tipologia dos ASs, selecionando um mapeamento para cada estrutura de informação diferente;
Propor a criação, utilização ou extensão de uma linguagem ou meta-linguagem para permitir a quebra do As numa estrutura mais granular de acordo com as tipologias encontradas.
Etapa 3: Realizar a análise dos resultados obtidos das etapas 1 e 2 para:
Especificar a meta-linguagem que defina as tipologias inspecionadas;
Elaborar o guia de autoria de ASs;
Propor uma ferramenta de suporte para verificação da abordagem;
Análise e projeto da ferramenta;
Implementação da ferramenta proposta;
Etapa 4: Realização de caso de teste sobre o protótipo, objetivando a prática do que foi desenvolvido nas etapas anteriores;
Finalização da escrita e submissão de artigos;
Entrega do seminário de andamento;
E revisão, entrega e defesa da dissertação.
Este trabalho se encontra organizado da seguinte maneira:
Capítulo 2: Apresenta a fundamentação teórica das tecnologias e conceitos sobre os principais temas discutidos no decorrer de o trabalho;
Capítulo 3: Apresenta os principais trabalhos com soluções relacionadas à abordagem proposta, sob uma visão comparativa;
Capítulo 4: Apresenta a solução encontrada assim como a descrição detalhada dos passos que foram seguidos para sua implementação;
Capítulo 5: Apresenta os testes feitos através do uso da abordagem.
Em este Capítulo também é apresentada a ferramenta de suporte a autoria de artefatos de software SwAT;
Capítulo 6: Em este Capítulo é apresentada a conclusão do trabalho.
2 Fundamentação Teórica Em este capítulo apresentamos um resumo explicativo sobre os principais conceitos utilizados nesta dissertação.
Nosso objetivo é facilitar a leitura deste trabalho, determinando a base da fundamentação teórica estudada durante a pesquisa.
Este capítulo está definido da seguinte forma:
Em a Seção 2.1 está definido o conceito de As juntamente com alguns exemplos;
A Seção 2.2 apresenta uma breve história sobre PDS, desde seu conceito base até sua utilização conforme exemplos de PDS existentes e bastante conceituados;
A Seção 2.3 apresenta fundamentação sobre modelagem e metamodelagem;
E, por fim, a Seção 2.4 apresenta um breve resumo sobre a linguagem de modelagem de PDS utilizada no decorrer deste trabalho.
Artefato de Software é identificado como um dos principais elementos que fazem parte do núcleo de PDSs, que descreve quem está fazendo o que, como e quando.
Em este caso, um Artefato de Software é o que está sendo feito.
Segundo, um artefato é um pedaço de informação que é produzida, modificada ou utilizada por um processo.
O que é uma definição bem razoável de um ponto de vista mais amplo.
Além disso, o mesmo autor ainda afirma que estes devem ser elementos tangíveis de um projeto, produzidos durante a construção de um produto final.
Entretanto, para, ASs são produtos de trabalho finais ou intermediários produzidos e usados durante os projetos, os quais são utilizados para capturar e transmitir informações do projeto.
Restringindo um pouco o domínio para PDSs, artefatos são inerentes à execução de alguma atividade, para a qual pode ser tanto uma entrada, para que a atividade possa ser executada, como uma saída ou resultado de uma execução que poderá ser utilizado em outras atividades.
Sendo assim, artefatos podem ser de várias formas ou formatos diferentes.
De entre eles podendo ser:
Um modelo, assim como Modelo de Casos de Uso da UML;
Um elemento de um modelo, que é um elemento dentro de um modelo, assim como um Caso de Uso (UC);
Um documento, como por exemplo o documento Visão do RUP;
A noção de processo é comum e faz parte das atividades humanas e em sua definição mais elementar é dado como sendo uma forma sistemática de criação de um produto de acordo com algumas tarefas pré-determinadas.
Processo é um verbete de origem direta do Latim processus, que significa a idéia do que segue adiante, do que avança no eixo do tempo.
Este verbete exibe uma origem etimológica mais distante, seu significado tem a ver com a palavra grega proodoz (leia- se próodos) que traduz progresso, progressão, avanço.
Processos são geralmente utilizados para se criar formas efetivas e, possivelmente, genéricas na construção de algum produto.
O processo, em sua essência, é visto como o alcance de uma solução e, conforme as descrições dos passos do processo, executar- lo como uma instância.
Esta instância servirá para resolver problemas mais específicos.
Entretanto, muitas vezes não é fácil entender um processo, e isto se dá por existir uma diferença fundamental entre a descrição e o próprio processo.
Para Dijkstra, 1979, enquanto a descrição do processo é uma entidade estática e de fácil análise e compreensão, o processo em si é dinâmico e um pouco mais difícil de ser compreendido.
Como exemplo, pode- se tomar uma receita de bolo:
A receita simplesmente descreve como o bolo deve ser feito;
O processo será o preparo do bolo.
Em este exemplo, fica claro que enquanto um processo é um instrumento para se fazer algo, sua descrição especifica como algo deve ser feito.
Em o contexto da computação, um processo é uma tarefa em execução inserida num dispositivo computacional.
No entanto, não existe um consenso entre os autores no tocante a definição de um Processo de Desenvolvimento de Software (PDS).
De acordo com, um PDS pode ser definido como um conjunto de atividades, métodos, práticas e transformações que as pessoas empregam para desenvolver e manter o software e os produtos associados (por exemplo, planos de projeto, documentos de projeto, design, código, casos de teste, manual do usuário).
Não muito obstante, para Soares, 2004, um processo de software é um conjunto coerente de atividades e resultados associados que auxiliam na produção de software.
Para, processo de software nada mais é que um conjunto coerente de ações (policies), estruturas organizacionais, tecnologias, procedimentos e artefatos necessários para conceber, desenvolver, implantar e manter um produto de software.
Um PDS define a seqüência em que os métodos serão aplicados, como os produtos serão entregues, os controles que ajudam a assegurar a qualidade e a coordenar as mudanças, e os marcos de referência que possibilitam aos gerentes de software avaliar o progresso do desenvolvimento.
Sendo assim, PDSs são importantes porque tentam uniformizar a realização dos Produtos de Software (PS) através de projetos, reduzindo o tempo de produção e custos.
Caso um processo esteja explicitamente correto, o desenvolvimento do software será feito de forma sistemática e ordenada.
Conforme, existe uma relação quase que direta entre a qualidade de um PS e o PDS que o produziu.
Desta forma, o PDS faz parte da camada mais importante da Engenharia de Software (ES) e se constitui no elo de ligação entre as ferramentas e os métodos, além de possibilitar um desenvolvimento racional do software (Sommerville, 2004).
Em este caso, a ES caracteriza- se por a produção de um PS através de processos de qualidade.
Entretanto, para construir um PDS que seja efetivo, não basta apenas escolher um ciclo de vida de processo, deve- se considerar a complexa inter-relação organizacional, cultural, tecnológica e econômica.
Sendo assim, deve- se ter em mente que criar um processo capaz de conservar todas essas variáveis não é uma tarefa fácil. Segundo,
a criação, construção e utilização de processos envolve a captura e a análise de práticas existentes dentro de a construção de algum produto ou fornecimento de serviço, redesenho e simulação, instalação e gerenciamento, captura e auditoria do histórico dos acontecimentos e refinamento e melhoria.
O ciclo da gerência de processos é apresentado na Figura 2.1 e está dividido em três instantes.
Em o instante 0, em branco, está a modelagem do PDS, de o qual este instante é conhecido por autoria (authoring).
O instante 1, em tom mais escuro, apresenta a execução (enactment) do PDS.
Entre esses dois instantes, em tom claro, pode- se adicionar um instante de re-análise e remodelagem (tailoring).
Em as próximas Seções serão apresentados PDSs já consolidados.
Em a Seção 2.2.1 é apresentado o RUP, um exemplo de PDS baseado em metodologias tradicionais de desenvolvimento;
Já a Seção 2.2.2 está o Scrum, como instância de metodologia ágil.
Rational Unified Process. Modelo de arquitetura 4+ 1 do RUP.
Adaptado de· Logical View:
Esta perspectiva endereça os requisitos funcionais do sistema, em outras palavras, o que o sistema deve fazer.
Esta perspectiva é uma abstração do modelo, identificando como devem ser os pacotes, subsistemas, classes, entre outros.
Implementation View: Esta perspectiva descreve como a parte estática do software deve ser organizada em módulos (código-fonte, arquivos de dados, componentes, executáveis, entre outros), dentro de um ambiente em termos de empacotamente e configuração.
Process View: Esta perspectiva endereça os aspectos concorrentes de um sistema em tempo de execução.
São analisados deadlocks, tempo de resposta, isolamento de funções e falhas.
Deployment View: Esta perspectiva define como os vários executáveis e outros componentes de execução são mapeados para uma plataforma computacional.
São endereçados problemas como instalação e performance.
Use-Case View: A última perspectiva, baseada em casos de uso, contém os cenários do sistema.
Inicialmente esta perspectiva é utilizada para direcionar a descoberta e projeto da arquitetura nas fases inicial e elaboração.
Artefatos Um artefato é qualquer pedaço de informação que é produzido, alterado, ou modificado através das atividades de um PDS.
Além disso, artefatos são unidades tangíveis de um projeto e sua soma determina o PS final.
Um artefato pode ser de várias formas ou características, de entre elas:
Um modelo, um elemento de um modelo, um documento, código fonte e executáveis;
O RUP é muito famoso por pregar que sua documentação seja feita com alto grau de burocracia.
São definidos aproximadamente 100 artefatos de os quais, aproximadamente 55, são editados através de processadores de texto.
O padrão estabelecido para definição dos artefatos é baseado em templates e exemplos.
Tais templates são moldes em linguagem natural que definem como os artefatos devem ser preenchidos.
Os exemplos são instâncias de templates já preenchidos.
Disciplinas Disciplinas, são conjuntos de atividades do processo, organizadas logicamente.
Existem nove disciplinas e elas são divididas entre técnicas e de suporte:
Disciplinas Técnicas:
Modelagem de Negócio, Requisitos, Análise e Projeto, Implementação, Teste e Instalação.
Disciplinas de Suporte:
Gerência de Projeto, Configuração e Mudanças e Ambiente.
Scrum. O Scrum é um processo de gerenciamento de software de o qual, pode- se criar um projeto de desenvolvimento de software de forma iterativa e incremental.
Tal PDS foi introduzido em 1995 por a Advanced Development Methodologies, ganhando popularidade depois da formação da Agile Alliance, em 2001.
O processo em si é ágil (agile) e leve (lightweight), permitindo também, a combinação com novos processos ágeis, podendo funcionar como um empacotador.
Conforme, o Scrum oferece uma abordagem empírica, permitindo que membros de uma equipe trabalhem de forma independente e coesiva, dentro de um ambiente criativo.
Desta forma, este PDS reconhece a importância do aspecto social em ES.
Segundo o trabalho de Schwaber, em 2004, o processo em si é bastante rápido, adaptativo, e organizado, além de ser bastante diferente dos processos de software seqüenciais.
Em a verdade, o Scrum acredita que um software não deve ser desenvolvido como se fosse um produto manufaturado, ou seja, de uma forma repetitiva.
Artefatos do Scrum De acordo com, um metamodelo é um modelo que serve para modelar um outro modelo conceitual, ou seja, é uma forma de descrever como um modelo deve ser modelado.
Um metamodelo também pode ser utilizado para modelar metadados, assim como configuração de um software ou os metadados dos requisitos, por exemplo.
Metamodelos provêm mecanismos e soluções independentes de plataforma que especificam:
A estrutura, sintaxe e semântica para ferramentas, frameworks ou tecnologias com metamodelos compartilhados;
Um modelo compartilhado para qualquer espécie de metadado;
Uma padronização de formatos para permitir troca de dados.
Em as próximas Seções serão apresentadas linguagens padrões de metamodelagem e modelagem utilizadas durante o trabalho.
Em a Seção 2.3.1 é apresentado o MetaObject Facility, que se promove como linguagem padrão de construção para construção de metamodelos, de a qual fizemos uso.
Mais adiante, na Seção 2.3.2, é apresentada a Unified Modeling Language.
MetaObject Facility. A Object Management Group (OMG), através do MetaObject Facility (MOF), adotou um padrão que, provê um arcabouço para gerenciamento de metadados.
Além disso, o MOF contém um conjunto de serviços para o desenvolvimento e interoperabilidade de sistemas desenvolvidos a partir de Modelos da Unified Modeling Language (UML) e que utilizam metadados.
O MOF pode ser utilizado para especificar e integrar famílias de outros metamodelos, bastando utilizar o conceito de modelagem de classes.
Como exemplo, na Figura 2.6 é apresentado a definição da UML que é especificada a partir de o MOF v2.
Em esta figura também é possível verificar que o MOF utiliza de reflection para se auto definir.
A especificação do MOF é integrada e reusa o pacote Core do metamodelo da UML, provendo um arcabouço mais consistente para a utilização de Model Driven Architecture (MDA) Tal pacote é discutido em mais detalhes na Seção 2.3.2.
Em o nível mais abstrato (M3), encontra- se a meta-metalinguagem, neste caso, a própria linguagem se auto-define e descreve as metalinguagens.
O MOF é uma linguagem que possui artifícios que a torna capaz de se auto-definir.
Somente a partir de esta camada, as metalinguagens (M2) irão descrever as linguagens (M1), ou seja, o MOF irá descrever uma metalinguagem capaz de definir uma linguagem.
Contudo, as meta-metalinguagens, metalinguagens e linguagens estão nas camadas de meta metamodelos, metamodelos e modelos, da arquitetura do MOF, respecitivamente.
Em a última camada estão as instâncias do modelo.
Para maior facilidade de compreensão, a Figura 2.8 apresenta um exemplo de utilização dos mesmos níveis de abstração desenvolvidos na Figura 2.7 para a linguagem UML sendo que:
Em a camada M3 está o MOF;
Em a camada M2 está o metamodelo da UML criado a partir de o MOF;
Em a camada M1 estão os modelos de usuário utilizados para modelagem UML e definidos por M2;
Em a camada M0 está um objeto criado a partir de a implementação do modelo UML em M1.
Modelos baseados no MOF utilizam alguns conceitos para aumentar o reuso através de outros modelos e metamodelos.
Desta forma, diferentes tipos de metadados podem ser criados.
A especificação do MOF é dividida em dois pacotes principais que sugeram dois Pontos de Conformidade (Compliance Points) diferentes:
O Essential MOF (EMOF) e o Complete MOF (CMOF).
Isto foi feito para separar em pacotes as diferentes capacidades (ou propostas de metamodelagem) do MOF.
O MOF contém algumas funcionalidades que são necessárias para a metamodelagem.
Tais funcionalidades estão localizadas em pacotes diferentes que estão mesclados através de package merge entre os Pontos de Conformidade supracitados.
As funcionalidades são:
Reflexion (pacote de reflexão), provê habilidade de se auto-definir;
Identifiers (pacote de identificadores), provê um identificador único para cada elemento;
Extension (pacote de extensão), significa estender elementos do modelo, tanto o nome, quanto os valores existentes.
A o se definir um metamodelo baseado em MOF pode- se utilizar diferentes níveis de formalismo, para:
Aumentar o nível de corretividade na descrição dos elementos da linguagem;
Diminuir ambiguidades e inconsistências;
Validar o metamodelo utilizando técnicas complementares;
E melhorar a legibilidade;
Como é bastante comum para especificação de linguagens, primeiramente pode- se definir a sintaxe da linguagem, para depois acrescentar suas semanticas (static semantics e dynamic semantics).
Em esse sentido, a sintaxe define os construtores da linguagem e como estes podem ser construídos a partir de outros construtores.
Já a semântica é definida da seguinte forma:
Static semantics, define como uma instâncias de construtorres devem estar conectadas para que exista algum sentido e geralmente são construídas a partir de regras de boa formação (wellformed rules) (ii) dynamic semantics, define o significado de um construtor desde que este esteja em seu estado correto (well-- formed).
Diante de isso, o MOF e seus metamodelos podem ser dotados de sintaxe e semântica.
Além disso, foi definida uma notação que funciona de forma idependente, sendo uma linguagem gráfica.
A partir de o mapeamento entre a notação para uma linguagem gráfica, definindo uma nova sintaxe (i.
e abstract syntax) pode- se obter uma sintaxe concreta (concrete syntax).
Embora existam esses níveis de formalismos, a descrição dos modelos e metamodelos formados a partir de o MOF não possuem uma especificação totalmente formal.
Unified Modeling Language. Conforme, a Unified Modeling Language (UML) é uma linguagem padrão para projetar, visualizar, especificar, construir e documentar um Produto de Software (PS).
O escopo da linguagem UML é muito abrangente e diversificado, cobrindo vários domínios em aplicações bem diferentes.
Nem sempre toda esta capacidade de modelagem é utilizada para todos os domínios.
Baseado neste contexto, a UML é dividida em diversos módulos que, podem ser selecionados de acordo com necessidade de utilização da linguagem.
Sendo assim, a UML v2 possui duas especificações que são complementares:
Infrastructure, define os alicerces estruturais.
Superstructure, define as estruturas necessárias para interação em nível de usuário.
Em a definição da UML existe um vocabulário e regras específicas que aumentam a facilidade de comunicação.
Isto foi feito por que a utilização de uma linguagem de modelagem é feita para aumentar o entendimento sobre o sistema.
No entanto, apenas um único modelo não foi suficiente para representar todo um sistema, sendo necessária a existência de vários modelos que estejam interconectados.
Portanto, a UML permite a utilização de diferentes visões de um mesmo sistema.
A UML dispõe de contêineres de abstrações visualizáveis na forma de diagramas.
Os diagramas servem para representar um mesmo sistema ou software sobre diversas perspectivas.
Para que isto seja possível, a UML dispõe de treze diferentes tipos de diagramas:
Diagrama de Classes;
Diagrama de Objetos;
Diagrama de Componentes;
Diagrama de Casos de Uso; Diagrama de Seqüência;
Diagrama de Colaboração;
Diagrama de Estados;
Diagrama de Atividades;
Diagrama de Implantação;
Diagrama de Pacotes;
Diagrama de Tempo;
Diagrama de Interação;
E Diagrama de Estrutura.
Como em qualquer linguagem, a UML possui uma série de regras para especificar como deve ser um modelo bem formado (well-- formed).
Estes tipos de modelos precisam ser semanticamente auto-contidos e estar em harmonia com modelos relacionados.
Tais regras são tanto sintáticas quanto semânticas a fim de definir:
Nomes, como devem ser os nomes das abstrações, dos relacionamentos e dos diagramas;
Escopo, o contexto em que estão os nomes, garantido sentido;
Visibilidade, como os nomes podem ser vistos e utilizados por outros;
Integridade, como as abstrações devem ser relacionadas;
Execução, execução ou simulação de um modelo dinâmico.
Além disso, para uma melhor organização e padronização, a UML possui quatro mecanismos que a fazem consistente:
Specification, provê um pano de fundo que garante valor semântico para as construções feitas graficamente;
Adornments, cada elemento da UML possui uma notação gráfica única, provendo representação visual;
Common divisions, na modelagem de sistemas orientados a objetos, o mundo sempre é dividido em diferentes caminhos para se chegar a um mesmo destino;
Extensibility mechanisms, para que a UML pudesse ser utilizada, representando um número maior de domínios específicos, foram definidos mecanismos de extensão:
­ stereotypes, estende o vocabulário da UML, permitindo a criação de novos blocos de construção para resolver um problema específico;
No entanto, o excesso de flexibilidade acaba por permitir a incompatibilidade entre duas ferramentas para modelagem UML distintas, que suportarem diferentes subconjuntos da linguagem.
Conseqüentemente, há algumas regras que exigem um balanço entre os módulos e a facilidade de troca de dados.
Entretanto, como a flexibilidade precisa ser mantida, UML provê o conceito de language units.
Uma language unit consiste numa coleção de conceitos de modelagem bem definidos que provêm o poder de representar aspectos de um sistema de acordo com um paradigma ou formalismo pré-determinado e escolhido.
Isto significa que um usuário somente precisa conhecer o subconjunto que julgar necessário de acordo com os modelos que irá utilizar.
Contudo, os grupos providos por os language units e os incrementos que se constituem, servem para simplificar a definição das regras de conformidade (compliance rules) da UML.
Isto é, o conjunto de conceitos do modelo da UML é particionado em camadas horizontais, chamadas de níveis de conformidade (compliance levels).
Cada ponto em que seja necessária alguma conformidade será chamado de ponto de complacência ou conformidade (compliance point).
Para facilitar a troca de modelos existem apenas dois níveis de conformidade definidos para a UML Infrastructure:
Nível 0.
Este nível contém apenas uma language unit que provê os tipos de estruturas (todas class-based) necessárias para modelar as linguagens OO mais populares.
Portanto, existe um primeiro nível (nível de entrada) que permite a modelagem.
Contudo, esta camada serve como base para a existência de interoperabilidade entre diferentes categorias de ferramentas para modelagem.
Metamodel Constructs (LM).
Este nível adiciona alguns language unit extras para obter estruturas (também class-based) mais avançadas.
Estas estruturas são utilizadas para a criação de metamodelos, assim como da própria UML (utilizando CMOF).
Para que os níveis de conformidade sejam suportados, existem mecanismos que são utilizados a partir de a especificação da UML.
Estes mecanismos permitem que os conceitos de modelagem definidos num nível determinado possam ser estendidos sem que percam suas características.
Para que os mecanismos funcionem, é necessário que os níveis de conformidade estejam num mesmo namespace.
Por esta razão, todos os níveis de conformidade estão definidos como extensões do pacote core da UML.
Este pacote define um namespace comum para todos os níveis de conformidades.
O nível 0 (L0) é definido por o metamodelo da Figura 2.10.
Arquitetura da UML Toda a especificação da UML é definida utilizando o metamodelo desenvolvido por a OMG.
Este metamodelo ajusta, ou melhor, acomoda as especificações formais e técnicas da UML.
Embora esta o metamodelo não apresente todas as formalidades da especificação rigorosamente, ele oferece vantagens por ser mais intuitivo.
A arquitetura da UML foi desenvolvida baseada em alguns princípios e padrões, sendo eles:
Modularity -- O princípio básico de alta coesão e baixo acoplamento.
Este padrão é aplicado ao se determinar grupos e separar- los em pacotes, agrupando as características em metaclasses;
Layering -- Layering é aplicado no metamodelo da UML de duas formas:
A estrutura de pacotes é dividida em camadas, separando as principais construções do metamodelo das construções que as utilizam.
É aplicado um padrão de quatro camadas arquiteturais do metamodelo a fim de separar- lo (especialmente no que se refere a instanciação) através de camadas de abstração.
Partitioning -- Utilizado para organizar os conceitos de uma mesma área, dentro de a mesma camada.
No caso de a biblioteca da Infrastructure, é utilizado um particionamento com O Software and System Process Engineering Metamodel (SPEM v2) (OMG, 2008 b) é um metamodelo para engenharia de PDSs assim como um arcabouço conceitual, provendo os conceitos necessários para modelar, documentar, apresentar, gerenciar, inter-mutabilidade e execução de métodos e processos de software.
Estrutura do Processo x Conteúdo.
O SPEM v2 separa a engenharia do processo em dois momentos principais:
Criação de uma biblioteca (Method Library), que armazenará o conteúdo (Method Content) e sua utilização num PDS (Method Structure), Figura 2.12.
Method content é tudo aquilo que provê explicações passo- a- passo, descrevendo como os objetivos serão alcançados independente ciclo de desenvolvimento.
Em esse sentido, um PDS fará uso dos elementos que formam o Method Content configurando- os para uma execução específica.
Definição do metamodelo.
Definição dos Pacotes. No tocante a o metamodelo, o SPEM v2 foi estruturado em sete pacotes principais, Figura 2.14, os quais são compostos aplicando- se o mecanismo package merge da UML.
Os pacotes apresentados na Figura 2.14 são abaixo descritos:
Core -- pacote que contém as classes e abstrações para a construção da base do metamodelo.
Process Structure -- pacote que define o metamodelo base modelagem de processos e que Pontos de Conformidade.
Audiência: Fornecedores de ferramentas com foco em compatibilidade com o SPEM v1.
X e modelagem.
SPEM Method Content O SPEM Complete compreende todos os três pacotes do metamodelo do SPEM v2, descritos em 2.4.3.
Este Ponto de Conformidade é recomendado para aqueles que desejam utilizar todo o metamodelo e suas capacidades.
Em a Figura 2.17 é apresentado um espaço de nomes chamado SPEM2-Method-Content, o qual utiliza- se de package merge para compor:
O LM, um nível de conformidade definido por a UML 2 Infrastructure Library, descrita em 2.3.2;
e o pacote Method Content, compondo através de transitividade os pacotes Managed Content e Core do SPEM v2.
Em esta seção apresentamos os principais trabalhos relacionados à construção de ASs.
Nosso objetivo foi analisar a literatura atual e observar se autoria de As tem sido objeto de pesquisa na comunidade da Engenharia de Software.
Porém, chegou- se a conclusão que os trabalhos mais recentes não possuem foco em Autoria de ASs, divergindo para outros fins.
Portanto, como o principal interesse desta pesquisa está relacionado à identificação das necessidades e soluções para a especificação e construção de uma Autoria de ASs, foram analisados os trabalhos que mais contribuíram com nossa abordagem.
Tais trabalhos são divididos nas Seções 3.1, que apresenta trabalhos relacionados no tocante a edição, classificação e organização de artefatos de software e 3.2, que demonstra a comparação com trabalhos que procuraram utilizar metamodelagem como meio da abordagem.
Em esta Seção, a análise comparativa das abordagens é baseada nos critérios de Autoria, Representação, Capacidades e Avaliação ou Testes.
Além disso, cada abordagem será apresentada conforme sua descrição e relação com o trabalho aqui proposto.
Em o que se constitui a Autoria, analisamos como as abordagens atacam os problemas em autoria de ASs em si.
Desta forma, definidos os atributos: (
A) Paradigma de construção, como a abordagem trata os artefatos?
Artefatos são vistos como uma união de fragmentos de informação?
Artefatos possuem estrutura lógica? (
B) Guia de construção, existe algum diagrama com fluxos?
Se sim, quais são os passos necessárias para se realizar a construção ou classificação dos artefatos? (
C) Escopo da abordagem, a abordagem permite a construção de que tipos de artefatos? (
D) Separação de Conteúdo, há uma clara divisão entre a estrutura do processo (Process Structure) e o seu conteúdo (Method Content)?
Em relação a Representação, verificamos como as abordagens atacam os problemas em autoria de ASs no tocante a utilização ou criação de uma linguagem própria.
Baseados em, analisamos os atributos:
Semântica Estática, existe descrição semântica sobre a utilização os contrutores?
Esta abordagem consiste na construção de um arcabouço para Documentos Compostos (Compounding Documents) chamado HotDoc, que permite a construção de documentos que não possuam somente texto, mas sejam flexívels a partir de partes dinâmicas, como tabelas, figuras, diagramas, gráficos, sons e vídeos.
Descrição: Cada documento é dividido em partes de diferentes tipos que podem ser aninha- das até formarem uma árvore.
Desta forma, as partes podem compartilhar mesmo modelo de dados através de ligações entre si, desde que as ligações sejam entre modelos compatíveis.
Autoria: Esta abordagem adiciona funcionalidades para a autoria de documentos, permitindo que o autor combine diferentes partes do documento.
Seu principal objetivo foi detectar a mudança de paradigma na construção de documentos.
Esta abordagem não apresenta um guia que explique como fazer a autoria e seu escopo é limitado apenas a documentos.
Além disso, não é apresentada separação entre estrutura e conteúdo de PDSs.
Representação: Em nossas análises não detectamos nenhum tipo de representação ou modelo.
Entretanto, algumas regras de formação são brevemente comentadas, mas sem nenhuma formalidade ou linguagem específica.
Capacidades: A abordagem não apresenta nenhuma das capacidades analisadas.
Validação ou Testes:
Esta abordagem consiste numa ferramenta implementada a partir de um arcabouço para Documentos Compostos.
O HotDoc foi implementado utilizando o padrão arquitetural Model-View--Controller (MVC) para VisualWorks Smalltalk.
A ferramenta permite que documentos possam ser construídos a partir de a inserção de novas partes num tipo de área de trabalho de usuário (workspace).
A interface com usuário permite o uso de objetos reposicionáveis e redimensionáveis, juntamente com a funcionalidade drag and drop.
Relação com a abordagem proposta:
Esta abordagem possibilita a criação de documentos baseando- se na montagem do mesmo por estruturas internas, tais documentos conhecidos como documentos compostos (compounding documents).
Esta abordagem não foi desenvolvida especificamente para autoria de ASs, entretanto, abrange a montagem de documentos, ou seja, determina um escopo menor.
Sobre questões de gerenciamento ou controle, não há qualquer referência sobre classificação, maturidade e versionamento.
Além disso, nenhuma representação ou conceitualização foi apresentada e embora seja um arcabouço, não foram apresentados pontos de extensão.
Finalmente, não foi identificado qualquer suporte para diferenciação entre a definição do documento, seu uso e sua instância.
Abordagem Cattaneo 2000.
Esta abordagem visa a permitir que documentos possam ser estruturados com base numa definição de XML.
Descrição: Pensando na estruturação de artefatos, os autores definiram um gerenciador de artefatos baseado na Web chamado Labyrinth.
Esta ferramenta permite a definição de artefatos através de XML Schema (XSD).
Autoria: Esta abordagem apresenta autoria com estruturação de artefatos e permite que o conteúdo esteja separado da definição.
Além disso, esta solução possui escopo em artefatos, mas não contempla nenhuma espécie de guia ou fluxo de autoria.
Representação: A solução abordada no trabalho destes autores apresenta uma definição de artefatos baseada em XSD e o protótipo foi modelado sobre diagrama Entidade Relacionamento (Er).
Entretanto, não há qualquer explicação sobre o XSD e o modelo Er apresentado e não é possível concluir que exista alguma semântica bem definida.
As linguagens utilizadas, por si só já possuem sintaxe e notação.
Capacidades: A abordagem não apresenta nenhuma das capacidades analisadas.
Validação ou Testes:
Para verificação foi desenvolvido um protótipo para Web e alguns exemplos de utilização são apresentados.
O protótipo apresenta como características navegação e preenchimento de documentos, controle de incosistências e sistema de notificações, que avisa quando um artefato foi modificado.
Relação com a abordagem proposta:
Conforme os autores, este trabalho possibilita a criação de documentos compostos, baseando- se na montagem dos mesmos a partir de outras estruturas.
Assim como em, esta abordagem não foi desenvolvida especificamente para autoria de ASs, e seu escopo se reduz à montagem de documentos.
Além disso, não há formas de efetuar classificação, maturidade ou versionamento e nenhum ponto de extensão foi apresentado.
Por fim, esta abordagem não diferência entre definição, uso e instância.
Esta abordagem apresenta um Banco de Dados Orientado a Objetos que permite a gerência de documentos.
Descrição: Nomeada como Compound Document access and Management (CDAM) esta abordagem provê um tratamento de documentos de forma a se tornarem coleções de partes ou componentes, formando uma agregação de pedaços de informações estruturadas com a propriedade de se auto definir.
Autoria: Em o contexto de autoria, esta abordagem apresenta uma construção de documentos sob o mesmo paradigma apresentado em, mas da mesma forma, não apresenta um guia explicativo para autoria e seu escopo também é sob documentos.
Além disso, não é apresentada separação entre estrutura e conteúdo de PDSs.
Representação: Em esta abordagem pode ser vista uma descrição semântica dos conceitos utilizados para autoria de documentos, utilizando linguagem natural.
Nenhuma outra forma de representação foi encontrada.
Capacidades: A abordagem não apresenta nenhuma das capacidades analisadas.
Validação ou Testes:
Não é definida nenhuma validação mas sim uma verificação através do uso de um protótipo implementado sobre um sistema de nome CDAM.
Tal sistema foi desenvolvimento seguindo os seguintes passos:
Inicialmente foi projetado um modelo, este modelo foi mapeado para um ambiente de banco de dados orientado a objetos e deste ambiente, foi criado um banco de dados relacional;
E que consiste num Bancos de Dados Relacional, um Sistema de Banco de Dados Orientado a Objetos, uma API geral de controle e uma API para suporte a métodos.
O Banco de dados Orientado a Objetos possui as seguintes tabelas que contém todas as informações:
Conforme os autores, este trabalho possibilita a criação de documentos estruturados, baseando- se na montagem dos mesmos a partir de outras estruturas definidas num documento XSD.
Assim como em alguns trabalhos anteriores, esta abordagem não foi desenvolvida especificamente para autoria de ASs, e seu escopo se reduz à montagem de documentos.
Além disso, não há formas de efetuar classificação, maturidade ou versionamento e nenhum ponto de extensão foi apresentado.
Esta abordagem possui um foco em classificação de artefatos produzidos num projeto, numa tentativa de controlar- los e gerenciar- los uniformemente.
Descrição: O autor dessa proposta sugere uma nomenclatura com base em uma classificação gerencial d documentação, que segue:
Software Description, Utilization Documents, Development Plans, Quality Control Documents and Administrative Documents.
Autoria: Diferente das abordagens anteriores, este trabalho não consiste em autoria de artefatos.
Seu foco é apenas em documentos no paradigma padrão.
Entretanto, é apresentado um guia resumido para utilização da abordagem, a partir de um arcabouço de classificação.
Representação: Em esta abordagem existe uma breve descrição semântica dos conceitos utilizados para classificação dos documentos, utilizando linguagem natural e uma tabela demonstrativa.
Nenhuma outra forma de representação foi encontrada.
Capacidades: De entre as capacidades analisadas, esta abordagem demonstra classificação de artefatos do tipo documentos.
Validação ou Testes:
O trabalho não apresenta nenhuma implementação, teste ou aplicação.
Relação com a abordagem proposta:
Como o foco desta abordagem é apenas classificar documentos produzidos durante a execução de um PDS, a única relação que pode- se fazer é conforme classificação.
A abordagem proposta possui classificação para um escopo maior, no caso artefatos, enquanto esta abordagem apresenta apenas classificação para documentos.
Por fim, não é apresentada qualquer validação, verificação ou teste.
Abordagem Tilley&amp; Müller, 1991.
Esta abordagem se constitui num facilitador para a documentação de artefatos do tipo código-fonte.
Segundo o próprio autor, sem uma boa documentação, o único meio de entender o código-fonte é analisando- o e mesmo que o código esteja bem documentado, muitas vezes está fora de o padrão utilizado por a companhia ou incompleto.
Descrição: O autor sugere uma ferramenta que age como um facilitador em hipertexto que permite anotar documentos de forma não intrusiva, o INFO.
A documentação e todos os comentários pertinentes são persistidos num arquivo texto, enquanto isso são utilizadas tags que correspondem as chamadas das informações contidas no código-fonte.
Autoria: O contexto desta abordagem é bastante específico, servindo apenas para determinar documentação de código-fonte.
Portanto, esta abordagem não apresenta nenhuma característica para autoria de artefatos.
Entretanto, o próprio autor demonstra como editar os documentos para acrescentar as tags previstas por a abordagem.
Representação: Esta abordagem apresenta uma linguagem de anotações baseada em tags, devendo possuir sintaxe e semântica.
Entretanto, existem apenas alguns exemplos de utilização e não é possível inferir que a semântica, embora exista, esteja bem definida.
Mesmo assim, algumas regras de formação são especificadas.
Capacidades: A abordagem não apresenta nenhuma das capacidades analisadas.
Validação ou Testes:
Houve a implementação do conceito e o próprio autor demontra exemplos de utilização e aplicação da abordagem, conforme dados sobre a experiência do usuário.
No tocante a ferramenta, o autor a julga desnecessária.
Relação com a abordagem proposta:
Esta abordagem apresenta um diferencial em relação as propostas anteriores, pois trabalha com artefato do tipo código-fonte.
Embora o foco não seja estrutura, o autor apresenta uma maneira de documentação diferente das abordagens utilizadas na indústria.
Além disso, esta abordagem não se trata de autoria, mas sim da criação de uma metalinguagem.
Em esse contexto, não foi possível encontrar os níveis esperados de formalismo no tocante a descrição e especificação da linguagem.
Por fim, não é possível concluir que exista alguma ferramenta específica ou protótipo para a utilização da abordagem.
Esta abordagem identifica um meio de melhorar processos de desenvolvimento de software por meio de a definição de níveis de maturidade para a documentação.
Descrição: A abordagem dos autores identifica um meio de melhorar o processo e definir quatro níveis de maturidade para a documentação do mesmo:
Ad-hoc, inconsistente, definido e controlado.
Cada nível é descrito por os seguintes campos:
Nome, descrição simples, palavraschaves, principais áreas do processo, principais práticas, principais indicadores, principais desafios e principais significados.
Autoria: Assim como, esta abordagem não consiste em autoria de artefatos e seu foco é apenas em documentos.
Além disso, é apresentado um guia resumido para utilização da abordagem, a partir de um arcabouço conceitual para definição de níveis de maturidade.
Representação: Em esta abordagem é apresentada uma descrição semântica dos termos utilizados para definir os níveis de maturidade dos documentos, utilizando linguagem natural e uma tabela demonstrativa.
Nenhuma outra forma de representação foi encontrada.
Capacidades: De entre as capacidades analisadas, esta abordagem demonstra apenas a maturidade de artefatos do documentos.
Validação ou Testes:
O trabalho não apresenta nenhuma implementação, teste ou aplicação.
Relação com a abordagem proposta:
Como o foco desta abordagem é apenas definir níveis de maturidade em documentos produzidos durante a execução de um PDS, única relação que pode- se fazer é conforme maturidade.
Esta abordagem proposta define níveis maturidade para um escopo menor, ou seja, apenas para documentos.
Regras de boa formação, a linguagem traz com si regras que definem a boa construção da abordagem?
Existem regras para auxiliar o entendimento?
No tocante a Modificações feitas no metamodelo UML, analisamos o que foi feito para que o metamodelo estendesse a UML a partir de o MOF, sendo possível:
Remover construtores existentes para evitar alguma má construção que esteja ocorrendo;
Adicionar algum construtor, diante de alguma herança ou relacionamento para aumentar a especialidade da linguagem;
Alterar construtores existentes, melhorando e tornando o metamodelo mais específico.
Finalmente, verificamos como as abordagens são validadas ou quais avaliações são feitas por os autores dos trabalhos analisados.
Partindo deste princípio, tomamos por base os atributos:
Instanciação, utilização da abordagem a partir de ferramentas externas ou sem apoio computacional;
Implementação, implementação da abordagem em alguma linguagem computacional ou implementação de processo de utilização não computacional;
Ferramental ou Protótipo, implementação da abordagem criando alguma ferramenta ou protótipo.
Abordagem. Descrição:
Esta abordagem consiste na definição e modelagem de um Processo de Software, utilizando UML como linguagem de modelagem.
Por se tratar de uma definição, os autores percorrem muitos conceitos de Orientação a Objetos e Processos de Software, formando a conceitualização de Processo como um Objeto.
Segundo os autores, tal contribuição permite o uso de ferramentas para automatizar a execução do Processo.
Tipo de Extensão da UML:
Segundo nossas análises, para a conclusão desta abordagem não foi feita nenhuma extensão da UML.
Níveis de formalismo da Linguagem:
Em este caso, por não se tratar de uma especialização da UML, não fica explícita a criação de uma linguagem própria.
Entretanto, é definido um domínio com características próprias a partir de os diagramas UML.
Tipos de Modelos existentes:
Em esta abordagem á apresentada apenas um nível de modelagem.
O modelo conceitual criado para modelar Processos de Software é um modelo de nível de usuário, que utiliza- se da própria UML.
Validação ou Testes:
Os autores deste trabalho não apresentam nenhuma implementação ou ferramenta capaz de automatizar a utilização da abordagem.
Também não foi encontrada nenhuma verificação, qualquer tipo de teste ou experimento.
Ao invés de isto, é apresentado um estudo de caso vinculado a um exemplo, não sendo um estudo de caso real.
Relação com a abordagem proposta:
Os autores trazem um trabalho de modelagem de PDSs utilizando paralelamente a definição de objetos, assim como nossa abordagem, que se constitui na modelagem de Artefatos de PDSs utilizando Orientação a Objetos.
Além disso, em nossa abordagem utilizamos os níveis de formalismo de linguagem abstrata e concreta e também apresentamos regras de boa formação e descrições semânticas.
Outro ponto bastante relevante é sobre a representatividade do modelo, uma vez que os autores dessa abordagem utilizam apenas um modelo de usuário UML.
Abordagem. Descrição:
Esta abordagem trabalha com a modelagem e metamodelagem dos conceitos de política de acesso a tarefas (task assignment policy) de Processos de Software.
Em este trabalho foram explorados os recursos possíveis de executar tarefas diversas, com base em política de acesso conforme três aspectos:
Organização, com foco sobre papéis organizacionais, assim como Gerente de Projetos e Gerente de Configuração;
Processo, com foco em algumas fases do ciclo de vida, hierarquia de atividades e os papéis executores;
E produto, no intuito de policiar artefatos de entrada e/ ou saída, além de controlar os papéis responsáveis por tais artefatos.
Tipo de Extensão da UML:
A UML foi especializada utilizando- se o mecanismo extensão heavyweight, caracterizando- se como uma modificação direta em seu metamodelo.
Segundo os autores, tal alteração é bastante sensível e não altera o comportamento inicial da UML.
Ao invés de isso, esta abordagem apenas adiciona novos construtores de linguagem, tornando este trabalho flexível e com três níveis de modelo:
Meta, conceitual e de instância.
Níveis de formalismo da Linguagem:
Quanto a os níveis de formalismo, este trabalho traz uma metalinguagem baseada em MOF e que estende UML, trazendo com si notação gráfica.
Entretanto, outros níveis de formalismo não foram encontrados.
Tipos de Modelos existentes:
São utilizados três diferentes tipos de modelos:
Meta, que consiste nos conceitos utilizados para criar metalinguagem;
Conceitual, definido por o meta;
E instância, que é justamente a instância do modelo conceitual definido por a metalinguagem criada por os autores.
Validação ou Testes:
No tocante a validação, este trabalho traz uma implementação feita através de softwares de geração de código.
Além disso, mostra uma instância da abordagem utilizando modelos em diagramas UML e exemplos.
Entretanto, nenhuma ferramenta é apresentada e não foram feitos estudos de caso ou experimentos para testar as funcionalidades, além disso, não há exemplos analíticos ou comparativos com casos reais e atuais.
Relação com a abordagem proposta:
Os autores desta abordagem utilizaram a extensão da UML, criando um metamodelo para permitir a modelagem de política de acesso em atividades e artefatos num PDS.
Em comparação com nosso trabalho, esta abordagem foi feita a partir de o mecanismo heavyweight de extensão da UML, enquanto nossa abordagem utiliza ambos os mecanismos de extensão.
Outro ponto de comparação é em relação a a falta de definição da semântica e regras de boa formação.
Além disso, os autores não trazem nenhuma ferramenta.
Abordagem. Descrição:
Baseados no fato de UML ser altamente aceita como linguagem de representação de Softwares, os autores desta abordagem propõem um metamodelo que estende a UML para permitir representação de domínio do estilo arquitetural específico.
Como os próprios autores se reservam a afirmar, esta abordagem é bem menos ambiciosa, por se limitar aos conceitos de uma única linguagem específica de arquitetura.
Tipo de Extensão da UML:
Esta abordagem utiliza- se do mecanismo de extensão da UML, adicionando novos metaconstrutores e criando uma nova metalinguagem para definir e prover modelagem arquitetural de software.
Segundo os autores, a utilização de estereótipos não seria suficiente para representar os elementos arquiteturais.
Níveis de formalismo da Linguagem:
Esta abordagem só não apresenta a linguagem de representação concreta.
Em este caso, tanto as regras de boa formação quanto uma linguagem abstrata devem estar presentes, além de as especificações semânticas.
Tipos de Modelos existentes:
Apresenta apenas o metamodelo e não dispõe de exemplos.
Validação ou Testes:
Os autores não apresentam nenhuma validação ou teste.
Relação com a abordagem proposta:
Em este trabalho foi desenvolvido um metamodelo para noção de Arquitetura de Software de acordo com o estilo C3.
Tal abordagem foi desenvolvida utilizando o mecanismo heavyweight de extensão da UML.
Assim como nossa abordagem, este trabalho também apresenta descrição semântica dos construtores da linguagem e uma linguagem abstrata, porém não descreve nenhuma linguagem concreta.
Os autores não mostram nenhum modelo de instância ou mesmo o modelo conceitual criado a partir de o metamodelo constituído.
Por fim, não é apresentada nenhuma implementação, teste, ou ferramenta.
Abordagem. Descrição:
Esta abordagem apresenta uma solução de modelo para os elementos que constituem a disciplina de Engenharia de Software.
Os autores utilizaram UML para modelar sua especificação, desde o metamodelo até a instância real da Engenharia de Software.
Estes modelos identificam os níveis de abstração da disciplina, desde seus pilares filosóficos, caindo por fim, na Engenharia de Software.
Desta forma, neste trabalho a Engenharia de Software é uma especialização da Engenharia, que possui seus fundamentos na Ciência, que por sua vez se baseia na filosofia.
Tipo de Extensão da UML:
Embora esta abordagem utilize- se de UML para construir os modelos, definindo vários domínios específicos, não há clara evidência de extensão da UML.
Níveis de formalismo da Linguagem:
Por não se tratar de uma especialização da UML, a linguagem descrita por os autores é apresentada como um modelo UML definido por os diagramas.
Embora existam os níveis de modelagem previstos para os diferentes aspectos da disciplina de Engenharia de Software, não foi possível identificar como as ligações de instância desses modelos foram restringidas.
Em outras palavras, não foi apresentado de forma clara como a Engenharia de Software pode ser uma instância da Ciência.
Tipos de Modelos existentes:
Embora não tenham sido identificados como modelos de definição de outros modelos, mas sim diferentes modelos de usuário da UML sem ligação entre si, aparentemente eles se constituem em metamodelo (Filosofia), modelo conceitual e (Ciência) e instância (Engenharia e Engenharia de Software).
Validação ou Testes:
Esta abordagem apresenta um exemplo para utilização de diferentes modelos chamados:
Functional Solution Model, Technical Problem Model e Technical Solution Models.
Estes modelos foram implementados em linguagem Java, com o banco de dados e seu acesso gerado em linguagem DDL e interface gráfica em Html, tudo isto utilizando geradores de código.
Em termos de validação ou testes, esta abordagem apresenta um exemplo de utilização de um Projeto European Institute, que se compromete em suportar processos de negócio entre os Estados-Membros Europeus e a European Commission.
Relação com a abordagem proposta:
Este trabalho não utiliza o MOF para criação de uma meta-linguagem, pois utiliza a própria UML para definir vários níveis de modelos que se instanciam entre si.
Em este trabalho também é apresentado implementação, porém nenhuma realização de ferramenta específica ou protótipo foi encontrado.
O objetivo desta seção é apresentar de forma sintética os resultados da comparação entre os trabalhos analisados e a abordagem definida nesta dissertação.
Para isto foi realizado uma análise comparativa, descrita anteriormente.
Os resultados desta análise estão ilustrados nas Tabelas nas Figuras 3.1 e 3.2 oriundas das Seções 3.3.1 e 3.3.2, respectivamente.
Resultado: Autoria de ASs Os critérios de comparação da Figura 3.1 foram definidos anteriormente na Seção 3.1.
A partir de a Figura 3.1 observa- se que:
Linguagem: Os níveis de formalismos de todas das abordagens analisadas são incompletas.
Apenas possui semântica estática e de todas, a mais completa é, que traz com si os outros níveis de formalismo exigidos.
Além disso, apenas em duas abordagens, das sete analisadas, existe notação e linguagem concreta.
Autoria: Em o que se diz respeito a autoria, a grande maioria das abordagens (cinco) possuem foco apenas em artefatos do tipo documentos, apenas uma em artefatos do tipo código-fonte, e apenas uma outra compreende artefatos em geral.
Como pôde ser visto, das abordagens analisadas, apenas os trabalhos de e trouxeram evidências no tocante a existência de um Guia para a construção.
Por fim, a separação de conteúdo não aparenta ser algo muito popular de entre as abordagens, entretanto, os paradigmas de construção de artefatos fica bastante dividido.
Características: De entre as características analisadas, foi observado que poucas ou nenhuma das abordagens corresponderam ao esperado.
Nenhuma das abordagens implementa ou sugere algum tipo de mecanismo para permitir extensibilidade da proposta e controle de versões dos artefatos.
Testes: Nenhuma da abordagens analisadas faz uso ou algum tipo de testes de instância, entretanto, a grande maioria utiliza- se de protótipos ou ferramentas computacionais.
Resultado: Metamodelagem.
Os critérios de comparação da Figura 3.2 foram definidos anteriormente na Seção 3.3.2.
A partir de a Figura 3.2 observa- se que:
Mecanismo de extensão da UML:
Entre as abordagens analisadas, apenas e fazem extensão da UML.
Tal extensão utiliza o mecanismo heavyweight, que como pode ser visto na Seção 2.3.2, caracteriza- se por adicionar ou alterar construtores da linguagem, conforme a necessidade de restrições.
Linguagem: No que se refere aos níveis de formalismo, apenas implementa o valor semântico de sua linguagem por completo, juntamente com regras de boa formação, o que não ocorre nas outras abordagens.
Entretanto, todos os trabalhos analisados utilizam notação em linguagem abstrata, porém, apenas dispõe de uma linguagem concreta.
Modificações feitas sobre UML:
Como pode ser observado, apenas as abordagens e alteram o metamodelo da UML, adicionando construtores a linguagem.
Porém, os próprios autores advertem que preferiram não alterar a UML numa tentativa de tornar suas linguagens mais independentes.
Tipos de modelos utilizados:
Para os tipos de modelos, foi analisada a existência de metamodelo e sua instância.
De os trabalhos analisados apenas não dispõe de metamodelo e apenas não continha um modelo conceitual que instanciasse o metamodelo proposto.
Testes: Embora e tenham proposto implementação e uso de suas abordagens, seus trabalhos não apresentam nenhuma ferramenta ou mesmo um protótipo.
Os outros trabalhos não apresentam nenhuma validação, verificação, formas de uso ou testes.
4 Autoria de Artefatos de Software.
Artefatos de Software são os elementos principais e o objetivo de existência de um PDS, pois espera- se que após o término de sua execução, todos os artefatos necessários tenham sido produtos.
Desta forma, o conjunto formado por os artefatos produzidos durante a execução de um PDS permite a criação de um Produto Final.
Entretanto, mediante a existência de vários e diferentes PDSs, nem sempre os termos e nome dos elementos são os mesmos aqui empregados.
Por isso, de acordo com o PDS utilizado, é bem comum encontrar nomenclaturas totalmente diferentes, mas que possuem o mesmo significado.
Desta forma, para fins de conhecimento e um melhor vocabulário comum, a Tabela 4.1 traz uma tradução dos diferentes termos encontrados nos PDSs atualmente mais comuns, no que se refere a Papel, Atividade e Artefato.
Por exemplo, um artefato do tipo Código-Fonte é totalmente diferente de um Documento de Visão.
Mesmo assim, não existe um padrão que determine como deve ser um artefato e não sabemos quem, ou o que, os construirá.
Por isso é complicado definir como os artefatos devem ser preenchidos sem a utilização de algum guia.
Partindo deste princípio e utilizando as facetas de definição, uso e instância pode- se definir artefatos para um Processo específico, assim como o RUP.
O RUP utiliza- se de uma lista de templates (definição) que especificam como devem ser os artefatos.
Além disso, são fornecidas informações sobre quais atividades e papéis devem ser utilizados para construir instâncias a partir de o template (uso).
Tais templates contam com breves descrições de conteúdo e estrutura para determinar como serão os artefatos (instância) do Projeto.
Por exemplo, para desenvolver o artefato Visão, do RUP, primeiro precisaríamos descobrir seu objetivo e conhecer seu template.
Desta forma podemos investigar sua estrutura e organização, encontrando dados para saber como deve ser o seu preenchimento e utilização dentro de o projeto.
Após isso, devemos saber quais atividades criam, alteram ou lêem o documento Visão e quais são os papéis atuantes neste artefato.
Após isto, segundo teremos informações suficientes para criar o artefato Visão durante um Projeto.
No entanto, artefatos devem ser especificados durante a fase de definição do PDS authoring, que por sua vez possui dois instantes de criação, Method Content e Process Structure.
Diferentemente, seu preenchimento, ou seja, sua produção é feita no decorrer de a execução do PDS (enactment) em forma de projeto.
Além disso, diferentes PDSs poderão produzir diferentes tipos de artefatos, que são na verdade a união de várias camadas para representação da informação.
Vejamos: (a) camada de informação ou conteúdo:
Em esta está toda informação considerada realmente importante e que poderá ser transformada em conhecimento.
Além disso, é levado em conta que diferentes informações possuirão diferentes níveis de restrições, os quais podem ser determinados através do tipo de informação (exemplo -- Numérico, string, data) ou sua necessidade (exemplo -- Empty, null, unique). (
b) camada de estrutura esta camada é responsável por (i) determinar a estrutura a ser utilizada para guardar o conteúdo da informação e verificar que (ii) a mesma informação pode ser estruturada de maneiras diferentes, sendo em suas formas (exemplo -- Imagens, tabelas, textos) ou em sua lógica de apresentação (exemplo -- Em capítulos, seções, subseções). (
c) camada de formato conforme a estrutura utilizada (i) faz- se necessário publicar, ou mesmo garantir que informações sejam visualizadas de forma a aumentar a compreensão sobre ela.
Desta forma a mesma informação pode ser vista de diferentes maneiras, dependendo da necessidade de representação (exemplo -- Um gráfico em barras ou pizza).
Por fim, diferentes processos podem utilizar diferentes metodologias ou métodos e produzir diferentes tipos de artefatos como resultado (exemplo -- Planilhas, documentos, arquivos XML).
Essa estrutura de camadas para construção de artefatos ajuda na definição dos papéis responsáveis por as fases do PDS.
Diferente dos atores existentes num PDS, os atores que o constrõem atuam em papéis exclusivos.
Sendo assim, poderíamos definir papéis como:
Engenheiros de Conteúdos ou Conhecimento, para investigar informações necessárias;
Engenheiro de Documentos para definir a estrutura de documentos e criar o Method Content;
E o Engenheiro de Processos para criar o Process Structure.
Portanto, sabemos que os artefatos armazenarão informações, utilizando- se de uma estrutura própria para o armazenamento e apresentando de forma com que o leitor entenda a informação disponível.
Assim como definido na especificação da UML, nossa idéia é definir um metamodelo para a autoria de ASs especificando a sintaxe e a semântica da linguagem, utilizando como base os princípios de:
Modularidade; Layering;
Partitioning; Extensibilidade;
Reuso; E utilizando:
Sintaxe: Representada através de notação UML, mostrando as metaclasses que definem os construtores da linguagem (como por exemplo:
Association, Operation, Property, entre outros) e seus relacionamentos;
Além de a existência de uma sintaxe computável;
Regras de boa formação:
Trata- se de um conjunto de regras de boa formação que são descritas usando OCL ou linguagem natural;
Semântica: Para cada construtor da linguagem é associado um significado.
Para isto é usado linguagem natural.
O uso da linguagem natural para especificar os elementos que compõem a linguagem, como a semântica, as regras de boa formação e sintaxe abstrata citados anteriormente, favorece o surgimento de ambigüidade.
Conseqüentemente, implica em dificuldades em estender o metamodelo da linguagem.
Este trabalho não tem como um de seus objetivos apresentar uma especificação formal da extensão do SPEM v2, mas sim uma descrição de autoria de ASs, seguindo as recomendações de extensão do metamodelo apresentada da especificação da linguagem.
Embora na literatura existam diversas maneiras de definir como devem ser PDSs, a utilização de UML para representar uma linguagem gráfica que permita reproduzir a criação de processos vêm se tornando cada vez mais popular.
Diversos metamodelos que explicam como devem ser os modelos de um processo determinado já foram ou estão sendo concluídos, assim como o metamodelo do RUP e do OPEN.
Entretanto, nenhum dos processos analisados possui um metamodelo que defina ASs de forma detalhada, constituindo- se a construção de forma manual, desde sua definição até o seu uso e instância.
Geralmente, no tocante a definição, uso e preenchimento é utilizada linguagem natural (como português e inglês) o que dificulta análise computacional posterior.
Desta forma, se quisessemos apenas obter ASs na forma tradicional, poderíamos determinar o nome e uma breve descrição e deixar a produção por conta dos papéis responsáveis.
Sendo assim, partindo do objetivo do trabalho, reutilizamos a linguagem UML para que seja possível a construção de um metamodelo que represente ASs detalhadamente, a partir de a extensão do metamodelo do SPEM v2.
Para evitar conflitos de nomes com os metamodelos da própria UML e SPEM v2, o metamodelo definido nesse trabalho também utilizada nomenclatura em inglês.
Conforme apresentado na Seção 2.3.2, ao se criar ou extender uma linguagem baseada no metamodelo da UML, deve- se utilizar o MOF.
Em a Figura 4.4 estão as camadas relativas ao que estamos propondo.
Em a camada M3 está o MOF, característico por permitir a criação de metamodelos, como os da camada M2.
O foco da modelagem da nossa proposta consiste em criar uma linguagem em nível M2, ou seja, uma metalinguagem, permitindo o seu uso na camada M1.
O modelo de domínio determinado através da nossa proposta de metamodelo pode ser realizado na camada M1, mesmo nível dos usuários da UML.
Em a camada M0 estão as instâncias, ou seja, elementos reais do processo, assim como artefatos, papéis e atividades.
Dado o SPEM v2, nossa extensão acrescenta os elementos cruciais para criação de artefatos em detalhes.
No decorrer de esta Seção estão apresentados os diversos problemas identificados por este trabalho, juntamente com a solução encontrada.
Tal solução é apenas uma breve descrição das partes modeladas para a constituição de um metamodelo comum ao SPEM v2 e a UML, sua especificação completa pode ser vista no Apêndice B2.
As análises foram feitas a partir de ASs definidos em dois processos de software diferentes, RUP (processo tradicional) e SCRUM (processo ágil).
Para o RUP foram utilizados os artefatos definidos em e comparados com os mesmos dos software Rational Unified Process, baseado na Web.
Já para o SCRUM foram utilizados os artefatos definidos em.
Cenário 1 -- Tipificação dos Artefatos envolvidos Atualmente, ASs são preenchidos com a utilização de ferramentas específicas e que trabalham de acordo com o tipo do artefato.
Porém, durante um projeto, estes tipos estão fortemente atrelados a informação da extensão do arquivo.
Desta forma, se um artefato possui uma extensão compreendida por algum software específico, poderá então ser manuseado.
Alguns exemplos de ferramentas bastante utilizadas são:
Microsoft Office WordTM ou Open Office Writer, para ASs que possam ser preenchidos como documentos;
Microsoft Office ExcelTM ou Open Office Calc, para ASs a serem preenchidos como planilhas de cálculos ou matrizes;
IMB Eclipse1 ou Sun Microsystems NetBeans2, geralmente utilizados para artefatos de código-fonte;
IBM Rational Modeler 3 ou Enterprise Architect 4, para modelagem Orientada a Objetos utilizando UML.
Pontos Fracos Conforme nossas análises, os pontos fracos desta abordagem são:
Não existe uma lista que apresente os tipos de ASs existentes;
O tipo de cada As é determinado a partir de sua extensão ou ferramental utilizado.
Análise e Resultados.
Comparação com abordagens atuais Com a introdução de tipificação, podemos determinar os possíveis tipos de ASs, desde a definição até o preenchimento dos mesmos.
Além disso, é possível criar categorias de ASs baseados nos tipos, uma vez que são conhecidos.
Cenário 2 -- Definição das Estruturas das Informações participantes.
Conforme analisado, diferentes ASs possuem diferentes informações.
Tais informações carregam com si uma determinada estrutura e possivelmente formas diferentes de visualização.
Entretanto, atualmente não existe um padrão ou formato para estas informações, dificultando tanto sua definição estrutural, quando o seu preenchimento posterior.
Pontos Fracos Esta abordagem tráz com si alguns problemas como:
Falta de conhecimento prévio da estrutura a ser utilizada em determinada informação;
Má interpretação do tipo ou estrutura a ser utilizada;
Preenchimento ambíguo por conta da decisão de estrutura tardia;
Falta de padronização estrutural.
Exemplos Exemplo 1: O artefato Modelo de Caso de Uso demonstra alguns problemas em relação a sua estrutura.
Apesar de ser baseado em UML, no RUP é utilizado um Template que especifica uma estruturação para cada caso de uso.
Desta forma, temos que construir Casos de Uso UML a partir de sua especificação.
Isto gera bastante confusão na estrutura a ser utilizada, pois pode- se utilizar tabelas, texto livre ou até uma estrutura específica para a especificação enquanto que seu modelo poderia ser em UML ou até mesmo uma representação em forma de figura.
Portanto, fica difícil determinar o que será um caso de uso, pois é dependente de contexto.
Exemplo 2: O SCRUM apresenta o mesmo problema.
O artefato BurnDown Chart é representado através de um gráfico em forma de imagem, seus dados são coletados em planilhas.
Sendo assim, este artefato poderia ser representado através de uma tabela simplificada ou de listas.
Embora isso ocorra, naturalmente existe uma padronização do gráfico, mas não da estrutura que este deve utilizar.
Análise e Resultados Conforme verificações em templates de ASs, obtivemos os seguintes resultados:
RUP: De 108 artefatos apenas 39 possuem templates e 21, exemplos;
Não há artefatos de tipos binários, planilha e código fonte que possuam templates ou exemplos;
De 32 artefatos do tipo modelo UML, apenas 3 possuem templates e outros 4 possuem exemplos;
De 50 artefatos do tipo documento, 36 de eles possuem templates e destes, 17 possuem exemplos;
Scrum: De os 8 artefatos analisados, todos possuem templates e apenas 2 não possuem exemplos.
Em este próximo passo classificamos os tipos de informações existentes, utilizando três tipos possíveis de classificação:
Simples ou Primitiva, sendo os tipos mais simples possíveis;
Complexa, informação que deve possuir alguma estruturação mínima e que utiliza os tipos simples;
E Específica, geralmente informação bem estruturada mas encontradas especificamente no processo analisado.
Após a classificação, os resultados obtidos foram:
RUP: 97 tipos de estruturas, sendo 2 simples, 9 complexas e 86 específicas.
Scrum: 14 tipos de estruturas, sendo 2 simples, 5 complexas e 7 específicas.
Concluindo, os tipos encontrados foram:
Simples -- Texto, Texto com Etiqueta e Imagem;
Complexo -- Comentário, Diagrama, Lista, Tabela, Grupo, Pergunta e Plano X, Y (conteúdo desenvolvido a partir de informação para montagem de eixo euclidiano x, y).
Cenário 3 -- Determinar a Estrutura Interna dos artefatos envolvidos.
Cada AS possui uma estrutura interna que serve para viabilizar o acesso as informações expondo- as eficientemente.
Conforme existem diferentes artefatos, também podem existir diferentes estruturas.
Além disso, muitas vezes um conteúdo informativo sofre avanços ou incrementos no decorrer de o projeto.
Outras vezes, a mesma informação sofre correções ou refinamentos.
Desta forma, a informação estará sendo exposta de diferentes maneiras a medida que evolui, sendo importante que a estrutura de um artefato esteja flexível o bastante para suportar essas mudanças na informação.
Geralmente, a estrutura escolhida para um artefato é dada para organizar informações.
Caso contrário, informações estariam jogadas no artefato conforme a estrutura específica de cada uma.
Pontos Fracos. De acordo nossas análises, os pontos fracos desta abordagem são:
Não existe uma informação que caracterize a estrutura do artefato em relação a o seu tipo;
Por o preenchimento ser dependente de ferramenta do tipo Office, a abordagem torna- se bastante flexível, porém sem estrutura bem definida;
Não é possível determinar ou categorizar a informação estruturalmente, apenas visualmente.
Exemplo. O artefato Lista de Riscos possui uma estrutura baseada em seções, dividindo as informações sobre os riscos em vários níveis.
Desta forma, embora a própria informação possua uma estrutura é importante que o próprio artefato possa categorizar- la, para melhor disponibilizar as informações existentes.
Análise e Resultados Dados artefatos de ambos os processos supracitados, encontramos as estruturas do tipo:
Árvore, comum em documentos;
Lista; E tabela, comum em planilhas;
Solução encontrada.
Conforme observamos, todas as estruturas encontradas podem ser derivadas de uma única estrutura genérica baseada em composição, que é uma solução bastante comum em estrutura de dados.
Optamos por utilizar uma estrutura mais genérica em detrimento de estruturas específicas por o fato de haver maior flexibilidade pois, aparentemente, não parecia haver ganho em introduzir uma modelagem mais complexa com diferentes estruturas especificas de ASs.
A Figura 4.8 apresenta a modelagem que foi feita para tornar possível a estruturação do As.
Em esta mesma Figura está a metaclasse responsável por definir a estrutura geral de As, a ContainerDefinition.
Como pode ser visto, cada contêiner possui ainda dois relacionamentos do tipo pai/ filho, melhor representado a partir de a metaclasse ContainerDefinition_ Relationship criando uma espécie de estrutura composta genérica que permite a criação de vários contêiners alinhados.
Cenário 4 -- Classificação dos diferentes ASs Como a idéia central para a produção de artefatos de software é armazenar informações pertinentes para concluir um produto de software específico.
Entretanto, a falta de indexação pode causar problemas, tornando difícil um possível busca alguma informação necessária.
Em esse contexto, basicamente não existem soluções de recuperação que não sejam ferramentas de busca de terceiros.
Mesmo assim, muitas vezes sabe- se sobre a informação, mas não se consegue recuperar- la através de buscas baseadas em palavras-chaves.
Conforme visto em, nesta abordagem também classificamos ASs de acordo com os tipos de conteúdo que eles conterão.
Assim tornando mais completa a classificação do tipo de armazenamento a ser feito diante de as informações de um artefato.
Pontos Fracos. Desta forma, sabemos que existem dificuldades na classificação da informação armazenada, tendo em vista problemas de recuperação da informação por falta de organização dos ASs num projeto.
Exemplo. A busca de informações durante o desenvolvimento de um Produto acaba por ser facilitada, desde que seja uma informação essencial ou bastante conhecida.
Desta forma, caso desejássemos localizar alguma nova solicitação feita por o Stakeholder, por exemplo, conseguiríamos encontrar o As através das próprias divisões do processo, como disciplinas e atividades específicas, utilizando algum rastreamento.
Em todo caso, uma vez terminado o projeto, determinar as solicitações ocorridas, quando esta informação já foi esquecida por os antigos membros do projeto, tornará- se- um problema.
Solução encontrada.
A Figura 4.9 apresenta as metaclasses quer permitem a classificação de artefatos de acordo com a abordagem vista em.
Como pode ser visto, a metaclasse abstrata ClassifiedElement possui um relacionamento com ClassElement, permitindo que suas subclasses sejam classificadas de acordo com a enumeração ClassElementKind.
Todo elemento que possa ser classificado de acordo com os tipos definidos na enumeração deve ser um ClassifiedElement, neste caso os artefatos.
Comparação com abordagens atuais Classificações para informação são feitas geralmente sobre documentação e na maioria das vezes, sobre documentação pronta de um projeto.
Além disso, faz- se o uso de classificações externas aos documentos, através de tabelas ou com utilização de hierarquias feitas por algum sistemas de arquivos.
Nossa abordagem provê uma implementação para o trabalho de que se constitui em classificar mais do que documentos, ou seja, ASs e de forma que seja internamente, sem a necessidade de outra ferramenta ou recurso.
Cenário 5 -- Definição de níveis de Maturidade Partindo do princípio que artefatos são pontos de medidas para determinar o nível de maturidade de um PDS, adicionamos a definição de níveis de maturidade baseados em.
Desta forma, existe a gerência de artefatos em relação as modificações feitas durante a autoria e uso dos mesmos, verificando o quão próximo de o ideal está o PDS.
Atualmente as abordagens de maturidade são feitas com base nos Processos, inclusive PDSs.
Desta forma, os ASs são analisados para determinar o nível de maturidade em que se encontram, medindo o PDS e a empresa que o adota.
A grande maioria das análises é feita conforme gabarito externo aos artefatos que, mediante consulta e rastreabilidade, consegue- se determinar o quanto cada artefato está maduro dentro de um Projeto.
Em estas abordagens, os pontos fracos são:
A forma subjetiva para determinar o nível de maturidade de cada um dos artefatos já preenchidos;
A necessidade de rastrear os artefatos mediante tabela de maturidade;
Uso de gabarito comparativo que determina apenas o instantâneo em relação a o preenchimento dos artefatos, não a sua estrutura anterior.
Exemplo Em o RUP, o artefato Visão do Negócio é um reflexo criado a partir de o Template sugerido na fase de autoria do PDS.
O objetivo do documento é capturar os objetivos relacionados a modelagem de negócios num nível bastante abstrato.
O documento Visão do Negócio é criado na fase de Iniciação de um projeto e usado como base para o Caso de Negócio e como primeiro rascunho do documento de Visão.
Por isso, está intrinsecamente relacionado ao projeto, desde o esforço de Engenharia do Software até o Caso de Negócios e o documento de Visão.
Desta forma, por ser um artefato complexo faz- se necessário verificar qual o nível de maturidade em que se encontra durante o projeto.
Mesmo assim, apenas isso só poderá ser feito após a execução de algumas atividades, por conta de necessidade de preenchimento.
De acordo com, podemos verificar o nível de maturidade do artefato ainda em seu template, mas será medido o nível de maturidade do Processo, não sua execução.
Comparação com abordagens atuais Com a utilização desta solução é possível definir de um modo mais granular o nível de maturidade de um projeto.
Desta forma, podemos definir o quanto cada artefato nas diversas camadas do PDS, desde o Method Content, Process Structure até o Process Enactment.
Cenário 6 -- Inserção de Mecanismo de Versionamento.
A o se trabalhar com informação, principalmente em grandes quantidades, são utilizados repositórios de dados, na busca por garantias de armazenamento.
Muitos repositórios funcionam com base em instantâneos feitos durante períodos de tempo, garantindo que diferentes versões da mesma informação sejam guardadas.
Devido a o fato de PDSs se constituírem em três camadas (authoring, tailoring e enactment) o nível de dados existentes sobre um único PDS é bastante alto, necessitando de repositórios capazes de armazenas os diversos instantâneos gerados a medida que as alterações ocorrem.
Como pode ser visto na Figura 4.11, existem diferentes repositórios para armazenar as informações das diversas camadas, ou facetas, distribuídas a medida que um PDS muda de estágio.
Como se trata de uma extensão do MOF, o MOF Repository adiciona estas metaclasses na própria camada M3.
Desta forma, qualquer linguagem definida a partir de esta extensão do MOF, poderá ser versionada.
Como pode ser visto na Figura 4.12 a metaclasse VersionedExtent herda Extent.
Em o contexto do MOF, um Extent é responsável por aplicar algumas das capacidades a elementos do MOF, assim como gerar a identificação através de Uniform Resource Identifier (URI).
Através de VersionedExtent é possível obter versões e históricos do que foi alterado.
O MOF Repository ainda contém metaclasses responsáveis por determinar workspaces, Baselines e definir sessões.
Comparação com abordagens atuais Com a utilização do MOF Repository é possível verificar o que exatamente foi alterado dentro de as camadas existentes num PDS.
Além disso, também é possível saber o papel responsável por as alterações.
Finalmente, é possível rastrear os elementos da modelagem nas diversas camadas modeladas para um PDS.
Cenário 7 -- Relacionar os artefatos utilizando diferentes níveis de reuso e compartilhamento Existe uma grande preocupação por parte de a indústria no modo como é feito o armazenamento de informações durante a execução de um processo.
Como sabemos, estas informações são guardadas nos artefatos, porém, a preocupação está em armazenar- las corretamente.
Cenário 8 -- Envolver a estruturação de ASs com o PDS.
Em o cenário atual de modelagem de PDS, papéis, artefatos e atividades estão interligados entre si.
Desta forma, é possível identificar quais atividades são responsáveis por dado artefato e seus respectivos papéis.
Conforme identificado em alguns PDSs, assim como RUP e OPEN, é bastante comum a utilização de sub-atividades, ou seja, dividir uma atividade em pedaços menores.
Muitas vezes uma atividade chega a ser subdividida a ponto de ser tornar uma tarefa (task), empregada apenas um papel exclusivamente.
Além disso, também é bastante comum o desenvolvimento de grupos de papéis (Composite Role), que juntos contém competências, ou qualificações suficientes para atuar em atividades um pouco mais exigentes.
Assim como as tarefas são exclusivas e interligadas com papéis específicos, que muitas vezes são agrupados, um artefato também precisa se relacionar desta forma, para que as restrições de execução da atividade, em meio de tarefas e papéis, sejam correspondidas.
Portanto, diante de o fato de nossa abordagem subdividir ASs, devemos também alinhar tais fragmentos e contêineres as atividades e papéis correspondentes.
Atualmente, já que PDSs tratam ASs de forma monolítica, ou seja, inteiros e sem divisões, existem alguns problemas conforme a ligação entre os papéis atuantes e as atividades correspondentes, tais como:
Artefatos são produzidos inteiramente, sem identificar quais pontos serão produzidos durante aquela atividade;
Necessária experiência e conhecimento prévio sobre construção do artefato para seu preenchimento correto durante atividade;
Os papéis precisam conter maior quantidade de competência ou qualificações para executarem uma atividade dado o fato de produzirem artefatos inteiros;
Em um artefato não existem informações suficientes para identificar as atividades que foram responsáveis, nem quais partes foram construídas.
Exemplo A construção do artefato Visão, é feita parte a parte, ou seja, ao longo de a execução de diversas atividades do PDS, neste caso o RUP.
Para a execução dessas atividades são necessários diferentes papéis.
A exemplo temos as atividades Capturar um Vocabulário Comum que requisita um Analista de Sistemas, Localizar Atores e Casos de Uso de Negócios que precisa de um Analista de Processo de Negócios e Localizar Entidades e Trabalhadores de Negócios que utiliza um Designer de Negócios, e assim por diante.
Como pode ser visto, um mesmo As pode ser construído por diversos papéis diferentes, em diversas atividades diferentes.
Embora a documentação do RUP apresente quais passos devem ser feitos para executar as atividades, não fica claro quais partes que constituem o artefato Visão devem ser feitas por Quem (Papel) e Quando (Atividade).
Desta forma, após o preenchimento do artefato, tais informações são praticamente impossíveis de rastrear dentro de um PDS.
Entretanto, muitas vezes a experiência adquirida num PDS específico permite que este conhecimento seja formado ao longo de o tempo.
Porém, muitas vezes não se usa o mesmo processo inteiramente, além disso, suas execuções são diferentes entre si.
Solução encontrada Para este fim o SPEM v2 foi estudado cuidadosamente, sendo identificados seus pontos de extensão.
Por ser um metamodelo flexível e uma extensão da UML para desenvolvimento de um domínio específico, sua construção foi feita determinando diferentes níveis de conformidade (compliance levels).
Por fim, devemos integrar a extensão do metamodelo com o metamodelo original, combinando assim a autoria de ASs com a autoria de PDSs já definida por o SPEM v2.
Como o próprio SPEM v2 já possui a conexão entre artefatos, papéis e atividades, dadas por as metaclasses WorkProductDefinition/ WorkProductUse, RoleDefinition/ RoleUse e ActivityDefinition/ ActivityUse, para haver integração é necessário definir como será a interação entre os mesmos em relação a os conceitos acrescentados no metamodelo.
Devido a extensão, artefatos e suas informações contêm tipo e estrutura interna, para adicionar este conhecimento aos papéis e atividades, deve existir uma ligação que permita tal sincronia.
Em a Figura 4.18 estão algumas das metaclasses da extensão feita sobre o SPEM v2, em tons mais claros.
As metaclasses ArtifactDefinition, ContainerDefinition e FragmentDefinition, já definidas anteriormente em 4.3.3, foram remodeladas como sub-classes de WorkProductDefinition, herdando o auto relacionamento previamente definido por a metaclasse do SPEM v2 WorkProductDefinitionRelationship.
A metaclasse abstrata SimpleInformationElement tambem é uma dessas subclasses, por transitividade.
Desta forma, passa a existir uma conexão entre o metamodelo definido por a OMG e a extensão realizada nesse trabalho.
Vale notar também, que qualquer alteração na metaclasse WorkProductDefinition será espelhada para suas subclasses.
Relacionamento entre papel e artefato.
Para definir a interação entre artefato e atividade foi reutilizada a estrutura do SPEM v2.
Em a Figura 4.20 está definido um diagrama que representa esta ligação.
Através da metaclasse Default_ TaskDefinitionParameter do SPEM v2 pode- se criar um elo de ligação entre as subclasses de WorkProductDefinition e TaskDefinition, que especializa WorkDefinition.
A metaclasse WorkDefinition modela o conceito de trabalho a ser realizado podendo ser um sinônimo para atividade, embora mais geral.
Relacionamento entre papel e atividade do SPEM v2.
Comparação com abordagens atuais Desta forma, tanto a estrutura da informação, quanto a estrutura do artefato devem possuir relacionamentos com papéis e atividades.
A partir deste ponto pode ser visto que é possível determinar, exatamente, o que cada papel será responsável em produzir, conforme ação específica a ser feita numa atividade que deva manipular um artefato.
Em a Seção anterior houve a especificação da Definição dos ASs, tornando possível utilizar uma linguagem para a permitir a Autoria de ASs, conforme essa especificação.
Entretanto, apenas definir como deve ser um artefato não basta para que ele possa estar num PDS.
Para solucionar este problema devemos adicionar uma camada que permite a utilização dos artefatos por os PDSs, sem alterar suas definições.
Portanto, para que exista uma autoria completa, apresentaremos nessa Seção como se deu a construção da camada de ligação entre a definição dos artefatos e a definição da estrutura de PDSs, conhecida por Process Structure, ou simplesmente por uso.
Assim como na última Seção, utilizaremos uma estrutura comparativa entre este paradigma e o atual, mostrando:
Pontos fracos do paradigma atual, a nossa solução e, por fim, a comparação entre as soluções.
Pontos Fracos. Dentro de a abordagem tradicional, mais especificamente nos processos avaliados (Scrum e RUP), notamos a utilização constante de templates, exemplos e guias de utilização.
Os templates são na maioria das vezes esqueletos dos artefatos originais, publicados de forma que sejam auto-explicativos.
Além disso, notamos que os templates são utilizados para definir como devem ser artefatos do tipo documentos e dificilmente são feitos templates para outros tipos de artefatos, embora seja possível.
Em esse sentido, existe um grande problema:
Já que nem todos os artefatos possuem templates, como pode- se utilizar- los, já que não existe a própria definição?
Ou seja, o maior problema está na parte de utilização desses templates.
Embora sejam documentos que indicam a estrutura de seções e como devem ser preenchidos, não há uma clara definição de certo ou errado quanto a os tipos de informação.
Para tentar corrigir esta situação, são utilizados exemplos, guias e ferramentas específicas, porém, o sucesso depende puramente da interpretação do responsável por o preenchimento do artefato.
Além disso, os templates nem sempre são utilizados por completo, ou seja, neste paradigma não ficam claras as alterações feitas no que se diz respeito a utilização dos templates (i.
e remoção, alteração, adição de definições), durante a criação do PDS.
A construção do artefato Visão, é feita parte a parte, ou seja, ao longo de a execução de diversas atividades do PDS, neste caso o RUP.
Para a execução dessas atividades são necessários diferentes papéis.
A exemplo temos as atividades Capturar um Vocabulário Comum que requisita um Analista de Sistemas, Localizar Atores e Casos de Uso de Negócios que precisa de um Analista de Processo de Negócios e Localizar Entidades e Trabalhadores de Negócios que utiliza um Designer de Negócios, e assim por diante.
Solução encontrada.
Em este contexto, a solução que foi utilizada é a mesma encontrada na especificação do SPEM v2.
O metamodelo da OMG já traz a noção de separação do conteúdo do Processo, de sua estrutura.
Desta forma, os artefatos podem ser utilizados através do padrão Proxy, conforme a Figura 4.22.
Comparação com abordagens atuais.
Em relação as abordagens atuais, nossa abordagem permite entender o relacionamento entre a definição dos ASs e o seu uso em PDSs.
As abordagens atuais não permitem avaliar este relacionamento, pois não utilizam o conteúdo separado da estrutura, sendo assim, dificilmente conseguem estabelecer ligação entre a instância do artefato e seu template.
Em nossa abordagem o uso dos artefatos é feito a partir de uma definição, ou seja, todos os artefatos obrigatoriamente terão uma definição única.
Por isso é possível saber qual foi o tipo de uso, percebendo se houve alguma alteração a partir de o próprio modelo.
Atualmente nem todos os artefatos possuem definição e mesmo o que são providos de templates ou até mesmo exemplos, dependem de interpretação de definições feitas em linguagem natural.
Definir nova Biblioteca:
Aqui estão agrupadas as atividades responsáveis por definir uma biblioteca de configuração.
Esta biblioteca permitirá a criação de conteúdos e estruturas de PDSs.
Criar Method Content: Aqui estão agrupadas as atividades responsáveis por definir o conteúdo.
Desta forma pode- se utilizar o conteúdo previamente definido para construir a estrutura de até mesmo uma família de PDSs.
Definir Process Structure: Aqui estão agrupadas as atividades responsáveis por definir a estrutura de um PDS.
Tal estrutura especifica exatamente como deve ser o uso de um conteúdo prévio, fazendo ligações e relacionamentos com os elementos que constituintes da biblioteca de conteúdo.
Publicar Processo: Em esta última macro-atividade estão agrupadas atividades afins no contexto de publicar o PDS criado a partir de as macro-atividades anteriores.
Além disso, a Figura 4.25 também apresenta os papéis responsáveis por a execução das atividades supracitadas, assim como os artefatos de os quais são responsáveis:
Configurador: O ator deste papel deve ser responsável por configurar todo o Ambiente de Autoria de Processos.
Desta forma, ele deverá produzir o artefato Biblioteca (Spemxt Library) e preparar- lo para receber os dados das próximas atividades.
Em este momento o Spemxt Library encontra- se vázio no que se refere a PDSs.
Engenheiro de Conhecimento: O ator deste papel deve ser responsável por criar conteúdo reutilizável por o processo, definido elementos como papéis, atividades e artefatos.
O conteúdo produzido deverá entrar no Spemxt Library.
Engenheiro de Processos: O ator deste papel deve ser responsável por criar a estrutura do Processo reutilizando os elementos produzidos por o Engenheiro de Conhecimento.
O Engenheiro de Processo deve ser capaz de combinar os diversos elementos existentes no conteúdo para criar um Processo geralmente específico para um domínio.
Toda a estrutura produzida, assim como os relacionamentos criados para se utilizar os elementos do conteúdo deverão entrar no Spemxt Library.
Além disso, o Engenheiro de Processo ainda deve publicar o PDS para que este possa ser utilizado, criando o Artefatos diversos, geralmente em páginas Html.
Após descrever esta visão geral sobre o fluxo de atividades que descrevem o guia para autoria, apresentaremos as macro-atividades com maiores detalhes nas Seções a seguir.
Definir nova Biblioteca.
Primeiramente, para criar uma nova biblioteca deve- se definir o espaço necessário para o armazenamento dos dados.
Conforme nossa abordagem, toda a biblioteca será definida num arquivo, entrentanto, deve- se ter em mente que podem ser utilizadas outras tecnologias, assim como banco de dados.
Logo após sua criação, a biblioteca deve ser nomeada.
Além disso, também é interessante, mas não obrigatório, deixar breves descrições para que ela possa ser identificada mais adiante, preparando- a para o uso posterior.
Conforme a necessidade de identificação, o nome, ou talvez um identificador externo deve ser único, evitando problemas de ambiguidade.
O fluxo de atividades para a criação de uma nova Biblioteca pode ser visto na Figura 4.26.
Criar Method Content. A construção de ASs não possui um fluxo complexo, precisando apenas de dois, no máximo três, passos para ser concluída.
A definição de ASs deve ser feita de forma detalhada, por isso é importante utilizar os contêineres, agrupando as informações quando necessário, porém, isto não é obrigatório.
Em a Figura 4.28 é apresentado o diagrama que explica como configurar os artefatos conforme nossa abordagem.
Esta configuração só pode ser feita quando os conteineres e tipos de informações a serem utilizados já estiverem criados.
Conforme esse diagrama, devese inserir os contêineres selecionando também o tipo de relacionamento entre eles e o artefato.
Definir Process Structure. Após criar o Method Content, segundo o Guia, já é possível incluir o Process Structure.
Sendo assim, o próximo passo é criar a estrutura dos PDSs.
Esta atividade é quase exclusiva, pois deve ser feita para cada PDS existente.
O Process Structure também possui diversos elementos a serem definidos, na verdade, ele funciona como um espelho do Method Content, refletindo todos os elementos existentes no conteúdo, assim como papéis, atividades, tarefas e ferramentas, com exceção de que, esses elementos só deverão existir, caso sejam necessários para a estruturação do PDS.
Conforme o objetivo deste Guia, mostraremos apenas o fluxo para a construção de elementos de definição de ASs, que pode ser visto na Figura 4.29.
O fluxo de atividades visto na Figura 4.29 apresenta o fluxo para o uso da definição de ASs.
Após a seleção da definição de um ou mais artefatos (primeira Atividade), todo o resto deve ser também utilizado, ou seja, o uso dos contêineres (segunda Atividade) e tipos de informação (última Atividade) devem ser feitos em cascata.
Durante a utilização dos elementos internos dos ASs, pode- se também selecionar o tipo de uso que deve ser feito.
Esta característica permite que o uso de um artefato possa ser diferente de sua definição, desde que este seja um subconjunto.
Ou seja, pode- se em tempo de uso desistir de alguns Tipos de Informação ou mesmo Contêineres, dependendo do que se desejar.
Este tipo de utilização, embora seja possível neste momento é muito mais comum durante a fase de tailoring, adaptação e geração de famílias de processos.
A última atividade do Guia é reponsável por exportar os dados armazenados na biblioteca.
Como foi dito anteriormente, esses dados são armazenados num arquivo XMI preparado para troca posterior.
Porém, permitir o uso apenas de arquivos do tipo XMI não é suficiente para que exista troca de dados entre outras ferramentas.
Ou seja, deve ser possível de se utilizar a biblioteca, ou ao menos os dados que ela possui, a partir de outras ferramentas, principalmente ferramentas comuns ao uso na indústria.
Desta forma, a publicação permite troca de dados para diferentes ferramentas, mesmo que estas não utilizem arquivos do tipo XMI.
Para a quantidade de ferramentas capazes de utilizar os dados contidos na biblioteca, pode- se exportar- los em arquivos do tipo Html ou XHML, através da especificação padronizada por a W3C 6 e OOXML, padrão Microsoft para Office Open XML's vocabularies and document representation and packaging 7, entre outros.
Diante deste contexto, o Guia criado permite à publicação a partir de o momento em que se define qual o tipo de arquivo a ser exportado, partindo então para uma decisão sobre o que deve ser publicado.
Para isto, deve- se escolher entre dois níveis de publicação:
O primeiro nível (a) diz respeito a publicação do PDS como um todo;
Já o segundo nível (b) permite a publicação apenas de ASs, independente do PDS.
Ambos os níveis possuem uma tomada de decisão sobre o que exatamente deve ser publicado.
Conforme a Figura 4.30, as atividades referentes ao nível (a) permitem uma escolha entre Method Content, Process Structure ou toda a Spemxt Library.
Desta forma pode- se extrair todos os dados existentes.
O fluxo de atividades em (b) servem para a publicação exclusiva de ASs, ecolhendo- se entre sua definição, o seu uso, ou ambos.
Em nossa abordagem, assim como na UML, utilizamos os termos source e target para definir os elementos participantes de um relacionamento:
Source ­ has ­\&gt; target.
Regras Estruturais. As regras estruturais servem para garantir o valor semântico do domínio de autoria de artefatos, no tocante a utilização do metamodelo.
A regra estrutural fundamental é:
Regra E0:
Nenhum auto-relacionamento deve ser feito entre a mesma instância.
Evita- se então que um elemento seja &quot;pai «ou &quot;filho», diferenciando- se um target de um source.
Regra E1:
Um artefato deve possuir ao menos &quot;um tipo de informação «ou &quot;um container».
Ou seja, não devem existir artefatos vazios.
Regra E2:
Os relacionamentos entre artefatos só podem ser feitos através da metaclasse WorkProduct_ Relationship.
Regra E3:
Os relacionamentos entre contêineres só podem ser feitos através da metaclasse ContainerDefinition_ Relationship.
Regra E4:
Os relacionamentos entre tipos de informação só podem ser feitos através de seus relacionamentos internos, definidos em nível M2.
Regra E5:
Os relacionamentos entre artefatos e contêineres devem ser feitos através da metaclasse ArtifactContainer_ Relationship.
Regra E6:
Os relacionamentos entre artefatos e tipos de informação devem ser feitos através da metaclasse ContainerFragment_ Relationship.
Regra E7:
Os relacionamentos entre contêineres e tipos de informação devem ser feitos através da metaclasse ArtifactFragment_ Relationship.
Regras para Reuso.
Existem cinco níveis de reuso definidos na Seção 4.3.7: Content, extension, local contribution, local replacement e reference.
A regra fundamental para a utilização dos conceitos de reuso é:
Regra R0:
Nenhum dos níveis de reuso pode ser aplicado mais de uma vez entre os mesmos elementos.
Isto é expressado em OCL da seguinte forma:
I -- Quanto a utilização de apenas um nível numa mesma hierarquia as regras definidas são:
Regra R1:
O reuso do tipo content deve reutilizar tanto a estrutura quanto o conteúdo.
Desta forma, ao se aplicar esse tipo, o elemento source do relacionamento deverá adquirir toda a estrutura do elemento target, assim como todo o seu conteúdo.
Regra R2:
O reuso do tipo content não pode ser utilizado entre um elemento source Contêiner e um elemento target Artefato.
Regra R3:
O reuso do tipo content não pode ser utilizado entre um elemento source Tipo de Informação e um elemento target Artefato.
Regra R4:
O reuso do tipo content não pode ser utilizado entre um elemento source Tipo de Informação e um elemento target Contêiner.
Regra R5:
O reuso do tipo content deve reutilizar a estrutura.
De esse modo, ao se aplicar esse tipo de reuso, o elemento source do relacionamento deverá adquirir toda a estrutura do elemento target.
Regra R6:
O reuso do tipo extension deve reutilizar toda a estrutura interna do elemento que está sendo reutilizado.
Regra R7:
O reuso do tipo extension somente pode ser utilizado entre elementos de mesma metaclasse.
Regra R8:
O reuso do tipo local contribution deve reutilizar a estrutura interna do elemento a ser reutilizado.
Desta forma, um elemento source obterá a mesma estrutura hierárquica de seu target, aliada a estrutura que já possuia anteriormente.
Regra R9:
Em o reuso local contribution, todo elemento a ser reutilizado será sempre adicionado após o último elemento da mesma hierarqui no source.
Regra R10:
Em o reuso local contribution, todo elemento a ser reutilizado será sempre adicionado após o último elemento da mesma hierarqui no source.
Regra R11:
Em o reuso local contribution, caso haja conflito de reuso por motivos de existência do mesmo elemento em mesmo nível de hierarquia, este elemento não será afetado.
Regra R12:
Em o reuso local replacement, os elementos internos do elemento target deverão substituir os elementos internos de um source.
Regra R13:
Em o reuso reference, um elemento source apenas referência um elemento target, entretanto não é criada estrutura física. --
Quanto a utilização de mais de um nível numa mesma hierarquia as regras definidas são (estension pode ser sobreescrito.
Vide reconstrucão da regra R5):
Regra R14:
O reuso do tipo extension, quando aplicado, deve ser feito de forma que englobe o elemento de maior nível hierárquico (mais próximo de a raiz possível).
Pois, não faz sentido aplicar- lo mais de uma vez numa mesma hierarquia.
Regra R15:
Quanto a utilização de mais de um o reuso do tipo extension não deve aplicado de forma fique em nível hierárquico inferior a qualquer outro tipo de reuso.
Regra R16:
O reuso do tipo extension pode ser sobrescrito por todos os tipos de reuso, com exceção de reference.
Em o que se constitui a nossa abordagem para a Autoria de Artefatos de Software, foram definidas algumas características a serem atendidas.
Tais características foram elaboradas para possibilitar uma melhoria em relação as propostas já existentes e analisadas no Capítulo 3.
De essa forma, visamos construir uma série de conceitos para atingir o nosso objetivo de estrutura artefatos, no tocante a conseguir introduzir tais características de maneira tal que não comprometesse esse trabalho.
Haja visto, foram abordados os seguintes conceitos:
Paradigma de construção -- em nossa abordagem os artefatos são vistos como uma união de fragmentos de informação definidos através de estrutura bem definida.
Este paradigma se opõe ao paradigma atual, onde artefatos são elementos monolíticos, auto-contidos e fechados.
A escolha por um paradigma praticamente oposto ao utilizado na maioria dos PDSs atuais, foi feita com base na nossa hipótese de que o controle das informações de um artefato estruturado pode ser melhorado, em relação a um artefato monolítico, no tocante a estruturação, categorização, organização, controle de versão e reuso;
Guia de construção -- foram definidos diagramas com fluxos de atividades mostrando quais atividades, etapas ou passos são necessárias para se realizar a autoria de artefatos.
Embora nenhuma outra abordagem analisada apresente algo nesse sentido, acreditamos (hipótese H2) que a utilização de um Guia permite construções mais bem definidas, pois o guia representa um processo a ser seguido, diferentemente de produção ad hoc;
Escopo da abordagem -- a abordagem permite a construção de quaisquer tipos de artefatos, desde que eles estejam no conjunto dos artefatos analisados com base nos processos RUP e SCRUM.
A modelagem de outros tipos de artefatos, vistos outros diferentes processos, não é garantida;
Separação de Conteúdo -- assim como no SPEM v2, nossa abordagem possui uma clara divisão entre a estrutura do processo (Process Structure) e o seu conteúdo (Method Content).
Ou seja, a hierarquia de atividades, ou disciplinas, definidas na maioria das vezes por estruturas do tipo Work Breakdown Structures (WBS) está separada da definição dos papéis, atividades e artefatos, entre outros elementos de PDS.
Com base nesse conceito definido no SPEM v2, acreditamos na hipótese (H3) de que separando um PDS nesses dois níveis é possível se obter adaptabilidade de processos.
Desta forma, pode- se utilizála como princípio para estruturar os conceitos de reuso de estrutura e conteúdo, tanto de artefato quanto de suas informações.
Em relação a representação da nossa abordagem, ao optarmos por desenvolver uma linguagem própria, verificamos que seria necessário atender a uma série de requisitos, principalmente com relação a UML.
Por isso, da mesma forma como foi definido na UML, utilizamos a técnica de especificação da sintaxe da linguagem, para só depois definir sua semântica.
Temos por base as convenções e tipologia definidas em.
Nosso metamodelo compreende os seguintes níveis de formalismo:
Sintaxe: Define quais os contrutores existentes na linguagem, mostrando como podem ser construídos a partir de outros construtores.
Foram utilizados dois níveis de sintaxe:
Sintaxe Abstrata, que se constitui numa representação gráfica, funcionando como uma linguagem de notação independente.
Sintaxe Concreta, que é definda através de um mapeamento da notação definida por a sintaxe abstrata, tornando tal sintaxe computável e formalizada.
Como pode ser visto no Apêndice, nossa abordagem possui um metamodelo completo que utiliza a mesma notação da UML.
Além disso, na Seção 5.1 é apresentada a linguagem concreta, feita em XMI e derivada da utilização do MOF.
Semântica: define os significado dos construtores utilizados na linguagem, bem como o que representam.
Em nossa abordagem foram definidos três níveis de semântica:.
Semântica Estática:
apresenta valores semânticos da linguagem definido como as instâncias dos construtores devem ser conectadas entre elas, apresentado as formas possíveis de utilização para se conseguir algum sentido;
Semântica Dinâmica: descreve o sentido de cada construtor da linguagem;
Regras de boa formação:
este último nível de formalismo é acrecestado a linguagem pois traz com si regras que definem a boa construção dos ASs.
Em o Apêndice é apresentado o valor semântico de cada construtor do metamodelo nos três níveis existentes, quando aplicável.
O UML Profile definido nesse trabalho e que está apresentado no Apêndice A. 8 possui os níveis de formalismo definido em duas fases.
A primeira fase foi definida por a própria UML, uma vez que o SPEMXt UML Profile se utiliza de seu metamodelo.
A segunda fase tem por base a descrição semântica dos estereótipos em comparação ao metamodelo do Apêndice, uma vez que eles se constituem numa mais simples representação do metamodelo.
Por fim, uma vez que o metamodelo foi definido utilizando os princípios de empacotamento definidos na UML, houve a necessidade de especificar os níveis de conformidade a serem utilizados, definindo os pontos de conformidade a serem implementados por Tool Vendors.
Em esse sentido foram definidos dois níveis de conformidade:
Extended Method Content, que define a utilização dos pacotes responsáveis por a criação apenas de elementos de definição de PDS.
Esse nível se constitui num ponto de conformidade para implementadores que necessitem apenas definir bibliotecas de conteúdo;
All, que define a utilização de todos os pacotes do metamodelo.
Este nível estabelece a implementação de todo o metamodelo, focando na construção de PDSs completos e reutilizáveis.
Testes e Verificação.
Em este capítulo apresentamos as formas de verificação desta abordagem.
As análises foram feitas com base em testes analíticos, comparando este trabalho com outras abordagens existentes.
A verificação aqui apresentada aplica tudo o que foi discutido nos capítulos anteriores, demonstrando na prática exemplos de uso da abordagem proposta.
Contudo, implementamos uma ferramenta de suporte para demonstração da nossa solução.
O restante deste capítulo se apresenta da seguinte forma:
Em a Seção 5.1 é apresentado o protótipo desenvolvido para a aplicação da proposta, tecnologias utilizadas, arquitetura, funcionalidades e implementação;
Em a Seção 5.2 apresentam- se os cenários de testes, utilizando comparações de forma analítica;
E, por fim, a Seção 5.3 apresenta as nossas conclusões sobre a abordagem após a execução dos testes.
Com o objetivo de automatizar e colocar em prática a abordagem proposta, foi desenvolvida uma ferramenta de autoria de artefatos de software chamada Software Artifact Specification Tool (SwAT).
Juntamente com sua utilização foi feita uma avaliação deste trabalho.
Tecnologias Utilizadas. Durante o desenvolvimento do protótipo foram utilizadas diferentes tecnologias e ferramentas.
Em esta Seção serão apresentadas as principais tecnologias utilizadas.
Eclipse Modeling Framework O Eclipse Modeling Framework (EMF) (Steinberg 2008) trata- se de um arcabouço para desenvolvimento de modelos baseados no MOF (OMG, 2008 a), com suporte a geração de código através de linguagem Java.
Além disso, o EMF provê persistência dos dados utilizando XMI, linguagem padrão para definição de troca de dados da UML.
Quanto a geração do código, o EMF cria a base do modelo, constituída de Java Interfaces e sua implementação, utilizando Java Classes.
Já a geração da Interface Gráfica é feita baseada no padrão Adapter (Gamma 1993), possibilitando visualização e edição do modelo através de um editor básico.
Os modelos definidos por o EMF são baseados no ECore.
O ECore pode ser considerado uma implementação simples do MOF, sendo utilizado para definir a sintaxe e a semântica dos modelos manipulados por o EMF.
Isto implica na capacidade de construir elementos como classes, interfaces e associações.
Basicamente, os modelos criados a partir de o EMF são formados por EClasses (elementos equivalentes às classes definidas no MOF) as quais podem ter EAttributes (elementos equivalentes as propriedades definidas no MOF) e, por fim, é possível estabelecer relacionamento entre as EClasses (esses relacionamentos são equivalentes à associações definidas no MOF).
Visão Geral.
Embora existam esforços referentes a definição de PDSs, pouco se fala em Autoria de Artefatos de Software.
Geralmente, durante um Projeto e de acordo com o PDS utilizado, diferentes ferramentas ou técnicas de captura de conhecimento serão realizadas, com objetivo de se conseguir os ASs necessários para obter um Produto de Software.
Entretanto, toda a questão sobre a definição do Artefato é praticamente ignorada, dado o fato que tais ferramentas ou técnicas possuem maior foco em preenchimento da informação.
Além disso, a existência de diversos tipos de ASs diferentes, causa um aumento da dificuldade de seu preenchimento (responsável) e entendimento (leitor), ainda mais quando tais artefatos são feitos de forma distribuída.
Sendo assim, a utilização de uma ferramenta que automatize parcial ou completa a definição e uso dos ASs poderá trazer significantes melhorias.
Diante desse contexto, o protótipo de ferramenta SwAT foi desenvolvido com o objetivo de permitir a definição e uso de ASs, dentro de o domínio de PDSs.
Escopo e limites da ferramenta protótipo.
Sob o ponto de vista do Engenheiro de Conhecimento, é necessário que exista uma interação que permita a definição dos ASs, para conduzir- lo a um correta configuração do Method Content.
Para o Engenheiro do Processo, deve ser possível utilizar a biblioteca construída a partir de o Engenheiro de Conhecimento, para montar o Process Structure.
Tendo isso em mente, foi elaborada uma ferramenta que auxilia a Autoria de Artefatos de Software.
De um modo geral, a ferramenta permite:
Permite a Autoria de Artefatos conforme definido no Capítulo 4, utilizando os princípios de separação de conteúdo (Method Content) e estrutura (Process Structure);
Verificar problemas que surgem durante a autoria, ou seja, problemas de integridade, de campos entre outros;
Importar, carregar e salvar os modelos construídos, permitindo a troca de dados através de outras ferramentas que venham a implementar esta abordagem utilizando os mesmos princípios de extensão da UML e do SPEM v2.
A execução (enactment) de PDSs não faz parte do escopo dessa abordagem.
De essa forma, não é necessária sua implementação nessa ferramenta.
Entretanto, é possível preencher os ASs e visualizar- los com base nas informações em que se constituem.
Arquitetura A arquitetura da SwAT é dividida em camadas funcionais de acordo com a Figura 5.1.
Em essa camada estão as funcionalidades básicas para a criação de um plug-in baseado no Projeto Eclipse1.
Eclipse é uma comunidade para produtos de código-livre, de os quais seus projetos possuem foco em construção de uma plataforma extensível e aberta.
De essa forma, o protótipo utiliza- se de plug-ins desenvolvidos para o Eclipse, reutilizando o seu editor e toda a infra-estrutura de seu WorkBench, assim como o JFaces e o SWT para construção de aplicações Rich Client Platform (RCP).
Infraestrutura: EMF Assim como o Eclipse, o Eclipse Modeling Framework também provê funcionalidades de infraestrutura reutilizáveis e por se constituir basicamente do ECore, fornece diversas funcionalidades de modelagem, tais como:
Persistência em XMI ou Objeto Relacional, validação de integridade de modelo e gerência dos dados do modelo com utilização de transação.
Modelo A camada de modelo possui toda a implementação do metamodelo proposto no Capítulo 4.
Toda a implementação foi feita com a utilização de linguagem Java, dessa forma, nesta camada também estão os contratos e restrições, feitos a partir de Java Interfaces.
Interface Gráfica. A interação entre a ferramenta e o seu usuário é realizada através desta camada.
Toda a interface gráfica utiliza SWT e baseia- se no conceito de Views, Perspectives e Wizards, assim como os encontrados na plataforma Eclipse.
Isto ocorre por o fato da ferramenta SwAT funcionar como um plugin para o Eclipse, estendendo suas funcionalidades.
Funcionalidades. Em esta sessão estão dispostas as funcionalidades básicas da ferramenta de autoria SwAT.
Para especificar- las, foi tomado como partida à visão do modelador.
As funcionalidades aqui apresentadas foram modeladas com a utilização de UML em dois diagramas bastante comuns:
Diagrama de Casos de Uso e Diagrama de Atividades, somente para as principais funcionalidades.
Em esse sentido, utilizamos a ferramenta de modelagem Rational Software Modeler.
As funcionalidades principais da SwAT estão definidas nos pacotes:
Artifact Authoring -- as funcionalidades existentes nesse pacote possuem relação com a autoria de ASs, permitindo a criação dos construtores definidos na extensão do SPEM v2.
Process Authoring -- as funcionalidades existentes nesse pacote possuem relação com a autoria de PDSs, permitindo a criação dos construtores de processos, já existentes no SPEM v2 e redefinidos na extensão proposta neste trabalho.
Authoring Configuration -- as funcionalidades existentes nesse pacote configuram o projeto de autoria, permitindo a criação de pacotes de bibliotecas, separando o conteúdo do processo em si.
Durante o projeto da ferramenta SwAT, mais especificamente durante sua fase de análise e elaboração, foi tomada a decisão de modelar cada funcionalidade como um caso de uso, tomando os devidos cuidados em relação as dependências e relacionamentos existentes.
Para facilitar a visualização, foram modeladas quatro perspectivas, agrupando os casos de uso conforme similaridade e que serão apresentadas com mais detalhes a seguir.
Perspectiva de Configuração Em essa perspectiva estão os casos de uso responsáveis por as funcionalidades referentes a configuração básica do projeto de autoria.
Além disso, nessa mesma perspectiva são encontrados dois atores referentes aos papéis Administrator e Authoring Project Configurer, que são responsáveis por os casos de uso desta perspectiva, Figura 5.2.
Como pôde ser percebido através dos casos de uso anteriores, as funcionalidades de persistência de dados foram agrupadas.
Para maior facilidade e reuso de modelo, os casos de uso foram modelados com a utilização de UML Building Blocks.
Essa técnica de modelagem permite o aproveitamento de blocos de construção que podem ser utilizados em diversos pontos do mesmo projeto.
O Building Block modelado para prover tal facilidade chama- se CRUD (sigla para as funcionalidades Create, Retrieve, Update e Delete) e pode ser visto na Figura 5.6.
Entretanto, é importante entender que embora as quatro funcionalidades de CRUD estejam agrupadas através de UML Include Relationship, marcadas através do estereótipo include, não existe a obrigatoriedade de implementação de todas estas funcionalidades.
Embora o Building Block possa ser utilizado por completo, as vezes não existe tal necessidade, permitindo apenas um uso parcial.
Mesmo assim, todas às vezes que utilizaremos o CRUD, este será por completo.
Perspectiva Method Content. Em esta perspectiva estão os casos de uso responsáveis por as funcionalidades referentes à criação de uma biblioteca de conteúdo.
O responsáveis por os casos de uso desta perspectiva é o papel Engenheiro de Conhecimento, como visto na Figura 5.7.
CRUD -- Artifact Definition.
Elements assim como o caso de uso anterior, neste estão funcionalidades para elementos pertencentes ao Method Content, exceto que, apenas elementos relacionados a extensão proposta.
Desta forma, apenas os elementos artefato, contêiner e tipos de informações podem ser adicionados, removidos, alterados ou recuperados.
Este caso de uso põe em prática um dos objetivos deste trabalho, pois permite a construção de artefatos de forma que sua organização interna esteja bem estruturada.
Por ser bastante complexo, apresentaremos quatro diagramas de atividades, explicando- os em seguida.
A Figura 5.9 apresenta o diagrama de atividades com o fluxo principal.
Como pode ser visto as atividades necessárias para que seja possível obter uma boa definição do artefato são:
Criar os tipos das informações necessárias, agrupar- las em contêineres, quando necessário e finalmente a criação dos artefatos.
Já na Figura 5.10 está o diagrama com o fluxo esperado para a atividade, que é utilizada para a criação dos tipos de informações.
Tal fluxo é bastante simples, bastando determinar o tipo da informação e, caso necessário, inserir um pequeno conteúdo descritivo para uma melhor identificação posterior.
Essa descrição é totalmente opcional, porém com o seu uso é possível definir vários níveis de descrição (i.
e descrição principal, breve descrição, nome de apresentação, propósito) assim como vários níveis de seções para criar notas ou comentários em categorias.
Esse Diagrama de Atividades é um pouco mais complexo, pois apresenta duas iterações diferentes.
Uma de elas é a iteração para o agrupamento de tipos de informação que é feita em três atividades:
Seleciona- se um tipo de informação desejado;
Define- se o índice, como se trata de um relacionamento ordenado, caso não seja definido, ficará na ordem em que o tipo de informação foi adicionado;
E, por fim, agrupa- se o tipo de informação confirmando a escolha.
A outra iteração é responsável por o aninhamento de contêineres, permitindo relacionamentos do tipo parent/ child.
Além disso, como se trata de um relacionamento ordenado, pode- se alterar a ordem de construção determinando o &quot;nível de aninhamento».
Por último, o fluxo para a criação da definição de ASs está representado através do diagrama da Figura 5.12.
Como pode ser visto, para criar uma boa definição de Artefatos de Software deve- se primeiro definir Quais contêineres Ou tipos de informações serão utilizados.
Isso ocorre por que o fluxo permite a adição de ambos paralelamente.
Em a verdade, o que ocorre é que um As pode possuir ambos, entretanto, é requisito, visto na Regra E1, que exista ao menos um de eles.
Ou seja, não deve ser possível que exista um As vazio.
Em esse fluxo pode ser visto também que durante a adição dos contêineres deve- se selecionar o tipo de relacionamento desejado e qual o índice.
Perspectiva de Process Structure 5.13 são apresentados outros três casos de uso incluídos neste próprio.
Estes casos de uso são:
CRUD -- Process Use Elements, CRUD -- Artifact Use Elements e Use Method Content Elements, vistos a seguir.
CRUD -- Process Use Elements -- neste caso de uso estão as funcionalidades de criação, remoção, atualização e recuperação dos elementos pertencentes ao Process Structure.
Existem inúmeros elementos que podem ser criados para formar a estrutura de um PDS, assim como papéis, atividades, tarefas, guias, ferramentas, entre outras.
CRUD -- Artifact Use Elements -- assim como o caso de uso anterior, neste também estão funcionalidades para elementos pertencentes ao Process Structure, exceto que, apenas elementos relacionados a extensão proposta.
De essa forma, apenas os elementos artefato, contêiner e tipo de informação podem ser criados, removidos, alterados ou recuperados.
Este caso de uso põe em prática um dos objetivos deste trabalho, pois permite a criação do uso de ASs de forma estruturada.
Use Method Content Elements -- por fim é possível alinhar a estrutura do processo conforme os elementos existentes no Method Content.
Os elementos de uso, criados para a estrutura do processo, devem utilizar dos elementos de conteúdo.
Este caso de uso põe em prática outro objetivo deste trabalho, pois permite a utilização da definição dos ASs.
Create Process Family and Adaptabilities -- este caso de uso adiciona uma funcionalidade que está fora de o escopo deste trabalho, porém, de bastante ajuda para àqueles que desejarem criar famílias de processos.
De essa forma, como o metamodelo proposto no Capítulo 4 estende as propriedades do SPEM v2, permitir a criação de famílias de processos e dar suporte à adaptabilidade de processos de software foi uma escolha feita para manter a compatibilidade com o nível de complacência escolhido, ou seja o SPEM v2 Complete.
Além disso, este caso de uso estende as funcionalidades existentes no caso de uso CRUD -- Process Structure.
Perspectiva de Artefato de Software. Os casos de uso desta perspectiva são:
Fill Artifact -- a partir de o momento em que a estrutura do Processo está pronta é possível criar instâncias dos elementos existentes.
Desta forma, com este caso de uso é possível preencher os artefatos de um PDS já previamente criado.
Conforme foi visto anteriormente, os artefatos deverão ser preenchidos de acordo com os tipos de informação contidos, mantendo a organização previamente definida na fase de autoria.
Use Read-Only Artifacts -- da mesma forma que é possível preencher as instâncias dos artefatos, também pode- se utilizar- las somente para leitura.
Sendo assim, o conteúdo das informações existentes nos As previamente preenchidos podem ser visualizadas sem a necessidade exportação ou qualquer tipo de publicação.
Export Artifact -- embora as instâncias de As possam ser lidas dentro de a própria ferramenta, isto é bastante limitado, pois a ferramenta não possui um editor avançado.
Para corrigir esse problema, a funcionalidade de exportação de dados foi modelada, possibilitando a troca de dados através de outros tipos de arquivos.
Interface Um ponto importante para à autoria de ASs é a iteração entre a ferramenta e os atores usuários.
Uma das formas para aumentar a compreensão e facilitar a interação entre os usuários e a ferramenta é através da utilização de uma interface amigável.
Tais interfaces geralmente são ambientes gráficos do inglês Graphical User Interfaces (GUI).
Deve- se então selecionar quais os tipos de informação e como agrupar- las de forma a conseguir estruturar o artefato conforme o nossa proposta, mapeando os conceitos do template, para conceitos existentes no nível M2.
Por fim, deve- se construir o modelo de nível M1 utilizando- se dos elementos existentes no nível M2, previamente mapeados.
O objetivo geral dos testes é mostrar que cada um desses artefatos pode ser definido através da camada M2, criando elementos na camada M1.
Além disso, será apresentada uma amostra da camada M0, com o intuito de demonstrar que é possível se obter uma instância real de artefatos ao final do processo de autoria.
Todavia, para que isto seja possível deve- se levar em conta a ordem de construção ser feita.
Tal ordem, previamente definida na Seção 4.6, será seguida, permitindo também que o Guia para Autoria de Artefatos de Software seja testado.
Em esse primeiro cenário será utilizado o protótipo da ferramenta SwAT para instanciar a camada M2, criando assim a camada M1.
Este protótipo implementa a camada M2, dando suporte a construção da camada M1.
Além disso, a ferramenta de suporte também implementa o Guia para Autoria de Artefatos de Software, automatizando- o.
Criação de Novo Projeto de Autoria De esta forma, vamos então criar um novo PDS, inciando uma autoria.
Esse é o primeiro passo a ser executado, segundo o Guia.
Como este passo já está implementado, basta utilizar a ferramenta para criar um novo projeto de autoria do Processo de nome SwAT.
Test.. Os próximos passos a serem seguidos são:
Criar uma nova biblioteca;
Criar um Method Content para a biblioteca e criar um Process Structure.
O responsável por a publicação não está implementado nessa versão do protótipo.
Criação de Biblioteca Seguindo então para o próximo passo, devemos criar uma nova biblioteca, Figura 5.28.
Relacionamentos modelados a partir na ferramenta SwAT type $= reference, indicando que o tipo do relacionamento possui reuso estrutural por referência;
Artifact $= UseCaseSpecification;
Containers $= Introduction, FlowOfEvents, Preconditions, Postconditions, SpecialRequirements e ExtensionPoints;
Introducao_ referencias -- relacionamento do tipo &quot;contêiner x contêiner «que instancia a metaclasse ContainerDefinition_ Relationship e relaciona as seções Introdução e Referências do artefato Especificação de Caso de Uso.
Desta forma Introdução será &quot;Pai «de Referências, que será subseção de Introdução;
Introducao_ definições -- relacionamento do tipo &quot;contêiner x contêiner «que instancia a metaclasse ContainerDefinition_ Relationship e relaciona as seções Introducão e Definições, Acrônimos e Abreviações, ambas fazem parte do artefato Especificação de Caso de Uso;
FluxoDeEventos_ fluxosAlternativos-relacionamento do tipo &quot;contêiner x contêiner «que instancia a metaclasse ContainerDefinition_ Relationship e relaciona as seções Fluxo de Eventos e Fluxos Alternativos, ambas fazem parte do artefato Especificação de Caso de Uso;
FluxoDeEventos_ fluxos-relacionamento do tipo &quot;contêiner x tipo de informação «que instancia a metaclasse ContainerFragment_ Relationship e relaciona a seção Fluxo de Eventos com o tipo de informação Fluxos que é uma instância de List e representa o fluxo básico.
Fluxos é uma lista que possui o tipo de informação Fluxo, como conteúdo interno.
Fluxo é uma instância da metaclasse Group;
FluxosAlternativos_ fluxos-relacionamento do tipo &quot;contêiner x tipo de informação «que instancia a metaclasse ContainerFragment_ Relationship e relaciona a seção Fluxos Alternativos com o tipo de informação Fluxos;
Precondicoes_ condicoes- relacionamento do tipo &quot;contêiner x tipo de informação «que instancia a metaclasse ContainerFragment_ Relationship e relaciona a seção Pré-condições com as condições a serem satisfeitas antes da execução do Caso de Uso.
Como visto anteriormente, condições é uma lista de condição.
Esses tipos de informação instanciam as metaclasses List e Group, respectivamente;
Poscondicoes_ condicoes- relacionamento do tipo &quot;contêiner x tipo de informação «que instancia a metaclasse ContainerFragment_ Relationship e relaciona a seção Pós-condições com as condições a serem satisfeitas após a execução do Caso de Uso;
RequisitosEspeciais_ requisitos -- relacionamento do tipo &quot;contêiner x tipo de informação «que instancia a metaclasse ContainerFragment_ Relationship e relaciona a seção Requisitos Especiais com os requisitos necessários para a execução do Caso de Uso.
Em esse sentido, como visto anteriormente, requisitos é uma lista de requisito e instanciam as metaclasses List e Group, respectivamente;
PontosDeExtensao_ pontos -- relacionamento do tipo &quot;contêiner x tipo de informação «que instancia a metaclasse ContainerFragment_ Relationship e relaciona a seção Pontos de Extensão com os pontos de extensão existentes no Caso de Uso.
Em esse sentido, como visto anteriormente, pontos de extensão é uma lista de ponto de extensão e instanciam as metaclasses List e Group, respectivamente.
Esse segundo pacote contém a modelagem dos relacionamentos utilizados por os artefatos Glossário de Negócios e Glossário, que são:
GlossarioDeNegocios_ definições -- relacionamento do tipo &quot;artefato x tipo de informação «que instancia a metaclasse ArtifactFragment_ Relationship e relaciona o artefato Glossário de Negócios com os tipos de informação Abreviações, Acrônimos, Definições e Termos.
Todos estes tipos de informação são instâncias da metaclasse List;
Glossario_ definições -- relacionamento do tipo &quot;artefato x tipo de informação «que instancia a metaclasse ArtifactFragment_ Relationship e relaciona o artefato Glossário com os tipos de informação Abreviações, Acrônimos, Definições e Termos;
SecaoDefinicoes_ definições -- relacionamento do tipo &quot;contêiner x tipo de informação «que instancia a metaclasse ContainerFragment_ Relationship e relaciona a seção Abreviações, Acrônimos e Definições com os seus respectivos tipos de informação.
3. Esse último pacote contém a modelagem dos relacionamentos utilizados por os artefatos Modelo de Análise e Modelo de Design, que são:
ModeloDeAnalise_ diagramas -- relacionamento do tipo &quot;artefato x tipo de informação «que instancia a metaclasse ArtifactFragment_ Relationship e relaciona o artefato Modelo de Análise com seus diagramas de Análise de Caso de Uso e de Classes;
ModeloDeDesign_ diagramas -- relacionamento do tipo &quot;artefato x tipo de informação «que instancia a metaclasse ArtifactFragment_ Relationship e relaciona o artefato Modelo de Design com seus diagramas de Design de Caso de Uso e de Classes.
Enfim concluímos todos os passo de criação do MethodContent utilizando a SwAT.
Como foi apresentado, tanto os tipos de informação quanto os relacionamentos foram modelados em diferentes pacotes para fornecer uma melhor visualização.
Entretanto, não é aconselhável a divisão de instâncias da mesma metaclasse em diferentes pacotes.
Embora isso não faça diferença no modelo, pode- se cometer erros ao não visualizar as informações por estas estarem em outro pacote.
Isso também pode ocasionar uma pequena confusão no conceito de tipos de informação e reuso, pois estes tipos de informação e contêineres não pertencem necessariamente a um artefato específico, pelo contrário, são elementos a serem compartilhados.
Criação do Process Structure Partindo então para o último passo, usaremos tudo que foi definido no Method Content para criar o Process Structure.
Em a Figura 5.31 pode ser visto a utilização dos artefatos definidos no Method Content.
Em este exemplo o uso de elementos de definição não é demonstrado de forma efetiva.
Entretanto, isto permite que na camada M1, que contem modelos para PDS específicos, sejam criados processos independentes das modificações feitas no Method Content.
Como nosso foco é testar a autoria de artefatos, não faz sentido modelar todo um PDS para provar que a divisão entre definição e uso adiciona ganhos na modelagem, uma vez que isso já foi demonstrado em.
A Figura 5.33 apresenta a modelagem do Process Structure através da ferramenta SwAT.
Como pode ser visto, a estrutura do processo foi criada a partir de as classes existentes no Method Content.
Sendo assim, cada classe do Process Structure necessariamente possui uma relação com alguma classe de mesmo tipo do Method Content.
Este tipo de ligação é chamado de Method Content Trace.
A partir de a construção do Process Structure utilizando a ferramenta SwAT, conseguimos colocar em prática essa parte da abordagem.
Versionamento e Reuso Tendo em vista os testes feitos sobre a estruturação de artefatos, daremos continuidade a este cenário tratando sobre Versionamento e Reuso de informação, optando por utilizar uma visão com base nas camadas apresentadas na Figura 5.26.
A o se tratar de grandes quantidades de informações estruturadas, duas grandes questões a serem levadas em consideração são o controle de versão e reutilização.
De acordo com o cenário apresentado, essas questões transformam- se em necessidades, assim como em ambientes em que tais informações são manipuladas por várias pessoas e durante um longo período de tempo.
Conforme visto na Seção 4.3.6, por meio versionamento é possível inspecionar as mudanças que ocorreram sobre alguma informação, guardando seus estados.
Desta forma, quando necessário, consegue- se reverter para uma mudança num estado anterior.
Entretanto, existem vários fatores que descaracterizam esse tipo de característica, portanto nem sempre é possível manusear todos os vários estados que pode possuir dada informação.
Atualmente, o controle de versões sobre artefatos é feito através de software do tipo SVN (Subversion) 2, dado o fato que apenas objetos reais, de nível M0 são versionados.
Além disso Softwares como esse tratam artefatos conforme blocos monolíticos de informação, impossibilitando discussões sobre os detalhes das modificações e possíveis inferências, como qual informação sofreu maiores alterações, por exemplo.
Embora sistemas como o SVN sejam bem adaptados quanto a utilização de artefatos apenas texto, assim como código-fonte ou arquivos do tipo txt, eles falham quando se trata de documentos mais complexos, assim como documentos do tipo Office, como documentos do Microsoft WordTM e Microsoft ExcelTM.
Reuso A reutilização permite que as informações sejam organizar com prudência, já que evita duplicações de partes de conteúdo ou estrutura comum.
Hoje em dia a reutilização de artefatos de software é feita através do uso de templates, que possuem espaços em branco a serem preenchidos.
Embora essa solução permita a reutilização da estrutura de artefatos, ela falha quanto a o reuso de conteúdo e, o que é ainda pior, reforça o uso de procedimentos do tipo´ cópia-e-cola, o que pode facilmente propagar as informações e gerar diversas inconsistências.
Em nossa abordagem, o reuso de informação é baseado em pontos de variabilidades.
Tais pontos consistem em firmar relacionamentos entre elementos de mesmo tipo, determinando características comuns ou particularidades.
Embora este tipo de nomenclatura seja mais usual em trabalhos sobre adaptação e tailoring de PDSs, também é possível determinar o reuso de infor2 subversion.
Tigris. Org mação utilizando esse mesmo princípio.
Em esse sentido, o próprio SPEM v2 especifica pontos próprios de variabilidade e, além disso, indica o curso a ser seguido para construir famílias de PDSs.
Entretanto, como o foco desta abordagem é a autoria de ASs, esta característica do SPEM v2 foi extendida, conforme pode ser visto na Seção 4.3.7.
De essa forma, adicionamos maior semântica e novas regras para a utilização do reuso, possibilitando, além de o reuso de estrutura, o reuso de conteúdo.
Integração De esta forma, essa seção tem como objetivo mostrar como nossa abordagem funciona em relação a controle de versão e reuso.
Tais características já estão integradas, provendo a capacidade de acompanhar as mudanças na estrutura e conteúdo de artefatos.
Para maior facilidade no entendimento, uma visão geral é apresentada Figura 5.34.
Essa figura apresenta uma ilustração dessas capacidades, mostrando diversas revisões nas camadas M2, M1 e M0.
Ela está organizada como uma tabela em a qual as colunas indicam as revisões e as linhas indicam qual a camada e os papéis que são responsáveis por as alterações.
Além disso em cada célula da tabela existe um conjunto de classes e observações que indicam o que foi modificado.
É importante entender que na Figura 5.34, as barras cinzas no alto de cada linha diz respeito à versão do metamodelo, processo ou projeto.
A Figura 5.34 também apresenta três atores, na coluna mais a esquerda, indicando qual o papel responsável por as modificações em cada camada:
O Tool Vendor é responsável por manter o metamodelo para autoria de artefatos, ou seja, a camada M2;
o Engenheiro de Processo é responsável por criar os modelos para definição e uso de artefatos utilizando a camada M2, ou seja, é responsável por a camada M1;
por fim, o Engenheiro de Software é responsável por criar o projeto na camada M0 que utilizará um processo definido na camada M1.
O mecanismo de versionamento pode ser visto a partir de a Revision:
0 (segunda coluna), quando foi feito o primeiro commit.
Em esta coluna uma representação da metaclasse ArtifactDefinition da camada M2, que foi utilizada para moldar os artefatos Especificação de Caso de Uso e Glossário, da camada M1.
Já na terceira coluna está a Revisão -- 1.
Em essa revisão houve uma pequena modificação em ArtififactDefinition.
Agora, ela possui o atributo mandatory que indica quando um artefato é, ou não, obrigatório no processo de desenvolvimento, indicando se ele deve ser criado e preenchido.
Ou seja, foi feita uma modificação apenas no nível M2, que possivelmente implicaria numa nova versão da ferramenta de modelagem de artefatos, que deve ser feita por o Tool Vendor.
Por esta razão, os artefatos modelados a partir de o metamodelo da Revisão -- 1 indicam se são obrigatórios.
Em o exemplo apresentado na Figura 5.34, o artefato Especificação de Caso de Uso é obrigatório, enquanto que Glossário não o é.
Outro fato que pode ser visto na Revisão -- 1 é que conforme houve modificação em M2, os modelos M1 e M0 também foram afetados.
Em esse sentido, ao alterar o metamodelo de nível M2, criando a nova Revisão -- 1, todas as novas instâncias de nível M1 se utilizarão dessas alterações.
De a mesma forma, um novo projeto de nível M0 que instanciar um processo modelado em M1 a partir de a nova revisão em M2.
Entretanto, em nossa abordagem, os projetos anteriores a essa revisão, assim como os processos modelados, não partilharão dessas alterações.
A Revisão -- 2, que se encontra na quarta coluna, não apresenta modificações no nível M2, mas sim em M1.
Embora a metaclasse Text esteja presente em ambas as revisões do metamodelo, ela, assim como o restante do metamodelo, foram suprimidos para evitar confusão.
Sendo assim, conforme está apresentado na Figura 5.34, a camada M1 está organizada de maneira a demonstrar o reuso.
Como se sabe, os elementos criados na camada M1 são de responsabilidade do Engenheiro de Processos.
Sendo assim, no Processo v 3.0 foi feito reuso através da metaclasse Terms, que é utilizada por ambos os artefatos.
A decisão de compartilhar essa informação foi feita para tornar os termos consistentes e sincronizados.
Em o exemplo da Figura 5.34, o Projeto C utiliza instâncias da Especificação de Casos de Uso e do Glossário para compartilhar os termos CRUD, Login e Logoff.
É importante perceber que o mecanismo de versionamento utilizado na nossa abordagem é baseado na integração com a camada M3, como visto na Figura 5.26.
Como resultado, todos os elementos do Metamodelo para a autoria de ASs estão relacionadas com a metaclasse VersionedExtent, do MOF Versioning.
Além disso, o MOF Versioning provê metaclasses para:
Controle e gerência de versionamento através de operações de:
Check-in, check-out, revert, delete, commit e look-up versions;
Identificação de versão, utilizando ids e rótulos;
Marcação de versões através de datas e timestamps;
Histórico de versões;
Utilização de sessões em revisões inseridas numa workspaces;
E, por fima criação de versões de baselines conforme suas configurações.
Criação de instâncias reais de Nível M0 Por fim, embora o enactment não faça parte do objetivo deste trabalho, para que o cenário de uso esteja completo apresentamos também como se dá a camada M0, entretanto, isto não é suportado por a ferramenta.
Como definido anteriormente, esta camada contem as instâncias reais dos artefatos definidos no modelo M1.
Desta forma, esta camada estará em conformidade com a camada M1.
Uma amostra das instâncias feitas nessa camada pode ser vista na Figura 5.35.
Em este caso a Figura 5.35 ilustra uma instância real do artefato Especificação de Caso de Uso, utilizando anteriormente.
Como pode ser visto, as caixas que estão dentro de os quadrados de contornos pontilhados representam os conteúdos deste artefato.
Sendo assim, essas caixas são instâncias das classes correspondentes, que estão dentro de as caixas em tom cinza e que foram definidas na Camada de Processos.
A o observar a Figura 5.35 é possível visualizar que o artefato é uma instância da classe UseCaseSpecification, podendo então ser preenchido utilizando informações de um projeto real.
Para fins de exemplo nós consideramos um caso de uso para o caso de Login.
Esse caso de uso possui:
Nome; Descrição;
Fluxos, um fluxo básico e alguns alternativos;
Requisitos; Précondições e pós-condições;
Além de atores.
Em esse exemplo temos que:
Login é um caso de uso bastante usual e que pode ser executado quando actor $= User;
Os fluxos definem o que o User deverá fazer para executar uma determinada ação do Caso de Uso.
Ou seja, o fluxo básico define o fluxo mais evidente ou esperado (como no exemplo:
&quot;use the ok option&quot;), enquanto que os fluxos alternativos definem os passos para algum comportamento excepcional (como no exemplo:
&quot;use the cancel option&quot;);
Os requisitos definem o que é necessário para executar um caso de uso, no exemplo existem os requisitos 3.1 Id must unique e 3.2 Password must be 6-8 characters, que na verdade mostram a necessidade de restrições para a validação dos campos Id e Password;
As pré-condições 4.1 e 4.2 descrevem o estado inicial para a execução do caso de uso, ou seja, é necessário que o usuário a fazer login esteja cadastrado e que a página com o formulário de login esteja renderizada;
A pós-condição 5.1 da uma idéia do estado esperado após a execução do caso de uso.
Desta forma, é essencial que o User esteja &quot;logado «na aplicação.
O próximo passo do Guia para Autoria é a modelagem dos contêineres.
Desta forma, adicionamos todos os contêineres mapeados dentro de o modelo adicionando- se o estereótipo ContainerDefinition.
Além disso, foram definidos os relacionamentos entre os contêineres, todos feitos através do estereótipo ContainerDefinitionRelationship e expressados através de setas com diamante branco, utilizados para denotar associações de agregação da UML.
Esses contêineres podem ser vistos na Figura 5.41, que apresenta um diagrama de nome Containers (mostrado em (D)).
Além disso, nessa Figura pode também ser visto a aplicação do estereótipo ContainerDefinition ao contêiner Actors (em (E)), assim como os tagged values existentes já previamente preenchidos (pode ser visto em (F)):
BriefDescription, utilizado para expressar uma descrição resumida do contêiner;
MainDescription, utilizado para expressar a descrição principal do contêiner;
Kind, herdado do catálogo de estereótipos do SPEM v2, esse atributo não faz sentido nesse contexto, por isso não foi utilizado nesse caso, entretanto, seu valor determina qual metaclasse da UML ele esta representando;
PresentationName, utilizado para expressar um nome de apresentação para um contêiner;
Purpose, utilizado para expressar o propósito ou a finalidade do contêiner;
Por fim, na Figura 5.41 estão todos os relacionamentos que foram adicionados ao modelo, vistos através da espansão do pacote associations.
Criação do Process Structure. A modelagem do Process Structure acontece da mesma forma como no primeiro cenário, ou seja, basta definir um elemento de processo que precise utilizar um elemento de definição do Method Content.
Conforme a Figura 5.43, criamos o uso do artefato Especificação de Caso de Uso, lado direito da Figura, que pertence ao pacote AtifactsUse, com o estereótipo ArtifactPackage.
Além disso, o pacote que estrutura o Process Structure possui o estereótipo Desta forma, utilizamos o diagrama ArtifactUse, visto a direita da Figura, para criar a visão lógica que representa a ligação entre o Uso do artefato e sua definição.
Esta ligação foi feita através do relcionamento de dependência definido por o próprio SPEM v2.
Conforme a necessidade de utilização de processos para a construção de produtos, em Engenharia de Software, o foco dos Processos de Desenvolvimento de Software é visar a um Produto de Software final a partir de a construção de vários Artefatos de Software.
Diante deste fato, problemas no tratamento de tais artefatos caracterizam um provável erro de paradigma, visto que ao tratar- los como elementos monolíticos, os processos desconhecem as interações e mudanças ocorridas nos artefatos durante sua evolução.
Diante deste contexto foram apresentados alguns desafios e os problemas descritos no Capítulo 1, todos culminando na solução de um objetivo comum:
Construir artefatos de forma que sua organização interna esteja bem estruturada e definir diversas versões, autores e estruturas de informação aos artefatos durante sua autoria.
A partir de o qual foi criada a Questão de Pesquisa para este trabalho:
Como deve ser a autoria de Artefatos de Software de forma que estes não sejam monolíticos?
Em este sentido, a construção de um modelo capaz de facilitar a estruturação e manipulação desses artefatos traz um novo paradigma, uma vez que deixa de orientar o processo as atividades, aumentando o foco nos artefatos, uma vez que serão mais bem estruturados.
Desta forma, neste trabalho foi feito uso de linguagens de especificação que permitem a representação de informações relacionadas aos artefatos presentes no processo utilizando conceitos de modelagem Orientada a Objetos.
Para que tal feito pudesse ser concretizado, houve a extensão do metamodelo SPEM v2 e da UML, apresentando soluções para versionamento, organização e estruturação lógica interna tanto no conteúdo quanto na estrutura, utilizando- se de informações com tipos bem definidos e compartilhados.
Por fim houve a criação de um ferramental para nossa abordagem que permitiu avaliar a capacidade de utilização do metamodelo.
A idéia de autoria de artefatos, juntamente com seus detalhes foi concretizada a partir de o seu uso no protótipo SwAT, visto no Capítulo 5, dando conta da solução das problemáticas citadas no Capítulo 1 e atendendo o objetivo supracitado.
Em esta seção são apresentadas algumas limitações deste trabalho:
Durante a avaliação da proposta não foram realizadas verificações da autoria de PDSs com foco em detalhamento de ASs em processos inteiros, assim como os utilizados em indústria de grande porte.
Além disso, não foram feitos estudos empíricos.
A ferramenta SwAT ainda é apenas um protótipo, sendo necessário melhorar- la para uma melhor usabilidade e maior suporte ao usuário.
A abordagem não oferece suporte a publicação dos artefatos para que possam ser utilizados em outras ferramentas.
Os tipos determinados para as informações, assim como as restrições implementadas no metamodelo foram feitas para casos gerais, conforme estudo apresentado no Capítulo 4.
Entretanto, existem diversos pontos de extensão que permitem tal melhoria.
Em esta dissertação foram respondidas algumas questões importantes relacionadas à autoria de Artefatos de Software.
Apesar de esta contribuição, a abordagem ainda precisa ser melhorada, principalmente no quesito avaliação, com o objetivo de ser consolidada.
Apesar de avaliações iniciais terem demonstrado a aplicabilidade e corretude da abordagem, maiores investigações devem ser feitas quanto sua aplicabilidade na indústria.
Desta forma, alguns trabalhos a serem realizados futuramente estão listados a seguir:
Melhorias a serem feitas na Abordagem:
­ Executar mais casos de testes:
Possivelmente, após a execução de novos casos de testes mais completos novos dados serão coletados, surgindo a oportunidade de se fazer novas avaliações;
­ Realizar um experimento:
A realização de um experimento que seja capaz de comparar nossa abordagem com o paradigma atual pode ser muito útil, pois coletando dados suficientes, pode- se tirar conclusões mais acertadas, baseando- se em análises de variáveis qualitativas e quantitativas.
Ferramenta de Autoria de Artefatos: ­Análise de desempenho:
Apesar de os testes realizados, é necessária a execução de testes reais e de grande porte utilizados na industria, a fim de verificar o desempenho e o comportamento da ferramenta nestes cenários.
Possivelmente possa ocorrer queda de desempenho conforme o aumento da biblioteca em que os artefatos se encontram.
De esse modo, uma avaliação destes pontos pode vir a ser importante e representa um relevante e provável futuro investimento.
O resultado desta avaliação permitirá prover melhorias na ferramenta.
Guia de Autoria de Artefatos: ­ Aplicabilidade do guia de Autoria de Artefatos:
A aplicação do guia de composição definido neste trabalho em diferentes tipos de artefatos é indispensável para avaliação de sua aplicabilidade, consolidação e evolução.
