Avaliação de desempenho de sistemas distribuídos trata- se de uma importante ferramenta durante a fase de desenvolvimento.
Esta tarefa tem por objetivo mostrar ao usuário (pesquisador, programador, analista, etc) o comportamento previsto para o seu sistema, antes mesmo que este esteja implementado, evitando custos com tempo de implementação e de eventuais reconstruções de código.
Em este contexto, existem maneiras muito utilizadas na comunidade científica para dar suporte a avaliação de desempenho, como Simulação e Modelagem Analítica.
Entretanto, a criação e a execução destes modelos nem sempre é realizada de maneira trivial, pois uma importante fase na modelagem é a obtenção dos parâmetros do sistema alvo, devido a o fato de que quanto mais fiel for o modelo, mais próximo de o real serão os resultados.
Assim, este trabalho visa realizar uma análise comparativa entre duas ferramentas de avaliação de desempenho (SimGrid e SAN) através de duas abordagens diferentes (Simulação e Modelagem Analítica, respectivamente).
Para isto, os parâmetros das aplicações executadas no SimGrid foram mapeados para o modelo SAN, procurando desta forma obter uma equivalência nas modelagens para que seus resultados possam ser comparados.
Após a apresentação dos resultados obtidos, alguns aspectos interessantes sobre as duas maneiras de avaliação de desempenho são discutidos.
Paravras-chave: Avaliação de desempenho, programação distribuída, modelagem analítica, simulação, SAN, SimGrid.
Os avanços nos diversos ramos da Ciência (tais como Medicina, Física, Química, Engenharia e Geologia) foram concebidos através da utilização de ferramentas computacionais.
Entretanto, simulações de grande porte constantemente demandam um alto poder computacional para que sejam realizadas.
Com a finalidade de evitar os elevados custos da compra de supercomputadores, a utilização de aglomerados de computadores pessoais de baixo custo surge como uma alternativa atraente.
A partir de então, uma vasta gama de tecnologias criadas para explorar recursos vem surgindo, como clusters, grades computacionais, etc..
Apesar de a utilização destas plataformas distribuídas serem alternativas atraentes, o desenvolvimento de aplicações em tais ambientes é particularmente difícil, devido a o grande número de variáveis envolvidas e diferentes tipos possíveis de falhas.
Plataformas mais distribuídas (como grades computacionais, por exemplo) são espalhadas em diversos domínios administrativos, trazendo como conseqüência flutuações na disponibilidade dos recursos.
Logo, a condução de experimentos repetitivos para aplicações com tempos de execução relativamente altos tornase impossibilitada, dificultando a avaliação de desempenho de aplicações reais, principalmente considerando as inúmeras possibilidades de configuração existentes.
Esta avaliação de desempenho, no entanto, é uma tarefa imprescindível para a validação da implementação realizada.
Esta importância se deve ao fato de que, quando se deseja desenvolver determinado sistema para um dado propósito, a expectativa é de que ele se comporte de maneira adequada, apresentando um bom desempenho e sendo capaz de executar num tempo aceitável.
Existem diversas formas de avaliação de desempenho, normalmente divididas em três grandes grupos:·
Medições: Em a qual o programa deve estar previamente implementado para que medidas sejam coletadas de suas execuções;·
Simulações: Em a qual um modelo computacional do sistema é criado para observar os fatores que interferem no seu comportamento;·
Modelagem analítica:
Que se trata de uma representação matemática do sistema a ser analisado.
Em este estudo, utilizará- se- simulação e modelagem analítica, com o intuito de comparar tais para efetuar a avaliação de desempenho de aplicações para plataformas distribuídas.
O formalismo analítico a ser utilizado neste trabalho será Rede de Autômatos Estocásticos (SAN -- Sthocastic Automata Network), por tratar- se de um formalismo mais recente e fortemente baseado na teoria de Cadeias de Markov, porém expressando os modelos Markovianos de forma mais fácil, compacta e eficiente.
Em a modelagem analítica, entretanto, as métricas de desempenho são geradas através de parâmetros indicados no modelo.
Assim, experimentos realizados através de simulação surgem como uma escolha bastante viável para a obtenção precisa de tais parâmetros.
Simulações podem ser repetidas, são cofiguráveis e geralmente demandam menos tempo que execuções reais.
Este tipo de abordagem vem sendo amplamente utilizada para apontar decisões corretas durante o desenvolvimento de software para ambientes de grades computacionais.
Uma das ferramentas mais conhecidas para a simulação de algoritmos em grades é o SIMGRID, que será utilizada neste trabalho para a realização dos objetivos em ele propostos.
Em a comunidade científica, alguns trabalhos utilizando a modelagem SAN para a avaliação de desempenho de sistemas computacionais podem ser encontrados.
Um de eles trata- se de um trabalho realizado por Maraculescu e Nandi.
Em ele, os autores apresentaram uma nova metodologia para a modelagem de aplicações de sistemas de níveis.
O decodificador de vídeo MPEG-2 foi a aplicação utilizada para validar e exemplificar as vantagens desta nova abordagem.
O formalismo SAN foi utilizado para modelar a aplicação, e foi comprovado que esta possui um comportamento estacionário através de diferentes probabilidades, o que permitiu mapeamentos mais eficientes da aplicação.
Os próprios autores consideraram SAN como uma ferramenta eficiente para modelar a comunicação entre os processos, e ainda relataram a vantagem de que o número de estados não explode.
Outro trabalho interessante com a utilização de SAN trata- se do trabalho descrito em.
Em este trabalho, os autores propuseram o uso de Redes de Autômatos Estocásticos para desenvolver modelos que se aplicassem a programas do tipo mestre/ escravo, considerando dois padrões de comportamento para descrever a comunicação entre os mestres e os escravos:
Síncrono e assíncrono.
Como caso de estudo, o algoritmo de region growing conhecido como Propagation foi utilizado.
Esta aplicação trabalha com interpolação de imagens, para gerar uma visão virtual entre dois pontos iniciais distintos.
A aplicação foi modelada utilizando SAN para validar a estratégia de implementação escolhida.
Segundo os autores, a modelagem de programas paralelos é facilitada com o formalismo SAN, e pôde dar uma visão geral dos resultados que serão obtidos com a paralelização do Propagation de acordo com alguns fatores, como sincronia/ assincronia e grão fino/ grosso.
O trabalho realizado por Mokdad Também utiliza a modelagem SAN.
Em este trabalho, os autores apresentaram um novo algoritmo de roteamento, para melhorar a qualidade de entrega de pacotes em redes de baixa latência.
Os autores mostram os benefícios desta nova proposta de algoritmo através da avaliação de desempenho de modelos SAN, além de ressaltar o fato de que o formalismo SAN é muito utilizado para sistemas complexos, quando a utilização de Cadeias de Markov é inviável.
A implementação de aplicações para sistemas computacionais (em diversas ocasiões) não é trivial, principalmente quando se tratam de aplicações paralelas e distribuídas.
Estudos sobre o desempenho apresentado por tais aplicações antes mesmo de sua implementação de fato, são de grande importância para que as soluções propostas sejam previamente validadas, evitando problemas relacionados com reconstruções do sistema.
Uma vez previsto o comportamento da aplicação desejada, alterações na implementação, nos parâmetros ou nas configurações da solução proposta podem ser realizados (se necessário) para que o desempenho real apresente- se conforme o esperado.
Devido a o constante avanço das plataformas distribuídas e sua crescente utilização, a construção de simuladores facilita ao usuário a avaliação dos sistemas propostos.
Isto se deve ao fato de que há uma maior flexibilidade de configuração e diversificação dos parâmetros do ambiente, flexibilidade esta que se torna bastante complexa de ser realizada na prática.
Em a modelagem analítica, por sua vez, as métricas são obtidas através de modelos construídos com certos parâmetros que vêm da aplicação.
Uma das grandes dificuldades encontradas na construção e resolução deste método, no entanto, é exatamente a definição precisa destes parâmetros, o que acarreta em incertezas nos resultados obtidos aravés dos modelos.
Com a ferramenta de simulação SIMGRID, os parâmetros providos por o simulador podem agregar grande valor na construção do modelo SAN das aplicações, tendo em vista as configurações mais bem definidas desta ferramenta.
O objetivo do trabalho a ser realizado é comparar o comportamento e os resultados obtidos através da criação de Modelos Analíticos (com a utilização da ferramenta SAN) de aplicações para plataformas distribuídas, com aqueles obtidos através da utilização de uma abordagem de Simulação (através da ferramenta SimGrid).
Com isto, obterá- se- uma análise das funcionalidades, analisando ainda as facilidades e os obstáculos encontrados no desenvolvimento de cada um dos tipos de modelagem.
Em este contexto, poderá ser avaliado quão semelhantes e quão úteis tornam- se estas ferramentas para o usuário final, que deseja avaliar o desempenho de sua (s) aplicação (ões).
O intuito da modelagem com SAN, neste contexto, é procurar parametrizar da maneira mais fiel possível o modelo criado para as aplicações, de acordo com os parâmetros obtidos com o simulador, com a finalidade de comparar e validar a utilização de tal modelagem para este fim.
A o final do estudo, acredita- se que será possível extrair uma conclusão fortemente aceitável sobre as abordagens de Simulação e Modelagem Analítica utilizando SAN.
Este trabalho está estruturado da seguinte forma:
De desemepenho (Simulação e Modelagem Analítica);
Sistemas computacionais devem apresentar certas características para que suas implementações sejam de real valia (facilidade de utilização, de manutenção, etc).
De entre estas características, pode- se destacar o desempenho, que se trata do rendimento demonstrado por a aplicação ao realizar suas respectivas funções.
Este desempenho, então, é um critério fundamental na criação destes sistemas, principalmente quando se tratam de ambientes paralelos ou distribuídos.
Em estes ambientes, tanto usuários quanto projetistas, analistas e desenvolvedores desejam que seus sistemas apresentem o melhor desempenho com o menor custo possível, o que tem resultado numa grande evolução dos sistemas de baixo custo e alto desempenho.
Embora processadores e memórias atuais já atinjam desempenhos muito mais satisfatórios quando comparados aos que apresentavam antes, as pesquisas realizadas na área de avaliação de desempenho das aplicações não se detêm apenas a aspectos tecnológicos.
De este modo, diversos modelos e métodos foram (e continuam sendo) criados para realizar análises através de diferentes abordagens.
Em este contexto, para realizar a análise de desempenho de um determinado sistema, primeiramente deve- se construir um modelo condizente com ele.
Construir um bom modelo que realmente auxilie na análise de desempenho, contudo, não é uma tarefa trivial e requer considerações cuidadosas.
Segundo, um bom modelo deve incluir todos os detalhes necessários para descrever o comportamento do sistema com a maior exatidão possível.
Além disso, o modelo deve ser de simples resolução, excluindo a maior quantidade de parâmetros que se consiga.
Note, no entanto, que quando se incluem todos os detalhes do comportamento do sistema, aumenta- se a complexidade de resolução do modelo, tornando a tarefa de selecionar os parâmetros necessários um passo importante na construção do modelo.
Um modelo, então, trata- se de uma coleção de atributos e um conjunto de regras que governam como estes atributos interagem.
Em o âmbito da avaliação de desempenho de programas desenvolvidos para serem executados em ambientes paralelos, devido a complexidade natural inferida nestas plataformas (comunicação e sincronização, por exemplo), tais modelos devem ser suficientemente claros e simples, abstraindo ao máximo estas complexidades.
Predição e avaliação de desempenho são assuntos que caminham juntos.
Pode- se dizer, inclusive, que a tarefa de predizer o desempenho de uma aplicação trata- se de um tipo especial de avaliação.
Quando se deseja desenvolver um determinado sistema (principalmente tratando- se de programas paralelos), um dos principais objetivos é a obtenção de um desempenho satisfatório.
Entretanto, para os programadores, analistas e toda a equipe que estiver envolvida na implementação deste sistema, não é interessante que se descubra que o sistema desenvolvido não apresentou o desempenho esperado somente quando a versão encontrar- se implementada e for executada.
Conforme visto anteriormente, avaliação de desempenho apresenta o comportamento da aplicação, de acordo com os fatores que se deseja analisar.
Predição de desempenho, por sua vez, é o ato de anunciar com antecedência este comportamento.
Assim sendo, o objetivo da predição também é compreender a maneira como o sistema se comporta, mas este comportamento é visualizado antes mesmo que a aplicação seja implementada.
Com isto, gargalos e situações adversas ao que se espera podem ser encontrados e solucionados antes mesmo da construção do sistema.
Existem duas abordagens principais para o processo de análise de desempenho, as quais estão diretamente relacionadas com o estágio de desenvolvimento do sistema.
A primeira de elas refere- se ao estágio posterior à construção do sistema, quando ele encontra- se totalmente implementado.
Assim, ao menos um protótipo deve previamente estar implementado.
A segunda abordagem refere- se a uma avaliação que (geralmente) é realizada antes da implementação da aplicação, sem a necessidade da existência de código-fonte e nem sequer protótipos.
Em este caso, a avaliação está fortemente ligada à predição de desempenho, pois as técnicas são utilizadas na parte inicial no processo de desenvolvimento, e o comportamento da aplicação é previamente examinado antes mesmo de sua implementação.
A seguir, são descritas as duas técnicas para a modelagem do processo de análise de desempenho utilizadas neste estudo:
Simulação e Modelagem Analítica.
Quando se utiliza esta técnica, pretende-se simular o comportamento do sistema, para que se tenha uma idéia do seu desempenho.
Com a utilização desta abordagem, pode- se realizar predições, pois não há a necessidade do sistema pronto.
Para tanto, um modelo do sistema que se deseja implementar (ou mesmo de um sistema já implementado) é criado, para facilitar e observar os fatores que interferem no seu comportamento.
Os sistemas modelados podem alterar suas características com o tempo ou não, diferenciando simulações estáticas e dinâmicas, respectivamente.
Conforme descrito em, diferentes tipos de simulação são encontrados, tais como emulação, Monte Carlo, trace-driven, discretevent e execution-driven.
Entretanto, é comum que modelos de simulação falhem, apresentando resultados incorretos.
Alguns dos erros mais comuns são citados a seguir, e um maior detalhamento e alternativas para a resolução de eles podem ser encontrados em.
São eles:
Nível de detalhes inapropriado, linguagem de programação inadequada, falta de verificação nos modelos, modelos sem a devida validação, condições iniciais impróprias, simulações muito curtas, gerações fracas de números aleatórios e seleção imprória da semente inicial (primeiro valor aleatório gerado, fornecido por o analista).
Em simulações, as aplicações paralelas são caracterizadas por eventos globais separados por computações locais.
Eventos (computações) locais não interferem e não são interferidos por outros processos do sistema, diferentemente dos eventos globais.
O acesso a memória compartilhada e computações para a tarefa de sincronização são algumas das operações de um evento global.
Em este contexto, simuladores surgem como ferramentas interessantes para auxiliar na avaliação de desempenho de sistemas reais.
Existem diferentes ferramentas utilizadas para simular plataformas de computação distribuída, de entre as quais pode- se citar algumas mais notáveis, tais como OptorSim, GridSim, MicroGrid, e SIMGRID.
O primeiro simulador (OptorSim), é implementado em Java e trabalha com réplicas de jobs.
Este simulador é utilizado principalmente para comparar diferentes estratégias de escalonamento com a utilização destas réplicas, simulando o comportamento de ambientes distribuídos conforme alguns parâmetros definidos (topologia de rede e conjunto de jobs, por exemplo).
Outra ferramenta bastante difundida, trata- se do GridSim, que também simula ambientes de grades computacionais, monitorando seus recursos.
Utiliza- se do pacote SimJava (simulação baseada em eventos), o que torna- o escalável e portável.
Finalmente, para este trabalho escolheu- se a ferramenta SIMGRID, que será descrita na Seção 3.1.
Um modelo analítico é uma representação matemática de um sistema computacional.
Em esta modelagem, métricas de desempenho da aplicação são geradas através de parâmetros do modelo realizado.
Este tipo de técnica vem sido cada vez mais utilizada para modelar sistemas paralelos, devido a a facilidade de utilizar- las e ao seu baixo custo.
Este custo, entretanto, trata- se tanto do custo com ferramentas para o desenvolvimento da própria modelagem quanto do custo ao final da análise dos resultados por ela gerados, pois o sistema ainda não foi implementado (diferentemente de medições, por exemplo).
As técnicas baseadas em modelagem analítica abstraem as características do sistema paralelo, modelando- as como um conjunto de parâmetros ou de funções parametrizadas.
A modelagem analítica pode ser dividida em três tipos:
Modelagem com parâmetros escalares, modelagem com funções e análise estatística.
Em a primeira de elas, utiliza- se um conjunto de parâmetros escalares que irão representar o comportamento do sistema paralelo sobre determinadas condições.
A dificuldade deste modelo é a escolha dos parâmetros corretos e importantes.
Uma escolha mal formulada diminuirá a precisão dos resultados do modelo.
Por outro lado, estes parâmetros simplificam o comportamento do sistema, levando a naturais imprecisões.
O tipo de modelagem realizado com funções, por sua vez, utiliza- se de funções matemáticas ao invés de parâmetros em seus modelos.
Tal abordagem pode se tornar bastante complexa por ter que determinar a forma e os coeficientes das funções.
A modelagem baseada em parâmetros descrita previamente, trata- se de uma caso especial de modelagem através de funções, em a qual as funções são constantes.
Finalmente, a abordagem através de análise estatística é usualmente utilizada para analisar sistemas paralelos quando as características da carga de trabalho são bem conhecidas.
Em esta modelagem, o comportamento assintótico do sistema alvo é o que se deseja representar.
O desenvolvimento destes modelos, no entanto, pode necessitar de um conhecimento mais específico sobre estatística.
Como exemplo de ferramentas que realizam tal tipo de análise, podemos citar:·
Teoria de Filas:
Modelos baseados em filas são úteis para a análise de sistemas em os quais conflitos ocorrem quando diversas entidades tentam acessar simultaneamente o mesmo recurso.
Existem dois tipos de rede de filas:
Rede de filas aberta e rede de filas fechada.
Em uma rede aberta, existem chegadas externas de clientes ao sistema e saídas dos clientes em determinados pontos da rede.
Em este tipo de modelagem, há uma variação na quantidade total de clientes.
Por outro lado, em redes fechadas o serviço é realizado e o cliente continua no sistema, voltando para algum ponto do mesmo.
Não há, portanto, chegadas de clientes externos e tampouco saída dos que se encontram no sistema.·
Cadeias de Markov: Conforme, uma Cadeia de Markov trata- se de um conjunto de estados e transições entre estes estados.
Estas transições são modeladas por processos estocásticos, e possuem ou uma probabilidade associada (quando tratam- se de processos de tempo discreto) ou uma taxa (no caso de processos de tempo contínuo).
Cadeias de Markov de tempo contínuo permitem que as transições possam ocorrer em qualquer instante de tempo, enquanto as de tempo discreto (como o próprio nome diz) ocorrem em pontos discretos de tempo.·
Redes de Petri: Rede de Petri é uma poderosa ferramenta para modelar e analisar concorrência e sincronização de sistemas paralelos, pois permite uma visualização das coopera-ções entre as diversas entidades.
Tornou- se um formalismo famoso por a simplicidade de sua modelagem e por a capacidade de descrever sistemas extensos.
A ferramenta escolhida para a realização das modelagens neste trabalho foi Redes de Autômatos Estocásticos, que será descrita na Seção 3.2.
3 Ferramentas Para a realização dos objetivos propostos neste trabalho, duas ferramentas foram utilizadas:
A primeira versão do simulador SIMGRID era uma versão mais simples, e está descrita em.
Foi desenvolvida por Henri Casanova, que modificou uma implementação previamente realizada, criando uma estrutura de simulação mais genérica e com uma API (Application Programming Interface) amigável.
Após algum tempo, uma nova camada chamada MSG (Meta-SIMGRID) foi desenvolvida, acrescentando threads e também a idéia de processos sendo simulados independentemente.
Em o final do ano de 2003, o SIMGRID passou a executar em sua versão SIMGRID v2.
A partir de a versão 3, outros diferentes módulos foram adicionados à implementação (alguns destes sendo tratados a seguir).
O simulador encontra- se, ultimamente, em sua versão 3.2.
O SIMGRID é uma das ferramentas mais conhecidas para a simulação de ambientes de programação distribuída, e neste estudo será utilizado para ambientes de grades computacionais.
Alguns de seus principais componentes podem ser vistos na Figura 1, cada um com uma funcionalidade específica.
O primeiro componente trata- se do MSG supracitado.
É um ambiente de programação simples, incluído desde a segunda versão do simulador, e foi o primeiro ambiente de programação distribuída provido no SIMGRID.
Em este componente, algumas funcionalidades básicas são oferecidas, tais como o gerenciamento de hosts e tarefas, e é normalmente utilizado para a simulação de aplicações distribuídas genéricas.
O próximo componente trata- se do SMPI, que se refere ao ambiente de programação para aplicações construídas com a utilização da biblioteca MPI.
Aplicações implementadas em MPI serão executadas no simulador através deste módulo, sem que sua implementação tenha que ser modificada.
O componente Surf é responsável por providenciar todas as funcionalidades de simulação da plataforma virtual.
É o kernel de todos os componentes do SIMGRID, tratando- se assim de um módulo de bastante baixo nível.
O último componente corresponde ao GRAS (Grid Reality And Simulation).
Este módulo é utilizado por usuários que desejam desenvolver aplicações reais, ou seja, aplicações com a finalidade de que, após o término das simulações, o programa realmente venha a ser distribuído sem a necessidade de alterações no código.
As aplicações deste documento foram implementadas sobre os módulos MSG e GRAS, pois são os que provêm uma visão mais real do ambiente de plataformas distribuídas.
As aplicações executadas no SimGrid são implementadas utilizando a linguagem de programação C. Tratam-se de programas parecidos com os usuais, porém, com algumas abstrações e funções que não realizam em si a tarefa, mas sim simulam o seu possível comportamento.
Quando as execuções no simulador são realizadas, usualmente ao final é relatado o tempo total de simulação, e impressões na tela podem ser realizadas durante a simulação para mostrar os passos que estão sendo realizados por os processos.
O ponto mais importante para este estudo neste contexto, trata- se dos arquivos de configuração.
A o executar uma aplicação no SimGrid, dois arquivos XML de configuração devem ser informados para que a simulação seja feita de maneira correta.
O primeiro de eles chama- se platform.
Xml. Trata- se de um arquivo em o qual são descritas informações sobre a topologia da rede.
Todos os nodos presentes na simulação devem ser descritos neste arquivo, e para cada processo ainda deve ser adicionada a informação sobre o seu poder computacional.
Além de isto, informações como a latência de o (s) link (s), largura de banda e a maneira por a qual os nodos são interligados devem ser descritas.
A Figura 2 apresenta um exemplo deste arquivo.
O segundo arquivo trata- se do deployment.
Xml. É um arquivo em o qual são descritas informações para a aplicação, tais como parâmetros de entrada e informações sobre a porta para comunicação com os demais processos.
Para cada processo do sistema (descrito no arquivo platform.
Xml), deve haver no mínimo uma linha neste arquivo de deployment, fazendo referência a sua função no processo (funções estas definidas no código da aplicação).
Estas funções podem ser se o processo é o mestre ou o escravo, se o processo é o cliente ou o servidor, se é o coordenador ou o subordinado, etc..
A Figura 3 apresenta um exemplo de arquivo de deployment para o arquivo de platform citado acima.
A modelagem utilizando Redes de Autômatos Estocásticos data da década de 80, e surge como uma importante alternativa para a modelagem de sistemas paralelos.
Seu nome original é Stochastic Automata Network (SAN), e trata- se de um formalismo baseado na teoria de Cadeias de Markov, expressando modelos Markovianos de maneira mais intuitiva e compacta.
Através da modelagem com SAN, medidas de desempenho podem ser obtidas, tais como throughput, atraso de sincronização, tempo de resposta, de entre outras, mesmo antes da implementação da aplicação.
O princípio da utilização do formalismo SAN é traduzir (ou abstrair) um sistema real em sua totalidade em diversos módulos, de maneira independente, modelando diversos subsistemas.
Estes subsistemas, obviamente, terão pontos de interação em alguns momentos para que o objetivo final do conjunto como um todo seja alcançado.
Entretanto, para a obtenção das medidas de desempenho de um sistema, é necessário que o modelo criado seja resolvido.
Em esta seção, a maneira de construção de modelos SAN é detalhada, visando gerar as estimativas de desempenho do sistema real.
Em este documento, será apresentada uma visão mais intuitiva da maneira por a qual os modelos SAN são construídos, indicando para considerações e explicações mais formais a leitura da referência.
Um estado na modelagem SAN é representado graficamente por um círculo.
Cada um destes refere- se a um determinado comportamento apresentado por o sistema, e o conjunto de eles representa o conjunto destes comportamentos.
Quando o sistema altera seu comportamento, seu estado é alterado.
Tal situação (mudança de um estado para outro) é chamada de transição, e é representada por um arco ligando os estados origem e destino (note que se trata de um grafo dirigido, pois as arestas possuem setas que indicam sua direção).
Entretanto, para que uma mudança de estado aconteça, um evento deve ocorrer.
Assim, quando um evento do sistema ocorre, o modelo altera seu estado, realizando transições de acordo com as probabilidades associadas a cada um destes eventos.
A ocorrência destes eventos depende de taxas associadas a cada um de eles.
Para alguns eventos, uma probabilidade é associada.
Em o exemplo apresentado, nota- se que do estado B do autômato A2, na ocorrência do evento ca, há uma probabilidade de 70% do autômato alcançar o estado R, e uma probabilidade de 30% de continuar no estado B. Além de isto, funções podem ser definidas para os eventos, como acontece no autômato A3.
O evento pa neste autômato, depende do estado do autômato A2.
Caso A2 encontre- se em B, o evento pa levará A3 do estado N para o estado A. Caso contrário (A2 em R), o evento pa acarreta na transição do estado N para o estado C. Dois tipos de análises podem ser realizadas ao resolver um modelo SAN:
Estacionária e transiente.
Em a análise estacionária, os resultados esperados são as probabilidades de permanência em cada estado (ou de combinações de estados desejados por o usuário).
Com isto, pode ser realizada uma análise do comportamento da aplicação modelada com as taxas e probabilidades definidas no modelo, possibilitando que alterações nestes valores sejam realizados, para melhorar o desempenho, diminuir gargalos, etc..
Já na análise transiente, é possível estimar o tempo médio de execução da aplicação modelada.
Este estudo dedicou- se a utilizar análise transiente, para realizar comparações nos tempos de execução previstos no simulador SimGrid e na modelagem SAN.
Para completar a criação de modelos SAN, ainda restam as definições das taxas associadas a cada evento.
As taxas de um evento representam a frequência com que este evento acontece a cada unidade de tempo.
Para exemplificar, a Figura 5 representa uma possível modelagem para a requisição de uma tarefa.
Em este simples modelo, o autômato A envia uma mensagem para o autômato B, que realiza um processamento sobre esta mensagem e retorna o resultado para o autômato A. O estado I do autômato A representa o estado em o qual este autômato está parado.
Em a ocorrência do evento sincronizante e, o autômato A passa para o estado W (aguardando) e o autômato B passa do seu estado W para o estado P (processando).
Quando o autômato B termina o processamento, ocorre o evento local l, que faz com que este autômato passe para o estado E, em o qual enviará a mensagem.
Finalmente, na ocorrência do evento sincronizante f (representando o envio da mensagem de B para A), o autômato B vai para o estado F (final), enquanto o autômato A volta para o estado I. Supondo que o tempo de envio da mensagem do autômato A para o autômato B (evento e) seja de 20 segundos, o tempo de processamento do autômato B (evento l) seja 37 segundos e o tempo de envio do autômato B para o autômato A (evento f) também seja de 20 segundos, e que a unidade de tempo é em segundos, tem- se:·
taxa do evento e:
A cada unidade de tempo, este evento ocorre 1/20 vezes, ou seja, a taxa deste evento será de 0,05;·
taxa do evento l:
A cada unidade de tempo, este evento ocorre 1/37 vezes, ou seja, a taxa deste evento será de 0,027;·
taxa do evento f:
A cada unidade de tempo, este evento ocorre 1/20 vezes, ou seja, a taxa deste evento será de 0,05.
De esta maneira, calcula- se as taxas para os eventos, baseando- se no tempo em que leva para executar.
Para encontrar este tempo, o usuário pode realizar medições (por exemplo, através de um programa que colete o tempo de envio da mensagem), realizar cálculos (através da utilização de valores encontrados em manuais da rede, por exemplo) ou até mesmo empiricamente.
Cabe ressaltar que a obtenção dos valores corretos é de extrema importância na fase de modelagem, para representar da maneira mais fiel possível a aplicação.
Além de estas taxas, existem ainda as chamadas taxas funcionais.
Elas possuem este nome por serem executadas em função de alguma condição.
Por exemplo, se o evento l (do autômato B) possuísse uma taxa funcional, ela poderia ser dada por:·
taxa funcional do evento l:
Se o autômato A estiver no estado W, então a taxa será de Como pode ser visto, o evento l ocorre em função de o estado do autômato A. Para a execução dos modelos SAN, utilizou- se a ferramenta PEPS (Performance Evaluation of Parallel Systems).
Em esta seção, serão abordados de maneira simples e intuitiva alguns aspectos relativos a sintaxe da ferramenta, que serão utilizados no decorrer de o trabalho.
O arquivo de entrada do PEPS tem a extensão san (nome_ de o_ arquivo.
San). Em este arquivo, são descritos os autômatos, os estados, transições, eventos, taxas e todos os demais aspectos referentes ao modelo SAN.
Abaixo, encontram- se algumas estruturas e expressões utilizadas neste documento:
Todas estas expressões quando são utilizadas resultam em verdadeiro ou falso.
Logo, são utilizadas para definições de taxas funcionais, como no exemplo abaixo:
Conforme relatado anteriormente, a análise transiente foi utilizada neste trabalho para realizar a obtenção de tempos de execução através da modelagem SAN.
Em esta seção, será descrito o procedimento para a realização da análise transiente.
O primeiro passo para a realização da análise transiente é a definição de um estado inicial e de um estado final para o modelo SAN.
Por exemplo, no modelo SAN da Figura 5, podese determinar -- na sintaxe da ferramenta PEPS (Seção 3.2.3) -- os estados inicial e final como seguem:
Ou seja, o estado inicial acontece quando o autômato A encontra- se no estado I e o autômato B encontra- se no estado W, enquanto no estado final o autômato A encontra- se no estado I e o autômato B no estado F. A ferramenta PEPS possui métodos iterativos para a resolução de sistemas de equações.
Assim sendo, na execução do modelo no PEPS, o usuário informa um tempo para que seu modelo seja executado.
A o final da execução para este tempo determinado, obtem- se como resultado um vetor de probabilidades com todos os estados do modelo SAN.
Analisa- se, então, se a probabilidade do modelo estar no estado final encontra- se em 99%.
Caso isto não ocorra, este vetor de probabilidades é recarregado por o PEPS (para continuar da iteração anterior), e é realizada uma nova execução.
Este procedimento é repetido até que o a probabilidade do estado final seja de 99%.
Cada uma destas execuções parciais gera uma determinada probabilidade para o estado final do modelo.
Devido a o fato de que a cada execução tem um tempo associado, tem- se que o tempo parcial de cada execução é dado por:
Entretanto, para cada nova iteração, a probabilidade da execução anterior já foi calculada.
Logo, antes do cálculo do tempo parcial, é necessário descontar da probabilidade atual, a probabilidade anterior, como segue:*
tempo $= tempo parcial.
Assim, com todas as probabilidades parciais conhecidas (desde a primeira até a última execução), basta realizar o somatório destes valores e obterá- se- o valor do tempo para o modelo SAN.
Em a Tabela 2 é apresentado um exemplo simbólico de cálculo do tempo com a análise transiente.
Para avaliar e comparar os resultados obtidos através da simulação e da modelagem analítica, algumas aplicações foram escolhidas, modeladas e executadas em suas respectivas ferramentas (previamente citadas neste documento).
Antes de apresentar as aplicações, algumas definições serão realizadas, objetivando formalizar e unificar o entendimento do processo realizado.
Conforme descrito anteriormente, um modelo SAN necessita de Estados, Transições, Eventos e Taxas.
Entretanto, nem todos estes parâmetros estão relacionados diretamente com a aplicação.
Alguns de eles estão ligados a variáveis provenientes do ambiente de execução (podendo também ser chamado de middleware, por ser um mediador entre a aplicação e a infra-estrutura).
Esta seção tem por objetivo deixar clara a diferença entre os parâmetros que vêm da aplicação e os parâmetros oriundos do middleware, relacionando- os com suas respectivas funções nos modelos SAN que serão construídos.
O primeiro nível a ser discutido trata- se do nível de aplicação.
Quando o usuário depara- se com uma situação em a qual necessita modelar determinada aplicação, este é o primeiro nível a ser analisado.
Em ele, os principais pontos a serem observados estão relacionados ao comportamento da aplicação, que será útil para definir:
Em quais subsistemas a aplicação pode ser abstraída;
As interações entre estes subsistemas;
Quando a aplicação tem seu estado global alterado;
E qual o evento causador desta alteração de estado.
Note que, com estas observações, já é possível realizar a criação dos autômatos, a definição dos estados de cada um de eles e os eventos de transição entre os estados.
Em o outro nível (middleware) encontram- se as variáveis de ambiente.
Em a modelagem de sistemas para computação distribuída, comumente as transições entre os estados do modelo acontecem devido a a ocorrência de eventos de comunicação entre os processos ou de término de processamento.
As taxas dos eventos normalmente estão relacionadas a fatores externos à aplicação.
Estes fatores são as variáveis de ambiente, que podem ser, por exemplo, o poder de processamento dos nodos, o tempo de realização de uma determinada tarefa, o tempo de transmissão de dados entre os processos por a rede, a latência dos links, de entre outros.
Tais variáveis estão relacionadas à infra-estrutura do ambiente, e são utilizadas em conjunto para o cálculo das taxas dos eventos do modelo (podendo ser utilizadas inclusive em conjunto com variáveis da aplicação).
Com isto, tem- se uma separação clara dos aspectos que influenciam o modelo provenientes da aplicação daqueles obtidos através das características do ambiente (middleware).
Existem, ainda, os parâmetros de entrada da aplicação.
Estes parâmetros não podem ser enquadrados genericamente em nenhum dos dois níveis supracitados, pois dependendo do tipo de parâmetro que a aplicação recebe como entrada, sua consequência pode tanto refletir na alteração de algum autômato no sistema quanto na alteração de alguma (s) taxa (s) de determinado (s) evento (s).
Por exemplo, caso um parâmetro de entrada seja o número de tarefas a serem executadas, tal informação pode tanto alterar um autômato que representa uma fila de tarefas como também pode alterar a taxa de algum evento que eventualmente seja calculado em função deste número.
Em um possível caso, estas duas alterações podem ocorrer simultaneamente no mesmo modelo.
Em as execuções realizadas no SIMGRID, os parâmetros das aplicações (definidos nos arquivos XML de entrada) podem ser descritos por a quíntupla SG $ (,,,), em a qual:·
são os parâmetros da aplicação, tratando- se de um conjunto de entradas;·
é a topologia, que representa a configuração de máquinas e links na grade, modelada e a maneira como estão interligados;· (
lk) é a largura de banda de cada link lk presente na topologia;· (
lk) é a latência de cada link lk presente na topologia;· (
p) é o poder computacional de cada máquina p presente na topologia.
Os dois arquivos XML criados por o usuário são responsáveis por a definição destes parâmetros no SimGrid:
Deployment. Xml e platform.
Xml. O arquivo de deployment descreve os máquina cria o token, etc) e os valores de entrada (quando houver).
Os demais termos(, e) são descritos no arquivo platform.
Xml. A modelagem SAN das aplicações, por sua vez, pode ser definida por a tripla Sn $= (G, E, T), em a qual· G é um conjunto de grafos dirigidos, cada um de eles composto por estados e arestas (transições);·
E é o conjunto de eventos que permite as transições de estados;·
T é o conjunto de taxas e probabilidades associadas a cada evento.
Todos os termos de Sn são definidos por o usuário no arquivo de entrada do PEPS (com extensão.
San). Os termos G e E tratam- se da representação da topologia (da quíntupla SG) de acordo com as funcionalidades e a maneira por a qual a aplicação foi implementada.
O termo T é obtido através de cálculos realizados sobre os termos, e de SG, de acordo com a necessidade do modelo SAN da aplicação.
A comunicação entre os nodos denota um certo tempo, e este tempo depende da maneira por a qual os nodos estão interligados.
Para parametrizar os modelos SAN de acordo com os parâmetros do SIMGRID, então, é necessário saber como o simulador calcula estes tempos de comunicação.
Assim sendo, a fórmula da Equação 4.1 apresenta o cálculo do tempo de comunicação realizado por o SIMGRID:
TempoComunicacão $ + (TamC/ LBE) onde é a latência, TamC é o tamanho (em bytes) da tarefa e LBE é a Largura de Banda Efetiva.
A fórmula da LBE é ilustrada na Equação 4.2: LBE $= min(, (W/ 2) onde W é a janela de congestionamento do protocolo TCP.
Ou seja, LBE e o mínimo entre implementação atual do SIMGRID este valor é fixado em 20000 bytes.
Assim sendo, obtêm- se a LBE através da seguinte fórmula:
LBE $= min) Perceba que, agora, a combinação dos termos da quíntupla permitem o cálculo do tempo de comunicação entre dois nodos.
Em alguns casos pode ser necessário conhecer o tempo de processamento dos nodos.
Em estes casos, utiliza- se a fórmula:
TempoProcessamento $= TCT/ O parâmetro é conhecido e o Tamanho Computacional da Tarefa (TCT) (em flops/ s) deve ser definido por o usuário.
Para realizar experimentações sobre o mapeamento de parâmetros e realizar comparações e análises sobre a Simulação e a Modelagem Analítica, algumas aplicações foram escolhidas e modeladas nas duas abordagens.
Em esta seção, três destas aplicações são descritas, detalhando seu funcionamento e a maneira de obtenção dos parâmetros.
A primeira aplicação apresentada trata- se da aplicação Token Ring.
Este tipo de aplicação é bastante utilizado em situações em as quais necessita- se garantir acesso único a certos recursos disponíveis (por este fato, também é conhecida como Exclusão Mútua).
A idéia básica é de que os recursos ditos de acesso exclusivo só podem ser acessados por o nodo que obtiver permissão para tanto.
Esta permissão trata- se do token, que nada mais é do que uma mensagem que avisa o nodo que ele pode acessar a região crítica.
Quando o nodo termina seu acesso, repassa o token para a próxima máquina da topologia, formando uma espécie de anel.
O funcionamento da aplicação é simples:
Um nodo da grade (topologia) inicia a execução e cria o token.
Este nodo repassa o token para seu sucessor, e assim sucessivamente, até que o token chegue novamente ao primeiro nodo da topologia.
O critério de parada da aplicação é definido por o usuário, e é o número de voltas que o token realiza na topologia inteira.
Conforme dito anteriormente, os parâmetros do simulador são definidos por a quíntupla SG.
Logo, têm- se que para a aplicação Token Ring:·:
O parâmetro que o usuário deve informar é unicamente o critério de parada, ou seja, quantas passadas o token deve realizar por toda a topologia.·:
A topologia da grade é ilustrada na Figura 6, e é composta por um determinado número de nodos interligados um a um por um link unidirecional, ou seja, o Nodo 1 comunica- se através do Link 2 com o Nodo 2, mas o contrário não é verdade.
Um exemplo dos arquivos de platform e deployment para esta aplicação são apresentados nas Figuras 7 e 8.
A Figura 9 mostra o modelo SAN da aplicação Token Ring.
O grafo dirigido representa o termo G da tripla Sn, e os eventos e suas respectivas taxas completam a definição de Sn.
A aplicação foi modelada com 3 diferentes tipos de autômatos.
O primeiro de eles trata- se do autômato NodoInicial, que possui os estados Init e Wait.
Este autômato é aquele nodo que criará o token.
O evento sincronizante s1 representa o envio do token para seu sucessor, alterando seu estado para o estado Wait, que representa que o nodo está aguardando o seu predecessor (o último nodo da topologia) lhe devolver o token.
Quando isto acontece, o autômato volta para o estado Init através do evento sincronizante sn, concretizando uma volta realizada.
O critério de parada é controlado por o autômato Loops, que a cada volta executada por o token incrementa seu estado, até que este autômato alcance o estado M (M $= número de voltas a serem realizadas).
O terceiro tipo de autômato modela os nodos intermediários da topologia (autômato Nodo).
Eventos s representam a chegada do token e os eventos sn representam o envio do token para o seu sucessor.
Para continuar a modelagem, existe ainda a definição dos estados inicial e final.
O estado inicial é quando todos os autômatos encontram- se no estado Init e o autômato Loops no estado está em Init e os demais autômatos encontram- se em Wait.
Isto pode ser descrito como segue (onde N é o número de nodos intermediários):
A seguir, serão apresentadas as maneiras como as taxas do modelo SAN foram calculadas através do mapeamento das informações obtidas através do SimGrid.
Como o tamanho da mensagem é 1 (pois trata- se apenas de um byte indicando o token), têm- se que TempoComunicacao $ +) e os eventos s são calculados com a utilização desta fórmula.
O evento s1 também, porém, este evento possui uma taxa funcional que depende do autômato Loops, ou seja, o evento s1 só ocorre se o critério de parada (autômato Loops estar no estado M) ainda não foi atingido.
5.2 Estudo de Caso 2: Exclusão Mútua Com Coordenador Centralizado Esta aplicação representa um sistema em o qual existe um recurso compartilhado e alguns clientes querendo acessar- lo simultaneamente.
Trata- se de um recurso crítico, logo, os acessos a ele devem ser realizados de maneira exclusiva.
Para realizar o controle desta região crítica, garantindo o acesso exclusivo ao recurso, existe um processo que é o processo coordenador.
Todos os clientes que desejam acessar o recurso devem, primeiramente, enviar uma requisição para o coordenador, que verificará se o acesso é possível ou não.
Caso o acesso seja possível, o cliente é liberado para utilizar o recurso.
Caso contrário, o coordenador insere o cliente numa fila de espera, até que o recurso esteja liberado novamente, assim garantindo o acesso exclusivo.
Para esta aplicação, o critério de parada é o número de requisições realizadas por cliente.
Através da utilização da quíntupla SG, os parâmetros da aplicação EMCC são dados por:·:
O parâmetro que o usuário deve informar é unicamente o critério de parada, ou seja, quantas requisições os clientes desejam realizar ao recurso exclusivo.·:
A topologia da grade é ilustrada na Figura 10, e é composta por um conjunto de processos clientes, que se encontram interconectados com o coordenador através de um link bi-direcional.
Ainda relacionado aos parâmetros e a modelagem no SimGrid, as Figuras 11 a 12 exemplificam os arquivos de configuração deployment.
Xml e platform.
Xml para a aplicação Exclusão Mútua com Coordenador Centralizado.
Para a aplicação Exclusão Mútua com Coordenador Centralizado, o modelo SAN criado possui 4 autômatos:
Coordenador, Cliente, Recurso e Requisições.
O referido modelo SAN pode ser visualizado na Figura 13.
O primeiro autômato (Coordenador) representa exatamente o coordenador do sistema, que permite ou não os acessos à seção crítica.
Este autômato possui 2 estados, W e V. Estar no estado W representa que o Coordenador está esperando alguma requisição de um Cliente, enquanto estar no estado V significa que esta entidade está verificando uma requisição enviada, se esta deve ser encaminhada para a fila ou poderá ter sua liberação para utilização do recurso.
Em o autômato Cliente, o estado I representa que ele ainda não foi inicializado.
De esta maneira, quando o evento sincronizante up ocorrer, os clientes passarão para o estado S, que representa um estado em que o Cliente encontra- se ocioso.
A partir deste estado, o Cliente pode realizar uma requisição para o coordenador, que é acionada através do evento sincronizante req.
Como existem n eventos req (onde n é o número de Clientes), somente um Cliente poderá ter sua requisição verificada por vez.
Caso a requisição seja aceita por o Coordenador, ocorrerá então o evento u, que representa a liberação do Coordenador para aquele Cliente.
Este Cliente, então, terá seu estado alterado para Usa e, ao término da utilização, ocorre o evento l, que libera o recurso do Cliente que estava utilizando.
Caso contrário (Coordenador não libera utilização), ao recurso), são relacionados com o estado do próximo autômato, o autômato Recurso.
Em o autômato Recurso, são 2 os estados possíveis:
A (alocado) ou L (liberado).
Quando um evento de acesso ao recurso ocorre (u ou c), o recurso passa automaticamente para o estado A. deste estado, somente poderá- se- mudar para o estado L quando ocorrer o evento de liberação da seção crítica, ou seja, l. Por fim, o autômato Requisições trata- se de uma fila de estados, variando de 0 até M, onde M é o número de clientes multiplicado por o número de requisições que cada Cliente realiza (parâmetro de entrada da aplicação).
Assim, este autômato é responsável por controlar o critério de parada, que é alcançado quando o número de requisições for atendido.
A cada nova requisição (evento req), o autômato Requisições aumenta em 1 o seu estado.
A definição dos estados inicial e final é dada por a seguinte estrutura:
Para o cálculo das taxas, a fórmula abaixo representa o tempo de comunicação entre os processos, uma vez que neste exemplo também a mensagem tem tamanho 1, por ser somente uma mensagem de controle de acesso liberado ou negado.
TempoComunicacao $ +) Como pôde ser percebido no modelo SAN anteriormente detalhado, 6 são os eventos presentes na modelagem.
A Tabela 4 apresenta estes eventos, descrevendo suas respectivas taxas.
A última aplicação trata- se de um clássico da programação paralela e distribuída.
Mestre/ Escravo é um programa em o qual um nodo centralizador (chamado Mestre) envia tarefas para os demais nodos da topologia (chamados Escravos).
O Mestre é quem controla a divisão das tarefas e a quantidade de tarefas disponíveis no buffer.
Enquanto ainda houver tarefas, o Mestre envia para os Escravos, que processarão esta tarefa e aguardarão o envio de uma nova.
A aplicação chega ao seu final quando todas as tarefas designadas por o Mestre tiverem sido processadas.
Em a definição dos parâmetros do SimGrid para a aplicação Mestre/ Escravo, temos a seguinte configuração:·:
Os parâmetros que o usuário define são 3: O número de tarefas, o tamanho computacional de cada tarefa e o tamanho de comunicação das tarefas.·:
A topologia da grade é ilustrada na Figura 14, e é composta por um conjunto de processos escravos que se conectam (num link bidirecional) com um processo Mestre.· (
lk), (lk) e (p), serão definidos especificamente para cada experimento realizado no Para a execução da aplicação Mestre/ Escravo no simulador, os arquivos de configuração deployment.
Xml e platform.
Xml são estruturados conforme mostram as Figuras 15 e 16.
Já no autômato Escravo, percebe- se a existência de 2 estados apenas:
O estado S, em o qual o Escravo aguarda um envio do Mestre, e o estado P, em o qual o Escravo recebeu uma tarefa do Mestre e está processando- a.
Quando o Mestre envia uma mensagem, o estado do Escravo que a recebe passa de S para P através do evento sincronizante t..
Quando o Escravo termina o processamento, ocorre então o evento local f, representando o final do processamento por parte de o Escravo, que torna a aguardar por mais tarefas caso existam.
Em este ponto, aparece a diferença entre os autômatos EscravoA e EscravoB.
O que acontece neste modelo, é que o número de tarefas não necessariamente será divisível por o número de Escravos.
Porém, na aplicação (conforme dito anteriormente), o Mestre não entrega uma nova tarefa para o primeiro Escravo que terminar a sua execução, mas sim para o próximo Escravo na sua ordem de envio.
Por exemplo, o envio de 5 tarefas é distribuído entre 3 Escravos na ordem Escravo 1, Escravo 2, Escravo 3.
As tarefas 4 e 5 serão enviadas para os Escravos 1 e 2 respectivamente.
Ou seja, os Escravos 1 e 2 receberam uma tarefa a mais de o que o Escravo e EscravoB, para quando a quantidade de tarefas não for igual a quantidade de Escravos para processar- las.
Podemos fazer, então, a seguinte relação para este modelo (onde T é o número de tarefas e E o número de escravos):·
caso o número de tarefas seja divisível por o número de Escravos, todos os Escravos serão modelados como autômatos do tipo EscravoB, pois conforme o modelo SAN apresenta, o índice i dos Escravos varia de (T% E) até (E-1).·
caso o número de tarefas não seja divisível por o número de Escravos, os Escravos de índice variando no conjunto serão modelados como autômatos do tipo EscravoA, enquanto os demais Tal situação ocorre porque quando o número de tarefas não for divisível exatamente por todos os Escravos, alguns de eles (os do tipo EscravoA) receberão uma tarefa a mais de o que os do tipo EscravoB.
O número de escravos que recebem mensagens a mais é dado por T% E. Talvez esta diferenciação não seja trivial, mas a diferença encontra- se na quantidade de tarefas a serem recebidas.
No caso de os Escravos do tipo EscravoA, o número de tarefas a serem recebidas é dado por MRA $= T/ E, enquanto para os escravos do tipo EscravoB este valor é dado por MRA -- 1.
Definidas a distribuição dos autômatos e a quantidade de tarefas entre eles, basta apenas realizar a separação das tarefas.
Conforme pode ser observado no modelo SAN da Figura 17, tem- se que:·
caso o número de tarefas seja divísivel exatamente entre os Escravos, não utiliza- se o autômato do tipo EscravoA, e todos os eventos que farão parte do autômato EscravoB são dados (individualmente para cada EscravoB (i)) por:·
caso o número de tarefas não seja divisível exatamente por o número de Escravos, os eventos são dados por:
Para o modelo SAN da aplicação Mestre/ Escravo, dois cálculos são necessários:
O tempo de comunicação entre os nodos e o tempo de processamento dos escravos.
Os referidos cálculos, que serão utilizados na sequência para o cálculo das taxas dos eventos, são realizados utilizando as fórmulas encontradas nas Equações 4.1 e 4.4, relativas ao tempo de comunicação e de processamento, respectivamente.
A Tabela 5 apresenta os eventos para o modelo Mestre/ Escravo e suas taxas.
Conforme descrito anteriormente, algumas aplicações foram utilizadas como exemplos neste estudo, objetivando a realização de análises e comparações entre uma abordagem utilizando Simulação e outra utilizando Modelagem Analítica.
Em o Capítulo 5 tais aplicações foram descritas em detalhes, e neste capítulo serão abordados alguns experimentos realizados sobre elas.
Devido a o fato de cada aplicação possuir seus próprios parâmetros e características, as configurações a serem testadas são específicas para cada caso.
Assim sendo, com o intuito de avaliar os pontos mais relevantes em cada situação, as aplicações foram submetidas a diferentes variações, que serão apresentadas no decorrer de esta seção.
Para cada uma das aplicações, os testes que seguem estão assim organizados:
Primeiramente, são descritas as variações realizadas na aplicação;
Em seguida, no que tais variações afetam as modelagens (SimGrid e SAN) apresentadas anteriormente;
E, finalmente, os resultados das execuções no SimGrid e do modelo SAN são apresentados.
Dois testes principais são apresentados para a aplicação Token Ring.
O primeiro de eles tratase da variação do número de voltas que o token realiza na topologia.
O segundo ambiente de teste refere- se a variação da latência do link que interconecta os nodos.
Para estes dois ambientes, o número de nodos da topologia foi variado entre 2 e 10.
Em este caso de teste, a variação ocorre no número de voltas que o token realiza no anel da topologia (ou seja, o número de passagens do token por cada um dos nós).
Estas variações foram de 2, 4, 6, 8 e 10 voltas.
A Tabela 6 apresenta a configuração do ambiente (presente nos arquivos de configuração do SimGrid) para este caso de teste, com os demais parâmetros da aplicação (que não foram alterados).
Com isto, conforme as equações apresentadas na Seção 4.3, os parâmetros do modelo SAN da aplicação Token Ring sob estas configurações são apresentados na Tabela 7.
Pode- se perceber no gráfico que o comportamento das duas curvas é similar, e mesmo quando são adicionados novos nodos na topologia ambas as curvas tendem a um crescimento contínuo.
Comparando- se os tempos, nota- se que a diferença entre aqueles obtidos na execução no SimGrid e os obtidos na execução do modelo SAN é de aproximadamente 1,6 segundos.
Para dar continuidade na variação das voltas do token na topologia, o gráfico da Figura 19 apresenta as curvas para a execução com 4 voltas, enquanto a Tabela 9 apresenta os tempos relativos a esta execução.
Novamente, percebe- se a similaridade das curvas, com a mesma característica da execução anterior, em a qual acrescentar nodos novos dá continuidade ao aumento do tempo.
Para perceber este crescimento e esta continuidade nos valores de tempo, ainda foram executados testes para 6, 8 e 10 voltas.
Os tempos obtidos com estas execuções pode ser verificado na Tabela 10.
Os resultados apresentados confirmam a tendência de crescimento e mantêm a diferença dos tempos entre aproximadamente 1,6 e 1,8 segundos, não importando quantos nodos ou quantas voltas o token realizará na topologia.
Em este ambiente, a configuração dos parâmetros no SimGrid é a mesma apresentada anteriormente (Tabela 6), acrescentando- se o número de voltas do token na topologia, que neste exemplo foi fixado em 10.
Além de isto, a latência do link da topologia foi alterada, variando- a em 1, 1,2 e 1,5 segundos.
Os valores para a execução com latência igual a 1 para 10 voltas já foi apresentado anteriormente, podendo ser observado na Tabela 10.
Entretanto, a Tabela 12 mostra que para as latências com valores de 1,2 e 1,5 segundos, os tempos de execução da simulação e da modelagem analítica foram muito similares.
Em esta tabela, observa- se que em todos os casos a diferença entre os tempos de execução foi menor do que 1 segundo.
Além de isto, o comportamento crescente de ambas as abordagens continua sendo um fator perceptível e interessante, pois ilustra a compatibilidade da modelagem SAN criado com a execução no SimGrid.
O número de voltas da aplicação Token Ring e a latência do link na topologia são os parâmetros mais importantes desta aplicação.
Isto ocorre por tratar- se de uma aplicação que não possui processamento sobre dados (pois o token é apenas uma mensagem que é recebida e repassada).
Sendo assim, a variação na potência dos nodos, por exemplo, não afetaria o modelo, pois não alteraria nenhuma taxa.
As variações de tempo observadas nas execuções foram pequenas, mostrando que o modelo SAN criado conseguiu apresentar um bom resultado, assemelhando- se muito àquele obtido no simulador.
Além disso, o comportamento percebido em ambas as abordagens permite ao usuário uma idéia do comportamento da aplicação de acordo com as variações que serão realizadas.
Acredita- se que as diferenças encontradas (apesar de mínimas) decorrem devido a diferente natureza das própria maneiras de calcular o tempo de execução, uma vez que na modelagem SAN são realizados cálculos e poderações probabilísticas, ocasionando erros de arredondamento.
Para esta aplicação, foram executados testes que variam o número de clientes existentes na topologia, o número de requisições de acesso à seção crítica que estes clientes desejam realizar e a latência do link do sistema.
A seguir, apresentam- se os resultados obtidos para os experimentos, seguidos por algumas considerações.
A Tabela 13 apresenta os valores para os parâmetros fixos deste experimento, constantes nos arquivos de configuração do SimGrid.
Os parâmetros variáveis foram o número de clientes e o número de requisições.
Já as taxas do modelo SAN referente a esta aplicação podem ser calculadas com as fórmulas descritas anteriormente, e resultam nos valores encontrados na Tabela 14.
Figura 20 ­ Resultados para a aplicação Exclusão Mútua com 1 cliente.
A primeira execução realizada foi com 1 cliente, variando o número de requisições de 1 até 5.
O gráfico da Figura 20 ilustra o comportamento das duas abordagens.
Pode- se perceber no gráfico que o comportamento é muito semelhante, com valores tão próximos que as curvas se sobrepõem.
Isto se deve ao fato de que com 1 cliente apenas não existe disputa por a seção crítica.
Toda vez que o cliente deseja o acesso exclusivo, o recurso está disponível, e ele nunca vai para a fila.
O fato do cliente nunca ir para a fila está relacionado à taxa funcional do evento f..
Esta taxa diz que um cliente aguarda na fila quando ele requisita o recurso e este encontra- se alocado, situação que nunca ocorre com apenas 1 cliente no sistema.
A semelhança dos valores pode ser comprovada através da Tabela 15, que apresenta os valores referentes ao gráfico supracitado.
Esta situação modifica- se quando mais clientes são adicionados.
O gráfico da Figura 21 apresenta os resultados para a execução da aplicação com 2 clientes requisitando a seção crítica.
Apesar de afastadas, as diferenças entre os tempos com 3 clientes ainda não são demasiadamente grandes.
Entretanto, por o comportamento observado na curva, pode- se acreditar que a diferença aumentará de acordo com o aumento do número de requisições dos clientes.
A Tabela 17 apresenta os tempos de execução relativos à este gráfico, juntamente com os tempos de execução para uma topologia com 4 e 5 clientes.
Isto quer dizer que além de a diferença ocorrida devido a a disputa da seção crítica entre os processos, há uma diferença associada ao número de requisições.
Estas diferenças podem estar associadas ao fato de que, no modelo SAN criado, não importa qual dos clientes vai requisitar novamente a seção crítica.
O que importa neste modelo, é que a seção crítica vai ser requisitada N vezes, o que aumenta a probabilidade de clientes que já utilizaram o recurso por &quot;requisições «vezes utilizem novamente, fazendo com que os outros clientes não requisitem, ou, requisitem poucas vezes.
Em o SimGrid, por sua vez, a execução se dá na forma de que cada cliente utilizará a seção crítica &quot;requisições «vezes.
O que importa aqui, então, é que os M clientes utilizem a seção crítica &quot;requisições «vezes.
Entretanto, pode- se ressaltar um fato interessante:
Tanto para uma abordagem quanto para outra, os tempos de execução para mais clientes podem ser encontrados empiricamente.
Para predizer o tempo de execução da aplicação para 10 requisições, por exemplo, pode- se utilizar os valores de antes encontrados.
Por exemplo, nota- se através das execuções realizadas um crescimento constante dos valores nas execuções do SimGrid.
De acordo com a Tabela 16, com 2 clientes e 1 requisição, o tempo é de 7,5 segundos.
Para 2 requisições, o valor é de 13,5 segundos, ou seja, uma diferença de 6 segundos para o valor encontrado com 1 requisição.
A o verificar os demais valores, percebe- se que a diferença entre os tempos das requisições é sempre de 6 segundos neste caso.
Empiricamente, pode- se calcular que com 10 requisições, 2 clientes levariam 61,5 segundos.
Com os resultados do modelo SAN acontece a mesma situação, porém, não com valores exatos e constantes, por tratar- se de um método matemático, que pode, por exemplo, apresentar erros de arredondamento que se acumulam.
Porém, as diferenças entre os tempos das requisições variam aproximadamente em 6,3 segundos.
Desta forma, pode- se prever que para 10 requisições, 2 clientes utilizariam cerca de 63 segundos.
O próximo experimento realizado teve como variável a latência do link.
Em estes experimentos, o número de clientes foi fixado em 2, e os valores da latência variaram entre 1,5, 3,5 e 5 segundos.
Os demais parâmetros continuam conforme apresentados anteriormente na Tabela Com as alterações na latência, as taxas do modelo SAN tiveram seus valores re-calculados, resultando nos valores ilustrados na Tabela 18.
Os resultados das execuções utilizando a latência de 1,5 segundos com 2 clientes foi apresentada anteriormente, tratando- se do gráfico da Figura 21.
Em este gráfico percebe- se que as curvas cruzam- se em determinado ponto (3 requisições), fazendo com que o tempo na modelagem SAN passe, a partir deste ponto, a ser maior do que o tempo do SimGrid.
Em a Figura 23 encontram- se as curvas referentes às execuções realizadas com latência igual a 3,5 segundos.
O fenômeno do cruzamento continua acontecendo, entretanto as curvas se cruzam somente a partir de 5 requisições, conforme pode ser observado na Tabela 19, que contém os tempos de execução.
Ainda na Tabela 19, é possível observar que o comportamento das curvas continua o mesmo, porém, quanto maior o valor da latência, mais longe as curvas se cruzam (em relação a o número de requisições).
Mesmo assim, os tempos de execução obtidos são similares.
O modelo SAN criado para a aplicação Exclusão Mútua com Coordenador Centralizado apresentou resultados interessantes quando executado para poucos clientes.
À medida que mais clientes são adicionados à topologia, os valores da sua execução distanciam- se dos valores obtidos através da simulação no SimGrid.
Este modelo, no entanto, mostrou- se interessante para ilustrar duas maneiras diferentes de modelagem de uma mesma aplicação.
Enquanto a implementação no SimGrid foca no fato de que cada cliente deve realizar suas requisições, o modelo SAN criado foca na quantidade de requisições atendidas, não importando quais os clientes solicitaram a seção crítica.
O último caso de teste foi executado com a finalidade de analisar alguns aspectos relevantes tais como o tamanho das tarefas e o poder computacional dos nodos.
Em as outras aplicações estes testes não eram necessários, pois os nodos não realizavam nenhum processamento sobre as mensagens.
Além destes aspectos, ainda são variados para este exemplo o número de tarefas a seram realizados e a quantidade de escravos presentes na topologia.
Primeiramente, este experimento visa variar a quantidade de tarefas executada por os escravos.
Para tanto, variou- se entre 5, 10 e 20 este número, e para cada um destes casos realizaramse execuções de 2 até 9 escravos.
Os demais parâmetros para esta aplicação foram fixados conforme apresenta a Tabela 20.
Com estas configurações, o mapeamento dos parâmetros do modelo SAN para esta situação resulta nos valores constantes na Tabela 21.
Cabe lembrar que a variação do número de tarefas altera a quantidade de estados do autômato Mestre.
A primeira execução realizada pode ser observada no gráfico da Figura 24.
Trata- se da execução com 20 tarefas.
Através da análise do gráfico, percebe- se claramente que o comportamento da modelagem SAN e da simulação com o SimGrid foram semelhantes.
À primeira vista, pode parecer estranho o ponto da curva do SIMGRID com 6 escravos.
Porém, quando imagina- se o que deve acontecer na aplicação, percebe- se que tal fenômeno tem um bom embasamento.
Em esta aplicação são enviadas 20 tarefas de mesmo tamanho.
Pode- se dizer que, teoricamente:·
com 2 escravos, ocorrerão 10 envios de 2 tarefas;·
com 3 escravos, ocorrerão 6 envios de 3 tarefas e mais um envio das outras 2 (totalizando 7 envios);·
com 4 escravos, ocorrerão 5 envios de 4 tarefas;·
com 5 escravos, ocorrerão 4 envios de 5 tarefas;·
com 6 escravos, ocorrerão 3 envios de 6 tarefas e mais um envio de 2 tarefas (totalizando 4 envios);·
com 7 escravos, ocorrerão 2 envios de 7 tarefas e mais 1 envio de 6 tarefas (totalizando 3) Assim, como o número de envios de tarefas quando a aplicação é executada com 5 ou com 6 escravos é o mesmo, a cada envio é realizada uma &quot;bateria de execuções».
Se com 5 e 6 escravos ocorrem o mesmo número de envios, logo, ocorrerá o mesmo número de &quot;baterias de execução», resultando num tempo de execução similar.
Para validar tal fato, executou- se a aplicação com 20 tarefas e 20 escravos.
Desta forma somente 1 envio seria realizado, resultando em apenas uma &quot;bateria de execuções».
Logo, o tempo total deve ser o tempo de enviar as 20 tarefas mais o tempo de processar uma única tarefa, já que os 20 nodos estarão executando totalmente em paralelo cada um uma bateria.
Assim (teoricamente e desconsiderando tempos de inicialização e de finalização):+
5.09 $= 7.09 Executando o programa Mestre/ Escravo com 20 escravos no SIMGRID, o tempo de execução encontrado foi 7.2171 segundos.
Infelizmente, o modelo SAN não apresentou- se viável para a execução, pois teríamos o montante de 20971520 estados.
Outros testes foram realizados com os demais tamanhos de tarefa para verificar sua influência nos resultados.
A Tabela 22 apresenta os valores para os tempos de execução dos experimentos com 5, 10 e 20 tarefas.
Observando os valores encontrados, nota- se que o comportamento das duas abordagens continua similar em todos os casos.
Primeiramente, quando de a execução com apenas 1 escravo, a diferença entre as execuções não é muito grande.
Conforme o número de processos aumenta, a diferença dos tempos de execução também aumenta, mas ainda com valores próximos.
Outra variável que possivelmente afete os resultados das execuções trata- se do Tamanho Computacional das tarefas.
Em o experimento que segue, os valores para estes tamanhos computacionais foram variados entre 100.000.000, 250.000.000 e 500.000.000 flops.
Os demais valores foram fixados conforme a Tabela 20 apresentada anteriormente, e o número de escravos variou entre 2 e 9.
A alteração no tamanho das tarefas resultou em tempos de execução diferentes, conforme teoricamente imagina- se.
A Tabela 24 ilustra esta alteração dos tempos de execução para os três tamanhos computacionais executados sob as configurações supracitadas.
Analisando os valores encontrados, percebe- se que as diferenças de tempo nas execuções foram bem próximas do que teoricamente deveria acontecer.
Em outras palavras, se o tamanho computacional de 250 megaflops trata- se da metade de 500 megaflops, teoricamente, o tempo para a execução daquele deveria ser 50% menor do que o deste (teoricamente, pois sabe- se que existem variáveis que alteram esta teoria, tais como congestionamentos, perdas de pacotes, variáveis de controle, etc).
A o verificar os valores obtidos e realizar tal cálculo, notará- se- que esta relação está presente, não em valores exatos mas em valores aproximados.
Por exemplo, com 1 escravo e tamanho de tarefa de 500 megaflops, obteve- se com o modelo SAN o tempo de 51.37 segundos.
Se 250 megaflops representa 50% de 500 megaflops, então o tempo teórico é de 51,37* 0,5 $= 25,685 segundos, enquanto o obtido foi 25.992 segundos.
O mesmo vale para 100 megaflops.
Se 100 megaflops trata- se de 20% de 500 megaflops, logo (teoricamente) teríamos 51,37* 0,2 $= 10,27 segundos, e o tempo obtido foi de 10,76 segundos aproximadamente.
O mesmo fato também pode ser observado nos tempos do SimGrid.
A última variação desta aplicação diz respeito ao poder computacional dos nodos que realizarão a função de escravo.
Em os exemplos anteriores, este poder computacional possuía o valor de 98.095.000 flops/ s, e nestes novos experimentos, oa valores foram alterados para que os escravos executem com 50.000.000 e 200.000.000 flops/ s de poder computacional.
As demais variáveis permaneceram conforme a Tabela 20 apresentada anteriormente, e as execuções continuam sendo realizadas para número de escravos variando entre 2 e 9.
Com o novo poder computacional dos escravos, as taxas do modelo SAN foram novamente alteradas, e podem ser observadas na Tabela 25.
Os valores obtidos para as execuções com 50.000.000 e 200.000.000 flops/ s podem ser vistas na Tabela 26.
Através da análise destes tempos de execução, percebe- se que o poder computacional dos escravos altera bastante os valores, fazendo com que ambientes com nodos com maior poder de processamento de fato tenham seus desempenhos melhores do que ambientes com pouco poder de processamento.
Em os valores obtidos, nota- se que o comportamento destes continua semelhante, apresentando as mesmas características entre as duas curvas, conforme foi descrito anteriormente no primeiro e no segundo experimento.
Através da utilização da aplicação Mestre/ Escravo, análises de comportamento das curvas, variação do número de tarefas e influência do tamanho computacional da tarefa e do poder de processamento dos escravos puderam ser realizadas.
Um aspecto interessante trata- se do comportamento da curva, que não importando as variações que sejam realizadas, continua com a mesma similaridade.
Os experimentos realizados ressaltou alguns aspectos importantes da aplicação, no que se refere a custo-benefício de aquisição e/ ou utilização de diversos nodos.
Utilizando tanto a modelagem com SAN como a simulação com o SimGrid, obterá- se- uma boa noção do desempenho para usuários que possuem necessidades parecidas com as apresentadas por a aplicação Mestre/ Escravo.
Este trabalho comparou duas diferentes abordagens de avaliação de desempenho para aplicações de plataformas distribuídas:
A Modelagem Analítica e a Simulação.
Estas formas foram escolhidas por possibilitarem ao desenvolvedor (ou ao usuário que necessite avaliar o desempenho de seu sistema) a obtenção de resultados destes desempenhos antes mesmo da implementação do sistema, evitando assim gastos com re-construção de código, perda de tempo ao implementar algo que não apresentará um desempenho aceitável, auxiliando na procura de gargalos, etc..
Entretanto, uma das partes mais importantes na hora de criar um modelo de um sistema computacional trata- se da fase de coleta de parâmetros.
De acordo com os parâmetros que forem obtidos e inseridos no modelo, os resultados sofrem grandes alterações, podendo iclusive invalidar o modelo.
Em este contexto, neste estudo foi realizada uma comparação entre execuções do simulador de plataformas distribuídas SimGrid e a ferramenta de Modelagem Analítica SAN.
Os parâmetros dos modelos SAN, então, puderam ser mapeados através de alguns cálculos e informações obtidas através dos arquivos de configuração do SimGrid.
De esta maneira, a modelagem SAN realizada possuía parâmetros que estavam de acordo com as execuções do simulador, podendo assim serem realizados testes e análises comparativas.
Para facilitar o mapeamento dos parâmetros, algumas definições foram realizadas, incluindo algumas considerações sobre parâmetros dependentes do ambiente e parâmetros dependentes da aplicação.
Para realizar alguns testes experimentais, foram descritas três aplicações, incluindo a modelagem no SimGrid, a modelagem SAN detalhada e a maneira por a qual os parâmetros foram calculados.
Em a condução dos experimentos, percebeu- se que o mapeamento dos parâmetros de maneira geral foi bem sucedido.
Em o primeiro exemplo, o modelo SAN da aplicação Token Ring apresentou diferenças muito pequenas, mesmo quando executado com diferentes configurações de ambiente e variáveis.
O segundo exemplo fazia referência a uma aplicação chamada Exclusão Mútua com Coordenador Centralizado.
Em os experimentos desta aplicação, o modelo SAN conseguiu captar o mesmo comportamento apresentado por o simulador, apesar de ter havido um aumento na diferença dos tempos quando mais requisições eram adicionadas.
No entanto, através dos resultados percebeu- se que as abordagens do modelo SAN e da aplicação no SimGrid eram um pouco diferentes, explicando a diferença nos tempos encontrados.
Por fim, uma aplicação do tipo Mestre/ Escravo foi executada.
Em esta aplicação, outros fatores puderam ser testados, como variações no poder de processamento dos nodos e no tamanho das tarefas.
Os resultados foram interessantes, mostrando que o modelo SAN e o SimGrid apresentaram o mesmo comportamento, com pouca variação no tempo de execução.
Através do desenvolvimento deste trabalho, ficaram claras algumas diferenças importantes entre as duas abordagens utilizadas.
Alguns exemplos podem ser citados, tais como a maior dificuldade de implementação e modelagem utilizando a abordagem de simulação.
Isto se deve ao fato de que com a simulação necessita- se de um conhecimento concreto sobre aspectos específicos de programação.
Muitas vezes, entretanto, o usuário que deseja avaliar o desempenho de algum sistema não é um desenvolvedor e não possui conhecimentos técnicos para tanto.
Por outro lado, com a modelagem analítica, percebeu- se que há uma abstração maior, não necessitanto tais conhecimentos específicos, modelando apenas com os parâmetros obtidos.
Outra diferença que pôde ser observada durante a realização do trabalho, foi que o código utilizado para a simulação muitas vezes assemelha- se muito ao código do sistema em si, tornando a etapa de avaliação mais custosa quando não se possui o conhecimento necessário, fazendo com que a Modelagem Analítica fique em vantagem neste aspecto também.
Porém, com simulações, os resultados são obtidos de maneira muito rápida, não necessitando a realização de cálculos e diversas execuções do modelo.
Basta realizar alterações nos arquivos de configuração e executar novamente.
Outra desvantagem percebida na Modelagem Analítica quando comparada à simulação, é que a explosão do espaço de estados ocorre rapidamente de acordo com o tamanho do modelo analítico criado, enquanto no simulador isto não acontece tão rapidamente.
Apesar de que o mapeamento dos parâmetros, as modelagens criadas e os testes realizados terem sido satisfatórios, acredita- se que para uma real validação destas comparações, análises estatísticas devem ser realizadas, assim como as execuções destas aplicações em ambientes reais.
De esta maneira, validaria- se- por completo o estudo, trazendo comprações e aspectos não apresentados neste trabalho.
A utilização desta abordagem com a utilização de aplicações reais trata- se de um trabalho futuro a ser realizado.
Além de isto, a comparação entre simulação e modelagem analítica apresentada neste trabalho com a utilização de um simulador para plataformas distribuídas abre novas idéias para uma modalagem de mais baixo nível e mais específica futuramente, não focando somente na aplicação.
Esta nova leitura seria utilizando especificamente ambientes de grades computacionais, modelando a parte existente abaixo de a aplicação, que é responsável por gerenciar toda a execução de tarefas neste tipo de ambiente.
