A manutenção e evolução do software demanda um custo muito alto das organizações.
Um dos motivos para este alto custo é a falta de documentação.
Os requisitos representam um dos principais meios de documentação do software.
Geralmente os requisitos não são atualizados depois do término do desenvolvimento do software, ou seja, não são atualizados durante a fase de manutenção.
O objetivo desta pesquisa é propor uma solução para o problema de manter os requisitos de aplicações de software atualizados e consistentes ao longo de processos de manutenção.
A solução consiste num modelo de gerência de requisitos que suporta a atualização e consistência dos requisitos ao longo de processo de manutenção.
Este modelo é constituído por um Modelo Conceitual, representando os conceitos envolvidos no problema e como eles devem estar relacionados para que seja possível alcançar o objetivo, regras de consistência, e um mecanismo de versionamento dos requisitos.
Os resultados são demonstrados através de exemplos, ilustrando os diversos cenários possíveis, utilizando um protótipo desenvolvido a partir de o modelo proposto.
A principal contribuição deste trabalho é um modelo que auxilie a manter os requisitos de software atualizados e consistentes ao longo de processos de manutenção, além de auxiliar na análise de impacto das requisições de mudança.
Palavras-chave: Engenharia de Requisitos, Gerência de Requisitos, Requisitos, Casos de Uso, Manutenção de Software.
A Engenharia de Requisitos (Er), uma subárea da Engenharia de Software, estuda o processo de definição dos requisitos que o software deverá atender.
O processo de definição de requisitos é uma interface entre os desejos e necessidades dos clientes e a posterior implementação desses requisitos em forma de software.
A engenharia de requisitos é um processo que engloba todas as atividades que contribuem para a produção de documentos de requisitos e sua manutenção ao longo de o tempo.
A gerência de requisitos em processos de manutenção é uma atividade que acompanha a evolução dos requisitos ao longo de o ciclo de vida de uma aplicação de software ou produto.
Os requisitos da aplicação devem ser gerenciados desde seu nascimento e enquanto estiverem presentes na aplicação.
Freqüentemente estas aplicações passam por processos de manutenção que alteram seus requisitos.
Estas alterações devem ser devidamente registradas na documentação da aplicação para possibilitar a rastreabilidade e garantir que os requisitos atuais da aplicação estejam atualizados, consistentes e disponíveis.
Organizações de desenvolvimento de software estão se dando conta que seu principal artefato é sua própria experiência e o conhecimento ganho a partir de ela.
Elas estão dando passos em direção a estabelecer bases de conhecimento corporativo que tornam este artefato tangível.
Os requisitos são pontos chave para esta base de conhecimento.
Portanto existe a necessidade de um movimento do foco de gerência de requisitos ao longo de o ciclo de vida de um projeto para o gerenciamento dos requisitos como uma contribuição contínua para o conhecimento geral da organização.
Chama a atenção para a importância da disseminação do conhecimento das aplicações no processo de manutenção de software.
A gerência de requisitos em processos de manutenção contínua é uma atividade que acompanha a evolução dos requisitos ao longo de o ciclo de vida de uma aplicação ou produto.
A fim de compreender as dificuldades relacionadas com a gerência dos requisitos em processos de manutenção, realizou- se um estudo de caso exploratório, detalhado na seção software que pertence a uma empresa multinacional.
Esta pesquisa visa encontrar uma solução para a deficiência identificada na literatura, e ilustrada no caso particular da empresa, no suporte à manutenção dos requisitos de aplicações consistentes e atualizados ao longo de o Ciclo de Vida da Aplicação.
Em, a autora realizou um estudo comparativo das ferramentas de gerência de requisitos existentes no mercado com o objetivo de analisar como as mesmas suportam o gerenciamento dos requisitos ao longo de o ciclo de vida das aplicações.
Segue uma breve descrição dos resultados deste estudo.
Primeiramente gerou- se uma lista dos requisitos que uma ferramenta de gerência de requisitos deve atender para resolver o problema foco deste trabalho.
Considerando estes requisitos, fez- se uma análise de três ferramentas do mercado:
RequisitePro, Compuware Optimal Trace Enterprise e DOORS.
A conclusão do estudo mostrou que nenhuma das três ferramentas atendem os seguintes requisitos:
Gerenciamento de mudanças:
A ferramenta deve fornecer a possibilidade de manipulação de CRs (Change Requests ­ Requisições de Mudança) formais.
A ferramenta deve armazenar a informação de quais os requisitos foram afetados por a requisição de mudança e de que forma estes requisitos foram afetados (adicionados, removidos ou alterados);
Gerenciamento dos requisitos da aplicação (as ferramentas analisadas são orientadas a projeto):
Habilidade de manter requisitos de aplicação através dos projetos de manutenção;
Habilidade de ligar requisitos de aplicação com requisições de mudanças através de relações como Adicionar, Alterar, Remover;
Habilidade de atualizar os requisitos de aplicação de forma automática quando a implementação da requisição de mudança é entregue ao cliente da aplicação;
Habilidade de exportar um documento de requisitos da aplicação;
Histórico de cada requisito da aplicação:
Apresenta informação sobre qual projeto ou requisição de mudança o requisito foi criado, modificado, removido;
Quais foram os autores das modificações;
Em que data as modificações ocorreram.
A partir de esta análise, pode- se observar dois problemas críticos:
As ferramentas não estão preparadas para suportar os requisitos das aplicações ao longo de a sua evolução.
Uma vez que elas são orientadas a projeto, os requisitos existem apenas enquanto o projeto estiver ativo.
Uma vez que o projeto termine, os requisitos também deixam de existir.
Portanto, para manter os requisitos das aplicações, mesmo após o término do projeto, é necessário se efetuar uma cópia dos requisitos gerados ou atualizados por o projeto.
Este tipo de procedimento não garante a consistência e atualização dos requisitos.
É necessário que se mantenha um repositório centralizados com os requisitos da aplicação;
As ferramentas não suportam as requisições de mudanças:
É crucial que se tenha o histórico dos requisitos da aplicação desde sua origem até o atual momento.
Muitas vezes uma requisição de mudança afeta mais de um requisito.
É importante que a ferramenta ligue a requisição de mudança com os requisitos que foram afetados e informe de que forma os mesmos foram afetados.
Baseado nesta análise pode- se afirmar que as ferramentas do mercado não estão preparadas para gerenciar os requisitos de uma aplicação ao longo de sua evolução.
Este trabalho tem como principal objetivo propor uma solução para garantir a consistência dos artefatos de requisitos de aplicações.
Em a maioria das vezes o documento de requisitos de uma aplicação é concebido no início do projeto que visa desenvolver- lo e após o fim do projeto, ou mesmo durante o projeto, o documento com os requisitos é esquecido e se torna obsoleto.
Em este sentido, a questão de pesquisa deste estudo é a seguinte:
&quot;Como suportar a consistência e atualização de requisitos afetados por requisições de mudança para manutenção de software?»
Uma vez definida a questão de pesquisa, definiu- se o objetivo geral e os objetivos específicos deste trabalho, os quais são apresentados a seguir.
Propor um modelo que suporte a consistência e atualização das documentações de requisitos de aplicações.
Embasamento teórico e contextualização do problema na literatura;
Análise das dificuldades relacionadas com a gerência de requisitos de aplicações durante a fase de manutenção;
Aprofundar o estudo teórico sobre as arquiteturas das ferramentas existentes no mercado;
Especificar um modelo de arquitetura que atenda às necessidades identificadas;
Desenvolvimento de uma instância do modelo de arquitetura especificado através de um protótipo de ferramenta de gerência de requisitos;
Avaliar o uso do protótipo a partir de exemplos hipotéticos.
Este volume está organizado em sete capítulos.
O capítulo 1 corresponde a esta introdução.
Em o capítulo 2 é apresentado o referencial teórico desta pesquisa, envolvendo os principais conceitos e áreas do estudo:
Engenharia de requisitos, gerência de requisitos, casos de uso e manutenção de software.
O capítulo 3 apresenta os estudos relacionados com o tema de pesquisa deste trabalho.
Foram selecionados artigos sobre estudos em áreas relacionadas ou complementares a pesquisa aqui apresentada.
Durante este capítulo, são feitas considerações sobre estes trabalhos.
Em o capítulo 4 o problema de pesquisa é detalhado e o modelo de gerência de requisitos durante a manutenção do software é apresentado.
Em o modelo proposto é apresentado o Modelo Conceitual com a representação dos principais conceitos envolvidos no problema e como estes se relacionam de forma a auxiliar no suporte a consistência e atualização dos requisitos.
Em este capítulo também são apresentadas regras de consistência dos casos de uso e o mecanismo de versionamento dos mesmos.
O capítulo 5 descreve a avaliação do modelo proposto através do protótipo desenvolvido a partir de o modelo.
Para a demonstração dos resultados criou- se alguns exemplos hipotéticos de sistemas.
O capítulo 6 ilustra as considerações finais desta pesquisa.
São descritas as contribuições deste estudo, bem como suas limitações e trabalhos futuros.
Este capítulo descreve o referencial teórico deste trabalho apresentando os principais conceitos envolvidos com o tema da pesquisa:
Engenharia de requisitos, gerência de requisitos, casos de uso e manutenção de software.
Engenharia de Requisitos (Er) é um conjunto de atividades voltadas a identificar e comunicar os objetivos de um sistema de software, e o contexto em o qual o mesmo é usado.
Portanto, Er atua como uma ponte entre as necessidades de usuários, clientes e outras partes do mundo real afetadas por o software e as capacidades e oportunidades disponibilizadas por as tecnologias de software.
Thayer e Dorfman definem engenharia de requisitos como a ciência e disciplina preocupada com a análise e documentação dos requisitos, incluindo análise das necessidades e análise e especificação dos requisitos.
Além disso, a engenharia de requisitos fornece mecanismos apropriados para facilitar as atividades de análise, documentação e verificação.
Desde a década de 70, problemas com Er persistem como uma causa chave para a ineficiência e falhas de projetos de software.
Melhorias no processo de Er têm potencial de reduzir custos e tempo de desenvolvimento, e aumentar a qualidade do software.
A engenharia de requisitos (no contexto da engenharia de software) é um processo que engloba todas as atividades que contribuem para a produção de um documento de requisitos e sua manutenção ao longo de o tempo.
Segundo, a Er é ambos uma atividade organizacional e uma atividade de projeto.
É uma atividade organizacional quando o enfoque é definir qual o conjunto de requisitos que são apropriados para o software, e quais requisitos serão entregues.
É uma atividade de projeto quando este conjunto de requisitos é direcionado para a equipe que irá desenvolver o software.
Este dualismo envolve um conjunto de decisões que tem que atender tanto as necessidades da organização, assim como as necessidades do projeto.
Segundo, requisitos de software podem ter duas definições:
Uma condição ou capacidade do sistema de software necessária para o usuário resolver um problema ou alcançar um objetivo;
Uma condição ou capacidade que deve ser encontrada ou possuída por um sistema ou componente do sistema de software para satisfazer um contrato, padrão, especificação ou outro documento imposto formalmente.
Alguns autores definem um requisito como qualquer função ou característica necessária a um sistema -- os comportamentos quantificáveis e verificáveis que um sistema deve ter, as restrições que deve atender ou outras propriedades que devem ser fornecidas, de forma a satisfazer os objetivos das organizações e resolver um conjunto de problemas.
Outros, afirmam que os requisitos de um sistema definem o que o sistema deve fazer e as circunstâncias sobre as quais deve operar.
Em outras palavras, os requisitos definem os serviços que o sistema deve fornecer e dispõem sobre as restrições à operação do mesmo.
Diversos autores dividem os requisitos de software em dois tipos:
Funcionais (o que o software deve fazer) e não-funcionais (como o software se comporta em relação a alguns atributos observáveis).
Requisitos funcionais devem definir as ações fundamentais que devem ser tomadas por o software na aceitação e processamento das entradas, e no processamento e transformação das saídas.
Requisitos funcionais devem ser descritos de forma completa e consistente, onde a completeza significa que todas as funções requeridas por o usuário devem estar descritas, e consistência significa que os requisitos não devem ter definições contraditórias.
Segundo requisitos funcionais podem ser representados por uma simples sentença ou na forma de casos de uso.
Requisitos não-funcionais são requisitos que especificam as propriedades de um sistema de software, tais como restrições de ambiente e implementação, desempenho, dependência de plataformas, manutenabilidade, extensibilidade, e confiabilidade[ JAC 1998 LEF 2000], requisitos não-funcionais são tipicamente documentados em linguagem natural.
A falha em se cumprir um requisito não-funcional pode ser muito pior do que a falha em se cumprir um requisito funcional.
Muitos requisitos não-funcionais dizem respeito ao sistema como um todo.
Enquanto a falha num requisito funcional pode degradar parte do sistema, a falha num requisito nãofuncional pode tornar todo o sistema inútil.
Sommerville considera a atividade de Gerência de requisitos como uma das principais atividades do processo de engenharia de requisitos.
Atualmente tem- se convicção de que mudanças em requisitos ao longo de o processo de desenvolvimento de software fazem parte do processo.
A gerência de requisitos está associada ao processo de acompanhar a evolução dos requisitos ao longo de o processo de desenvolvimento.
De acordo com, as principais responsabilidades da gerência de requisitos são:
Gerenciar mudanças em requisitos já aprovados;
Gerenciar os relacionamentos entre os requisitos;
Gerenciar as dependências entre o documento de requisitos e outros documentos produzidos durante o processo de desenvolvimento do sistema.
Os requisitos evoluem devido a mudanças no ambiente do sistema e devido a a evolução da compreensão dos stakeholders de suas reais necessidades.
Novos requisitos surgem e requisitos existentes mudam em qualquer estágio do processo de desenvolvimento do sistema.
Isto pode causar sérios problemas para os desenvolvedores do sistema.
Para minimizar estas dificuldades é necessário controlar e documentar estas mudanças.
O impacto das mudanças deve ser avaliado e, se as mudanças forem aceitas, o projeto e a implementação do sistema também devem ser modificados.
Indispensável à tarefa de gerência de requisitos é a disponibilidade de facilidades de rastreamento.
Um requisito é rastreável se é possível descobrir quem sugeriu o requisito (a fonte), por que o requisito existe (razões e motivações), que outros requisitos estão relacionados a ele (dependência entre requisitos) e como o requisito se relaciona com outras informações tais como arquitetura do sistema, implementação e documentação do usuário.
Algumas pesquisas apontam que os principais motivos que levam a atrasos na entrega, aumento de custos, e ineficiência de um software são todos relacionados com práticas de gerência de requisitos.
Existem diversos estudos relacionados à gerência de requisitos.
Por exemplo,[ Dou 2008] apresenta métodos para auxiliar os stakeholders não-técnicos envolvidos com a engenharia de requisitos a gerenciarem mudanças nos requisitos dentro de um domínio específico.
Segundo o autor, uma parte importante de gerenciar requisitos que evoluem ao longo de o tempo é manter a ordem temporal das mudanças e suportar a rastreabilidade das modificações.
Cenários podem ser úteis para facilitar a comunicação com os usuários.
Os usuários geralmente acham mais fácil relacionar exemplos da vida real do que descrições abstratas.
Os usuários podem compreender e criticar um cenário de como poderiam interagir com um sistema de software.
Os engenheiros de requisitos podem utilizar as informações obtidas com essa discussão para formular os requisitos reais do sistema.
A obtenção de requisitos com base em cenários pode ser realizada informalmente, e o engenheiro de requisitos trabalha com os stakeholders para identificar cenários e captar detalhes desses cenários.
Os casos de uso são técnicas baseadas em cenários para a obtenção de requisitos utilizando uma abordagem estruturada.
Eles são atualmente uma característica fundamental no uso da UML (Unified Modeling Language ­ Linguagem de Modelagem Unificada)[ JAC 1998].
Um caso de uso engloba um conjunto de cenários em que cada cenário é um traço isolado dentro de o caso de uso.
Casos de uso descrevem as interações entre o usuário e o sistema, focando no que o sistema faz para o usuário.
O modelo de casos de uso descreve na totalidade o comportamento funcional do sistema.
De acordo com a especificação UML, um caso de uso consiste na especificação de uma seqüência de ações, incluindo variações, que o sistema pode executar, interagindo com atores do sistema.
Um caso de uso descreve uma porção do comportamento do sistema sem revelar a estrutura interna do sistema.
Sendo assim casos de uso são úteis para a captura e documentação de requisitos externos.
Eles também são ideais para a validação de requisitos através de protótipos.
Vários processos de desenvolvimento de sistemas de software incluindo o Método Unificado de Desenvolvimento de Software (Unified Software Development Process) recomendam a utilização de casos de uso para a documentação dos requisitos dos usuários.
Um padrão de especificação de casos de uso é recomendado porque uma estrutura prédefinida auxilia aos engenheiros de requisitos a identificarem e incluírem importantes elementos em cada caso de uso.
Existem diferentes padrões e guias para a especificação de requisitos na literatura.
Exemplos podem ser encontrados em,, e.
O conteúdo encontrado com mais freqüência é mostrado na Tabela 1.
Seguem abaixo as propriedades dos casos de uso que serão adotadas neste trabalho, bem como descrição detalhada de cada uma:
Objetivo: Esta informação deve conter o motivo por o qual o requisito é necessário para atender um objetivo de negócio.
Apesar de não ser identificada com uma propriedade freqüente em templates de casos de uso, adotou- se esta propriedade como uma informação adicional que deve auxiliar os stakeholders a compreender o caso de uso;now
Título: Contém o nome do caso de uso.
Cada caso de uso deve ter um nome único que sugira o seu objetivo;
Atores: Consiste na lista de atores que interagem com o caso de uso.
São entidades externas (usuários ou outros sistemas) que interagem com o caso de uso para atingir um determinado objetivo.
Não se deve confundir ator com usuário, uma vez que um usuário pode realizar diferentes papéis no uso de um sistema, enquanto que um ator representa apenas um papel;
Pré-condições: Listagem das condições que se devem ser atendidas antes de iniciar o caso de uso;
Pós-condições: Descrevem o que deve ser verdadeiro quando de a bem-sucedida conclusão do caso de uso ­ seja o cenário principal ou algum outro caminho alternativo.
É uma garantia de sucesso do caso de uso que deve atender às necessidades de todos os stakeholders;
Importância: Esta propriedade indica o quanto o requisito é importante para os Propriedade Título Fluxo básico de X de X Atores Pré-condições eventos Pontos extensão Fluxos alternativos Pós-condições stakeholders.
Para esta propriedade podem ser atribuídos valores numéricos ou algumas expressões como &quot;vital», &quot;importante «ou &quot;interessante se ter&quot;;
Comentários: O propósito desta propriedade é permitir ao engenheiro de requisitos informar outras informações que não se enquadram nas outras propriedades;
Freqüência: Indica o número de vezes que se espera que o caso de uso execute.
Apesar de a freqüência não ser um requisito, é uma informação importante para os desenvolvedores do software;
Fluxo básico de eventos:
Descreve o fluxo de eventos ou cenário principal que o caso de uso deve realizar para atingir o objetivo, ou seja, descreve o cenário típico de sucesso que satisfaz o objetivo dos stakeholders.
Usualmente é descrito através de uma seqüência de eventos numerados;
Fluxos alternativos:
Representam fluxo de eventos ou cenários que são ramificações do fluxo básico de eventos (cenário principal);
Requisitos Não-Funcionais: A especificação de caso de uso também pode conter a descrição de requisitos não-funcionais relacionados com o caso de uso (requisitos especiais).
Entre esses requisitos podem- se ter requisitos de qualidade, tais como desempenho, confiabilidade, usabilidade e restrições de projeto (freqüentemente relativas a dispositivos de E/ S) que foram impostas ou consideradas prováveis[ Lar Cockburn define que casos de uso representam requisitos que especificam o que o sistema de software deve fazer.
Porém eles não são todos os requisitos, já que não especificam interfaces externas, formatos de dados, regras de negócio e fórmulas complexas.
Ou seja, segundo o autor, os casos de uso constituem somente uma fração de todos os requisitos do sistema.
O trabalho de propõe uma solução para o problema da representação dos requisitos dos clientes de forma que possam ser entendidos tanto por os engenheiros de software como também por profissionais não envolvidos com computação e usuários finais.
Para tanto são apresentados padrões de representação dos requisitos funcionais e não funcionais.
O padrão para requisitos funcionais apresentado está no formato de casos de uso.
Ou seja, os autores consideram casos de uso como forma de descrever, de forma padronizada, os requisitos funcionais de um sistema.
Segundo Somé, casos de uso, que descrevem as possíveis interações envolvendo o sistema e seu ambiente, vêm cada vez mais sendo adotados como meio de elicitação e análise dos requisitos funcionais.
Em este trabalho o autor apresenta um método suportado por uma ferramenta de engenharia de requisitos baseada em casos de uso.
O método inclui a formalização dos casos de uso, uma forma restritiva de descrição dos casos de uso em linguagem natural, e a derivação de uma especificação executável, bem como um ambiente de simulação dos casos de uso.
A UML define os relacionamentos Inclusão (representado por &quot;include&quot;), Extensão (representado por &quot;extende&quot;) e Generalização entre casos de uso.
O relacionamento de Inclusão define que um caso de uso contém o comportamento definido em outro caso de uso.
O caso de uso que inclui pode depender apenas do resultado (valor) do caso de uso incluído.
Este valor é obtido como um resultado da execução do caso de uso incluído.
A execução do caso de uso incluído não é opcional, ou seja, é sempre requerida por o caso de uso que inclui.
O relacionamento de inclusão permite a composição hierárquica e o reuso dos casos de uso.
O relacionamento de Extensão define que o comportamento de um caso de uso pode ser estendido por o comportamento de outro caso de uso.
O caso de uso estendido é definido independentemente do caso de uso que estende, ou seja, ele existe independente do caso de uso que o estende.
Por outro lado, o caso de uso que estende pode definir comportamento que não necessariamente faça sentido por si só.
Em este caso, o caso de uso que estende define um conjunto de comportamento modular que complementa a execução do caso de uso estendido quando determinada condição é encontrada.
O relacionamento Generalização é usado quando um caso de uso especializa outro caso de uso mais geral, ou seja, diz- se que o caso de uso é &quot;um tipo de «outro caso de uso.
Segundo a UML um relacionamento de generalização entre casos de uso implica que o caso de uso filho contém todos os atributos, seqüências de comportamento, e pontos de extensão definidos no caso de uso pai, e participa de todos os seus relacionamentos.
Além de os relacionamentos entre casos de uso definidos por a UML, será considerado neste trabalho o relacionamento entre casos de uso por suas pré-condições e póscondições.
Pré-condições: São condições que devem ser verdadeiras quando a execução do caso de uso for invocada.
Pós-condições: São condições que serão verdadeiras quando o caso de uso completar a sua execução com sucesso, assumindo que suas pré-condições foram satisfeitas.
Póscondições são particularmente importantes quando o caso de uso executado leva o sistema para um determinado estado que caracterize uma pré-condição para outro caso de uso[ COC Somé define que pré e pós-condições são especificações implícitas da seqüência de execução dos casos de uso.
Pré-condições e pós-condições permitem especificar que casos de uso devem preceder um dado caso de uso e quais os casos de uso que devem suceder (executar após) o caso de uso.
Mais detalhes sobre o trabalho pode ser encontrado na seção 3.1 que descreve os estudos relacionados.
Larman[ Lar 2007 7] descreve os Contrato os de Opera ação como artefatos re elacionados com a análise orientada a objeto.
Os contratos de d operação o usam pré e pós-cond dições para rever modif ficações de etalhadas em m objetos do d Modelo de Domíni io, como re esultado de descr uma operação do d sistema.
Segundo o autor, as pós-condiç ções descre evem modif ficações no estad do de os obje etos do Me o odelo de Domínio.
Te a ais modific cações no estado do Modelo do Dom mínio incluem instânc cias criada as, associa ações form madas ou desfeitas e atributos modi ificados.
A Figura a 1 mostra um u exemplo o de dois ca asos de uso o que estão relacionado os por pré e pós-c condições.
Em o exemplo, a pós-c condição do o caso de uso &quot;Entra ar no Sistem me a é précond dição do caso de uso «S Submeter Pe edido».
Figur ra 1.
Exemp plo de casos s de uso rela acionados por pré e pós s-condições.
Mais exe emplos de casos de uso relacio onados por pré e pós s-condições, conforme propo osto neste tr rabalho, podem ser obs servados na a seção 5.2.4 ção de Software De acord do com[ Be EN 2000] a manutenção o e evolução o do softwa are caracteri izam- se por dema andarem cu usto muito alto a das org ganizações e também por a baixa velocidade de resposta (implementação o de mudanç ças).
Desenvo olvimento Inicial:
Nes sta fase a p primeira ver rsão do sof ftware é desenvolvida.
Esta primeira versão pode não conter r todas as f funcionalida ades, mas já á tem uma arquitetura persistirá por o resto do d ciclo de vida da ap plicação.
Um m outro im mportante re esultado do que p desen nvolvimento inicial é o conheci imento da aplicação:
Conhecime ento do omínio, dos requi isitos de usu uário, a fun nção da apli icação no pr rocesso de negócio, as soluções e algoritmos ambiente de utiliz zados, os fo ormatos de dados, pont tos fortes e fracos da arquitetura, d operação da ap plicação, etc c..
Este conh hecimento é um pré-req quisito para a subseqüe ente fase Ev volução.
Evolução o:
Esta fase e só inicia quando o desenvolvim mento inicia al foi bem sucedido.
Serviço: Durante esta fase, somente pequenas mudanças táticas (concertos, ajustes) são possíveis.
Para a organização, quando a aplicação entra neste estágio, é porque ela não é mais um produto essencial e o custo-benefício de se efetuar mudanças é baixo.
Descontinuação: Esta fase se dá quando nenhum serviço de manutenção (fase de Serviço) é necessário, mas a aplicação ainda está em produção.
Os usuários precisam conviver com deficiências e limitações conhecidas.
Término: Em a fase de término o software é desativado e os seus usuários são direcionados a outro software substituto.
As fases de Evolução e Serviço, que estão destacadas na Figura 2, são foco principal deste trabalho.
Em ambas as fases a mudança da aplicação é a operação principal, com a única diferença que na fase de Evolução as mudanças tendem a ser mais complexas do que na de Serviço.
Em também é apresentado o Ciclo de Vida de Mudança, conforme ilustrado na Figura 3, com as seguintes etapas:
Requisição de mudança:
Em a maioria das vezes é originada dos usuários do sistema e pode ter a forma de um relato de um problema (bug) ou a requisição por uma funcionalidade nova.
Normalmente é expressa em termos que representam conceitos do domínio da aplicação, por exemplo:
&quot;Adicione uma nova funcionalidade ao sistema de registro do estudante em cursos que impeça estudantes cujo registro esteja no estado retido não possam se registrar».
Planejamento da mudança:
Esta atividade é compreendida por duas subatividades, são elas:
O Compreensão do software:
A compreensão do software é um pré-requisito para a mudança e tem sido tópico de diversas pesquisas.
Relatos mostram que esta fase consome mais do que a metade dos recursos de manutenção.
Uma substancial parte da compreensão do software é a localização dos conceitos do domínio da aplicação no código.
Como no exemplo do registro do estudante em cursos, encontrar onde no código se encontra o &quot;registro de estudante em cursos&quot;;
Implementação da mudança:
Consiste na implementação da mudança nos componentes de software identificados previamente.
Pode acontecer de após modificar um determinado componente, este não se relacionar mais adequadamente com outros componentes, então estes outros componentes também devem ser alterados.
Isso se chama propagação da mudança[ RAJ Verificação e validação da mudança:
Consiste na verificação se a requisição de mudança foi atendida como esperado.
Re-documentação: Atualização da documentação do software.
Se não existe documentação do software ou se ela é incompleta, o fim do ciclo de mudança é o momento de registrar a compreensão adquirida durante a mudança.
Considerando o alto custo para compreensão do software, o registro do conhecimento adquirido é valioso.
Mas na prática, ao término da mudança, os envolvidos na mudança do software tendem a voltar sua atenção a coisas novas em vez de atualizar a documentação.
Por este motivo existem estudos, como apresentado em[ RAJ 1999], que propõem a documentação incremental ao longo de o processo de mudança.
Segundo este método, depois de certo período de contínuas mudanças, uma documentação significativa tende a ser gerada.
Este capí ítulo aprese entou a fund damentação o teórica do os principais s conceitos envolvidos neste e trabalho.
São S eles:
En ngenharia de requisitos s;
Requisitos s;
Gerência de d requisito os;
Casos de uso e manutençã ão de software.
De os caso os de uso, al lém da sua definição na a literatura demonstrou u- se que vár rios autores os consideram como uma forma de d represent tar os requ uisitos funcionais.
Os s possíveis relac cionamentos s entre os ca asos de uso também for ram apresen ntados.
Em relaç ção à manu utenção do software a apresentou- se o ciclo de vida do o software, dand do ênfase pa ara as fases de evoluçã ão e serviço o, pois é qua ando aconte ecem as req quisições de muda anças.
O cic clo de vida da requisiçã ão de muda ança também m foi aprese entado.
Em o próx ximo capítulo serão ap presentados alguns tra abalhos rela acionados ao a tema de pesqu uisa.
Após a pesquisa bibliográfica foram encontrados alguns trabalhos relacionados ao tema de pesquisa apresentado nesta dissertação.
Este capítulo apresenta uma breve descrição dos mesmos, seguido das características relevantes para este trabalho.
Somé propõe numa formalização da representação textual dos casos de uso.
Segundo o autor, o fato dos casos de uso serem intuitivos, centralizados no usuário e textuais é uma das razões para o seu sucesso.
Porém um certo nível de formalização é necessário para automatizar o desenvolvimento, incluindo a modelagem, verificação e validação, dos sistemas que se baseiam nos mesmos.
Em o nível sintático, um meta-modelo em UML e uma forma restringida de linguagem natural são definidas para a descrição dos casos de uso.
A semântica de execução é proposta como um conjunto de Regras de Mapeamento (Mapping Rules) dos casos de uso bemformados para as redes de Petri Básica.
O trabalho de Somé contribui com este trabalho de duas maneiras.
A representação da descrição dos casos de uso através de um meta-modelo auxiliou na definição dos elementos que constituem o caso de uso bem como na sua representação no modelo proposto, conforme descrito na seção 2.4.3.
Outra contribuição deste trabalho é em relação a o relacionamento entre os casos de uso por pré e pós-condições.
Somé cita o seguinte:
&quot;Pré-condições e pós-condições são especificações implícitas das condições de seqüência dos casos de uso.
A pré-condição de um caso de uso é uma condição que precisa ser atendida até a execução do caso de uso, enquanto que a pós-condição é uma condição que é atendida no final da execução do caso de uso.»
Apesar de citar que as pré e pós-condições indicam a seqüência de execução dos casos de uso, Somé não propõe o relacionamento direto por pré-condições e póscondições entre os casos de uso, como é apresentado nesta dissertação.
O autor propõe um relacionamento indireto que pode estar baseado nas pré-condições e pós-condições.
Este relacionamento está representado por as listas &quot;UseCaseEnabling «(Casos de Uso Habilitados ou que procedem o caso de uso atual) e &quot;FollowList «(Casos de Uso que Precedem o caso de uso atual).
Rastreabilidade dos artefatos de software é a habilidade de descrever e seguir a vida de um artefato (requisitos, código, testes, modelos, relatórios, planos, etc) desenvolvido durante o ciclo de vida do software, em ambas as direções (dos requisitos ao código e vice-versa) A rastreabilidade pode fornecer importantes informações no desenvolvimento e evolução do software auxiliando na compreensão do software, na análise de impacto, e reuso de softwares existentes.
A principal deficiência de sistemas de gerência de artefatos de software é a falta de geração automática ou semi-automática de ligações de rastreabilidade e manutenção destas ligações.
Em este trabalho o autor propõe a integração de um sistema de gerência de artefato conhecido como ADAMS (ADvanced Artefact Management System), proposto em[ LUC 2004], com uma ferramenta de recuperação de rastreabilidade baseada numa técnica de Recuperação de Informação (Ir ­ Information Retrieval), denominada LSI (Latent Semantic Indexing).
As ligações de rastreabilidade armazenadas no ADAMS são úteis para análise de impacto e manutenção durante a evolução do software notificando os engenheiros que um artefato tem que ser modificado por conseqüência de mudanças aplicadas com artefatos que eles dependem.
O sistema ADAMS auxilia na manutenção dos artefatos consistentes através das ligações de rastreabilidade entre os mesmos.
Quando uma mudança afeta um artefato (por exemplo um caso de uso), existe a possibilidade de afetar os artefatos dependentes desse primeiro identificado.
A representação da dependência entre os artefatos se dá através das ligações de rastreabilidade.
Seguem abaixo algumas conclusões identificadas por o autor após a avaliação da ferramenta:
O uso da ferramenta de recuperação da rastreabilidade reduz significativamente o tempo necessário para a identificação das ligações se comparado com o método manual;
Métodos de Recuperação de Informação (Ir ­ Information Retrieval) fornecem um suporte útil na identificação das ligações de rastreabilidade, mas não conseguem identificar todas as ligações existentes:
A limitação da recuperação da rastreabilidade através de Ir é que estes métodos não podem auxiliar na identificação de todos as ligações corretas, forçando o engenheiro de software a analizar e descartar um alto número de falso positivos;
O método incremental de recuperação da rastreabilidade foi identificado como melhor do que o método de identificação numa única vez;
Métodos baseados em Ir pode auxiliar na identificação de problemas de qualidade da descrição textual de artefatos de software.
Conforme pode ser observado, a proposta do trabalho de é bastante similar à proposta desta dissertação, pois também propõe uma solução para suportar a evolução do software.
A diferença principal é que a solução apresentada propõe auxiliar na evolução do software a partir de a rastreabilidade entre todos os artefatos do software, tendo o suporte de uma ferramenta de gerência de artefatos e um método para geração automática das ligações de rastreabilidade.
Enquanto que o trabalho que está sendo apresentado se propõe a suportar a evolução dos requisitos do software através de ligações de rastreabilidade entre as requisições de mudanças e os requisitos (funcionais, representados por casos de uso, e não funcionais), ligações entre os casos de uso (por os relacionamentos propostos por e), e através do histórico dos requisitos ao longo de o ciclo de vida do software.
Enfim, este trabalho é menos abrangente no sentido que não apresenta uma solução que abranja todos os artefatos do software, porém é mais específico e, por conseqüência, mais detalhista no suporte aos artefatos de requisitos.
Este trabalho propõe a integração de ontologias no Processo Unificado (PU) a fim de fornecer rastreabilidade baseada em conceitos ao longo de o ciclo de vida do software.
Este método permite a integração de diferentes modelos do sistema de software incluindo negócio, requisitos, modelos de análise e de projeto.
Para auxiliar os projetistas na criação da ontologia e ligação dos conceitos dos artefatos o autor disponibiliza uma ferramenta integrada com um modelador UML.
A principal diferença do trabalho de Noll em relação a este trabalho é que ele apresenta uma proposta de rastreabilidade dos artefatos do software, mas não apresenta uma proposta para manter a consistência e o controle de versão dos mesmos.
O controle de versão é essencial para que seja possível se ter o histórico da evolução do software.
Outra diferença é que neste trabalho o autor propõe a rastreabilidade de todos os artefatos, enquanto que neste trabalho o enfoque é apenas artefatos de requisitos.
Gerência de configuração do software ou Software Configuration Management (SCM) e rastreabilidade são duas práticas importantes no desenvolvimento do software que suporta a evolução do sistema e o controle de mudanças.
SCM auxilia a gerenciar a evolução dos artefatos de software e suas documentações, enquanto que a rastreabilidade auxilia a gerenciar o conhecimento sobre o processo do desenvolvimento dos artefatos.
Em este trabalho é apresentada uma solução que integra a rastreabilidade e SCM a fim de suportar o gerenciamento de mudanças durante o desenvolvimento e evolução dos artefatos de software.
É apresentada uma ferramenta (chamada Tracer) que suporta a integração destas duas práticas.
Tracer se caracteriza por uma ferramenta de rastreabilidade integrada com o MS Visual SourceSafe.
O trabalho de também apresenta uma proposta de solução de escopo mais abrangente do que esta dissertação, pois propõe uma solução que suporta a gerência de todos os artefatos do software ao longo de sua evolução.
No entanto, o trabalho desta dissertação, por ter o foco apenas em requisitos, apresenta uma solução mais aprofundada para suportar a consistência e atualização dos requisitos do software ao longo de sua evolução.
Em[ MOH 2008] os casos de uso são armazenados como um único elemento, enquanto que neste trabalho os casos de uso são uma composição de elementos (Título, Pré-condições, Póscondições, Objetivo, Atores, etc).
A vantagem desta representação é que ela permite explorar o conteúdo dos casos de uso, como por exemplo, o relacionamento entre os casos de uso por suas pré-condições e pós-condições conforme descrito na seção 2.4.3 (Relacionamentos entre Casos de Uso).
Outra diferença entre os trabalhos é que não propõe o reuso dos artefatos.
Em este capítulo foi apresentada uma breve descrição do trabalho de Somé[ SOMé 2007].
Embora o propósito do trabalho do autor não seja o mesmo deste trabalho, algumas de suas definições, como o meta-modelo de representação dos casos de uso e a identificação de pré e pós-condições como indicações da seqüência de execução dos casos de uso, contribuíram para o desenvolvimento da solução apresentada neste trabalho.
Em este capítulo também foram apresentados dois trabalhos, de e[ MOH 2008], com propósito muito semelhante ao desta dissertação.
Em suma, a principal diferença deste trabalho em relação a estes dois citados é que ele tem como foco a gerência dos requisitos, representados por casos de uso.
Enquanto que os outros dois trabalhos focam na gerência de todos os artefatos do software, ou seja, são mais abrangentes.
Por ser mais específico, com o escopo limitado ao nível de requisitos, este trabalho se aprofunda mais no tópico e propõe uma solução para o suporte da consistência e atualização dos requisitos.
Esta solução se difere por os seguintes motivos:
Propõe um padrão de formação dos requisitos funcionais, representados por casos de uso;
Suporta a representação dos relacionamentos entre os casos de uso, não só os propostos na UML, mas também relacionamento dos casos de uso por suas pré e pós-condições;
Fornece a rastreabilidade entre a requisição de mudança e os requisitos afetados por a mesma;
Mantém o histórico de cada requisito do software;
Possibilita a associação de um mesmo requisito com mais de uma aplicação (reuso).
Mais detalhes sobre a solução proposta são apresentados no próximo capítulo.
Com estes recursos, este trabalho permite o suporte à atualização e consistência dos requisitos durante a manutenção.
O foco principal de é definir a rastreabilidade entre os artefatos do software de forma semi-automática através do método LSI.
Mas esta rastreabilidade não garante que os requisitos estão definidos de forma consistente e que estão sendo atualizados a partir de cada requisição de mudança (evolução do software).
O foco principal de[ MOH 2008] é a integração entre as práticas de gerência de configuração e a rastreabilidade dos artefatos de software.
Ambos os trabalhos, de e, não se preocupam em definir a forma como os requisitos estão representados, como eles se relacionam entre si, com as aplicações de software, e com as requisições de mudanças.
Estas são características essenciais para suportar a consistência e a atualização dos requisitos ao longo de a evolução do software e estão no escopo desta pesquisa.
O próximo capítulo apresenta um estudo de caso exploratório para melhor compreensão do problema alvo deste trabalho seguido da descrição do modelo proposto para resolver- lo.
Este capítulo ilustra o problema que este trabalho se propõe a resolver ressaltando as principais dificuldades identificadas a partir de um estudo de caso exploratório realizado na fábrica de software citada anteriormente.
A partir de as dificuldades identificadas é apresentada a proposta de solução para o problema através do Modelo Conceitual do problema, regras de consistência e do versionamento dos requisitos.
Em esta seção será apresentada a descrição de um estudo exploratório importante para a compreensão do problema e a identificação dos principais requisitos que o modelo de gerência de requisitos que será proposto deve atender.
Com o objetivo de identificar as principais dificuldades envolvidas na manutenção dos requisitos consistentes e atualizados ao longo de projetos de manutenção de software realizouse uma análise de como uma equipe de 5 Analistas de Sistemas trabalham com os requisitos de mais de 25 aplicações que passam por constante processo de evolução na fábrica de software.
Para cada aplicação que o grupo tem a responsabilidade de manter existe um SRS (Software Requirements Specification) onde estão descritos todos os requisitos da mesma.
A maior parte destes SRSs foram criados a partir de um processo de Engenharia Reversa.
A Engenharia Reversa foi realizada com o objetivo principal de adquirir conhecimento da aplicação, considerando que a equipe em questão não tinha conhecimento prévio das mesmas até ser designada a manter- las.
Observou- se que os requisitos funcionais dos SRSs existentes estão organizados por funcionalidade, onde cada funcionalidade é descrita da seguinte forma:
Introdução/ Objetivo da funcionalidade:
Contém a descrição do objetivo geral da funcionalidade;
Sequência de seqüência de par estímulo-resposta:
Contém a seqüência de entradas e respostas do sistema para alcançar os resultados desejados;
Requisitos Associados: Contém os requisitos de entrada e saída;
E requisitos nãofuncionais associados.
Em o processo de manutenção das aplicações seguido por a equipe estão definidas todas as fases de um processo de desenvolvimento:
Fase de visão, planejamento, desenvolvimento, teste e estabilização.
Durante a fase de visão, a equipe recebe uma lista de requisições de mudanças dos usuários.
Os engenheiros escrevem os requisitos para atender cada necessidade dos usuários (requisição de mudança).
Estes requisitos são escritos num documento customizado criado por a equipe (com base no documento SRS) denominado ERD (Enhancement Request Document), para conter os requisitos que atendem a cada necessidade.
Por convenção da equipe, cada ERD está relacionado com apenas uma aplicação.
A Figura 4 ilustra a estrutura do documento ERD.
Necessidade do negócio:
Uma breve descrição da necessidade de negócio que a alteração da aplicação irá atender.
Esta descrição é baseada na requisição de mudança submetida por o usuário.
Estado atual dos requisitos da aplicação:
Contém a descrição dos requisitos da funcionalidade (s) atingida (s) por a modificação.
Esta descrição é uma cópia da descrição contida no SRS da aplicação.
Cabe ressaltar que a identificação de qual funcionalidade (s) deve ser alterada para atender a necessidade do negócio é feita de forma manual, baseada no conhecimento prévio dos Engenheiros de Requisitos sobre a aplicação em questão.
No caso de a necessidade do negócio demandar a criação de uma funcionalidade nova, esta sessão deve indicar que a funcionalidade não existe na aplicação atualmente.
Caso seja identificado que a necessidade de negócio implica em modificações em mais de uma aplicação, um ERD é criado para cada aplicação.
Requisitos para atender a necessidade:
Em esta seção são identificados e devidamente descritos os requisitos que devem ser alterados, removidos ou adicionados à aplicação.
Estado dos requisitos da aplicação após as modificações:
Esta seção deve conter a descrição dos requisitos da aplicação que serão alterados, removidos ou adicionados de tal forma que estes estejam prontos para serem transcritos para o SRS da aplicação.
A partir de entrevistas com membros da equipe de analistas, observou- se que a principal preocupação da equipe é de manter os SRSs consistentes contendo os requisitos das aplicações atualizados ao longo de o processo de manutenção.
Tendo em vista esta preocupação apontada por a equipe, identificou- se a necessidade de entender melhor o problema, identificar as principais dificuldades e qual a dimensão das mesmas.
Para isso partiu- se para uma análise dos documentos de requisitos (SRSs e ERDs) criados por a equipe.
Seguem abaixo as perguntas que guiaram a análise.
Estas perguntas foram elaboradas por a própria autora com o objetivo de identificar se os requisitos afetados por requisições de mudanças estavam sendo atualizados e de que forma eles eram identificados (análise de impacto) e atualizados no SRS das aplicações:
Estas perguntas foram respondidas a partir de a análise de 12 ERDs feita por a pesquisadora sem intervenção dos analistas.
No caso de as ERDs analisadas, cada ERD está associada com uma única aplicação.
Seis aplicações são afetadas por estas ERDs.
Identificou- se que as 12 ERDs analisadas alteram um total de 118 requisitos de aplicação.
De entre estes requisitos de aplicação alterados, nenhum foi atualizado no SRS das aplicações correspondentes.
No entanto para todos os requisitos afetados, tem- se informação para determinar qual a requisição de mudança que os alterou e de que forma eles foram alterados.
Em o momento em que foi feita esta análise, todas estas requisições de mudança já haviam sido implementadas e entregues ao cliente.
De acordo com a própria equipe, após a entrega do produto aos clientes, os requisitos das aplicações afetadas devem ser atualizados nos SRSs de cada aplicação.
A não atualização acarreta numa desatualização e inconsistência dos dados que pode ter conseqüências como:
Falha na análise de impacto, falha no entendimento dos requisitos por parte de a equipe de desenvolvedores e testadores, entre outros problemas.
Não se sabe por que estes requisitos de aplicação não foram atualizados já que é uma preocupação apontada por a própria equipe.
Uma hipótese de provável causa é o fato de não haver uma ferramenta conhecida por a equipe que auxilie no processo de atualização destes requisitos.
A equipe utiliza o editor de texto Microsoft Word para escrita e atualização de requisitos.
Conforme relatado por a equipe e constatado na análise, por não existir ferramenta apropriada para atualização dos requisitos de aplicação ao longo de o ciclo de vida da mesma (principalmente na fase de manutenção), a tarefa de manter os requisitos de aplicação atualizados torna- se bastante penosa e, por conseqüência, é deixada de lado na maioria dos casos.
O problema que motivou este trabalho está relacionado com a dificuldade de manter a documentação de requisitos de aplicação atualizados ao longo de o seu ciclo de vida.
De acordo com o caso prático descrito, os seguintes requisitos para a solução se destacam por descreverem as principais características que devem ser encontradas num modelo de suporte à atualização e consistência dos requisitos para manutenção de software:
Requisito 1: Suporte à identificação dos requisitos afetados por uma requisição de mudança (análise de impacto).
A identificação dos requisitos afetados de forma manual baseada no conhecimento dos stakeholders, considerando que uma requisição de mudança pode afetar mais de uma aplicação e que uma aplicação pode ter muitos requisitos (dependendo de sua complexidade) é uma atividade muito complexa e propensa a erros;
Requisito 2: Suporte ao gerenciamento da concorrência.
Duas ou mais requisições de mudança podem afetar os mesmos requisitos de uma mesma aplicação num mesmo período, sendo essencial o gerenciamento da concorrência;
Requisito 3: Os requisitos de aplicações devem ser atualizados e estarem consistentes para refletirem as alterações da requisição de mudança.
Em este caso, além de a atualização dos requisitos, deve- se ter cuidado para que estas atualizações só sejam consideradas como definitivas a partir de o momento que a mudança é entregue aos usuários.
Até este momento as mudanças devem ser feitas de forma que possam ser descartadas, caso a requisição de mudança não seja atendida;
Requisito 4: Deve ser possível obter a rastreabilidade das mudanças dos requisitos de aplicação a fim de se ter informações tais como a partir de qual requisição de mudança um determinado requisito surgiu, foi removido ou alterado.
Essa rastreabilidade entre as requisições de mudanças e os requisitos afetados fornece o histórico da evolução da aplicação.
Este histórico pode auxiliar, por exemplo, os stakeholders na identificação das causas de problemas na aplicação, podendo agilizar a sua manutenção;
Requisito 5: Suporte ao rollback das alterações feitas por uma requisição de mudança.
Uma requisição de mudança é implementada (os requisitos estão atualizados) e entregue aos usuários, porém, após certo período é verificado que a mudança deve ser desfeita (rollback).
Considerando os requisitos listados acima, as principais prioridades deste trabalho será encontrar uma solução para os seguintes requisitos:
Identificação dos requisitos afetados, manutenção dos requisitos atualizados e consistentes conforme as requisições de mudanças (requisito 3) e manter a rastreabilidade das mudanças dos requisitos de aplicação (requisito 4).
O requisito 2 que trata do suporte ao gerenciamento da concorrência não será abordado nesta dissertação por se tratar de um tópico de pesquisa complexo, que exige um estudo aprofundado do assunto, e não foi possível realizar- lo no tempo de desenvolvimento desta dissertação.
Estes problemas ficam em evidência para os analistas durante a fase de manutenção da aplicação, que é quando, na maioria das vezes, se despende muito tempo para identificar o impacto da mudança na aplicação e as modificações são feitas na aplicação sem se preocupar em atualizar a documentação dos requisitos.
A partir de o problema detalhado na seção anterior, desenvolveu- se um Modelo Conceitual como primeiro passo para se encontrar a sua solução.
O modelo representa os conceitos envolvidos no problema.
O modelo está demonstrado na Figura 5.
O Modelo Conceitual foi desenvolvido com base nos seguintes trabalhos:
Cerri: A composição do SRS apresentado na Figura 5 se baseia no Modelo Conceitual do SRS apresentado por a autora;
Somé: A definição dos elementos que compõem o Caso de Uso foi baseada no meta-modelo de casos de uso apresentado no trabalho do autor, com apenas duas exceções.
São elas:
Somé não propõe o relacionamento direto entre pré e pós-condições.
Em vez de isto ele propõe que o relacionamento é implícito e cria novas classes para representar estes relacionamentos:
Lista dos casos de uso que precedem o caso de uso atual (FollowList) e lista dos casos de uso que sucedem o caso de uso atual (UseCaseEnabling).
Estas duas classes definidas por Somé não serão utilizadas por o modelo apresentado neste trabalho.
Esta seção apresenta a descrição das classes e dos relacionamentos entre as classes do Modelo Conceitual do problema apresentado.
As principais classes que compõem o modelo são:
A classe que representa o SRS (SRS);
A classe que representa a Aplicação (Aplicacao);
A classe que representa os Requisitos da Aplicação (RequisitoAplicacao);
E a classe que representa as Requisições de Mudança (RequisicaoMudanca).
SRS: A classe SRS representa o documento SRS da aplicação.
Este documento mostra que um SRS é composto de quatro seções maiores:
Introdução, Descrição Geral, Informações de Suporte e Requisitos de Aplicação, representadas respectivamente por as classes:
IntroducaoSRS, DescricaoGeral, InformacoesSuporte RequisitoAplicacao).
Esta definição da composição do SRS é baseada na representação do SRS apresentado em.
IntroducaoSRS: A classe IntroducaoSRS representa a seção Introdução da SRS e contém informações que dão uma visão geral sobre o documento.
Em a SRS esta seção é composta de outras cinco subseções:
Propósito, Escopo, Definições, Referências e Visão Geral representadas, respectivamente, por as classes Proposito, EscopoSRS, Definições, Referencias e VisaoGeral.
Proposito: A classe Proposito representa a subseção Propósito da SRS que indica seu objetivo geral.
Indica, também, a audiência pretendida para a SRS.
EscopoSRS: A classe EscopoSRS representa a subseção Escopo da SRS e descreve os objetivos específicos, focando no software que está sendo especificado.
Definicoes: A classe Definições representa a subseção Definições, Acrônimos e Abreviaturas que contém as definições de todos os termos, siglas e abreviaturas necessárias para interpretar apropriadamente a SRS.
Referencias: A classe Referencias representa a subseção Referências da SRS que identifica todos os documentos referenciados.
VisaoGeral: A classe VisaoGeral representa a subseção Visão Geral da SRS que apresenta informações referentes à organização do documento.
DescricaoGeral: A classe DescricaoGeral representa a Seção Descrição Geral da SRS, responsável por descrever os fatores gerais que afetam o produto.
Esta seção contém outras nove subseções:
Funções do Produto, Características do Usuário, Suposições e Dependências, Restrições Gerais, Requisitos de Operação, Limites de Memória, Distribuição dos Requisitos, Requisitos de Adaptação de Local e Interfaces representados, respectivamente, por as classes CaracteristicasUsuario, SuposicoesDependencias, RequisitosOperacão, LimitesMemoria, FuncoesProduto, RestricoesGerais, DistribuicaoRequisitos, RequisitosAdaptacão e Interface.
FuncoesProduto: A classe FuncoesProduto representa a subseção Funções do Produto da SRS que fornece uma relação das funções do sistema, a fim de informar os principais objetivos.
Esta classe é composta de outros dois elementos:
Stakeholders e Objetivo representados, respectivamente, por as classes SRS_ Stakeholder e Objetivo.
SRS_ Stakeholder:
Mantém a lista dos stakeholders (usuários, patrocinadores, etc) envolvidos com o software.
Objetivo: A classe Objetivo é responsável por manter todos os objetivos necessários para o desenvolvimento completo do sistema.
CaracteristicasUsuario: A classe CaracteristicasUsuario representa a subseção Características do Usuário da SRS que descreve as características gerais dos usuários do sistema.
SuposicoesDependencias: A classe SuposicoesDependencias representa a subseção Suposições e Dependências da SRS que define os fatores que afetam os requisitos expressos na SRS como condições específicas de hardware.
RestricoesGerais: A classe RestricoesGerais representa a subseção Restrições Gerais da SRS que fornece uma descrição geral de qualquer outro item que limite as opções dos desenvolvedores como normas reguladoras, limites de hardware, protocolos etc..
Para isto o atributo idRestricão foi definido para manter a identificação da restrição e o atributo descricão para manter sua informação.
RequisitosOperacao: A classe RequisitosOperacão representa a subseção Operação da SRS e descreve todas as operações normais e/ ou especiais requisitadas por o usuário, como rotinas de inicialização, processamento, backup's e restauração.
LimitesMemoria: A classe LimitesMemoria representa a subseção Limites de Memória da SRS que especifica a memória (interna e externa) a ser, provavelmente, utilizada por o software.
DistribuicaoRequisitos: A classe DistribuicaoRequisitos representa a subseção Distribuição dos Requisitos na SRS que identifica os requisitos que podem ser adiados até versões futuras do sistema.
RequisitosAdaptacao: A classe RequisitosAdaptacão representa a subseção Requisitos de Adaptação do Local da SRS que contém a especificação das situações em que o software deverá ser adaptado antes da instalação.
Interface: A classe Interface representa as informações referentes às interfaces do sistema.
Os tipos de interface são:
Interfaces de Usuário, Interfaces do Hardware, Interfaces do Software e Interfaces de Comunicação.
InformacoesSuporte: A classe InformacoesSuporte define a seção Informações do Suporte da SRS responsável por tornar a SRS mais fácil de ser utilizada.
Esta seção é constituída por duas subseções:
Tabela de Conteúdo e índice e Apêndices representadas, respectivamente, por as classes Tabela e Apendices.
Apendices: A classe Apendices representa a subseção Apêndices da SRS que os especifica, se necessário.
Caso sejam identificados, deve ser informado se eles são ou não parte dos requisitos.
Aplicacao: Esta classe representa a aplicação de software.
Em ela devem estar definidos os dados da aplicação como a sua descrição, a data em que foi criada, por quem ela foi criada, qual o seu objetivo, qual o contexto em o qual ela está inserida dentro de a organização, número de usuários, tipos de usuários que utilizam a aplicação, entre outras informações.
RequisitoAplicacao: Esta classe deve conter os requisitos da aplicação.
Esta classe deve conter informações como o objetivo do requisito, a importância, comentários, dados da versão do requisito e seu estado, que indica se o requisito está ativo ou inativo (caso tenha sido removido).
Existem dois tipos de requisitos de aplicação:
CasoUso: Esta classe contém os requisitos funcionais da aplicação, que são representados por casos de uso.
Esta classe deve contem informações como título do caso de uso, a freqüência em que ele é executado, entre outras informações sobre o mesmo.
Existem dois tipos de casos de uso no modelo, casos de uso normal e caso de uso de extensão, representados por as classes CasoUsoNormal e CasoUsoExtensao.
Os casos de uso &quot;normais «podem conter pontos de extensão, representados no modelo por a classe PontoExtensao.
Esta definição da composição dos casos de uso é baseada no trabalho de.
CasoUsoNormal: Esta classe representa os casos de uso que não são extensão de outro (s) caso (s) de uso.
Um caso de uso &quot;normal «define o comportamento completo de um caso de uso.
Sua execução resulta no atendimento de um objetivo ou numa situação de erro.
CasoUsoExtensao: Esta classe representa os casos de uso que extendem outro (s) caso (s) de uso.
Um caso de uso extendido especifica um conjunto de comportamentos que são desvios com o objetivo de extender o comportamento definido por outros casos de uso.
O caso de uso de extensão contém a descrição do caso de uso de extensão (representada por a classe DescricaoCasoUsoExtensao).
ReqNaoFuncionalGeral: Esta classe representa os requisitos não-funcionais referentes ao sistema como um todo.
Requisitos não-funcionais geral seriam, por exemplo, requisitos de desempenho que se apliquem a toda a aplicação.
PontoExtensao: A classe PontoExtensão representa o ponto de extensão definido no caso de uso que é extendido por outro caso de uso.
O ponto de extensão é um símbolo do caso de uso extendido que referência um ponto particular do caso de uso que o extende.
As interações definidas no caso de uso que o extende podem ser inseridas neste ponto de extensão.
É através desta classe que está definido o relacionamento de extensão (extend) entre os casos de uso.
Cada ponto de extensão está associado com uma ou mais partes (representadas por a classe Parte) do caso de uso de extensão.
Estas partes são conjuntos de passos do caso de uso de extensão (representados por a classe PassoCasoUso).
ReqNaoFuncionalEspecifico: Esta classe representa os requisitos não-funcionais referentes ao caso de uso ao qual estão associados.
Requisitos não-funcionais específicos seriam, por exemplo, requisitos de desempenho que se apliquem apenas a funcionalidade descrita por o caso de uso.
DescricaoCasoUso: Esta classe representa a especificação do caso de uso.
Ela é especializada por outras duas classes DescricaoCasoUsoNormal (especificação do caso de uso que não extende outros casos de uso) e DescricaoCasoUsoExtensão (especificação do caso de uso que extende outros casos de uso).
DescricaoCasoUsoNormal: Classe que representa a especificação completa (título, pré-condições, pós-condições, passos do cenário principal, passos dos cenários alternativos, etc) do caso de uso que não extende nenhum outro caso de uso.
Esta classe é composta por as seguintes classes:
PreCondicão, PosCondicão, Alternativa e PassoCasoUso.
PreCondicao: Esta classe representa o conjunto de pré-condições associadas a um caso de uso.
PosCondicao: Esta classe representa o conjunto de pós-condições associadas a um caso de uso.
Restricao: Esta classe contém a descrição de uma restrição.
A restrição é formada por as informações objeto e estado.
As pré-condições e pós-condições, representadas por as classes PreCondicão e PosCondicão respectivamente, são tipos de restrições.
A pós-condição &quot;Usuário está registrado no Sistema «mostrada na Figura 1 mostra um exemplo de restrição.
Em este caso &quot;Usuário «é o objeto e &quot;está registrado no Sistema «é o estado.
Alternativa: A classe Alternativa representa os cenários alternativos do caso de uso.
Uma alternativa especifica uma continuação possível do caso de uso após a execução de um passo.
As alternativas são usadas para descrever exceções, situações de erro ou cursos de eventos menos comuns.
As alternativas são constituídas por restrições (condições que devem ser verdadeiras para que a alternativa seja executada), passos da alternativa e por o atraso, caso a alternativa tenha um tempo de espera (delay) associado.
Estas informações são representadas no modelo por as classes Restricão, PassoCasoUso e Atraso respectivamente.
PassoCasoUso: Esta classe representa os passos do caso de uso.
Um passo pode ser um bloco de repetição (representados por a classe RepeteBloco) ou um passo simples (representados por a classe PassoSimples).
RepeteBloco: Esta classe define blocos de repetição.
Um bloco de repetição define uma execução iterativa de uma seqüência de passos do caso de uso de acordo com uma condição e/ ou um atraso.
Blocos de repetição são descritos por palavras-chave de repetição tais como &quot;enquanto «e &quot;até que».
PassoSimples: Esta classe representa todos os passos do caso de uso, exceto os que são blocos de repetição.
Um passo simples pode ser dos seguintes tipos:
Passo que representa uma operação, passo de representa um desvio ou ramificação, passo que representa uma diretiva de inclusão de outro caso de uso e passo que representa uma diretiva de generalização de outro caso de uso.
Os diferentes tipos de passos dos caso de uso estão representados por as classes PassoOperacão, Ramificacão, IncluiCasoUso e SessaoGeneraliza respectivamente.
Um passo simples pode estar associado com uma condição (representada por a classe Restricao), que deve ser verdadeira para que o passo seja executado, e/ ou com um atraso (representada por a classe Atraso).
A condição para o passo pode ser descrita através das palavras-chave (classe PontoExtensao).
Atraso: Representa o tempo que o sistema deve aguardar para a execução de um passo do caso de uso.
PassoOperacao: Esta classe representa passos que são operações.
Uma operação pode ser executada por um ator do ambiente, através de um gatilho, ou por o próprio sistema, através de uma reação.
Portanto uma operação pode ser um gatilho, representado por a classe Gatilho ou pode ser uma reação, representada por a classe Reacao.
Um passo de operação pode estar associado com uma ou mais alternativas (representada por a classe Alternativa).
Gatilho: O gatilho é uma operação disparada por um ator do sistema.
Reacao: A reação é uma operação disparada por o próprio sistema.
Ramificacao: Esta classe representa passos que são ramificações.
Um passo de ramificação inclui a referência para um passo i, de forma que o fluxo de eventos do caso de uso seja desviado para o passo i.
IncluiCasoUso: Esta classe representa um passo do caso de uso que inclui um outro caso de uso.
Este passo representa a realização de um relacionamento de inclusão entre um caso de uso e o caso de uso incluído referenciado no passo.
SessaoGeneraliza: Esta classe representa um passo do caso de uso que generaliza um outro caso de uso.
Esta classe permite a relação de generalização entre os casos de uso, ou seja, possibilita representar que um caso de uso generaliza outros casos de uso.
DescricaoCasoUsoExtensao: Esta classe representa a descrição do caso de uso de extensão.
A descrição do caso de uso de extensão é constituída por um conjunto de partes (representadas por a classe Parte).
Parte: Representa uma parte do caso de uso de extensão.
É nestas partes que se encontram as descrições dos passos do caso de uso (representados por a classe PassoCasoUso).
Cada parte do caso de uso de extensão está relacionada com um ou mais pontos de extensão (representados por a classe PontoExtensao).
CasoUsoExtensao: Representa o caso de uso de extensão.
É constituído por a descrição do caso de uso de extensão (definido por a classe DescricaoCasoUsoExtensao).
Participante: Esta classe representa o sistema ou o ator que interage com os casos de uso.
Existem dois tipos de participantes:
Sistema (representado por a classe Sistema) e Ator (representado por a classe Ator).
Sistema: Esta classe representa o próprio sistema, que reage a operações disparadas por o ator do caso de uso.
Ator: Esta classe representa os atores do caso de uso.
RequisicaoMudanca: Esta classe representa as informações da Requisição de Mudança que devem alterar uma ou mais aplicações de software.
Esta classe deve conter informações como: Qual
a origem da requisição de mudança, a data em que foi submetida, a sua descrição, o seu objetivo, a data em que as mudanças devem ser entregues aos clientes, a prioridade de implementação, o título, a pessoa que irá verificar se a mudança foi atendida, o autor da requisição de mudança, entre outras informações.
Em esta seção é apresentado como o Modelo Conceitual se propõe a atender aos requisitos identificados na seção 4.1.2.
Os requisitos da aplicação podem estar relacionados com mais de uma aplicação:
Isto é possível através do relacionamento entre as classes Aplicacão e RequisitoAplicacão que determina que uma aplicação pode estar associada com nenhum ou vários requisitos de aplicação, e que os requisitos de aplicação devem estar associados com pelo menos uma aplicação, podendo estar associados com mais de uma aplicação.
A vantagem desta característica é que ela permite o reuso dos requisitos.
Considerando o exemplo de um requisito funcional representado por o caso de uso &quot;Entrar no Sistema «demonstrado na Figura 1 da seção 2.4.3, este caso de uso pode estar associado com duas ou mais aplicações que possuam a mesma funcionalidade para registrar os seus usuários.
Esta característica auxilia no atendimento dos requisitos 1 e 3.
O reuso dos requisitos por mais de uma aplicação facilita a análise de impacto.
Por exemplo, uma vez que se identifique que uma requisição de mudança afetou um requisito associado com mais de uma aplicação, já se sabe que estas aplicações foram afetadas por a mudança.
Sem este recurso teria que se identificar todas as instâncias do requisito relacionados com cada aplicação.
O reuso dos requisitos também auxilia no suporte a consistência e atualização dos requisitos (requisito 3), pois uma vez alterado o requisito, a modificação já refletirá para todas as aplicações associadas, sem a necessidade de replicação das modificações.
Ligação entre requisição de mudança e requisitos de aplicação:
Esta ligação se dá através dos relacionamentos &quot;Adiciona», &quot;Altera «e &quot;Remove «entre a classe RequisicaoMudanca e RequisitoAplicacao.
O relacionamento &quot;Adiciona «determina que uma requisição de mudança pode adicionar requisitos de aplicação.
O relacionamento &quot;Altera «determina que uma requisição de mudança pode alterar requisitos de aplicação.
E o relacionamento &quot;Remove «determina que uma requisição de mudança pode remover requisitos de aplicação.
Através destas ligações é possível se obter a rastreabilidade das mudanças dos requisitos de aplicação a fim de se ter informações tais como a partir de qual requisição de mudança um determinado requisito surgiu, foi removido ou alterado.
Essa rastreabilidade, unida com um controle de versão dos requisitos, fornece o histórico da evolução da aplicação.
Esta característica auxilia no atendimento dos requisitos 1, 3, 4 e 5.
A rastreabilidade entre as requisições de mudanças e os requisitos de aplicação e o histórico dos requisitos de aplicações auxiliam na análise de impacto.
Uma vez identificado que um determinado requisito foi afetado por uma requisição de mudança, o sistema fornece o histórico de mudanças que afetaram este requisito no passado, junto com os outros requisitos que também foram afetados por a mesma requisição de mudança.
Se uma requisição de mudança do passado afetou os requisitos A e B, quando se identificar que uma nova requisição de mudança afeta o requisito A, existe a possibilidade de ela também afetar o requisito B. Esta característica também auxilia na manutenção dos requisitos atualizados e consistentes (requisito 3) em relação a as requisições de mudanças, já que permite identificar os requisitos de aplicação que foram afetados por uma requisição de mudança e de que forma eles foram afetados.
Esta característica atende ao requisito 4 (rastreabilidade das mudanças dos requisitos de aplicação).
A rastreabilidade entre requisições de mudanças e requisitos de aplicação afetados é essencial para que seja possível o rollback das alterações feitas por uma requisição de mudança (requisito 5).
Detalhes de como esta solução suporta o versionamento dos requisitos de aplicação podem ser encontrados na seção 4.2.4.
Representação dos casos de uso como um conjunto de elementos:
Conforme descrito na seção anterior, a classe CasoUso é constituída por um conjunto de classes, tais como, pré-condições (classe PreCondicao), pós-condições (classe PosCondicao), passos do cenário principal e dos cenários alternativos (classe PassoCasoUso), Atores (classe Ator), Ponto de Extensão (classe PontoExtensao), entre outros.
Essa granularidade permite uma verificação de consistência mais eficaz, já que é possível por exemplo, relacionar a pré-condição do caso de uso &quot;Submeter Pedido «com a póscondição do caso de uso &quot;Entrar no Sistema «como ilustrado na Figura 1 da seção dos requisitos atualizados e consistentes.
Representação da relação de inclusão entre os casos de uso:
Esta relação está representada por o relacionamento entre as classes IncluiCasoUso, que é um tipo de passo (IncluiCasoUso é a especialização da classe PassoSimples), com a classe CasoUsoNormal.
Ou seja, o caso de uso que inclui possui um passo cujo tipo é de Inclusão.
O caso de uso incluído é representado por a classe CasoUsoNormal.
A representação do relacionamento de inclusão entre os casos de uso também auxilia na garantia da consistência (requisito 3).
Por exemplo, se uma requisição de mudança afeta um caso de uso que inclui outro caso de uso, dependendo do tipo de mudança, o analista precisa verificar se a inclusão ainda é válida, ou se alguma mudança deve também ser feita no caso de uso incluído.
Tendo o relacionamento devidamente mapeado, esta análise é facilitada.
Esta característica também auxilia no suporte à análise de impacto.
Mais detalhes podem ser verificados na seção 4.2.2 (Regras de consistência).
Representação da relação de extensão entre os casos de uso:
Esta relação está representada por o relacionamento entre as classes PontoExtensão do caso de uso extendido e a classe Parte, que é o conjunto de passos do caso de uso que extende.
A representação do relacionamento de extensão entre os casos de uso, por os mesmos motivos que o relacionamento de inclusão, auxilia no suporte à consistência dos casos de uso (requisito 3).
Esta característica também auxilia no suporte ao requisito 1.
Mais detalhes podem ser verificados na seção 4.2.2 (Regras de consistência).
Representação da relação de generalização entre os casos de uso:
Esta relação está representada por o relacionamento entre as classes SessaoGeneraliza, que é um tipo de passo (SessaoGeneraliza é a especialização de PassoSimples) com a classe CasoUsoNormal.
Em este caso, o caso de uso mais genérico possui um passo que é uma sessão de generalização.
Esta sessão se liga com o caso de uso especializado, representado por a classe CasoUsoNormal.
Assim como o relacionamento de inclusão e extensão, o relacionamento de generalização também facilita o suporte à consistência das informações dos casos de uso (requisito 3).
Esta característica também auxilia no suporte ao requisito 1.
Mais detalhes podem ser verificados na seção 4.2.2 (Regras de consistência).
Representação da relação por pré e pós-condições entre os casos de uso:
Representada por a relação entre as classes PreCondicão e PosCondicão, esta relação possui a restrição &quot;DescricaoCasoUsoNormal distintos «que define que ela só é possível entre casos de uso distintos.
Isto deve- se ao fato que a pré-condição de um caso de uso só pode estar relacionada com a pós-condição de outro caso de uso, e não com a pós-condição do próprio caso de uso.
As classes PreCondicão e PosCondicão herdam os atributos Objeto e Estado da classe Restricao.
A descrição das pré e póscondições do sistema proposto é definida da forma &quot;Objeto&quot;+ Estado.
Sendo que quando uma pré-condição de um caso de uso A é relacionada com a pós-condição de um caso de uso B, o sistema determina que esta pré-condição é formada por o mesmo &quot;Objeto «e &quot;Estado «da pós-condição do caso de uso B, permitindo apenas que o analista complemente a definição do &quot;Estado «com algum comentário ou definição que julgue necessário.
Este relacionamento por pré e pós-condições auxilia no suporte à consistência (requisito 3) e na análise do impacto das requisições de mudanças.
Detalhes sobre como esta característica auxilia no suporte à consistência podem ser obtidos na próxima seção.
Em relação a a analise de impacto, uma vez que uma requisição de mudança altere um caso de uso cuja pós-condição é pré-condição de outro caso de uso, este outro caso de uso também deve ser revisado, pois dependendo da mudança, também pode ser afetado.
A partir de a definição do Modelo Conceitual, partiu- se para a definição das regras de consistência que devem ser respeitadas por o sistema de gerência de requisitos que siga o modelo proposto neste trabalho.
Estas regras de consistência apóiam a solução no atendimento do requisito 3, identificado na seção 4.1.2.
O requisito 3 determina que os requisitos de aplicações devem ser atualizados e estarem consistentes para refletirem as alterações das requisições de mudança.
Fig gura 7.
Rem moção de um m caso de uso relacionad do por Pós-condição.
Figur ra 8 que se e o caso de d uso &quot;Cria ar Crediário para Clie ente «for re emovido, o sistem ma deve ta ambém rem mover o caso o de uso &quot;V Verificar Cadastro do Cliente em o «porque o mesmo não tem relação o com ator e nem com nenhum ou utro caso de uso.
O sis stema deve remover tam mbém o cas so de uso in ncluído, caso o mesmo não possua relaç ção com ato or ou com nenhum ou utro caso de e uso.
Veja na Figura 9 que se o passo o que do ca aso de uso &quot;Criar Cred diário para Cliente «qu ue inclui o caso de uso &quot;Ver rificar Cada astro do Cliente no SP PC «for rem movido, o sistema dev ve também remo over o caso de uso «Ver rificar Cada astro do Clie ente no SPC Figur ra 9.
Remoç ção do passo o de um cas so de uso rel lacionado por p Inclusão o.
Para cada caso de d uso que estende o c caso de uso o sendo rem movido, o si istema deve remo over- lo, caso o o mesmo não n possua relação com m ator ou com o om nenhum m outro caso de us so.
Um exem mplo é dem monstrado na a Figura 10.
Fi igura 10.
Re emoção de um u caso de uso relacio onado por Extensão.
O siste ema deve re emover tam mbém o caso de uso qu ue estende, caso o mesmo não n possua relação com m ator ou com m nenhum outro caso d de uso;
Figu ura 11.
Rem moção de um m caso de us so relaciona ado por Gen neralização.
Para o ve ersionamen nto dos requ uisitos foi utilizado o conceito de Revisão[ C A ca ada alteração o de um req quisito de aplicação, o sistema de e gerência de d requisitos s deve criar uma nova revisã ão.
A revisã ão é um num mero que rep presenta o estado do re equisito dep pois de uma sação.
Send do que a tra ansação pod de ser de cr riação do re equisito, alte eração ou remoção do trans mesm mo.
Se um elemento de um u caso de uso (requis sito funcional), como por exemplo o, um passo, é alte erado, uma nova revisã ão do caso de uso é ge erada.
Esta revisão está á associada a com todos os elementos qu ue compõem m o caso de uso u no mom mento da tra ansação.
Quando um requisit to é criado ele está au utomaticam mente associ iado com a revisão de ero 1.
Se ele sofrer qua alquer tipo de d alteração o, o sistema a automatica amente criar rá a revisão núme de nú úmero 2, e assim con nsecutivame ente.
Cada requisito com o ontém sua própria num meração de revis são, ou seja, a numeração não é ún nica entre os s requisitos.
Quando uma requisição de mu udança cria ou altera um u requisito o uma nova a revisão do requi isito é gera ada, e a req quisição de e mudança é associada à esta no ova revisão o, conforme most tra a Figura a 12.
O objeto Requisi itoAplicacão o1 foi criad do por a Req quisicaoMudanca1 e a revis são de núme ero 1 foi cr riada.
Quando o mesm mo requisito RequisitoA Aplicacao1 foi f alterado por a RequisicaoMudanca2 2, a revisã ão de num mero 2 fo oi criada.
O estado do objeto Requ uisitoAplica acao1 assoc ciado com a revisão d de número 1 é mantid do para his stórico.
Isto perm mite que o analista saib ba exatamen nte qual o estado do requisito após as modificações de uma determinad da requisição de mud dança.
O sistema dev ve permitir que o ana alista possa alizar o esta ado do requi isito em cad da revisão.
Este recu urso de vers sionamento viabiliza o armazenam mento do histórico da evolução da aplic cação, confo orme descr rito no requ uisito 4 da a seção 4.1.2.
Mais de etalhes em relação a o recur rso de versi ionamento serão forne ecidos nos e exemplos que q demons stram os res sultados no próxi imo capítulo, seção 5.3 rações fina ais O requis sito 1, que consiste na identificaçã ão dos requi isitos afetad dos por uma a requisição de m mudança, fo oi atendido o parcialmente.
A solu ução propo osta auxilia a na identif ficação dos requi isitos, consi iderando qu ue mostra ao o analista to odos os requ uisitos das aplicações e como eles estão o relacionad dos, inclusiv ve propondo o novos rela acionamento os:
Por pré e pós-condi ições e por o histó órico de mu udanças.
Por rém a ident tificação com o ontinua send do manual.
Uma vez identificado que uma requisição de mu udança afeta a um caso de uso esp pecífico, o modelo para o oposto pode auxil liar na ident tificação do os outros ca asos de uso afetados a partir de o hi istórico de mudanças tamb bém das dep pendências entre os cas sos de uso.
O requisito 3, que corresponde e à manuten nção dos req quisitos atualizados e consistentes confo forme as re equisições de mudanç ças também m foi parcialmente at tendida pel la solução.
Parci ialmente po orque apesar de supo ortar a atua alização e consistência dos requ uisitos, este mode elo não con nsidera o est tado da requ uisição de mudança par ra só efetiva ar as alteraç ções a partir de o m momento em m que a requ uisição de mudança seja a entregue ao a usuário.
O requisito 4, que consiste em manter a rastreabilidade das mudanças dos requisitos de aplicação foi totalmente atendido por esta solução através do Modelo Conceitual e também do recurso de versionamento.
O requisito 5, que consiste em suportar o rollback das alterações feitas por uma requisição de mudança foi atendido parcialmente por o relacionamento entre a requisição de mudança e os requisitos de aplicação.
Com esta rastreabilidade é possível recuperar o estado anterior a uma requisição de mudança.
O requisito 2, que trata do gerenciamento da concorrência dos requisitos de aplicação serão tratadas como trabalho futuro.
Estas considerações em relação a o escopo atendido por esta solução serão ilustradas no próximo capítulo.
Este capítulo visa apresentar a avaliação do modelo proposto.
Para viabilizar esta avaliação foi desenvolvido um protótipo que será descrito na seção 5.1.
Após o desenvolvimento do protótipo, fez- se um levantamento de todos os cenários relevantes ao contexto deste trabalho, considerando todas as peculiaridades desta solução.
Considerando os cenários, selecionou- se três sistemas hipotéticos para utilizar- los nas demonstrações.
Estes exemplos estão descritos na seção 5.2.
As demonstrações de como o sistema se comporta nos diversos cenários estão apresentadas na seção 5.3.
Com o objetivo de auxiliar a avaliação do modelo proposto neste trabalho, um protótipo de software foi desenvolvido.
A implementação iniciou com a escolha da arquitetura e das linguagens para a implementação do protótipo.
Foi definido que a persistência seria feita num banco de dados, com a entrada de dados feita através de uma interface gráfica.
Assim, optou- se por a arquitetura em três camadas, no modelo MVC (Model View Control).
Microsoft C&amp;. Net foi a linguagem de implementação utilizada para as camadas de dados, controle e interface.
Já para a camada de persistência, que dá suporte a camada de dados, foi utilizado o banco de dados Microsoft Access.
Estas escolhas foram feitas por sua grande utilização tanto no meio acadêmico como no meio industrial, por experiências de sucesso alcançadas anteriormente, por a disponibilidade das ferramentas e, também, por a facilidade de integração entre o banco de dados e a linguagem definida.
Os documentos do protótipo criados (Modelo de Casos de Uso, Especificação dos Casos de Uso e Diagrama de Classes) podem ser encontrados no Apêndice I. Com o propósito de avaliação da solução apresentada neste trabalho através do protótipo, definiu- se um exemplo hipotético envolvendo três sistemas.
Segue a descrição do que se tratam estes sistemas para melhor compreensão dos resultados que serão apresentados na posterior (seção 5.3).
Este sist tema tem como objet tivo possibi ilitar a ven nda online de produto os de uma empr resa.
O sist tema realiza ao atendim mento ao cli iente, permi itindo que o mesmo selecione os produ utos e solicite compraz- los.
Para so olicitar a com mpra dos pr rodutos, o cliente deve e informar o códig go de cada produto.
Qu uando infor rmado o cód digo, o siste ema verifica a se o produ uto não está no oferta e caso o esteja, o sistema calc cula o desco onto no preç ço.
Caso o cliente seja a um cliente espec cial da loja o sistema calcula um desconto em m cima do preço total da compra.
O controle do pa agamento dos d produtos é feito atr ravés da int terface com outro sistema chamad do &quot;Sistema de Pa agamento».
O sistem ma permite que q o cliente acompanh he o andam mento do seu u pedido e que q cancele o me esmo caso queira desist tir da compr ra.
O sistem ma recebe o os produtos de seus fo ornecedores s e entrega os produto os aos seus clien ntes através de uma tr ransportado ora.
A cota ação de pre eços dos pr rodutos e c compra dos produ utos dos for rnecedores é feita por outro sistem ma &quot;Sistema a de Compr ra de Fornec cedores».
A Figur ra 13 abaixo o ilustra o modelo de casos de uso o deste siste ema.
A espe ecificação de cada caso de us so pode ser encontrada no Apêndic ce II deste trabalho.
O sistem ma de pagam mento tem com o omo propós sito permitir r que o clien nte efetue o pagamento para a empresa.
O cliente pode efetuar r o pagamen nto de três formas:
Com cartão de crédito:
Com cheque e:
Em este caso o cliente deve inform mar os dados s do cheque e.
O sistema verifica o crédito do cliente jun nto ao SPC C e em ca aso positivo o efetua o pagamento;
E dinheiro Em o:
O sistema a solicita qu ue o funcio onário infor rme a quant tia recebida em m dinheiro.
O sistema efetua o pag gamento.
A Figura a 14 ilustra o modelo de d casos de e uso deste sistema.
A especificaç ção de cada de ser encon ntrada no Ap pêndice II deste trabalh ho.
Este é um u sistema online cuj jo objetivo é permitir r que o funcionário d da empresa subm meta requisi ições de com mpra aos se eus fornecedores a fim m de atender r aos pedido os dos seus clien ntes.
O sist tema permi ite que os fornecedor res informe em suas com o otações de preços de produ utos e entã ão submetam m propostas s que atend dam as requ uisições de compra env viadas por a empr resa.
O func cionário da a empresa pode então aceitar a proposta envi iada por o fo ornecedor e enfim m efetuar a compra d do mesmo.
A Figura 1 15 ilustra o modelo de d casos de e uso deste sistem ma.
A espe ecificação de d cada ca aso de uso pode ser encontrada no Apêndi ice II deste traba alho.
Figu ura 15.
Siste ema de Com mpra de For rnecedores.
Pode- se perceber que além de as relaç ções descritas por a UML, tam mbém estão ident tificados os s relacionam mentos por r pré e pós s-condições conforme apresentado na seção to de ilustra ação, os rela acionamento os por pré e pós estão identificado os de forma gráfica.
Porém é important te ressaltar que não est tá sendo para o oposta uma a extensão da d UML.
A esentação gr ráfica deste es relaciona amentos por r pré e pós-condições é apenas pa ara auxiliar repre na com o ompreensão o dos exemp plos.
Conform me descrito na n seção 4.1.2 do capít tulo anterio or, dos cinco o requisitos s listados, a soluç ção apresen ntada neste trabalho se propõe a re esolver quat tro:
Requisit tos 1, 3, 4 e 5.
Seguem abaix xo demons strações a partir de cenários, utilizando o sistemas da seção os o 5.2 para exem mplificação, de como o sistema a atende es stes requisi itos.
O sis stema de gerência de requi isitos está re epresentado o por o protó ótipo desenv volvido.
Em esta seç ção serão mostrados ce enários ilustrando com mo o sistema a atende o requisito atrav vés do cadas stro de requ uisições de mudança e da identificação dos requisitos de aplicação que s são afetados s por as mesm mas.
A Figura a 17 mostra à tela do protótipo onde o anal lista deve preencher os dados da requi isição de mudança.
Após preenc cher os dad dos de a requ uisição de mudança e salvar- la, o anali ista deve id dentificar os s requisitos s de aplicaç ção que a requisição de d mudança a modifica.
Para esta identif ficação, o sistema forn nece as opçõ ões para ide entificar os casos de u uso afetados (atrav e identific vés do bot tão &quot;Identif ficar Casos s de Uso Afetados&quot;) car os requ uisitos nãofunci ionais afet tados (atra avés do bo otão &quot;Iden ntificar Req quisitos Não Funcion nais Geral Afeta ados&quot;).
Com mo esta req quisição de mudança se s trata da adição de novas funci ionalidades, neste e exemplo o analista de eve selecion nar a opção &quot;Identificar r Casos de Uso U Afetado os».
Figu ura 17.
Cada astro da Requisição de Mudança.
Quando o analista seleciona a opção de identificaç ção dos cas sos de uso afetados o sistem ma mostra uma u tela com as seguin ntes informa ações:
Árvore &quot;Aplicação x Casos de d Uso&quot;:
O primeiro nível de el lementos desta árvore conté ém lista de todas as aplicações cad dastradas no os sistema.
Conforme pode ser ob bservado na Figur ra 18, as ap plicações de escritas na seção Sistema de Vendas, Sistema de Pa agamento e Siste ema de Cota ação de Ped didos com Fornecedore es) estão cad dastradas no o sistema.
Em o N segundo nível l da árvore estão os ca asos de uso o pertencent tes a cada aplicação.
Para cada caso de uso listad do, o sistem ma gera três s sub-árvore es com os casos de uso o incluídos (sub-árvore &quot;Inclui&quot;), que extendem (sub-árvor &quot;re Extend dido «Por&quot;) ou que são generalizados (sub-árvore &quot;Gen neraliza&quot;) por o caso de e uso.
No caso de a aplicação &quot;Sist tema de Com o otação de Pe edidos com Forn necedores», apenas o caso de uso o &quot;Submeter r Requisiçã ão de Comp pra aos For rnecedores «está cadastrado.
Forn necedores &quot;possui uma sub-árvore «Inclui», q que mostra o caso de uso u incluído o:
&quot;Procurar Pedid do.
Os outros casos s desta apli icação serão o adicionad dos por a req quisição de muda ança cadast trada na Figura 17.
As A Figuras 21 e 22 mostram os s casos de uso sendo adici ionados.
As s Figuras 18 e 19 mostram exemplos de sub-árvore es &quot;Extendi ido «Por &quot;e «Gen neraliza «(es stas sub-árv vores só são o mostradas s quando o caso de uso o possui os respectivos relac cionamentos s).
Árvore &quot;Histórico de Mudanç ça do Caso o de Uso&quot;:
O objetivo desta árvor re é mostrar ao an nalista o histórico de modificação o de uma ap plicação ou u de um cas so de uso selecionado.
Então o quando uma aplicaç ção ou um caso de uso o da árvore e &quot;Aplicaçã ão x Casos de Uso «é selec cionado, o seu s histórico o de mudan nças é most trado na árv vore &quot;Histó órico de M Mudança do Caso o de Uso».
O primeiro nível desta a árvore con ntém a lista das requisi ições de mu udanças que afeta aram a aplic cação ou o caso de uso.
O segu undo nível contém a lista dos ca asos de uso (exce eto o caso de d uso selec cionado) af fetados por cada requis sição de mu udança.
Para a cada caso de us so selecionado na árvo ore &quot;Histór rico de Mu udança do Caso de Uso», o siste ema mostra abaix xo do caso de d uso uma sub-árvore com o seu histórico de e mudança.
Árvore &quot;Casos de Uso relaci ionados po or Pré e Pó ós-Condiçõ ões&quot;:
O obj jetivo desta árvor re é mostra ar ao analist te aos casos de uso rel lacionados por p pré e pós-condiçõ es com um caso de uso sele ecionado.
Quando um caso de us so da árvore e &quot;Aplicaçã ão x Casos de Uso «é cionado, o sistema mos stra duas lis stas com as seguintes informações s:
Os casos de uso cuja selec pós-c condição es stá relaciona ada com a pré-condiçã ão do caso de uso sele ecionado (ca asos de uso que precedem o caso de e uso selec cionado);
E os casos de uso cu uja pré- con ndição está cionada com m a pós- con ndição do caso de uso selecionad de o (casos de e uso que procedem relac caso de uso sele ecionado).
Funciona alidades de Adicionar, Editar e Remover um m caso de uso:
Cada a caso de us so seleciona ado é adicion nado à lista «Cas sos dos.
Em esta a lista o ana alista pode optar por editar ou re emover um caso de uso.
Qu uando o ana alista identif fica que par ra atender a requisição de mudanç ça um novo caso de uso deve e ser adicionado, ele de eve selecion nar o botão &quot;Adicionar Caso de U Uso».
Aba &quot;Ca asos de Uso o Afetados por a Requi isição de Mudança&quot;:
Esta aba mo ostra a lista dos c casos de uso o que foram m adicionados, alterado os ou remov vidos por a re equisição de mudança.
Um e exemplo desta funcionalidade pod de ser visto n na Figura 25.
Figur ra 20.
Tela de Casos de e Uso Afeta ados por a Re equisição de e Mudança.
Cenário 1: Voltand do ao exem mplo da Fig gura 17, em a qual foi re ealizado o cadastro da requi isição de mudança Adicionar funcionalidad des para req quisição e fechamento de compra com fornecedor r».
Após selecionada a opção de id dentificar os o casos de uso u afetado os mostrado igura 20, o próximo pa asso é adicio onar os casos de uso &quot;Submeter Proposta Requisição de na Fi Com mpra «e &quot;Ace eitar Propos sta do Forne ecedor e Ef fetuar Comp pra «para at tender à req quisição.
As Figur ras 21 e 22 2 mostram m a adição dos casos de uso &quot;Su ubmeter Pr roposta Req quisição de Com mpra «e &quot;Ac ceitar Proposta do Fo ornecedor e Efetuar Compra».
A Figura 23 3 mostra a ident tificação da a pré-condi ição do cas so de uso &quot;Aceitar Pr roposta do Fornecedor r e Efetuar Com mpra «que é vinculada c com a pós-c condição do o caso de uso &quot;Submete er Proposta Requisição de Compra».
Após ad dicionados os o casos de uso &quot;Sub bmeter «e &quot;Ace eitar Propos sta do Forne ecedor e Ef fetuar Comp pra», o siste ema atualiza à tela &quot;Ca asos de Uso Afeta ados por a Requisição d Mudança de a «como mo ostrado na Figura O casos de e uso foram adici ionados à árvore &quot;Ap plicação x Casos de Uso».
O ca aso de uso &quot;Aceitar P Proposta do Forn necedor e Efetuar Com mpra «inclui o caso de uso &quot;Pagam mento com m cartão de crédito «da aplic cação Sistem ma de Paga amento.
Qua ando o caso o de uso &quot;A Aceitar Prop posta do Fo ornecedor e Efetu uar Compra a «é selecio onado, o sis stema mostr ra a relação o por pré- com o ondição que o mesmo tem com o cas so de uso &quot;Submeter Proposta Requisição de Compra «a».
Em este caso, a prédição (&quot;Prop posta foi su ubmetida ao a funcioná ário&quot;) do ca aso de uso &quot;Aceitar Proposta do cond Forn necedor e Ef fetuar Comp pra «está relacionada com a pós-condição (&quot;P Proposta foi i submetida ao fu uncionário&quot;) do caso de e uso &quot;Subm meter Propo osta».
Com mpra».
A ún nica requisiç ção de mud dança que afetou este caso de us so foi a req quisição de muda ança &quot;Adic cionar fun ncionalidade es para re equisição e fechamen nto de compra com forne ecedor».
Ab baixo da re equisição de d mudança ao sistema a mostra os s outros ca asos de uso afeta ados por a mesma.
Nes ste caso, a requisição de mudanç ça também afetou o caso de uso &quot;Sub bmeter».
Para o oposta do Fornecedor e Efetuar Com o ompra».
Cenário 2: Outro ce requi isitos afetad dos por um ma requisição de mud dança é ilustrado nas Figuras 26 6, 27 e 28.
Diga amos que o analista re eceba uma requisição de mudanç ça descrevendo que o usuário do Siste ema de Ven ndas não precisa mais estar auten nticado no sistema para a submeter pedidos de comp para a conform me mostra a Figura 26.
O sistema informa, na a Figura 27, que a pré-c condição do caso de uso &quot;Su ubmeter «está re elacionada com a pós-condição do o caso de uso &quot;Efetuar Login».
Em este caso, para ate ender esta requisição de mudança a deve- se re emover a pr ré-condição aso de uso &quot;Submeter r Pedido «que q está vin nculada com m a pós- con ndição do caso de uso do ca &quot;Efet tuar&quot;».
A Figura 28 mostra como ficam m as relações s por pré e pós-condiçõ ões do caso de us so &quot;Submeter Pedido «após as modificações p para atender r a requisiçã ão de mudan nça.
Objeto da pós s-condição sel lecionada aba aixo.
Estado da pós s-condição sel lecionada abaixo.
Fig gura 23.
Iden ntificação da d pré-condi ição do caso o de uso &quot;A Aceitar Proposta do For rnecedor e Efetuar Com mpra».
Fig gura 24.
Casos de Uso Adicionado os por a Requ uisição de Mudança.
Figur ra 25.
Caso os de Uso afetados pe ela Requisiç ção de Mud dança &quot;Adic cionar funcionalidades para requisição e fechamen nto de compra com forn necedor».
Fig gura 26.
Requisição de e Mudança &quot;Usuário nã ão precisa es star autentic cado no sist tema para sub bmissão de pedido».
Fig gura 27.
Requisição de e Mudança &quot;Usuário nã ão precisa es star autentic cado no sist tema para sub bmissão de pedido».
Figur ra 28.
Requ uisição de Mudança &quot;Usuário nã ão precisa estar autenticado no si istema para subm missão de pe edido «atend dida.
Cenário 3: Outro ce enário a ser demonstrad do é quando o o analista recebe uma a requisição de m mudança que e tem como conseqüênc cia a remoção de casos s de uso.
Em o exem mplo da Figu ura 29 o ana alista receb beu duas req quisições de e mudança.
A primeira descr revia que o sistema de pagamento não devia mais m permit tir o pagamento com ch heque.
Para esta requisição s atendida ser a, o caso de uso &quot;Efetu uar «foi re emovido.
A segun nda requisição de mud dança receb bida descrev via que o sistema não devia mais s permitir a criaç ção de credi iários.
Para a esta requis sição ser at tendida, o caso de uso &quot;Criar Cre ediário «foi rem movido.
Re espeitando a regra de e consistên ncia 3 descr rita na seção 4.2.2, o sistem ma também m removeu o caso de uso &quot;Verifi ficar Cadast tro do Clien nte no SPC C».
Deve- se obser rvar que o sistema não o remove os casos de uso u fisicam mente.
Os ca asos de uso removidos conti inuam dispo oníveis para a consulta.
Cenário 4: Segue um u outro cen nário para ilustrar com mo a propost ta auxilia na a análise de impa acto.
Supon ndo- se que chegue um ma requisiç ção de mud dança com a seguinte e descrição &quot;Fun ncionário de eve garantir que a proposta do forn necedor con ntém o preço o de cada pr roduto com o pre eço à vista e com o preço a praz zo.»
Consid derando que e esta requi isição trata- se de uma muda ança no rec cebimento da d proposta do forneced dor, o analista deve ide entificar qu ue o caso de uso &quot;Aceitar Pr roposta do Fornecedor r e Efetuar Compra «pode sofrer uma altera ação.
Sendo que o caso de us so &quot;Aceitar Proposta do o Fornecedo or e Efetuar r Compra «está e relacion nado com o caso de uso &quot;S Submeter Proposta Re equisição&quot; «(ver Figu ura 24), exi iste grande proba abilidade da a alteração também afe etar este cas so de uso.
Ambos os ca asos de uso manipulam o me esmo objeto &quot;proposta&quot;», que é alvo o da requisiç ção de mud dança recebi ida.
Como já á foi demon nstrado nos exemplos ilustrados na n seção an nterior como o o sistema mant tém os requ uisitos atual lizados de acordo com m as requisiç ções de mudanças, nes sta seção se dará enfoque a como o sis stema mant tém a consi istência des stes requisit te os (requisi ito 3).
Este alho se prop põe a suport tar a consist tência respeitando as re egras aprese entadas na seção 4.2.2.
Para exe emplificar a regra de consistência 1, que descreve qu ue o sistema não deve perm mitir a remoç ção da pós-condição de e um caso de d uso que está e associad da com a pr ré-condicão de ou utro caso de e uso, segue nas Figura as 30, 31 e 3 Conform me mostra a Figura 30, a pós- con ndição do caso de uso &quot;Submeter r Pedido «é pré-c condição do os casos de e uso &quot;Proc curar Pedid do, «Subm meter Requi isição de Compra aos Forn necedores», &quot;Verificar Pedido «e &quot;Cancelar Pedido».
Se o analista receber uma a requisição de m mudança e identificar q para at que tender- la dev ve remover r a pós- con ndição do caso de uso &quot;Sub bmeter», o siste ema mostra ará uma me ensagem de erro inform mando que a operação não é possível conforme mo ostra a Figu ura 32.
Figur ra 31.
Edição caso de &quot;Uso U Subme eter «ra 32.
Men nsagem de erro na re emoção da pós-condiç ção do cas so de «Uso Submeter Figur Pedid do.
A regra de consistê ência 2, qu ue descreve que o siste ema de gerê ência de req quisitos não deve permitir a remoção de e um caso de e uso cuja pós-condiçã ão é pré- con ndicão de ou utro caso de ada na Figur ra 33.
A regra de consistê ência 3, que e descreve que q o sistem ma, na remoção de um caso de uso deve remover ta ambém o ca aso de uso incluído, ca aso o mesmo o não possu ua relação com ator ou utro caso de e uso, já fo oi demonstr rada no exe emplo da Fi igura 29 (ce enário 3 da com nenhum ou o anterior).
A regra de d consistên ncia 4 é mu uito semelh hante à regr ra 3 com a exceção de seção que a remoção é de um passo do cas so de uso que q inclui, e não do caso de uso o em si.
As dema ais regras não serã ão demonstr radas por se erem muito seme elhantes às regras 3 e 4, 4 com a dif ferença de tratarem dos outros tip pos de relaci ionamentos da U UML:
Extens são e Gener ralização.
O sistem ma permite q que o analis sta visualize e o histórico o de mudan nças de uma a aplicação.
Este histórico contém info ormações com o omo por qu uais requisiç ções de mu udança a ap plicação foi ada, mostran ndo, para c cada requisi ição de mud dança, quai is os requis sitos modifi icados e de afeta que f forma eles foram mod dificados.
Em esta seção será demon nstrado com mo a solução o suporta o requ uisito 4.
Em a seção o 5.3.1 foi i demonstrada a adiç ção dos cas sos de uso o &quot;Submete er Proposta Requ uisição «e &quot;Aceitar Para o oposta do Fornecedor e Efetuar Compra «par ra atender à requi isição de mudança Adicionar funcionalidad des para req quisição e fechamento de compra com fornecedor r».
Em a Figura 34 pode- se obs servar na árvore &quot;Hi istórico de Mud dança do Caso de Uso o», o histór rico da aplicação &quot;Sist tema de Com o otação de Pe edidos com Forn necedores «após as mod dificações por a p requisição de mud dança.
O pr rimeiro níve el da árvore most tra as requis sições de mudanças mu qu ue afetaram requisitos deste sistem ma.
Em o segun ndo nível, é most trada a lista a dos casos s de uso af fetados.
An ntes do nom me do caso de uso é mostrada a descr rição do tip po de modif ficação sofr rida:
Remoç ção, Alteraç ção ou Adiç ção.
Outro e exemplo de histó órico da apli icação foi mostrado na a Figura 29, com a dif ferença que ao invés de e adição de casos s de uso, neste exem mplo foi realizada a remoção de e casos de uso do &quot;S Sistema de Paga amento».
Figur ra 34.
His stórico de mudança da d aplicaçã ão &quot;Sistem ma de Cota ação de Pe edidos com Forn necedores».
Outra fun histó órico dos req quisitos.
O analista pod de visualiza ar as alteraçõ ões do requ uisito desde sua criação até su ua remoção o.
Outro ex xemplo da seção as 26, 27 e 28, foi a alteração do caso de uso &quot;Su ubmeter «para atender a requisição de d mudança a &quot;Usuário não n precisa estar r autenticado o no sistem ma para subm missão de pedido».
Em este caso, ap pós a alteraç ção do caso de us so &quot;Submete er Pedido «o sistema gerou uma nova versão do mesmo.
Este histór rico do caso de uso está ilus strado na Fi igura 35.
Quando o an nalista selecionar o bo otão &quot;Ver Versão «ele pode e visualizar os detalhes do caso de e uso associa ado com a versão da li inha em que e o botão se encontra, confor rme mostra ado na Figur ra 36.
Nest ta figura pode- se obser rvar que o caso de uso na su ua primeira versão tinh ha a pré- con ndição &quot;Usu uário&quot;».
Enquanto que n na sua segun nda versão esta pré- con ndição foi r removida.
Em este mo odelo propo osto, cada ve ersão do caso de uso está associad da com uma a requisição de mudança, exc ceto se o ca aso de uso não n foi criad do na fase de d manuten nção da aplicação.
Para cada requisição de mudanç ça que afeta a requisitos, uma nova a versão de cada requis sito afetado será gerada e a rastreabilid dade entre a requisição o de mudanç ça e a nova a versão do requisito é mant tida.
Fig gura 36.
Det talhes das versões do Caso de Uso o &quot;Submeter r Pedido».
Uso O model lo proposto também pr rovê a possibilidade de e reuso dos s casos de uso u entre as diver rsas aplicaç ções que auxilia no ate endimento dos d requisit tos 1 e 3.
Em o N Modelo Conceitual apres sentado na seção, um caso de e uso pode estar associ iado com um ma ou mais aplicações.
Em esta a seção será á apresentad do um exem mplo de com mo o sistema a suporta es ste reuso.
Em a Figur ra 37 o caso o de uso &quot;S Submeter R Requisição de d Compra aos Fornec cedores «da aplic cação &quot;Siste ema de Com mpra «&quot;inclui o caso de uso «Procurar Pedido &quot;de a aplic cação «Siste ema de Vendas».
De a mesma forma a, um caso de d uso de uma aplicaçã ão pode ser esten ndido ou gen neralizado por p um caso o de uso de outra aplica ação.
A Figura a 38 mostra outro exem mplo de reus so, porém através do relacioname ento por pré e pós s-condições s.
O caso de d uso &quot;Sub bmeter «da apli icação &quot;Sis stema «está relac cionado por r sua pós- com o ondição com m o caso de e uso &quot;Subm meter Requ uisição de Compra aos Forec cedores «da a aplicação &quot;Sistema de e Compra d de Fornecedores».
Fi igura 37.
Ex xemplo de inclusão de caso de uso o de outra ap plicação.
Fig gura 38.
Req quisição de Mudança &quot;a atendida».
Em este capítulo demonstrou- se como o protótipo, instância do modelo de gerência de requisitos proposto neste trabalho, suporta a análise do impacto das requisições de mudança sobre requisitos de diversas aplicações, a atualização, e a manutenção da consistência destes requisitos.
Os exemplos demonstraram como a solução atende o requisito 1, que trata da identificação dos requisitos afetados por uma requisição de mudança (análise de impacto), o requisito 3, que consiste na manutenção dos requisitos atualizados e consistentes conforme as requisições de mudanças, e o requisito 4, que se refere a como manter a rastreabilidade das mudanças dos requisitos de aplicação, definidos na seção 4.1.2 deste trabalho.
Embora não tenham sido apresentados todos os exemplos possíveis da aplicação do modelo proposto neste trabalho, os apresentados contribuíram facilitando a visualização da proposta e comprovando seu funcionamento diante de os objetivos inicialmente propostos.
Mais ilustrações de telas do protótipo podem ser observadas no Apêndice III.
O próximo capítulo apresenta as considerações finais obtidas com o desenvolvimento desta dissertação.
A engenharia de requisitos é uma das atividades críticas e mais importantes do processo de desenvolvimento de software, visto que é a partir de ela que o sistema final será desenvolvido.
Atualmente, é tida como um dos principais desafios na engenharia de software e como a principal razão de muitas das falhas ocorridas nos sistemas.
A manutenção e evolução do software caracterizam- se por demandarem custo muito alto das organizações.
Se na fase de evolução do software os requisitos não forem eficientemente gerenciados, muito tempo pode ser demandado para a manutenção e, no pior caso, informações sobre funcionalidades importantes do sistema podem ser perdidas.
Em este contexto, o tema abordado nesta dissertação busca auxiliar a atividade de gerência dos requisitos durante a evolução do sistema de software através de um modelo de sistema de gerência de requisitos que suporte a atualização e a consistência dos requisitos de software afetados por requisições de mudança.
O sistema de gerência de requisitos proposto, instanciado através do protótipo apresentado no Capítulo 5, fornece as seguintes principais funcionalidades:
Manter a rastreabilidade entre requisições de mudanças e os requisitos afetados por as mesmas;
&quot;generaliza&quot;) e por pré e pós-condições;
O registro do histórico dos requisitos desde a sua criação até o seu término;
E o reuso entre requisitos de diferentes aplicações.
Com estas funcionalidades, descritas no capítulo 4 e demonstradas no Capítulo 5, pode- se afirmar que o objetivo geral desta pesquisa foi atingido.
O referencial teórico, apresentado no Capítulo 2, surgiu devido a a pesquisa bibliográfica realizada sobre o tema, onde os principais pontos foram considerados e apresentados.
O estudo de caso exploratório realizado na empresa auxiliou na compreensão do problema e na identificação das principais dificuldades envolvidas.
A instanciação do modelo proposto através do protótipo e o detalhamento do seu comportamento perante os diferentes cenários levantados através dos sistemas de exemplos, apresentados no Capítulo 5, permitiram avaliálo para a confirmação do alcance dos objetivos desta pesquisa.
Uma das principais contribuições desta pesquisa é a possibilidade de manter os requisitos de aplicações de software atualizados ao longo de a sua evolução.
Os sistemas de gerência de requisitos existentes atualmente no mercado são orientados a projeto.
Uma vez terminado o projeto, os requisitos tendem a serem esquecidos e não mais atualizados.
Com o modelo de gerência apresentado é possível se obter o histórico de cada requisito de aplicação desde sua criação até o seu término (desativação do ambiente de produção do software).
Além de auxiliar na manutenção dos requisitos atualizados, uma outra importante contribuição é o suporte à consistência dos requisitos funcionais representados por casos de uso.
No geral os casos de uso são definidos por os analistas de software como texto livre, sem muitas regras de formação.
Em o modelo apresentado neste trabalho o caso de uso é representado por sub-elementos (ator, pré-condições, pós-condições, passos da sequência básica, etc) que auxiliam o analista na descrição dos casos de uso.
O modelo também suporta regras de consistência nos relacionamentos entre os casos de uso:
Inclusão, estensão e generalização, definidos por a UML, e por pré e pós-condições proposto neste trabalho.
Este modelo também traz benefícios para análise de impacto das requisições de mudanças através dos recursos que mostram o histórico dos requisitos e como os requisitos das aplicações estão relacionados.
O relacionamento por pré e pós-condições auxilia na identificação dos requisitos associados com um mesmo objeto, além de representar a ordem de seqüência de execução dos casos de uso.
Este trabalho atendeu ao objetivo ao qual se propôs, porém existem algumas limitações a serem trabalhadas:
Análise de impacto automatizada:
Apesar de auxiliar na análise de impacto, o modelo proposto só auxilia na identificação dos requisitos afetados se o analista identificar pelo menos um primeiro requisito.
A identificação de requisitos afetados por as requisições de mudanças de forma automática seria um recurso que traria muitos benefícios;
Controle de concorrência:
O modelo proposto não suporta o controle de concorrência descrito por o requisito 2 da seção 4.1.2;
Suporte ao rollback das alterações feitas por uma requisição de mudança:
Apesar de o modelo proposto suportar o rollback, não foi desenvolvido o mecanismo de rollback das alterações dos requisitos feitas para atender uma requisição de mudança.
Além de atender às limitações apontadas na seção anterior, a partir deste trabalho identificou- se algumas oportunidades de desenvolvimento de trabalhos futuros.
Por exemplo, o reuso dos casos de uso pode ser mais explorado de tal forma que o sistema verifique, quando um analista está alterando um caso de uso utilizado por mais de uma aplicação, até que ponto modificações são aceitáveis para ainda se caracterizar o caso de uso reutilizado.
Dependendo das alterações pode ser necessária a criação de outra instância do caso de uso, separando o caso de uso alterado do caso de uso comum as outras aplicações.
Em relação a o suporte à consistência mais avanços podem ser realizados no que diz respeito à definição de regras de formação e consistência na definição dos casos de uso.
Com mais regras, evita- se que casos de uso sejam descritos como texto livre, o que facilita o suporte à atualização e consistência dos mesmos por as ferramentas.
Um exemplo de nova regra poderia ser quando o analista remover a pré-condição de um caso de uso, o sistema verificaria que pelo menos um passo deste caso de uso deve ser alterado.
Outra possibilidade de trabalho futuro é a geração do Modelo de Domínio dos sistemas cadastrados a partir de os conceitos descritos nos casos de uso.
Além de o Modelo de Domínio é desejado que o sistema avance para suportar a rastreabilidade com os outros artefatos do software como Diagrama de Classes, Diagrama de Seqüência, etc.
