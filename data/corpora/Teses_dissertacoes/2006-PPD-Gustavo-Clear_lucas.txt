Um dos maiores problemas na área de computação de alto desempenho é a dificuldade de definir qual a melhor estratégia de paralelização de uma aplicação.
Em este contexto, a utilização de métodos analíticos para a avaliação de desempenho de aplicações paralelas aparece como uma alternativa interessante para auxiliar no processo de escolha das melhores estratégias de paralelização.
Em este trabalho, propõe- se a adoção do formalismo de Redes de Autômatos Estocásticos para modelar e avaliar o desempenho de aplicações paralelas especialmente desenvolvidas para máquinas agregadas (i.
e, clusters).
A metodologia utilizada é baseada na construção de modelos genéricos para descrever esquemas clássicos de implementação paralela, tais como Mestre/ Escravo, Fases Paralelas, Pipeline e Divisão e Conquista.
Estes modelos são adaptados em casos de aplicações reais através da definição de valores para parâmetros de entrada dos modelos.
Finalmente, com intuito de verificar a precisão da técnica de modelagem adotada, comparações com resultados de implementações reais são apresentadas.
Modelo SAN para Divisão e Conquista Introdução Em as últimas três décadas, a computação de alto desempenho tem se tornado uma área de pesquisa crescente da Ciência da Computação.
A razão para isto está relacionada ao grande crescimento das necessidades de poder computacional de outras áreas de pesquisa, como por exemplo Biologia, Física, Medicina, Geologia, Química, Astronomia, Engenharia, etc..
Todas essas disciplinas apresentam pesquisas de estado da arte baseadas em simulação ou técnicas de visualização as quais requerem muito mais poder computacional do que um computador monoprocessado pode prover.
Três exemplos representativos correntes deste cenário são a análise de genomas, predição de terremoto e visualização de dados médicos obtidos através de Imagens de Ressonância Magnética (IRM).
Soluções em computação de alto desempenho são fortemente dependentes da plataforma alvo.
Existem diferentes plataformas para executar programas de alto desempenho e diversas formas de desenvolver programas eficientes para estas plataformas.
Podemos citar, por exemplo, máquinas multiprocessadas muito velozes, porém com um custo muito alto, até arquiteturas do tipo grade completamente distribuídas, passando por supercomputadores vetoriais ou máquinas agregadas.
Além disso, muitas dessas máquinas são extremamente complexas de controlar, adicionando um custo de manutenção estrutural àquele de sua aquisição.
Em este cenário, máquinas agregadas começaram a ganhar popularidade desde 1995 com o projeto Beowulf.
A idéia inovadora trazida por este projeto foi a abordagem de utilização de recursos de &quot;prateleira «para criar ambientes de alto desempenho.
Agregados do projeto Beowulf podem ser definidos como uma coleção de processadores dedicados ao processamento paralelo (diferente de estações de rede) comunicando- se através da mais veloz e eficiente interconexão acessível.
Este projeto foi o ponto de começo de uma massiva difusão de arquiteturas de máquinas agregadas no mundo científico.
Devido a este baixo custo, ambientes agregados têm se tornado uma alternativa interessante para alcançar alto desempenho com um agrupamento de centenas ou até milhares de nós.
Motivação As aplicações que se pretende executar em ambientes do tipo máquinas agregadas devem ser programadas utilizando- se o paradigma de troca de mensagens, uma vez que a memória utilizada não é compartilhada entre os processadores.
Assim, saber se uma aplicação obterá um desempenho desejado em máquinas agregadas é uma questão que hoje somente pode ser respondida quando esta aplicação for executada, pois existem diversos fatores influentes no desempenho da mesma tais como o modelo de programação escolhido, a granularidade das tarefas ou até mesmo a rede utilizada.
Além disso, diversos modelos de programação surgiram no momento em que ambientes do tipo cluster começaram a ser utilizados.
Com isso, aplicações podem ser desenvolvidas de diversas formas.
Porém, saber de antemão qual modelo é o que melhor enquadra uma aplicação é outra pergunta que somente pode ser respondida através da implementação.
Em este cenário, a predição de desempenho de programas de alto desempenho surge como uma interessante alternativa para otimizar os processos de desenvolvimento de aplicações.
A análise de desempenho é baseada na construção de modelos genéricos, usando algum formalismo, para descrever cada método de implementação.
Como resultados de tal análise, deve ser possível prever o desempenho de uma dada implementação em diversos níveis, variando desde probabilidades de transmissão, porcentagem de uso dos nós, e até estimativas de tempo de execução.
Objetivos Em os últimos anos, um novo formalismo baseado em Redes de Autômatos Estocásticos (Stochastic Automata Network -- SAN) tem sido utilizado para descrever estruturas interdependentes complexas.
Este trabalho tem como objetivo realizar uma investigação aprofundada sobre a utilização do formalismo SAN para a modelagem e análise de desempenho de aplicações paralelas que se adaptem a ambientes do tipo Cluster of Workstations (COW).
A escolha do formalismo SAN baseia- se na dificuldade de encontrar outros formalismos que sejam capazes de representar comportamentos independentes de diferentes módulos que se relacionem entre si.
Estrutura do Trabalho Este trabalho está dividido como segue.
Em o próximo capítulo, alguns trabalhos relacionados são discutidos, apresentando a idéia básica de cada um e mostrando a diferença de cada formalismo estudado.
O capítulo 3 apresenta uma breve descrição do formalismo escolhido para ser utilizado ao longo deste trabalho.
O capítulo 4 introduz os modelos de programação para aplicações paralelas mais utilizados e apresenta os seus respectivos mo delos SAN genéricos (i.
e, autômatos e estados sem taxas).
As formas de parametrização desses modelos genéricos são descritas no capítulo 5.
Quatro aplicações escolhidas como estudo de caso são detalhadas no capítulo 6.
A análise e comparação dos resultados obtidos com a execução dos modelos e das aplicações paralelas é realizada na seção 7.
Por fim, a conclusão deste trabalho e possíveis trabalhos futuros são apresentados no capítulo 8.
Trabalhos Relacionados Em esta seção, alguns trabalhos relacionados são apresentados.
Primeiramente, três trabalhos que utilizam SAN para modelar e avaliar desempenho de suas aplicações são discutidos.
Mais adiante, outros formalismos que poderiam ser utilizados para modelagem de aplicações paralelas são apresentados juntamente com aspectos sobre a escolha de SAN para este trabalho.
Trabalhos que utilizam SAN Em os últimos anos, formalismos estocásticos para predição de desempenho de aplicações têm sido utilizados com mais freqüência.
Em, utiliza- se SAN para analisar interações entre agentes com sistemas baseado em componentes.
Estes modelos criados permitiram aos autores descobrir detalhes significantes no desempenho de agentes.
Mais precisamente, com modelos SAN os autores conseguiram atribuir corretamente diferenças´ da de desempenho entre agentes ou entre um agente e o ambiente em que ele reside.
E opinião dos autores que o formalismo utilizado é flexível, fácil de usar e que pôde prover uma variedade de percepções no comportamento de agentes modelados.
Maraculescu e Nandi usaram SAN para modelar aplicações de sistemas de níveis.
Este trabalho teve como objetivo apresentar uma nova metodologia para modelagem de aplicações para análise de desempenho de sistemas de níveis, a qual pode auxiliar o desenvolvedor a escolher a plataforma correta para implementação de um conjunto de aplicações multimídia.
O decodificador de video MPEG-2 foi a aplicação utilizada para ilustrar os benefícios desta metodologia.
Com o modelo SAN, os autores conseguiram mostrar que a aplicação alvo possui um comportamento estacionário através de diferentes combinações de probabilidades, o que permitiu mapeamentos eficientes da aplicação na plataforma escolhida.
Ainda, os autores consideraram SAN uma ferramenta eficiente para modelagem de comunicação de processos, e ressaltaram que este formalismo possui vantagens em relação a outros quanto a a explosão no número de estados, pois SAN não gera a cadeia Markoviana.
Em os últimos anos, serviços como vídeo ou multimídia em redes de baixa latência têm se tornando importantes e muito usados.
Em, Mokdad Apresentam um novo algoritmo de roteamento para prover uma melhor qualidade de serviço de entrega de pacotes em redes de baixa latência.
Em este trabalho, uma avaliação de desempenho de modelos SAN é realizada para mostrar os benefícios deste novo algoritmo.
Os autores lembram que o formalismo SAN é muito utilizado para sistemas paralelos complexos, situação em que o emprego de cadeias de Markov é inviável.
Outros Formalismos Muitos autores têm apresentado estudos genéricos oferecendo opções de predição de desempenho de aplicações paralelas.
A comunidade de pesquisa classifica as diferentes abordagens em três grupos bastante distintos:·
As abordagens de monitoramento, as quais são na maioria das vezes baseadas na comparação de custos de tempo de execuções de implementações;
Estas implementações podem ser tão superficiais quanto programas artificiais, ou bastante genéricos como os reconhecidos benchmarks, e.
g, whetstones, dhrystones, e LINPACK;·
As abordagens de simulação, as quais são baseadas no uso de uma ferramenta computacional para descrever e simular o comportamento de uma dada implementação;
As ferramentas de simulação são geralmente baseadas em gerações aleatórias de escolhas do programa, mas também técnicas mais sofisticadas como Perfect Simulation podem ser utilizadas;·
As abordagens de modelagem analítica, as quais são empregadas mais raramente em predições de programas paralelos;
Os mais conhecidos formalismos da modelagem analítica, e.
g, Cadeias de Markov e Redes de filas de espera, não são muito apropriados para representar paralelismo e sincronização por não possuírem primitivas que possam corresponder a estes fatores.
Como dito anteriormente, a predição de desempenho de aplicações paralelas tem sido uma boa alternativa para escolha de melhores parâmetros ideais como plataforma, número de nós e distribuição de carga.
Em os últimos anos, muitos estudos revelam diferentes metodologias para predição de desempenho desta classe de aplicações.
Diferente de trabalhos anteriores que são muito específicos ou requerem uma descrição detalhada da aplicação alvo (algumas vezes até o código fonte), neste trabalho foi utilizado o formalismo SAN para gerar modelos genéricos para aplicações paralelas que sejam executáveis em máquinas agregadas (clusters).
Em 1996, Yan, Zhang e Song propuseram um modelo de predição de desempenho Em este trabalho, os autores conseguiram prever tempo de execução, aceleração e eficiência de diferentes aplicações paralelas.
Para esta predição de desempenho, foi utilizado uma abordagem baseada num modelo de dois níveis.
O primeiro nível utilizou um grafo de tarefas semi-determinístico para capturar comportamentos das execuções paralelas, incluindo comunicação e sincronização.
O segundo nível usou um modelo de tempo discreto para quantificar os efeitos do agregado tipo NOW.
Um processo iterativo foi usado para determinar os efeitos interativos entre estes dois níveis.
Apesar de Yan Conseguirem apresentar resultados interessantes, viu- se que é necessário o conhecimento de boa parte do código da implementação para conseguir tais resultados, i.
e, a utilização desta técnica de predição de desempenho sóé valida quando o desenvolvimento de uma aplicação encontra- se já em fase de implementação.
Ainda, percebeu- se que muitos parâmetros de cada nó devem ser considerados, como memória, número de instruções de ponto flutuante, etc..
Dois anos mais tarde, Anglano apresentou uma metodologia para estimativa do tempo de execução de aplicações através de modelos de Redes de Petri Temporizados (Temporized Petri Nets -- TPN).
Em este trabalho, Anglano utiliza uma mistura de análise empírica e modelagem analítica para representar os efeitos da disputa de rede de máquinas agregadas não-dedicados.
Apesar deste trabalho apresentar resultados positivos quanto a predição de desempenho da aplicação alvo (multiplicação de matrizes), observou- se que os modelos são muitos específicos à aplicação, i.
e, para cada aplicação a ser executada numa máquina agregada um novo modelo deve ser gerado.
Ainda, constatou- se que muitos detalhes de implementação devem ser conhecidos a priori, como por exemplo o número de iterações de um laço &quot;for».
A utilização de modelos estocásticos para predição de desempenho utilizando o formalismo SAN parece lidar com aspectos que não são tratados, ou são às vezes muito específicos em outros formalismos estudados.
Por exemplo, com modelos SAN não é necessário o conhecimento do código de uma implementação, i.
e, é possível construir modelos SAN e realizar uma análise com sucesso ainda na fase de modelagem de uma aplicação.
Outro ponto chave na escolha deste formalismo é a abstração de muitos parâmetros dos nós envolvidos na computação.
Em contraste ao trabalho apresentado em, neste trabalho são apresentados modelos SAN genéricos que podem ser adaptados a diferentes máquinas agregadas.
Outro motivo que justifica a escolha do formalismo SAN -- diferentemente de outros formalismos tais como Redes de Petri e Redes de fila de espera -- é o fato deste permitir uma modelagem mais apropriada da comunicação entre processos independentes, representando de maneira mais clara o funcionamento de aplicações paralelas.
Ainda, para resolver modelos SAN utiliza- se distribuição exponencial, não necessitando assim parâmetros de entrada com valores absolutos.
Em outras palavras, a parametrização de modelos SAN é realizada através de valores aproximados balisados por uma distribuição exponencial que permitem a geração de resultados bem próximos do esperado.
Redes de Autômatos Estocásticos é um formalismo que surgiu na década de 80 para modelar sistemas, especialmente aplicações paralelas, baseado na teoria de Cadeias de Markov.
Também chamada de SAN, essa técnica permite que modelos markovianos possam ser descritos de forma compacta e eficiente.
SAN permite inferir medidas de desempenho antes da implementação, como por exemplo tempo de resposta, throughput, atraso de sincronização efetivo, e outras características relacionadas à predição de desempenho em aplicações paralelas.
Este capítulo apresenta apenas uma breve descrição do formalismo SAN.
O leitor interessado em maiores detalhes sobre o mesmo poderá consultar.
Descrição do Formalismo Em o contexto deste trabalho, troca de mensagens será considerado como um modelo de execução, já que este é capaz de avaliar o comportamento de uma aplicação paralela, desde que modelos de máquina e de programação sejam pré-definidos.
A troca de mensagens nos modelos SAN são modeladas através do uso de eventos sincronizantes.
A idéia básica das Redes de Autômatos Estocásticos é que esta descreva um modelo global de um sistema em diversos subsistemas (submodelos) quase independentes entre si, onde cada dois ou mais submodelos interagem somente em alguns casos.
Estes subsistemas, definidos como autômatos estocásticos, são caracterizados por três aspectos:
Estados, transições e eventos.
E3 e E4).
O segundo autômato possui dois estados e dois eventos (E4 e E5).
Dois tipos de eventos podem ser encontrados numa SAN:
Locais e sincronizantes.
Eventos locais modificam somente o estado de um submodelo.
Por outro lado, eventos sincronizantes modificam dois ou mais estados em dois ou mais autômatos.
Ainda observando a Figura 1, o evento E2 é um exemplo de um evento local.
Já E4 é um evento sincronizante.
O evento E4 é considerado sincronizante, pois modifica o estado dos autô matos A e A.
Em o autômato A, o evento E4 pode modificar seu estado de duas formas:
De o estado S3 para o estado S2 com uma probabilidade 1 e do estado S3 para o estado S1 com uma probabilidade 2.
Eventos locais são aqueles que modificam somente o estado de um autômato estocástico.
A Cadeia de Markov pode ser construída combinando todos os estados de todos os subsistemas.
Como pode ser visto na Figura 2, este autômato possui 6 estados globais, ao contrário de o modelo estocástico que possui, para o autômatos A e A, 3 e 2 estados locais, respectivamente.
Esta possibilidade dá- se por o fato do formalismo possuir primitivas paralelas e sincronizantes.
Porém, a definição das taxas dos eventos de um modelo ainda é complexa, exigindo um grande conhecimento do formalismo e grande experiência de quem irá utilizá- lo.
Mesmo assim, acreditamos que é possível o uso de SAN para a modelagem de aplicações paralelas e servirá neste trabalho como validação das escolhas de implementação.
Análise Transiente Os resultados apresentados neste trabalho foram obtidos através de modelos SAN ferramenta possui métodos iterativos para resolução de sistemas de equações.
Com o PEPS, dois tipos de análise podem ser realizadas sobre os modelos SAN gerados:
Análise estacionária e análise transiente.
Esta segunda análise foi a adotada, pois com análise transiente consegue- se estimar o tempo médio de execução de aplicações modeladas.
Por esta razão, ela foi adotada neste trabalho uma vez que em computação de alto desempenho o objetivo principal é observar o tempo de execução.
O leitor com interesse nas diferentes soluções transientes pode procurar em.
A análise transiente foi implementada na ferramenta PEPS utilizando um modelo iterativo onde o usuário especifica o tempo que ele deseja executar seu modelo SAN.
Com este tempo, o PEPS calcula o número de iterações necessárias para executar o modelo.
Os modelos SAN devem possuir um ou mais estados absorvente, ou seja, um estado que não possui transições de saída.
Em este trabalho o estado absorvente para cada modelo é o estado Fim.
A figura 3 apresenta o exemplo de um modelo SAN com este estado absorvente.
Este Modelo tem dois autômatos A1 e A2.
A função deste modelo SAN é modelar a troca de dados entre o autômato A para o autômato A, através dos eventos s e r.
Em o momento que o evento r ocorre, a transmissão de dados é finalizada e os autômatos passam para o estado absorvente Fim.
Para executar um modelo SAN utilizando um método transiente, é necessário especificar o tempo de duração dessa execução.
Com este tempo, o método transiente calcula o número de iterações a serem executadas.
Em o final de uma execução, o método transi-ente retorna um vetor de probabilidades de todos os estados do modelo SAN.
Em este caso, analisa- se somente a probabilidade do estado absorvente (estado Fim da figura 3).
Se na i-ésima execução do modelo SAN a probabilidade do estado Fim não estiver por exemplo em 99%, o vetor de probabilidades da i-ésima execução é recarregado por o método transiente e uma nova execução é realizada, até que o critério seja satisfeito (probabilidade do estado Fim estar em 99%).
Desta forma, tem- se as probabilidades parciais em cada execução do modelo SAN.
Com estas probabilidades e com os tempos de execução passados para o método transiente, pode- se calcular o tempo total de execução da aplicação modelada através de somas ponderadas dessas diversas durações.
Em outras palavras, é realizado um somatório de sucessivas multiplicações entre a probabilidade e o tempo do método transiente.
A tabela 3.2 apresenta um exemplo de como realizar o cálculo do tempo total (em segundos) de execução de uma aplicação modelada através das probabilidades parciais do estado absorvente.
Observe que o tempo parcial na i-ésima execução é a diferença das probabilidades dó necesséstado i e i -- 1 multiplicados por o tempo de execução parcial do modelo.
E ario realizar esta diferença entre as probabilidades para saber o quanto a probabilidade do estado absorvente evoluiu, uma vez que em cada execução o vetor de probabilidades é recarregado com valores da execução anterior.
Assim, tem- se a evolução da probabilidade do estado absorvente multiplicado por o tempo que o modelo SAN já executou, resultando num tempo parcial.
A soma de todos os tempos parciais resulta no tempo total que a aplicação modelada irá demorar pra executar.
Modelos SAN Genéricos para Máquinas Agregadas Em esta seção, os modelos SAN genéricos para máquinas agregadas são apresentados focando na troca de dados e no tempo de processamento, uma vez que a relação entre essas duas características são o ponto chave para determinar o sucesso de implementações paralelas sobre a referida plataforma.
Quatro modelos SAN são discutidos nesta seção:
Modelo mestre/ escravo, modelo de fases paralelas, modelo pipeline e modelo divisão e conquista.
Primeiramente, será realizada uma breve apresentação dos modelos de programação paralela escolhidos, seguido de uma descrição detalhada de cada modelo Modelos de Programação Paralela Diversos modelos de programação são encontrados hoje na literatura.
De entre eles, os que mais se destacam são os modelos mestre/ escravo, fases paralelas, pipeline (também conhecido como produtor/ consumidor), divisão e conquista, grafo de tarefas e decomposição geométrica.
Os quatro primeiros foram escolhidos por serem os mais utilizados por a comunidade científica em aplicações desenvolvidas para máquinas agregadas e por apresentarem características diferentes entre eles, tais como comportamento dos processos e quantidade de informação trocada entre eles.
O modelo mestre/ escravo tem como característica a presença de um processo coordenador responsável por a geração de trabalho e alocação destes para outros processos, denominados escravos.
Em este modelo, o processo mestre pode utilizar uma técnica de balanceamento de carga para que todos os processos tenham tarefas de pesos próximos, evitando que processos escravos fiquem sub-carregados ou sobrecarregados (i.
e, processos ociosos).
A utilização do modelo mestre/ escravo deve ser realizada de forma que o processo mestre (centralizador) não se torne um gargalo, resultando assim em perda de desempenho.
O segundo modelo escolhido é o modelo de fases paralelas.
Este padrão de desenvolvimento tem como características a divisão da execução em duas fases básicas:
A fase de processamento e a fase de transmissão (sincronização).
Em este modelo, todos os processos realizam processamento de tarefas, não existindo um processo centralizador.
O balanceamento de carga neste caso é distribuído, ou seja, todos os processos executam um algoritmo de balanceamento de carga para definir suas tarefas.
A fase de transmissão (troca de dados de todos para todos) é utilizada para sincronização de todos processos, onde estes mudam de fase ao mesmo tempo.
A desvantagem deste modelo está no alto custo de comunicação, uma vez que todos os processos devem trocar informações si.
Em o modelo pipeline, o conjunto de tarefas é passado entre processos sucessivamente e cada processo realiza a computação de uma tarefa.
Em este modelo, os processos são organizados em forma de fila, onde um processo recebe tarefas de seu predecessor, executaas, e as envia para seu sucessor.
O modelo pipeline é o mais difícil de aplicar devido a as características de decomposição do problema em etapas quase seqüenciais.
Mesmo assim, este modelo foi escolhido por possuir características diferentes dos outros.
Por fim, o último modelo escolhido é o modelo de divisão e conquista.
Em este modelo, um problema é dividido em sub-problemas que são resolvidos independentemente e seus resultados são unificados numa fase final.
Em o modelo divisão e conquista, unidades (processos) são agrupadas numa hierarquia de árvore.
Os processos pais dividem suas tarefas e repassam uma parte para seus filhos.
Os resultados são integrados recursivamente.
A figura 4 apresenta um exemplo dessa hierarquia com 4 processos, indicando como é realizada a divisão de trabalho e comunicação neste modelo.
Em esta figura, percebe- se que todos os processos chegam ao último nível, em o qual é realizado o processamento.
Após o processamento, todos os processos que receberam tarefa devem retornar o resultado para o processo enviador (denominado processo pai).
Assim, uma série de transferência de dados é realizada até que o processo que está no primeiro nível da árvore contenha todos os resultados.
Desta forma, todos os processos realizam trabalhos paralelamente e somente na fase de unificação dos resultados que os processos enviam seus resultados para níveis superiores da árvore.
Modelo SAN para Mestre/ Escravo O modelo SAN para mestre/ escravo é mostrado na figura 5.
Este modelo contém um autômato Mestre, um autômato Tarefas, e P autômatos Escravos.
Para esta abordagem (figura 5), o nó mestre é responsável por a distribuição de trabalho e armazenamento dos resultados das tarefas processadas por os escravos.
Em o modelo correspondente, o autômato Mestre possui três estados (Init, Re e Tr) que significam, respectivamente, o estado inicial, a recepção dos resultados das tarefas enviadas por os escravos ou requisição dos escravos de uma nova tarefa, e transmissão de uma nova tarefa para um escravo.
A ocorrência do evento up representa o envio da primeira tarefa para cada nó escravo.
Esta condição é uma característica particular do ambiente de máquinas agregadas, uma vez que sabe- se que todos os nós escravos estarão prontos para processar tarefas no início da execução de uma aplicação.
Por a ocorrência do evento sincronizante si, o nó mestre envia uma nova tarefa para o i-ésimo escravo.
De uma maneira similar, a recepção dos resultados avaliada por o i-ésimo escravo é feita através da ocorrência do evento sincronizante ri.
Quando o nó mestre recebe uma resposta de um nó escravo, ele pode alternativamente enviar uma nova tarefa para este escravo ou somente receber e armazenar o resultado.
O autômato Tarefas é utilizado para contar o número de tarefas restantes a serem processadas por os escravos.
Este autômato possui N+ 1 estados, aonde N representa o número total de tarefas a serem executadas.
Quando o mestre recebe a resposta de um escravo, ele desconta o número de tarefas restantes, mudando o estado deste autômato.
O autômato Escravo representa o i-ésimo escravo com estados:
Init (inicial), Comp (processando) e T r (enviando).
O evento sincronizante si representa a recepção de uma nova tarefa por a i-ésimo escravo enviada por o nó mestre.
O Escravo finaliza o processamento de uma tarefa por a ocorrência do evento local pi.
O evento sincronizante ri representa o envio dos resultados de uma tarefa processada para o nó mestre.
Modelo SAN para Fases Paralelas O modelo SAN para fases paralelas é mostrado na figura 6.
Este modelo específico contém dois autômatos representando o processo i e o número de tarefas a serem processadas.
Vale lembrar que o número de processos pode variar, acrescentando ou diminuindo o número de autômatos no modelo.
Cada autômato P rocesso possui 3 estados, denominados Pr, Tr e Fim que representam, respectivamente, o processamento, a transmissão e a finalização da execução.
Com o evento local pi, o processo i termina o seu processamento, iniciando assim a fase de sincronização (toca de dados) entre todos os processos.
Com o evento sincronizante t todos os processos finalizam a fase de troca de dados e retornam para o processamento da próxima fase.
A finalização da execução paralela é indicada através do evento ei.
Os deve ser utilizada sempre quando estes modelos forem resolvidos utilizando a ferramenta PEPS.
Em este caso, o estado Fim dos autômatos tem característica de estado absorvente, ou seja, conforme o tempo de execução aumenta, a probabilidade deste estado também aumenta.
Esta condição é importante, quando utilizada a análise transiente, para que se possa encontrar o tempo de execução aproximado da aplicação modelada.
O autômato F ases, diferentemente do modelo SAN mestre escravo, representa o número de fases restantes a serem processadas.
Observe que aqui cada vez que a ocorrência do evento t é realizada o número de fases decresce.
Ainda, o número de tarefas realizadas por cada processo é pré-determinada, i.
e, cada processo realizará a computação de uma ou mais tarefas em todas as fases paralelas.
Modelo SAN para Pipeline O modelo SAN para pipeline é mostrado na figura 7.
Este modelo específico contém três autômatos representando os processos 1, i e o número de tarefas a serem processadas.
Vale lembrar que o número de processos pode variar, acrescentando ou diminuindo o número de autômatos no modelo.
Em este modelo, o autômato P rocesso1 possui 3 estados, denominados Pr (Processando), Tr (transmitindo), e Fim (Finalizando).
Já os outros processos possuem um estado a mais (Re -- Recebendo), que serve para receber tarefas de seu processo antecessor.
Esta característica se dá por o fato do modelo de programação pipeline determinar que um processo somente inicia execução de uma tarefa quando o processo anterior a tiver terminado.
Assim, o processo 1 tem como estado inicial Pr enquanto os outros processos aguardam o recebimento da tarefa em Re.
Por a ocorrência do evento p1, o processo 1 finaliza seu processamento e inicia o envio da tarefa para o processo 2.
O evento s1 caracteriza o fim do envio do processo 1 para o processo 2 e início do processamento deste.
O processo i, por sua vez, finaliza seu processamento através da ocorrência do evento pi.
De a mesma forma o envio de uma tarefa de um processo antecessor para um sucessor é realizado sucessivamente até que a tarefa chegue ao último processo da fila.
A ocorrência do evento ei em cada autômato P rocesso indica a finalização da execução paralela.
Semelhante ao modelo de fases paralelas, todos os autômatos necessitam de um evento um autômato T aref as é utilizado para contar o número de tarefas já processadas.
Este autômato é necessário para definir o critério de parada do modelo SAN.
Modelo SAN para Divisão e Conquista O modelo SAN para divisão e conquista é mostrado na figura 8.
Este modelo contém 3 autômatos que representam o processo raiz, processo intermediário e processo folha.
Por possuir características diferentes dos outros modelos apresentados até então, tais como organização dos processos e divisão das tarefas, este modelo de programação foi o mais complexo de ser modelado utilizando SAN.
Assim, para acrescentar processos neste modelo, deve- se alterar os autômatos já existentes, uma vez que a divisão de trabalho deve ser escalonada conforme o número de processos envolvidos.
Este modelo, como dito anteriormente, pode ser visto também como uma árvore de processos, onde a comunicação de cada nível significa uma transmissão de dados entre dois processos.
O estado S do autômato Raiz significa a divisão e envio de trabalho para seus processos filhos.
Em outras palavras, o processo Raiz divide a tarefa inicial em duas sub-tarefas, envia uma sub-tarefa para um processo filho e fica com uma sub-tarefa.
Se ainda houverem processos que não possuem uma tarefa, o processo Raiz divide novamente a sua sub-tarefa em duas sub-tarefas, enviando uma de elas para outro processo filho.
Esta divisão é realizada até que todos os processos obtenham uma tarefa para processar.
Observe que processos filhos do Raiz podem ser tanto processos intermediários quanto processos folhas.
Os processos intermediários, representados por o autômato Intermediarioi recebem uma tarefa de seu processo pai, quebram em sub-tarefas e enviam para seus filhos.
Já os processos folhas, representado por o autômato F olhaj não possuem processos filhos.
Estes recebem uma tarefa, processam- a e enviam a resposta para seu processo pai.
Note que utilizou- se uma generalização quanto a o número de envios e recebimentos de tarefas nos autômatos Raiz e Intermediarioi.
Porém, quando o número de processos for definido numa execução, estes estados de envio e recebimento serão quebrados em mais estados, cada um representando o envio/ recebimento de uma tarefa para/ de um processo filho.
Por a ocorrência o evento si, o envio de uma tarefa de diferente tamanho é realizado.
O evento ri representa o recebimento de um resultado processado por um processo filho.
O evento pi ocorre quando um processamento de uma tarefa é finalizado.
Por fim, a ocorrência do evento fi é necessária para que o modelo torne- se cíclico, igualmente aos outros modelos SAN apresentados até agora.
Como Parametrizar Modelos SAN O próximo passo para completar a elaboração dos modelos SAN é a determinação de valores numéricos associados às taxas dos eventos e probabilidades.
Alguns parâmetros são dados por o desenvolvedor (valores de entrada do modelo), enquanto outros são avaliados utilizando estes valores de entrada.
Algumas variáveis são criadas para auxiliar a definição dos parâmetros:·
Cs -- tempo de comunicação que um processo leva para enviar dados para outro processo;·
P S -- tempo de processamento que um processo consome para concluir uma tarefa;
Em os modelos descritos neste trabalho considera- se que diferentes tarefas (e seus resultados) têm a mesma média de custo de comunicação e processamento.
Todavia, sem nenhuma perda de generalidade nos modelos propostos, taxas médias diferentes poderiam ser associadas aos diferentes nós para definir características específicas do ambiente paralelo utilizado na modelagem.
Os tempos Cs e P S podem ser calculados de duas formas:
Utilizando programas simples que coletam estes tempos ou utilizando fórmulas com características específicas das máquinas e da rede alvo.
A primeira forma de calcular o tempo Cs é utilizando um programa com o código descrito no algoritmo 1.
Algoritmo 1 Algoritmo para calcular o tempo de envio de uma tarefa.
1: Se processo $= 0 então Pega tempo inicial Envia bytes para processo 1 Pega tempo final Tempo de Envio $= Tempo inicial -- Tempo final 6: Senão Recebe bytes do processo 0 8: Fim se Observe que este programa não possui complexidade e pode ser utilizado para coletar o valor para Cs em diferentes máquinas agregadas.
A segunda forma de calcular este tempo é utilizando a fórmula 1.
Onde N B é o número de bytes a ser enviado e Bs é o tempo de envio de um byte numa rede.
Este segundo tempo pode ser extraído dos manuais da rede que será utilizada.
Independente do método adotado para calcular os tempos de comunicação, ambos podem representa a realidade de forma aproximada.
A primeira forma de calcular P S é utilizando o programa seqüencial a ser paralelizado.
Em outras palavras, geralmente um programa que necessite ser paralelizado já foi implementado seqüencialmente.
Assim, pode- se identificar dentro deste programa qual a parte a ser paralelizada, calcular o tempo de execução desta parte de código e dividir este tempo por o número de processos que irão participar do processamento paralelo.
Desta forma, tem- se o tempo aproximado de processamento paralelo de cada processo, ou seja, A segunda forma de calcular P S é utilizando também uma fórmula simples, apresentada em 2.
Onde N O é o número de operações aritméticas que uma tarefa terá e Te o é o tempo que um processador demora para processar uma operação aritmética.
Novamente, este tempo pode ser retirado do manual dos processadores a serem utilizados.
Com estes dois tempos, é possível calcular todas as taxas dos quatro modelos SAN apresentados anteriormente.
Estas taxas são definidas a seguir.
Obtenção das taxas Em esta seção serão apresentadas as formas de obtenção das taxas para cada modelo SAN genérico descrito no capítulo 4.
Modelo Mestre/ Escravo Os eventos si, pi, e ri do modelos SAN mestre/ escravo têm suas taxas(, µ, e respectivamente) definidas numericamente por (equação 3):
Para o modelo mestre/ escravo, a taxa do evento up é numericamente definida considerando o envio das tarefas iniciais para todos os P escravos (equação 4):
A probabilidade de ainda haver tarefas a serem distribuídas para os escravos é uma probabilidade funcional a qual depende diretamente do estado do autômato Tarefas.
Esta probabilidade assegura que o nó mestre irá enviar novas tarefas para os nós escravos somente se ainda houver tarefas a serem processadas, i.
e (equação 5):
Modelo de Fases Paralelas Em o modelo de fases paralelas, as taxas são utilizada de acordo com os eventos mostrados na tabela da figura 6.
A taxa do evento pi deste modelo é calculada da mesma forma que a taxa do evento pi no modelo mestre/ escravo.
Já a taxa, relacionada ao evento sincronizante t, é calculada da seguinte forma (equação 6):
Sendo P o número total de processos e Cs, neste caso, o tempo de transmissão do resultado de um processo para todos os processos restantes.
Por fim, tanto a taxa como a taxa são taxas funcionais, descritas da seguinte forma (equação 7):
Onde mais uma vez P é o número total de processos.
Esta taxa funcional indica que Fim, ou seja, finalizado a execução.
Modelo Pipeline O modelo pipeline também possui quatro taxas, mostradas na tabela da figura 7.
Os anteriormente.
Já a taxa é diferente, e pode ser calculada da seguinte forma:
Onde Cs, neste caso, é o tempo de transmissão de uma tarefa de um processo para o outro.
Por outro lado, a taxa e a taxa µ são as mesmas do modelo de fases paralelas, taxas funcionais onde todos os processos devem estar no estado Fim.
Modelo Divisão e Conquista O modelo divisão e conquista tem a taxa igual à descrita nos outros modelos SAN.
A taxa de envio de tarefas é calculada da mesma forma que no modelo pipeline.
Porém, as tarefas possuem tamanhos diferentes, modificando a taxa de cada evento.
A taxa é, para este estudo de caso, a mesma que a taxa.
Isto ocorre porque o número de dados a serem retornados são os mesmos que enviados numa tarefa.
Por fim, a taxa µ, relacionada aos eventos locais de fim, são taxas funcionais de mesma sintaxe apresentadas em outros modelos SAN.
Escolha dos Estados Iniciais e Finais Para apresentar a análise transiente dos modelos, é necessário assumir um conjunto de estados iniciais e finais para cada modelo SAN.
Os estados inicias e finais são descritos nesta seção utilizando a sintaxe da ferramenta PEPS.
