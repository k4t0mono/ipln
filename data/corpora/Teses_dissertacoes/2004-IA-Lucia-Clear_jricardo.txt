Existe um novo paradigma pós-industrial baseado nos conceitos do ciberespaço apoiado por os novos meios de comunicação.
Este novo ambiente cria bases para registrar os resultados de nossa Inteligência Coletiva.
Entretanto ainda não exploramos adequadamente o potencial destes ambientes para melhorar nossos sistemas educacionais, especialmente a forma que os educadores ensinam e os aprendizes constroem seu conhecimento.
O desafio é construir um novo processo educacional baseado nesta cibercultura.
Em este contexto, os jogos computadorizados desempenham um papel muito importante.
Todos os jogos computadorizados têm propriedades educacionais, independente se foram construídos ou não com suporte às atividades didáticas.
Entretanto, professores estão diante de um problema:
Crianças e adolescentes não gostam destes jogos computadorizados com fins educativos.
Tais jogos não atendem suas expectativas.
Eles possuem interfaces pobres, baixo nível de desafio e não oferecem opções para configurar o jogo conforme os objetivos dos educadores e/ ou aprendizes.
A solução é desenvolver um ambiente que permita projetar jogos educativos capazes de reduzir o gap entre jogos comerciais e os jogos que possuem objetivos didáticos explícitos.
Porém, esta solução não é fácil de ser implementada e possui um alto custo de desenvolvimento, pois para produzir uma ferramenta educacional não é uma tarefa simples.
Então, uma opção para resolver estes problemas pode ser uma infraestrutura genérica para criar diferentes jogos computadorizados, inclusive considerando as plataformas móveis.
Esta dissertação de mestrado apresenta um framework multiplataforma denominado Amphibian que foi projetado para auxiliar programadores e projetistas de jogos na criação de novos jogos computadorizados que poderiam ser usados em ambientes de aprendizagem.
Algumas técnicas relacionadas à Engenharia de Software, tais como padrões de projeto, frameworks e componentização, foram usadas para modelar o projeto.
O protótipo foi criado com Java e seguindo os princípios de código-aberto e Software Livre.
Algumas métricas de qualidade foram usadas para verificar o desempenho do Amphibian.
Desde a pré-história que o homem gosta de expressar sua subjetividade e manter registrado seu conhecimento e suas emoções.
Um exemplo disto são as pinturas rupestres nas grutas de Lascaux que datam do período Paleolítico.
Além de esta manifestação, nas artes plásticas, o homem sempre foi fascinado para ouvir e contar estórias sobre criaturas lendárias, feitos heróicos de seu grupo social e lições morais.
Sempre apreciou estórias contadas em torno de uma fogueira por os homens mais velhos e sábios da comunidade.
Desta forma as tradições eram perpetuadas através da oralidade e da imaginação dos homens primitivos que criavam seus mundos imaginários.
Muitas vezes concretizados na forma de pinturas, máscaras, esculturas, danças e novas releituras das estórias contadas.
Com a evolução da espécie, o ser humano começou a construir artefatos cada vez mais complexos e expandiu suas manifestações racionalistas e artísticas.
Com a invenção da imprensa de Gutenberg, as estórias dos sábios anciões tribais deixaram de ser uma cultura local e puderam ser lidas em diferentes contextos temporais e geográficos.
Como destaca Negroponte, a sociedade até a era industrial era totalmente forjada em átomos, logo as tradições passaram a ser transmitida através da escrita em átomos, seja tinta e papel, luz e filme ou som e fitas magnéticas.
Entretanto nos meados dos anos 40 com o término da II Guerra Mundial ocorre um grande salto do período industrial para o pós-industrial devido a as descobertas da física atômica, biotecnologia, avanços nos meios de transporte e comunicação, criação de novos materiais, ascensão da eletrônica, da informática e das telecomunicações.
Por esta razão o pós-industrialismo é considerado a era do conhecimento.
Em o pós-industrialismo o ser humano aumenta a autonomia para buscar mais informações que lhe interessam para complementar suas competências, a figura central responsável por organizar o que deve e o que não deve ser lido é minimizado.
Em este novo paradigma surgem novos valores e outras necessidades sociais.
Existe uma valorização de atividades que requerem inteligência, criatividade e preparação cultural;
A valorização da subjetividade, da emoção e da estética;
A virtualidade, a globalização, a desestruturação do trabalho e do lazer;
E, principalmente as exigências de autonomia e flexibilidade podem ser citadas como exemplos de valores do pós-industrialismo.
Em este contexto do ciberespaço e pós-industrialismo o sistema educacional também sofre fortes influências.
Segundo Pierre Lèvy, surgem novas formas de raciocínio, como as simulações cujo conhecimento é oriundo das experiências.
O conhecimento deixa de ser uma estrutura estática e passa a ser representado num mundo virtual.
Permite que novos conhecimentos sejam produzidos através das simulações.
Destacando que as simulações têm uma grande importância na pesquisa científica, na indústria, na aprendizagem e no entretenimento, na forma de jogos.
Em este contexto pós-industrial e cibercultural o imaginário é forjado em bits, é virtualizado e compartilhado por os demais sujeitos.
O ciberespaço permitiu a criação de comunidades de pessoas em torno de temas comuns sob uma estrutura tecnológica constituída de artefatos computacionais e de telecomunicações, produzindo novos conhecimentos através da interação entre sujeitos, emergindo deste social-cibernético uma inteligência coletiva.
O receptor passivo dos meios de comunicação tradicional, como a televisão e os jornais da era industrial torna- se coautor no processo de comunicação e a mensagem é transformada, reconstruída por a interação entre o emissor e o receptor.
O fato que a sociedade é modificada por os artefatos tecnológicos que produz.
Portanto, a cibercultura que emerge do ciberespaço modifica os modelos sociais desde os modelos econômicos até os processos de ensino-aprendizagem.
Todos estes conceitos de cooperação e autonomia da cibercultura afetam o modo de vida das crianças e jovens modernos.
Novas formas de educar e aprender começam a ser necessárias e artefatos que até então eram discriminados do contexto escolar, tais como a televisão, as histórias em quadrinhos, o cinema e os jogos computadorizados começam a ser inseridos nas salas de aula, por o fato de serem ferramentas que desenvolvem habilidades meta-cognitivas.
Em este contexto surge a possibilidade de utilizar os elementos principais dos RPGs (Role--Playing Games) no processo de ensino-aprendizagem, cujo principal objetivo deste jogo é representar papéis num mundo imaginário construindo uma estória coletivamente com um grupo de pessoas.
Tal modalidade de jogo possui uma grande afinidade com o contexto cibercultural, devido a as questões de criação de comunidades, imaginação e cooperação.
Assim considera- se o RPG numa forma digitalizada, ou seja, na forma de um jogo computadorizado, numa partida executada através da Internet em tempo real ou através da troca de e-mails e como esta modalidade digital pode ser usada como uma nova técnica de ensino-aprendizagem.
Em esta modalidade digital o RPG continua tendo as representações de papéis, num jogo de fazde-conta que permite vivenciar mundos imaginários.
O que ocorre é que o grupo de pessoas não se reúne presencialmente em torno de uma mesa, mas remotamente, num ambiente, num mundo virtual, localizado no ciberespaço.
Tal gênero recebe destaque por o fato de misturar estilos (ação, aventura e simulação) interessantes do ponto de vista cognitivo e por o fato desta modalidade de jogo estar sendo utilizada com propósitos educativos devido a o seu caráter lúdico e cooperativo.
Acredita- se que o uso deste gênero de jogo, em sua modalidade computacional, poderá contribuir na criação de novos jogos com propósitos educativos.
Esta definição de escopo certamente não exclui a investigação dos potenciais cognitivos de outros estilos e gêneros de jogos.
Considerando o fato que a presente dissertação está inserida num Programa de Pós-graduação em Ciência da Computação e compreendendo tal ciência com um enfoque transdisciplinar, como uma ciência meio, capaz de gerar transformações econômicas e sociais, alterando a forma de vida dos sujeitos através da disponibilidade de modelos computacionais e da interface com as diversas áreas do conhecimento, buscou- se propor soluções computacionais que possam servir como artefatos que promovam uma nova forma de ensino-aprendizagem neste contexto da educação pósindustrial.&amp;&amp;&amp;
Objetivou- se desenvolver um ambiente computadorizado que permitisse alunos e professores construir seus mundos virtuais, seus jogos computadorizados na categoria de RPG.
Tais aplicações poderiam suportar diversos usuários interagindo em tais mundos, construindo artefatos e vivenciando uma experiência lúdica.
Além de estas possibilidades de entretenimento, tal ferramenta poderia ser utilizada no Ensino Fundamental, Ensino Médio ou Ensino Superior explorando diversos temas vinculados ao currículo escolar, permitindo, assim, que os educadores construíssem seus jogos de RPG de forma livre e criativa, pois as ferramentas oferecidas por o sistema não deveriam limitar as opções do usuário oferecendo recursos para uma única temática.
Assim seria possível construir mundos virtuais para ensinar a Revolução Farroupilha, a História do Brasil, o Império Romano, explorações espaciais, missões geológicas, Biologia, Medicina, entre inúmeras outras possibilidades.
Visando atender tais objetivos criou- se o projeto denominado REVOLUTION (digital RolE--playing game enVirOnment for Learners edUcaTION) cuja meta principal é a criação de ferramentas, que utilizam elementos do RPG, permitam a construção de mundos virtuais que possam ser utilizados no processo de ensino-aprendizagem.
Em este projeto definiu- se um motor de jogo que fosse capaz de controlar estes mundos virtuais e, que permita a educadores e aprendizes modelarem seus próprios cenários, suas histórias e seus personagens.
Este motor de jogo foi denominado Druida.
Certamente que um projeto desta magnitude é bastante ambicioso e não pode ser concluído em curto prazo.
Logo, foi desenvolvido um planejamento que cobrisse o espaço de tempo da dissertação de mestrado e um futuro trabalho de doutorado.
Inicialmente foi efetuado um levantamento tecnológico que auxiliasse na definição da viabilidade de concretizar tal ferramenta com prazos e escopo bem definidos para serem efetuados durante a dissertação.
Antes de iniciar o levantamento tecnológico partiu- se de dois requisitos fundamentais:
A solução deverá executar em diferentes sistemas operacionais e uma licença de uso de baixíssimo custo (ou nenhum).
Através do levantamento tecnológico constatou- se a existência de ferramentas cujo objetivo é justamente permitir criar RPGs computadorizados.
Estes softwares são denominados RPG Maker.
Entretanto as maiorias destas ferramentas são compatíveis com o sistema Microsoft Windows, algumas destas são bastante amadoras, outras possuem um custo de licença bastante elevado e algumas soluções possuem sérios problemas de legalidade da licença.
Logo, diante deste cenário justificava- se a proposta de um RPG Maker que atenda estes dois pré-requisitos.
A segunda etapa deste processo de definição convergiu para o estudo do desenvolvimento de jogos computadorizados para determinar novos requisitos para infra-estrutura computacional necessária para implementar o Projeto REVOLUTION.
Analisando alguns motores de jogos (game engines), kits de desenvolvimento e bibliotecas de software mais comumente usadas no desenvolvimento de jogos constataram- se que a grande maioria destas executam no ambiente Microsoft Windows e outras possuem alto custo de licença de uso.
As soluções baseadas na filosofia de Software Livre em sua maioria são pouco documentadas, com falta de padronização e código-fonte extremamente difícil de ser compreendido principalmente por a falta de comentários.
Além de estas características nenhuma destas soluções oferecem suporte ao desenvolvimento de jogos para computadores pessoais e para as plataformas móveis, tais como celulares e handhelds.
Como para o desenvolvimento do RPG Maker é necessário desenvolver um motor de jogo, uma infra-estrutura tecnológica básica, e por a ausência de soluções o foco inicial do trabalho, a presente dissertação, passou a considerar a proposta de uma solução para esta infra-estrutura tecnológica básica.
Assim, a primeira etapa do desenvolvimento do Projeto REVOLUTION consiste no desenvolvimento de uma proposta de um framework que permita o desenvolvimento de jogos computadorizados multiplataforma, incluindo a plataforma móvel.
Desta forma com este framework será possível desenvolver o motor de jogo que irá gerenciar os mundos virtuais desenvolvidos por o RPG Maker.
Além de isto, permitirá desenvolver outros jogos computadorizados, pois representa uma arquitetura geral de desenvolvimento.
A principal contribuição deste framework é permitir desenvolver jogos computadorizados com mais rapidez e mais facilidade desta forma incentivando a criação de jogos para serem utilizados com fins pedagógicos.
Muitos projetos acadêmicos em Informática na Educação acabam reimplementando funcionalidades já desenvolvidas em projetos anteriores.
Com a existência de uma infra-estrutura responsável por tratar de problemas de gerenciamento de eventos e visualização de imagens, por exemplo, é possível focar os trabalhos futuros em aspectos mais sofisticados do jogo, tais como Inteligência Artificial, assim criando soluções mais arrojadas e compatíveis com as metodologias de ensino-aprendizagem adotadas por os educadores.
Além destes aspectos educacionais acredita- se que um framework para o desenvolvimento de motores de jogos auxilia no crescimento das empresas nacionais desenvolvedoras de jogos, principalmente por oferecer uma forma padrão de criação de jogos para computadores pessoais e plataformas móveis.
Tendo em vista que a implementação adota uma forma padronizada, a curva de aprendizado dos desenvolvedores é reduzida e por conseqüência as empresas poderão desenvolver protótipos mais rapidamente e atender um número diferente de plataformas de execução.
Portanto considerando este contexto e o problema descrito anteriormente, esta dissertação buscou responder a seguinte questão de pesquisa:
&quot;Que funcionalidades e modelo arquitetural deve ter um framework que permita a construção de game engines com suporte a multiplataformas?»
A partir de esta questão principal foi criada a seguinte questão derivada:
&quot;O quanto um nível elevado de generalização pode impactar o desempenho das game engines desenvolvidas?»
Associadas às estas questões de pesquisa foram formuladas as seguintes hipóteses:
O framework deverá ser independente dos mecanismos de visualização (2 D/ 3 D), dos mecanismos de persistência dos dados e das especificidades de cada sistema operacional.
Desta forma o framework deverá operar com camadas de abstração referente a o sistema operacional e aos mecanismos de visualização e persistência;
O reuso de soluções computacionais pode ser feito através da componentização e da adoção de padrões de projetos, definindo interfaces em tais artefatos que facilitam a comunicação e a fácil substituição dos componentes sem comprometer os demais envolvidos no framework;
O desenvolvimento de um modelo computacional sob a filosofia de Software Livre favorece o constante aperfeiçoamento do aplicativo por a comunidade, desta forma otimizando- o e oferecendo um maior número de alternativas, componentes, para serem usados no projeto de game engines.
Assim quando os componentes do framework são otimizados, esta melhoria se refletirá nas engines desenvolvidas a partir de ele.
O principal objetivo desta dissertação é propor um framework que permita a construção de game engines, voltadas para jogos simples e complexos, com suporte a multiplataformas.
Complementando este objetivo principal, alguns objetivos específicos foram estabelecidos:
Projetar um framework independente dos mecanismos de visualização (2 D/ 3 D), de persistência dos dados e das especificidades de cada sistema operacional;
Desenvolver um simples mecanismo de visualização 2D que permita efetuar alguns testes simples;
Desenvolver um mecanismo de persistência utilizando o formato XML;
Testar a reusabilidade de componentes estruturais, por exemplo, mecanismos de persistência, e componentes lógicos dos motores de jogos criando alguns casos de testes;
Com a finalidade de detalhar o processo de elaboração da solução computacional proposta nesta dissertação este volume está organizado da seguinte maneira:
Alguns destes constituem de testes como é o caso dos &quot;Quadrados Coloridos «e, o exemplo de interação com o mouse.
Além destes exemplos foram criados os jogos Snake, o Jogo da Serpente e o Jogo da Vida de John Conway.
Por último, são apresentados as métricas de qualidade analisadas do framework e os testes de desempenho da arquitetura proposta.
Capítulo 6: Apresenta as considerações finais, onde são retomadas as conclusões parciais apresentadas ao longo de o trabalho, destacando as contribuições da dissertação e apresenta- se uma lista de possíveis trabalhos futuros.
Antes de apresentar os conceitos associados ao framework que está sendo proposto no presente trabalho é necessário efetuar uma contextualização transdisciplinar, isto é, buscará- se- discutir os conceitos das áreas correlatas e suas interrelações.
Tratar os jogos computadorizados desprezando a influência de outras áreas do conhecimento seria uma abordagem reducionista e não desejável para um trabalho científico que visa propor uma solução computacional considerando as pluralidades que permeiam o tema.
Parte- se desta abordagem transdisciplinar para apresentar os jogos computadorizados inseridos na cultura e no contexto social.
Jogos associados ao período do pós-industrialismo onde as novas tecnologias acabam condicionando novos valores, os quais afetam os processos sociais vigentes, tais como a Economia e a Educação.
Por isto é importante o entendimento desta concepção macroscópica para compreender a importância que os jogos computadorizados possuem no sistema de ensinoaprendizagem do século XXI.
E como que o modelo computacional que está sendo proposto neste trabalho poderá contribuir para disseminação dos jogos computadorizados em ambientes de aprendizagem, tais como as salas de aula, através de uma visão de inclusão digital, considerando o aprendiz como um sujeito autônomo, criativo e resolvedor de problemas.
Considerando que o escopo desta dissertação se concentra em Ciência da Computação, detalhes sociológicos, filosóficos e educacionais não serão aprofundados.
Maiores detalhes podem ser obtidos em Bittencourt &amp; Giraffa.
Basicamente a História da Humanidade pode ser dividida em três grandes períodos:
O pré-industrial, o industrial e o pós-industrial.
O período pósindustrial surge nos meados dos anos 40 com o término da II Guerra Mundial.
Para De Masi, o grande salto do período industrial para o pós-industrial deve- se às descobertas da física atômica, biotecnologia, avanços nos meios de transporte e comunicação, criação de novos materiais, ascensão da eletrônica, da informática e das telecomunicações.
Por esta razão o pós-industrialismo é considerado a era do conhecimento.
Em o pós-industrialismo o ser humano aumenta a autonomia para buscar mais informações que lhe interessam para complementar suas competências, a figura central responsável por organizar o que deve e o que não deve ser lido é minimizada.
Em este novo paradigma surgem novos valores e outras necessidades sociais.
Existe uma valorização de atividades que requerem inteligência, criatividade e preparação cultural;
A valorização da subjetividade, da emoção e da estética;
A virtualidade, a globalização, a desestruturação do trabalho e do lazer;
E, principalmente as exigências de autonomia e flexibilidade podem ser citadas como exemplos de valores do pós-industrialismo.
Em este contexto da emergência do pós-industrialismo temos uma série de processos repensados e reestruturados, como é o caso do sistema educacional.
Atualmente no Brasil temos um modelo educacional ainda baseado na transmissão de conhecimento, no acumulo de saberes e na supremacia de um professor que detém o saber constituindo uma pedagogia bancária, da omissão e da passividade, conforme Paulo Freire.
O grande desafio está em como preparar a nossa sociedade, principalmente crianças e jovens, a viverem numa sociedade pós-industrial.
Como capacitar- los humanisticamente, tecnologicamente e socialmente para lidarem com a virtualidade, serem globalizados, criativos, responsáveis e autônomos para buscarem o conhecimento?
Além disso, qual o papel da Ciência da Computação neste cenário atuando como um componente de transformação social e não como uma ciência voltada exclusivamente para resolução de seus problemas e na utilização da capacidade de computar de tais máquinas?
Como que a Ciência da Computação é capaz de prover modelos computacionais que potencializem a interatividade e a interconectividade da sociedade com o ciberespaço?
A sociedade atual está sofrendo um processo de transformação e está buscando se adaptar ao novo paradigma social pós-industrial fundamentado no conhecimento.
Em esta nova abordagem a informática é um dos principais fatores desta mudança.
Em um sentido mais amplo a sociedade pós-moderna está sendo condicionada por o ciberespaço.
Considerando o ciberespaço se pode definir- lo como um meio de comunicação que surge da interconexão mundial de computadores, não somente sua estrutura física, mas também um conjunto de informações e de seres humanos que navegam e/ ou publicam novas informações.
Caracteriza- se como um meio de comunicação do tipo &quot;de todos para todos «que interconecta pessoas.
O ciberespaço por si só, não causa impactos na sociedade.
Ele é o produto de uma sociedade pósmoderna com valores de globalização.
O ciberespaço é oriundo das idéias de inúmeros pesquisadores que através da manipulação de recursos artificiais, tais como os computadores e as redes de comunicação, possibilitaram criar um canal de comunicação e troca de conhecimentos entre pessoas localizados em pontos temporais e espaciais diferentes.
Desta forma o ciberespaço condiciona os valores de uma sociedade pósindustrial da mesma forma que a agricultura condicionou a sociedade pré-industrial.
Em este contexto do ciberespaço e pós-industrialismo o sistema educacional também sofre fortes influências.
Surgem novas formas de raciocínio, como as simulações cujo conhecimento é oriundo das experiências.
O conhecimento deixa de ser uma estrutura estática e passa a ser representado num mundo virtual.
As simulações têm uma grande importância na pesquisa científica, na indústria, na aprendizagem e nos jogos computadorizados.
Uma das formas mais intensas de expressão dos mundos virtuais é a Realidade Virtual Imersiva cujo usuário utiliza dispositivos sofisticados, tais como luvas (datagloves), capacetes e/ ou salas de projeções para interagir diretamente com objetos virtuais simulados por um modelo computacional.
O usuário tem a sensação física de estar imerso neste mundo.
A grande desvantagem desta abordagem é o custo destes equipamentos e o desconforto gerado no usuário por o uso destes dispositivos.
Outra abordagem alternativa é a Realidade Virtual Não-Imersiva.
Através do uso de dispositivos convencionais de entrada e saída (monitores, teclado, mouse e joystick) o usuário controla uma entidade que consiste de uma representação do usuário e é capaz de modificar o mundo que esta está inserida.
É uma abordagem de realidade virtual mais fraca que a imersiva, mas em compensação é menos dispendiosa e elimina a utilização de periféricos desconfortáveis.
Os simuladores de vôo, os jogos computadorizados em geral e os RPGs em rede (MUD ­ MultiUser Dungeons) são exemplos de mundos virtuais.
Assim, se agrega ao processo de ensino-aprendizagem o papel de ser cooperativo através das interações dos aprendizes em comunidades virtuais e da interação com mundos virtuais, que envolve a simulação.
A educação deixa de ser menos estática e institucionalizada e permite uma troca de saberes gerenciada por a inteligência coletiva e por as competências individuais.
Evidentemente que o papel do professor também se modifica neste contexto, pois este deixa de ser um mero fornecedor de informações para os alunos e passa a ser um articulador da inteligência coletiva, mantendo a dinâmica da comunidade e dos mundos virtuais.
O ciberespaço pode ser considerado como uma tecnologia que propicia a exclusão social da mesma forma que a escrita propiciou os analfabetos.
O ciberespaço torna- se excludente principalmente por um de seus componentes, a infraestrutura tecnológica (computadores e conexão com a Internet).
Devido a os altos custos desta estrutura muitas pessoas acabam sem ter acesso ao ciberespaço.
Segundo o Mapa da Exclusão Digital lançado em Abril/ 2003 desenvolvido por o Centro de Políticas Sociais da Fundação Getúlio Vargas e idealizada por o Comitê para Democratização da Informática (CDI), 12,46% da população brasileira dispunha de acesso em seus lares a computador e 8,31% à Internet, no ano de 2001.
Em este mesmo ano, nas escolas 23,94% dos alunos do Ensino Fundamental e 55,87% dos alunos do Ensino Médio tinham acesso a Laboratórios de Informática e 25,49% dos alunos do Ensino Fundamental e 45,64% dos alunos do Ensino Médio dispunham de acesso à Internet.
Por esta razão, o desenvolvimento de novas tecnologias não deve fomentar o aumento desta exclusão, ao contrário, deverá permitir um processo de inclusão.
Por o fato do ciberespaço possuir características libertárias, ou seja, que propiciam a autonomia, a criticidade do indivíduo e a construção dos saberes baseada na interação entre as pessoas existe uma correlação com a abordagem educacional sóciopolítica representada principalmente por as idéias do pedagogo Paulo Freire.
Para Freire existe na sociedade uma relação de opressores e oprimidos e um processo de desumanização que aliena os oprimidos (envolve diretamente as questões referentes a criticidade).
O objetivo é a construção de uma pedagogia forjada por os homens na luta por a recuperação de sua humanidade (humanização).
Sabe- se que as escolas tradicionais não estimulam a experimentação e a criticidade dos alunos, falta participação e cooperação.
Freire denomina o modelo escolar tradicional como uma &quot;pedagogia bancária», ou seja, os educadores &quot;depositam «informações nos educandos que por sua vez passam a ser meros depósitos de informações oriundos de um processo de memorização mecanizada.
Além disso, existe uma relação que os educadores são os que sabem (detentores do conhecimento) e os educandos não sabem.
Para Freire, a &quot;pedagogia bancária «é um destes processos de desumanização, pois por a extrema passividade dos educandos acaba se formando pessoas alienadas.
Em o sentido que a libertação é feita por os próprios indivíduos e que neste processo de libertação é extremamente importante à cooperação e a criticidade, o ciberespaço pode ser visto como um instrumento de humanização no processo educacional.
Evidentemente que esta transformação não ocorre simplesmente por a existência do ciberespaço, pois infelizmente esta tecnologia ainda não atingiu a maioria das pessoas, mas com o uso da tecnologia como uma mediadora que auxilia no desenvolvimento de habilidades importantes nesta era do conhecimento.
Entende- se como humanização do ensino respeitar o estilo individual de aprendizagem de cada aluno e isto implica no rompimento da relação tradicional aluno-professor e na criação de uma relação de co-autoria entre professor e o aluno.
Para Silva, a escola não está em sintonia com a emergência desta interatividade, mantêm- se fechada em si mesma, em seus rituais de transmissão, enquanto modifica- se o sistema comunicacional numa nova dimensão.
Para Silva a comunicação interativa é o desafio para a educação centrada no paradigma da transmissão, sendo que adotar este novo modelo não invalida o paradigma clássico.
Silva destaca as principais mudanças na comunicação considerando uma modalidade unidirecional (modelo tradicional) e a modalidade interativa:
Mensagem: Em a unidirecionalidade a mensagem é fechada, imutável, linear e seqüencial.
Em a interativa é mutável, modificável na medida que responde às solicitações do manipulador;
Emissor: É visto como um narrador que atrai o receptor para seu universo mental, seu imaginário, na abordagem unidirecional.
Em a interativa o emissor cria uma rede, não uma rota e define um conjunto de territórios para serem explorados.
Oferece um território aberto às navegações, modificações e interferências;
Receptor: Em a unidirecionalidade é passivo e assimilador.
Em a interativa o receptor é usuário, manipula a mensagem como um co-autor.
Em o contexto deste novo modelo de comunicação, baseado na interação a informática, recebe destaque por o fato destes princípios de interação estarem condicionados ao ciberespaço.
Porém, a interação pode ser aplicada numa sala de aula mesmo sem a presença de computadores.
O mais importante neste novo paradigma é considerar o aluno um sujeito ativo que manipula o conteúdo a sua maneira, respeitando sua forma de aprender e seus interesses pessoais.
Para Silva, a interatividade permite ultrapassar as condições de espectador passivo para condição de sujeito operativo.
Os jogos computadorizados mais avançados permitem que o jogador faça uma série de tomadas de decisão ao longo de a trama.
Ele cria estratégias em tempo real e imerso num enredo aberto à sua intervenção.
Em este trabalho considera- se o uso da informática, mais especificamente do ciberespaço no processo de ensino-aprendizagem, auxiliando na construção deste novo paradigma interacional, mas consciente que a interação pode estar presente na sala de aula independente do ciberespaço.
Para Haag, Passerino &amp; Henriques, uma educação tecnológica aspira formação de pessoas com a capacidade para compreender, selecionar, utilizar, avaliar e criar técnicas e/ ou tecnologias.
Portanto, o uso da informática na educação não substitui o modelo atual, mas complementa modificando- o com uma perspectiva de educação tecnológica.
Como foi visto anteriormente, a partir de o ciberespaço surgem novas formas de raciocínio, tais como os mundos virtuais, sendo que uma das formas mais intensa de expressão destes é a Realidade Virtual Imersiva seguido da Realidade Virtual NãoImersiva.
Por o fato da primeira modalidade requerer equipamentos com altos custos, a segunda modalidade, também conhecida como Realidade Virtual (RV) de mesa, surge como uma alternativa interessante do uso de RV por o fato se ser menos dispendiosa e eliminar a utilização de periféricos desconfortáveis.
A grande vantagem da RV é permitir explorar ambientes, processos e/ ou objetos através da manipulação e análise virtual do próprio alvo do estudo.
Por exemplo, ao invés de estudar através de livros, fotos e aulas o modo de vida das abelhas, o usuário pode experimentar um ambiente simulado de uma colméia exercendo papel de uma abelha neste mundo virtual.
Aulas de história sobre o Descobrimento do Brasil ou sobre Império Romano poderiam ser vivenciadas através da RV cujos aprendizes poderiam representar os papéis de um indígena ou um colonizador português no cenário do Descobrimento ou um cristão perseguido por os romanos.
A RV permite aprender &quot;visitando «lugares onde jamais estaríamos na vida real.
As potencialidades educacionais emergem da RV por o fato desta permitir fazer experiências com o conhecimento de forma interativa.
O maior diferencial da RV é:
&quot;permitir que um estudante aprenda sobre um assunto inserido no contexto deste assunto e assim receba, a cada ação que fizer, uma realimentação deste contexto».
Quando se fala em Educação emergem as palavras transmitir e instruir.
É interessante perceber que o conceito atual de Educação está fortemente relacionado com o modelo industrial.
A Educação muitas vezes se reduz à preparação do invidivíduo para o mercado de trabalho.
O grande desafio está em fazer educação no período pósindustrial preparando o aprendiz para ser autônomo, capaz de cooperar, de lidar com as novas tecnologias e ser criativo.
Por estas razões propor qualquer solução computacional transpassa uma mera solução de software e/ ou hardware.
Uma solução eficiente que se baseia na Informática e no ciberespaço deve estar fundamentada com teorias educacionais, devidamente contextualizadas com os demais processos sociais.
Pois se deseja contribuir para uma proposta nova e diferenciada de se fazer Educação.
Em as próximas subseções algumas teorias educacionais importantes ao contexto dos jogos computadorizados são apresentadas.
A taxonomia dos objetivos educacionais proposta por Benjamim S. Bloom tem por objetivo facilitar a comunicação entre pesquisadores através da classificação e hierarquização dos objetivos educacionais.
Ou seja, categorizar os comportamentos esperados dos alunos.
Basicamente os objetivos educacionais foram divididos em três domínios:
Cognitivo, afetivo e o psicomotor.
O domínio cognitivo está relacionado à memória e ao desenvolvimento das capacidades intelectuais.
O segundo domínio se refere à afetividade, envolvendo as mudanças de interesse, atitude e valores.
O domínio psicomotor trata das questões das habilidades manipulativas ou motoras.
O domínio cognitivo é subdivido em seis categorias:
Conhecimento, compreensão, aplicação, analise, síntese e avaliação.
Mesmo esta taxonomia sendo dos anos 50, com um forte racionalismo e a tendência prescritiva, ela é bastante interessante considerando o contexto dos jogos computadorizados.
Em estes jogos, a resolução de problemas está fortemente relacionada aos processos cognitivos, como é o caso dos RPGs e dos jogos de estratégia.
O jogador deverá desenvolver uma série de habilidades cognitivas partindo de habilidades mais simples relacionadas com o conhecimento, até raciocínios mais elaborados de avaliação.
Um exemplo disto é o jogo SimCity 2000 da Eletronic Arts.
Em este jogo, o jogador é desafiado a construir e a gerenciar uma cidade.
Primeiramente o objetivo do jogador é conhecer o jogo, descobrir a finalidades dos inúmeros botões existentes na interface (conhecimento).
Depois que os elementos principais do jogo são conhecidos, o jogador deve entender as funcionalidades e a mecânica do jogo (compreensão).
Pois, depois desta etapa, é possível fazer experimentações e observar o resultado de determinadas ações.
Desta forma, o jogador tem condições de entender cada uma das partes do jogo, que no caso de o SimCity envolve um sistema de finanças da cidade, sistema de segurança, sistema de habitação e políticas de investimento agrário, industrial e comercial (análise).
Entendendo estas estruturas o jogador é capaz de criar planos (síntese), atuar sob determinados sistemas e verificar resultados.
Por último, é capaz de julgar seus planos conforme critérios (avaliação), por exemplo, escolher qual o melhor plano para aumentar a produção industrial, reduzir a criminalidade, entre outros.
Uma pessoa que não conhece os elementos básicos do jogo e não compreende sua mecânica, dificilmente terá sucesso no gerenciamento da cidade, pois habilidades intelectuais elementares não foram desenvolvidas e o sucesso do jogo requer habilidades cognitivas sofisticadas, assim desta forma uma pessoa que consegue administrar corretamente uma cidade no jogo SimCity implica no julgamento de alternativas, do uso de habilidades intelectuais mais arrojadas.
A Teoria Interacionista proposta por Lev Seminovich Vygotsky possui como elemento central o conceito de mediação.
Para Vygotsky a mediação é o processo de intervenção de um elemento intermediário numa relação que deixa de ser direta e passa a ser mediada por esse elemento.
O desenvolvimento psicológico do indivíduo é determinado por a interação social.
Ou seja, diretamente com os membros da cultura, ou indiretamente através dos diversos elementos do ambiente culturalmente estruturado.
Outra concepção importante da teoria interacionista de Vygotsky é a zona de desenvolvimento proximal.
Quando o indivíduo é capaz de executar uma atividade sozinho, de forma independente denomina- se nível de desenvolvimento real.
Já as tarefas que precisam ser executadas com a ajuda de outras pessoas mais capacitadas são denominadas de nível de desenvolvimento potencial.
A a distância entre o nível de desenvolvimento real e o nível de desenvolvimento potencial é a zona de desenvolvimento proximal.
A intervenção constante nesta zona por indivíduos mais experientes contribui para o desenvolvimento do indivíduo ainda imaturo.
Desta forma é fundamental a intervenção do educador no papel de mediador para auxiliar neste processo de redução da distância desta zona.
Partindo- se do pressuposto que o ciberespaço é um local social, entende- se o desenvolvimento humano influenciado por as comunidades virtuais.
De a mesma forma que o ciberespaço como um todo é compreendido como um mediador no processo de aprendizagem, os jogos computadorizados também podem ser considerados estes mediadores para reduzir a zona proximal.
As brincadeiras são situações imaginárias com regras implícitas e os jogos possuem regras com situações imaginárias ocultas e ambos auxiliam no desenvolvimento do indivíduo por o fato de atuarem na zona de desenvolvimento proximal.
Para Horward Gardner, o ser humano é dotado de inúmeras inteligências e que a complexidade dos comportamentos humanos não é oriunda simplesmente da capacidade lógico-matemática mensurada nos testes de quociente de inteligência (QI).
O ser humano possui um conjunto de inteligências (competências) relativamente autônomas que podem ser modeladas e recombinadas de múltiplas formas por indivíduos ou culturas.
Cada competência intelectual humana (inteligência) é um conjunto de habilidades que permitem ao ser humano resolver problemas, em geral produzindo um produto, e criar ou perceber novos problemas.
Por exemplo, no caso de resolver alguma operação aritmética o indivíduo utiliza uma série habilidades lógico-matemáticas que provavelmente não serão usadas na mesma intensidade no caso de uma composição musical.
Primeiramente Gardner sugeriu sete inteligências:
Lingüística, musical, lógico-matemática, espacial, cinestésica, interpessoal e intrapessoal.
Em este contexto, de múltiplas inteligências, o uso dos computadores é extremamente importante por o fato de proporcionar meios diferenciados (sons, imagens, textos, canais de comunicação com outros aprendizes) para que o aprendiz escolha a forma mais confortável de aprendizado.
Um exemplo de software educativo que se baseia na teoria das múltiplas inteligências é o Brincando com Kauê desenvolvido por Balestro &amp; Mantovani destinado às crianças de cinco a seis anos de idade.
Apesar de não explorar todas as sete inteligências, o software pretende utilizar diversas competências cognitivas, tais como a espacial, musical e lógico-matemática para o desenvolvimento intelectual das crianças.
Outro exemplo de utilização das múltiplas inteligências é no ensino de medicina e no desenvolvimento de softwares educativos médicos.
Em este trabalho considera- se que os indivíduos em geral possuem duas ou três inteligências mais desenvolvidas e que a utilização de mais de uma inteligência nos materiais de ensino facilita o processo de aprendizagem, pois o aluno pode usar mais de uma inteligência para compreender a matéria.
As práticas pedagógicas predominantes na atualidade acabam utilizando poucos os jogos ou são usados em momentos especiais sempre acompanhados de algum objetivo pedagógico implícito, conforme Fortuna.
De maneira geral os jogos fazem forte oposição ao modelo de ensino-aprendizagem atual, centrado na figura do professor e com enfoque conteudista (conteúdo em detrimento de o processo de aquisição do conhecimento).
Principalmente por o fato do sistema de ensino atual ser forjado em intencionalidades e atividades dirigidas e o jogo representar uma atividade livre e prazerosa.
Para Fortuna, o jogo muitas vezes é proposto como uma &quot;isca «para fisgar o interesse do aluno, ensinando conteúdos de forma que ele não perceba que está aprendendo.
Deve- se ter muito cuidado com esta abordagem para não tornar o jogo somente um produto didatizado fazendo- o perder seu caráter prazeroso e espontâneo.
Em geral a indústria e os professores querem se redimir de oferecer brinquedos inúteis às crianças e passam a interferir no lazer infantil colocando conteúdo pedagógico no seu entretenimento.
O objetivo do jogo é, antes de qualquer coisa, jogar.
O que caracteriza os jogos são &quot;a espontaneidade, improdutividade, trânsito entre a realidade externa e interna, interatividade, simbolismo, constantemente recriado, desafio e instigação, mistério, imponderabilidade e surpresa».
O jogo por si só exercita a função representativa da cognição como um todo.
O brincar desenvolve a imaginação e a criatividade.
Assim o simples fato de jogar acaba desenvolvendo habilidades nos aprendizes extremamente úteis para desempenhar outras atividades, tais como a leitura e escrita.
De forma sumária podemos dizer que o jogo ensina a aprender.
Friedmann coloca a seguinte questão:
&quot;o jogo é um meio para atingir determinados objetivos ou tem um fim em si mesmo?»
Existem momentos que a criança brinca de forma espontânea somente por o prazer, por a diversão.
Em este caso o jogo é visto como um fim em si mesmo, ou seja, a finalidade do jogo é a diversão de forma espontânea.
Mas em outros momentos os jogos são vistos como meios educacionais como uma tentativa de resgatar a ludicidade na sala de aula.
Ou seja, usar o jogo para atingir objetivos preestabelecidos.
Um jogo computadorizado é definido por Battaiola como um sistema composto de três partes básicas:
Enredo, motor e interface interativa.
O enredo define o tema, a trama, os objetivos do jogo e a seqüência do jogo.
O motor do jogo, também conhecido por a denominação em inglês game engine, é o mecanismo que controla a reação do jogo em função de as ações do usuário.
E por último a interface interativa controla a comunicação entre o motor e o usuário reportando graficamente um novo estado do jogo.
O framework proposto neste trabalho enfoca o motor de jogo, não sendo abordado questões referentes ao enredo e a interface interativa.
Crawford destaca quatro propriedades comuns a qualquer um destes tipos de jogos, inclusive os computadorizados.
A primeira propriedade se refere à representação, um sistema formal fechado que subjetivamente simboliza um subconjunto da realidade.
Outra propriedade está relacionada com a interação.
Ou seja, a capacidade que o usuário possui de modificar a realidade representada no jogo.
Outra propriedade importante é o conflito.
Não existe jogo sem este componente, mesmo quando não está ocorrendo uma competição entre dois usuários.
Pelo menos, o jogador estará sempre competindo contra entidades controladas por o computador.
E por último, temos a propriedade da segurança, as pessoas gostam de jogar por o fato de experimentar uma realidade sem correr riscos.
Para Crawford, basicamente as pessoas jogam não só por o prazer, existe um desejo inconsciente de aprender.
O aspecto da fantasia, vivenciar mundos desconhecidos e ter experiências diferentes do cotidiano também são fortes motivadores.
Além destes aspectos, existem outros fatores motivacionais:
O desejo por o poder, concluir um grande número de jogos é prazeroso para o usuário;
O fato social, a possibilidade de integrar- se a uma comunidade;
A necessidade de tornar- se reconhecido;
Exercitar as habilidades cognitivas.
Praticamente cada usuário tem um tipo de motivação mais evidenciada, mas suas razões primárias são referentes à aprendizagem e a fantasia.
Battaiola destaca três grandes razões para utilizar jogos computadorizados em pesquisas científicas:
O aspecto educacional, auxílio ao desenvolvimento técnico-científico e a criação de um nicho mercadológico.
O primeiro refere- se à combinação de aspectos educacionais com entretenimento.
Segundo Battaiola, infelizmente estima- se que menos de 20% dos jogos possuem uma finalidade educacional.
Por esta razão, os jogos computadorizados com propósitos educacionais são um campo de pesquisa riquíssimo, principalmente quando ocorre uma integração com a Internet, permitindo uma maior integração e cooperação entre os jogadores.
Quanto a o aspecto técnico-científico, desenvolver um jogo é uma atividade multidisciplinar, envolve questões referentes às Linguagens de Programação, Sistemas Operacionais, Computação Gráfica, Engenharia de Software, Redes de Computadores e Inteligência Artificial.
Os jogos educacionais computadorizados são uma das modalidades de Cai (Computer Assisted Instruction) proposto por Coburn, Kelman, Roberts et al e são elaborados para divertir os alunos, desta forma aumentando a chance de aprenderem os conceitos, o conteúdo ou as habilidades embutidas no jogo.
Os jogos educacionais podem ser bastante simples como os de exercícios e práticas, mas podem ser ambientes de aprendizagem ricos e complexos, denominados por alguns de micromundos, porque estes fornecem um mundo imaginário para ser explorado por o aluno.
Para Papert apud Kafai micromundos são ambientes de aprendizagem interativos baseados em computador em a qual os pré-requisitos estão construídos no sistema e os aprendizes podem se tornar ativos, construindo sua própria aprendizagem.
Thomas Malone identificou três características que tornam os jogos computadorizados intrinsecamente motivadores:
Desafio, fantasia e curiosidade.
Para Greenfield, os jogos computadorizados são atraentes para as crianças porque estas desenvolveram preferências por as imagens visuais dinâmicas e animadas devido a a experiência televisiva e devido a a interatividade, pois a criança pode agir no jogo.
Foi realizada uma pesquisa por Clua, Junior &amp; Nabais com jovens de 10 a 17 anos, de classe média e moradores da cidade do Rio de Janeiro com o objetivo de verificar quais as razões que tornam os jogos computadorizados tão atrativos para os jovens e o que eles pensam sobre os jogos educacionais.
Para 85% dos jovens o que torna os jogos atrativos é o desafio.
Além disso, os jovens preferem ambientes imersivos com histórias ricas, jogos com qualidade gráfica e com personagens cuja Inteligência Artificial é sofisticada.
De estes jovens 68% consideram os jogos educativos ruins e ninguém considera estes jogos ótimos.
Os principais problemas dos jogos educacionais listados por os jovens são os seguintes:
Carecem de desafios grandes e motivadores;
Baixo grau de imersão;
Por o fato de serem elaborados por pedagogos a ênfase principal do jogo é a educação;
Em geral possuem baixa qualidade, pois são desenvolvidos com baixo orçamento.
Em este contexto evidencia- se a necessidade de desenvolver jogos com propósitos educativos de forma que atraia os jovens, desenvolva habilidades de forma explicita ou não e não seja uma forma alienante de ensinar, conforme expõe Fortuna em relação a o uso dos jogos para &quot;camuflar «a educação.
Visando melhorar a qualidade dos jogos educativos Clua, Junior &amp; Nabais sugerem um roteiro que deve ser observado durante o desenvolvimento de jogos didáticos:
Os desafios não devem estar relacionados com o assunto educativo;
Os aspectos educativos devem ser apresentados através do contexto, da ambientação ou de conhecimentos prévios do usuário;
Ambientes imersivos e personagens bem elaborados.
Lembrando que imersão implica em envolver o jogador no ambiente.
Além disso, a imersão não é só gráficos, é engajamento;
A ênfase no lúdico.
As características pedagógicas devem se adaptar ao roteiro;
Roteiros ricos, bem elaborados e com alto grau de interação.
Para Battaiola, Elias, Domingues et al, a motivação é o componente mais importante para o aprendizado.
O sucesso de um jogo é a combinação perfeita de enredo, interface interativa e o motor do jogo.
Para os autores a questão é porque não usar alguns princípios dos jogos computadorizados comerciais de grande aceitação por os jovens para implementar softwares educacionais, de forma a tornar- los mais atrativos?
Para Amory, os jogos educativos requerem enredos atraentes.
Para o autor é muito importante utilizar os jogos computadorizados no processo educacional por o fato dos jogos afetarem a motivação, as funções cognitivas e a curiosidade do aprendiz, pois estes jogos permitem a experimentação e a exploração do usuário.
Um dos grandes problemas dos jogos educativos é apresentar para o aprendiz uma coleção de enigmas sem nenhuma ligação, tornando o jogo desinteressante.
Por isto é interessante acrescentar nestes jogos princípios narrativos que estabeleçam início, meio e fim.
Por último, Amory acredita que os jogos computadorizados educativos disponibilizam uma forma onde o aprendiz pode estar imerso em micromundos construtivistas.
Segundo, existem os ambientes de aprendizagem que são diferentes da maioria dos Cais, pois estes ambientes não têm objetivos educacionais explícitos.
Auxiliam no desenvolvimento em áreas, tais como solução de problemas, planejamento, tomadas de decisão e julgamento estético.
Um ambiente de aprendizagem não contem um currículo esquematizado, não são definidas as habilidades nem os conceitos para serem aprendidos através do programa.
Coburn, Kelman, Roberts et al acreditam que estes ambientes serão usados de forma intensa, aliando a qualidade gráfica dos desenhos animados, motivação dos jogos computadorizados, a complexidade de Dungeons &amp; Dragons e o potencial lingüístico para o usuário construir suas próprias estórias.
Para Kafai, basicamente existem duas abordagens para o desenvolvimento de jogos com propósitos educacionais.
A abordagem instrucional e a construtivista.
A abordagem instrucional consiste da maioria dos jogos voltados para ensinar.
A criança aprende algo enquanto faz uma determinada atividade, pois existe uma integração do conteúdo que será ensinado com a idéia do jogo.
A outra abordagem é a construtivista, os jogos são usados para aprender.
As crianças constroem seus mundos utilizando ferramentas computacionais, muitas vezes linguagem de programação, tais como Logo.
Kafai realizou um projeto com crianças de 10 anos de idade para o desenvolvimento de jogos computadorizados visando o ensino de frações para alunos que estavam cursando o ensino fundamental.
O projeto dos jogos foi extremamente desafiador para os aprendizes que tiveram que planejar, resolver problemas, projetar, ensinar e revisar diversos conteúdos sobre frações.
Segundo Jenson &amp; Castel, a meta principal do educador é engajar os aprendizes como agentes e arquitetos de sua própria educação.
O maior desafio dos jogos com propósitos educacionais é oferecer para o aprendiz um ambiente que propicie a imersão onde os usuários queiram estar, explorar e aprender da mesma forma que os aprendizes fazem nos jogos computadorizados comerciais.
Os autores também concordam com a premissa que os jogos comerciais são extremamente atraentes para as crianças e jovens, com alta qualidade técnica.
Mas infelizmente são considerados por a sociedade como jogos sem valor educacional que consideram o jogador como um mero comprador.
Já os jogos educativos em geral não são atrativos, pois não criam uma sensação de imersão, trata o jogador como um estudante, pois possui uma forte abordagem educacional.
Os jogos didáticos devem seguir a rota do sucesso dos chamados jogos comerciais por o fato que estes permitem uma maior imersão, uma exploração do espaço e permite que o aprendiz interprete um personagem e explore um mundo virtual.
Os autores coordenam o projeto Ludus Vitae que consiste de um ambiente imersivo de jogo on-line focado no personagem com várias áreas e caminhos que podem ser explorados livremente por o aluno.
Tanto professores quanto aprendizes colaboram na construção deste mundo.
Cria- se a idéia de uma comunidade, independente das fronteiras curriculares.
Assim diante deste contexto devemos repensar o significado dos &quot;jogos computadorizados educativos».
Como foi apresentado anteriormente criou- se uma divisão entre jogos comerciais e jogos educativos.
Primeiramente tal denominação já estabelece um pressuposto que os jogos educativos não podem ser comerciais e viceversa.
Sabe que o primeiro grupo possui um forte apelo para os jovens, alta qualidade técnica e um conteúdo de puro entretenimento, enquanto que o segundo tem um fraco apelo entre os jovens, baixa qualidade e um enfoque altamente conteudista.
Battaiola e Bates consideram jogos educativos como uma modalidade de jogo computadorizado.
Em estes jogos existe uma proposta pedagógica explícita, seu principal objetivo é ensinar algo de uma forma lúdica.
Tal modalidade é conhecida como eduntainment.
Para Rollings &amp; Morris, existem os estilos de jogos e estes não são categorizados num único grupo, ou seja, em geral os jogos apresentam características de diferentes estilos.
Um dos estilos propostos por Rolling &amp; Morris é o estilo educacional, cujo aprendizado é efetuado através da prática.
Baseandose nesta concepção de Rollings &amp; Morris que permite que os jogos assumam diferentes estilos pode- se afirmar que os jogos podem ser desenvolvidos com um estilo educativo.
Assim, por exemplo, podem existir jogos de ação, de estratégia, de RPG, de esporte educativos.
Um ponto importante que precisa ser destacado para compreensão desta questão é a diferenciação entre a mecânica de um jogo e o seu conteúdo e que ambas possuem O termo RPG Digital se refere aos jogos de RPG no contexto do ciberespaço.
Isto é, aqueles jogos onde se utiliza o computador como uma ferramenta mediadora das ações dos jogadores.
Existem diferentes modalidades de RPG Digitais cada uma destas com características próprias.
Como neste trabalho estão sendo enfocados jogos computadorizados, destaca- se uma modalidade de RPG Digital denominada RPG Computadorizados (CRPG ­ Computer Role--Playing Game).
Por o fato dos RPGs apresentarem um papel educativo porque não utilizar os jogos de RPG para criação de mundos virtuais de aprendizagem, ou seja, porque não utilizar a modalidade computacional dos RPGs no processo de ensino-aprendizagem?
Porque não desenvolver RPGs computadorizados com aventura, ação e simulações (estilos de jogo que são atrativos para os jovens) e que possuam uma proposta pedagógica explicita sem reduzir o prazer da ludicidade?
Pizzol &amp; Zanatta incentivam que esforços sejam feitos para unir RPG, Computador e Educação, pois existe muita resistência no meio acadêmico para aceitar termos como jogo ou RPG como meios educacionais válidos.
Entretanto a comunidade mostrou- se ávida por resultados, isto leva a concluir que este mercado é fértil para investigação científica.
Em os Estados Unidos, foi desenvolvida uma pesquisa por Goodson-Espy, Espy &amp; Cifarelli que consistiu do uso de um 3D MMORPG2 de uma infra-estrutura para ser produzido.
Desta forma o escopo deste trabalho concentra- se no framework que permitirá projetar o Druida.
A o término deste capítulo algumas considerações devem ser feitas relacionando esta contextualização fortemente baseada em princípios oriundos da sociologia e da educação com a Ciência da Computação.
O que está sendo proposto neste trabalho está fortemente baseado nesta filosofia da cibercultura e na formação de sujeitos pósindustriais, assim não abordar tal temática antes de aprofundar os conceitos computacionais acabaria reduzindo as potencialidades da proposta.
Certamente a nossa sociedade neste início de século começa a modificar- se e adaptar- se ao novo modelo pós-industrial.
Desta forma o sistema educacional também sofrerá influências devido a as mudanças sócio-culturais.
Partindo do pressuposto que este novo modelo social é fortemente influenciado por a computação e por as telecomunicações novas tecnologias educacionais deverão ser geradas visando à formação de um cidadão cibercultural e integrado nesta nova sociedade emergente.
Exatamente nesta concepção de provedor de soluções tecnológicas que a Ciência da Computação possui um papel importante, pois também compete ao cientista da computação propor novas soluções para problemas oriundos da sociedade.
Em o caso deste trabalho a solução computacional estará inserida no contexto de Informática na Educação.
Compreendendo- se a importância dos jogos computadorizados, com ou sem fins pedagógicos explícitos, no processo de ensino-aprendizagem seria interessante fomentar a produção de novos títulos e com qualidade que poderão ser usados em ambientes de aprendizagem, tais como salas de aula.
Infelizmente tal ação não é simples de ser executada devido a os altos custos para o desenvolvimento de jogos computadorizados e para a aquisição de novos títulos.
Portanto seria interessante oferecer uma infraestrutura computacional com baixo custo que permitisse a construção de jogos computadorizados, desta forma colaborando no desenvolvimento das habilidades metacognitivas do aprendiz.
A criação destes jogos poderia ser explorada de diferentes formas, tais como serem desenvolvidos por os próprios alunos e professores, no âmbito acadêmico das universidades e por a iniciativa privada.
O que se espera futuramente é a construção de mundos virtuais de aprendizagem baseados nos elementos de RPG (Projeto REVOLUTION -- Druida).
Certamente que desenvolver esta ferramenta durante o período da dissertação por um único indivíduo tornaria este processo impossível de ser concluído, pois a criação de jogos requer grandes equipes, prazos e orçamentos para serem desenvolvidos.
Mesmo enfocando um gênero de jogo, o processo de desenvolvimento de jogos pode ser visto de uma forma mais ampla, permitindo a concentração das etapas iniciais do grande projeto no desenvolvimento de uma infra-estrutura que permita a construção de jogos computadorizados, independente de gêneros e estilos.
Desenvolvendo tal artefato o processo de criação de jogos tornaria- se- mais simplificado, desta forma facilitando a popularização dos títulos e por conseqüência o uso em instituições de ensino.
Em o próximo capítulo serão abordados conceitos envolvendo o desenvolvimento de jogos computadorizados, destacando as tecnologias existentes e técnicas de Engenharia de Software, tais como design patterns e frameworks, no processo de criação de motores de jogos.
Como foi ressaltado no capítulo anterior, os jogos computadorizados podem ser utilizados como ferramentas educacionais.
Portanto, para produzir tais artefatos tornase necessário o conhecimento de como produzir- los e quais ferramentas podem ser usadas na criação de jogos sob o ponto de vista computacional.
O objetivo deste capítulo é apresentar os principais elementos que compõem os jogos computadorizados destacando as tecnologias que estão sendo utilizadas durante a fase de implementação, tais como bibliotecas de funções, toolkits, SDK (Software Development Kits) e game engines.
Além disso, são destacadas técnicas importantes oriundas da Engenharia de Software que permitem construir aplicações computacionais de forma mais simplificada e com alto reaproveitamento de projeto e de código, tais como, os frameworks, padrões de projeto (design patterns) e componentes reutilizáveis.
Em a finalização deste capítulo serão destacados os principais requisitos de um framework voltado para a criação de jogos computadorizados baseando- se nas ferramentas que foram analisadas e nas principais arquiteturas de jogos computadorizados.
Furtado &amp; Santos complementam estes conceitos destacando que as game engines proporcionaram uma redução significativa no ciclo de vida do desenvolvimento de um jogo computadorizado, pois os motores permitiram que o processo de programação do jogo fosse mais automatizado, permitindo uma maior concentração nas áreas referentes aos recursos multimídia e ao roteiro.
Ainda, Furtado &amp; Santos, destacam que as engines permitem que o programador especifique em alto nível como será o comportamento de seu jogo, sem necessariamente saber como que este comportamento será implementado.
Trata- se de criar uma abstração do comportamento.
Para Watt &amp; Policarpo, os principais fatores envolvidos na criação de uma game engine para ser usada por diferentes jogos computadorizados são:
Oferecer um conjunto de facilidades requeridas por os diferentes gêneros de jogos.
A questão estabelecida por os autores é qual o nível de facilidade que deverá ser oferecido por a engine?
Oferecer diferentes possíveis otimizações típicas para cada gênero de jogo;
A evolução continua do hardware acaba tornando as funções de software redundante (soluções embarcadas), podendo encurtar o ciclo de vida da game engine;
Muitos esforços investidos no desenvolvimento de um jogo podem consistir no desenvolvimento de ferramentas de apoio que não possuem alta reusabilidade, por exemplo, editores de níveis.
Além destes fatores Watt &amp; Policarpo fazem uma conceituação bastante importante sobre a estrutura de um jogo.
A complexidade de um jogo esta embarcada na game engine e em seus plug-ins.
A grande parte do esforço da programação do jogo e de sua complexidade está na game engine.
Desta forma as game engines poderão delegar grande parte de seu esforço para os seus plug-ins.
A idéia principal é construir uma simples game engine que seja capaz de lidar com qualquer estrutura de jogo, utilizando uma série de componentes.
Para Hodorowicz (Madeira e Domingues também referenciam este autor), uma game engine é dividida em:
Sistema, console, suporte, renderer, interface do jogo, jogo e dados (ferramentas).
Cada uma destas partes será detalhada a seguir.
Dados: O jogo necessita de um conjunto de dados, tais como imagens, sons, músicas e modelos 3D.
Grande parte do desenvolvimento da game engine consiste na criação de ferramentas para o desenvolvimento de tais dados.
Podem ser usadas ferramentas de terceiros, mas em geral algum ferramental deve ser criado para ser usado em conjunto com a game engine, tais com um editor de mapas, um empacotador de arquivos ou um conversor de formatos.
Sistema: O sistema comunica- se diretamente com o hardware do dispositivo.
O próprio sistema é responsável por a inicialização, atualização e encerramento dos subsistemas responsáveis por os gráficos, entradas, som, temporizador e configuração do motor.
No caso de o subsistema gráfico, este é responsável por a apresentação dos objetos do jogo num dispositivo de vídeo.
O subsistema de entrada deve ser responsável por a captura das interações do jogador através do mouse, joystick, teclado ou qualquer outro dispositivo de entrada.
Em este aspecto Hodorowicz destaca um fato bastante importante, para a lógica do jogo não importa se o protagonista está sendo movimentado com um joystick ou com um teclado.
O subsistema de som é responsável por carregar e reproduzir os sons.
O temporizador é utilizado para sincronização e controle de eventos dependentes do tempo.
E por último o subsistema de configuração trata da definição dos parâmetros dos demais subsistemas, tais como mudança da resolução do vídeo, profundidade de cores, opções de som, entre outras definições.
O módulo Modelo trata- se dos modelos geométricos e os atributos visuais dos objetos de uma cena e provê as funcionalidades para organização da cena, detecção de colisão e outras operações gráficas, tais como geradores de partículas.
Em este contexto estão as classes de Repositório, Representação de Cena e Gerenciamento de Cena.
O módulo Visão é responsável por a geração das imagens.
Possui classes responsáveis por o volume de visão, projeção, câmera, área de visualização e o renderizador.
Destaca- se que estas classes são responsáveis por a criação de gráficos 3D que é o foco da dissertação de Domingues.
Algumas destas classes são abstratas e representam os chamados hot spots do framework que deverão ser personalizados por o desenvolvedor.
O módulo Controlador é responsável por a dinâmica do sistema.
Trata- se dos gerenciadores responsáveis por a manipulação dos dados de entrada, simulação física, dados de entrada e saída da rede de comunicação e os dados referentes aos algoritmos de Inteligência Artificial.
Domingues não abordou os controladores de rede e de Inteligência Artificial.
Em este módulo estão classes de sinais para comunicação entre objetos do modelo, temporizador, gerenciador de entrada, gerenciador de simulação física e o gerenciador de animação.
A camada de Sistema fornece duas abstrações, uma de hardware e outra de software.
A abstração de hardware comunica- se com dispositivos físicos e com o sistema operacional, enquanto a abstração de software fornece alguns componentes fundamentais para criação dos jogos, tais como estruturas de dados e funções matemáticas.
Em relação a a estrutura de Hodorowicz a abstração de hardware seria equivalente ao sistema e a abstração de software equivaleria ao componente de suporte.
Gelatti apresenta uma proposta de um framework bastante interessante.
O objetivo da arquitetura proposta por o autor é uma tentativa de padronização das arquiteturas das engines, permitindo que o desenvolvedor troque de engines sem precisar reaprender uma nova arquitetura ou ter que reescrever grandes quantidades de código.
A arquitetura proposta por Gelatti é decomposta em três camadas principais.
O esquema desta arquitetura do framework pode ser vista na Figura 5.
Os componentes desta arquitetura podem ser organizados em três camadas principais:
De sistema operacional, de usuário e de cena.
Gerenciador gráfico efetua a transformação da cena dos objetos do jogo em imagens para serem exibidas nos dispositivos gráficos;
Gerenciador de som para execução de sons a partir de eventos;
Gerenciador de Inteligência Artificial para controlar o comportamento de entidades artificiais sob o controle do computador;
Gerenciador de múltiplos jogadores para permitir a troca de informações entre jogadores conectados via Internet ou Intranet;
Gerenciador de objetos para manter os objetos lógicos do jogo;
Objeto do jogo representa as entidades que fazem parte do contexto do jogo e todas as informações necessárias referentes à lógica da aplicação;
Gerenciador do mundo armazena o estado atual do jogo e necessita de diversos gerenciadores de objetos;
Editor de cenários usado para criar estados de jogo usando uma ferramenta visual sem a necessidade de programação, extremamente usado para criação de níveis;
E por último, o gerenciador principal que permite a integração das partes do jogo, além de representar uma &quot;fachada», ou seja, um único ponto de acesso ao sistema.
A partir de esta arquitetura Pessoa sugeriu uma game engine para criação exclusivamente de jogos 2D para dispositivos móveis denominada wGEM.
É importante se destacar algumas definições e diferenciações entre as inúmeras ferramentas existentes para o desenvolvimento de jogos computadorizados.
Existem muitas contradições e definições errôneas dos termos utilizados na literatura da área, tais como biblioteca (library), toolkit, game engine e framework.
Uma biblioteca é um conjunto de rotinas gravadas num arquivo onde cada uma destas possui um nome e uma funcionalidade específica.
Para o programador basta referenciar tais funções, sem precisar que estas sejam reescritas todas as vezes que forem necessárias.
Estas bibliotecas podem comportar uma série de funcionalidades específicas para um domínio, por exemplo, jogos computadorizados.
Tais rotinas não são orientadas a atividades, mas a funcionalidades.
No caso de uma biblioteca para jogos esta pode oferecer funcionalidades para manipulação de imagens, arquivos, reprodução sonora, criação de imagens e/ ou algoritmos de Inteligência Artificial.
Portanto, não se aconselha o uso direto destas bibliotecas nas aplicações, recomenda- se criar um toolkit ou uma engine que utiliza estas funções e permite facilmente criar inúmeros jogos baseados no mesmo motor.
Basicamente, as bibliotecas tais como a OpenGL encapsulam funcionalidades de mais baixo nível com grande acesso ao hardware.
Pressman define que na análise estruturada o sistema é dividido em partes funcionais e procura- se modelar o fluxo (controle) e o conteúdo da informação (dados).
Esta forma de modelagem possui uma metodologia de projeto também baseada no fluxo de dados.
Para a implementação destes sistemas utiliza- se linguagens de programação estruturada, tais como Pascal e C. Destaca-se que esta forma de análise, projeto e implementação teve seu apogeu no final dos anos 70 com Tom DeMarco[ PRE 95].
Em este contexto as funções e estruturas de dados providas por as bibliotecas eram utilizadas para desenvolver aplicações modulares permitindo tais funções ser reutilizadas em diversas aplicações.
Em a Figura 12 esta esquematizado esta forma de programação estruturada centrada nas funcionalidades e nos dados.
Em suma a aplicação consiste de um programa principal que executa vários processos que por sua vez acessam uma coleção de dados.
Sprite é um gráfico de tamanho arbitrário que em geral é usado por as entidades computacionais, por os jogadores ou como objetos decorativos.
Em a maioria dos casos os sprite são animados.
Engine, trata- se do mecanismo para detecção de colisão.
Destaca- se que Wen trata a Crystal Space como uma game engine, quando na verdade ela trata- se de um toolkit.
Uma característica da arquitetura do Crystal Space muito importante é o uso do sistema de plug-ins, isto é, um executável funcionará com diversos renderizadores, tais com OpenGL, Direct3D e Glide.
Assim cria- se uma camada de abstração da interface oferecida por a ferramenta e a forma de implementação que poderá adotar qualquer mecanismo de renderização.
Gradativamente novos plug-ins são criados e distribuídos separadamente facilitando o processo de desenvolvimento por o fato desta alta modularidade.
Para citar um exemplo de aplicação do Crystal Space, pode- se destacar o jogo PlanetShift.
Este jogo consiste de um MMORPG com gráficos 3D e distribuído gratuitamente.
A DarkBASIC é uma linguagem baseada no BASIC para criação de jogos computadorizados.
Desenvolvida por a empresa Pixtudio, a DarkBASIC não possui código aberto e possui três versões cujos preços atualmente variam de U 14,99 à U 49,99.
A versão mais simples não permite criar arquivos executáveis.
A Pixtudio fornece dez licenças da versão mais simples do DarkBASIC gratuitamente para as escolas.
É executável somente na plataforma Windows e utiliza a biblioteca DirectX.
Utilizando a linguagem BASIC é possível construir jogos com gráficos 2D ou 3 D, multiplayer e com suporte a som.
Possui um editor gráfico para codificação do jogo e uma série de ferramentas não gratuitas voltadas para jogos 3 D, tais como um construtor de jogos, coleção e modelador de objetos, editor de níveis 3D e gerador de texturas.
Quanto a a documentação, no site estão disponibilizados alguns tutoriais e existe um livro voltado aos iniciantes de como utilizar o DarkBASIC.
Além disso, no site existem os fóruns de discussão, onde os interessados podem trocar experiências e informações.
O DirectX é uma biblioteca proprietária desenvolvida por a Microsoft distribuída gratuitamente.
A grande maioria dos jogos computadorizados comerciais utiliza o DirectX para o desenvolvimento de jogos.
É uma biblioteca voltada somente para a plataforma Windows.
Recentemente está sendo distribuída uma versão para o Windows CE e para o Dreamcast.
Esta biblioteca é implementada em C+, porém existem bindings para outras linguagens, por exemplo, o Delphi possui o DelphiX que consiste de componentes que acessam o DirectX.
No caso de o Java, a API Java3D da Sun pode utilizar a OpenGL ou DirectX para renderizar os gráficos 3D e a Microsoft oferece o Microsoft SDK for Java que inclui um binding do DirectX para Java.
O DirectX foi lançado em 1995 e é reconhecido como um padrão para o desenvolvimento de aplicações multimídia.
É importante destacar que segundo Hecker, se uma tecnologia é interessante para Microsoft ou qualquer outra grande empresa influente não significa que esta tecnologia seja interessante para toda a indústria de jogos.
Às vezes seguir uma tendência lançada por uma grande indústria não é uma boa decisão para determinado projeto.
Em este sentido deve- se sempre adotar uma postura crítica quanto a o uso de uma tecnologia e não adotas- la simplesmente por uma questão de modismo ou senso comum.
Considerando o framework proposto adotar exclusivamente a tecnologia DirectX não seria uma boa decisão por o fato de inúmeras escolas utilizarem outros sistemas operacionais incompatíveis com esta biblioteca.
Com a utilização do DirectX, os desenvolvedores podem acessar características de hardware especializadas sem precisar escrever código de máquina.
Permite acesso a placas gráficas (desenhos 2D ou 3 D), suporte a diferentes dispositivos de entrada (mouse, teclado e joystick);
Manipulação de sons (mixagem e reprodução);
Suporte a jogos em rede (multiplayer);
Apresentação de vídeos;
E o recurso de criar instaladores.
Com o surgimento do DirectX o processo de desenvolvimento de jogos foi facilitado, pois as rotinas de baixo nível presente nos jogos passaram a ser executadas por esta biblioteca que funciona como uma abstração de hardware.
Fly3D foi desenvolvido por o brasileiro Fábio Policarpo em parceria com Alan Watt durante a elaboração do livro 3D Games Vol_ 1 ­ Real-Time Rendering and Software Technology.
O livro é a principal fonte de documentação.
Para complementação são oferecidos alguns fóruns de discussão.
A versão 1.02 é gratuita tanto para uso comercial quanto para o uso não comercial.
Já a versão 2.0 que inclui uma engine, SDK, ferramentas adicionais e o código-fonte está disponível para aplicações comerciais conforme o pagamento de uma taxa não informada no site oficial do produto.
O Fly3D é implementado em C+ e executa somente na plataforma Windows e suporta tanto o DirectX quanto OpenGL.
Não tem suporte para dispositivos móveis.
Foi desenvolvido com ênfase para renderizar gráficos 3 D, apesar de permitir criar jogos 2D.
Apresenta suporte a jogos multiplayer e reprodução de sons.
A arquitetura do Fly3D baseia- se que todos os comportamentos da engine são encapsulados em plug-ins, ou seja, os front-ends são separados da aplicação do jogo e no uso intenso do conceito de herança das classes.
De forma sumária é possível afirmar que o Fly3D utiliza um tipo de objeto para efetuar todas as suas operações.
Assim para novos objetos basta criar uma subclasse a partir de esta interface padrão.
Destaca- se que o Fly3D é uma ferramenta de propósito geral, apesar de enfocar jogos de ação em primeira pessoa, jogos de estratégia e de corrida.
Os próprios autores, Watt &amp; Policarpo afirmam que o Fly3D é um SDK, isto é, oferece um conjunto de classes que podem ser usadas no desenvolvimento de novos jogos.
Entretanto, por as definições que foram feitas anteriormente o Fly3D não pode ser tratado como uma engine, mas sim como um toolkit, pois este simplesmente provém uma série de implementações referentes às operações de Computação Gráfica.
Genesis3D foi desenvolvido por a empresa Eclipse Entertainment usando C e C+ e executa somente na plataforma Windows utilizando a tecnologia DirectX.
Distribuído gratuitamente como um projeto Open Source pode ser usado em aplicações com ou sem fins lucrativos desde que todas as modificações da ferramenta sejam disponibilizadas para comunidade e sempre seja exibido o logotipo Genesis3D.
No caso de não utilização do logo e/ ou não divulgação das alterações deve ser assinada uma licença de U 10.000,00.
Além disso, não possui suporte para dispositivos móveis.
No caso de esta ferramenta, no site oficial do produto é apresentada como um SDK.
O site da empresa oferece alguns tutoriais, um fórum de discussão e o código-fonte bastante documentado.
Baseando- se nas funcionalidades, aspectos positivos e negativos detectados na análise destas ferramentas para implementação dos jogos computadorizados é possível destacar alguns requisitos fundamentais para um framework que visa à criação de game engines.
Tais requisitos estão listados a seguir:
Multiplataforma: Fundamental a criação de um framework que permita desenvolver motores de jogos multiplataforma, seja esta um computador pessoal ou outro dispositivo qualquer, tais como um telefone celular e um handheld.
Game engines que permitem desenvolver um jogo voltado para sua lógica e integrar esta com componentes dependentes da plataforma de execução são inéditas.
Conforme foi visto nenhum dos grandes motores e das bibliotecas permitem desenvolver um jogo para diferentes plataformas bastante peculiares.
Basicamente as engines multiplataformas encontradas referem- se a um mesmo tipo de hardware.
Por exemplo, executam no Linux ou no Windows, porém, estes diferentes sistemas operacionais executam sob um computador pessoal que possui uma configuração de hardware específica;
Licença de Uso: Desenvolvimento sob a filosofia de software livre distribuído sob a licença LGPL para permitir que o framework seja constantemente revisado e desta forma facilitando o desenvolvimento de novos componentes por o fato do desenvolvedor ter acesso ao código-fonte.
Em o momento que se adota a licença LGPL, se permite que as game engines e extensões desenvolvidas sejam proprietárias ou livremente distribuída.
Desta forma se possibilita flexibilidade para o desenvolver que pode adotar uma licença de distribuição mais adequada a sua estratégia de negócio;
Custo: Além de distribuir livremente manter o custo do framework gratuito permite uma ampla utilização principalmente envolvendo o desenvolvimento de jogos com fins educacionais para plataformas com poucos títulos, como é o caso do Linux.
Facilitando, assim, o uso nas escolas, principalmente as instituições públicas.
É importante destacar que a gratuidade está associada ao framework.
Pois, cada desenvolver é livre para definir uma política de cobrança para as game engines criadas a partir de o framework e, para os jogos que respectivamente executam neste motor;
Flexibilidade na Visualização:
O framework deve permitir facilmente a troca do componente de criação das imagens do jogo, sem afetar a mecânica do jogo.
Isto significa que pode ter sido desenvolvida uma game engine que utiliza gráficos 2D para apresentar as imagens e a posteriori decide- se trocar esta forma de visualização por um mecanismo de renderização 3D.
Este requisito é muito importante principalmente no desenvolvimento de jogos educativos, pois é possível desenvolver um mecanismo de jogo (lógica da aplicação) sofisticado com uma forma de visualização mais simplificada, pois se acredita que a manipulação de imagens 2D ao invés de modelos 3D é mais simples para os educadores e jovens aprendizes.
Se posteriormente se deseja criar um mecanismo de visualização mais sofisticado é só trocar- lo sem comprometer a lógica da aplicação;
Flexibilidade na Persistência:
De a mesma forma que o mecanismo de visualização deve ser facilmente substituível os mecanismos de persistência também devem.
Quando se desenvolve a lógica de um jogo, esta é independente de plataforma.
Quando se deseja armazenar o estado do jogo atual esta lógica de jogo pode estar sendo utilizada num computador pessoal que utiliza um sistema de arquivos ou está rodando num handheld que possui um outro mecanismo de armazenamento.
Portanto, as game engines devem ser independentes da forma de persistência dos dados.
Linguagem Java: Principalmente para atender o primeiro requisito optou- se por o uso da linguagem Java desenvolvida por a Sun Microsystems.
Basicamente o framework deverá executar em qualquer ambiente que possua uma máquina virtual Java, portanto o framework deverá possuir uma camada de abstração que encapsule as especificidades de cada máquina virtual.
Os mecanismos de controle e visualização não utilizam as classes nativas da máquina virtual, devem utilizar esta camada de abstração do framework.
Caso a linguagem ofereça algum tipo de problema de performance, pode- se utilizar métodos nativos para implementação de trechos de código críticos, tais como renderização, na linguagem C/ C+.
É importante ressaltar que o fato de utilizar a linguagem Java na implementação do protótipo não inválida o modelo arquitetural que poderá ser implementado em qualquer linguagem orientada a objetos.
Não pode ocorrer uma mistura de decisões de ordem tecnológicas e as soluções computacionais propostas que independem de tais decisões.
Após a análise e estudo das arquiteturas de motores de jogos existentes e das ferramentas adotadas para criação de jogos computadorizados foi possível iniciar a definição da proposta do framework.
Primeiramente foi necessário tratar a questão referente a a identificação deste projeto.
Para facilitar o processo de comunicação e o reconhecimento da comunidade é necessário denominar o framework.
Para isto foi escolhido o nome Amphibian.
Este termo é uma palavra oriunda da língua inglesa que significa anfíbio.
Este tipo de animal, cujo sapo é a espécie mais representativa deste grupo, possui a habilidade de viver num meio aquático e num meio terrestre.
Para que isto seja possível estes seres possuem uma estrutura biológica principal e alguns órgãos especializados para desempenharem determinadas funções conforme o meio.
Por exemplo, existem órgãos voltados para respiração em meio aquoso e em meio terrestre.
Metaforicamente, da mesma forma que um anfíbio, o framework proposto no presente trabalho tem por objetivo permitir criar game engines capazes de executarem em diferentes dispositivos mantendo a mesma lógica do jogo.
Para isto utiliza uma arquitetura geral que permite o uso de componentes específicos para cada uma das plataformas.
Em as próximas subseções o Amphibian apresenta- se o detalhamento do modelo proposto.
Primeiramente será apresentado um enfoque geral da arquitetura e depois cada decisão de projeto para atender os pré-requisitos a ela relacionados.
Em o capítulo 5 serão abordadas algumas questões técnicas referentes a prototipação, casos de teste desenvolvidos usando o protótipo, levantamento de algumas métricas referentes à qualidade do framework e por último alguns testes de desempenho.
Quando se considera a complexidade de um jogo, implicitamente o enredo também está sendo tratado.
Em este contexto consideramos jogos complexos aqueles que necessitam uma grande quantidade de objetos e/ ou apresentam uma grande quantidade de processamento.
Conseqüentemente tais jogos irão consumir mais recursos computacionais quanto a o uso de memória e processamento.
Em contrapartida jogos simples são aqueles que necessitam poucos objetos lógicos e/ ou efetuam pouco processamento.
Pressuposto&amp; 1: Diferentes jogos computadorizados possuem diferentes graus de complexidade e cada um destes jogos requer um processo de desenvolvimento diferenciado considerando as especificidades oriundas deste grau de complexidade.
Para desenvolver um jogo computadorizado com alto desempenho, seria necessária sua construção para um único hardware, desta forma efetuando o máximo de otimizações considerando as instruções específicas oferecidas por o processador.
Em este sentindo além de as otimizações algorítmicas são utilizados códigos em Assembler para executarem sob uma plataforma específica.
Assim neste contexto teríamos o máximo de performance possível.
Em contra partida devido a a alta especificidade dificulta extremamente a portabilidade do código para outras plataformas.
Por outro lado, um jogo computadorizado pode ser desenvolvido usando uma arquitetura que proporciona uma alta abstração do hardware facilitando portar- las para diferentes dispositivos.
Entretanto à medida que são adicionados estes elementos de projetos para incrementar a abstração adiciona- se um overhead no sistema comprometendo sua performance.
Então se conclui que o desempenho de uma aplicação é inversamente proporcional ao nível de generalização de sua arquitetura.
Portanto um dos desafios na concepção do framework está justamente na criação de uma arquitetura genérica que não comprometa o desempenho, ou seja, que não inviabilize sua jogabilidade.
Outra observação que pode ser feita é que sempre um determinado nível de generalização de uma arquitetura irá ter um desempenho máximo em conseqüência ao seu nível de abstração.
Portanto deduze- se que a partir de esta arquitetura é possível desenvolver diferentes jogos que exijam no máximo o desempenho suportado por a arquitetura.
Assim dada uma arquitetura é possível criar um conjunto de jogos em conformidade com a limitação de desempenho e um conjunto de jogos que não é possível de ser implementado.
Sempre adotar a mesma metodologia de desenvolvimento de jogos computadorizados considerando que tal aplicação requer um alto desempenho, significa que sempre os desenvolvedores terão que reescrever a aplicação por o fato de sempre perder generalização.
Então em jogos que não requerem alto desempenho ocorre uma perda de tempo de projeto preocupando- se com detalhes supérfluos.
Desta forma não é recomendável sempre considerar que os jogos computadorizados requerem alto desempenho.
Portanto existirão aplicações cujo Amphibian não será a melhor solução computacional, entretanto um conjunto de jogos poderá ser desenvolvido reaproveitando a generalização oferecida por o framework de forma muito mais rápida e fácil.
Pressuposto&amp; 2: Os motores de jogos possuem diferentes graus de generalização, alguns motores são específicos para um determinado jogo e outros motores possuem uma maior abrangência permitindo que diferentes jogos sejam construídos usando o mesmo motor de jogo.
Cada motor de jogo pode oferecer um nível de abstração diferenciado, ou seja, que permita desenvolver diferentes títulos de jogos usando a mesma mecânica, simplesmente alterando seu parâmetro e os objetos do jogo.
Alguns jogos por o fato de apresentarem uma mecânica de jogo bastante simplificada, até mesmo oriunda de um enredo simplificado terão um grau menor de generalização para outros jogos.
Por exemplo, a mecânica do jogo Snake1 é bastante simplificada, logo é difícil gerar diferentes títulos usando o mesmo motor.
O máximo que pode ocorrer é uma modificação dos componentes multimídia do jogo.
Portanto apresenta um baixo grau de generalização.
Por outro lado, se considerarmos um motor de jogo para criação de CRPG é possível criar diferentes títulos, pois por o fato da complexidade da mecânica do jogo esta oferece uma série de pontos de personalização.
Em este caso pode- se citar o exemplo dos jogos Baldur's Gate e Baldur's Gate II que são títulos diferenciados, entretanto usam o mesmo motor de jogo.
Considerando este pressuposto é possível contemplar dois cenários diferenciados.
O primeiro trata- se de utilizar o framework somente para criar motores de jogo com baixa generalização.
Em conseqüência de esta abordagem cada título de jogo possui um motor de jogo.
Apesar de primeiramente tal cenário aparentar- se negativo, se considerarmos que está sendo usado um framework para criar motores, existe uma padronização no processo de desenvolvimento, desta forma reduzindo a curva de aprendizado dos desenvolvedores e facilitando o processo de desenvolvimento.
O segundo cenário, mais otimista, considera que n títulos podem ser desenvolvidos usando o mesmo motor.
Em este caso a adoção do framework também é benéfica por as mesmas razões apresentadas para o primeiro cenário, além de representar uma redução de custos devido a a alta reusabilidade.
Pressuposto&amp; 3: Alguns motores de jogos não podem ser portáveis para diferentes dispositivos por o fato de sua mecânica requerer recursos disponíveis somente em determinados dispositivos.
O que se espera é desenvolver jogos computadorizados portáveis para diferentes dispositivos, entretanto em algumas situações isto não poderá ser efetuado por o fato do motor de jogo ser inerentemente complexo e o dispositivo não disponibiliza recursos suficientes para sua execução.
Tratando desta questão de portabilidade podem ser considerado três cenários ­ totalmente portável, parcialmente portável e não-portável.
O primeiro e o terceiro cenário são os casos extremos, e o segundo cenário representa um determinado nível de portabilidade.
Em a Figura 17 estes cenários estão representados de forma esquemática.
Considera- se a fim de representação que os círculos representam a disponibilidade de recursos oferecidos por um dispositivo e o círculo preto simboliza o quanto de recurso Jogo bastante conhecido por o fato de ser distribuído nos telefones celulares.
Consiste de alimentar uma serpente e à medida que esta se alimenta sua cauda aumenta.
O jogador que controla a serpente deve alimentar- se e não pode fazer com que a serpente colida com as paredes ou com o corpo da serpente.
O objetivo do Amphibian é fornecer um conjunto de classes para o desenvolvimento de motores de jogos multiplataforma, onde as aplicações oriundas destes motores serão orientadas à lógica da aplicação.
Ou seja, a lógica de determinado jogo poderá ser portada para diferentes plataformas, desta forma garantindo uma maior reusabilidade, oferecendo uma solução com alta portabilidade.
Espera- se que utilizando o Amphibian modele- se somente a lógica do jogo e porta- se a aplicação com extrema facilidade para multiplataformas.
O ideal é que o projetista do jogo preocupe- se somente com a mecânica do jogo (lógica) e com os objetos do jogo, sejam estes elementos sem representação visual ou elementos multimídia, tais como gráficos, sons e música para cada plataforma que o jogo irá executar.
Ressaltando que este processo considera o escopo pré-definido por os pressupostos apresentados na seção 4.1.
O Amphibian pretende atender os requisitos apresentados na seção 3.4 da seguinte forma:
Um motor de jogo em geral, deve ser executável na plataforma de computadores pessoais (Windows, Linux e MacOS), móveis (PalmOS e Windows CE), celulares (Symbian Os) e motores integrados com tecnologia Web (servlets e applets);
Além de estas plataformas e sistemas citados anteriormente o Amphibian deve ser extensível, ou seja, ser adaptável para uma nova plataforma que não esteja prevista no item anterior;
Independente do dispositivo de visualização, ou seja, uma aplicação pode ser visualizada com gráficos bidimensionais (vista superior ou isométrica) ou gráficos tridimensionais em qualquer dispositivo, seja este um monitor ou um display de um handheld ou telefone celular.
Considerando o pressuposto 4 apresentado na seção 4.1;
Independente do mecanismo de persistência.
Em este contexto a persistência trata da configuração do motor de jogo, da descrição do jogo e dos objetos que são utilizados.
Portanto as questões referentes a salvar e recuperar uma sessão de jogo estão incluídas neste tópico;
A persistência dos dados pode ocorrer no módulo cliente ou em servidor remoto.
Independente do local de armazenamento, a forma de persistência dos objetos deve ser flexível.
Isto implica em persistir os dados usando um gerenciador de banco de dados, XML (eXtensible Markup Language), arquivos de textos, formatos proprietários, PDB (Palm Database) ou um outro formato de armazenamento qualquer;
Oferecer alta modularidade.
Deve permitir trocar os componentes do motor afetando o mínimo possível outros componentes, principalmente os que se referem aos componentes da lógica da aplicação;
Distribuído sob os termos da licença LGPL;
Uma solução com baixo custo (valor monetário) para ser ofertada para comunidade.
O Amphibian está sendo desenvolvido para permitir o avanço técnico-científico, principalmente no cenário brasileiro, do desenvolvimento de jogos computadorizados, seja no âmbito acadêmico ou no âmbito comercial beneficiando principalmente a indústria na produção de jogos para computadores pessoais e dispositivos móveis.
Além disso, como foi apresentado no capítulo 2, espera- se construir motores de jogos para serem utilizados na área de Informática na Educação.
Espera- se que por o fato de desenvolver um framework para construir motores de jogos multiplataforma e que seja livremente distribuído, os jogos computadorizados passam a ser mais utilizados nas escolas, principalmente nas instituições públicas que utilizam outros sistemas operacionais diferentes da plataforma Microsoft Windows.
Mesmo sendo o objetivo principal do Amphibian criar motores de jogos, outras aplicações multimídia podem ser criadas a partir de o framework.
Visualização científica, simuladores gráficos de robótica autônoma, de simulações empresariais, de sistemas de informações geográficas, entre outras aplicações multimídias.
Algumas destas aplicações foram citadas por Domingues em sua dissertação referindo- se a Forge V8 3 D, entretanto o Amphibian também possui funcionalidades que permitem desenvolver estas mesmas aplicações.
Destacando que estas podem ser integradas em navegadores Web e poderão executar em dispositivos móveis, incluindo handhelds e telefones celulares.
Conforme foi visto no capítulo 3, para que uma game engine desempenhe sua função é necessário que esta utilize uma série de recursos gráficos, sonoros e objetos lógicos, além de a especificação da seqüência lógica do jogo.
Portanto, deve- se considerar um contexto do jogo, incluindo uma série de outras ferramentas auxiliares e arquivos que darão suporte para execução do motor.
Lembrando que para Pessoa e Hodorowicz estas ferramentas pertencem ao escopo da game engine.
Em a Figura 18 estão representados os principais componentes do contexto de um motor de jogo Os recursos são todos os objetos do jogo, sejam estes lógicos ou multimídia.
Os objetos lógicos não possuem uma representação gráfica ou sonora, são objetos descritivos que servem como parâmetros do jogo.
Em contrapartida os objetos multimídia são todos os recursos audiovisuais.
Os editores de recursos são ferramentas capazes de gerar estes objetos de jogo.
Em geral para criação de objetos multimídia, tais como imagens, modelos 3 D, som, música e animações utilizam- se ferramentas de terceiros.
Por exemplo, para criação de um modelo 3D pode ser utilizado o GMax ou 3D Studio Max da empresa Discreet.
Porém, para criação de objetos lógicos para determinado jogo na maioria das vezes desenvolve- se uma série de editores.
Por exemplo, num CRPG, existe a necessidade de desenvolver editores de itens, mapas e personagens, sendo que estes por sua vez podem requerer alguns objetos multimídia para serem construídos, tais como sons e sprites.
O editor de jogo é responsável por a integração dos inúmeros objetos lógicos definindo a lógica do jogo propriamente dita.
Para isto utiliza- se uma coleção de recursos, incluindo objetos lógicos e objetos multimídia.
É importante destacar que a partir de uma coleção de objetos (recursos) podem ser criados vários jogos.
Por exemplo, através de uma coleção de objetos para fantasia medieval é possível construir vários RPGs computadorizados ambientados em cenários de fantasia medieval.
Por último, a game engine é responsável por a interação com o usuário, execução do jogo e apresentação dos resultados em tempo real nos dispositivos de vídeo e/ ou adequados.
Para isto utiliza os recursos e o descritivo do jogo.
Em o escopo do presente trabalho será enfocada a construção do framework para criar motores de jogo, pois os editores de jogos e os editores em geral para criação de recursos dependem de um contexto específico de um determinado motor de jogo.
Ou seja, se está sendo desenvolvida uma engine para jogos de estratégia, este motor terá seus editores específicos.
Quanto a as questões metodológicas para o desenvolvimento do framework baseou- se em Fayad, Schimidt &amp; Johnson que sugerem a construção de modelos de conhecimento criados a partir de a análise de domínio, do conhecimento das principais fontes sobre determinado assunto.
Este processo auxilia na compreensão do domínio e auxilia no desenvolvimento da proposta do framework.
Por esta razão foram pesquisadas inúmeras arquiteturas de motores de jogos e diversas ferramentas mais usuais para o desenvolvimento de jogos.
Além de esta análise, cujos requisitos fundamentais foram destacados, utilizou- se uma coleção de cenários que auxiliaram na definição dos objetivos e da arquitetura do framework.
Estes cenários encontram- se no Anexo A. Inicialmente foi utilizada a técnica do Larman para auxiliar na definição de requisitos e das funcionalidades do framework.
Entretanto, esta técnica é bastante eficiente para projetar sistemas mais simples e baseados em situações reais concretas.
No caso de o projeto de um framework de uma aplicação computacional a realidade não é tão tangível quanto um sistema bancário ou de folha de pagamento.
Por esta razão optou- se por o Larman numa fase inicial para permitir que as primeiras abstrações fossem construídas e após partiu- se para uma abordagem de prototipação.
Para Pressman, a prototipação é uma técnica de análise cujos princípios são baseados num modelo de software.
O autor afirma que em algumas situações a prototipação é exigida no início da análise por auxiliar na especificação dos requisitos do sistema, pois neste caso o modelo computacional auxilia na elaboração dos requisitos.
Também se optou por a prototipação por o fato de Fayad, Schimidt &amp; Johnson considerarem que um framework começa a ficar estável a partir de a terceira aplicação desenvolvida a partir de ele e recomendam que os frameworks não devem ser construídos nos ciclos de desenvolvimento de softwares tradicionais por o fato de sua concepção ser bastante complexa.
Pode- se dizer que o processo de modelagem do framework deve possuir uma integração com a codificação desde o início da modelagem, pois não existe uma compreensão arrojada da eficiência de uma proposta de sistema sem antes efetuar algumas experimentações.
Constantemente as propostas devem ser testadas com codificação.
Elaborar frameworks de forma incremental como os sistemas tradicionais são desenvolvidos é uma tarefa complicada.
Procurou- se definir alguns requisitos iniciais, foram desenvolvidos alguns diagramas de classes rudimentares e iniciou- se o processo de modelagem.
O framework que está sendo apresentado neste trabalho representa um protótipo que implementa uma série de tomadas de decisão importantes que objetivam atender os objetivos e os requisitos do framework.
O processo de refinamento desta solução será feito em momentos futuros quando motores de jogos mais arrojados começarem a ser desenvolvidos.
Em a Figura 19 procurou- se definir uma estrutura genérica de um motor de jogo com componentes conforme as arquiteturas apresentadas no capítulo anterior.
Esta é a arquitetura geral cujo Amphibian é modelado.
Basicamente um motor de jogo possui os seguintes componentes:
Interação, Comunicação, Controle e Visualização.
O componente de Interação relaciona- se com os periféricos de entrada, tais como teclado, mouse, joystick, caneta utilizada por handhelds e teclas de telefones celulares.
São responsáveis por o tratamento de eventos gerados por estes periféricos quando ocorre alguma interação do usuário com estes.
O componente de Comunicação permite a criação de jogos em rede com múltiplos participantes.
Em a maioria das aplicações utiliza- se um processo de comunicação por sockets e estes por sua vez são implementados de forma diferenciada em cada plataforma de execução.
Desta forma existem sockets para plataforma de computadores pessoais, handhelds e telefones celulares.
O componente de Comunicação e o de Interação são responsáveis por fornecer as entradas para o motor de jogo.
O componente de Controle mantém à lógica do jogo propriamente dita e manipula os objetos do jogo.
Para desempenhar tais tarefas utiliza uma descrição do jogo, que por sua vez utiliza uma série de recursos e entradas oriundas dos componentes de Interação e/ ou do componente de Comunicação.
Um motor de jogo pode conter inúmeros controladores cada um responsável por uma operação lógica, ou seja, podem existir controladores de simulações físicas e controladores de Inteligência Artificial, por exemplo.
Destacando que estes controladores poderão ser reusados em diferentes jogos computadorizados.
Em esta arquitetura a camada de abstração do sistema é substituída por duas diferentes camadas ­ a máquina virtual Java (JVM ­ Java Virtual Machine) e uma camada de abstração referente a a máquina virtual.
A primeira impressão é que tal decisão é redundante e sem sentido, pois a máquina virtual tem justamente o propósito de criar Conforme foi apresentado por Sametinger a interface padrão dos componentes é o elemento principal dos componentes reusáveis, portanto para garantir os benefícios listados anteriormente é necessário criar interfaces padrão sofisticadas para os componentes que efetuam o processo de comunicação entre as camadas.
Dando continuidade no detalhamento da arquitetura veja a Figura 22.
Esta figura trata de um cenário realístico e representa a forma real que o framework foi estruturado numa arquitetura de execução considerando todo seu contexto.
A camada referente a o Amphibian é projetada para utilizar somente a abstração oferecida por a Sal.
Percebe- se na figura que o Amphibian acessa somente tal camada.
Em a camada do Amphibian estão implícitas as camadas referentes à lógica e a visualização do jogo.
A última camada trata- se das extensões criadas basicamente a partir de as abstrações de cada uma das camadas básicas e especifica a relação destas extensões com as camadas da arquitetura de execução.
Fayad, Schimidt &amp; Johnson afirmam que os frameworks são projetos de software com pontos de personalização (hot spots).
Quando uma aplicação é criada a partir de um framework adota- se um fluxo de controle padrão e as especificidades da aplicação serão atendidas através da construção de extensões para serem utilizadas nestes pontos de personalização.
Portanto, existem extensões criadas a partir de os hot spots do Amphibian e da Sal.
Tais extensões podem usar componentes oferecidos por a camada JVM e por o sistema operacional, entretanto à medida que uma extensão utiliza um componente das camadas mais inferiores perde- se sua portabilidade.
Ou seja, se for criada uma extensão para o Amphibian usando somente tal camada, esta extensão será reutilizável para qualquer Sal, JVM e sistema operacional.
Entretanto se tal extensão utilizar um componente do sistema operacional o uso desta ficará restrito a esta plataforma.
Mesmo considerando a possibilidade de perder portabilidade adotar tal arquitetura permite que a estrutura do framework em geral seja mais flexível, desta forma melhor atendendo os requisitos do projeto de um jogo.
Assim é possível utilizar bibliotecas externas e/ ou dependentes de sistema operacional inclusive tecnologias bastante difundidas no desenvolvimento de jogos, tais como OpenGL, SDL e DirectX.
Em resumo o desenvolvedor de um motor de jogo pode optar por o nível de portabilidade de suas extensões.
O último detalhamento trata- se da arquitetura propriamente dita do Amphibian, em termos de componentes principais e inter-relacionamentos.
Esta arquitetura pode ser vista na Figura 23.
Esta arquitetura assemelha- se ao esquema geral dos motores de jogo apresentado na Figura 1 e nos componentes da Figura 19.
Existe um componente container que contêm o motor de jogo e oferece para este uma superfície gráfica.
Além disso, o container é responsável em capturar os eventos gerados por os dispositivos de entrada e encaminhar estes para o laço de eventos do motor.
Este container em geral é uma janela do sistema, entretanto pode ser outro objeto desde que capture eventos e forneça a superfície gráfica.
O funcionamento básico do motor baseado nesta arquitetura consiste que todo evento gerado por o sistema é enviado para o laço.
Caso o evento seja uma tecla o laço consulta um mapa de teclas e verifica se existe alguma ação associada à tecla pressionada.
Se a ação é capaz de auto-executar então a execute, caso contrário envia um sinal para os controles que irão desempenhar a atualização de algum objeto do jogo contido na memória.
O render utiliza o relógio para efetuar o número de atualizações especificado por segundo (framerate).
A cada atualização, o render solicita que os controles sejam atualizados, implicando na mudança dos estados de alguns objetos 72 alocados na memória, e produzindo uma imagem na superfície gráfica conforme o estado dos objetos multimídia (representações gráficas) contidos na memória.
É importante destacar que na subseção 4.4 esta arquitetura será detalhada.
As extensões serão abordadas na seção 5.1 quando serão tratadas as questões referentes à implementação do protótipo.
As camadas referentes à máquina virtual Java e o sistema operacional não serão detalhadas por o fato de estarem fora de o escopo da modelagem da proposta do framework, apesar de estarem inseridas no mesmo contexto de execução.
A documentação de um framework é bastante abrangente por o fato desta solução computacional apresentar um alto grau de abstração.
Para Fayad, Schimidt &amp; Johnson existem diferentes tipos de usuários e cada um destes possui um conjunto de interesses diferenciados, logo devem existir diferentes formatos de documentação.
Por exemplo, existem os desenvolvedores de aplicações que estão interessados em como reusar o framework, os mantenedores que devem entender seu o projeto e estão interessados em saber o porque de seu funcionamento, e os desenvolvedores de frameworks que estão interessados em conhecer as decisões de projeto de forma que possam aprender e reusar estas decisões em outros frameworks.
Johnson destaca que a documentação de um framework deve ter um caráter prático, deve enfocar as questões de como reusar um framework, uma espécie de &quot;receita «que descreve uma solução de um problema na forma de um padrão.
Uma coleção de receitas, forma um &quot;livro de receitas», e consiste da principal documentação do framework.
Para Johnson, a maioria dos usuários está preocupada em como utilizar a ferramenta ao invés de entender o porque de seu funcionamento.
Entretanto, esta abordagem voltada exclusivamente para prática é bastante prescritiva e ignora aspectos teóricos importantes que circundam a solução do problema.
Possivelmente estas informações teóricas não irão interessar os desenvolvedores de aplicações, entretanto outros públicos-alvos terão interesse.
Gamma, Helm, Johnson et al propõem um gabarito (template) com um conjunto de informações que servem para descrever padrões de projeto.
Em este gabarito são contempladas questões teóricas referentes ao projeto da solução e está de acordo com a concepção de descrever problema-solução conforme Johnson.
Os autores propõem um gabarito para definição de padrões.
Buschmann, Meunier, Rohnert et al também fazem uma proposta de gabarito com algumas características diferenciadas.
Esta proposta de gabarito é mais teórica enquanto que o gabarito do Gamma, Helm, Johnson et al é mais prático.
Buschmann propõe um gabarito com quinze características:
Nome, curta descrição, &quot;conhecido como», exemplo, contexto, problema, solução, estrutura, dinâmica, implementação, exemplo resolvido, variações, usos conhecidos, conseqüências e padrões relacionados.
As características propostas por Gamma, Helm, Johnson et al são semelhantes:
Nome, classe, intenção, &quot;conhecido como», motivação, aplicação, estrutura, participantes, colaborações, conseqüências, implementação, exemplo de código fonte, usos conhecidos e padrões relacionados.
Como serão adotados os padrões para documentar o Amphibian optou- se em customizar um gabarito selecionando algumas características dos dois já citados anteriormente.
Desta forma, o gabarito que vai ser considerado irá adotar as seguintes características:
Nome, intenção, motivação (equivalente ao exemplo), contexto (equivalente à aplicação), solução, estrutura, participantes, colaborações (equivalente à dinâmica), implementação e conseqüências.
As demais características foram excluídas por o fato de não estarem fortemente relacionadas com a documentação de um framework, mas sim úteis para a definição de um novo padrão de projeto.
Quanto a a característica &quot;participantes «foi tratada de uma forma diferenciada nesta documentação.
Normalmente quando é proposto um framework apresenta- se um diagrama de classes simplificados demonstrando a abstração e logo a seguir acompanha uma descrição dos componentes participantes do diagrama.
Entretanto no caso de a utilização dos gabaritos para documentar extensas decisões de projeto, os diagramas de classe não ficam enxutos e possuem muito participantes.
Colocar uma extensa lista de todas as classes participantes descrevendo suas responsabilidades tornaria a leitura deste texto bastante cansativa.
Por estas razões optou- se em usar o formato de cartões CRC (Cartões de Classe--Responsabilidade-Colaboradores), que consiste de um formato mais informal para caracterização das classes, listados por ordem alfabética no Anexo B. Caso exista algum componente especial este é descrito na seção &quot;participantes «do gabarito.
Destaca- se que no caso de usar estes gabaritos não está sendo proposto um novo padrão de projeto, pois tal tarefa requer uma alta generalização e uso em diferentes contextos de aplicação.
Os padrões serão usados como uma ferramenta para efetuar a documentação.
As soluções de projeto propostas, futuramente após a execução de diferentes aplicativos e de diversos refinamentos poderão ser tratadas como um novo padrão de projeto.
Entretanto este não é o enfoque inicial apresentado no presente trabalho.
Além disso, para a definição do framework baseou- se num princípio proposto por Watt &amp; Policarpo que os autores adotaram na concepção da Fly3D apresentado na seção 3.1.
Grande parte do esforço de um motor de jogo pode ser delegado para os seus &quot;plug-ins».
Este princípio na concepção do Amphibian foi adotado no momento que se concebeu uma arquitetura altamente genérica que oferece uma série de hot spots que deverão ser customizados por os desenvolvedores.
Portanto, a arquitetura do Amphibian prove uma estrutura que aceita componentes &quot;plugáveis».
A ClanLib também procurou desenvolver seus componentes com interfaces simples que permitem a personalização.
Desta forma facilitando o trabalho de substituição de um componente para outro.
Para especificar o Amphibian optou- se em detectar 11 problemas que envolviam o framework e que deveriam ser resolvidos para atender seus objetivos e pré-requisitos.
Abaixo estes problemas estão listados e a seguir em cada subseção um destes problemas será detalhado:
Abstração do Sistema Operacional;
Configuração em Tempo de Execução do Motor de Jogo;
Carga de Diferentes Recursos;
Ciclo de Execução do Motor de Jogo; Tratamento de Eventos ­ Teclado &amp; Apontadores;
Mecanismo de Persistência dos Dados; Gerenciamento dos Objetos do Jogo;
O Uso do Descritivo de Jogos Computadorizados;
Gerenciamento dos Controladores;
Mecanismo de Visualização 2 D;
Reproduzir Sons Independente de Dispositivo. Antes de iniciar as descrições é importante destacar que em geral as conseqüências positivas e negativas de adotar cada uma das soluções que serão apresentadas, por o fato destas serem baseadas em padrões de projeto tais conseqüências serão oriundas das próprias limitações e pontos fortes dos padrões.
O objetivo é desenvolver uma interface padrão que permita que aplicações sejam desenvolvidas de forma independente da API oferecida por a máquina virtual que está sendo usada sob um determinado sistema operacional.
Diferentes dispositivos podem oferecer diferentes implementações e interfaces de sockets de comunicação, geração de números aleatórios, eventos produzidos por teclas e apontadores (mouse e caneta nos handhelds), imagem, som, contexto gráfico e estruturas de dados, tais como vetores e tabelas hash.
Esta grande diversidade espera- se desenvolver uma solução de padronização.
Desta forma as aplicações podem ser construídas independente de máquina virtual.
O uso de uma camada de abstração é adotado por Hodorowicz, Domingues, Gellati.
Também é usada no DirectX e JTGame.
Contexto Aplicável nas situações que se deseja um conjunto de componentes independentes do sistema operacional e modelar classes clientes que utilizam estes componentes independentemente de suas implementações.
Solução Basicamente este problema foi resolvido com o uso do padrão Layers e esta abstração trata- se da camada de abstração do sistema (Sal) apresentada naFigura 27.
Internamente adotou- se um conjunto de classes concretas utilitárias e um conjunto de interfaces.
Estas são produzidas através de uma fábrica, pois, adotou- se o padrão Abstract Factory e existe uma única fábrica no sistema, adotando o padrão Singleton.
Sempre que as classes clientes necessitarem de um componente do sistema operacional solicita- se para a fábrica que será responsável em instanciar um componente que implementa a interface padrão desejada por a classe cliente.
Abstract Factory e Singleton, ambos são padrões propostos por Gamma, Helm, Johnson et al.
A Abstract Factory fornece uma interface padrão para criação uma família de objetos relacionados sem especificar a implementação destes.
Já o padrão Singleton é um padrão para garantir uma única instância de um objeto e um único ponto de acesso global de acessa para esta.
Quanto a o padrão Layers, este foi descrito na seção 4.3.
Colaborações -- A GValue utiliza um IConversor para efetuar algumas conversões de tipos;
GObservable contêm registrado os observadores (IObserver) usando um objecto IVector para tal atividade;
As classes IVector e IHashtable oferecem acesso aos seus objetos através de uma enumeração (IEnumeration);
A classe GPersistent delega para classe IPersistenPeer a responsabilidade para armazenar e recuperar o estado do objeto persistente;
Eventos de teclas (GKeyboardEvent) e apontadores (GPointerEvent) são eventos do sistema (ISystemEvent);
A GPlatform cria instâncias das classes IVector, IHashtable, IRandom, IConsole e IKeys.
Implementação Para cada máquina virtual que se deseja uma camada de abstração devem ser criadas classes que implementam as interfaces.
Em geral são criadas as classes referentes ao vetor, enumeração, tabela hash, evento do teclado, console, conversor e gerador de números randômicos.
Além disso, deve- se criar uma classe que estenda GPlatform onde basicamente seus métodos abstratos referentes à instanciação de objetos do sistema operacional são implementados.
Outro aspecto importante que deve ser considerado é que a criação destas classes que implementam as interfaces oferecidas por a camada de abstração do sistema operacional podem ser feitas de três maneiras:
criando adaptadores para máquina virtual;
criando novas classes usando exclusivamente Java;
criar novas classes usando métodos nativos.
O primeiro método baseia- se no padrão Adapter que consiste em adaptar a interface das classes oferecidas comumente com a distribuição de determinada máquina virtual para a interface padrão oferecida por a camada de abstração.
Desta forma permitindo que classes incompatíveis sejam usadas em conjunto.
A conseqüência de adotar esta abordagem é que cada máquina virtual irá requerer uma camada de abstração.
Já o segundo método elimina esta limitação, pois as classes oferecidas por a máquina virtual não são utilizadas, as funcionalidades são reescritas em novas classes.
E por último, a utilização dos métodos nativos é semelhante à segunda abordagem, só que ao invés de usar somente código Java são utilizados códigos compilados para uma plataforma específica.
Conseqüências a) Oferece uma padronização para o desenvolvimento de aplicações.
Além de o Amphibian outras aplicações podem usar esta camada de abstração, desta forma facilitando a portabilidade para diferentes dispositivos;
Permite implementar diferentes camadas de abstração adotando diferentes estratégias.
Por exemplo, pode ser criada uma camada compilada para determinado sistema operacional e com os algoritmos otimizados.
Esta melhoria será refletida para todas as aplicações desenvolvidas usando a Sal.
Esta vantagem é um ponto importante quando tratamos do desenvolvimento de jogos computadorizados e pode- se aliar a eficiência reconhecida do C+ com a facilidade de programação Java, pois o C+ pode ser usado para estas operações de mais baixo nível enquanto o resto das outras definições de mais alto nível adota- se Java puro;
As classes na Sal não dependem de pacotes externos.
Possuem dependência interna.
Alguma extensão da Sal pode usar classes oferecidas por determinada máquina virtual.
Esta característica evita grandes impactos nas camadas superiores quando ocorre alguma alteração na camada;
Oferece uma abstração (interface padrão) para ser usada por as aplicações desenvolvidas sob a Sal independente da forma de implementação.
Ou seja, as aplicações podem utilizar um vetor (IVector) independente da forma que este é implementado por determinada classe concreta que pode usar a classe Vector oferecida no pacote java.
Util da J2SE ou reimplementar usando código-nativo.
É oferecida uma família de componentes dependentes do sistema operacional que pode ser usado através de uma única classe que é responsável em instanciar objetos conforme a plataforma de execução;
Existe um único ponto de acesso no sistema à plataforma que está sendo usada.
Desta forma não ocorre uma replicação desnecessária da classe Platform que naturalmente deve existir uma única instância desta na aplicação;
A o adotar a Sal existe um maior overhead por o grande tráfego de informações oriunda da adição de classes intermediárias que fazem o papel de abstração.
Esta desvantagem das camadas havia sido mencionada na seção 3.1.3;
De a mesma forma que uma otimização impacta de forma positiva em todas as aplicações construídas sob a camada, o contrário também é válido, uma implementação ineficiente irá impactar de forma negativa nas aplicações;
Caso a plataforma ofereça um novo componente do sistema operacional isto irá implicar em reescrever a classe Platform e suas subclasses.
Por o fato do Amphibian ser fortemente relacionado com componentes reusáveis, naturalmente que os motores de jogos serão criados a partir de a composição de diferentes componentes cada um destes com um determinado conjunto de responsabilidades.
Desta forma, seria interessante dotar o sistema da capacidade de configurar- se simplesmente definindo um conjunto de propriedades e em tempo de execução o motor de jogo seria criado.
Com isto para criar um novo motor bastaria configurar um arquivo de propriedades que automaticamente o configuraria corretamente.
Isto adiciona um nível alto de abstração quanto a a modelagem do motor.
Em geral é necessário definir os seguintes componentes principais:
Relógio, laço de eventos, renderizador, forma de persistência da memória, forma de persistência do descritivo do jogo e a cena.
Além destes, é necessário definir os carregadores de objetos, controladores, os repositórios de objetos usados por o motor, ações associadas às teclas e aos apontadores.
Contexto Criação de aplicações através de arquivos de configuração cuja definição dos componentes da arquitetura são criados e configurados em tempo de execução, desta forma dispensando recompilação.
Solução Adotar uma classe responsável em fornecer informações gerais para configuração do motor de jogo sendo que esta classe é capaz de ser persistida de diferentes formas.
Foi adotado o padrão Singleton para definir uma única instância da especificação do motor.
O fato de adotar o padrão Abstract Factory para GPlatform permite que este forneça uma forma de persistir a especificação do jogo (veja seção 4.4.6).
Por último, adotou- se o padrão Bridge para separar a implementação da persistência da interface padrão, desta forma permitindo a troca do mecanismo de persistência referente a a especificação.
Estrutura na Figura 25 estão representadas as principais classes que permitem efetuar a configuração do motor de jogo em tempo de execução.
Participantes CustomEngineSpecPeer:
Esta classe seria uma representação geral que simboliza uma definição de como persistir a especificação do motor.
Por exemplo, poderia ser usada uma classe para persistir a especificação usando um arquivo de propriedades, um banco de dados, um arquivo XML ou qualquer outra forma de persistência.
CustomComponent: Uma representação geral que simboliza um componente do motor de jogo que precisa ser criado e configurado em tempo de execução, seja este o relógio, um renderizador, ou qualquer outro objeto.
Colaborações -- EngineSpecification é uma subclasse de GPersistent, logo o estado da especificação pode ser armazenado e recuperado posteriormente;
Platform fornece um CustomEngineSpecPeer conforme a plataforma de execução que está sendo usada;
Um CustomComponent para ser criado precisa utilizar um ClassLoader;
O ClassLoader para criar uma nova instância de um determinado componente precisa consultar as informações providas por a EngineSpecification;
Uma CustomEngineSpecPeer é responsável em configurar uma EngineSpecification que será utilizada posteriormente para configuração do motor de jogo.
Implementação Quando for definida uma plataforma de execução deve- se definir também a forma que a especificação será persistida.
Em a especificação contem uma série de informações que serão usadas por outros componentes para serem instanciados em tempo de execução.
Entretanto, no caso de a especificação esta deve ser persistida de uma forma padrão, ou seja, ela não poderia conter informações para se auto-recuperar, pois para saber tal informação ela deveria ser restaurada.
Por esta razão cada plataforma provê uma forma padrão para persistir a especificação.
Outro ponto que deve ser observado é que a especificação centraliza as informações para criação dos componentes, logo se um componente da arquitetura do Amphibian precisa ser configurado em tempo de execução, a especificação deverá prover informações para isto.
Em geral, adota- se uma política de propriedades, ou seja, associa- se o nome de uma classe a um identificador padrão.
Quando o componente for criado a classe responsável por a criação de objetos (ClassLoader) acessa o nome da classe usando este identificador.
Conseqüências a) A forma de persistir a especificação é independente da sua interface padrão, isto permite substituir a forma de persistência por diferentes mecanismos;
O sistema oferece uma única instância da especificação do motor, logo existe um único ponto de acesso;
Forma padrão de como definir a especificação do motor para uma determinada plataforma.
Ou seja, todos os jogos para determinada plataforma são definidos da mesma maneira, que pode ser feito através de um arquivo de texto contendo as propriedades ou um arquivo XML, por exemplo;
A forma de persistência da especificação fica atrelada à plataforma, não permitindo que sejam criadas formas diferentes de persistência associadas com diferentes motores de jogos;
Pode ocorrer que a especificação do jogo contenha um excesso de informação aumentando a dependência entre as classes e a especificação.
O mesmo recurso é armazenado de formas diferenciadas nos inúmeros dispositivos existentes.
O objetivo é estabelecer uma forma padrão para o carregamento de recursos independente da plataforma.
Entende- se por recurso uma coleção de bytes que armazenam algum objeto com semântica, tais como, uma imagem ou um som.
Considerando que está sendo desenvolvido um determinado jogo que precisa utilizar uma imagem que está no formato JPEG.
Se considerar o contexto dos computadores pessoais esta imagem provavelmente estará armazenada em disco na forma de um arquivo localizado numa estrutura de diretórios.
Para recuperar- la do disco basicamente consiste em ler o arquivo por uma classe responsável em tratar imagens para posteriormente desenhas- la numa superfície gráfica.
Entretanto, se for considerado o contexto de um handheld da Palm, o conceito modifica- se.
Os dados são armazenados no Palm usando o formato PDB, exceto nos cartões de expansão que podem ser usados arquivos.
A estrutura básica de um PDB é uma tabela que pode conter inúmeros registros de tamanhos variáveis.
Cada registro destes pode ser armazenado os dados da imagem.
Logo, a recuperação da imagem num Palm segue uma mecânica diferenciada.
Desta forma o motor de jogo deve ser capaz de lidar recursos armazenados de diferentes formas, sendo que este processo de recuperação deve ser transparente para aplicação, ou seja, quando é necessário usar determinado recurso este simplesmente deve ser recuperado e disponibilizado para a classe cliente que requisitou o serviço.
Contexto Carga de diferentes recursos em diferentes dispositivos.
Solução Define-se na especificação do motor de jogo quais os carregadores de recursos que serão usados associados com diferentes recursos.
Em o momento que o motor é configurado, registra- se o nome da classe do carregador com os tipos de recursos que este suporta.
À medida que são solicitados carregadores para manipular um recurso é criado um pool, ou seja, a classe mantém o controle de todos os carregadores que já foram instanciados, sem a necessidade de criar um novo carregador a cada solicitação.
Esta decisão consiste da aplicação do padrão Flyweight que permite o uso compartilhado de objetos para suportar grandes quantidades de objetos.
Os carregadores são capazes de prover um objeto de jogo baseado numa referência de localização ou a partir de um buffer de dados.
Participantes CustomEngineSpecPeer:
É responsável em efetuar o registro dos carregadores associando os nomes das classes com os recursos.
Também implica na forma de definir os carregadores na especificação do motor.
CustomRepositoryPeer: Quando os dados são recuperados referentes ao repositório de objetos são utilizados os carregadores.
Sua responsabilidade é carregar, tais recursos na forma de objetos de jogo para serem posteriormente alocados na memória do motor.
Quando à especificação do motor, esta é recuperada do dispositivo de armazenamento os carregadores são registrados;
Quando o repositório de objetos é recuperado são usados os carregadores para carregar os objetos do jogo para posteriormente alocar- los na memória do jogo.
Implementação Quando são criados os mecanismos de persistência para a especificação do motor as subclasses devem efetuar tal tratamento referente a o registro dos carregadores.
E para cada recurso ou uma coleção destes devem ser criados tais carregadores.
Conseqüências a) Os motores de jogos são facilmente extensíveis para suportar diferentes formatos de arquivos.
Além disso, cada motor pode aceitar um número específico de formatos;
Os tipos de arquivos são carregados de forma transparente para as classes clientes.
Cada arquivo é carregado de uma forma específica conforme as peculiaridades da plataforma;
Por o fato de usar um pool de carregadores evita- se criar instâncias desnecessárias de carregadores.
Existe uma única de instância de cada carregador durante a execução.
Quanto a o ponto negativo é possível citar que para cada motor de jogo que é desenvolvido deve- se especificar quais os formatos de arquivos suportados e quais os carregadores responsáveis por a sua carga.
Esta tarefa de especificação para cada motor pode tornar- se um pouco entediante para o desenvolvedor.
A principal motivação é projetar uma solução descomplicada que facilite a compreensão da execução do motor de jogo e que esteja em conformidade com a fundamentação teórica efetuada no capítulo 3.
Além disso, deve ser oferecido um conjunto de serviços básicos que permita aplicações clientes, em geral os containers, acessarem facilmente o motor de jogo sem conhecer seus detalhes de implementação.
Mantendo esta interface padrão é possível modificar radicalmente a estrutura dos motores sem precisar alterar nenhuma classe cliente que usa o motor.
Contexto Representar os estados de um motor de jogo oferecendo uma interface padrão de acesso às funcionalidades dos motores de jogo.
Solução Foi adotado o padrão State para representar os estados do motor de jogo e o padrão Mediator para manter coesas as seqüências de interações entre os componentes do motor.
Além destes o motor pode ser analisado como uma fachada para ser acessado por classes clientes, logo se adotou o padrão Façade.
Este padrão unifica um conjunto de serviços que podem ser usados por classes externas do sistema.
Assim, em geral, as classes externas precisam acessar somente o motor de jogo.
O padrão State consiste da representação do estado de um objeto explicitamente utilizando para isto um outro objeto, ou seja, no caso de o motor de jogo cada estado que este pode assumir é representado por um objeto.
Já o padrão Mediator encapsula um conjunto de objetos e suas respectivas interações.
Ao invés de o motor coordenar todos os seus componentes, cada estado que o motor pode assumir é um mediador responsável em interagir com um conjunto de objetos.
Indiretamente esta solução está relacionada com todas as demais, por o fato desta ser a solução para o problema central do motor.
Estrutura Quanto à estrutura da solução serão apresentados três diagramas que melhor detalham a estrutura do motor de jogo em termos de componentes e detalha os possíveis estados que o motor pode assumir.
Em a Figura 29 está apresentado o diagrama de estados do motor de jogo.
As transições de estados correspondem aos métodos do motor de jogo e constituem a interface pública para prestação de serviços (Façade).
A seguir será apresentada uma série de diagramas de seqüência que representam as transições de estados.
Em a Figura 30 é apresentado o diagrama de seqüência referente a criação do motor de jogo.
Por o fato da classe Engine adotar o padrão Singleton é responsável por a criação e manutenção da única instância do motor em tempo de execução.
A plataforma de execução é definida, configura- se o descritor de jogo que será usado e inicializa- se a especificação do motor.
A partir deste ponto é possível efetuar a inicialização.
Para sair de estado de pausa o desenvolvedor também deve criar uma ação para retirar o motor de jogo deste estado.
Conforme Figura 38, se o motor está pausado os 88 elementos que foram parados ­ relógio, controladores e renderizador são iniciados novamente.
Implementação Quanto à implementação, esta solução permite desenvolver diferentes containers que irão comportar os motores de jogos, fornecer uma superfície para desenho e capturar os eventos produzidos por os periféricos de entrada.
Devido a a interface padrão bem definida proposto para o motor de jogo, este processo de integração é facilitado.
Um exemplo de definição de alguns containers poderá ser visto na seção 5.1.
Outro ponto de personalização é a possibilidade de criar subclasses para os componentes principais do motor ­ relógio, laço de eventos e renderizador.
Mantendo o fluxo de controle descrito por a máquina de estados finitos já apresentada é possível efetuar personalizações do motor através destas subclasses.
Além disso, não é preciso recompilar a aplicação basta definir na especificação do motor de jogo o nome da classe do componente que em tempo de execução os componentes são criados.
Conseqüências a) Por o fato de adotar os estados do motor de jogo como mediadores responsáveis por as interações entre os objetos reduze- se o acoplamento entre os componentes;
Cada estado passa a representar um conjunto de interações entre objetos responsáveis em manter o controle da arquitetura do motor;
Cada estado por o fato de centralizar um conjunto de interações entre os componentes do motor torna- se mais complexo que suas partes.
Esta estratégia facilita a manutenabilidade por o fato de alterar uma seqüência de interação simplesmente modificando um único estado do motor sem comprometer o fluxo de controle geral do motor;
Os estados do motor de jogo são claramente representados por objetos distintos.
Desta forma ocorre uma divisão das atividades que devem ser executadas para cada um destes objetos que representam os estados;
O motor de jogo que é responsável por efetuar as transições entre os estados;
O motor de jogo pode ser obtido em qualquer ponto da arquitetura e existe somente uma única instância em execução;
Torna o uso do motor de jogo mais fácil por o fato de isolar as classes do sistema.
As classes clientes precisam somente acessar o motor de jogo;
Internamente mantém um forte acoplamento entre os componentes e um fraco acoplamento entre o sistema e as classes clientes.
Desta forma é possível alterar os componentes internos sem afetar os clientes;
Não proíbe o acesso as demais classes do sistema.
É possível optar entre a facilidade de uso e a generalidade.
Considerando os eventos produzidos por teclas.
Cada dispositivo oferece um conjunto de teclas, permitindo que o desenvolvedor associe ações a estas.
Por exemplo, num jogo de RPG pode ser programado que ao pressionar a tecla' A'aparece o conteúdo da mochila carregada por o personagem.
Se este jogo é portado para um dispositivo móvel, por exemplo, um handheld, não existe a tecla' A'para ser pressionada.
Portanto, deve ser desenvolvido um mecanismo que dissocia as teclas das ações de jogo.
Dando continuidade ao exemplo, a idéia seria associar a ação de mostrar conteúdo da mochila com outra tecla.
Tal procedimento deverá ser efetuado sem recompilar a aplicação, alterando a especificação do motor.
O mesmo é válido para os apontadores.
Um mouse e uma caneta dos handhelds possuem função semelhante de apontar na tela do dispositivo, entretanto apesar de a mesma funcionalidade são dispositivos diferentes.
Um jogo desenvolvido para computadores pessoais que se baseia num duplo-clique do mouse não irá encontrar um evento correspondente num handheld.
Desta forma os eventos produzidos por apontadores também devem ser dissociados das implementações de dispositivos.
Contexto Tratamento de eventos independente de dispositivo.
Solução A solução para este problema consistiu de diversos passos e tomadas de decisão.
Primeiramente foi criada uma abstração para ações.
Em a verdade uma ação é um evento dentro de o escopo do jogo que será mapeado por o laço de eventos, que converte eventos produzidos por o sistema em ações.
Para isto foi adotado o padrão Command.
Basicamente existem dois tipos de ações ­ sinais e as auto-executáveis.
As ações de sinais são encaminhadas para controladores interessados por determinado sinal e as auto-executáveis não são encaminhadas para nenhum componente, ao serem ativadas simplesmente são executadas.
Em geral estas ações efetuam alguma manipulação dos objetos de jogos alocados na memória do motor.
Além disso, foi definida uma abstração para as teclas oferecidas por o dispositivo.
Esta abstração foi apresentada na subseção 4.4.1 sobre a camada de abstração do sistema operacional.
Tendo como base estas classes é definido um mapa de teclas que associa uma ação à determinada tecla.
Este mapeamento é efetuado na especificação do motor.
Em a especificação também são definidas as ações que serão geradas quando ocorre algum evento do apontador.
Quando o descritivo do jogo é criado associa- se ao determinado objeto multimídia à ação que deverá ser produzida no momento que o usuário apontar para ele.
Além de estas foram criadas abstrações referentes aos eventos produzidos por o teclado e por os apontadores.
Estas também são oferecidas por a camada de abstração do sistema operacional.
Adotou- se o padrão Adapter para compatibilizar os eventos gerados por a plataforma e a interface padrão proposta para os eventos.
Os eventos do sistema são capturados por uma classe container que contem o motor de jogo e encaminha os eventos do sistema padronizados para ele.
Para completar a solução adotou- se um laço de eventos responsáveis em tratar os eventos padronizados.
Se for um evento produzido por teclas consulta- se o mapa de teclas.
Se existe alguma ação execute- a caso esta seja auto-executável ou encaminha o sinal para os componentes interessados.
No caso de um evento produzido por um apontador encaminha- se o evento para o gerenciador de cena, por o fato deste manipular os objetos gráficos que são desenhados na superfície gráfica.
Destaca- se que existe somente um laço de eventos no motor, por isto adotou- se o padrão Singleton.
A estrutura desta solução pode ser vista na Figura 41.
Implementação Quanto às implementações dificilmente serão criados novos objetos persistentes referentes aos componentes do motor.
Caso sejam criados isto poderá implicar em mudanças na classe EngineSpecification.
Entretanto é mais comum serem criados objetos peer que implementam diferentes formas de persistência.
Por exemplo, pode ser criado um objeto peer para persistir a memória do jogo (Heap) usando um banco de dados.
Futuramente pode optar por uma outra forma de persistência, para isto basta alterar as configurações do motor de jogo, onde existe um atributo que define a classe usada para persistir a memória, por exemplo.
Conseqüências a) Os componentes persistentes não precisam conhecer a forma que são persistidos;
Permitir criar facilmente diferentes formas de persistência ­ arquivo XML, banco de dados, arquivo de propriedades, entre outros.
Por o fato de permitir diferentes formas de persistência os objetos podem ser persistidos conforme o dispositivo.
Por exemplo, no caso de os Palmtops estes usam o formato PDB para armazenar os dados.
Desta forma os objetos persistentes podem utilizar tal formato;
Oferece um mecanismo que facilita a implementação destas funcionalidades comuns nos jogos computadorizados;
Efigura do boneco) e objetos lógicos (representado por os círculos), cada um com identificador único.
Além destes objetos é possível definir variáveis, atribuir valores para estas e consultar- las de qualquer parte do motor.
Quanto a a tarefa de alocação podem ser usados os carregadores de recursos, conforme foi apresentado na subseção 4.4.3.
Implementação Em geral esta solução não requer muito esforço dos desenvolvedores, pois basicamente os descritivos de jogo são definidos usando comandos já estão desenvolvidos.
Entretanto pode existir a necessidade de projetar justamente visando algum tipo de configuração e principalmente manipulação da memória do jogo.
O Amphibian oferece oito comandos básicos:
Criar objeto de jogo:
Dado um identificador e o nome da classe do objeto de jogo, este é instanciado e alocado na memória caso esta não contenha nenhum objeto com tal identificador;
Alocar objeto:
Dado o identificador do objeto e o nome de um repositório de objetos previamente registrado efetua- se a alocação do objeto na memória caso este não esteja alocado.
Em a necessidade de instanciar um novo objeto busca- se no repositório, efetua- se a carga do recurso e por último aloca com o devido identificador;
Desalocar objeto:
Dado um identificador de objeto e o nome de um repositório previamente registrado desaloca- se tal recurso da memória e libera- se espaço;
Definir variável:
Dado o nome da variável, o tipo e o valor cria- se na memória do motor de jogo uma nova variável caso não exista nenhuma variável especificada com o mesmo nome;
Liberar variável:
Desaloca da memória e libera espaço de uma variável informando o nome desta;
Associar objetos num outro objeto de jogo:
Dado o identificador e o repositório do objeto que terá os objetos associados, e os nomes dos repositórios e os identificadores dos objetos que serão anexados, efetua- se tal processo de associação, definindo os objetos anexados como observadores do objeto receptor;
Desassociar objetos de um outro objeto de jogo:
Dado o identificador e o repositório do objeto que terá objetos desassociados, e os nomes dos repositórios e os identificadores dos objetos que não serão mais anexados, efetua- se tal processo de dissociação;
Definir valor do atributo de algum objeto:
Dado o identificador do objeto, o nome do repositório, o nome do atributo e o valor deste efetua- se a definição de tal atributo utilizando o valor especificado;
Atribuir uma ação a um objeto quando ocorre algum evento de apontador:
Dado o identificador da ação que está armazenada na especificação do motor de jogo, o identificador do objeto e o nome do repositório registrado efetua- se o processo de adição da ação ao objeto;
Além disso, pode ser desenvolvido diferentes formas de persistir o descritivo do jogo estabelecendo desta maneira diversas formas de especificar jogos computadorizados.
Conseqüências a) Facilidade de especificar diferentes descritivos de jogos para serem usados por diferentes motores de jogo;
Não precisa conhecer a implementação dos comandos simplesmente executa- os;
Pode- se oferecer a possibilidade de criar comandos complexos agrupando diferentes comandos simples;
Facilidade para criar novos comandos.
Entretanto isto implica em modificar os mecanismos de persistência que manipulam o descritivo do jogo, pois estes devem reconhecer novos comandos;
Colaborações EngineSpecification instancia os controladores (Controller) que serão usados no motor de jogo;
RunState solicita que o motor de jogo (Engine) atualize os controladores;
A Engine para cada um de seus controladores solicita para serem atualizados; (
Heap); RunState efetua as modificações nos objetos de jogo contidos na memória Caso o Controller seja um EngineActionListener quando uma ação do tipo sinal é gerada por algum dispositivo de entrada o Controller também poderá efetuar alguma modificação nos objetos de jogo.
Quanto a forma de efetuar a pintura da cena 2D pode ser considerado o diagrama de seqüência apresentado na Figura 61.
Quando é efetuada uma atualização, conforme a taxa de quadros por segundo, e o serviço de desenho oferecido por a cena 2D é solicitado, efetivamente o padrão Composite é utilizado.
A cena 2D pede para gerenciador de camadas desenhar- se.
Este por sua vez invoca o método de desenho para cada uma de suas camadas, que se auto desenha (definindo qual superfície gráfica será usada por o pintor) e para cada objeto 2D contido no campo de visão da cena solicita- se para que tais objetos sejam desenhados.
Implementação Uma das atividades que pode ser efetuada por os desenvolvedores é criar novos objetos 2D a partir de LeafObject2D ou CompositeObject2D.
Estes objetos podem ser de propósito geral, por exemplo, num momento futuro criar um mapa isométrico 2D que poderá ser usado por diferentes jogos computadorizados.
Ou poderá ser criado algum objeto que seja usado somente no escopo de um motor.
Em a seção 5.2 será visto que para implementação do jogo Snake, a serpente foi construída como um objeto 2D formando por uma cabeça e uma coleção de segmentos.
Para efetuar o desenho da serpente simplesmente solicita- se para ela desenhar- se e automaticamente esta invoca os métodos de desenho para cada um dos objetos 2D que a compõe.
Outro ponto de personalização é criando novas fábricas 2D que utilizam outras implementações para efetuarem os desenhos.
É importante destacar que caso seja criado um novo objeto composto não é necessário alterar a fábrica 2D para esta produzir mais um novo objeto.
A fábrica somente deverá ser modificada, acrescentando um novo serviço, se for criado um simples objeto 2D (LeafObject2D).
Para este novo objeto 2D deve ser criada uma interface que será manipulada por este.
Objetos pertencentes ao domínio lógico deverá implementar- la de forma que possa ser usado por tal objeto 2D.
Além de esta interface cada novo objeto 2D simples requer a criação de um novo pintor, uma subclasse de Painter para cada uma das fábricas 2D existentes.
Quanto a o suporte à tecnologia 3 D, a mesma abstração poderá ser utilizada, ou seja, cria- se uma coleção de objetos 3D organizados conforme uma hierarquia adotando o padrão Composite e uma fábrica 3D capaz de gerar objetos renderizadores.
Estes objetos serão responsáveis por a criação do objeto 3D dentro de uma cena 3D que também será renderizada conforme o posicionamento de uma câmera numa área reservada para o desenho numa superfície gráfica.
Conseqüências a) Existe uma única instância da fábrica 2 D;
Podem ser criados diferentes pintores para os objetos 2D utilizando diferentes estratégias e ferramentas de desenvolvimento.
Isto oferece uma grande flexibilidade no desenvolvimento, pois permite facilmente trocar a fábrica 2D que provê tais objetos;
Facilidade para criar objetos mais complexos através da composição de objetos 2D simples;
As classes clientes lidam facilmente com objetos compostos como se fossem simples objetos 2D utilizando a mesma interface;
Utilizando a hierarquia de objetos 2D facilita a criação de novos objetos que sejam ajustáveis ao fluxo de controle do framework e funcionam perfeitamente na composição de objetos;
Existe um excesso de chamadas de atualizações quando um objeto lógico modifica- se, pois esta notifica todos os objetos 2D que estão observando- o e cada um destes por sua vez notifica seu objeto pintor para ser atualizado;
Sempre que um novo objeto 2D simples for criado deve- se modificar a fábrica para que esta ofereça suporte a este novo objeto.
Além disso, deve- se criar um objeto pintor para cada objeto 2D implementado.
Portanto a criação de novos objetos 2D torna- se complicada;
A maioria dos jogos computadorizados emite algum tipo de som, sejam sons diversos, tais como explosões, ou músicas.
Em muitas situações deseja- se que seja reproduzido algum som diante a ocorrência de um evento.
Entretanto cada plataforma oferece um tipo de dispositivo de som, sendo que algumas nem oferece esta possibilidade.
Seria interessante dotar o motor de jogo da capacidade de reproduzir sons independente da forma que este será reproduzido em conformidade com a plataforma.
Ou seja, para implementação de um som no jogo poderá ser usado um arquivo MP3 nos computadores pessoais ou simplesmente a emissão de alguns beeps como é o caso dos handhelds mais antigos e telefones celulares.
Contexto Reprodução sonora independente de dispositivo.
Solução Criação de uma classe responsável por a reprodução som que oferece serviços de iniciar um novo som, executas- lo num laço infinito e parar a execução.
Para executar tal tarefa precisa ser informado o identificador do objeto sonoro que está alocado na memória do motor.
Usando o recurso da herança o reprodutor sonoro utiliza uma abstração do som e as subclasses implementam a forma de execução.
Desta forma é possível oferecer suporte para diferentes formatos de som e as classes pertencentes ao domínio do jogo utilizam um identificador padrão independente destes formatos.
Sabese que esta forma de implementação é adotada por a biblioteca ClanLib.
Outra decisão foi tornar o reprodutor de sons uma classe Singleton por o fato de não existir necessidade de um motor de jogo conter mais de um reprodutor.
Estrutura A estrutura da solução proposta pode ser vista na Figura 62.
Colaborações O objeto sonoro deve ser alocado na memória (Heap) do motor de jogo.
Em geral é utilizado algum carregador de recurso para efetuar a alocação;
Para reproduzir algum som, seja uma execução única ou no modo laço infinito de execução, deve- se obter a instância padrão do reprodutor sonoro (caso não esteja criada é feita sua instanciação) e informas- lo qual som deverá ser reproduzido.
Para isto indica- se o identificador do objeto que está alocado na memória do motor.
Implementação O ponto de personalização desta solução concentra- se na criação de classes de som.
De forma sumária para cada formato de arquivo sonoro deve- se implementar uma subclasse de Sound.
Assim desta forma é possível oferecer suporte para diferentes formatos de som, tais como WAV, MIDI, MP3 e OGG.
Além disso, para cada um destes formatos deve ser criado um carregador de recurso conforme foi visto na subseção 4.4.3 quando foi apresentado os carregadores de recursos (Loaders).
Oferece um único reprodutor sonoro evitando alocação de memória desnecessária;
O reprodutor sonoro é independente da forma que os sons são executados;
Facilidade para criar suporte para diferentes formatos de som para diferentes dispositivos;
O objetivo deste capítulo é apresentar o processo de prototipação do framework, destacando- se as decisões de implementação referente a a adoção da linguagem Java.
Também são apresentados os conjuntos de métricas referentes aos sistemas orientados a objetos, a fim de se fazer uma análise sobre a estrutura do framework proposto.
Destacando- se que o objetivo de tais métricas não é efetuar um estudo detalhado referente a a qualidade do framework, mas sim elaborar um &quot;snapshot «da versão atual do sistema que permita verificar as questões relativas ao desempenho.
Conforme foi visto nos capítulos 3 e 4 os frameworks oferecem um conjunto de classes concretas cujo desenvolvedor para criar suas aplicações deverão personalizar uma coleção de interfaces e abstrações que representam hot spots.
Em geral por o fato de ter sido adotada a arquitetura geral do Amphibian em camadas, personalizações efetuadas nos níveis mais inferiores são menos freqüentes e atende uma maior quantidade de aplicações.
Em contrapartida personalizações nas camadas superiores são mais freqüentes e procuram atender especificidades da aplicação.
Como será visto nas próximas subseções as personalizações mais complexas estão situadas nas camadas mais inferiores, entretanto uma vez implementadas as extensões para estas camadas as classes não precisaram ser reescritas com grande freqüência.
Depois de apresentada a teorização sobre frameworks e componentes reusáveis, ter efetuado a proposta do Amphibian que buscou atender o requisito portabilidade é necessário verificar se o Amphibian é extensível de fato para multiplataformas e permite que jogos computadorizados sejam executáveis em diferentes dispositivos.
Os testes de desempenho serão apresentados na seção 5.4 e exemplos de jogos que executam em diferentes dispositivos serão mostrados na seção 5.2.
Entretanto, para desenvolver estes testes e criar alguns exemplos de demonstração é necessário primeiramente definir em quais plataformas serão efetuados os testes e posteriormente desenvolver as extensões do Amphibian.
Quanto a os computadores pessoais optou- se por os sistemas operacionais Microsoft Windows e Gnu/ Linux por o fato destes sistemas serem mais difundidos na sociedade.
As extensões criadas são compatíveis com ambos os sistemas operacionais, desta forma evitando que sejam criadas extensões para cada um dos sistemas.
Caso fosse interesse do desenvolvedor poderiam ser criadas extensões executáveis numa única plataforma.
Em o caso deste protótipo optou- se em adotar uma extensão que fosse executável em ambos sistemas operacionais.
Como na proposta do Amphibian destaca- se a capacidade do framework ser utilizado em dispositivos pouco convencionais, tais como celulares e handhelds.
Foi escolhido o sistema operacional PalmOS que executa principalmente nos handhelds produzidos por a empresa Palm Inc.. Quanto
a a extensão da GPlataform, para computadores pessoais foi criada a classe Desktop e para os handhelds foi criada a classe SuperWaba.
Estas classes, por o fato de serem fábricas, provem uma coleção de objetos dependentes da plataforma.
Em termos de implementação as extensões criadas a partir de Sal visando os computadores pessoais foram agrupadas num pacote denominado saldesk e as extensões para handhelds agrupadas no pacote salsw.
Sendo que abstrações da Sal foram agrupadas num pacote denominado sal.
Em a Figura 63 está apresentada a relação dos pacotes referente a cada dispositivo.
Perceba que o pacote, que contêm as abstrações da camada, é comum no dois dispositivos e somente as extensões utilizam a API das máquinas virtuais, desta forma mantendo a coerência da arquitetura proposta.
É importante destacar que quando novos motors forem criados não precisam estender uma nova classe GameWindow, pois esta solução é um container genérico para qualquer aplicação para computadores pessoais que utilize o modo de janelas ou tela cheia.
Os motores são inicializados simplesmente informando- se na linha de comando da aplicação, no caso a GameWindow.
A localização da especificação do motor de jogo e opcionalmente o descritivo do jogo.
Tratando- se deste aspecto visual foi criada uma superfície gráfica para ser utilizada no modo fullscreen denominada FullScreenGraphics e uma outra para ser utilizada no modo janelas chamada DesktopGraphics.
Em a verdade FullScreenGraphics é uma subclasse de DesktopGraphics.
Para viabilizar a utilização do FullScreenGraphics também foi necessária a criação de um novo renderizador chamado FullScreenRenderer que efetua a configuração da superfície gráfica para ser utilizada no modo tela cheia.
O monitor de vídeo, classe Display, oferece todos os modos de vídeo disponibilizados no sistema e estão disponíveis para serem usados por o renderizador visando configurar a superfície gráfica.
Quanto a as questões referentes a controle foi implementada uma ação básica de saída, a ExitAction, que simplesmente encerra a aplicação de forma direta, ou seja, finaliza totalmente a aplicação de forma abrupta.
Tratando- se de recursos para serem usados nos jogos computadorizados foram criadas duas adaptações ­ DesktopImage e DesktopSound.
A DesktopImage estende a classe GImage delegando suas responsabilidades para classe Image oferecida por o pacote AWT da J2SE.
Desta forma é possível lidar com imagens nos formatos GIF, JPEG e PNG.
Já a classe DesktopSound estende a classe Sound oferecida por o Amphibian e delega suas responsabilidades para classes dos pacotes de som disponíveis na J2SE.
Com isto, o Amphibian passa suportar arquivos de som nos formatos:
MIDI tipo 0, MIDI tipo 1, RMF, AIFF, AU e WAV.
Cada som executa numa thread separada.
Para que estes arquivos fossem manipulados criaram- se dois carregadores (loaders), o primeiro é o ImageLoader responsável em carregar um arquivo contendo uma imagem e criar uma instância de DesktopImage, e o segundo trata- se do SoundLoader responsável e carregar arquivos suportados por o DesktopSound e instanciar um novo objeto pertencente a esta classe.
Para organizar os recursos criou- se um repositório de objetos bastante simples baseado na estrutura de diretórios denominado DirectoryRepository.
Esta classe implementa IPersistentPeer e é usada como mecanismo de persistência para manipular um repositório de objetos.
O funcionamento básico deste mecanismo é organizar os arquivos contendo recursos, sejam multimídia ou lógico, num diretório.
O nome do repositório é o nome do diretório e o identificador alfanumérico único de cada objeto contido no repositório é o nome do arquivo.
Apesar de ser um mecanismo simples facilita os testes iniciais e poderá ser substituído por uma estratégia de persistência mais sofisticada.
Por último, serão tratadas as classes relacionadas com persistência e que utilizam como formato de armazenamento o padrão XML.
O XML é um padrão da W3 Consortium que consiste de uma linguagem para descrever documentos semelhante ao Html, onde o usuário pode construir seus próprios elementos para descrever seus objetos.
Dentro de as inúmeras características citadas em sua especificação destacam- se as seguintes:
É conciso, formal e legível para a compreensão humana;
Facilita a criação programas que utilizam o XML;
É fácil criar e editar documentos formatados usando esta especificação.
Estes arquivos XML usam uma sintaxe, as tags, muito semelhante ao Html.
Estas marcações servem como identificadores dos dados.
O uso do XML no escopo das extensões do Amphibian é extremamente importante por o fato de oferecer algumas características importantes no escopo referente a a criação de jogos computadorizados multiplataforma.
Usando o XML para criar os mecanismos de persistência adota- se uma forma padrão de especificar objetos facilitando a definição de objetos de jogo simplesmente alterando o arquivo que descreve o objeto;
Pode ser utilizado por outras aplicações em diferentes contextos e implementadas em diferentes linguagens;
Por o fato de ser uma forma canônica pode ser usado para conversão de formatos, por exemplo, criar um banco de dados a partir de um arquivo XML;
E a criação de editores, pois inicialmente todas as configurações são efetuadas de forma manual por o desenvolvedor, mas utilizando uma padronização XML é possível construir editores em conformidade com este padrão facilitando o processo de configuração e criação de objetos e especificações do sistema.
A principal desvantagem do uso do XML é o tempo para efetuar o parsing dos dados descritos por o formato, entretanto diante de inúmeras vantagens, tal desvantagem é minimizada.
Para adicionar esta facilidade no Amphibian criou- se uma classe utilitária denominada XML que fornece alguns serviços para manipulação deste tipo de arquivo, tais como efetuar leitura e escrita de arquivos, e manipular seus elementos.
Aproveitando- se da reusabilidade o processo de parsing é delegado para o pacote JAXP (Java API for XML Processing) distribuída junto com a J2SE.
Para a manipulação dos arquivos foi adotado o padrão Dom (Documenta Object Model) que organiza os elementos numa árvore e permite que o desenvolvedor manipule diretamente os nós e as subárvores.
Esta classe é usada por alguns carregadores e por os peers de persistência.
O carregador de sprite (SpriteLoader) e o carregador do gerenciador de camadas (LayersManagerLoader) utilizam o formato XML.
Os atributos destes objetos são descritos usando este padrão e foram criadas duas extensões distintas para diferenciar estes arquivos no momento da carga destes.
Para o gerenciador de camadas adotou- se a extensão LMN.
Quanto a o SpriteLoader este é possível carregar três tipos de descritivos ­ de fontes (extensão FNT), sprites e sprites animados (ambos com extensão SPR).
Em o Anexo C encontram- se alguns exemplos da especificação destes objetos.
Quanto a os peers, utilizados no mecanismo de persistência foram as criadas as classes XMLGamePeer, XMLHeapPeer e XMLEngineSpecPeer para serem usados por as classes Gamem, Heap e EngineSpecification respectivamente.
Todas estas classes utilizam a classe utilitária XML.
Em o Anexo C é possível consultar alguns exemplos de arquivos usados por estas classes.
De estes peers é interessante destacar o XMLHeapPeer que constrói o arquivo XML utilizando todos os objetos de jogo e variáveis que estão alocados na memória.
Para cada um dos objetos de jogo solicitam- se os nomes dos atributos e os valores destes assumidos no momento do armazenamento do estado da memória no dispositivo.
Para recuperação do estado armazenado também se utiliza o mesmo nome de atributos e valores para redefinir o estado de cada objeto que estava armazenado na memória.
Por último é importante destacar a organização dos pacotes que foram implementados em função de esta extensão.
As abstrações referentes ao Amphibian foram agrupadas num pacote denominado amphibian.
Criou- se um pacote chamado xamphibian que contem um subpacote desktop, na próxima subseção o pacote xamphibian será tratado novamente só que considerando o aspecto referente a a plataforma móvel.
O xamphibian.
Desktop baseia- se na API oferecida por o J2SE, na abstração Sal e no pacote amphibian.
Em a Figura 64 é possível analisar o diagrama de pacotes para esta extensão do Amphibian para computadores pessoais.
Percebe- se que somente as extensões xamphibian.
Desktop e saldesk utilizam o pacote java, o pacote sal é usado tanto por as extensões quanto por o amphibian, que a propósito utiliza somente este pacote externo.
Para organizar os recursos criou- se um repositório de objetos simples baseado num catálogo, waba.
Io. Catalog, de registros armazenados num PDB (Palm Database).
Esta classe implementa IPersistentPeer e é usada no mecanismo de persistência para manipular um repositório de objetos.
Para compreender o funcionamento básico do repositório é necessário compreender o formato PDB.
Este arquivo consiste de um banco de dados com inúmeros registros geralmente usados para armazenar dados para uma aplicação.
Por isto foi adotado para armazenar os objetos de jogo criando um repositório voltado para os handhelds.
Destaca- se que formato também foi usado para efetuar a persistência da especificação do motor de jogo e do descritivo do jogo.
Foi criado um aplicativo simples, o PDBResources, que dada uma listagem contendo o identificador, o nome do arquivo, seu tipo e a forma de armazenamento (pode ser armazenado somente o endereço para buscar neste lugar a informação ou os dados binários são armazenados), que no caso é o conteúdo binário;
O identificador e o nome do repositório.
Cria- se um arquivo PDB com tal nome e em cada registro armazena- se o identificador do objeto, seu tipo e os dados binários.
Para facilitar buscas futuras cria- se um indexador num arquivo PDB com um único registro sendo que se define para cada identificador de objetos sua posição no repositório.
Quando algum recurso precisa ser recuperado do PDB utiliza- se o índice para descobrir a posição do repositório que precisa ser lida.
Desta forma evita- se uma busca linear por todos os registros.
Destaca- se que o nome do repositório é definido conforme o nome do arquivo PDB e o identificador único de cada objeto contido no repositório é armazenado no mesmo registro junto com os dados binários que foi informado na listagem usada no utilitário para criar o PDB contendo um repositório de objetos.
Por último, serão tratadas as classes relacionadas com a persistência e que utilizam como formato de armazenamento o padrão XML.
Por o fato de ter usado este padrão tornou- se bastante fácil criar os arquivos de especificação do motor de jogo e o descritivo do jogo, pois a forma de criação é absolutamente a mesma.
A única diferença em relação a os computadores pessoais é que nestes o arquivo XML é usado diretamente, enquanto que nos handhelds deve ser usado um PDB que contem o conteúdo do arquivo XML armazenado num registro.
Para adicionar esta facilidade na extensão do Amphibian para handhelds criouse uma classe utilitária também denominada XML que fornece alguns serviços para manipulação de dados formatados neste padrão.
O processo de parsing é delegado para o pacote XML oferecido por o pacote xplat da SuperWaba.
A implementação oferecida com a máquina virtual adota um autômato para efetuar o parsing, à medida que são encontradas as tags e atributos, eventos são disparados sinalizando que algum elemento foi identificado.
De forma facilitar a criação dos peers que usam XML foi criada a classe XMLState, onde se define um estado para cada elemento do arquivo XML.
Configuram- se estes estados associados aos elementos e conforme os eventos são disparados o XMLState efetua suas ações de configuração.
Estas classes são usadas por alguns carregadores e por os principais peers.
Os carregadores de sprite (SWSpriteLoader), de gerenciador de camadas (SWLayersManagerLoader), de beeps (BeepSound) utilizam o formato XML.
Os atributos destes são descritos usando este padrão e foi criada mais uma extensão para diferenciar estes arquivos no momento da carga destes.
Para o beep foi escolhida BEP, para os demais foi usada à mesma extensão que os computadores pessoais utilizam.
Quanto a os peers, foram criadas as classes SWXmlGamePeer, SWXmlHeapPeer e XMLEngineSpecPeer para serem usados por as classes Game, Heap e EngineSpecification respectivamente.
Todas estas classes utilizam as classes XML e XMLState.
É importante destacar que no caso de a SWXmlHeapPeer no momento não é possível efetuar persistência da sessão do jogo.
Quanto a a especificação do motor e o descritivo do jogo precisam ser armazenados num PDB, para isto foi criado um utilitário, XMLtoPDB, que armazena os dados do arquivo XML num único registro de um PDB.
Por último, é importante destacar a organização dos pacotes que foram implementados em função de esta extensão.
Utiliza- se o mesmo pacote amphibian que foi adotado nos computadores pessoais.
Em o pacote xamphibian acrescentou- se o subpacote superwaba.
O xamphibian.
Superwaba baseia- se na API oferecida por a SuperWaba, na abstração Sal e no pacote amphibian.
As mesmas propriedades referentes aos relacionamentos observadas na Figura 64 é possível de encontrar no diagrama de pacotes da Figura 65.
Somente as extensões xamphibian.
Superwaba e salsw utilizam o pacote waba.
O pacote sal também é usado tanto por as extensões quanto por o amphibian.
Em as próximas subseções serão apresentados exemplos de uso do Amphibian.
Alguns poderiam ser chamados de &quot;pseudojogos «por o fato de simplesmente testarem algumas funcionalidades e extensões que foram apresentadas anteriormente.
A subseção 5.2.1 e a subseção 5.2.2 são estes testes, já na subseção 5.2.3 é apresentado o jogo da serpente e na subseção 5.2.4 uma versão orientada a objetos do Jogo da Vida de John Conway.
Todos estes exemplos foram construídos usando as extensões do motor de jogo descritas na seção 5.1.
Para os testes de desempenho será utilizado o Jogo da Vida de John Conway.
Como o desenvolvimento do framework encontra- se numa fase inicial utilizar um domínio muito complexo, ou seja, um jogo com uma lógica sofisticada, não seria adequado.
Teria- se despendido tempo para resolver questões inerentes ao domínio do jogo ao invés de focar na modelagem da arquitetura do framework, lembrando que o objetivo deste trabalho não é desenvolver nenhum jogo computadorizado, mas projetar uma infra-estrutura flexível e portável que permita desenvolver diferentes motores de jogos.
Quanto as screenshots que serão apresentadas nas próximas subseções foram obtidas usando os seguintes sistemas operacionais para computadores pessoais:
Microsoft Windows XP e a distribuição Red Hat cuja versão do kernel é 2.2.17.14 cl do Gnu/ Linux.
Quanto a a plataforma móvel foram utilizados emuladores fornecidos por a Palm Inc..
Foram emulados os hardwares do Palm m100 rodando o sistema operacional PalmOS 3.5 e o Palm m505 com o PalmOS 5.0 usando o Palm Os® Emulator (Pose) versão 3.3.
Também foi emulado o hardware do Palm Zire utilizando o Palm Os® Simulation 5.2 com o PalmOS 4.5.
A primeira aplicação criada trata- se de um teste referente a o uso do modo tela cheia visando o desenvolvimento de jogos.
Comumente os jogos comerciais utilizam toda a superfície gráfica de um determinado modo de vídeo oferecido por o periférico de visualização disponível no dispositivo para criar as imagens.
Por esta razão, é fundamental oferecer a possibilidade de desenvolver jogos computadorizados no modo tela cheia.
O teste &quot;Quadrados Coloridos «consiste em desenhar na tela inúmeros quadrados usando diferentes cores.
Estes são posicionados em pontos aleatórios na superfície gráfica.
Suas cores e dimensões também são definidas de forma randômica.
O resultado desta aplicação é a criação de diferentes mosaicos coloridos.
Para implementação deste teste foi criada uma única classe denominada FullScene que consiste de uma subclasse de Scene disponibilizada por o Amphibian.
A responsabilidade de desenhar quadrados coloridos foi delegada a esta classe que a cada vez que o loop de execução do motor de jogo solicita para cena padrão, no caso FullScene, atualiza a superfície gráfica a classe desenha um novo quadrado.
Não possui nenhum controlador e não usa nenhum objeto lógico, simplesmente faz desenhos diretamente na tela.
A FullScene é compatível com qualquer plataforma que suporta o Amphibian, pois esta classe foi criada usando os pacotes amphibian e sal.
Para os computadores pessoais criou- se um arquivo XML contendo a especificação do motor de jogo, associando- se à saída padrão (encerrar a aplicação) à tecla 'ESC' e definindo que a cena padrão que será usada é a FullScene.
O container é configurado com a cor preta e deve assumir a resolução 800x600 com 32 bits de profundidade de cor, sem usar double buffering.
Isto permite que a tela não seja limpa e cada quadrado fique sobreposto ao anterior.
Não é necessário criar nenhum descritivo de jogo.
Para que &quot;Quadrados Coloridos «execute na plataforma móvel criou- se um arquivo XML contendo a especificação do motor de jogo, definindo a cena padrão (FullScene) e associando- se a ação de sair da aplicação à tecla' HARD1 minute que equivale à funcionalidade de exibir a agenda no Palm.
O container foi definido para ser preto e usar o modo de vídeo 160x160 com 8 bits de profundidade de cor.
Este arquivo é armazenado num arquivo PDB, conforme visto na seção 5.1.3.
Em a Figura 69 estão apresentadas as telas capturadas do Quadrado Coloridos executando em diferentes plataformas.
As telas referentes à execução no Linux e no Windows são idênticas por o fato de ambas utilizarem o modo tela cheia.
Estão sendo apresentadas justamente para identificar que não existem diferenças na execução da aplicação nos dois sistemas operacionais.
Em outros exemplos é possível diferenciar a plataforma de execução do teste, por exemplo, na Figura 70.
A partir de esta versão original do &quot;Quadrados Coloridos «foram criadas duas variações.
A primeira trata da execução deste teste no modo janelas e a segunda quanto a o uso de áudio.
Decidiu- se por a execução no modo janelas para verificar como seria modificar o container do motor e o impacto que ocorreria nos outros componentes.
Para isto simplesmente modificou- se o arquivo XML referente a a especificação do motor definindo o tamanho da janela e o texto que deveria aparecer na barra da janela, tanto para os computadores pessoais quanto para os handhelds.
As telas podem ser vistas na Figura 70.
A outra variação referente a a reprodução do áudio necessitou maiores modificações.
Basicamente o objetivo é continuar desenhando os quadrados coloridos com a diferença que se executa uma música de fundo, no formato OGG, e quando se pressiona a tecla de espaço é reproduzido um som, no formato WAV.
Além disso, permite fazer um teste quanto a o salvamento e recuperação do estado do jogo.
Foram criados um controlador (AudioControl) e três ações auto-executáveis ­ reproduzir som (PlayAction), salvar sessão (SaveAction) e restaurar sessão (RestoreAction).
A classe FullScene é reutilizada sem nenhuma modificação.
A classe AudioControl é uma subclasse de Controller compatível com o Amphibian.
Quando é inicializado começa a reprodução de um som em loop cujo identificador é «Audio.
BACK». A ação PlayAction tem a responsabilidade de reproduzir um som cujo identificador é «Audio.
TYPE». Utilizar estes identificadores torna a solução compatível com diferentes formatos de som, portanto executável em qualquer plataforma que dê suporte ao Amphibian.
A ação SaveAction solicita que a memória (Heap) seja persistida num arquivo padrão e a ação RestoreAction restaura o estado da memória usando o mesmo identificador do arquivo padrão.
Para efetuar a persistência é usado o formato XML conforme visto na seção 5.1.
Cria- se um repositório de objetos adotando a forma de diretório onde são colocados dois arquivos de áudio, um para música de fundo no formato OGG e outro no formato WAV, cujos identificadores são &quot;BACK «e &quot;TYPE «respectivamente.
O nome do repositório é definido como &quot;Audio».
Através destes identificadores o controlador de áudio poderá reproduzir a música de fundo e a ação PlayAction poderá reproduzir o som.
Depois de concluída a etapa anterior de definição de novas classes e criação dos recursos, cria- se uma nova especificação do motor de jogo onde são definidos dois carregadores de recursos, um para o formato de áudio OGG e outro para o WAV;
O controlador de áudio;
Registra- se o repositório &quot;Audio «como repositório que utiliza diretórios para armazenar seus recursos;
E associam- se teclas as ações.
O container é configurado da mesma forma original, no modo tela cheia.
No caso de esta variante é necessário criar um descritivo do jogo.
Também utilizando o formato XML, cria- se um arquivo que especifica que o único nó do jogo ao ser carregado deve declarar uma variável inteira chamada &quot;COUNT&quot;_ FRAMES «(usada para o teste de persistência).
Os objetos multimídia &quot;BACK «e &quot;TYPE «do repositório &quot;Audio «devem ser alocados.
Quanto a o teste de persistência, basicamente consistiu em armazenar e recuperar o valor da variável &quot;COUNT_ FRAMES».
Um exemplo de um arquivo que mantém o estado da memória pode ser visto no Anexo C. Concluídas estas configurações a aplicação pode ser executada informando para a GameWindow dos computadores pessoais os arquivos de especificação do motor e o descritivo do jogo.
Em esta variação não serão apresentadas as telas de execução do jogo por o fato destas serem idênticas as telas do Windows e do Linux da Figura 69, pois a diferença desta variante está na reprodução de sons.
Como no exemplo anterior as operações visuais foram delegadas a uma classe especial responsável em desenhar diretamente na superfície gráfica este exemplo foi criado para testar o uso de classes básicas do mecanismo 2 D, sem o uso de animação, e testar as interações entre eventos gerados por periféricos com teclas e apontadores.
Este exemplo consiste em movimentar a imagem de um sapo em quatro direções (para cima, para baixo, para esquerda e para direita) ou posicionar- lo em qualquer ponto da tela utilizando um apontador.
Também é apresentada uma imagem idêntica do sapo só que esta não pode ser controlada e um texto apresentado na parte superior da tela.
Tais elementos foram adicionados para demonstrar questões referentes à transparência das imagens.
Em este caso não foi criado nenhum controlador somente cinco ações autoexecutáveis ­ UpAction, DownAction, LeftAction, RightAction e MovePointerAction.
As quatro primeiras ações efetuam a translação de um sprite cujo identificador é «VIEW2D.
AMPHIBIAN_ SPR «conforme a direção da ação e a velocidade deste sprite.
Por exemplo, caso seja executada uma ação RightAction, o sprite é deslocado dx pixels no eixo x.
No caso de a MoverPointerAction recebe como parâmetro de execução um evento gerado por um apontador, posiciona o sprite definido por o mesmo identificador considerando o ponto informando por o evento do apontador e o ponto central do sprite que é posicionado nesta coordenada do evento.
Quanto a os recursos do jogo, optou- se por o uso de diretórios com seis objetos de jogo.
Foram criadas duas imagens uma para representar o sapo (&quot;AMPHIBIAN&quot;) e outra que representa a fonte (&quot;FONT&quot;) para ser usada para escrever uma mensagem na tela.
Em a Figura 71 estão apresentados estes recursos.
Em a versão para computadores a imagem do sapo tem as dimensões 140x109 pixels no formato PNG e a fonte 320x204 no formato GIF.
Em a versão para handhelds ambas imagens estão no formato BMP e as dimensões do sapo são 70x55 pixels e as dimensões da fonte 160x102 pixels.
Dando continuidade na definição dos recursos criou- se os arquivos em XML para descrever um sprite que representa o fundo do jogo (&quot;BACK_ SPR&quot;), um sprite para o segmento da cauda (&quot;BODY_ SPR&quot;), um sprite para maçã (&quot;FOOD_ SPR&quot;), uma fonte textual (&quot;SNAKE_ FNT&quot;), um sprite animado que representa a cabeça (&quot;HEAD_ SPR&quot;) e um gerenciador de camadas (&quot;LAYER_ MANAGER&quot;).
Criou- se a especificação do motor de jogo usando o formato XML definiu- se os carregadores dos arquivos, registrou- se o repositório &quot;RESOURCES «como um diretório, definiu- se o controlador do jogo serpente (SnakeControl), declarou- se as ações associando- as as teclas e configurou- se o container no modo janela com as dimensões 504x504 pixels, sem permitir redimensionamento e com o título &quot;Snake».
No caso de os handhelds, o repositório é registrado como um arquivo PDB, as ações são associadas às teclas do handheld e as dimensões do container são definidas em 144x144.
Por último, foi criado o descritivo do jogo para os computadores pessoais que contêm um único nó.
A o ser alocado executa os seguintes comandos:
Declara as variáveis &quot;WIDTH», &quot;HEIGHT», &quot;Score_ X «e &quot;Score_ Y», sendo que as duas primeiras representam as dimensões do mundo de jogo considerando o número de células numa matriz e as duas últimas é a coordenada do placar;
Aloca- se todos os objetos;
E define- se que &quot;BACK_ SPR», &quot;BODY_ SPR», &quot;FOOD_ SPR «e &quot;HEAD_ SPR «devem estar contidos dentro de a camada.
O descritivo do jogo para handhelds é idêntico ao identificador para computadores pessoais exceto que não utiliza nenhuma imagem de fundo e nenhuma música, portanto estes objetos de jogo não são alocados, e os valores das variáveis são diferentes, por exemplo, a dimensão da matriz usada para representar o mundo de jogo para computadores pessoais é definida em 21x21 e para os handhelds em 9x9.
Em a Figura 74 é possível visualizar algumas screenshots do Snake executando em diferentes plataformas.
O Jogo da Vida de John Conway foi proposto em 1970 por o matemático John Conway e consiste de um problema de autômatos celulares referenciado por diferentes pesquisas.
Conway criou um passatempo que o autor denominava &quot;vida».
O jogo consiste de uma matriz quadrada, semelhante a um tabuleiro de xadrez, onde cada célula pode estar viva ou morta.
O estado destas células é definido por as regras apresentadas na Figura 75.
O autor definiu este conjunto de regras simples que é capaz de produzir um comportamento complexo, criando diversos padrões visuais semelhante ao comportamento de seres unicelulares.
O objetivo de determinar/ aplicar algumas métricas ao framework foi de verificar quanto o protótipo inicial do Amphibian está coeso e complexo.
Tais métricas, serviram como um conjunto de propriedades que indicaram oportunidades para futuramente serem aplicados indicadores, que de fato, permitirão analisar o framework sob o ponto de vista da qualidade de software.
Desta forma estas métricas podem ser usadas como um descritor da arquitetura adotada e, em conjunto com os testes de desempenho que serão apresentados na próxima seção, será possível estabelecer algumas relações quanto a arquitetura e seu desempenho.
As definições destas métricas basearam- se em Fayad, Schimidt &amp; Johnson.
Para os autores são necessários muitos anos para aperfeiçoar a arquitetura de um framework por o fato de ser extremamente complexo prever todas as situações de aplicações com suas diferentes especificidades que poderão ser desenvolvidas a partir de o framework.
Pode- se dizer que a principal vantagem do uso de um framework é a produtividade para o desenvolvimento de novas aplicações, entretanto, tal produtividade existe quando os desenvolvedores aprenderam a usar esta infra-estrutura.
À medida que os desenvolvedores vão aprendendo a utilizar a ferramenta o tempo de criação das aplicações, a partir de o framework, vai diminuindo.
Logo rapidez de aprendizagem é um fator importante no uso dos framework, sendo que esta depende da farta documentação, da própria estrutura, e da estabilidade e complexidade das funções do framework.
Os autores focalizam na questão da arquitetura e das funções propondo um índice de estabilidade quanto a estes dois fatores.
Em este contexto estável é interpretado como o máximo de cobertura do framework em relação a o seu domínio e o mínimo de esforço para desenvolver aplicações personalizadas a partir de ele.
Apesar de ser um fato subjetivo é útil para os usuários na escolha dos frameworks, pois é possível estabelecer uma comparação entre os índices de diferentes frameworks e comparar a evolução da estabilidade em função de o lançamento de novas versões.
Também é importante para os desenvolvedores no sentido de verificar o quanto a as mudanças desenvolvidas para uma nova versão impactaram na estrutura do framework e para os gerentes de projeto quanto a a criação de estimativas de tempo e custo envolvidos na produção de um framework.
Os frameworks podem ser analisados quanto a arquitetura do sistema e quanto a arquitetura das classes.
Quanto a arquitetura do sistema esta é representada por as colaborações entre as classes (características de interação) e a hierarquia de classes (características estáticas).
Quanto a arquitetura das classes esta é definida por a estrutura (características estruturais), funcionalidades (características funcionais) e por as colaborações entre as classes (características relacionais).
Tendo em vista esta coleção de características referentes às arquiteturas do sistema e das classes escolheu- se um conjunto de métricas que irão descrever- las.
Fayad, Schimidt &amp; Johnson indicam que a primeira etapa de avaliação do framework deve ser a escolha das métricas que permitam caracteriza a arquitetura da solução.
Apesar de os autores especificarem que as métricas referentes á arquitetura de classes serem calculadas para cada uma de elas, optou- se em obter a média destas métricas para cada um dos pacotes analisados.
Por esta razão não foi adotada nenhuma métrica quanto a as colaborações das classes, pois estas já estão representadas nas interações do sistema na forma das médias.
O objetivo é justamente criar um panorama traçando as principais características do framework, cujas métricas sejam fáceis de serem coletadas.
A partir de a Tabela 5 até a Tabela 9 são descritas as métricas escolhidas para avaliar o Amphibian.
Em o total foram definidas 33 métricas.
A maioria desta foram obtidas na bibliografia especializada no tema, entretanto algumas de elas foram definidas de forma empírica como um complemento às outras métricas.
Média do número de métodos públicos do NMMPC sistema.
Soma de todos os métodos públicos dividido por o total de classes do sistema.
A dependência entre pacotes não deve formar nenhum ciclo, ou seja, o pacote A depender de B e o pacote B depender de A. Um valor PDA de 1.0 significa que não existe nenhum ciclo entre os pacotes.
Esta métrica representa o nível de acoplamento entre os pacotes.
O mesmo que o PDA entretanto considera os sub-pacotes recursivamente.
PRDA Significa que determinado pacote depende de outros para seu funcionamento.
Representa o grau de dependência.
Cada pacote pode depender de outros n pacotes.
É dado por o somatório do número de pacotes usados por cada pacote do sistema dividido por o total de pacotes (Np) Significa a responsabilidade do pacote, ou seja, o número de pacotes que usam o que está sendo avaliado.
É o somatório de todos os pacotes que o usam cada pacote do sistema dividido por o total de pacotes (Np) Em a média o quanto que cada classe depende de pacotes externos.»
definido por a dependência eferente (De) dividida por o total de classes do sistema (NC).
Uma alta estabilidade significa que o pacote é altamente independente e responsável.
É determinado por a divisão da dependência eferente (De) por a soma da dependência aferente (De a) com a dependência eferente (De).
Em o caso considera- se um valor médio para cada sub-pacote do sistema.
Representa a distância do pacote em relação a o equilíbrio entre a abstração e a instabilidade.
O somatório de todas as linhas de código não comentadas do sistema.
O somatório de todas as linhas não documentadas de arquivos de configuração usados por o sistema.
O tamanho, expresso em bytes, de todas as classes do sistema incluindo seus subpacotes, sem nenhuma compactação das classes.
O tamanho, expresso em bytes, de todas as classes e arquivos de configuração usado por o sistema, sem nenhuma compactação das classes.
Descrição Contabiliza o total de métodos, independente da visibilidade, existentes no sistema.
Somatório de todos os métodos das classes do sistema, incluindo os sub-pacotes.
Contabiliza o total de atributos, independente da visibilidade, existentes no sistema.
Somatório de todos os atributos das classes do sistema, incluindo os sub-pacotes.
O valor médio de atributos por classe.
Definido por o total de atributos (NA) dividido por o total de classes (NC).
O tamanho médio, em bytes, de cada classe.
O tamanho total das classes do pacote (TTP) dividido por o número de classes (NC).
O tamanho médio expresso em linhas por cada classe do sistema.
É dado por o total de linhas do sistema (SLOC) dividido por o total de classes (NC).
O tamanho médio expresso em linhas por cada método do sistema.
É dado por o total de linhas do sistema (SLOC) dividido por o total de métodos (NTMP).
A quantidade de total de métodos abstratos disponíveis no sistema independente da NMA visibilidade.
É o somatório de todos os métodos abstratos das classes do sistema.
Número médio de A média de métodos abstratos por classe.
É Derivada de métodos abstratos por NMMAC definida por a divisão do total de métodos NMA classe abstratos (NMA) por o total de classes (NC).
A média de métodos por classe Derivada de Número médio de NMMC independente de serem abstratos e da métodos por classe NTM visibilidade.
Média do número de parâmetros por Número médio de método.
Dado por a soma dos parâmetros de parâmetros por NMPM todos os métodos dividido por o número total método de métodos do sistema (NTM).
Número de Complexidade ciclomática está baseada em Complexidade um grafo de controle que representa a lógica NCCM Ciclomática Médio dos de o método.
Conhecida como métrica de Métodos complexidade de McCABE.
Quanto a a camada Sal destaca- se um número pequeno de pacotes e classes.
Possui alta abstração, 69,57% e não possui nenhuma subclasse sendo que 60,87% dos componentes do pacote são interfaces.
Quanto a as interações, 93,8% dos seus métodos são públicos, portanto são possíveis serviços para serem utilizados por as classes clientes.
Tratando do relacionamento entre os principais sub-pacotes do sistema estes não possuem nenhum ciclo.
Quanto a o acoplamento, o pacote é bastante estável, pois é usado por uma grande quantidade de pacotes, depende de poucos pacotes externos e possui uma alta abstração.
Tal característica é importante quando consideramos que este pacote é utilizado por inúmeros outros.
Toda a solução possui poucas linhas de código, somente 304 linhas, não precisa de nenhum arquivo de configuração e ocupa cerca de 11 Kb.
Em relação a as classes, estruturalmente em média são pequenas, com cerca de um único atributo, utilizando 13 linhas de código e ocupando 520 bytes.
Funcionalmente cada classe possui em média 6 métodos, sendo que 3 destes são abstratos.
Cada método tem cerca de 2 linhas de código, utilizam em média 0,6124 parâmetros e apresentam baixa complexidade ciclomática, com pouco laços de execução e condicionais.
Comparando o pacote Sal com suas duas extensões, para computadores pessoais e handhelds, é possível verificar que em relação a as características estáticas, em geral são 40% menores.
Não são oferecidas mais classes abstratas, nem interfaces, basicamente consiste da implementação das interfaces oferecidas por o Sal.
Quanto a as interações, estas se tornam bem mais intensas desta forma deixando as extensões mais instáveis, pois cada sub-pacote utiliza em média outros quatros, não oferece nenhuma abstração e são poucos utilizados por os demais pacotes.
Em compensação as classes das extensões do ponto de vista estrutural são maiores, isto reflete no tamanho médio das classes, cerca de 1,92 Kb para as classes dos computadores pessoais e 1,28 Kb para os handhelds, praticamente dobrando o número de linhas de código.
Por conseqüência os métodos incrementam em média 45% em ambas extensões em relação a as linhas de código e a complexidade ciclomática para os handhelds incrementa cerca de 6%, mantendo- se praticamente inalterada em relação a os computadores pessoais.
Não oferecem nenhum método abstrato e as extensões ofertam praticamente a metade dos serviços públicos do pacote sal.
De forma sumária contata- se que estruturalmente as extensões são menores, mas com maior interatividade entre as classes por o fato que as extensões implementam os hot spots oferecidos por a Sal, delega suas responsabilidades para outras classes principalmente usando a API da máquina virtual da plataforma, tornando as extensões bem mais instáveis.
Em contrapartida as classes tornam- se mais arrojadas, com mais métodos e atributos requerendo uma maior quantidade de código.
Este em geral mantém- se simples por o fato da complexidade ciclomática permanecer praticamente inalterada.
Em relação as customizações não utilizam arquivos de parâmetros externos sendo necessário criar novas classes e recompilar a solução caso alguma classe seja modificada.
Quanto a a camada referente a o Amphibian no geral apresentou as mesmas características descritas anteriormente para a Sal em relação as suas extensões para ambas plataformas de execução.
As características estruturais do pacote amphibian descrevem uma solução com 38,24% de abstração.
Oferece- se um número significativo de hierarquias sendo que cerca de 47,06% das classes estendem alguma outra.
Em média, estas hierarquias possuem 2,67 subclasses com uma profundidade média de 1,5208 níveis.
Considerando suas inter-relações seus principais sub-pacotes não apresentam nenhum ciclo, quanto as dependência de forma recursiva obtém- se um valor de 0,97 em função de o forte acoplamento e das interdependências dos sub-pacotes que tratam da lógica do motor.
Seria extremamente difícil utilizar alguma destas classes sem importar uma série de outras.
Para minimizar este problema a classe Engine centraliza o controle e manipula todas as demais classes, desta forma as classes que necessitam dos serviços oferecidos por o pacote podem interagir somente com a classe Engine, facilitando suas operações (padrão Façade).
O pacote possui uma estabilidade mediana por o fato de em média necessitar de aproximadamente 7 pacotes para realizar suas operações e ser usado por praticamente outros 9 pacotes.
Para sua codificação são necessárias 2258 linhas de código e o pacote ocupa cerca de 98 Kb sem utilizar nenhum arquivo de configuração. Quanto
suas classes, cerca de 90% dos métodos são disponibilizados publicamente, em média possuem 2,5735 atributos, com tamanho de 1,45 Kb e escritos com cerca de 33 linhas de código.
Cada classe possui em média 7,25 métodos sendo que 83,82% são abstratos, estes métodos utilizam no geral de 0 a 1 parâmetro e a complexidade ciclomática é de 1,66.
Relacionando as extensões com o pacote amphibian, é possível constatar que suas arquiteturas gerais são menores que o amphibian, e na versão para handhelds aumenta o número de subclasses.
A causa deste incremento é o fato que o mecanismo de persistência implementado usando XML baseia- se na criação de subclasses para tratar cada uma das &quot;tags «dos arquivos XML.
Também são soluções praticamente concretas como pode se observar por o baixo índice de abstração.
Quanto a as interações, são altamente dependentes de uma grande quantidade de pacotes, tornando as extensões bastante instáveis, sendo que a grande maioria das classes necessitam de algum pacote externo.
Isto é conseqüência de desenvolver classes que utilizam a Sal, a abstração oferecida por o Amphibian e outros pacotes externos usados para implementar as funcionalidades definidas por as abstrações da camada Amphibian.
A conseqüência disto é a dificuldade de usar estas extensões em outras aplicações multimídias.
Conforme foi visto na seção 3.2.3, Sametinger destaca que os componentes de um framework são altamente dependentes e na maioria das vezes o uso de um único componente implica em incorporar todo o framework.
Quando se optou por desenvolver o Amphibian sob a camada Sal automaticamente agregou- se as extensões uma dependência a este pacote.
Em relação a a estrutura das classes a extensão para computadores pessoais possui classes bem mais complexas necessitando de mais linhas de código, com métodos que necessitam de mais parâmetros e com complexidade ciclomática mais elevada definida, em média 2,3.
Em contrapartida a extensão para os handhelds mantiveram- se relativamente da mesma forma que o pacote amphibian.
Comparando a camada Amphibian com a Sal, percebe- se que a camada equivalente ao Amphibian possui um número maior de classes, implementa mais interfaces, organiza- se mais em hierarquias de classes e possui um nível de abstração menor.
Quanto a as classes no Amphibian são mais arrojadas, requerem mais linhas de código, usam mais atributos e possuem mais métodos com complexidade maior.
Isto se caracteriza por o fato da camada Amphibian estar provendo soluções para um domínio específico ao contrário de a Sal que basicamente é uma proposta de uma homogeneização de métodos amplamente utilizados por diferentes domínios.
Tendo em vista as métricas das soluções mais genéricas serão analisados duas aplicações criadas a partir de o Amphibian.
As métricas para estes jogos podem ser analisadas em dois grupos.
O primeiro trata de classes independente de plataforma caracterizadas por o pacote referente a o domínio do jogo (segunda coluna) e extensões criadas para compatibilizar o domínio com o Amphibian (primeira coluna).
O segundo grupo trata das especificidades de executar em determinada plataforma, por exemplo, computadores pessoais e handhelds.
O primeiro jogo que será analisado é o jogo da Serpente.
O domínio possui poucas classes, a maioria subclasses organizadas numa hierarquia com maior profundidade do que com largura.
Isto significa que cada classe tem poucos filhos, entretanto com diversas gerações (A é subclasse de B, B é subclasse de C).
Oferece um nível baixo de abstração.
É bastante instável, pois utiliza vários pacotes para definir sua lógica e é pouco utilizado por outros.
O que equilibra este pacote é o fato deste ser uma instância concreta voltada para resolução de um problema específico.
Se considerarmos o pacote de uso comum também são oferecidas poucas classes, todas concretas que utilizam vários pacotes e não são utilizadas por nenhuma outra classe em tempo de execução, são classes que serão usadas no momento de criar a especificação do motor de jogo e/ ou na criação do descritivo do jogo para isto usa arquivos de configuração.
Tal dependência não é um problema justamente por o caráter específico da aplicação caracterizado por a métrica DM que estabelece um equilíbrio entre a instabilidade da classe (que envolve suas dependências e responsabilidades) e seu grau de abstração.
Quanto a as características das classes, estas dependem do domínio e possuem características próprias.
No caso de o jogo da serpente é possível constatar que as classes de domínio são bem mais complexas que as classes de uso geral.
Estas possuem poucos métodos, nenhum destes abstratos, escritos com maior número de linhas de código e com maior complexidade ciclomática.
Se considerarmos as implementações para cada plataforma é possível constatar que para os computadores pessoais não é criado nenhum pacote e nenhuma classe, somente são utilizados somente arquivos de configuração.
No caso de os handhelds cria- se uma única classe por o fato da máquina virtual SuperWaba, executando sob PalmOS, necessitar de uma aplicação launcher.
Além disso, percebe- se que a quantidade de linhas de configuração dos arquivos é basicamente o mesmo em ambas plataformas, sendo que estes são configurados usando o formato XML.
É interessante comparar as métricas do Jogo da Serpente com as métricas do Jogo da Vida de John Conway.
Em relação a os pacotes de uso geral a única diferença entre ambos é que a solução desenvolvida para o Conway é menor do que para o jogo da serpente.
Isto não é relevante para avaliação do framework, pois estas diferenças ocorrem em função de serem aplicações distintas.
Entretanto se observarmos as definições para as plataformas de execução constata- se que ambos os jogos foram criados usando somente arquivos de configuração e um launcher para os handhelds.
Além disso, os pacotes geral e de domínio, referentes ao Jogo da Vida, são totalmente concretos e instáveis devido o uso de vários pacotes e baixa reusabilidade.
Mas da mesma forma que o Jogo da Serpente este problema é minimizado por tratar- se de uma aplicação única sem o objetivo de ser reutilizada em diferentes contextos.
Assim é possível afirmar, em relação a estes dois jogos, que a questão da portabilidade é definida somente na criação de arquivos de configuração que especificarão os detalhes de cada plataforma.
A complexidade do desenvolvimento dos jogos resume- se na criação de um domínio de jogo compatível com o Amphibian e a Sal.
O domínio tornou- se o aspecto variante das aplicações.
Cada jogo terá suas características que será refletida no seu domínio.
Em este sentindo a pergunta efetuada na seção 3.2, sobre a possibilidade de desenvolver uma série de jogos computadorizados alterando sua especificação e os dados utilizados por o jogo, semelhante às soluções, tais como Struts, para criação de Web sites, pode ser respondida positivamente baseando- se nos resultados obtidos com a análise destas métricas.
Desta forma o processo de criação de um jogo computadorizado pode ser descrito como a criação de um domínio e dos recursos multimídia;
Desenvolvimento de classes de adaptação para o Amphibian;
Opcionalmente poderão ser criados alguns componentes específicos, por exemplo, uma nova forma de visualização;
Configurações da especificação do motor para cada plataforma;
E por último a definição dos descritivos dos jogos que poderão ser criados para executarem sob este novo motor.
O objetivo dos testes, apresentados nesta seção, é efetuar algumas análises referentes ao desempenho e consumo de memória que está sendo obtida com a arquitetura proposta para o Amphibian.
Para Pressman os testes de software representam uma fase final no processo de desenvolvimento e uma última revisão da especificação, do projeto e da codificação.
O objetivo dos testes é encontrar erros, falhas, revelar problemas desconhecidos.
Existem diferentes estratégias para efetuar testes de software, entretanto o foco ficará nos testes de desempenho.
Não se espera detectar erros de execução, problemas de ordem funcional, mas sim encontrar falhas quanto a o desempenho desta arquitetura quando posta em execução.
Pressman cita a importância dos testes de desempenho em aplicativos em tempo real.
Por o fato dos jogos computadorizados executarem em tempo real, testes de desempenho são bastante adequados.
Quanto a as plataformas de teste foram usados três hardwares distintos.
O primeiro trata- se um computador pessoal com um maior número de recursos computacionais, o segundo é um computador pessoal com uma configuração mais básica e o terceiro trata- se de um Palmtop modelo m100.
As características de hardware podem ser comparadas na Tabela 14.
Quanto a a aplicação de teste, optou- se por o uso do Jogo da Vida de John Conway (seção 5.2.4) por as seguintes razões:
Este jogo foi utilizado por Marner na avaliação do uso da linguagem Java para o desenvolvimento de jogos computadorizados;
Manipulação de uma grande quantidade de objetos lógicos e objetos multimídia referente a a visualização destes.
Para cada peça do jogo existe um visualizador que deve ser atualizado toda vez que uma peça tem seu estado alterado na lógica do jogo.
Grande quantidade de objetos é bastante comum quando se trata do desenvolvimento de jogos computadorizados profissionais com maior complexidade do que os jogos de passatempo;
Alto custo computacional para execução da lógica do domínio do jogo.
A cada atualização é necessário avaliar a vizinhança de cada uma das células do tabuleiro.
Este processo é efetuado duas vezes, a primeira marca- se as células que irão nascer e morrer, e na segunda efetua- se a atualização do mapa;
Uso do modo tela cheia.
De a mesma forma que a manipulação de grandes quantidades de objetos é usual nos aplicativos comerciais, o mesmo pode ser dito quanto a o uso do modo tela cheia.
Isto implica na forma que a máquina virtual manipula as janelas e o buffer gráfico;
Executa sem intervenção de um usuário humano facilitando a criação e automatização dos testes de desempenho.
Os testes que serão executados visam responder as seguintes questões:
Adotar arquivos de configuração e a criação de componentes em tempo de execução torna o processo de inicialização lento?
Quais os objetos que ocupam mais espaço na memória do dispositivo e são criados por quais métodos?
Quais os métodos consomem mais tempo de processamento?
Qual a taxa de quadros por segundo está sendo obtida considerando a aplicação de teste?
Quanto a as questões 2 e 3, o foco é quanto a as classes do pacote sal e amphibian, pois não se espera efetuar nenhuma otimização da aplicação, nem das extensões desenvolvidas.
O que está sendo avaliado é o framework, não tais especificidades.
Portanto foram definidos três testes que seguem listados abaixo:
Tempo de Inicialização:
Consiste verificar o tempo de execução da criação do motor de jogo (Engine), a inicialização (InitState) e começar uma nova sessão (StartState);
Utilização da memória:
O objetivo é detectar os métodos e por conseqüência os pacotes que provem estes serviços que alocam mais objetos, listando aqueles que ocupam maior espaço na memória.
Destaca- se que no presente trabalho não será efetuada nenhuma otimização, simplesmente tais métodos serão detectados e posteriormente poderão ser otimizados em trabalhos futuros;
Utilização do Processador:
O objetivo é semelhante ao anterior com a diferença que neste teste serão detectados os métodos que consomem mais processamento.
Observando a Tabela 15 é possível concluir que as inicializações num computador com um hardware mais sofisticado necessita de 312 ms para efetuar todas as inicializações dos componentes, incluindo parsing de arquivos XML e instanciação de classes em tempo de execução.
Mesmo considerando um hardware mais simples, tais inicializações consumiram um tempo de aproximadamente 1s.
O maior problema está inicial permite que em média a cada ciclo de execução do jogo sejam manipuladas 562,2932 células com um desvio padrão de 326,2595.
Por o fato de esperar- se detectar métodos mais críticos referentes aos pacotes sal e amphibian, para fazer uma reflexão que servirá de embasamento para os próximos ciclos de desenvolvimento do motor.
Não se espera descobrir que determinada biblioteca não produz um resultado específico, mas sim como que a abstração do framework foi utilizada.
Por exemplo, no caso de o mecanismo de visualização 2D é utilizado a Gamelib por os objetos pintores, logo será desprezado questões referentes ao consumo de memória desta biblioteca, pois está poderá ser substituída, sendo o foco a abstração dos objetos pintores.
Foram efetuadas 10 repetições do Jogo da Vida de John Conway usando a opção de hprof coletando informações referentes ao uso da memória e do processador.
Utilizando os dados gerados por o hprof e o HPMeter escolheu- se os 10 objetos que ocupavam mais espaço em memória para cada uma das repetições.
Efetuou- se a média destes valores, que estão sendo apresentados na Tabela 16, tratando o consumo de memória por os 10 tipos de objetos mais usados no sistema.
Estes objetos ocupam 10,91 Mb e equivalem a 79,21% de toda a memória utilizada para executar o jogo.
De estes tipos podem ser ignorados as posições 6 e 9 da Tabela 16 por o fato de serem objetos da biblioteca Gamelib que foi adotada como recurso de pintura dos sprites para os computadores pessoais.
É importante destacar que caso esta avaliação estivesse sendo executada para uma otimização do jogo Conway ou questões referentes à plataforma de execução estes métodos não deveriam ser desconsiderados.
Em relação a os vetores de inteiros, que ocupam cerca de 32% da memória, usando o HPMeter verifica- se que grande partes destes objetos são criados por a máquina virtual em função de a carga e instanciação das classes.
Conhecendo tais elementos seria interessante descobrir os métodos do framework que contribuíram para maior alocação de memória.
Destaca- se que estes métodos que serão detectados foram críticos dentro de a concepção do Jogo da Vida, em outro contexto outros métodos poderiam ser destacados.
Como este jogo tem características interessantes como um domínio complexo e alta alocação de objetos, métodos que alocaram muita memória neste domínio são candidatos para futuras otimizações.
Para descobrir estes métodos utilizou- se mais vez o HPMeter escolhendo das 10 execuções a que obteve resultados mais próximo de os valores médios demonstrados na Tabela 16.
A partir de o ranking dos objetos alocados procurou- se os métodos pertencentes ao pacote sal e amphibian que diretamente alocaram objetos.
Estes métodos estão listados na Tabela 17.
Tais métodos alocaram objetos que ocuparam 21,2% da memória, o restante foi alocado por outros métodos que podem tratar- se de pacotes pertencentes ao Java ou alguma extensão do Amphibian.
Portanto a construção de retângulos, sprites e objetos 2D requerem prudência na sua utilização e devem ser usados com cuidado por o desenvolvedor.
Como são objetos extremamente comuns na criação de um jogo, compete ao desenvolvedor refletir o quanto que um domínio de jogo irá necessitar destes objetos e quanto que isto implicaria na portabilidade para dispositivos móveis.
A execução do jogo da vida no Palm m100 é bastante difícil, o jogo torna- se extremamente lento e a aplicação não consegue efetuar suas atualizações de tela com uma taxa de quadros por segundo razoável.
Uma possível causa para este fraco desempenho é justamente uma alta alocação destes objetos para um dispositivo e possui apenas 2 Mb para armazenamento e para execução dos aplicativos.
Tais argumentações respondem a pergunta&amp; 2.
Uma hipótese para resolução deste problema seria estudar a possibilidade de adotar o padrão de projeto Flyweight cujo principal objetivo é reduzir a granularidade de inúmeros objetos alocados.
Tal decisão seria principalmente para tentar resolver o problema da clonagem dos sprites.
Estes poderiam ser descritos por um estado intrínseco, por exemplo, a definição do identificador da imagem, as velocidades de translação nos eixos x e y, cor de fundo, e um estado extrínseco que definiria a borda do sprite que descreve sua posição atual e suas dimensões.
Em o momento que o sprite fosse desenhado esta borda seria calculada baseando- se na posição do objeto lógico que o sprite observa.
Assim não existiria a necessidade de clonar o sprite sua estrutura geral é única e a parte variante seria definida por o estado extrínseco.
Metaforicamente os sprites seriam como carimbos que sempre que forem necessários eles são posicionados e desenhados.
A pergunta&amp; 4 pode ser respondida por a análise dos dados da Tabela 18.
É possível afirmar que quanto a os computadores pessoais obteve- se uma excelente fps, onde foi possível obter uma taxa máxima de 63 fps num computador pessoal mais arrojado, sendo que um micro de configuração mediana a taxa ficou em torno de os 30 fps.
Lembrando que existiam alocados mais de 500 objetos lógicos sem considerar os objetos multimídia, a alta complexidade computacional e alguns métodos que poderiam ser otimizados.
Diante destes resultados, quanto a os computadores pessoais, os resultados foram plenamente satisfatórios.
Entretanto se considerarmos a plataforma móvel os resultados foram insatisfatórios, pois se obteve em média 0,15 fps, no máximo obtendo cerca de 0,24 fps.
Em relação a os computadores pessoais estes são aproximadamente 277 vezes mais rápidos considerando um computador arrojado e 212 vezes para um computador pessoal simples do que o Palmtop.
Uma alternativa para justificar este fraco desempenho parte- se do princípio que o domínio é bastante complexo e requer uma grande quantidade de objetos, desta forma evidenciando o pressuposto&amp; 3 apresentado na seção 4.1.
Lembrando que na seção 4.3 destacou- se que a arquitetura de camadas é menos eficiente que uma arquitetura monolítica, devido a o tráfego informacional entre as camadas, logo incrementando o processamento.
A o término do presente trabalho é interessante retomar alguns pontos destacados ao longo de o texto e efetuar algumas considerações sobre a concepção de um framework para o desenvolvimento de jogos computadorizados multiplataforma contextualizando- o num cenário quanto a o uso com propósitos educacionais.
Partiu- se do pressuposto da importância dos jogos computadorizados no processo de ensino-aprendizagem e que seria interessante produzir novos títulos com possibilidade de algum grau de autoria e, que estes pudessem ser usados em sala de aula.
Entretanto este cenário é difícil de ser implementado devido a os altos custos envolvidos, principalmente devido a a inexistência de ambientes que permitam criar os jogos mencionados na introdução deste trabalho e, que serviram de elemento motivador para este trabalho.
Os resultados obtidos com o amphibian, apesar de ainda serem empíricos, respondem a nossa questão de pesquisa e permitem que se demonstre que foi possível se pensar e criar uma infra-estrutura de software gratuita que permite construir jogos computadorizados multiplataforma.
0s desenvolvedores com diferentes níveis de especialização podem criar as bases de seus futuros jogos.
Em o amphibian e nos jogos desenvolvidos a partir de ele, sempre poderão ser concebidos como multiplataforma.
Cabendo ao desenvolvedor decidir o nível de portabilidade.
Em os exemplos apresentados todos executaram no Microsoft Windows, gnu/ linux e palmos sem alterar uma linha de código e os arquivos de configuração.
Sendo que para portar para o dispositivo móvel alterou- se o arquivo de configuração.
Assim é possível responder a questão de pesquisa definida no início deste volume com uma lista contendo as funcionalidades do framework e uma breve discussão da arquitetura desenvolvida para atender tais funções.
As funcionalidades que devem estar presentes num framework para criação de motores de jogos independente de plataforma de execução são as seguintes:
Usar uma coleção de componentes independentes do sistema operacional e desenvolver classes que utilizam estes componentes sem preocupar- se com suas implementações, ou seja, acessando somente uma interface padrão.
Isto garante que os jogos computadorizados sejam portáveis para diferentes dispositivos;
Configurar os componentes do motor de jogo em tempo de execução, dispensando recompilação, pois os motores são criados através de arquivos externos de configuração.
Proporciona facilidade no desenvolvimento de jogos e alta reusabilidade do fluxo de controle do framework;
Suportar diferentes formatos de arquivos em diferentes dispositivos.
Ao invés de fornecer um conjunto limitado de arquivos que podem ser interpretados por o motor, cria- se a possibilidade de desenvolver objetos especializados na carga de qualquer arquivo.
Desta forma o framework torna- se compatível com' n'formatos definidos por o desenvolvedor;
Representar os estados do motor de jogo na forma de objetos, facilita a manutenção, pois se opera somente com trechos de código específicos para cada estado do jogo.
Também quanto a o motor, deve oferecer uma interface padrão de acesso às suas funcionalidades, desta forma facilitando o uso do motor.
Concede flexibilidade e possibilita que este seja integrado em diferentes containers, tais como, um frame, uma janela para handhelds, ou algum outro container que será desenvolvido;
Tratar eventos independentes de dispositivo de execução.
Os eventos são adaptados para uma abstração interpretável por o motor.
Isto, por exemplo, permite tratar eventos produzidos por o mouse e por a caneta nos handhelds da mesma forma, pois o motor é desenvolvido baseado numa abstração dos apontadores;
Persistir dados independentes de dispositivos e formatos.
Basicamente a persistência da especificação do motor, do descritivo do jogo e do estado da memória.
Estes devem ser armazenados e recuperados independente do dispositivo.
Assim é permitido criar diferentes mecanismos de persistência facilitando o processo de portabilidade;
Gerenciar objetos de jogo localizados em diferentes repositórios de objetos de forma independente de implementação e dispositivo.
Assim os objetos de jogo podem estar armazenados em diferentes formatos e localizações.
Ao invés de o framework suportar exclusivamente um único formato de repositórios oferece a possibilidade de usar' n'formas de armazenar os objetos de jogo;
Alocar e manipular objetos de jogos que serão usados principalmente por os controladores e ações de forma padronizada e independente de implementação.
Os objetos de jogo são alocados com um identificador único numa memória e poderá ser usado em diferentes componentes do motor;
Gerenciar diferentes controladores de forma independente de suas implementações e funcionalidades.
Assim, por exemplo, ao invés de ser oferecido um controlador padrão para controlar entidades inteligentes usando algoritmos de inteligência artificial e preocuparse com diferentes controles, o framework suporta que sejam construídos' n'gerenciadores que podem ser &quot;plugados «na arquitetura conforme as necessidades do motor simplesmente fazendo uma declaração em sua especificação;
Oferecer suporte para criação de motores de jogos computadorizados independente do mecanismo de visualização.
Detalhes referentes à visualização estão separados da lógica dos objetos, permitindo que diferentes formas visualização sejam usadas.
Em esta versão inicial o framework oferece suporte básico para criação de jogos 2 D;
Reproduzir sons de forma independente de plataforma.
Ao invés de oferecer uma série de formatos que sejam compatíveis o framework disponibiliza uma estrutura que permite desenvolver suporte para' n'formatos de som reprodutíveis para um determinado dispositivo;
Descrever o conteúdo e o fluxo dos jogos computadorizados usando uma forma canônica de representação que seja independente do dispositivo e das especificidades dos motores de jogo.
Assim, diferentes motores, cada um com suas características poderão ser descritos de uma mesma forma padrão e ser armazenado em diferentes formatos para diferentes dispositivos.
Quanto a a arquitetura, conforme foi visto na seção 4.3, o amphibian está fundamentado numa arquitetura de execução baseada em camadas, onde existe uma camada de abstração do sistema operacional que permite homogeneizar questões referentes ao sistema operacional e/ ou máquina virtual Java.
A camada referente a o amphibian baseia- se nesta abstração e oferece uma estrutura flexível para criação de motores de jogos.
Sob esta são efetuadas todas as extensões, inclusive os domínios de jogos, que personalizam o amphibian para determinada aplicação.
Além disso, para efetuar a implementação das funcionalidades descritas anteriormente foi importantíssimo adotar os padrões de projeto para projetar a arquitetura interna do amphibian.
A adoção destes padrões garante um fácil entendimento da arquitetura e evita- se o custo de recriar uma solução que já está consolidada na forma destes padrões.
Quanto a a questão secundária que relaciona nível de generalidade com desempenho é possível afirmar que a arquitetura do amphibian possui um alto nível de abstração e simplifica o desenvolvimento de jogos conforme foi visto na seção 4.7 através do estudo das métricas.
Os testes de desempenho considerando o jogo da vida de John Conway, que manipula uma grande quantidade de objetos e possui uma lógica com alto custo computacional, e os computadores pessoais apresentaram um ótimo desempenho, inclusive em máquinas medianas obteve- se a taxa mínima tolerável de 30 fps e em computadores pessoais mais arrojados a taxa média foi de 42 fps atingindo até 63 fps.
Entretanto se considerarmos o handheld ocorreu um sério problema de desempenho, onde aproximadamente um quadro é pintado a cada 7s.
Apesar de a hipótese que este baixo desempenho deve- se a grande complexidade do algoritmo do jogo, conforme visto na seção 4.8.3, que consome cerca de 70% do processamento, não existem evidências que permitam afirmar que tal suposição é a explicação para o baixo desempenho do jogo.
Logo, para os computadores pessoais é possível afirmar que conforme os testes executados que o nível de generalização do amphibian não comprometeu seu desempenho.
Já quanto a a plataforma móvel não é possível afirmar se o baixo desempenho é oriundo da generalização da arquitetura, das especificidades do domínio do jogo ou devido os recursos limitados do hardware.
Diante deste contexto as hipóteses iniciais podem ser retomadas afirmando que:
É possível desenvolver um framework que seja independente dos mecanismos de visualização, de persistência e de especificidades de cada sistema operacional adotando uma arquitetura baseada em camadas e utilizando as &quot;best practices «para o desenvolvimento da estrutura funcional do framework.
Desta forma este opera como uma abstração dos motores de jogos executando sob uma camada referente a o sistema operacional;
Em termos de codificação, de fato o reuso de soluções computacionais é potencializado por a componentização.
Quanto a o reuso de projeto, o mesmo pode ser dito quanto a a adoção de padrões de projetos.
Isto permitiu definir interfaces padrões que facilitam a comunicação e a fácil substituição dos componentes sem comprometer os demais envolvidos no framework.
A prova disto é a fácil configuração da especificação do motor, onde é possível trocar componentes, tais como o relógio, renderizador e controladores, simplesmente redefinindo o nome do componente, não necessitando recompilar a aplicação;
A o término deste trabalho surgem umas séries de trabalhos derivados e ajustes que deverão ser feitos principalmente quanto a as otimizações e melhoria ao suporte as plataformas móveis.
Se o modelo computacional do amphibian fosse uma solução fechada, tais melhorias dependeriam exclusivamente da predisposição do autor.
Por o fato desta solução está sendo disponibilizada livremente para comunidade desenvolvedora aumentam- se as possibilidades de derivações, pois existe uma maior probabilidade do framework ser desenvolvido por mais de uma pessoa.
Efetivamente não se pode comprovar que a adoção da filosofia de software livre garanta o constante aperfeiçoamento da ferramenta, entretanto potencializa- se para que isto ocorra.
Quanto a o interesse da comunidade desenvolvedora, existem indícios de colaboração, pois a tradução do site de português para inglês foi desenvolvida por um voluntário pertencente à comunidade do SourceForge.
Em relação a os objetivos estes foram plenamente atendidos, pois o amphibian é uma concretização da proposta do framework e permitiu que diversos casos de testes fossem desenvolvidos e executassem em multiplataformas, apesar de os problemas de desempenho no caso de os handhelds.
Além disso, foi implementados o mecanismo de visualização 2D e o mecanismo de persistência usando o formato XML conforme havia sido planejado.
Partindo para as contribuições do presente trabalho é possível destacar:
Ampliar as discussões e reflexões sobre o uso dos jogos computadorizados como uma ferramenta de ensino-aprendizagem e sobre seu uso no âmbito escolar, considerando que a princípio, todos os jogos são educativos mesmo os que não possuem objetivos pedagógicos explícitos.
O que ocorre é que alguns títulos não possuem uma temática adequada aos ambientes de aprendizagem.
Portanto espera- se ter contribuído nesta reflexão e que os jogos computadorizados sejam mais utilizados no âmbito escolar;
Para a ciência da computação, evidencia- se o potencial dos jogos computadorizados como uma área investigativa aplicada que demanda de conhecimentos avançados em computação e os conhecimentos oriundos do desenvolvimento deste tipo de aplicação podem ser utilizados em outros contextos.
Fundamentalmente este trabalhou baseou- se em princípios de engenharia de software e alguns princípios de informática na educação.
Além de estas suas derivações envolverão as áreas de inteligência artificial, computação gráfica, otimização algorítmica, linguagens de programação, banco de dados, entre inúmeras outras áreas da ciência da computação;
A camada de abstração do sistema (sal) é uma arquitetura que pode ser utilizada por qualquer aplicativo, mesmo que não esteja relacionado com jogos computadorizados, pois este pacote oferece uma abstração referente a a máquina virtual java.
Diversas extensões do sal podem ser usadas, inclusive versões otimizadas, em tempo de execução sem comprometer o restante da aplicação.
Quanto a os jogos, em geral as classes oferecidas por a sal são bastante utilizadas, logo otimizações efetuadas sob esta camada irão impactar sobre o desempenho de todos os jogos computadorizados e quaisquer extensões que foram desenvolvidas a partir de esta camada;
A formalização dos conceitos referentes à biblioteca, toolkit, engine e framework, destacando suas diferenças.
Partiu- se de um pressuposto que uma engine é uma aplicação completa que exige o mínimo de customizações e é capaz de executar uma série de jogos pertencentes a uma mesma família.
Muitos toolkits são erroneamente chamados de motores, pois toolkits não são aplicações são simplesmente objetos que podem ser usados num aplicativo;
Extensa documentação referente a o projeto do framework e conseqüentemente da estrutura dos motores de jogos.
Uma documentação detalhada auxilia os estudos e o entendimento dos novos usuários.
Espera- se que com este trabalho tenha proporcionando um embasamento sobre jogos computadorizados e como desenvolves- los do ponto de vista tecnológico referente sua estrutura geral.
Além disso, as reflexões sobre soluções de engenharia de software também são importantes no processo de aprendizagem e tal conhecimento poderá ser aplicado em outros projetos;
Uma solução inédita que procurou generalizar motores de jogos de forma que seu projeto também fosse estendido para diferentes plataformas, inclusive a móvel.
A maioria das soluções existentes procura abordar uma única plataforma e no caso de o sdl e do scummvm, que se preocupam em também prover soluções para diferentes plataformas, são uma biblioteca e um motor para jogos de aventura respectivamente.
Os frameworks existentes são modelados para uma única plataforma, ao contrário de o amphibian;
Por último é importante destacar que mesmo ocorrendo algumas dificuldades na execução do amphibian na plataforma móvel este trabalho estabelece uma forma padrão de projetar jogos computadorizados focado no domínio e nos objetos do jogo.
Assim mesmo considerando a eficiência da solução somente para computadores pessoais está sendo proposta uma forma de incrementar a reusabilidade, facilitar a manutenção do código e da aprendizagem dos desenvolvedores, desta forma agilizando o processo de desenvolvimento;
Referente a as limitações do framework proposto destaca- se o problema de desempenho na plataforma móvel.
Pode- se dizer que os jogos para esta plataforma usando o amphibian podem ser instalados e executados, entretanto ainda não são jogáveis, pois executam de uma forma não desejada, apresentando sério problema de desempenho, entretanto mostra potencial de alta portabilidade, pois os jogos para plataforma móvel tornam- se compatíveis com os computadores pessoais simplesmente alterando a especificação do motor de jogo.
Também a configuração do descritivo do jogo deve ser feita manualmente, ou seja, alterando diretamente o arquivo XML.
Para desenvolvedores isto não seria problema, tal processo torna- se problemático quando se considera a possibilidade dos próprios educadores configurarem seus próprios jogos.
Em este caso seria aconselhável criar uma aplicação gráfica que auxiliasse este processo de configuração.
Considerando o modelo do framework proposto e a implementação do protótipo pretende-se desenvolver os seguintes trabalhos futuros:
Otimizações dos pontos destacados na seção 4.8 principalmente quando se refere à plataforma móvel.
Além disso, seria interessante desenvolver uma camada sal usando métodos nativos para os pontos críticos de código.
Também quanto a a codificação do framework, alguns métodos poderiam ser otimizados simplesmente através de uma análise algoritmo visando reduzir sua complexidade sem necessitar implementas- los em código nativo;
Desenvolver um controlador de inteligência artificial integrando projetos desenvolvidos anteriormente por o autor, tais como um pacote para o uso de redes neurais artificiais (ANNeF), uma solução para o desenvolvimento de sistemas que usam lógica difusa (FuzzyF) e um simulador, denominado Gnu Mages, voltado para simulação de sistemas multi-agentes cooperativos e competitivos.
Desta forma espera- se oferecer suporte aos algoritmos de inteligência artificial aos jogos computadorizados usando alternativas já existentes;
A arquitetura interna atual do amphibian permite somente jogos computadorizados com um único jogador.
Uma futura extensão é desenvolver componentes nesta arquitetura que permitam a construção de aplicações distribuídas usando o modelo clienteservidor;
Gerenciador de janelas.
É fundamental que o motor consiga manipular janelas para capturar informações fornecidas por o jogador.
Devido a a portabilidade e o aspecto gráfico das janelas não seria recomendado o uso das classes padrão oferecidas por o Java.
Seria interessante desenvolver um gerenciador de janelas para o amphibian que permitisse modelar as janelas como objetos lógicos do jogo independente da forma que estas são desenhadas no dispositivo e do estilo gráfico.
Ou seja, este poderia ser alterado sem precisar mudar a implementação lógica das janelas, funcionaria como uma espécie de &quot;skin&quot;;
A SuperWaba além de executar sob o PalmOS, também executa em dispositivos que utilizam o Windows ce, portanto seria interessante executar testes do amphibian nos dispositivos com estes sistemas operacionais, principalmente para comparar o desempenho do framework em duas diferentes plataformas móveis.
Além disso, deveriam ser feito testes em dispositivos que oferecem mais recursos de memória e processamento.
Isto auxiliaria na verificação da questão quanto a o fraco desempenho do jogo da vida de John Conway no dispositivo móvel é em função de a falta de recursos computacionais ou é algum problema relacionado com o framework;
Efetuar a compatibilização do amphibian com o J2ME por o fato desta ser a solução oficial da sun quanto a a computação móvel.
Além de oferecer suporte para mais uma máquina virtual seria possível efetuar testes de execução do amphibian sob telefones celulares, pois o J2ME é amplamente utilizado para o desenvolvimento de aplicações para estes dispositivos;
Projetar novas visões de jogo.
O mecanismo de visualização 2D pode ser estendido para dar suporte à vista isométrica, conhecida como falso 3D e desenvolver o mecanismo de visualização 3D utilizando o mesmo conceito adotado por o mecanismo 2D de definir uma fábrica provedora de recursos com um objeto pintor associado, permitindo que estas fábricas utilizem diferentes recursos, tais como bibliotecas de terceiros.
Uma alternativa para o desenvolvimento do mecanismo de visualização 3D seria a adoção da opengl através do binding OGLJ;
Testes de qualidade do framework.
As questões referentes aos testes da arquitetura do framework e suas funcionalidades poderiam ser ampliadas e exploradas em maior profundidade em trabalhos mais detalhados.
Estes estudos permitiriam um constante incremento da qualidade e por conseqüência da confiabilidade da solução computacional proposta;
Estudo de novas formas de persistência dos dados, inclusive utilizando banco de dados e a possibilidade do estado dos objetos serem persistidos remotamente em banco de dados.
Estas funcionalidades seriam extremamente interessantes para a criação de mundos virtuais;
E por último, entretanto extremamente importante e que depende de alguns trabalhos citados anteriormente é o desenvolvimento do motor de jogo para RPGs computadorizados denominado Druida conforme foi visto na introdução.
Este motor permitirá o desenvolvimento de mundos virtuais com elementos dos RPGs.
É importante destacar que o desenvolvimento do Druida foi à motivação para a criação do amphibian.
Ou seja, o framework foi projetado especialmente para prover a estrutura computacional necessária para criar o Druida.
Por último, um aspecto importante para ser abordado é a relação do amphibian com os jogos computadorizados com propósitos educativos explícitos.
Se considerarmos os computadores pessoais e os resultados obtidos nos testes certamente uma grande quantidade de jogos didáticos poderiam ser construídos.
Os recursos atualmente oferecidos permitiriam desenvolver jogos simples, para um único usuário e usando gráficos 2D.
Apesar de os recursos modestos os jogos poderiam ser enriquecidos quanto sua lógica e seu enredo.
Lembrando que está infra-estrutura é oferecida gratuitamente e distribuída livremente para comunidade.
Considerando principalmente o âmbito acadêmico quando novos jogos didáticos são projetados, parte destes projetos destina- se a criação desta infra-estrutura mínima.
Com o amphibian esta parte infraestrutural pode ser abstraída e o foco do trabalho passa a considerar questões mais sofisticadas, desta forma existindo um melhor aproveitamento do tempo e por conseqüência jogos mais sofisticados.
Portanto espera- se que novos jogos computadorizados sejam desenvolvidos, principalmente no âmbito acadêmico, para serem utilizados em ambientes de aprendizagem.
Tendo em vista esta popularização dos jogos computadorizados desenvolvidos com qualidade técnica e preocupações referentes ao processo de ensino-aprendizagem acredita- se que os jovens estarão sendo oportunizados a desenvolver suas habilidades de aprendizagem, tornando- se mais criativos, autônomos e resolvedores de problemas.
Em este sentindo amplia- se à responsabilidade da ciência da computação como provedora de soluções computacionais que sejam capazes de promover o desenvolvimento destas habilidades, desta forma auxiliando no processo de transformação social.
Quando se considera a ciência como uma fonte única de produção de conhecimentos compreendese que cada área desta ciência pode colaborar entre si produzindo artefatos ricos baseados nas transdisciplinaridade, onde cada cientista tem suas habilidades potencializadas ao interagir com outros de outras áreas do conhecimento.
Isto pode ser considerado em relação a o papel da ciência da computação com as ciências da educação que juntas poderão prover excelentes soluções, em equilíbrio com os conhecimentos de ambas ciências.
Em esta perspectiva, o amphibian inicialmente é fortemente arraigado aos princípios e conhecimentos que norteiam a Ciência da Computação, mas progressivamente irá integrando- se com projetos educacionais desta forma sendo criados novos motores de jogos computadorizados que atendam as necessidades educativas e de aprendizagem.
Destacando que o amphibian provê funcionalidades e possibilidades de extensão para o desenvolvimento de jogos computadorizados no mesmo nível dos jogos computadorizados comerciais, assim os jogos criados para serem usados em ambientes de aprendizagem não seriam prejudicados do ponto de vista tecnológico.
Como o trabalho dos pesquisadores essencialmente baseia- se em utopias esperase que o amphibian seja o princípio de uma série de trabalhos científicos sobre a ampla exploração de jogos computadorizados no âmbito escolar, permitindo que futuramente os sistemas educacionais sejam menos tediosos e ultrapassados e que permitam que os novos aprendizes sejam capazes de aprenderem a aprender integrado numa sociedade da cibercultura.
Pretende-se dar continuidade em alguns destes trabalhos futuros, principalmente a implementação do Druida, em projetos de pesquisa, trabalhos de conclusão de curso de graduação e dependendo do nível de detalhamento até mesmo em dissertações de mestrado.
Além disso, possivelmente será dada a continuidade dos estudos sobre jogos computadorizados no processo de ensino-aprendizagem no contexto cibercultural, enfocando aspectos tecnológicos, num programa de doutoramento.
