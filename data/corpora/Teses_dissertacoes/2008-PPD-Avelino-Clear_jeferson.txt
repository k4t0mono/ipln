A complexidade de sistemas de software tem aumentado devido a os novos requisitos impostos por as aplicações modernas, tais como confiabilidade, segurança e disponibilidade.
Sistemas confiáveis são sistemas que mantém seu funcionamento de acordo com sua especificação mesmo na presença de situações excepcionais.
Em a tentativa de implementar sistemas mais robustos e confiáveis, torna- se imprescindível a utilização de mecanismos capazes de lidar com problemas que potencialmente possam afetar seu perfeito funcionamento.
Variados tipos de defeitos e situações inesperadas podem ocorrer em aplicações que rodam sobre sistemas distribuídos.
Para que seja atingido um grau satisfatório de utilização destes sistemas é extremamente importante que sejam utilizadas técnicas objetivando coibir ou minimizar a existência de falhas.
Tolerância a Falhas é uma técnica que tem por objetivo oferecer alternativas que permitam ao sistema manter o funcionamento conforme sua especificação, mesmo na ocorrência de situações indesejadas.
A literatura descreve diversos tipos de mecanismos que auxiliam no desenvolvimento de aplicações que possuem diversas atividades acontecendo simultaneamente.
Em geral, um mecanismo composto por diversos participantes (objetos ou processos) executando um conjunto de atividades paralelamente é chamado de interação multiparticipante.
Em uma interação multiparticipante diversos participantes de alguma maneira &quot;se unem «para produzir um estado combinado, intermediário e temporário e utilizam este estado para executar alguma atividade.
Após a atividade executada a interação é desfeita e então cada participante prossegue sua execução.
Entretanto, diversas vezes a interação entre os participantes pode levar a situações onde toda a execução tem que ser refeita (efeito dominó).
Para evitar este tipo de situação e para auxiliar no tratamento de exceções concorrentes que podem ocorrer nos diversos participantes de uma interação pode- se utilizar, por exemplo, o mecanismo de interações multiparticipantes confiáveis (Dependable Multiparty Interactions -- DMIs).
Este mecanismo tem sido utilizado para o desenvolvimento de aplicações em diversas áreas.
Todavia, percebemos que todos os estudos de casos desenvolvidos utilizando DMIs foram implementados manualmente, ou seja, sem a utilização de nenhuma ferramenta de apoio.
Tal situação além de acarretar um elevado tempo de desenvolvimento também facilita à inclusão de falhas no sistema.
Em esta dissertação apresentamos uma proposta de desenvolvimento de aplicações confiáveis que utilizam o mecanismo de DMIs.
Utilizando o Ide Eclipse desenvolvemos uma feramenta capaz de automatizar o processo de criação de aplicações que utilizam DMIs para tolerar falhas, proporcionando aos desenvolvedores ganho de produtividade, redução da possibilidade de inserção de falhas no código, assim como facilitar a compreensão dos elementos que compõem uma DMI e a maneira como os mesmos estão relacionados.
Com a expansão das redes de computadores, atividades envolvendo comunicação de computadores estão tornando- se cada vez mais distribuídas.
Tal distribuição pode incluir processamento, controle, gerenciamento de rede e segurança.
Embora a distribuição possa melhorar a confiabilidade de um sistema por replicar componentes, as vezes um aumento na distribuição pode introduzir falhas.
Em diversos ambientes a introdução de falhas ou e existência de falhas é inaceitável.
Por exemplo, sistemas onde a vida de pessoas podem estar em jogo (exemplo, Therac 25), ou mesmo onde recursos financeiros muito elevados foram aplicados (exemplo, Ariane 5).
Estes sistemas são em geral chamados sistemas confiáveis.
Sistemas confiáveis são sistemas que mantêm seu funcionamento de acordo com sua especificação mesmo na presença de situações excepcionais O comportamento deste sistema, mediante a ocorrência de situações inesperadas, é chamado de comportamento excepcional, ou comportamento anômalo, que define a forma como o sistema irá se comportar na tentativa de tratar situações excepcionais.
Visando o desenvolvimento de sistemas mais robustos e confiáveis são aplicadas algumas técnicas complementares que auxiliam neste processo, tais como:·
Previsão de falhas:
Tem por objetivo verificar através da utilização de modelos matemáticos a possibilidade ou probabilidade da existência de falhas que ainda não se manifestaram no sistema.·
Prevenção de falhas:
Tem por objetivo prevenir a ocorrência ou introdução de falhas, através da utilização de técnicas de programação e por implementações baseadas em linguagens de alto nível.·
Remoção de Falhas: Tem por objetivo minimizar o número ou a severidade das falhas, através de diversas técnicas de teste.
Em algumas situações é praticamente impossível evitar uma falha, como por exemplo, falhas em componentes físicos (hardware) deteriorados com o passar do tempo.
Desta forma, fazse necessário o emprego de técnicas de Tolerância a Falhas, que visam manter o sistema em funcionamento mesmo na presença de falhas.
Vale salientar que até mesmo para que tolerância a falhas possa ser empregada é importante que as falhas sejam antecipadas e suas conseqüências identificadas para que medidas apropriadas de tolerância a falhas possam ser empregadas para detectar sua ocorrência e manter o correto funcionamento do sistema.
Sistemas tolerantes a falhas diferem em relação a o seu modo de operação na presença de falhas e principalmente em relação a os tipos de falhas que devem ser toleradas.
Em alguns casos, o objetivo é continuar a proporcionar o desempenho e a capacidade funcional total do sistema, em outros o desempenho degradado e a capacidade funcional reduzida são aceitáveis, até a remoção da falha.
Os métodos de tolerância a falhas são realizados basicamente através de técnicas de tratamentos de erros e de falhas.
As técnicas de tratamento de erros destinam- se a eliminar- los se possível antes que ocorra um defeito.
O tratamento de falhas destina- se a evitar que falhas sejam reativadas.
De forma geral, procedimentos de manutenção ou reparo estão associados ao tratamento de falhas.
Para reduzir o risco de introdução de falhas em sistemas distribuídos é importante que tais sistemas sejam implementados de maneira organizada.
Uma maneira de organizar por exemplo, aplicações orientadas a objetos distribuídos é modelar operações que envolvem mais que um objeto como ações separadas que coordenam as interações necessárias entre os objetos participantes, facilitando a programação e utilização destes objetos.
Um mecanismo que inclui diversos participantes (objetos ou processos) executando um conjunto de atividades paralelamente é chamado de interação multiparticipante.
Em uma interação multiparticipante diversos participantes de alguma maneira &quot;se unem «para produzir um estado combinado, intermediário e temporário e utilizam este estado para executar alguma atividade.
Após a atividade executada a interação é desfeita e então cada participante prossegue a execução normal.
Diversas vezes a interação entre os participantes pode levar a situações onde toda a execução tem que ser refeita, gerando o efeito dominó.
Para evitar este tipo de situação e para auxiliar no tratamento de exceções concorrentes que podem ocorrer nos diversos participantes de uma interação pode- se utilizar, por exemplo, o mecanismo de interações multiparticipantes confiáveis (Dependable Multiparty Interactions -- DMIs).
Este mecanismo tem sido utilizado para o desenvolvimento de diversos estudos de caso.
Entretanto, todos os estudos de casos desenvolvidos utilizando DMIs foram implementados de maneira manual, ou seja, sem a utilização de ferramenta de apoio.
Tal situação além de acarretar um elevado tempo de desenvolvimento também facilita à inclusão de falhas no sistema.
Este problema poderia ser reduzido com a utilização de algum ambiente para geração automática de código.
Atualmente existem diversos ambientes para automatizar o processo de desenvolvimento de software.
Um exemplo que pode ser mencionado é o Eclipse.
O Eclipse é um projeto de código aberto que fornece muitos dos principais benefícios de ambientes de desenvolvimento comerciais, tais como JCreator ou JetBrains.
Além de ser um ambiente disponível para toda a comunidade de maneira aberta, o Eclipse também fornece a possibilidade de extensibilidade através do desenvolvimento ou customização de plug-ins.
Atualmente existe uma enorme variedade de plug-ins (gratuitos e comerciais) desenvolvidos para atender a diversos fins do conhecimento humano.
Percebemos que existe uma enorme carência de ferramentas (plug-ins) relacionados a atividades de desenvolvimento de aplicações tolerantes a falhas.
Esta dissertação apresenta uma forma de facilitar o desenvolvimento de aplicações tolerante a falhas que utilizem o mecanismo DMI.
A proposta se baseia na possibilidade de utilizar ambientes de desenvolvimento de software e incluir nos mesmos a possibilidade de utilização de mecanismos que tratam de falhas.
Como forma de demonstrar esta possiblidade, apresentamos um plug-in desenvolvido sobre o ambiente PDE (Plug-in Development Environment) do Eclipse que tem por objetivo automatizar o processo de criação de aplicações que utilizam o mecanismo de interações multiparticipantes confiáveis para tolerar falhas.
A utilização deste plug-in acarreta uma série de benefícios aos desenvolvedores.
Podemos destacar a possibilidade de ganho de produtividade, visto que parte do código para criação de DMIs passa a ser automatizado;
A redução da possibilidade de inserção de falhas no código responsável por a criação de DMIs, visto que código é gerado automaticamente;
Compreensão dos elementos que compõem uma DMI e a maneira como os mesmos estão relacionados.
Essa dissertação está organizada da seguinte forma.
O Capítulo 2 apresenta o conceito de Interações Multiparticipantes Confiáveis (DMI).
São descritos todos os componentes que compõem uma DMI, assim como a descrição de um framework para implementação de aplicações que utilizam DMIs.
Por fim, são apresentados alguns trabalhos implementados utilizando DMIs para tolerar falhas.
O Capítulo 3 apresenta os principais componentes que compõem o Eclipse (arquitetura);
Detalha os ambientes da plataforma;
Apresenta o conceito de plug-ins no Eclipse;
Existe uma enorme variedade de linguagens de programação disponíveis para projetar e implementar sistemas computacionais.
Estes sistemas podem conter diversas interações multiparticipantes durante sua execução, e usualmente tais interações são dispersas no código do sistema.
Em este capítulo apresentaremos uma forma de implementar DMIs utilzando linguagens orientadas a objetos.
Conforme mencionado no Capítulo 1, um mecanismo composto por múltiplos participantes (objetos ou processos) e que executam atividades em paralelo é chamado de interação multiparticipante.
Em interações multiparticipantes, diversos participantes de alguma maneira &quot;se unem «para produzir um estado combinado, intermediário e temporário, e utilizam este estado para executar alguma atividade.
Após a atividade executada a interação é desfeita e então cada participante prossegue sua execução individual.
Interações multiparticipantes que tratam de problemas que podem ocorrer durante sua execução devem prover algumas propriedades básicas.
As principais propriedades para a interação multiparticipantes desta categoria são:·
sincronização dos participantes da interação1;·
utilização de uma condição para verificar as pré-condições para executar a interação;·
confirmação após finalizar a interação, para garantir que um conjunto de pós-condições foi satisfeito por a execução da interação;·
atomicidade dos dados externos para assegurar que os resultados intermediários não sejam passados para outros processos antes que a interação acabe.
Geralmente, há também uma discussão sobre o uso do estado temporário por os participantes da interação, a maneira como a interação é dividida (geralmente a interação é dividida em mais de uma parte, e cada uma destas partes é chamada de uma parte da interação), ou a forma como o número de participantes é especificado na interação.
Geralmente não são esperadas falhas durante a execução de um programa, porém as mesmas existem e são rotineiramente tratadas por os programadores como exceções.
Para assegurar o tratamento de exceções que podem ocorrer durante a execução de um programa, um mecanismo de tratamento de exceções é usualmente desenvolvido.
Este mecanismo permite que Poderia- se- utilizar uma estratégia mais otimista, liberando os participantes para iniciar a interação mesmo que diversos não tenham chegado, mas esta situação poderia trazer um custo muito alto para manter o estado de todos os possíveis participantes para uma eventual recuperação.
O termo Interação Multiparticipante Confiável (Dependable Multiparty Interaction) é utilizado para Interações Multiparticipantes que provêm facilidades para a manipulação de exceções, em particular incluindo meios de:·
Manipulação de Exceções Concorrentes:
Quando uma exceção ocorre num dos participantes, e se não for tratada por esse participante, a exceção deve ser propagada a todos os participantes.
Uma DMI também deve prover uma maneira de tratar as exceções que podem ser geradas por um ou mais participantes.
Finalmente, se diversos tipos de exceções são gerados simultaneamente, então o mecanismo DMI utiliza um processo de resolução de exceção para decidir qual exceção será repassada para todos os participantes.
Com respeito a como os participantes de uma DMI serão envolvidos na resolução e manipulação de exceções, foram propostos dois possíveis esquemas:
Síncrono ou assíncrono.
Em o esquema síncrono cada participante deve ter terminado sua atividade e estar pronto para tratar a excessão.
Em o esquema assíncrono os participantes não esperam até finalizarem suas execuções ou gerarem uma exceção para participar da manipulação de exceção, uma vez que uma exceção é gerada em vários participantes do DMI, todos os outros participantes são interrompidos e tratam as exceções geradas juntos.
Embora a implementação de esquemas síncronos ser mais fácil que a implementação de esquemas assíncronos, uma vez que todos os participantes estão prontos para executar a manipulação de exceções, o esquema síncrono pode trazer o indesejável risco de deadlock.·
Sincronização na Saída:
Todos os participantes têm que esperar até que as interações acabem completamente.
Um participante somente pode deixar a interação quando todos terminaram seus papéis e os objetos externos estiverem num estado consistente.
Esta propriedade garante que se aconteceu algo de errado na atividade executada por um dos participantes, então todos os participantes podem tentar recuperar os erros possíveis2.
A idéia principal para manipulação de exceções é construir uma DMI a partir de uma corrente de Interações Multiparticipantes onde cada elo é o tratador de exceções do elo anterior.
A Figura 1 mostra como uma interação multiparticipante básica e interações multiparticipantes que tratam exceções (exception handling) são encadeadas para formar uma interação multiparticipante composta, de fato o que denomina- se uma DMI.
Como mostrado na figura, a interação multiparticipante pode acabar normalmente;
Gerando exceções que são tratadas por interações multiparticipantes;
Ou gerando exceções que não são tratadas na DMI.
Se a interação multiparticipante acabar normalmente, o fluxo de controle é passado para os chamadores da DMI.
Se uma exceção é gerada, então há dois caminhos possíveis de execução a serem seguidos:
Situação similar ao que foi descrito para a sincronização na entrada.·
se houver uma manipulação da exceção da interação multiparticipante para tratar esta exceção, então é ativado para todos os papéis da DMI;·
se não houver tratamento de exceção, então esta exceção é sinalizada para os invocadores da DMI.
O conjunto composto por a interação multiparticipante básica, e por os tratadores de exceções da interação multiparticipante são representados como uma entidade composta de interações multiparticipantes.
As exceções que são geradas por a interação multiparticipante básica ou por o tratador, devem ser as mesmas para todos os participantes da DMI.
Se diversos participantes gerarem diferentes exceções concorrentes, o mecanismo DMI ativa um algoritmo de resolução de exceções baseado em para decidir qual exceção comum deve ser tratada.
Implementação de DMI.
DMIs podem ser implementadas de diversas maneiras.
Em esta seção nós discutimos uma alternativa para fornecer uma implementação distribuída de DMIs em linguagens orientadas a objetos.
Primeiramente, os diversos componentes que podem ser usados para implementar uma DMI são descritos.
Basicamente, uma DMI é composta por:·
Gerente (Manager):
Um componente (ou mais) utilizado para controlar todos os protocolos dentro de a DMI, tais como:
Pré e pós-sincronização de participantes que participam da DMI;
Manipulação de exceções entre os processos;
Manutenção do controle interno e externo de dados para a DMI;
Etc.· Papéis (roles):
Diversos segmentos de códigos de aplicação, cada um de eles é executado por um participante da DMI;·
Dados externos:
Dados que são externos à DMI.
Este tipo de dado pode ser acessado de maneira competitiva por alguém que não está participando da DMI.
Um controle de acesso especial é requerido (em geral um sistema de transações);·
Dados locais:
Dados que são locais à DMI.
Participantes que não estão executando um papel (role) na DMI não têm acesso a estes dados.
Estes objetos, em geral, são utilizados por os participantes para troca de informação ou para sincronização.
Em linguagens orientadas a objetos, diversas possibilidades de implementar gerentes e papéis podem ser projetadas, por exemplo, papéis como objetos separados ou como funções de um objeto gerente.
Dados locais e dados externos são representados como objetos.
Uma maior descrição pode ser visto em.
Framework para implementação de DMIs.
Em o início do Capítulo 2 mostramos como componentes poderiam ser lincados para implementar DMIs.
Em esta seção um framework genérico orientado a objetos para implementar DMIs é descrito.
O framework proposto é composto por quatro tipos de objetos:
Papéis, gerentes, objetos compartilhados e objetos externos.
Cada um dos objetos descritos pode ser distribuído em diferentes locais.
Cada DMI é representado por vários conjuntos destes objetos remotos:
Um conjunto para interações quando não houver nenhuma falha, i.
e interação básica, e vários conjuntos para tratar as exceções que possam ser geradas durante a execução da interação (durante a interação básica ou durante uma interação da manipulação de exceção).
Objetos externos são associados com ambos gerentes e papéis.
Os gerentes manterão estes objetos para possível processo de recuperação.
Como mostrado na figura, não há nenhuma classe para representar uma interação multiparticipante básica ou uma DMI.
Uma DMI pode ser construída usando uma seqüência de passos de programação para relacionar os componentes quando forem instanciados (criados).
Este processo conforme já mencionado pode inserir falhas no desenvolvimento do sistema.
Este é o aspecto que resolvemos neste trabalho conforme será descrito no Capítulo 4.
Para programar uma nova DMI, utilizando o framework, o primeiro passo é definir uma nova classe que extenda a classe Role para cada parte da interação.
A classe estendida de Role deve redefinir ao menos um método:
O método body.
Este método conterá um conjunto de operações que será executado por o participante ativo do papel.
Em o momento da criação de cada papel deve ser informado o gerente que estará gerenciando este papel.
Um gerente que controla um objeto Role é uma instância de uma classe Manager.
A classe Manager fornece uma base para coordenar os participantes numa interação multiparticipante.
A separação do gerente dos papéis permite que o código da aplicação do papel possa ser distribuído para um local diferente do gerente.
Esta estratégia ajudará a evitar sobrecarga de um local com o controle da DMI e o código da aplicação.
Os gerentes de todos os papéis irão compor o controle da interação.
Cada gerente no momento da criação é informado de qual gerente vai atuar como líder na interação.
O líder é responsável por controlar protocolos de sincronização entre gerentes, para o algoritmo de resolução de exceção, e para manter- se informado sobre os objetos locais compartilhados.
Todos os gerentes são um potencial líder no framework, evitando a possibilidade de ponto único de falha.
A classe Manager é a principal classe do framework.
Cada papel tem que ser controlado por um gerente diferente.
Quando instanciar um objeto Manager, o gerente tem que ser informado de seu nome, o nome da interação, o líder da interação (um gerente sem um líder é seu próprio líder) e uma lista de exceções que será tratada por o gerente.
Cada exceção na lista é associada com um papel para manipular exceções de interações.
A lista de exceções anexada para os gerentes é a ligação entre as interações multiparticipantes de uma DMI.
Exceções que são geradas em interações multiparticipantes, e que não são tratadas, são propagadas.
Existem 3 maneiras para criar um objeto Manager:
Criando um objeto Manager líder que trata exceções;
Criando um objeto Manager que trata exceções e é controlado por um líder;
Ou, criando um objeto Manager que não suporta exceções e é controlado por um líder.
A Figura 3 mostra dois gerentes que foram criados para uma mesma DMI.
A tabela eh1 contém a lista de exceções que são tratadas por o mgr1 e os papéis que são ativados no caso de uma das exceções contidas na lista ser levantada.
Todas tabelas com exceções devem conter a mesma lista de exceções a serem tratadas numa mesma DMI.
Se as tabelas não contiverem a mesma lista de exceções, então uma exceção é levantada em tempo de criação.
Depois que um novo objeto Manager foi criado, o programador da interação multiparticipante tem que criar um objeto Role que será controlado por este gerente.
Este objeto Role tem que ser uma instância de uma nova classe Role derivada de uma classe Role fornecida por o framework.
Cada nova classe derivada de Role contém o código principal para um dos papéis que compõem a interação multiparticipante.
Somente objetos cujos tipos derivam do objeto Role podem pertencer a uma interação multiparticipante.
Quando derivar uma nova classe para a classe Role o programador deve implementar ao menos um método:
O método body, o qual conterá o código da aplicação principal para este papel.
Este método não retorna nenhum valor.
Ele recebe uma lista de objetos externos como parâmetro.
Se uma exceção é originada dentro deste papel, então esta exceção pode ser tratada localmente por o papel, se esta exceção não afetar outros papéis.
Se a exceção gerada tiver algum efeito nos outros papéis, deve ser repassada para o gerente deste papel, que notificará o líder e irá interromper todos os papéis da DMI.
Depois que todos os papéis forem interrompidos o líder resolve qual exceção será tratada por todos.
Extensões de classe Role são também responsáveis por declarar objetos locais compartilhados usados para coordenar os papéis dentro de uma interação particular, e para verificar partes das pré e pós-condições da interação.
Depois que os objetos locais compartilhados foram criados, o papel deve informar seu gerente sobre estes objetos, usando o método sharedObject.
Este método publica os objetos locais compartilhados para que outros papéis nesta interação possam usar- los mais tarde.
As pré e pós-condições de uma interação também podem ser verificadas de uma maneira distribuída;
Cada papel verifica parte das condições, ou um papel pode ser delegado para verificar todas as pré e pós-condições da interação.
A delegação pode ser conseguida utilizando objetos locais compartilhados entre os papéis.
Os métodos em que os testes de pré e pós-condições são programados são chamados:
PreCondition e postCondition.
Este métodos podem ser refinados na nova classe Role.
Por padrão, a classe Manager fornece um mecanismo de resolução de exceções concorrentes interno, baseado em.
Este mecanismo trabalha da seguinte forma.
Quando um papel gera uma exceção, seu gerente correspondente é notificado desta exceção.
O gerente então informa o líder que interrompe todos os papéis que não geraram exceções.
Depois que todos os papéis foram interrompidos ou notificaram o gerente do líder sobre uma exceção (exceções podem ser geradas concorrentemente), um algoritmo de resolução de exceções é executado por o líder.
Este algoritmo tenta encontrar uma exceção comum para todas as exceções levantadas.
Quando uma exceção comum é encontrada, o líder informa todos os gerentes sobre a exceção e um manipulador de exceções é ativado.
Se não houver nenhum tratador para esta exceção, um tratador para exceções de mais alto nível é ativado, i.
e classe Exception.
Se não houver nenhum tratador para a exceção, então a exceção é sinalizada para quem ativou a DMI.
Trabalhos Relacionados. Em esta seção são apresentados alguns trabalhos que foram implementados utilizando o mecanismo de Interação Multiparticipante Confiável para tolerar falhas.
Conforme poderá ser observado, DMIs podem ser utilizadas para tolerar falhas numa grande variedade de sistemas, desde sistemas médicos até sistemas manufaturados.
A primeira seção mostra como DMIs podem ser utilizadas para desenvolver outro mecanismo, ações atômicas coordenadas (CAAs), que possuem requisitos mais restritivos que DMIs.
Este mecanismo (CAA) foi utilizado para o desenvolvimento das aplicações citadas neste capítulo.
DMIs foram desenvolvidas para serem aplicadas no desenvolvimento de sistemas confiáveis.
Entretando, em determinadas situações é necessário a adoção de formas mais restritas para a manipulação de exceções.
Ações Atômicas Coordenadas (Coordinated Atomic Actions -- CAA) são um exemplo destas abstrações.
Assim como DMIs, CAA é um mecanismo utilizado para coordenar interações multiparticipantes e garantir acesso consistente a objetos na presença de concorrência e falhas potenciais.
Pode ser considerado como uma disciplina de programação que proporciona facilidades para transações concorrentes e tratamento de exceções.
CAA envolvendo múltiplos papéis numa ação devem concordar sobre seu resultado que podem ser um de quatro possíveis:
Normal, exceção, abortar e falhar.
Uma CAA termina normalmente se for capaz de satisfazer suas pós-condições.
Se uma CAA não terminar normalmente, então cada papel deve sinalizar uma exceção para indicar o resultado.
Os papéis devem concordar sobre o resultado de forma que cada papel deve sinalizar a mesma exceção.
Se uma exceção é gerada durante a execução da CAA, é desencadeado um processo de tratamento de exceção.
Dependendo do sucesso, a CAA pode recuperar a partir de a exceção, pode terminar normalmente ou excepcionalmente.
Se a recuperação de erro não for possivel, a CAA pode tentar recuperar o estado dos objetos externos e sinalizar abortar.
Se a recuperação do estado for mal sucedida, então a CAA deve sinalizar um defeito.
Este aspecto diferência CAA de DMIs, ou seja, em DMIs seria possível continuar tratando exceções, enquanto que em CAA o processo de tratamento de exceções deve terminar (uma cadeia de exceções não é possível em CAA).
Assim como em DMIs, o aninhamento de CAA é permitido.
Ou seja, uma CAA pode ser composta por diversas CAA.
A Figura 4 mostra como o mecanismo de CAA é construído usando o mecanismo de interações multiparticipantes.
Em a figura, as caixas retangulares representam as interações multiparticipantes, as setas representam o fluxo de controle e a caixa maior representa o mecanismo CAA.
Como pode ser observado, CAA são implementados com três tipos de interações multiparticipantes:
Uma interação para a execução normal da CAA;
Um conjunto de tratadores de interações multiparticipantes para lidar com as exceções que podem ser geradas durante a execução normal da CAA;
E a interação que lida com o processo de recuperação da CAA.
Em este trabalho é descrito a implementação de um sistema de controle médico que requer um alto grau de confiabilidade.
O sistema é desenvolvido utilizando Ações Atômicas Coordenadas (CAA) implementadas com DMIs (conforme descrito na Seção 2.3.1).
O sistema baseia- se nas técnicas de injeção subcutânea de insulina envolvendo diferentes sensores afim de garantir a execução contínua do tratamento, assim como detectar defeitos.
O grande desafio a ser transposto foi desenvolver um sistema que mantém a entrega de insulina mesmo na presença de um grande número e variedade de falhas de hardware e software.
A implementação deste tipo de controle foi desenvolvida em Java utilizando uma extensão do framework para DMIs.
O objetivo deste trabalho é demonstrar como CAA podem ser utilizados para o desenvolvimento de sistemas médicos que requerem resiliência e alta diponibilidade.
O estudo de caso em questão demonstra como um sistema de controle para diabetes fornece insulina ao paciente.
A equipe médica define os parâmetros do tratamento e o sistema, sensores e bombas verificam o status do paciente e administram a insulina.
É de extrema importância para o bem estar do paciente que a aplicação opere 24 horas por dia sem nenhum tipo de interrupção.
O sistema de controle de diabetes faz uso de diferentes tipos de dispositivos, que combinam alta performance, baixo consumo de energia e comunicação sem fio, aumentando a inteligência dos sensores e atuadores.
A Figura 5 mostra os diferentes componentes presentes no cenário.
O principal componente deste cenário é o paciente que está recebendo o tratamento, e onde os dispositivos estão conectados (sensores e atuadores).
O médico deve definir os parâmetros do tratamento enquanto os dispositivos operam de acordo com o tratamento especificado que o paciente deve receber.
Esta informação será armazenada nos registros pessoais do paciente e serão consultadas por a aplicação.
Entretando, as facilidades para o médico alterar e consultar as informações sobre o tratamento devem ser projetadas para ser tolerante a falhas.
O último componente é a sala de emergência (Er), onde encarregados estão continuamente monitorando os sinais vitais dos pacientes.
Eles serão os primeiros a saber se existe algum problema com o tratamento que o paciente está recebendo.
As setas pontilhadas representam a conexão sem fio e mostram como os dispositivos são conectados com o dispositivo de processamento central.
O sistema de controle da bomba de insulina foi projetado com a utilização de 7 CAAs.
Estas CAAs foram projetadas utilizando aninhamento e composição.
Existe uma CAA que controla todo o sistema chamada CAA--Cycle.
Esta CAA é responsável por fazer a verificação dos níveis de insulina do paciente e dos sensores da bomba de insulina.
Esta atividade é executada por a CAA aninhada CAA--checking.
A CAA--checking por sua vez ativa uma CAA composta (CAA-sensors) que é responsável por a verificação dos sensores da bomba de insulina.
A CAA--Cycle também é reponsável por a administração de insulina ao paciente.
Esta atividade e de responsabilidade de outra CAA aninhada chamada CAA-executing.
A CAA-Executing por outro lado ativa uma CAA composta (CAA-actuators) que é responsável por o controle dos atuadores da bomba.
A Figura 6 demonstra todo este processo.
Esta célula de produção é baseada numa célula real para processamento de metais e foi para aplicações industriais.
Desde então, o estudo de caso em questão atraíu muito a atenção e já foi investigado por mais de 35 distintos grupos de pesquisadores.
O trabalho apresentado nesta seção, descreve um sistema para controle desta célula de produção.
Em este sistema é aplicado o conceito de CAA para desenvolver e implementar um sistema que tolere falhas.
O sistema é desenvolvido em dois níveis:
O primeiro nível incide na negociação com a sincronização de CAA, e o segundo nível lida com a interação entre os dispositivos.
Tanto a sincronização de CAA aninhadas como as interações de dispositivos são realizados dentro de CAA.
Tratamento de exceções e recuperação de erros são incorporados dentro de CAA afim de satisfazer os requisitos de tolerância a falhas.
O sistema de controle foi desenvolvido na linguagem Java e é utilizado para controlar um simulador gráfico.
O projeto desta Célula de Produção aborda requisitos de segurança, funcionalidade e desempenho.
O requisito de segurança é satisfeito com a adoção de CAA, enquanto os demais requisitos são garantidos dentro de as CAA através da programação de acesso aos dispositivos e sensores.
Esta programação pode ser realizada de diversas maneiras.
A Figura 7 mostra a CAA mais externa (Production Cell Ca action) e uma possível execução de diversas CAA aninhadas (UnloadTable, LoadTable, LoadPress, UnloadPress, ForgePlate, TransportPlate, UnloadDepositBelt).
Os diversos participantes (FeedBelt, Table, Robot, Press, DepositBelt, Crane) executam os papéis na CAA mais externa e depois ficam no interior desta executando as CAA aninhadas dependendo das pré-condições de cada CAA aninhada.
Por exemplo, para descarregar a mesa (UnloadTable) é necessário que exista uma peça de metal sobre a mesma e que o robô esteja livre.
Estas condições são informadas por os participantes via objetos compartilhados.
Em 1996, o FZI apresentou a especificação de uma versão extendida da célula de produção original, denominada &quot;Célula de Produção Tolerante a Falhas ou Célula de Produção II».
Este segundo modelo possui uma prensa adicional, sensores extras, e luzes nos sistemas de alerta que facilitam a detecção e tolerância a falhas.
Este sistema é muito mais complexo e realistíco que o primeiro modelo de Célula de Produção.
Diferente do primeiro modelo, falhas de componentes eletromecânicos e sensores em produção são a grande preocupação.
Em particular, a célula de produção tem por objetivo fornecer serviço continuamente mesmo que uma das suas duas prensas esteja fora de ordem.
O trabalho é baseado numa extensão do modelo de célula de produção, a especificação e simulação para o qual foram definidos por o FZI (Forschungszentrum Informatik, Germany).
Esta célula de produção tolerante a falhas representa o processo de fabricação envolvendo redundância de dispositivos mecânicos (garantindo a produção contínua mesmo na presença de falhas mecânicas).
O desafio proposto por o modelo especificado é desenvolver um sistema de controle capaz de manter seu funcionamento de acordo com sua especificação mesmo na pre-No modelo original, a Célula de Produção não dispunha de qualquer dispositivo ou sensor para verificar a ocorrência de defeitos.
Em tal hipótese foi utilizado o conceito de CAA para organizar e projetar um programa de controle, e posteriormente implementar- lo em Java.
O programa de controle desenvolvido foi então aplicado para o simulador.
Para a Célula de Produção Tolerante a Falhas a mesma estratégia foi aplicada, mas agora buscando satisfazer os requisitos de tolerância a falhas extendido.
Assim como no sistema para a primeira Célula de Produção, CAA são aplicadas sempre que ocorre alguma interação entre os dispositivos.
Por exemplo, quando uma peça vai passar da mesa para o robô os controladores do robô e da mesa executam uma CAA chamada UnloadTable.
Esta mesma estratégia é utilizada quando a peça é colocada ou removida das prensas, colocada na esteira de alimentação, e assim por diante.
A Figura 8 apresenta o conjunto de dispositivos e também o conjunto de CAA utilizadas para controlar a célula.
Sempre que dois retângulos, que representam CAA, intersectam, significa que duas CAA não irão executar paralelamente pois o participante de uma CAA também é participante de outra.
Este trabalho discute algumas das características típicas das aplicações Web modernas e analisa alguns problemas que os desenvolvedores enfrentam na concepção deste tipo de sistema.
Para esta aplicação Web diversos serviços Web independentes são integrados.
A integração destes serviços independentes pode envolver interações que podem ser bastante complexas em atividades concorrentes.
O conceito de CAA é utilizado para estruturar estas atividades e para fornecer tolerância a falhas utilizando tratamento de exceções.
O trabalho detalha importantes decisões de projeto, implementações adotadas no desenvolvimento do estudo de caso referente a uma Agência de Viagens e o esforço para permitir que CAA fossem facilmente aplicadas para a construção de aplicações Web seguras que integram diversos serviços Web que um usuário pode desejar acessar.
O sistema é composto por duas partes:
Um lado servidor e um lado cliente.
O lado do cliente é executado na máquina do usuário e coleta as informações fornecidas por o usuário.
Estas informações são enviadas para o sevidor que é responsável por a ativação de sistemas legados.
A execução de todo o sistema é estruturado através de CAA's, e todas as informações trocadas entre o cliente e o servidor são realizadas dentro de CAA através de objetos locais.
Assim, toda vez que um cliente conecta ao sistema de agência de viagens uma CAA é iniciada no lado do servidor.
Esta ação é chamada de sessão.
A CAA sessão é composta por duas sessões aninhadas.
Uma para verificar a disponibilidade dos serviços solicitados por o cliente, e outra para fazer a reserva propriamente dito.
Dentro de a CAA para verificar a disponibilidade existe uma ação aninhada para consultar os servicos legados.
Cada servico legado é verificado por uma CAA composta, por exemplo uma CAA que possui diversos papéis, um para cada companhia outro para verificar a disponibilidade de vôos.
O Eclipse é composto por uma plataforma totalmente modular, baseada em plug-ins, que foi projetada para fornecer integração confiável e robusta no desenvolvimento de aplicações para diferentes sistemas operacionais.
É atualmente um dos Ides (Integrated Development Environment) mais polulares para desenvolvimento em plataforma Java e considerado uma das principais iniciativas Open-Source.
O Eclipse foi um projeto inicialmente desenvolvido por a IBM, que posteriormente foi doado para a Fundação Eclipse.
O projeto ganhou popularidade e força rapidamente na comunidade de desenvolvedores Java por diversos motivos:·
Ser software gratuito, livre (free software) e de código aberto (open source).·
Oferecer amplos e inovadores recursos de produtividade (plug-ins).·
Consistir num projeto sério e ativo, bem organizado e coordenado, além de o amplo apoio da comunidade e de grandes empresas e instituições.·
Ter ambiente gráfico construído com a biblioteca de componentes SWT (Standard Widget Toolkit) própria do projeto Eclipse, combinando grande riqueza de componentes gráficos e interface de usuário com desempenho e leveza.·
Possuir uma arquitetura de software aberta e extensível, permitindo que plug-ins sejam criados e facilmente integrados ao mesmo.
Para pesquisadores e educadores o Eclipse oferece um valor significativo:
Uma infra-estrutura para condução de pesquisas e desenvolvimento curricular em muitas áreas da computação, com relevância particular em linguagem de programação, ferramentas de desenvolvimento e colaboração.
Arquitetura da Plataforma.
Mais do que apenas uma ide (Integrated Development Environment), o Eclipse é basicamente uma plataforma de integração de sistemas, visto que fornece potencialidades não só para desenvolver produtos, mas para criar ferramentas para construir produtos.
Estas ferramentas (plug-ins) são pacotes estruturados de códigos que atribuem funções ao sistema, estendendo as funcionalidades do Eclipse e ilustrando o maior diferencial desta plataforma, a possibilidade de expansão.
A característica de expansão permite ao Eclipse integrar novas funcionalidades para diferentes fabricantes de software, enquanto também assegura um ambiente de coesão.
A plataforma de execução é a única parte do Eclipse que não é um plug-in, e é responsável por carregar o sistema base e descobrir dinamicamente os plug-ins básicos necessários ao Eclipse.
A plataforma de execução mantém um registro referente a os plug-ins instalados, assim como a função que eles fornecem.
Novas funcionalidades são adicionadas ao sistema através de um modelo comum de extensão, denominado pontos de extensão.
Pontos de extensão são basicamente implementados em Java, através da utilização de Apis (Application Programming Interface) disponibilizadas por a plataforma, entretando, alguns pontos de extensão são implementados sobre componentes ActiveX, ou em linguagens baseadas em script.
A plataforma do Eclipse incorpora o conceito de workspace, que refere- se a um diretório mantido localmente na própria estação do desenvolvedor onde estão armazenadas informações referentes ao projeto em desenvolvimento, assim como também define uma API para criar e gerenciar recursos, tais como identificar, notificar e manter o histórico de mudanças.
Este paradigma auxilia o processo de desenvolvimento visto que todas informações referentes a um determinado projeto estão contidas num diretório comum, e sempre que são criados novos projetos as informações referentes a tais projetos são mapeadas para subdiretórios dentro de o diretório workspace.
O uso do workspace local permite a colaboração muito mais eficiente de uma equipe através dos repositórios que podem ser disponibilizados na Internet ou numa rede corporativa.
O workbench é a interface do Eclipse com o usuário.
É através de ele que o desenvolvedor interage com o sistema, seja para compilar um projeto, para fazer o teste de um plug-in ou apenas para visualizar as propriedades de determinado arquivo.
Ele é formado por uma série de componentes, sendo a maioria de eles de interface gráfica do usuário (GUI) com ações associadas.
Esses componentes se classificam basicamente em perspectivas, visões e editores.·
Perspectiva -- Uma perspectiva controla a visibilidade inicial da visão, a visibilidade da ação e o leiaute inicial das visões e editores da janela do workbench.
Um workbench pode ter uma ou mais perspectivas, porém apenas uma é apresentada ao usuário de cada vez.
Cada perspectiva tem seu próprio conjunto de vistas, porém o conjunto de editores é compartilhado entre todas elas.
As perspectivas controlam o que aparece em certos menus e barras de ferramentas, além de definirem os conjuntos de ações (action sets) visíveis, que podem ser alterados para personalizar a perspectiva.
Uma perspectiva alterada pode ser armazenada para ser aberta posteriormente.
Cada perspectiva oferece um conjunto de funcionalidades para realizar um tipo de tarefa ou para trabalhar com um tipo específico de recurso.·
Visões -- Uma visão (view) é um componente de interface gráfica dentro de o workbench.
Ela é tipicamente utilizada para navegar numa hierarquia de informações (como um sistema de arquivos), abrir um editor ou mostrar propriedades para um editor ativo.
Modificações feitas numa visão (como alteração de parâmetros) são salvas imediatamente.
As visões também têm seus próprios menus e suas barras de ferramentas, que afetam apenas os ítens encontrados dentro de a respectiva visão.
Elas podem aparecer sozinhas ou agrupadas em forma de guias (tabs).·
Editores -- Um editor também é um componente visual no workbench.
Ele é utilizado para abrir, editar, salvar ou navegar através de recurso.
Modificações feitas num editor só são salvas quando o usuário decidir, diferentemente das vistas.
Um editor pode estar associado com diferentes tipos de arquivos.
Se não há um editor associado com o determinado tipo de arquivo dentro de a plataforma, é possível abrir um editor externo, fora de o workbench.
Vários recursos podem ser abertos para edição ao mesmo tempo, porém só um pode ser visualizado por vez.
Guias na área do editor indicam os nomes dos recursos abertos.
Um asterisco junto ao nome do recurso mostra que existem informações não salvas.
O workbench fornece uma completa estrutura que disponibiliza elementos necessários que constituem a interface entre o desenvolvedor e a plataforma.
O workbench é a principal janela para todas as funcionalidades que os plug-ins podem fornecer.
Através de ele é possível navegar em projetos, pastas e arquivos, visualizar e editar o conteúdo e propriedades destes recursos, assim como adicionar pontos de extensão a interface.
De o ponto de vista do desenvolvedor, uma aplicação é composta por editores, visões, e perspectivas que podem ser customizadas, possibilitando assim uma total liberdade para alterar a interface conforme sua necessidade/ vontade.
A API workbench é implementada usando ambos SWT e JFACE:·
SWT (Standard Widget Toolkit) é uma biblioteca de componentes para interface gráfica que disponibiliza à plataforma Eclipse funcionalidades nativas para componentes gráficos de modo independente de sistema operacional.
Provê um conjunto de componentes visuais, que engloba desde botões e listas, até componentes que adicionam ícones nas barras de tarefa do sistema operacional.
É análogo ao AWT/ Swing com uma diferença, o SWT usa um vasto conjunto de componentes nativos.·
JFACE é um conjunto de classes que serve como apoio para o desenvolvimento de aplicações SWT.
Durante a fase inicial do processo de desenvolvimento do Eclipse e do desenvolvimento do SWT, os desenvolvedores da plataforma perceberam que poderiam facilitar o uso do SWT com algumas novas funcionalidades, porém mantendo os componentes mais enxutos possíveis, então foi criado o JFACE.
Entre algumas das funcionalidades oferecidas por o JFACE estão a simplificação no controle de eventos.
Em determinados momentos durante o desenvolvimento de uma aplicação, o desenvolvedor possui vários componentes visuais diferentes (botões, menus, campos) que executam uma mesma lógica, tendo que replicar o mesmo código para vários componentes.
Usando JFACE basta criar uma ação e utilizar ela ao mesmo tempo em todos os componentes.
A implementação do servidor Web de ajuda é feita por o plug-in Help.
Através deste plug-in são definidos pontos de extensão que outros plug-ins podem utilizar para contribuir com ajuda ou outra documentação do plug-in, como livros online.
O servidor web de documentação inclui facilidades especiais para permitir que os plug-ins referenciem arquivos por uso lógico, URLs baseadas em plug-in em vez de o sistema de arquivos URLs.
O plug-in de suporte a grupo (Team) permite que outros plug-ins definam e registrem implementações para grupos de programação, acesso de repositório e controle de versões e recursos.
JDT e PDE.
O JDT (Java Development Tooling).
Extende o workbench da plataforma, disponibilizando um completo ambiente de desenvolvimento Java.
O ambiente fornece um conjunto de ferramentas que viabilizam uma maior produtividade no processo de desenvolvimento de uma aplicação, possibilitando a automatização de uma série de tarefas.
É composto por um conjunto de plugins nativos do Eclipse que auxiliam a visualizar, editar, compilar, depurar e rodar código Java.
Algumas das melhorias obtidas com a utilização do ambiente JDT são os editores com características que destacam a sintaxe e completam o código, assim como as janelas que possibilitam a visualização da estrutura do código.
Devido a enorme variedade/ diversidade de plug-ins disponíveis atualmente, desenvolvedores podem customizar seu ambiente de desenvolvimento de acordo com suas necessidade, automatizando/ acelerando uma série de tarefas.
A própria Fundação Eclipse é segmentada em projetos visando prover componentes estruturais ou ferramentas para várias destas finalidades.
Também existem muitos plug-ins gratuitos e comerciais para o Eclipse desenvolvidos por terceiros.
O PDE (Plug-in Development Environment) fornece ferramentas que automatizam a criação, manipulação, depuração e instalação dos plug-ins desenvolvidos.
Ele também é formado por uma série de plug-ins inseridos no Eclipse SDK (System Development Kit).
Plug-ins. Um plug-in é a menor unidade da plataforma funcional do Eclipse que pode ser desenvolvido separadamente.
Geralmente uma pequena ferramenta é implementada num simples plug-in, enquanto uma ferramenta mais complexa tem suas funcionalidades divididas sobre vários plug-ins.
Estruturalmente, todos os plug-ins estão localizados dentro de o diretório raiz do Eclipse.
Em este diretório existem diversos subdiretórios, cada um destes destinado a alocar plug-ins distintos.
Para evitar conflitos de versões, e também para definir um método de normatização, é definido que o nome de cada diretório deve ser a junção do nome do plug-in, precedido de sua versão.
A Figura 10 apresenta a estrutura básica dos plug-ins do Eclipse.·
plugin. Xml -- Arquivo de manifesto do plug-in onde estão contidas informações descritivas que são utilizadas por o Eclipse para integrar o plug-in com o Framework.
Em este arquivo são definidos as extensões, pontos de extensão, pontos abertos para extensão (se existir) e a (s) classe (s) Java que será (ão) invocada (s) para a disponibilização do plug-in.
O Eclipse disponibiliza uma ferramenta denominada Plug-in Manifest Editor que auxilia na criação e configuração deste arquivo.·
plugin. Properties -- Arquivo que contém informações de apoio ao plug-in.
Em a seção 4.1 será descrita a implementação de um plug-in onde este arquivo foi utilizado como base para a definição de mensagens textuais e como path para arquivos utilizados como template para geração de código.·
arquivos. Jar -- Código Java necessário para o plug-in;·
ícones, arquivos de documentação e demais arquivos de apoio necessários ao plug-in;
Sempre que o Eclipse é inicializado a plataforma de execução descobre dinamicamente todos os plug-ins disponíveis, e monta uma lista com tais registros.
Os plug-ins só são efetivamente ativados quando há requisições de suas funcionalidades (pontos de extensão são invoca- de os), desta forma, diminuindo o tempo de inicialização do Eclipse e a utilização em demasia de recursos de hardware, em especial memória RAM.
Atualmente não foi definido nenhum método capaz de descarregar plug-ins, porém existem projetos em andamento para possibilitar a carga e descarga de plug-ins sob demanda.
Este é um dos objetivos do projeto Equinox, que explora aproximações e tecnologias para aumentar a flexibilidade da plataforma de execução do Eclipse.
Plug-ins implementados no Eclipse.
O Eclipse é composto por uma plataforma totalmente modular, composta por diversos plugins.
Um destes plug-ins é denominado PDE (Plug-in Development Environment), através de ele é disponibilizado aos desenvolvedores de aplicações um ambiente totalmente voltado para a criação de novos plug-ins, ou a customização de plug-ins já existentes.
Esta seção apresenta alguns projetos (plug-ins) desenvolvidos sobre este ambiente, comprovando assim a importância e os benefícios obtidos com a adoção deste paradigma, tanto no meio acadêmico como no meio profissional.
Penumbra é um plug-in para o Eclipse desenvolvido na universidade de Purdue, com objetivo de facilitar o processo de aprendizagem de alunos do curso de Ciência da Computação aos conceitos de Programação.
Este plug-in possibilita simplificar o uso das funcionalidades do Eclipse, apresentando um ambiente simples, intuitivo e conseqüentemente mais produtivo.
A perspectiva do plug-in é bastante simples, e em ela estão contidos apenas os elementos necessários para introdução dos conceitos básicos de programação.
Como exemplo da simplificação do ambiente, podemos levar em consideração a alteração na maneira de executar uma aplicação, bastando um simples clique no botão do mouse.
A utilização do plug-in em classe evidenciou que os benefícios apresentados justificam o investimento de tempo e esforço para a capacitar os alunos, visto que as respostas obtidas foram muito positivas.
Os alunos uma vez familiarizados com a Ide conseguiram identificar e resolver de uma forma mais eficaz e rápida os problemas propostos na disciplina.
Outros plug-ins diretamente focados em assuntos pedagógicos de ambientes de programação, são BlueJ e GILD.
JIRiSS (Information Retrieval based for Java) é uma ferramenta de exploração de software que utiliza um mecanismo de indexação baseado num método da recuperação de informação.
JIRiSS é um melhoramento do plug-in Iriss que foi desenvolvido na paltaforma MS Visual Studio, com o objetivo de analisar códigos implementados em C+.
JIRiSS é implementado como um plug-in Eclipse e permite ao usuário pesquisar código fonte Java para a implementação de conceitos formulados através de consultas baseadas em linguagem natural.
Os resultados das consultas são apresentados através de uma espessa lista de métodos ou classes, ordenados por a similaridade da consulta do usuário.
JIRiSS também incorpora algumas características avançadas, tais como, pesquisas baseadas em fragmentos, verificação da ortografia das consultas executadas, sugestão de palavras para aprimorar a consulta e opções avançadas para customizar e indexar processos.
Existem diversas ferramentas capazes de suportar pesquisas, algumas de elas baseadas em plug-ins de diferentes Ides, de entre as quais detacam- se:
FEAT, que é um plug-in Eclipse que captura o conhecimento relacionado à implementação de código fonte.
Este plug-in suporta localização, descrição e análise de código relacionados ao código de implementação em Java, e Jripples, que é um plug-in Eclipse que suporta diferentes estágios de trocas incrementais e fornece aos programadores meios para a investigação e compreensão do programa, permitindo a visualização do software usando o grafo de dependência do programa.
O plug-in Sangam foi desenvolvido com objetivo de integrar pares de programadores remotamente distribuídos.
O plug-in possibilita que usuários da plataforma Eclipse localizados remotamente possam compartilhar a mesma área de trabalho (workspace), como se estivessem utilizando o mesmo computador ao mesmo tempo.
O plug-in fornece uma interface específica para pares de programadores distribuídos (Distributed Pair Program), e sincroniza o ambiente de desenvolvimento para ambos os programadores.
O plug-in é constantemente atualizado, e contempla algumas importantes funcionalidades, tais como:·
Sincronização do Editor: Isto inclui digitação, seleção, abertura, fechamento, e sincronização das visões.·
Sincronização de execução:
Os programadores podem rodar ou depurar a mesma aplicação Java ao mesmo tempo.
KenyaEclipse é um plug-in para o Eclipse que tem por objetivo auxiliar o processo de aprendizagem dos conceitos básicos de programação à estudantes iniciantes dos cursos da área de Ciências da Computação do Imperial London College.
Este plug-in possibilita aos estudantes a utilização de um ambiente Ide de produção, onde são diponibilizados diversos recursos que auxiliam no processo de aprendizagem e desenvolvimento de software, tais como, sugestões de melhorias no estilo de programação e vistas (janelas) que possibilitam uma visão mais clara do sistema como um todo.
A utilização do KenyaEclipse além de auxiliar o processo de aprendizagem também facilita a transição dos estudantes para qualquer outra linguagem de programação que utiliza ambientes similares, tal como Java.
Anteriormente ao desenvolvimento do plug-in KenyaEclipse as noções básicas de programação eram passadas aos estudantes do Colégio Imperial de Londres através da utilização da linguagem de programação Kenya.
Tal linguagem não oferecia aos estudantes muitos dos recursos disponíveis numa Ide.
Outros plug-ins desenvolvidos com o objetivo de auxiliar no processo de aprendizagem dos conceitos básicos de programação e que merecem ser mencionados são:
Penumbra, DrJava e Watcher.
Watcher é um plug-in desenvolvido para o Eclipse que tem como principal objetivo monitorar o comportamento dos programadores.
O plug-in rastreia comportamentos significantes como movimentos do mouse, movimentos da barra de rolagem e alterações no documento que ocorrem durante a sessão.
A ferramenta é composta por três componentes distintos, e a combinação destes componentes produz um detalhado conjunto de informações que pode ser utilizado para apontar áreas de desigualdade entre diferentes programadores e técnicas de programação.
O Watcher é inicializado em background sempre que o Eclipse é carregado.
Toda vez que este plug-in for invocado é automaticamente criado um arquivo xml que armazena todos os eventos gerados sobre a plataforma.
O programador não tem nenhuma interação direta com o plug-in, desta forma, assegurando- se a integridade das informações coletadas.
Após coletadas as informações, estas são repassadas para uma ferramenta denominada Xml2Excel, que recebe os dados coletados do plug-in Watcher, abstraí os dados considerados relevantes e converte estes dados para um formato Excel.
O terceiro e último componente da solução consiste da uma ferramenta denominada Watcher-Macros que consiste basicamente de macros desenvolvidos dentro de o próprio Excel, que possibilitam que os dados colhidos em etapas anteriores sejam expressos de forma gráfica.
O plug-in tem se mostrado bastante eficaz principalmente no meio acadêmico, uma vez que possibilita a identificação das áreas em que os estudantes estão tendo maiores dificuldades e conseqüentemente perdendo mais tempo, permitindo assim, que os professores possam explorar estas deficiências em sala de aula ou indicar material de apoio apropriado.
SpeechClipse é um plug-in para o Eclipse que possibilita que desenvolvedores de software possam efetuar várias outras tarefas ao mesmo tempo em que estão programando.
Este plug-in possibilita que sejam passados comandos para o Eclipse através de voz, sem que haja a necessidade de utilização de qualquer dispositivo de entrada, tais como mouse ou teclado.
Tal funcionalidade além de permitir um aumento de produtividade, também se mostra especialmente útil a desenvolvedores de software portadores de deficiências físicas.
O plug-in ainda precisa ser aprimorado, visto que é extremamente sensível a barulhos externos, acarretando a invocação de ações indesejadas na Ide.
Possíveis melhorias podem ser atingidas através da utilização de um dispositivo capaz de limitar determinados tipos de ruídos ou simplemente melhorar a gramática para ajudar a distinguir entre um comando válido ou inválido.
A configuração de hardware miníma requerida para que o plug-in opere de forma satisfatória é referente a um computador com processador Pentim III, com clock de 800 MHz e 512 MB de memória RAM.
A configuração ideal é um computador com processador Pentim 4 com 512 MB de memória RAM.
Algumas ferramentas utilizadas conjuntamente podem fornecer os requisitos necessários para dar suporte a estudantes remotamente distantes, fornecendo um ambiente de educação a distância colaborativa e um sistema de gerência de projeto de software.
Tais funcionalidades podem ser atingidas através da integração de duas ferramentas:
O Cure que consiste de uma plataforma de colaboração padrão e a solução de gerenciamento de projeto CodeBeamer.
O Cure foi integrado por um plug-in desenvolvido recentemente que possibilita a utilização de ferramentas como wiki, mail, chat com Eclipse.
Juntos com plug-ins adicionais, esta plataforma facilita o projeto de engenharia de software em todas as fases, e os estudantes poderão colaborar mais intensamente, gerenciar seus projetos mais facilmente e garantir software de alta qualidade.
A comunicação entre um grupo de desenvolvedores que compartilham um mesmo espaço físico é extremamente eficiente, visto a possibilidade de integração entre dos membros.
A troca de idéias e o compartilhamento de informações se dá de forma rápida, clara e ágil.
O plug-in Jazz tem por objetivo possibilitar que um pequeno número de desenvolvedores remotamente localizados, possam trabalhar conjuntamente de forma eficiente e produtiva.
O plug-in fornece ferramentas que auxiliam no processo de comunicação e coordenação entre os membros da equipe.
Estudantes que são forçados a aprender Java utilizando um editor de texto convencional e linhas de comando como interface de execução, apresentam uma enorme dificuldade em lidar com tais mecanismos, tornando o processo de aprendizagem mais lento e tortuoso.
Por esta razão muitos professores optam por a utilização de um ambiente de desenvolvimento integrado (Ide) para Java, afim de auxiliar seus alunos durante o processo de compreensão dos conceitos fundamentais de orientação a objetos e o desenvolvimento de programas.
DrJava fornece um ambiente mais simples, amigável, altamente interativo e totalmente focado no processo de ensinar Java para alunos iniciantes, amenizando os desafios envolvidos em utilizar uma Ide.
O plug-in consiste basicamente de duas janelas, uma onde é adicionado e editado o código do programa, e a outra onde são avaliadas as sentenças e expressões adicionadas.
Esta simples interface libera os estudantes da complicação de definição de métodos e os encoraja a conduzir simples experiências.
Conforme mencionado anteriormente, até o presente momento diversas aplicações já foram desenvolvidas com a utilização de DMIs.
Entretanto, o desenvolvimento de aplicações com DMIs podem ser suscetível a inserção de falhas durante a fase de programação, pois para o uso de DMIs o programador deve seguir uma sequência de passos sem margem para erros, por exemplo, se um dos gerentes passados por parâmetro durante a criação de um objeto Role for errado, o processo de sincronização no início da DMI entrará em deadlock, pois faltará um participante para sincronizar.
O mesmo vale para o momento da criação da tabela de exceções utilizada para o tratamento de exceções.
Se uma entrada da tabela estiver equivocada, todo o processo de tratamento de exceções poderá gerar problemas.
Diversas outras situações poderiam ser citadas.
Situação semelhante acontece em relação a o desenvolvimento de expansões para o Eclipse, uma vez que diversos plug-ins já foram desenvolvidos para diversas áreas, mas até onde sabemos nenhum trabalha com a possibilidade de desenvolver aplicações tolerante a falhas que utilizem mecanismos como DMIs, bloco de recuperações ou programação n-versões, por exemplo.
Desta forma a idéia principal deste capítulo é a união da possibilidade de desenvolvimento de aplicações tolerante a falhas com uma maneira automatizada de fazer- lo num ambiente que auxilie o desenvolvimento de software.
O sistema que será descrito neste capítulo é composto da implementação de um plug-in para o Eclipse que será responsável por a leitura da descrição de todas as DMIs a serem instanciadas para o framework apresentado na Seção 2.2.
A descrição das DMIs mais o código que utiliza estas DMIs formarão o código completo da aplicação tolerante a falhas.
O plug-in é invocado através de um ponto de extensão adicionado na barra de ferramentas do Eclipse (conforme será descrito na Seção 4.2).
A partir de então é disponibilizada uma interface gráfica onde é possível definir quais componentes serão criados e de que maneira os mesmos estarão relacionados.
A interface gráfica eliminará toda a parte de instanciação de objetos e mesmo exceções e suas relações no momento da criação dos objetos.
O código inserido nas classes é oriundo das informações adicionadas na interface gráfica do plug-in, associadas a arquivos de templates criados num editor de texto convencional (formato txt) e estruturados de acordo com a linguagem de templates denominada Velocity.
O plug-in DMI foi implementado utilizando a linguagem de programação Java.
A escolha foi motivada por dois fatores:
Esta linguagem é largamente utilizada por desenvolvedores de plug-ins, assim como é a mesma linguagem utilizada para o desenvolvimento do framework conforme descrito no Capítulo 2.
Implementação. Conforme descrito no Capítulo 3, o Eclipse é um sistema composto por uma enorme variedade de plug-ins, onde cada um destes plug-ins contribuem de uma maneira distinta com o ambiente.
Alguns plug-ins disponibilizam funcionalidades relacionadas à implementação de interfaces com usuário, outros fornecem suporte para gerenciar os recursos do sistema, e assim por diante.
Em o desenvolvimento do plug-in DMI foi necessário a utilização de seis plug-ins.
Entretanto, o sistema foi basicamente implementado sobre o plug-in (org_ Eclipse_ ui).
Este plug-in disponibiliza uma completa API (Application Programming Interface) para implementação de componentes de interface com usuário.
A Figura 13 demonstra os plug-ins utilizados e as extensões definidas sobre o plug-in org_ Eclipse_ ui.
A extensão org_ Eclipse_ ui.
NewWizards foi definida para possibilitar a utilização de wizards em nosso plug-in, enquanto a extensão org_ Eclipse_ ui.
ActionSets foi definida de forma a possibilitar a inclusão de um ícone (onde o plug-in é invocado) na barra de ferramentas do Eclipse.
Conforme já mencionado, a interface do plug-in foi implementada sob o formato de wizard.
Optamos por a adoção deste modelo visto a praticidade de implementação fornecida por a API do plug-in org_ Eclipse_ ui.
A utilização de um wizard também direciona a construção das DMIs, facilitando o entendimento do conceito de DMIs.
Todos os componentes inseridos na tela inicial do wizard são armazenados num estrutura de dados denominada HashMap.
Esta estrutura é composta por três níveis que operam de forma encadeada.
O primeiro nível contém um indicador para a tabela de cada tipo de elementos criados no wizard, ou seja, &quot;DMI, «Role», &quot;SharedObject», &quot;Exception «e &quot;DMIAninhada».
O segundo nível contém os elementos de cada tipo.
O terceiro nível contém os valores associados a cada um dos elementos.
Para facilitar a compreensão do modelo proposto vamos supor a existência de uma DMI composta por dois papéis.
A Figura 14 exemplifica a situação descrita.
Os componentes inseridos na primeira tela do wizard são estruturados de acordo com a estrutura que será apresentada abaixo.
Em o código abaixo representamos a DMI utilizando XML.
Este mesmo formato é utilizado para armazenar as DMIs criadas por o plug-in.
Conforme pode ser observado da linha 2 até a linha 19 temos a descrição da DMI existente, enquanto que da linha 20 até a linha 58 temos a descrição dos papéis.
Cada nível pode ser identificado pela palavra reservada entry.
Uma vez definidos os elementos e seus eventuais relacionamentos estes dados são armazenados em HashMap.
A partir de a HashMap é possível efetuar consultas e transformar nomes (inseridos no wizard) em objetos.
Outro aspecto importante a ressaltar em relação a implementação é a forma como o código é gerado.
Assim como estamos propondo uma estratégia para facilitar a criação de código para as DMIs, evitando assim que falhas sejam inseridas durante a fase de codificação, utilizamos um ambiente para facilitar a geração de código.
Para que as classes do framework sejam populadas com o código correspondente, o plug-in utiliza alguns arquivos de template.
Tais arquivos são criados num editor de texto convencional e são salvos em formato textual.
Os arquivos são estruturados de acordo com a linguagem de templates denominada velocity.
A utilização do velocity torna- se uma alternativa extremamente útil para geração de código, pois viabiliza separar os templates (arquivos txt) do código Java.
Utilizando o velocity os templates ficam muito próximos do resultado final, assim como também torna- se possível a utilização de expressões como foreach e if, tornando os templates dinâmicos.
A Figura 15 mostra parte do código do template Manager.
Txt, onde é feito um foreach para percorrer todas as DMIs (linha 4) e gerar o seu respectivo código.
Dentro de o loop é feito um teste onde é verificado se a DMI possui ou não exceções (linha 5).
Se a DMI possuir exceções relacionadas a ela, então é utilizado o template Manager-exception (linha 6), senão é utilizado o template Manager-normal.
Após definido o template que será utilizado para gerar o código, os parâmetros (váriaveis) armazenados no arquivo HashMap são recuperados e inseridos na estrutura do template.
O último pacote criado durante a geração é denominado manager.
Em esta fase é gerado o código principal para criação de todas as DMIs definidas por o usuário do plug-in, Uso do plug-in DMI.
Uma vez o plug-in instalado, basta inicializar o Eclipse para que a ferramenta esteja disponível aos desenvolvedores.
O plug-in é invocado através de um ícone localizado na barra de ferramentas do Eclipse, conforme pode ser observado na Figura 18.
Uma vez este ícone pressionado é disponibilizado ao desenvolvedor uma interface gráfica conforme pode ser observado na Figura 19.
Inicialmente é necessário que seja definido o nome do projeto corrente (o botão Browse pode auxiliar nesta tarefa caso a pasta não esteja previamente selecionada), em seguida basta que sejam definidos os componentes da DMI.
Conforme mencionado anteriormente, a interface do plug-in foi implementada sob o formato de wizard, e é composta por um total de quatro telas.
Em este modelo de implementação todos os componentes necessários para a criação de uma DMI estão centralizados na primeira tela do plug-in, enquanto a maioria dos eventuais relacionamentos são definidos nas telas posteriores.
O processo para a criação de componentes do tipo Role é praticamente idêntico ao de criação da DMI, bastando na tela inicial selecionar o elemento do tipo Role e em seguida adicionar quantos forem necessários.
É imprescendível que cada papel seja associado a uma DMI previamente definida.
A Figura 21 demonstra a criação de 5 papéis que foram associados a DMI0.
Conforme pode ser observado na parte superior da Figura 21 consta uma mensagem textual alertando que os papéis devem ser associados a DMI.
Após realizada tal associação a mensagem textual desaparece, e o botão Finish (localizado na parte inferior da tela) é então habilitado.
A partir de então basta que o botão Finish seja pressionado de forma que a estrutura de arquivos com seus respectivos códigos sejam gerados, conforme mencionado na Seção 4.
Para criar objetos compartilhados basta na tela inicial selecionar a opção SharedObject, e em seguida criar tantos elementos quanto necessários.
Em seguida é necessário que seja definido qual papel irá gerar e exportar este objeto compartilhado.
Vamos tomar como exemplo a criação de apenas um objeto compartilhado, denomiado SharedObject0 que será criado no Role0.
A Figura 22 detalha o ambiente descrito.
A partir de então percebe- se que na parte inferior da Figura 22 somente os botões Next e Cancel estão habilitados.
Pressionando o botão Next é apresentada a segunda tela do wizard.
Em esta tela é possível recuperar o objeto compartilhado criado na tela anterior e definir para qual (is) papel (éis) este objeto será exportado.
A tela é composta por duas listbox.
A primeira de elas localizada à esquerda da tela, intitulada &quot;Todas as Roles», é onde estão contidos todos os papéis relacionados a DMI, exceto o papel selecionado na tela anterior, onde o objeto compartilhado é criado e exportado.
A segunda listbox localizada à direita da tela é intitulada &quot;Roles Destino», e em ela estão contidos todos os papéis que receberão o objeto compartilhado criado na tela anterior.
Para que a lista possa ser populada são utilizados dois botões localizados entre as listbox, são eles:
Em a parte inferior desta figura percebe- se que apenas os botões Next e Cancel estão habilitados.
Pressionando o botão Next é disponibilizada a terceira tela do wizard, uma interface onde é possível associar cada uma das exceções a uma DMI, assim como, se for o caso, associar uma determinada exceção a outra exceção (veja Figura 25).
Inicialmente é necessário selecionar cada uma das exceções criadas anteriormente e associalas a uma DMI.
Para tanto basta selecionar a exceção na combobox &quot;Selecione «e em seguida na listbox &quot;Todas as DMIs «selecionar a DMI em que esta exceção estará vinculada.
Para finalizar a ação é necessário que a listbox &quot;DMIs Relacionadas «seja populada com a DMI selecionada.
Botões localizados entre as listbox executam tal associação.
Após todas as exceções terem sido relacionadas a uma determinada DMI, também é possível efetuar a associação de uma exceção a outra exceção.
Para tanto basta na combobox &quot;Selecione «selecionar qual exceção que será a filha, e na combobox &quot;Exception Pai «selecionar qual exceção será pai.
Este processo indica que uma exceção será tratada por o tratador de exceções correspondente.
A Figura 25 é composta de duas partes.
A figura da esquerda demonstra a situação onde a exceção Exception0 esta sendo diretamente associada com a DMI0, enquanto a figura da direita demonstra a situação onde a exceção Exception1 é filha da exceção Exception0.
DMIAninhada0 a estes papéis.
A Figura 26 detalha esta ação.
A figura é divida em duas partes, a parte da esquerda detalha o criação da DMIAninhada0 enquanto a parte da direita demonstra os papéis sendo associados a esta DMI.
Pressionando o botão Next é disponibilizada a quarta e última tela do wizard, onde é possível recuperar todos os papéis associados à DMIAninhada0 e DMI0.
Em a combobox &quot;DMIAninhada «é possível visualizar todas as DMIs aninhadas previamente criadas, e na combobox &quot;DMIPai «é possível visualizar todas as DMIs previamente criadas.
Uma vez selecionada qualquer DMI Aninhada no combobox &quot;DMIAninhada «o combobox &quot;Roles DMI Aninhada «é populado com todos os papéis associados a esta DMI.
O mesmo ocorre quando selecionada qualquer DMI presente no combobox DMI Pai.
Em este caso o combobox &quot;Roles DMI Pai «é populado com todos os papéis associados a esta DMI.
A Figura 27 demonstra a tela descrita.
Estudo de Caso: O Jantar dos Filósofos.
O problema do jantar dos filósofos foi introduzido com o intuito de demonstrar como obter sincronização quando um processo precisa de mais de um recurso para executar uma atividade, e.
g, um filósofo precisa de 2 garfos para iniciar a operação de comer.
Note que na especificação original do problema somente um processo pode iniciar a operação.
Para nosso propósito podemos considerar garfos como sendo processos, e a atividade comer acontecerá somente quando as 3 peças, ou seja filósofo e dois garfos, estão prontos para executar.
Uma sincronização similar acontecerá mais tarde, representando o filósofo pegando o garfo da direita.
Após, ambos os garfos irão sincronizar suas execuções para acessar os dados externos prato.
O Apêndice A apresenta o conjunto de telas do plug-in para a geração do problema dos filósofos, enquanto que o apêndice B apresenta o código gerado.
Durante os últimos anos diversos trabalhos foram desenvolvidos com um mecanismo para tolerância a falhas em sistemas concorrentes, ou seja, com a utilização de Interações Multiparticipantes Confiáveis (DMIs).
Estes sistemas foram utilizados para controlar sistemas de manufatura, controle de aplicações web e sistemas de controle de pacientes, entre outros.
Entretanto, conforme já mencionamos durante este documento, todos estes trabalhos fizeram a utilização deste mecanismo de uma maneira manual.
Apesar deste mecanismo melhorar e auxiliar na construção de sistemas confiáveis, o processo de utilização deste mecanismo pode trazer alguns situações indesejadas.
Entre estas situações podemos citar, principalmente, a introdução de falhas no código final gerado por o sistema.
Como o usuário do framework que possibilita a construção de sistemas com este mecanismo não possuir nenhum ambiente de apoio, o processo de utilização também é muito demorado.
Devido a estas carências, este trabalho buscou alternativas para o desenvolvimento de sistemas confiáveis que utilizem DMIs de uma maneira mais rápida e menos propensa a introdução de falhas no mesmo.
Durante os estudos realizados, verificamos que o ide Eclipse poderia ser utilizado de uma maneira que resolvesse os problemas encontrados, conforme já mencionado.
O Ide Eclipse já foi utilizado para auxiliar no desenvolvimento de diversos tipos de aplicações, por exemplo, programação colaborativa, apoio a programação e auxilio na utilização de fala, entre outros.
Entretanto, até onde sabemos, não encontramos um apoio para desenvolvimento de aplicações que utilizem mecanismos de tolerância a falhas.
Uma grande variedade de plug-ins é disponibilizado em.
Desta forma desenvolvemos um novo (plug-in) para o Eclipse que facilite o desenvolvimento de aplicações que utilizem DMIs.
Conforme apresentado neste trabalho, o desenvolvimento de uma aplicação que utilize nosso plug-in tem seu tempo reduzido além de ser menos suscetível a introdução de falhas.
Como sugestão de trabalhos futuros, podemos indicar a extensão do plug-in para o desenvolvimento de modificações de DMIs que possibilitam a construção de DMIs compostas (não foi estudado nesta dissertação de mestrado).
Além de isto, poderia- se- também desenvolver algumas ferramentas de apoio a visualização dos relacionamentos, por exemplo, uma ferramenta que mostrasse as classes ou objetos em diagramas UML.
