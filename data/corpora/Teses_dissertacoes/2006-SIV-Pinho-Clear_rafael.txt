Este trabalho apresenta uma metodologia para modelar e construir tarefas de interação 3D em ambientes virtuais usando Redes de Petri, uma taxonomia de decomposição de técnicas e conceitos de orientação a objetos.
Para tanto, um conjunto de classes e uma biblioteca gráfica são requisitos para construção de uma aplicação e para controlar o fluxo de dados da rede.
Operações podem ser desenvolvidas e representadas como nodos de uma Rede de Petri.
Estes nodos, quando interligados, representam as etapas do processo interativo.
A integração destas abordagens resulta numa aplicação modular, baseada no formalismo de Redes de Petri que permite especificar uma tarefa de interação, e também o reuso dos componentes existentes em novos projetos de ambientes virtuais.
Palavras-chave: Tarefas de interação, Redes de Petri, especificação.
O desenvolvimento de aplicações de Realidade Virtual (RV), em especial aquelas destinadas à pesquisa científica, ainda utilizam processos de modelagem e implementação pouco estruturados e formais, levando, na maioria dos casos, a reescrita de código e a dificuldade em obter uma análise da aplicação antes de seu desenvolvimento.
Para o entendimento de uma aplicação computacional, é útil usar alguma ferramenta de descrição formal que defina comportamentos, tais como Redes de Petri (RdP), Unified Modeling Language (UML) e Máquinas de Estado Finitos (MEFs).
Estas ferramentas permitem compreender e avaliar cada etapa de funcionamento do sistema, além de possibilitar a geração automática de código a partir de diagramas e a modelagem em diferentes níveis de abstração.
Smith destaca que a ausência de uma descrição formal em Ambientes Virtuais (AVs) dificulta a avaliação de semelhanças entre Técnicas de Interação (Tis) diferentes, o que acaba levando a &quot;reinvenção «de técnicas.
Além disso, conforme aborda Navarre, descrições informais facilitam ambigüidades nas implementações.
Formalismos já têm sido usados para modelar Tis e tarefas de interação.
Hynet, ICO e Flownet são alguns exemplos de formalismos existentes, baseados em RdP.
O uso destes formalismos ajuda, por exemplo, na detecção de falhas em sistemas ainda em tempo de projeto.
Além de formalismos, pesquisadores procuram desenvolver taxonomias capazes de documentar e especificar AVs num nível de detalhe mais próximo de a concepção do usuário.
Conforme Lindeman, a RV ainda é uma tecnologia que está em fase de definição e necessita ser classificada e categorizada.
De acordo com Bowman, esta classificação e categorização permitiria entender o conjunto de Tis utilizadas no desenvolvimento de AVs.
Uma vez identificadas, poderiam também ser usadas na organização do projeto interativo.
Os trabalhos que apresentam taxonomias procuram identificar as etapas do processo interativo, classificar Tis e organizar o controle de sistema.
Estas abordagens provêm a separação de contextos, dividindo o sistema em partes menores (componentes), responsáveis por encapsular uma determinada funcionalidade.
Isto permite que componentes sejam reutilizados por novos projetos, possibilitando a combinação destes com o objetivo de criar novas Tis, por exemplo.
Tanto o emprego de formalismos, como de taxonomias, visam otimizar o tempo de projeto e desenvolvimento de AVs.
Uma proposta de integração destas abordagens pode permitir a especificação de sistemas de acordo com o nível de conhecimento do usuário, além de possibilitar o detalhamento de cada etapa do processo de desenvolvimento de software.
Baseado nestes trabalhos anteriores, esta dissertação descreve uma metodologia capaz de modelar e implementar componentes que representem as etapas do processo interativo.
A união destes componentes permite a descrição de uma tarefa de interação, onde a seqüência de passos a serem desenvolvidas por o usuário é controlada por uma RdP.
Esta metodologia integra três abordagens de modelagem:
O formalismo de RdP, a taxonomia de decomposição proposta por Bowman e conceitos de orientação a objeto.
RdP são utilizadas para representar graficamente o comportamento de um AV com base na divisão das tarefas do processo interativo da taxonomia de decomposição de Bowman.
O uso destas abordagens gera um modelo que pode ser codificado com auxílio de um conjunto de classes em C+, o qual define a estrutura e o funcionamento do sistema.
A escolha de RdP para especificação de tarefas em AVs surge naturalmente quando se utiliza uma taxonomia como a de Bowman, pois as tarefas de interação podem ser interpretadas como transições, enquanto os estados assumidos por a aplicação podem ser modelados como lugares na RdP.
A partir de essa interpretação, é possível definir componentes independentes capazes de representar determinadas funcionalidades.
Um artigo com a descrição e aplicação da metodologia de especificação desenvolvida foi ser lido no Apêndice A. O presente texto está organizado da seguinte forma:
O Capítulo 2 apresenta uma análise de trabalhos relacionados de métodos e técnicas de especificação existentes na literatura, detendose naqueles voltados ao domínio de AVs e Tis.
O Capítulo 3 descreve as abordagens utilizadas para concepção da metodologia, enquanto que o Capítulo 4 apresenta base da metodologia proposta.
O Capítulo 5 aplica esta metodologia, demonstrando os passos necessários para a modelagem e a geração de código que implementa o AV, além de apresentar testes que validam a especificação.
Finalmente, o Capítulo 6 apresenta as conclusões deste trabalho, relatando também os objetivos que se pretende alcançar com trabalhos futuros.
Diferentes mecanismos têm sido propostos por a comunidade de RV para descrever e implementar tarefas de interação, buscando compreender a dinâmica das aplicações e possibilitar a padronização de funcionalidades.
Este Capítulo apresenta algumas propostas de especificação do processo interativo para AVs.
Metodologias e técnicas que serviram de base para a concepção deste trabalho são brevemente relatadas, destacando objetivos particulares, vantagens e desvantagens de cada uma de elas.
HyNet (do inglês Hybrid High--level Petri Nets) é uma metodologia de especificação de interfaces e Tis que integra três abordagens de modelagem bem fundamentadas na literatura.
RdP de alto nível representam a base formal da especificação, definindo a semântica e permitindo a representação gráfica dos eventos discretos da aplicação.
Equações diferenciais, por sua vez, permitem a descrição do comportamento contínuo do sistema, enquanto os conceitos de orientação a objeto permitem aumentar o poder de expressividade da metodologia, proporcionando modelos sucintos e compactos.
Conforme Smith, HyNet é um formalismo voltado ao projeto de interfaces.
Seus modelos visam auxiliar o projetista na identificação de problemas de interfaces e na escolha adequada de técnicas a serem empregadas, posteriormente, nas etapas de desenvolvimento de protótipos e da própria aplicação.
O formalismo também permite a representação do modelo em diferentes níveis de hierarquia, facilitando sua compreensão.
A notação de um modelo HyNet baseia- se numa Rede de Petri Objeto Relacional Hierárquica Temporizada, que é composta por oito elementos básicos, conforme mostra a Figura 1.
Em esta metodologia, os diferentes tipos de arcos determinam o fluxo de execução da rede que, conseqüentemente, define o que será apresentado ao usuário.
Em esta metodologia, os lugares definem as classes do sistema.
Sua descrição determina quais são os tipos de objetos (Marcas) suportados.
Transições definem características, e podem ser tanto discretas como contínuas.
Transições contínuas dispõem de um conjunto de equações diferenciais para representar os diferentes comportamentos da aplicação.
Transições discretas podem ter associado a elas o tempo de disparo e a forma de propagação das ações realizadas.
Para ilustrar o uso deste formalismo em ambientes virtuais (AVs), as Figuras 2 e 3 apresentam uma especificação da técnica de navegação baseada em mouse.
Esta técnica realiza um simples vôo de câmera sobre um plano, com alterações na posição relativa do mouse e na velocidade do movimento.
A Figura 2 é uma representação em alto nível da técnica, que procura abstrair detalhes das funcionalidades executadas, visando facilitar a compreensão do modelo (arcos pontilhados indicam que diferentes tipos de arcos estão sendo utilizados).
Mouse Movement e Scene são definidos como os pontos iniciais da rede.
Já a Figura 3 apresenta o detalhamento da operação de mouse, representada na Figura 2 por a transição Mouse Movement.
Em esta Figura, as três abordagens do formalismo estão presentes:
Elementos de uma RdP, equações diferenciais (conteúdo das transições) e orientação a objetos (esboço da classe).
O formalismo HyNet facilita a representação do comportamento das Tis.
Suas descrições auxiliam as fases de análise e projeto de AVs e podem servir de base para a implementação destas aplicações.
No entanto, a proposta de especificação detalhada pode dificultar a representação de AVs, principalmente aqueles que envolvem diferentes técnicas e dispositivos (multimodais), levando a modelos complexos e &quot;poluídos «visualmente, mesmo se for feito uma modelagem hierárquica.
Além disso, o formalismo não proporciona uma forma de geração automática de código, o que requer o aprendizado da metodologia tanto por parte de projetistas como de desenvolvedores.
Flownet Flownet é uma técnica de especificação formal desenvolvida para a modelagem de Tis, baseada na metodologia HyNet.
O formalismo Flownet usa RdP para definir o comportamento discreto de Tis e elementos de uma notação para modelagem de sistemas dinâmicos para descrever o comportamento do fluxo de dados contínuo das técnicas e objetos do AV.
Duke). Conforme Smith e Duke, o uso de Flownet tem por objetivo ajudar na descrição e compreensão dos componentes de um AV.
Esta técnica de modelagem oferece uma notação de interface entre o sistema e o usuário que possibilita a representação dos fluxos de dados.
Esta notação é composta para o dez componentes gráficos para especificação de sistemas.
A Tabela 1 apresenta estes componentes, e brevemente relata a funcionalidade de cada um no modelo Flownet.
A especificação usando Flownet procura definir a seqüência dos possíveis comportamentos apresentados por o sistema, sem preocupar- se com detalhes de implementação.
Isto abstrai a complexidade do sistema, permitindo o refinamento das técnicas utilizadas e a redução do mo delo.
Esta redução facilita a compreensão dos requisitos do sistema, e como estes podem ser alcançados durante a fase de projeto, resultando em modelos compactos, objetivos e expressivos.
O formalismo também dispõe de uma ferramenta, denominada Marigold, que possibilita ao desenvolvedor a construção dos modelos e protótipos.
A ferramenta permite a conexão de componentes que definem Tis e dispositivos com um AV para simulação dos comportamentos.
A Figura 4 apresenta um exemplo que modela uma técnica de navegação por vôo, usando Marigold, onde o usuário utiliza suas mãos para controlar seu deslocamento.
Como visto, Flownet oferece um método sistemático para projeto, teste e refinamento de Tis, com a possibilidade de prototipação de AVs.
No entanto, mesmo oferecendo recursos mais intuitivos para representação de técnicas e dispositivos, e uma ferramenta de geração de código, Flownet continua por exigir o aprendizado da metodologia.
De acordo com os trabalhos estudados, os protótipos gerados referem- se apenas à AVs simples, que envolvem um número reduzido de objetos, técnicas e dispositivos.
Além disso, a ferramenta Marigold não está disponível para uso, seja comercial ou gratuito.
O formalismo ICO (do inglês Interactive Cooperative Objects) é uma notação formal destinada à especificação de sistemas interativos, que usa conceitos de orientação a objetos para descrição dos aspectos estruturais ou estáticos de sistemas e RdP de alto nível para a descrição dos aspectos dinâmicos ou comportamentais.
Conforme Palanque, ICO foi planejado originalmente para modelagem e implementação de interfaces gráficas baseadas em eventos.
O modelo ICO de um sistema é composto de objetos cooperativos, onde o comportamento dos objetos e o protocolo de comunicação entre eles são descritos por uma RdP.
Em este formalismo, um objeto é representado por uma entidade caracterizada por quatro componentes:·
Comportamental: Define como o objeto deve reagir aos estímulos externos do sistema, através de uma RdP de alto nível.
Em outras palavras, são as opções de interação oferecidas por o sistema ao usuário;·
Serviços: Define a interface de comunicação entre o objeto e o ambiente, e como estes estão interligados (funções de ativação);·
Estado: Permite definir a disponibilidade dos serviços, baseado nas informações que recebe do usuário e do sistema;·
Apresentação: É a visão que o usuário tem do sistema e com a qual ele interage.
É o componente responsável por o rendering da aplicação.
ICO é utilizado para fornecer uma descrição formal do comportamento de uma aplicação interativa, mapeando as possíveis interações que um usuário pode ter acesso.
Esta especificação compreende tanto a descrição das ações do usuário que influenciam a aplicação, como aquelas que são destinadas a apresentar ao usuário informações pertinentes sobre sua interação.
Sua especificação é executável, e oferece a possibilidade de prototipar e testar uma aplicação antes que ela seja completamente implementada.
O formalismo também considera separadamente a modelagem de Tis e de dispositivos usados.
Além de estas vantagens, a especificação permite que os modelos sejam validados com o uso de ferramentas de análise e de prova desenvolvidas por a comunidade de RdP que dão suporte a objetos cooperativos.
As Figuras 5 e 6 são exemplos de modelos ICO que representam AVs.
A Figura 5 representa a ação de pegar e soltar uma peça de um jogo de xadrez usando uma luva de RV, enquanto que a Figura 6 representa a ação de controlar os instrumentos de uma simulação de vôo usando comandos de voz e gestos.
InTML Figueroa propõe uma arquitetura de desenvolvimento de Tis, baseada em filtros, em o qual fontes de informação (como, por exemplo, dispositivos) geram um fluxo de dados que são propagados entre filtros interconectados.
Em este trabalho, a linguagem de marcação InTML (do inglês Interaction Techniques Markup RV.
Esta linguagem foca a integração do comportamento específico da aplicação com o comportamento dos objetos e eventos de dispositivos de entrada, permitindo que Tis sejam construídas e tratadas como componentes externos, independentes da aplicação.
Isto permite que técnicas possam ser integradas, criando novas formas de interação.
Em esta arquitetura, um filtro representa qualquer dispositivo, técnica de interação, comportamento ou conteúdo de uma aplicação de RV descrito por um arquivo InTML.
Sua interface é definida por portas de entrada e saída as quais são os tipos de eventos que podem receber ou produzir dados, respectivamente.
A Figura 7 apresenta um exemplo de filtro que representa a técnica de seleção por toque, onde suas entradas (à direita) recebem um objeto 3D que representa a mão do usuário, a posição e orientação de um objeto, a cena de objetos disponíveis para seleção e eventos que informam sobre a inserção ou exclusão de objetos da cena.
A execução de um filtro é dividida em três estágios principais:·
Coleta de dados:
Toda informação gerada em certo intervalo de tempo é coletada.
Este estágio é considerado como de pré-processamento, em o qual filtros selecionam e manipulam a informação que eles recebem, procurando preparar os dados para a próxima etapa;·
Processamento: Em este estágio, um filtro executa de acordo com as informações de entrada e atualiza seu estado interno.
Informação de saída é gerada, mas não propagada;·
Propagação da saída:
A informação gerada por a etapa de processamento é transmitida a todos os filtros interconectados.
Filtros também podem ser combinados, gerando componentes que representam uma nova Ti.
A Figura 8 apresenta um exemplo que mostra a técnica Go-Go sob o ponto de vista geral (à esquerda) e detalhado (à direita).
Este recurso também permite que tais componentes sejam recombinados para gerar uma nova Ti.
Figueroa destaca que, usando uma linguagem padronizada como InTML, projetistas de aplicações de RV podem entender e comparar técnicas numa mesma linguagem, sob um paradigma de documentação uniforme.
A linguagem também permite abstrair a complexidade de um AV, e facilita o reuso do código de cada componente criado.
No entanto, como o processo de geração de código, oferecido por a arquitetura, resulta num código interpretado (no caso, Java), a qualidade da interação pode ficar comprometida caso não exista um hardware que suporte as exigências da aplicação.
Unit O framework Unit usa uma linguagem de programação de fluxo de dados para descrever Tis.
Unit estabelece uma camada de abstração entre os dispositivos de entrada e a aplicação para Tis, permitindo ao desenvolvedor separar as funcionalidades da aplicação das técnicas e comportamentos do projeto de interfaces gráficas.
Este framework foi desenvolvido usando a linguagem de programação Java, juntamente com a biblioteca Java3D, característica esta que o torna independente de plataforma.
Para criação da camada de técnicas, Unit usa um conceito de unidades que representam fluxos de dados.
Estas unidades são componentes que, agrupados, procuram representar uma determinada Ti.
Recursos da aplicação e de dispositivos comunicam- se com esta camada, oferecendo subsídios para o funcionamento da Ti.
Para visualizar as ligações entre as camadas da aplicação, Unit dispõe de uma interface gráfica que especifica a interação através de uma representação por grafos.
A Figura 9 apresenta um exemplo de grafo que representa parte do fluxo de dados da Ti Flexible Pointer.
O framework também permite que unidades que compõem uma Ti estejam distribuídas em diferentes máquinas, através de comunicação remota.
Esta característica possibilita, por exemplo, testes com dispositivos que estão permanentemente conectados a uma determinada estação de trabalho.
Unit também possibilita a troca de técnicas durante a execução da aplicação.
No entanto, o uso de grafos para representar a interação pode dificultar a compreensão de Tis, a medida que a sua complexidade aumenta.
Além disso, o framework também necessita um hardware robusto para a execução dos testes, uma vez que o código é interpretado.
Olwal e Feiner).
Metodologia baseada em máquinas de estado hierárquicas que permite a comunicação entre o projetista e o programador de uma interface 3 D, procurando descrever as características de sis-temas interativos em forma de &quot;conceitos reusáveis «que auxiliam no gerenciamento de código.
Conforme Wingrave, estes &quot;conceitos reusáveis «são descrições sucintas do funcionamento de uma Ti, que podem ser refinadas durante a fase de desenvolvimento, de acordo com as necessidades do projeto do AV.
Conceitos estabelecidos podem ser armazenados numa biblioteca, para posterior uso do desenvolvedor.
De acordo com o autor, esta forma de especificação permite que desenvolvedores expressem padrões de interação complexos, oferecendo uma forma de combinar Tis existentes com o mínimo esforço e sem alterar a base de uma aplicação.
O método de decomposição de técnicas em conceitos usado por CHASM adota o padrão «quando então para identificar um estado de comportamento.
Os pesquisadores apresentam um exemplo deste método com o mapeamento do comportamento de uma aplicação que oferece duas Tis para o usuário:
World-In-- Miniature (WIM) e RayCasting.
Em esta configuração, para o uso de WIM o usuário deve posicionar sua mão em frente ao rosto.
Em caso contrário, deve afastar- la.
Em ambos os casos, a interação com um botão é necessária.
Uma implementação tradicional deste comportamento exigiria verificar o relacionamento entre a mão e a cabeça quando algum movimento de uma desta fosse detectado.
Para isto, as seções de código precisam estar certas de que, no momento em que o botão for liberado, por exemplo, apenas uma das técnicas esteja habilitada.
CHASM permite reconhecer estas situações em tempo de projeto, forçando o desenvolvedor a prever sua ocorrência durante a implementação e não em tempo de depuração.
CHASM também possibilita a geração de diagramas, como diagramas de transição e relacionamento, oferecendo recursos para a descoberta de erros, documentação e visualização do projeto do AV.
No entanto, ainda não existem ferramentas capazes de manipular visualmente a base de conceitos, o que permitiria a concepção de novos conceitos e técnicas ainda na fase de projeto do AV.
Além disso, o autor destaca a necessidade de métodos de avaliação cognitiva e o suporte à descrição de conceitos para AVs complexos, como AVs de Realidade Aumentada (Ra).
O trabalho de Ying busca entender o processo interativo através da análise do códigofonte de aplicações de RV já implementadas.
Usando os conceitos de engenharia reversa, são extraídas informações relacionadas à interação do usuário em AVs colaborativos.
Tais informações são organizadas e armazenadas num arquivo que serve de base para a geração de um modelo de RdP, denominado IPN (do inglês Interaction Petri Net).
Para que uma ferramenta de modelagem possa compreender a especificação e gerar o modelo de RdP apropriado, uma tradução do arquivo IML é realizada para um novo arquivo, no formato PNML (do inglês Petri Net Markup Language), usando para tal um vocabulário XSLT (do inglês eXtensible Stylesheet Language Transformation).
A Figura 11 ilustra o procedimento completo realizado por esta abordagem, onde (a) mostra o arquivo 3D analisado, (b) apresenta a lista de especificação e (c) exibe a RdP gerada.
Apesar de a idéia de IPNs ser interessante para análise do processo interativo, a abordagem proposta por os autores limita- se a descrição de AVs não-imersivos.
Além disso, aplicações desenvolvidas em linguagem C/ C+, freqüentemente utilizada na construção de AVs, não podem ser especificadas, restringindo ainda mais o domínio de uso da proposta.
DWARF -- User Interface Control MacWilliams apresenta uma arquitetura para interfaces de Ra onde uma abordagem baseada em RdP permite a representação gráfica das metáforas de interação utilizadas por um sistema.
Esta arquitetura tem por base o framework DWARF (do inglês Distributed Wearable Augmented Reality Framework), responsável por o controle de serviços de dispositivos de entrada/ saída e protocolos de comunicação.
A interface de controle da aplicação comunica- se com o modelo (que representa a aplicação) através de funcionalidades oferecidas por a ferramenta de modelagem JFern.
Componentes de entrada enviam dados para a interface de controle, que os encapsula e envia para a rede.
Esta efetua a simulação de acordo com as regras estabelecidas por o modelo, e devolve para a aplicação a ação a executar.
Para demonstrar a utilização dos recursos desta arquitetura, os pesquisadores projetaram o sistema SHEEP, um jogo onde o objetivo é criar ovelhas e reunir- las em rebanhos através de uma interface de Ra.
A Figura 12 apresenta esta aplicação, onde o usuário interage através de um bastão e comandos de voz, e suas ações são simuladas por uma RdP.
Em o exemplo da Figura, enquanto não existe colisão no cenário (a), a RdP permanece ociosa, sem marcas depositadas em seus lugares.
De acordo com Hilliges, representações gráficas do funcionamento da aplicação são úteis para o processo de debugging.
Em este exemplo, o avaliador pode ter uma visão do processo interativo em execução na rede, enquanto o usuário interage normalmente com a aplicação.
As RdP que modelam as interações do usuário são descritas por arquivos XML, onde estruturas de classes podem ser geradas na linguagem Java.
A ferramenta JFern é evocada durante a execução da aplicação, simulando graficamente o comportamento da rede.
No entanto, tais modelos podem ser tornar complexos e de difícil compreensão, a medida que o número de possibilidades de interação aumentam.
Procurando sintetizar o que foi apresentado neste Capítulo, a Tabela 2 apresenta um resumo das características e das fases de desenvolvimento abordadas em cada uma das técnicas.
Desenvolvimento «referem- se às etapas de Análise (A), Projeto (P) e Implementação (I) de sistemas.
RdP Não Não Sim RdP Sim Não Sim RdP Sim Sim Não Não InTML Java Sim Não Não Grafos Java Sim Não Não Texto Texto Não RdP Não Não RdP Sim Sim Java Não 3 Fundamentos da Metodologia Por a análise dos trabalhos citados anteriormente, nota- se que as abordagens apresentam vantagens e objetivos particulares, mas, em geral, não atendem a contento todas as fase do ciclo de desenvolvimento de aplicações de computador.
Em este sentido, este trabalho propõe uma metodologia para o desenvolvimento hierárquico de aplicações de RV, do projeto à implementação, com base no processo interativo.
Em este Capítulo são discutidas duas das três ferramentas utilizadas como fundamento para esta metodologia.
Inicialmente, uma breve apresentação do Formalismo de Redes de Petri aborda as principais definições, características, propriedades e extensões de modelagem presentes na literatura.
Em seguida, é descrita a Taxonomia de Decomposição de Tarefas de Interação 3D proposta por Bowman.
Aspectos referentes à separação de tarefas de seleção, manipulação e navegação em partes menores são tratados por esta Seção.
Os conceitos de Orientação a Objetos, presentes nesta metodologia de especificação, não serão aqui abordados.
Este paradigma de análise, projeto e programação de sistemas é amplamente e corriqueiramente utilizado por projetistas e desenvolvedores, além de estar bem fundamento por a literatura.
Redes de Petri De acordo com Murata, uma Rede de Petri é uma ferramenta de modelagem gráfica e matemática aplicável a muitos sistemas, principalmente na descrição e estudo de sistemas concorrentes, assíncronos, distribuídos, paralelos, não-determinísticos ou estocásticos.
Protocolos de rede, sistemas fuzzy e aplicações de RV são exemplos de sistemas que podem ser modelados e simulados utilizando esta ferramenta.
O nome &quot;Redes de Petri «é uma homenagem a Carl Adam Petri, criador deste modelo em estado fossem capazes de se comunicar.
Formalmente, uma RdP pode ser definida como uma quíntupla, onde:·
F (P × T) (T × P) é um conjunto de arcos;
Raposo destaca que, num modelo de RdP, os estados estão associados aos lugares e suas marcações, e os eventos às transições.
O comportamento de um sistema modelado por RdP é descrito em termos de seus estados e suas mudanças.
Graficamente, uma RdP é um tipo particular de grafo direcionado, composta por quatro tipos de elementos:·
Lugares ou Places:
Representados por elipses, são vértices que representam os estados do sistema.
São componentes passivos da RdP;·
Fichas, Marcas ou Tokens:
Simbolizados por pontos, representam a situação atual, ou seja, em que estado encontra- se o sistema modelado.
As marcas iniciais informam o estado primitivo do sistema;·
Transições: Vértices que representam às ações (eventos) do sistema, simbolizados por traços ou barras (horizontais ou verticais).
Modelam o comportamento dinâmico do sistema;·
Arcos: Interligam lugares a transições, e vice-versa, por meio de setas direcionais, indicando a seqüência de execução da rede.
Transportam marcas entre os vértices do grafo, indicando as pré e pós-condições de uma transição.
Também podem ter rótulos que definem o número de marcas a transportar de um vértice a outro.
A Figura 13 ilustra uma RdP que representa uma tarefa simples de um sistema de empacotamento.
O modelo descreve uma linha de montagem de um conjunto de porcas e parafusos, onde o número de peças disponíveis está representado por marcas nos lugares &quot;Parafusos «e &quot;Porcas», além de uma marca em &quot;Máquina «indicando que a máquina de empacotar está livre para a execução da tarefa.
A transição de &quot;Montar Pacote «exige como pré-condição a existência de, no mínimo, três porcas e três parafusos (peso indicado nos arcos dirigidos), além de a máquina liberada.
Satisfazendo os requisitos, as marcas são consumidas, e uma nova marca será depositada no lugar &quot;Pacote».
Esta etapa habilita a transição de &quot;Enviar Pacote», que recoloca uma marca em &quot;Máquina «(indicando que a máquina está livre para novo empacotamento), enquanto &quot;Depósito «recebe uma marca informando que mais um pacote está disponível ao setor de Expedição.
O exemplo abordado também poderia ser representado em notação matemática.
Utilizando uma representação baseada em conjuntos, a Figura 13 poderia ser assim descrita:
A representação matemática possibilita uma análise aprofundada do funcionamento do sistema, de acordo com determinadas propriedades identificadas por a teoria de RdP.
Além disso, sistemas podem ser especificados com diferentes tipos de RdP existentes na literatura.
As duas próximas subseções destacam, brevemente, estas outras características.
Conforme Murata e Maciel, as propriedades das RdP podem ser divididas em dois grupos:
Propriedades estáticas (ou estruturais) e propriedades dinâmicas (ou comportamentais).
O primeiro não depende das marcas e não se modifica durante o estágio de execução da rede.
Já o segundo grupo depende das marcas, e tende a estar em constante atualização.
Abaixo, são apresentados os tipos de propriedades que compõem cada um desses grupos, e o que cada um de eles procura evidenciar na rede.
De acordo com Murata, as propriedades comportamentais são:·
Alcançabilidade (reachability):
Indica a possibilidade de atingir- se um determinado lugar por o disparo de um número finito de transições, a partir de uma marcação inicial.
Satisfazendo esta propriedade, diz- se que a rede é alcançável, e todos os estados, em algum momento da execução do sistema, serão satisfeitos;·
Limitação (boundedness):
Define o número de marcas que cada lugar pode acumular.
A passagem de um estado para outro depende do peso dos arcos associados às transições;·
Segurança (safeness):
Uma RdP é definida como segura se todos os lugares desta rede podem contar uma ou nenhuma marca.
Esta propriedade está ligada à limitação da rede;·
Vivacidade (liveness):
Usada para constatar a ausência de deadlocks.
Assim, esta propriedade é evidenciada quanto for possível executar todas as suas transições a partir de qualquer um dos estados alcançáveis da rede;·
Cobertura (coverability):
Identifica se uma transição é potencialmente disparável, isto é, se uma marca pode ser obtida a partir de uma outra, anterior a ela;·
Persistência (persistence):
Ocorre quando o disparo de uma transição não desabilita o disparo de outra.
Este tipo de comportamento está presente em sistemas paralelos e circuitos digitais com atividades assíncronas;·
Reversibilidade (reversibility):
Ocorre quando o lugar inicial ou um grupo específico destes pode ser novamente alcançado;·
Justiça (fairness):
Uma RdP é dita justa se, para quaisquer duas transições, o número de vezes que uma é executada enquanto a outra não é executada é finito.
Já as propriedades estruturais são:·
Limitação (structural boundedness):
Uma rede é estruturalmente limitada se o número de marcas em cada lugar sempre permanece o mesmo;·
Conservação (conservation):
Ocorre quando a soma dos valores dos arcos que ligam as pré-condições de uma transição for igual à soma das pós-condições;·
Repetitividade (repetitiveness):
Essa propriedade se evidência quando uma marcação habilita ilimitadamente uma seqüência de transições;·
Consistência (consistency):
Uma RdP apresenta essa propriedade quanto uma seqüência de transições é disparada, a partir de a marcação inicial, retornando- à esta configuração quando todas as transições da rede foram disparadas ao menos uma vez.
O modelo original de RdP, abordado até esse momento, é simples e possibilita a representação de diferentes tipos de aplicação, como já destacado.
No entanto, a medida com que pesquisadores adotaram RdP para representar seus sistemas, duas importantes características apresentaram- se de difícil modelagem:
Aspectos funcionais complexos (condições de fluxo de controle) e aspectos de temporização.
Para resolver esse problema, diversas extensões de RdP têm surgido na literatura.
Essas extensões, também chamadas de Redes de Petri de Alto Nível, procuram preservar a teoria inicial realizando adaptações conforme as necessidades e características do que se deseja modelar e formalizar.
De entre estas, duas freqüentemente são utilizadas, e servem de base para novas abordagens:
Redes de Petri Coloridas (RdP-C) e Redes de Petri Hierárquicas (RdP-H).
RdP-C diferenciam- se do modelo original por permitir a distinção de marcas através de cores ou tipos de dados, permitindo que recursos sejam agrupados numa única representação, reduzindo conseqüentemente o tamanho do modelo.
De acordo com Jensen, uma RdP-C é uma representação gráfica e intuitiva que facilita a visualização da estrutura básica de um modelo complexo, além de permitir a compreensão individual do comportamento dos processos do sistema.
Para tanto, elas são compostas por três diferentes partes:·
Estrutura: Grafo direcionado com dois tipos de vértices (lugares e transições), com arcos valorados interconectando- os;·
Declarações: Especificam o conjunto de cores e declarações de variáveis (legenda);·
Inscrições: Identificam cada elemento da rede.
Lugares têm nome, conjunto de cores e expressão de inicialização (marcação inicial).
Transições podem possuir nomes e expressões associadas.
Já inscrições em arcos podem ter tipos e expressões.
Conforme mostra a Figura 15, numa RdP-C as marcas coloridas (ícones) podem especificar tipos de dados.
Arcos podem definir os tipos suportados, ou são rotulados com condições especiais, como, por exemplo, operações lógico-matemáticas sobre esses dados.
Estas condições, chamadas de &quot;guardas», também podem estar associadas a limitações impostas por as transições, visando restringir o conjunto de dados a trabalhar.
Em a Figura 15, os lugares &quot;Parafusos «e &quot;Porcas «estão modelados como um único lugar, &quot;Peças», composto por ícones que simbolizam os recursos para a montagem dos pacotes.
O arco entre &quot;Peças «e &quot;Montar Pacote «contém a inscrição que indica as condições mínimas para elaboração de um conjunto de peças, enquanto os demais arcos indicam a máquina ligada e o conjunto que foi produzido.
Já as RdP-H proporcionam uma descrição estruturada dos sistemas, possibilitando diferentes níveis de abstração que auxiliam na interpretação dos modelos.
De o ponto de vista teórico, a hierarquia é uma conveniência gráfica que não adiciona poder computacional, contudo permite uma modelagem compacta em níveis de abstração variados de sistemas de grande porte.
Em essa extensão, um conjunto de lugares e transições pode ser uma sub-rede da rede global.
Para tanto, lugares e transições são utilizados como interface entre uma rede de mais alto nível e suas respectivas sub-redes.
Essa interface é vista como uma caixa-preta, ocultando detalhes do modelo representado.
Quando a caixa-preta define a especialização de uma rede é chamada de subpágina;
Quando representa a generalização de uma rede denomina- se superpágina.
Os elementos que se localizam nos extremos de uma subpágina são de mesmo tipo, e representam um lugar ou uma transição geral numa superpágina.
Por exemplo, caso busque- se especializar um evento, sua especificação deverá ter transições como entrada e saída da sub-rede.
Seguindo o exemplo das porcas e parafusos, a Figura 16 ilustra o uso de hierarquia com RdP.
A parte superior da ilustração apresenta a RdP-C da Figura 15 em alto nível, onde os procedimentos de montar e enviar pacote estão encapsulados numa única transição, representando a tarefa de empacotamento.
Já a parte inferior mostra um refinamento, por meio de a ligação da interface com a sub-rede.
Taxonomia de Decomposição de Tarefas A análise do processo interativo está ligada à especificação das tarefas do ambiente.
Cada tarefa a ser executada corresponde a um objetivo específico proposto por a aplicação.
Apesar de AVs serem compostos por diferentes tipos de tarefas, é possível decompor- las em tarefas simples que formam a base do sistema de interação.
Estas tarefas básicas geralmente envolvem técnicas de seleção, manipulação e navegação.
Por seleção entende- se o processo de definir, de entre os objetos de um AV, sobre qual ou quais de eles se deseja manipular.
Este processo envolve duas etapas:
Uma de indicação do objeto, onde o usuário &quot;mostra «ao sistema o objeto de interesse, e outra de confirmação da seleção, onde o usuário define o objeto como selecionado.
Segundo Pinho, a manipulação consiste no processo de alteração de parâmetros ou estado de um objeto previamente selecionado.
Esta mudança envolve a mudança da orientação, posicionamento, tamanho ou outro parâmetro qualquer, geométrico (forma ou posição), visual (cor ou textura) ou comportamental (iniciar movimento ou parar).
A navegação, por sua vez, é o processo que permite o deslocamento do usuário dentro de o AV.
Este processo pode envolver tanto mudanças de posição e rotação do avatar, como ferramentas que auxiliam o usuário a encontrar o caminho desejado e tarefas que controlam a velocidade do movimento.
Para tanto, existem técnicas responsáveis por a locomoção e localização/ orientação (wayfinding) do usuário.
As tarefas acima descritas podem ser executadas através da utilização de técnicas de in-teração em AVs.
Baseado em Bowman, pode- se dizer que uma técnica de interação é um método que permite a concretização das tarefas num AV de forma dinâmica, envolvendo tanto componentes de hardware como de software.
A parte de software é responsável em mapear a informação de um dispositivo de entrada para alguma ação compreensível por o sistema.
Além disso, o resultado dessa operação é mapeado por a aplicação para um dispositivo de saída, que procurará representar as ações do usuário de forma tão natural quanto possível.
Pensando numa alternativa que permitisse a organização de técnicas de interação em conjuntos particulares, de maneira com que elas pudessem ser pensadas sistematicamente, Bowman propôs uma taxonomia de técnicas de interação com base na decomposição das tarefas de uma aplicação.
Em este conceito, cada tarefa de interação possa ser particionada (decomposta) em subtarefas simples e independentes.
Similarmente, técnicas podem ser decompostas em subtécnicas, chamadas de componentes da técnica.
Cada um destes componentes pode estar relacionado a uma subtarefa.
A Figura 17 apresenta um esboço desta taxonomia de decomposição.
Para exemplificar o uso da taxonomia de decomposição de tarefas, suponha- se que uma tarefa básica seja alterar a cor de um objeto num AV.
Esta tarefa pode ser dividida, inicialmente, em três subtarefas diretamente relacionadas à tarefa:
Selecionar um objeto, escolher uma cor e aplicar esta cor.
No entanto, podem existir também subtarefas que não estejam diretamente relacionados à tarefa do usuário, mas são igualmente importantes durante o processo de decomposição.
A paleta de cores e os feedbacks de interação oferecidos por o sistema, por exemplo, poderiam ser enquadrados neste caso.
Bowman também destaca que uma taxonomia precisa ser suficientemente genérica para que técnicas de interação ajustem- se aos propósitos da tarefa.
Por exemplo, a taxonomia poderia oferecer três formas diferentes de interação para a tarefa de colorir um objeto:
Tocar o objeto, dar um comando de voz ou escolher um item de menu para aplicar a cor.
No entanto, nada impede que exista uma outra técnica que desempenhe a mesma tarefa (uma forma de apontamento, por exemplo).
Taxonomia e categorização são boas formas para entender os detalhes de uma técnica de interação, e formalizar as diferenças entre elas.
E, uma vez formalizado, é possível determinar sua utilização durante o projeto do AV.
Assim, a taxonomia serve como guia na avaliação de técnicas e de tarefas, ao invés de apenas identificar falhas de projeto.
Outra vantagem é a possibilidade de integrar componentes genéricos já desenvolvidos para a concepção de uma nova técnica.
Este processo pode ser extremamente útil quando o número de subtarefas envolvidas num projeto de AV é pequeno, e a escolha para cada subtarefa seja clara o suficiente para permitir sua representação gráfica.
Bowman apresenta uma taxonomia conjunta para técnicas de seleção e manipulação, uma vez que uma tarefa de manipulação requer, inicialmente, a execução de uma tarefa de seleção (o contrário não ocorre).
Como visto anteriormente, seleção refere- se ao ato de especificar ou escolher um objeto para algum propósito.
Já manipulação compreende a tarefa de ajustar a posição e orientação do objeto selecionado.
Em esta taxonomia, a tarefa de selecionar e manipular objetos é dividida em três tarefas básicas:
Seleção, manipulação e liberação, conforme mostra a Figura 18.
Esta abordagem também permite que o projetista da técnica possa detalhar a tarefa, subdividindo- a novamente.
Uma tarefa de manipulação poderia envolver, por exemplo, operações de anexação, posicionamento e orientação.
Baseado na taxonomia da Figura 18, é possível perceber que existem três etapas distintas durante o processo de seleção, quatro durante o processo de manipulação e duas etapas durante o processo de liberação.
A primeira etapa do processo de seleção refere- se à indicação do objeto, onde o usuário &quot;mostra «ao sistema qual objeto deseja manipular.
A segunda diz respeito à confirmação do objeto, onde o usuário define o objeto como selecionado.
No entanto, para que o usuário perceba suas ações no ambiente, tanto na indicação, como na confirmação do objeto selecionado, é necessário que o sistema sempre retorne um feedback apropriado a cada situação.
Uma das alternativas utilizadas por aplicações é realçar o objeto selecionado com uma cor diferente, uma moldura ou marcadores.
E, para o instante da confirmação, geralmente são empregados sinais visuais, sonoros ou táteis.
De a mesma forma que uma tarefa de seleção, o sistema apresenta um feedback apropriado para que o usuário perceba as alterações no ambiente.
Este feedback pode ser apresentado através do mapeamento instantâneo da ação do usuário.
O processo de liberação envolve, primeiramente, uma indicação de que o usuário está liberando o objeto em manipulação (através do pressionamento de um botão, gesto ou comando de voz).
Após isto, o sistema apresenta um feedback que &quot;solta «o objeto virtual em sua nova posição no AV.
Os componentes das técnicas listados na Figura 18, para cada uma das subtarefas apresentadas, podem ser combinados com o objetivo de produzir uma técnica de interação completa.
A capacidade de combinar componentes em novas maneiras já tem resultados expressivos em trabalhos apresentados por a comunidade de RV.
As técnicas HOMER e Voodoo Dools são exemplos que combinam diferentes componentes para a realização de tarefas de seleção e manipulação.
Conforme destacado anteriormente, a navegação refere- se à forma como o usuário movimentase dentro de o cenário virtual.
Esta tarefa envolve técnicas de deslocamento e orientação (wayfinding), sendo que a primeira consiste no componente motor da navegação virtual, relacionado as tarefas físicas realizadas no mundo real, enquanto que a segunda refere- se ao componente cognitivo num processo de navegação:
Pensamento, planejamento e decisão do caminho e dos movimentos a serem executados.
A taxonomia para técnicas de navegação decompõe a tarefa básica de navegação em três subtarefas:
Seleção da direção e do alvo, seleção da velocidade e aceleração e as condições de entrada, conforme mostra a Figura 19.
A seleção da direção e do alvo refere- se à subtarefa em a qual o usuário especifica como quer mover- se e para onde quer mover- se.
Quando a direção é determinada por o movimento da mão, por exemplo, o usuário sempre se desloca para onde sua mão ou dedo estiver apontando.
Um fator de escala também pode ser utilizado como instrumento de navegação, facilitando o apontamento de objetos-alvo a serem alcançados.
Outras formas de navegação utilizam o controle da direção por o movimento da cabeça e o uso de dispositivos físicos, como joysticks.
Uma forma fácil de controlar a velocidade e a aceleração do movimento em AVs é tornar- las constantes.
No entanto, isto pode não ser muito vantajoso quando uma rota distante precisa ser percorrida.
Para estes casos, técnicas que permitam movimentar- se mais rapidamente enquanto se está longe do destino, diminuindo gradativamente a velocidade à medida que se aproxima, e controlando a aceleração por meio de gestos ou comandos de voz são alternativas interessantes.
O objetivo principal desta metodologia é modelar e implementar componentes que representem as etapas do processo interativo.
O emprego de um formalismo, em conjunto com uma taxonomia de interação, possibilita a especificação detalhada do sistema, bem como auxilia o processo de estruturação e implementação, permitindo o encapsulamento de determinadas funcionalidades.
Tais características podem permitir que componentes gerados sejam reutilizados, simplificando o processo de desenvolvimento e adicionando flexibilidade às aplicações.
Para tanto, este Capítulo apresenta a base da metodologia proposta, onde o Formalismo de RdP e a Taxonomia de Decomposição de Tarefas são integrados para a modelagem e implementação de Tis.
Esta integração permite a descrição de uma tarefa de interação, onde a seqüência de passos a serem desenvolvidas por o usuário é controlada por uma RdP.
Justificativa Para a base da metodologia, optou- se por o emprego de RdP por esta apresentar um formato de especificação formal com diferentes formas de extensão, bastante fundamentado e consolidado por a comunidade científica.
Conforme Murata, uma RdP é uma ferramenta de modelagem gráfica e matemática para especificação e análise de sistemas concorrentes e dinâmicos, onde aplicações de RV se enquadram.
Além disso, o poder de expressão de seu formalismo, juntamente com as ferramentas de análise e simulação existentes, permitem que a estrutura e o comportamento de um sistema sejam previstos e testados antes da fase de implementação.
A representação gráfica adotada para a metodologia baseia- se no uso de RdP-C e RdP-H, como forma de distinguir os diferentes tipos de dados a serem manipulados por uma aplicação e permitir a hierarquização dos modelos.
Conforme visto anteriormente, ambas abordagens são uma extensão das RdP que têm por objetivo reduzir o tamanho dos modelos.
Por convenção, este trabalho irá referir- se à RdP-C por o simples termo de &quot;RdP», enquanto que &quot;RdP-H «fará menção às Redes de Petri Coloridas Hierárquicas.
A proposta também procura aproximar a concepção do usuário ao trabalho do projetista e do desenvolvedor, modelando a aplicação sob a perspectiva das tarefas que o usuário deve desempenhar no AV.
Estas tarefas podem ser agrupadas em tarefas-base que, quando organizadas por características similares, procuram definir as etapas do processo intera- tivo.
Conforme já mencionado, Bowman propõe uma taxonomia para interação que prevê a divisão deste processo em três tarefas elementares, seguindo esta ordem:
Seleção, manipulação e liberação.
Este trabalho procura adaptar essa taxonomia, separando a tarefa de seleção em duas etapas distintas.
A primeira, denominada seleção, é responsável por o processo de indicação do objeto que se deseja manipular.
Já a segunda, denominada anexação, trata do processo de confirmação da seleção.
Ambas apresentam feedbacks que informam o usuário sobre sua execução.
As tarefas de manipulação (posicionamento e orientação) e liberação permanecem inalteradas, seguindo a concepção original de Bowman.
Com base nessas definições, a metodologia de modelagem desenvolvida neste trabalho prevê que cada elemento de uma RdP (lugares, transições, arcos e marcas) represente um determinado papel durante o processo interativo de uma aplicação de RV.
Definição de Papéis Em o modelo desenvolvido, Lugares são elementos que determinam o estado atual da interação.
Eles dispõem de canais de comunicação, capazes apenas de receber e transmitir informações necessárias para o funcionamento da rede, não produzindo dados.
Para que uma tarefa de seleção esteja disponível ao usuário, por exemplo, é necessário que o lugar que representa o estado de seleção contenha dados que indiquem, ao menos, a forma de apontamento, os objetos disponíveis para seleção e que nenhum objeto está sendo manipulado neste momento.
A Figura 20 representa esta situação usando um lugar e uma transição.
Transições são elementos que realizam o processamento, alterando o comportamento da aplicação.
Elas representam, em alto nível, as tarefas elementares de interação.
Assim como os lugares, as transições dispõem de canais de comunicação para a recepção e transmissão de informações por a rede.
No entanto, elas podem consumir dados, bem como gerar e inserir novos dados na rede.
Após esta tarefa, a aplicação passa para o Estado de Manipulação.
Um exemplo de seu funcionamento pode ser representado por o exato momento em que o usuário confirma a seleção de um objeto.
A transição responsável por esta tarefa é então disparada, executando a operação que anexa o objeto ao apontador do usuário.
A Figura 21 representa este exemplo.
Arcos determinam a ordem de execução da rede.
Eles são responsáveis por o transporte de dados entre um lugar e uma transição (e vice-versa), indicando pré e pós-condições para a execução das transições ou para o estabelecimento de um estado.
Conseqüentemente, os arcos definem a ordem de execução das tarefas no AV.
Para manipular um objeto, por exemplo, é necessário antes executar tarefas de seleção e anexação que fornecem informação sobre o objeto escolhido por o usuário.
A Figura 22 apresenta esta seqüência, rotulando os arcos com os dados necessários para a realização de cada tarefa.
Por ser baseado em RdP, a metodologia também exige a definição de marcas iniciais.
Sob o ponto de vista de uma aplicação, estas marcas referem- se à configuração inicial do sistema.
Dados vindos dos dispositivos de entrada e a lista dos objetos geométricos que compõem um AV (fornecidos por a aplicação) podem ser considerados exemplos de marcas iniciais, e precisam ser fornecidos para algum lugar da RdP.
Seguindo o formalismo, deve se especificar ao menos um lugar que guarde estas marcas iniciais.
De acordo com as regras de formação das RdP, cabe lembrar que um nodo (lugar ou transição) não pode ser ligado diretamente a outro nodo de mesmo tipo.
Portanto, sempre entre dois lugares haverá uma transição, da mesma forma que entre duas transições haverá um lugar.
Como forma de sintetizar o que foi apresentado nesta Seção, a Tabela 3 apresenta um resumo do papel que cada elemento da RdP representa durante a especificação do processo interativo.
A partir de os conceitos apresentados nos Capítulos anteriores, já é possível representar as etapas do processo interativo de uma aplicação de RV utilizando a metodologia proposta.
Para tanto, este Capítulo apresenta um exemplo do uso da metodologia.
Um AV que envolve tarefas de seleção e manipulação foi escolhido para servir como plataforma de testes.
Sua descrição permite que as etapas do processo interativo sejam identificadas, modeladas e codificadas.
Testes com o modelo procurando observar o comportamento da aplicação também são apresentados, bem como uma forma de representação hierárquica do sistema.
Plataforma de Teste Para ilustrar o uso desta metodologia na especificação do processo interativo em AVs, foi utilizada uma aplicação de Quebra-Cabeça Virtual, onde o objetivo principal do usuário é escolher e encaixar corretamente cada peça do jogo, realizando para tal tarefas de seleção e manipulação de objetos.
A Figura 24 apresenta as características do cenário virtual.
Inicialmente, as peças do quebracabeça localizam- se misturadas ao lado direito da área de visualização e a caixa para montagem localiza- se à esquerda.
A ordem de escolha dos blocos não é um quesito levado em consideração por a aplicação.
Para interagir, usa- se a técnica de mão virtual.
Esta aplicação foi construída utilizando a linguagem C+ e as bibliotecas OpenGL, GLUT e SmallVR.
Esta última é uma biblioteca gráfica que facilita o desenvolvimento de aplicações de RV, abstraindo diferentes aspectos de implementação como o controle de dispositivos e o gerenciamento de um grafo de cena, não perdendo a estrutura básica de um programa construído com a GLUT.
A SmallVR traz suporte a dispositivos convencionais, como teclado, mouse e monitor e não-convencionais, como rastreadores e óculos de RV.
Para o emprego da metodologia, quatro passos devem ser seguidos por o projetista da aplicação, quais sejam:·
Identificar as etapas do processo interativo (tarefas do AV), de acordo com a taxonomia de decomposição de Bowman, bem como os estados assumidos após a execução de cada tarefa;·
Definir uma RdP com tarefas e estados identificados por o passo anterior;·
Identificar os recursos necessários para cada etapa do processo interativo (prés e póscondições), adicionando marcas aos arcos da RdP do passo anterior;·
Implementar o modelo, utilizando um conjunto de classes especialmente desenvolvido para construir a RdP e controlar sua execução.
Identificando as Etapas do Processo Interativo Analisando a aplicação sob a perspectiva da taxonomia apresentada no Capítulo 4, que divide a tarefa de interação em seleção, anexação, manipulação e liberação, a identificação das tarefas e estados assumidos por a aplicação é feita a seguir (sugere- se acompanhar o texto, observando a Figura 25).
A aplicação inicia no Estado de Seleção, em o qual o usuário move um apontador (mão virtual) no ambiente, procurando por um objeto para seleção.
A partir deste estado, a Tarefa de Seleção realiza um teste de colisão entre o apontador e as peças do quebra-cabeça.
Se a colisão existir (um objeto sendo apontado), o Estado de Anexação é habilitado.
A partir deste ponto, se o usuário pressionar (e não soltar) o botão de seleção, a Tarefa de Anexação é disparada.
Esta tarefa &quot;cola «o objeto ao apontador, estabelecendo o Estado de Manipulação.
Uma vez estabelecido este estado, a Tarefa de Manipulação é disparada, permitindo que o usuário reposicione o objeto usando a mão virtual.
A localização do objeto tem por base a posição da mão em a qual o mesmo está anexado.
Para simplificar a especificação, neste exemplo, algumas operações de feedback normalmente fornecidas ao usuário foram omitidas.
Enquanto a peça está sendo movimentada, uma ação de &quot;soltar «o objeto pode ser realizada.
Se o botão de seleção for solto, o Estado de Liberação é habilitado, o qual imediatamente dispara a Tarefa de Liberação que separa o objeto do apontador, retornando a aplicação ao Estado de Seleção.
Figura 26 ­ RdP representando o detalhamento do processo interativo da aplicação de Quebra-Cabeça Virtual.
Identificando os Recursos para o Processo Interativo Seguindo a metodologia, passa- se a identificar os recursos necessários (dados) para cada etapa do processo interativo, representando- os na RdP como marcas.
Para tanto, os arcos da rede devem ser rotulados com estas marcas que, neste caso, são representadas por ícones.
Os lugares Estado de Seleção, Estado de Anexação, Estado de Manipulação e Estado de Liberação necessitam constantemente de informações sobre o estado dos dispositivos e de variáveis de controle da aplicação.
Para tanto, marcas referentes a estes dados são depositadas nestes lugares.
Em este exemplo, tais marcas referem- se à forma de apontamento, à lista de objetos do cenário e aos dados provenientes dos dispositivos utilizados.
O modelo completo da RdP que representa o processo interativo do Quebra-Cabeça Virtual é apresentado na Figura 27, em a qual os dispositivos são representados por um triângulo, enquanto a aplicação é representada por um hexágono.
Estas formas são meramente ilustrativas e servem apenas para facilitar a compreensão visual do funcionamento da rede.
A execução de um passo da rede consiste na verificação da existência das pré-condições de cada transição, disparando aquelas que estiverem habilitadas a cada ciclo de rendering.
De maneira resumida, um ciclo completo de execução da RdP da Figura 27 pode ser analisado e interpretado da seguinte forma:
Inicialmente, a aplicação e o dispositivo enviam marcas para os lugares Estado de Seleção, Estado de Anexação, Estado de Manipulação e Estado de Liberação.
Como a transição Subtarefa de Indicação recebe todas as marcas necessárias do Estado de Seleção, esta é imediatamente disparada, coletando seus dados (a lista de objetos do cenário, o apontador e uma variável indicando que não existe objeto selecionado).
Esta transição realiza um teste de colisão entre o apontador do usuário e os objetos do cenário.
Havendo colisão com algum objeto, uma nova marca é gerada, representando este objeto.
Em seguida, o lugar Estado de Anexação recebe a marca que representa o objeto selecionado.
Em este estado, ele já dispõe das marcas referentes ao apontador utilizado e de um possível botão pressionado por o usuário.
Quando todos estes dados estiverem presentes neste lugar, a transição Subtarefa de Confirmação é disparada &quot;colando «o objeto selecionado ao apontador do usuário.
A seguir, a marca que representa o objeto selecionado é transmitida para o Estado de Confirmação.
Em estas condições, a Subtarefa de Feedback de Confirmação é disparada, emitindo um sinal sonoro comunicando o sucesso no processo de anexação.
Após isto, uma marca que encapsula o nome do objeto selecionado é transmitida para o Estado de Manipulação, que representa o início do processo de manipulação, onde o usuário pode posicionar corretamente o objeto na caixa de montagem.
Em face de a configuração da rede, este estado sempre dispõe das marcas que representam o apontador (recebido da aplicação), dos dados que chegam do dispositivo de rastreamento e do botão que está sendo pressionado por o usuário.
Assim, com a chegada da marca do objeto selecionado a transição Subtarefa de Posicionamento é disparada.
Esta transição atualiza a posição do objeto, baseada nos dados do rastreador, gerando e enviando uma nova marca com o objeto selecionado, para o Estado de Liberação e para o Estado de Manipulação.
Enquanto o botão de seleção estiver sendo pressionado, a transição Subtarefa de Posicionamento é repetidamente disparada, permitindo ao usuário reposicionar o objeto tantas vezes quanto necessárias.
Se o botão for liberado, o Estado de Manipulação não oferecerá mais as pré-condições necessárias para a Subtarefa de Posicionamento ser disparada.
Ao mesmo tempo, o Estado de Liberação recebe uma marca informando que o usuário soltou o botão, além de as marcas que representam o objeto selecionado e o apontador utilizado.
Nestas circunstâncias, a transição Subtarefa de Separação é disparada.
Esta transição &quot;solta «o objeto no AV em sua nova posição.
Seqüencialmente, o Estado de Separação recebe uma marca que dispara a transição Subtarefa de Feedback de Separação, que emite um sinal sonoro comunicando que o processo de liberação foi realizado com sucesso.
Uma marca é então repassada para o Estado de Seleção, designando que uma nova seleção já pode ser executada.
Implementando o Modelo de RdP Em esta Seção primeiramente são apresentados as classes que permitem a criação da RdP.
Em seguida, uma breve explicação sobre a comunicação entre lugares e transições é apresentada.
Após isto, é mostrada a metodologia para geração de código necessário à execução da RdP.
Uma vez concluída a modelagem, é possível iniciar o procedimento de implementação.
Com o objetivo de automatizar o processo de geração de código, foi desenvolvido um conjunto de classes na linguagem C+, descrito por o diagrama UML apresentado na Figura 28.
Estas classes representam os elementos da RdP, permitindo a implementação dos modelos que representam as tarefas de interação de uma aplicação.
Com elas, é possível simular e controlar o fluxo de atividades do sistema.
Note- se que todas as classes do diagrama herdam as características da classe Object, responsável por armazenar o nome e tipo de cada objeto.
Outra classe importante neste modelo é InteractObj.
Ela define que todas as suas classes derivadas implementem um método run, responsável por o processamento de elemento durante a execução da RdP.
ConectorIn e ConectorOut são as classes que representam os canais de comunicação de lugares e transições, e têm por função guardar em cada elemento os dados trafegados por a RdP.
Já Token é a classe responsável por encapsular os vários tipos de dados que o desenvolvedor utiliza na aplicação.
As classes Place e Transition representam lugares e transições, respectivamente, e podem ter associados a si canais de comunicação.
Para casos que precisam representar sub-redes, dois tipos especiais de classes podem ser utilizadas:
PlacePNPage e TransitionPNPage.
Maiores detalhes referentes ao conjunto de classes apresentado (descrição de métodos e atributos) podem ser vistos no Manual do Usuário, presente no Apêndice B deste trabalho.
Todas as classes apresentadas têm como base o mecanismo de signals e slots para a comunicação entre lugares e transições.
Conforme Trolltech, signals são notificações (mensagens) de um objeto para outro que sinalizam a ocorrência de um determinado evento, enquanto slots são respostas do objeto receptor a estas mensagens.
Sob o paradigma de orientação a objeto, esta resposta é um método a ser executado.
Em este projeto, este mecanismo foi implementado usando a classe QObject do toolkit Qt.
Com este recurso, lugares e transições podem ser implementados como objetos interconectados, permitindo a passagem das marcas durante a simulação da RdP.
Para exemplificar este mecanismo, imagine- se um AV para o treinamento de motoristas.
Um objeto carro possui uma função (slot) que ajusta seu ângulo de direção, e que precisa de um valor de entrada para operar.
Qualquer dispositivo pode ser usado para dirigir o veículo, desde que este forneça um dado (signal) que satisfaça a função do objeto carro.
Assim, basta existir uma comunicação entre o objeto que detém o dado, emitido por o dispositivo, e o objeto carro que possui a função que calcula a direção.
As classes que definem lugares e marcas podem ser diretamente usadas para instanciar objetos.
Arcos são representados por o uso explícito do método connectPN da classe PetriNet.
Já transições devem ser implementadas como novas classes derivadas da classe abstrata Transition, que representa uma transição genérica.
Por ser uma classe abstrata, esta abordagem força o desenvolvedor a codificar alguns métodos essenciais para a simulação do modelo, bem como permite o reuso de classes já desenvolvidas e utilizadas em projetos anteriores.
O reuso de componentes é útil quando procura- se verificar qual técnica de interação melhor se adapta a um AV.
Componentes das técnicas que representam feedbacks, por exemplo, poderiam ser freqüentemente testados e trocados durante o projeto a fim de avaliar qual de eles proporciona ao usuário a melhor percepção do processo interativo.
Para começar a implementação do modelo o projetista deve instanciar um objeto da classe PetriNet.
Este objeto representa a RdP como um todo e é usado para avançar a simulação da rede e para armazenar lugares e transições.
Além disso, dispõe de métodos que encapsulam e recuperam os conteúdos das marcas e realizam a conexão entre os nodos da RdP.
Após o instanciamento do objeto que representa a RdP, criam- se os lugares e transições, além de as marcas que circularão por a rede.
Lugares devem ser instanciados a partir de a classe Place, enquanto transições são instanciadas a partir de classes derivadas da classe Transition, e marcas a partir de a classe Token.
Posteriormente, lugares e transições são adicionados à lista do objeto rede.
Para tanto, o método addElement é utilizado, recebendo como parâmetro o nome atribuído ao elemento por a aplicação e o objeto que o representa.
Com a declaração de todos os conectores, a comunicação entre dois ou mais objetos pode ser estabelecida.
Para tanto, o projetista deve explicitamente conectar- los, definindo o objeto emissor e seu conector, bem como o objeto receptor e respectivo conector.
O método connectPN deve ser utilizado para que este procedimento seja realizado.
Em o caso específico das transições, é preciso instanciar objetos de classes derivadas da classe Transition que representem as tarefas do processo interativo simbolizadas no modelo.
Para o exemplo apresentado por a Figura 26, foram identificadas e criadas as seguintes classes, bem como definidas as suas funcionalidades:·
Indication: Detecta a colisão entre objetos do AV com o apontador do usuário;·
Indication_ Feedback:
Aplica um realce no objeto selecionado;·
Confirmation: Anexa o objeto selecionado ao apontador;·
Confirmation_ Feedback:
Notifica a anexação;·
Positioning: Atualiza a posição do objeto em manipulação;·
Detachment: Libera o objeto do apontador;·
Detachment_ Feedback:
Notifica a liberação.
De forma semelhante aos filtros definidos por Figueroa, a interface da classe abstrata Transition, que dá origem as classes derivadas de transições, obriga o desenvolvedor a implementar três métodos virtuais responsáveis por a coleta (preProcessingTokens) e distribuição (distributeTokens) de marcas e por o processamento dos dados (run) dentro de as transições.
O método preProcessingTokens recebe marcas, efetua o desempacotamento destas, e converteas para tipos de dados aceitos por a aplicação.
Já o método run permite ao desenvolvedor inserir o código específico da aplicação, realizando o que for necessário para o funcionamento do sistema.
Em este estágio, dados podem ter seus valores atualizados, bem como novos dados podem ser gerados.
Finalmente, o método distributeTokens realiza o empacotamento dos dados da aplicação para dentro de marcas, as quais são enviadas para a RdP.
Tome- se como exemplo a criação da classe Indication_ Feedback, que representa a transição Subtarefa de Feedback de Indicação da Figura 27 que tem por função aplicar um realce ao objeto selecionado.
O método run desta classe, primeiramente, cria um objeto geométrico temporário para armazenar um objeto selecionado.
A seguir, uma chamada do método preProcessingTokens é efetuada, a fim de desempacotar o objeto selecionado encapsulado por a marca da RdP (veja Figura 32).
Existindo um objeto selecionado, um realce (borda) é desenhado ao as novas propriedades do objeto selecionado numa marca da RdP (veja Figura 33).
Após todas essas etapas, a execução da RdP pode ser iniciada através da chamada do método run do objeto da classe PetriNet.
Este procedimento executa os métodos run de todos os objetos adicionados à sua lista.
Para garantir a sincronização entre a função de desenho da aplicação e a simulação da RdP, o desenvolvedor precisa evocar o método run da rede no início de cada ciclo de rendering.
Desta forma, a fase de implementação pode ser resumida nesta seqüência de passos:·
Derivar novas classes da classe base Transition para representar tarefas do AV;·
Instanciar o objeto que representa toda a RdP;·
Instanciar os objetos correspondentes aos lugares, transições e marcas;·
Adicionar estes objetos à rede;·
Adicionar conectores para lugares e transições;·
Realizar a ligação entre lugares e transições, através dos conectores;·
Definir o valor das marcas iniciais;·
Definir pontos onde a aplicação atualizará a RdP, através da inserção/ atualização das marcas;·
Executar a RdP.
Testes do Modelo Após modelada e implementada a aplicação de Quebra-Cabeça Virtual utilizando a metodologia proposta, alguns testes foram realizados para observar o comportamento do modelo e da aplicação em situações críticas como dados inválidos, errados ou redundantes.
O modelo previamente apresentado descreve situações válidas que podem ocorrer durante o processo interativo.
Com dados válidos, a aplicação foi testada por diferentes usuários, com duas configurações de dispositivos.
A primeira caracterizou- se por representar um AV nãoimersivo onde a interação era realizada através de dispositivos convencionais (mouse, teclado e monitor).
Já a segunda representou um AV imersivo, com o uso de um óculos de RV (I-glasses!)
e um dispositivo rastreador de posição (Polhemus Isotrack II), fixado a um mouse.
Em ambas, a RdP executou apropriadamente.
No entanto, algumas situações inválidas podem ocorrer impedindo a execução da rede e, conseqüentemente, bloqueando a interação no AV.
Para tanto, é importante verificar se o modelo comporta- se adequadamente nestes casos, não atuando de maneira inesperada.
O primeiro teste procurou simular um AV vazio, sem objetos para seleção.
Desta forma, quando o usuário pressionasse o botão de seleção para indicar um objeto, nada poderia acontecer.
De o ponto de vista do modelo, esta situação pode ser representada por a exclusão da marca Lista de Objetos da RdP (veja Figura 34).
Com esta configuração, a RdP continuou executando normalmente, porém, seu novo comportamento impediu que as transições Subtarefa de Indicação e Subtarefa de Feedback de Indicação fossem disparadas, como era esperado.
Em uma segunda simulação, optou- se por a exclusão do objeto apontador, representado na RdP por a ausência da marca Mão Virtual (veja Figura 35).
Assim como na situação anterior, a rede continuou executando normalmente, porém impedindo o usuário de realizar qualquer tarefa no AV, novamente conforme esperado.
Manipulação (veja Figura 36).
Conforme esperado, estes dados foram descartados quando a transição Subtarefa de Posicionamento era disparada.
O objetivo do último teste foi simular uma situação onde não houvesse comunicação entre o AV e a RdP (veja Figura 37).
Como conseqüência, o conteúdo das marcas da RdP era vazio, o que impedia a execução da aplicação pois nenhuma transição era habilitada.
Modelagem Hierárquica A modelagem hierárquica de uma aplicação usando RdP permite descrever o sistema em diferentes níveis de abstração, simplificando a representação e oferecendo diferentes visões do mesmo sistema.
Além disso, a existência de níveis de hierarquia pode ser útil para tornar mais claro o funcionamento do modelo como, por exemplo, em situações onde um conjunto complexo de operações necessite de uma representação simplicada, num único módulo como uma técnica de interação, por exemplo.
A título de exemplo, imagine- se que seja interessante agrupar numa única transição todo o processo de seleção.
Desta forma, as transições Subtarefa de Indicação, Subtarefa de Feedback de Indicação, Subtarefa de Confirmação e Subtarefa de Feedback de Confirmação, e os lugares Estado de Indicação, Estado de Confirmação e Estado de Anexação podem ser agrupados como uma única entidade, denominada Tarefa de Seleção.
As transições e lugares hachurados da Figura 38 destacam o conjunto a ser agrupado.
Para representar um subconjunto de lugares e transições (sub-redes), uma nova entidade precisa ser definida.
Em esta metodologia, estas entidades são chamadas de páginas e podem ser instanciadas a partir de as classes PlacePage e TransitionPage.
A primeira abstrai uma rede que inicia e termina por lugares, enquanto a segunda encapsula uma rede que inicia e termina por transições.
Note- se que para manter a consistência da RdP é necessário que a página inicie e termine por elementos da mesma classe.
Para este exemplo, optou- se por a criação de um objeto do tipo TransitionPage para representar a Tarefa de Seleção.
Posteriormente, este objeto foi adicionado a RdP, substituindo os elementos que agora fazem parte de sua lista.
As conexões entre os elementos encapsulados por esta página permanecem inalteradas, com exceção das transições que localizam- se nos extremos da sub-rede e dos lugares que recebem informações vindas da aplicação ou dos dispositivos.
Isto ocorre pois os &quot;antigos «conectores, a quem estes elementos estavam conectados, precisam agora ficar diretamente ligados aos conectores da página.
Tome- se como exemplos as Figuras 40 e 41.
Em a Figura 40, o conector objs do lugar Estado de Seleção era ligado ao conector objs da transição Subtarefa de Indicação, assim como o conector objSel da transição Subtarefa de Feedback de Confirmação era ligado ao conector objSel do lugar Estado de Manipulação.
Agora, como mostra a Figura 41, com a modelagem hierárquica o conector objs do lugar Estado de Seleção passa a ligar- se ao conector C1 da página Tarefa de Seleção, enquanto o conector C2 da página Tarefa de Seleção liga- se ao conector objSel do lugar Estado de Manipulação.
Para estabelecer a comunicação entre as hierarquias da RdP, as classes PlacePage e TransitionPage oferecem dois métodos responsáveis por &quot;revelar «(expor) à rede os conectores da página.
O método exposeIn revela para um elemento da sub-rede o valor depositado num conector de entrada da página, enquanto que o método exposeOut revela para a página um valor depositado num conector de saída de um elemento da sub-rede.
A Figura 42 apresenta um exemplo simples de geração de código do modelo hierárquico.
Em este exemplo, cria- se uma página onde elementos da RdP são à ela adicionados.
A seguir, definem- se os conectores de entrada e saída desta página, bem como estabelecem- se as conexões entre ela e os elementos da RdP de nível hierárquico superior.
Após estes procedimentos, estabelece- se a comunicação entre as hierarquias utilizando os métodos exposeIn e exposeOut.
Em a linha 09 o conector de entrada C1 da página Tarefa de Seleção (tPage) expõe seu conteúdo ao conector de entrada objs da transição Subtarefa de Indicação (tInd), enquanto que na linha 10 o conector de saída objSel da transição Subtarefa de Feedback de Confirmação (tFConf) expõe seu conteúdo ao conector de saída C2 da página Tarefa de Seleção (tPage).
Como forma de testar a aplicação com o uso desta RdP-H, os mesmos testes vistos na Seção 5.6 foram empregados.
Conforme esperado, os mesmos resultados foram obtidos, comprovando a eficácia da nova representação.
Finalizando, a Tabela 5 apresenta uma adaptação da Tabela 2, incluindo as características e recursos oferecidos por a nova metodologia (com base no estudo de caso realizado).
Este trabalho definiu uma metodologia para especificar tarefas de interação de uma aplicação de RV, utilizando o formalismo de RdP como base no processo da modelagem de software.
Para validar- la, um AV foi construído utilizando a metodologia.
Esta aplicação foi testada, e comportou- se conforme esperado tanto em situações normais, quanto em situações especiais, como naquelas em que a aplicação não dispunha dos dados necessários para a execução do programa.
A expectativa é que esta metodologia, à medida que vá sendo empregada, permita que tarefas e técnicas de interação possam tornar- se componentes disponíveis para novos sistemas, uma vez que sejam testadas e simuladas previamente.
Outro objetivo desta metodologia é auxiliar no desenvolvimento de aplicações, aproximando a etapa de concepção e projeto de AVs à etapa de desenvolvimento, oferecendo recursos para implementação, testes e documentação do sistema.
Além disso, é possível desvincular da metodologia a taxonomia de Bowman, adotando outras formas de categorização que preservem a modelagem da aplicação sob a perspectiva de tarefas do usuário.
Apesar de o processo de implementação apresentado ter usufruído dos recursos de uma biblioteca gráfica específica, não existe impedimento para o uso de outras bibliotecas.
Os passos da metodologia (e o pacote de classes desenvolvido) são independentes das funcionalidades gráficas e podem ser adaptadas conforme as necessidades de outras ferramentas, como, por exemplo, OpenSceneGraph, Crystal Space e X3D.
A possibilidade de importar arquivos de editores gráficos como o Dia e o yEd está sendo analisada.
Estes editores oferecem recursos para a construção de diferentes diagramas (entre os quais, RdP), além de armazenar a descrição destes modelos em formato XML.
Como trabalhos futuros, sugere- se construir um editor gráfico capaz de importar estes modelos e, a partir de eles, derivar o código-fonte da aplicação automaticamente.
Como a aplicação é controlada por os estágios de simulação da RdP, seria interessante também apresentar ao projetista o processo de execução do programa num gráfico animado, sobreposto ao grafo da RdP, e em paralelo ao uso da aplicação.
De a mesma forma, uma idéia interessante seria incorporar esta metodologia a um framework de RV, tornando- o uma plataforma completa de desenvolvimento.
Em este framework de interação, recursos para análise, projeto, desenvolvimento e avaliação de protótipos de AVs poderiam estar incorporados, permitindo que falhas de projeto fossem rapidamente detectadas e o tempo de construção dos sistemas fosse reduzido.
Em este sentido, o framework ViRAL (Virtual Reality Abstract Layer) está sendo analisado para incorporar esta metodologia, uma vez que o mesmo já utiliza um conjunto extensível de componentes de software que facilitam o controle, a comunicação e a organização dos módulos de um sistema.
Com a introdução desta metodologia, técnicas de interação também poderiam ser representadas e oferecidas ao projetista como componentes, assim como já acontece com dispositivos, avatares e AVs.
