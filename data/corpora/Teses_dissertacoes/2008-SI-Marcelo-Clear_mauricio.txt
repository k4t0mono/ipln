A Web Semântica provê acesso a informações distribuídas e heterogêneas, permitindo aos softwares a mediação entre as necessidades dos usuários e as fontes de informações disponíveis.
Os agentes de software são uma das tecnologias mais promissoras para o desenvolvimento da Web Semântica.
Entretanto, as tecnologias baseadas em agentes não serão difundidas a menos que existam infra-estruturas adequadas para o desenvolvimento de sistemas multiagentes (SMAs).
Tornar agentes de software uma abstração prática, capaz de lidar com ontologias e de ser integrado com as ferramentas Web existentes são desafios ainda existentes.
Este trabalho propõe uma arquitetura para ser integrada a navegadores e a servidores Web para permitir a criação de domínios semânticos onde os agentes de software vivem, estendendo a Web, sem interferir na sua estrutura atual.
Estes domínios alteram o atual paradigma request-response utilizado na Web para um paradigma híbrido requestresponse/ peer- to peer.
Os agentes vivendo nas máquinas cliente em domínios semânticos associados a navegadores Web serão capazes de comunicar- se com outros agentes em outros domínios e processarem conteúdos anotados semanticamente em páginas Web.
Palavras-chave: Web Semântica, Sistemas Multiagentes, Infra-estrutura de agentes.
A World Wide Web foi proposta como um projeto de desenvolvimento para o CERN (European Organization for Nuclear Research) em 1989, por Tim Berners-Lee, onde foi criado um sistema universal para a interconexão de informações.
Um requisito básico para esse sistema era uma linguagem para a formatação da informação em hipertextos, o que motivou a criação da linguagem Html por Tim Berners-Lee.
Em 1991 já havia um navegador portável e disponível para distribuição capaz de trabalhar com a linguagem Html.
O Netscape1 impulsionou a Web em 1994, através da criação de um navegador comercial.
Em a mesma época, o Yahoo2 foi criado e fornecia um indexador de páginas Web.
Existiam também mecanismos como o WebCrawler, que era um mecanismo de busca e possuía cerca de 2500 servidores no mundo todo.
Já no final de 1995, haviam aproximadamente 73500 servidores Web em todo o mundo, e a Microsoft fornecia uma versão do Internet Explorer3.
Em contraste, a proposta da Web Semântica tornou- se popular em 2001 quando foi reconhecido que a Web foi construída para consumo humano, e embora tudo em ela seja lido por máquina, os seus dados não estão numa forma que permita o raciocínio automatizado.
Portanto, a forma como a semântica contida em páginas Web é representada só faz sentido para os seres humanos, tornando difícil a automatização do processamento das fontes de informação na Web, e também por causa de o grande volume de informações em ela contida, torna- se impossível o seu gerenciamento manualmente.
Com o rápido crescimento da Web, torna- se cada vez mais difícil a manipulação das informações contidas nas suas páginas de maneira a gerar um resultado satisfatório.
Em muitos casos, para que possamos melhorar a coleta de informação na Web, são necessários mecanismos de busca complexos.
Mesmo com tais mecanismos, os resultados obtidos requerem ainda uma análise por o usuário para que este possa extrair a informação desejada.
A geração de conteúdos na Web de maneira automática a partir de as bases de dados não inclui uma semântica formal para a sua representação.
As páginas Web são construídas utilizando- se a linguagem Html, que é a linguagem predominante nos dias de hoje.
Esta linguagem não possui recursos suficientes para permitir a atribuição de significado para as informações contidas nas páginas Web e não permite a criação de modelos semânticos, devido a os marcadores Html representarem apenas a descrição de como os dados contidos na página devem ser exibidos.
A Web Semântica é uma iniciativa que busca a definição de formatos padrão para exprimir informações numa forma processável por a máquina.
A idéia básica é criar formas de explicitar o relacionamento de conceitos de vários domínios de conhecimento, permitindo que máquinas possam trabalhar sobre estes conceitos, relacionando- os e inferindo novos conceitos.
Durante os últimos anos muitas tecnologias relacionadas a Web Semântica tem emergido ou tem sido elaboradas.
A W3 C4, que é o principal consórcio responsável por os padrões Web, tem trabalhado intensivamente nos padrões semânticos, como o RDF e o OWL.
Estes padrões oferecem a criação de uma base sólida para aplicações semânticas e tem implicado num significativo avanço da Web Semântica de um nível de pesquisa para sua aplicação na indústria para a construção de aplicações de uma nova geração.
Devido a a grande quantidade de informações disponibilizadas na Web, torna- se evidente a necessidade de mecanismos ­ aplicações ­ que possam nos auxiliar na coleta e análise destas informações, bem como seu processamento automático.
Em a Web semântica, os agentes de software são usados como entidades autônomas capazes de consumir automaticamente os conteúdos publicados.
De a mesma forma, os computadores necessitam ter acesso a coleções estruturadas de informações (dados e meta-dados) e a conjuntos de regras de inferência que os auxiliem no processo de dedução automática para que seja administrado o raciocínio automatizado, ou seja, a representação do conhecimento.
Para possibilitar a construção de sistemas abertos e flexíveis que utilizam a infra-estrutura da Web, uma plataforma de agentes deve prover algumas características como distribuição de processamento e integração com ferramentas existentes (incluindo navegadores Web).
Estas qualidades são importantes para permitir uma fácil combinação entre a tecnologia de agentes e a Web, facilitando sua adoção.
Este trabalho apresenta uma arquitetura para a execução de aplicações baseadas em agentes na Web Semântica, por meio de a integração de tecnologias de criação de agentes, formas de representação de conhecimento e ferramentas atuais utilizadas na Web.
Esta arquitetura integra o framework SemantiCore a navegadores e servidores Web, permitindo a interação direta entre os usuários e os agentes associados ao conteúdo num determinado domínio.
Em os últimos anos têm crescido o número de iniciativas acadêmicas e industriais para atender os requisitos da Web Semântica.
Ferramentas de anotação de conteúdos, editores de ontologias e mecanismos de inferência tem sido criados para permitir o desenvolvimento de aplicações que podem beneficiar- se das características da Web Semântica.
Nenhuma destas iniciativas provê uma combinação de todos os esforços já realizados que permita o desenvolvimento de aplicações na Web Semântica.
Com base nesta perspectiva, surge a seguinte questão de pesquisa:
&quot;é possível criar uma arquitetura que integre as tecnologias existentes para prover transparência na execução de aplicações baseadas em agentes para a Web Semântica?».
Definida a questão de pesquisa, se faz necessária a definição dos objetivos do trabalho.
A seguir são apresentados o objetivo geral e os objetivos específicos deste trabalho.
O objetivo geral deste trabalho é a construção de uma arquitetura integrada a navegadores e a servidores Web.
Através da integração com o framework SemantiCore, que possui como abstração a construção de sistemas mutliagentes abertos na Web, e das tecnologias e padrões da Web Semântica, a arquitetura visa permitir a criação de ambientes onde os agentes de software vivem, estendendo a Web, sem interferir na sua estrutura atual.
Os objetivos específicos são os seguintes:
Aprofundar o estudo teórico sobre trabalhos relacionados ao problema abordado.
Apontar a alteração necessária no protocolo Http para permitir a identificação automática de ambientes de agentes.
Definir os elementos da arquitetura.
Integrar a arquitetura proposta às ferramentas Web, como navegadores e servidores de aplicação.
Mapear e implementar os elementos da arquitetura proposta.
Projetar e implementar uma aplicação que possibilite a verificação das características da arquitetura proposta.
Este trabalho está dividido em três partes:
A fundamentação teórica, a apresentação da proposta, e a demonstração da aplicabilidade desta proposta.
O Capítulo 2 apresenta a fundamentação teórica necessária para um bom entendimento do trabalho, onde são esclarecidos aspectos referentes à Web Semântica e suas tecnologias associadas, Agentes de software e Sistemas Multiagentes e o framework Semanticore.
Em o Capítulo 3 são apresentados alguns trabalhos encontrados na literatura que visam apoiar o desenvolvimento da Web Semântica, e que se relacionam com a presente proposta.
Em o Capítulo 4 é descrita a arquitetura proposta.
Já no Capítulo 5 é apresentado o protótipo desenvolvido que mapeia as características da arquitetura, e um exemplo de uso da proposta, através do desenvolvimento de um cenário de exemplo, que busca demonstrar todas as características da proposta.
Para a apresentação deste exemplo, são mostrados trechos de código e explicações contextualizadas sobre os elementos da arquitetura.
Por fim, no Em este capítulo, será apresentado o embasamento teórico referente a os principais conceitos e características de Web Semântica e suas tecnologias, agentes de software e sistemas multiagentes, e o framework SemantiCore.
A Web Semântica provê uma estrutura que permite o compartilhamento e reutilização dos dados.
Ela é um esforço conduzido por a W3C com a participação de um grande número de pesquisadores e parceiros.
Um dos objetivos da Web Semântica é desenvolver tecnologias e linguagens de representação de conhecimento legíveis para as máquinas, adicionando informações sobre o conteúdo contido nas páginas Web atuais e em futuras para que esta informação seja manipulável computacionalmente.
De entre os objetivos está o desenvolvimento de um modelo tecnológico que permita o compartilhamento global de conhecimento assistido por máquinas.
A Web Semântica deve ser capaz de suportar serviços automatizados baseados em descrições formais da semântica das informações.
A semântica é vista como uma alternativa na busca de informações relevantes, uma vez que os mecanismos de busca baseiam- se em técnicas predominantemente sintáticas, não atendendo muitas vezes as reais necessidades do usuário.
A Web Semântica não é uma Web alternativa, mas uma extensão da atual, onde a informação é recuperada através de uma semântica bem definida, habilitando uma cooperação entre o trabalho humano e computadores.
Ela é baseada numa estrutura descentralizada, onde agentes de software possam atuar em ambientes de diversas estruturas, compreendendo e realizando sofisticadas tarefas para os usuários através da valoração semântica destes conteúdos.
Estas estruturas são independentes do tipo de mídia, isto é, podem ser textos, sons, imagens, vídeos ou gráficos.
De modo a organizar a informação na Internet, pesquisadores de inteligência artificial vêm propondo uma série de modelos.
A idéia central é categorizar a informação de maneira padronizada, facilitando seu acesso.
No entanto, acredita- se que o maior fator de sucesso do crescimento da internet seja a liberdade que ela fornece a seus usuários.
Esta liberdade vai desde sites básicos, construídos por leigos, e que contêm informações triviais;
Até os mais sofisticados sites, construídos por grandes empresas, e que utilizam diversas tecnologias Web.
Para a construção da Web Semântica, existem inúmeros esforços para padronização de tecnologias, bem como o XML, o RDF, as arquiteturas de meta-dados, formas de representação de ontologias, agentes inteligentes, entre outras.
As ontologias, em ciência da computação, foram adotadas na inteligência artificial para facilitar o compartilhamento e reuso de conhecimento.
Atualmente, seu uso começa a ser expandido para áreas como integração de informações, sistemas cooperativos, engenharia de sistemas baseados em agentes e comércio eletrônico.
As ontologias são modelos conceituais que capturam e tornam explícito o vocabulário utilizado em aplicações semânticas, garantindo dessa forma, a comunicação livre de ambigüidades.
O trabalho eficiente e efetivo com a Web Semântica deve ser suportado por ferramentas avançadas que permitam o uso total destas tecnologias.
Em particular, isto requer os seguintes elementos:
Linguagens formais para expressarmos e representarmos ontologias.
Editores e construção semi-automática de ontologias.
Reuso e unificação de ontologias (ambientes que facilitem a criação de novas ontologias através do reuso de ontologias já existentes).
Ferramentas de anotação que associem informações não estruturadas e semi-estruturadas através de metadados.
Ferramentas para navegação e acesso a informação que permita o acesso inteligente a informação por usuários humanos.
Serviços de tradução e integração de diferentes ontologias que realizam intercâmbio entre padrões (especialmente em comércio eletrônico).
Destacadas algumas das principais características da Web Semântica, na próxima seção serão apresentados alguns desafios de pesquisa em Web Semântica.
A Web continua a crescer e novas tecnologias, modos de interação e aplicações estão sendo desenvolvidas.
As tecnologias da Web Semântica destinam- se a proporcionar um espaço compartilhado de informações semânticas, mudando qualitativamente as experiências na Web.
A Web Semântica possui ainda algumas tecnologias que não são maduras em diversas áreas.
Portanto, existem alguns problemas que ainda são encontrados, ocasionando novas oportunidades e desafios na pesquisa.
Tais desafios na Web Semântica incluem e não se limitam a:
Criação e gerenciamento de conteúdo semântico, construção de aplicações robustas e escaláveis, e organização e integração de informações de diferentes fontes, tornando a semântica explícita a fim de melhorar nossa experiência geral com tecnologias de informação e assim, nos permitindo utilizar a grande quantidade de informação que está disponível em forma digital para enfrentarmos as nossas tarefas quotidianas.
O desenvolvimento da Web Semântica envolve muitas áreas da ciência da computação, incluindo:
Inteligência Artificial:
Mecanismos de raciocínio, linguagens de representação de conhecimento, aprendizado, descoberta de recursos, etc..
Web: Profiling, identificação, linguagens baseadas em XML e tecnologias.
Agentes de software:
Computação distribuída, linguagens de comunicação e interação e protocolos de cooperação.
Teoria da computação e lógica (computacional):
Linguagens formais, prova e teoremas.
Lingüística computacional e reconhecimento de padrões:
Aquisição de conhecimento de fontes primárias, o uso de recursos léxicos para o desenvolvimento de ontologias, etc..
Engenharia de documentos e bibliotecas digitais:
Transformação, marcação e indexação.
Interfaces humano-computador:
Trabalho cooperativo suportado por computador, avaliação de fatores de trabalho e estudos de comunicação.
Ciências sociais e humanas:
Experimentos de validação de ontologias e processamento de informações sociais.
Acima de tudo, o desenvolvimento da Web Semântica deve considerar as atuais necessidades da Web, e que requerem soluções em diferentes áreas, como por exemplo, a personalização (e desse modo as questões de privacidade), a mobilidade (questões de confiabilidade) e a publicação (questões de segurança).
Estas questões e tópicos são bastante tradicionais, mas a Web Semântica lida com eles ao extremo.
Contudo, para a Web Semântica acontecer ela necessita mais do que somente tecnologias, questões econômicas e sociais também são importantes.
Esta seção apresenta o levantamento das pesquisas realizadas em Web Semântica nos últimos anos, apresentando uma visão da relevância e atualidade da área.
Serão apresentados alguns dados coletados das principais conferências da área, bem como a categorização dos principais tópicos de pesquisa sugeridos.
A tabela 1 apresenta os tópicos de pesquisa sugeridos para a conferência internacional da Www (International World Wide Web Conference).
Estes tópicos foram coletados nas conferências dos anos de 2005 a 2008.
A tabela apresenta cada tópico de pesquisa numa linha da tabela.
As demais colunas representam a marcação do ano em que este tópico foi abordado por a conferência.
A tabela 2 mostra os tópicos de pesquisa sugeridos para a conferência internacional de Web Semântica (International Semantic Web Conference -- ISWC).
Estes tópicos foram coletados nas conferências dos anos de 2004 a 2007.
A tabela apresenta cada tópico de pesquisa numa linha da tabela.
As demais colunas representam a marcação do ano em que este tópico foi abordado por a conferência.
Através destes dados podemos ter uma noção das tendências da pesquisa em Web Semântica onde, os temas tendem a se adaptarem às necessidades tecnológicas do momento.
Em este caso, os congressos solicitam contribuições que demonstram como as tecnologias semânticas podem ser exploradas na Web.
Em geral, são esperados os seguintes objetivos nas pesquisas:
Mostrar como as tecnologias semânticas adicionam valor para a Web, conseguindo atender requisitos que as tecnologias atuais não atendem;
Apresentar novas tecnologias para a Web Semântica ou novas aplicações de tecnologias semânticas existentes que provejam novos níveis de funcionalidades na Web;
Verificar o efeito das comunidades na Web pode ser explorado para gerar semântica;
Demonstrar como tendências emergentes na Web tais como wikis, softwares sociais, entre outros, podem ser enriquecidos com as tecnologias semânticas.
O enquadramento do presente trabalho, em relação a os tópicos de pesquisa dos congressos abordados, pode ser visto como:
&quot;Distributed Architectures for the Semantic Web «no congresso Www, e &quot;Semantic Web Middleware «no congresso ISWC.
Tabela 2 -- Conferência ISWC:
Todas as iniciativas contam com tecnologias básicas para o funcionamento da Web Semântica.
As próximas seções apresentam estas tecnologias para o entendimento da infra-estrutura da Web Semântica.
O XML é a linguagem universal de meta-dados.
Ela provê uma estrutura uniforme e um conjunto de ferramentas que possibilitam a troca de dados e meta-dados entre aplicações.
As linguagens de marcação utilizam etiquetas para que as informações possam ser adicionadas aos documentos, podendo assim indicar a maneira como estas informações serão exibidas, e até mesmo, atribuir um valor (agregar semântica) às palavras contidas no texto.
A Html é uma linguagem padrão para a codificação das páginas Web.
Ela fornece apenas a informação de como a página Web deve ser exibida, não fornecendo qualquer informação semântica sobre o texto que está em ela contido.
Considere o seguinte exemplo de página Html, conforme mostrado na Figura 1.
A figura mostra a codificação de uma página Web, onde são descritos somente marcadores de formatação de texto, como o &quot;e o «Eles indicam somente o modo como o texto contido em eles será exibido.
A mesma informação pode ser representada em XML, como mostrado na Figura 2.
Conforme a figura, podemos perceber que a descrição em XML expressa as informações sobre uma determinada página Web, através da definição do marcador &quot;webPage», e também possui os elementos &quot;title «e &quot;author», que respectivamente descrevem o título e o autor da página.
Ambas as linguagens Html e XML utilizam linguagem de marcação, sendo descrita por tags.
Estas podem ser aninhadas (tags dentro de tags).
Em o XML, todas as tags necessitam ser fechadas (por exemplo, ao abrir a tag a mesma deve ser fechada utilizando Em Html, tags como que indicam quebra de linha, não necessitam ser fechada.
A linguagem XML oferece uma distinção da informação, separando o conteúdo da estruturação do documento.
Ela possibilita a criação ilimitada de marcadores, permitindo ao usuário definir inúmeros tipos.
A seguir, serão apresentados os componentes da linguagem XML.
Os elementos XML representam as &quot;coisas «sobre as quais o documento fala, como uma página Web, um autor, e um título.
Eles formam os principais conceitos de um documento XML.
Um elemento consiste de uma abertura do marcador, o conteúdo, e o fechamento do marcador.
A Figura 3 apresenta um exemplo de elemento em XML.
Um elemento vazio não necessariamente é sem significado, porque este pode ter alguma propriedade em termos de atributo.
Um atributo é o par nome-valor dentro de um marcador aberto de um elemento.
Em a Figura 4 é apresentado um exemplo, onde temos os atributos &quot;email «e &quot;country», ambos com seus valores.
O uso de elementos com ou sem atributos é frequentemente uma questão de gosto.
No entanto, atributos não podem ser aninhados.
O objetivo desta seção é apresentar em linhas gerais as características básicas do XMLS, não sendo detalhados todos os componentes da linguagem.
A XML Schema é uma linguagem que provê um meio para a definição de estruturas, conteúdo e semântica para documentos XML.
Ela tornou- se recomendação da W3C em maio de 2001.
A XMLS é análoga a um schema em banco de dados, onde são definidos os nomes das colunas e os tipos de dados na tabela do banco de dados.
Como mostrado na Figura 5, temos dois tipos de documento:
O documento que representa o schema (ou documento de definição), e múltiplos documentos de instância conforme o schema.
Ambos os documentos e instâncias do schema usam a sintaxe XML (marcadores, elementos e atributos).
A XMLS permite a validação das instâncias para garantir a precisão e restrição dos valores dos campos e estrutura dos documentos em tempo de criação.
A precisão dos campos é verificada contra o tipo do campo;
Por exemplo, o campo &quot;idade «de uma pessoa deve conter apenas números, conforme definição do tipo do campo como &quot;integer».
Considere o exemplo de declaração a seguir, onde é declarado um elemento e seu nome, e a restrição de valores para ele.
Em o exemplo, é declarado o elemento chamado &quot;author», e seu tipo como sendo &quot;string», permitindo ao elemento ter atribuído qualquer valor textual.
Em o documento XML de instância, o mesmo elemento poderia ser descrito como:
O XML provê uma estrutura uniforme e um conjunto de ferramentas que possibilitam a troca de dados e meta-dados entre aplicações.
Entretanto, o XML não traduz semântica, mas apenas a estrutura dos dados.
Por exemplo, tags aninhadas não dizem nada em especial, como exemplificado na Figura 6.
Qual seria a resposta para a consulta &quot;recupere todos os membros acadêmicos&quot;?
Sintaticamente a resposta seria Maria.
Semanticamente Maria, Vitor e Paulo.
Conseguimos chegar a uma resposta semântica porque o ser humano é capaz de realizar a associação com base no modelo.
Mas como formalizar essa semântica para o software?
O RDF é uma linguagem declarativa que fornece uma maneira padronizada de utilizar o XML para representar metadados no formato de sentenças sobre propriedades e relacionamentos entre itens na Web.
Esses itens, chamados recursos, podem ser virtualmente qualquer objeto (textos, figuras, vídeos e outros), desde que possuam uma URI.
O RDF é independente de domínio, ou seja, nenhuma informação específica de domínio é usada.
A terminologia do domínio é escrita em RDFS (RDF Schema).
Os conceitos fundamentais do RDF são os recursos (RDF resources), as propriedades (RDF properties) e as sentenças (RDF statements).
Podemos pensar num recurso como um objeto, algo sobre a qual se deseja falar.
Recursos podem ser autores, livros, lugares, pessoas, hotéis, salas, etc..
Todo recurso possui uma URI (Uniform Resource Identifier), ou algum outro tipo de identificador que garanta a unicidade.
As propriedades são um tipo especial de recurso.
Elas descrevem as relações entre os recursos, como por exemplo, &quot;escrito por», &quot;possui idade», &quot;possui título», e assim por diante.
As propriedades em RDF também são identificadas por Uris.
A idéia de usar Uris para identificar os recursos e as suas relações é muito importante quando se trabalha num contexto global, como a Web, para que possamos garantir a unicidade de um recurso.
As sentenças indicam a propriedade de um recurso.
Um recurso é uma tripla objeto-atributo- valor», que consiste de um recurso, uma propriedade e um valor.
Valores podem ser tanto recursos como literais.
Os literais são valores atômicos, como por exemplo, os tipos primitivos de dados.
Um exemplo de uma sentença é:
A mesma sentença poderia ser descrita utilizando uma tripla RDF, como mostrado abaixo:
Podemos pensar da tripla (x, P, y) como uma fórmula lógica P (x, y), onde o predicado binário P relata o objeto x para o objeto y.
De fato, RDF oferece somente predicados binários (propriedades).
Note que a propriedade &quot;site-- owner «é identificada por uma URL.
As triplas RDF podem ser representadas em grafos, facilitando a visualização e a compreensão por humanos, como mostrado na Figura 8, que representa o exemplo anterior através de um grafo.
A visão da Web Semântica requer representações que possam ser acessíveis e processadas computacionalmente.
A linguagem RDF associa cada propriedade que o esquema define através da linguagem XML e de namespaces (Uris).
A Figura 9 mostra um exemplo de código utilizando RDF.
O código é iniciado com a declaração do prólogo, indicando que o RDF é baseado em XML.
As linhas 2 a 11 contêm as expressões RDF e utilizam o vocabulário definido por os namespaces especificados por &quot;xmlns «(linhas 2, 3 e 4).
O namespace na linha 2 refere- se à sintaxe padrão do RDF e os da linha 3 e 4 referem- se ao vocabulário especificado por as URLs descritas.
A tag (linha 5) é utilizada para referenciar recurso da Web que terá seus meta-dados descritos em O RDF é uma linguagem universal que possibilita aos usuários a descrição de recursos usando um vocabulário próprio.
Ela é genérica e não presume nenhum domínio, e para a especificação da semântica de um domínio, usa- se o RDF Schema.
O RDFS também permite especificar os elementos relacionados a um domínio de discurso.
Ele permite a declaração de classes de indivíduos, ou seja, conjuntos de indivíduos.
Em este trabalho não serão apresentadas todas as definições da linguagem, mas somente as principais para que possamos compreender como funciona a representação de conhecimento em RDF.
Uma classe pode ser vista como um conjunto de elementos.
Objetos individuais que pertencem a uma classe são referenciados como instâncias da classe, e descrevem objetos que compartilham as mesmas características.
As propriedades descrevem as relações comuns a um conjunto de objetos.
O conceito de herança em RDF é similar a OO (paradigma orientado a objetos).
Por exemplo, todos os professores são membros acadêmicos.
Podemos dizer que &quot;professor «é uma subclasse de &quot;membro acadêmico», ou a equivalência, onde &quot;membro acadêmico «é superclasse de &quot;professor», conforme ilustrado na Figura 10.
Uma classe pode ter múltiplas superclasses (Herança múltipla).
Sendo neste exemplo, a classe &quot;Professor «e &quot;Professor associado «como sendo subclasse de &quot;Membro acadêmico».
As ontologias são desenvolvidas com o intuito de facilitar o compartilhamento e reuso de informações.
De entre as várias definições para o termo ontologia existentes na literatura, a mais citada é a oferecida por Thomas Gruber, onde:
&quot;Uma ontologia é uma especificação explícita de uma conceituação».
Em a Web Semântica, é através do uso de ontologias que a semântica de um domínio é representada.
Em geral uma ontologia descreve formalmente um domínio de discurso.
Tipicamente, uma ontologia consiste de uma lista finita de termos e relacionamentos entre estes termos.
Os termos denotam importantes conceitos (classes de objetos) do domínio.
Por exemplo, no âmbito de uma Universidade, professores, alunos, administradores, cursos e disciplinas são conceitos importantes.
Em o contexto da Web Semântica, as ontologias provêem uma compreensão compartilhada de um domínio.
Para tal compartilhamento, é necessária a superação de diferenças nas terminologias.
Por exemplo, diferentes aplicações podem fazer uso de um mesmo termo de formas distintas.
Este problema pode ser resolvido por a definição de um mapeamento direto entre ontologias.
O mapeamento entre ontologias ainda é um dos grandes desafios de pesquisa em ontologias e Web Semântica.
As ontologias são úteis ainda para melhorar a precisão de buscas na Web.
Os mecanismos de busca podem olhar para as páginas que se referenciam a um conceito preciso numa ontologia ao invés de coletarem todas as páginas que contêm ocorrências deste conceito, geralmente de forma ambígua, por ocorrência de palavras-chave.
De esta maneira, diferenças entre terminologias de páginas Web e buscas podem ser superadas.
Para se definir e manipular ontologias sugere- se a utilização de linguagens que suportem estruturas para a representação do conhecimento.
Esta representação é realizada através da descrição formal de um conjunto de termos sobre um domínio específico.
A definição de uma linguagem é necessária para a representação e descrição formal da estrutura que especifica uma conceituação.
Existem várias formas de representar ontologias por meio de linguagens de marcação.
De essa forma, são necessários alguns dos seguintes requisitos para uma linguagem de definição de ontologias:
Uma sintaxe bem definida;
Uma semântica formal;
Conveniência de expressão;
Suporte ao raciocínio;
Poder de expressividade.
A linguagem OWL é recomendada por a W3C para a descrição de ontologias.
Ela é projetada para ser usada quando a informação contida num documento precisa ser processada por aplicações.
Ela apresenta maior expressividade semântica do que o XML, o RDF e o RDF Schema, fornecendo um vocabulário amplo para a descrição de propriedades e classes.
Em ela existem marcadores para a definição de:
Relações entre classes, cardinalidade, igualdade, tipagem de propriedades, características de propriedades, classes enumeradas, entre outros.
A sintaxe OWL é baseada em XML e RDF/ RDF Schema e incorpora uma revisão sobre a linguagem DAML+ Oil.
A Figura 12 mostra a origem da OWL.
A OWL dispõe de três sublinguagens com níveis crescentes de expressividade.
O OWL Full representa a linguagem completa do OWL, possibilitando o uso de todas as primitivas da linguagem.
Possibilita a combinação de suas primitivas arbitrariamente com RDF e RDF Schema.
Permite portanto, alterar o significado de primitivas pré-definidas, tanto em RDF quanto em OWL.
Já OWL Dl é mais focada para usuários que buscam eficiência para processamento computacional.
Esta sublinguagem restringe a forma como os construtores de OWL e RDF devem ser usados com o objetivo de aumentar a eficiência computacional.
A OWL Lite apóia usuários que necessitem, primeiramente, de uma classificação hierárquica e restrições simples.
As restrições do subconjunto de construtores da linguagem OWL Dl também são válidas para OWL Lite.
Além deste subconjunto, também são excluídas as cardinalidades arbitrárias, enumeração das classes e declarações de disjunções.
A vantagem na utilização de OWL Lite é por a simplicidade e facilidade de implementação, principalmente com ferramentas para construção de ontologias.
A desvantagem, por outro lado, é a clara restrição na expressividade.
Um documento OWL pode ser estruturado através de:
Classes: Conjunto de instâncias com características comuns.
Propriedades: O Tipos:
Identificam os valores primitivos das instâncias, como o Objetos:
Representam o vínculo de duas instâncias, isto é, seus relacionamentos.
Adicionando valores a uma propriedade, consequentemente, adicionam- se valores numa segunda.
Instâncias: Representam os objetos num domínio, isto é, coisas específicas.
Verifica- se aqui que dois nomes podem representar o mesmo objeto no mundo real.
Uma classe em OWL é definida usando o elemento owl:
Class. Por exemplo, podemos definir classes como na Figura 13, onde são definidas as classes &quot;Winery», &quot;Region e «ConsumableThing».
Já a Figura 14 define uma classe &quot;PortableLiquid «como sendo uma subclasse de &quot;ConsumableThing», através do elemento subClassOf.
Uma propriedade é uma relação binária.
Dois tipos de propriedades são distinguidos:
Datatype properties: Relações entre instâncias de classes e literais RDF e XML Schema datatypes.
Object properties: Relações entre instâncias de duas classes.
A Figura 15 ilustra a definição de propriedades.
Em este exemplo, são declarados os conceitos &quot;SistemaMultiAgentes «e &quot;Agentes», e eles são relacionados utilizando a propriedade &quot;compostoPor».
As ontologias estabelecem uma terminologia comum usada tanto por humanos quanto por agentes de software para o entendimento dos conceitos de um domínio.
Em a próxima seção, serão apresentados os conceitos referentes a Agentes e Sistemas Multiagentes.
A tecnologia de agentes de software pode ser vista como uma abordagem complementar ao paradigma de objetos no desenvolvimento de sistemas de software complexos.
Esta nova tecnologia propõe um nível de abstração mais alto que aquele proposto por a tecnologia de objetos, uma vez que o comportamento dos agentes situa- se mais próximo de o comportamento de seres humanos, cujo trabalho em geral é substituído ou suportado por sistemas de software.
Um agente de software, segundo Weiss, pode ser definido como um sistema de computador situado em algum ambiente e capaz de agir de forma autônoma para atingir um objetivo, onde a autonomia refere- se a capacidade de agir de acordo com sua própria linha de controle.
Em a Web Semântica, agentes de software são usados como entidades capazes de consumir automaticamente conteúdos publicados.
Assim, a Web Semântica pode ser vista como um sistema multiagentes global formado por a relação de um grande número de sociedades de agentes.
Em a literatura são encontrados diversos trabalhos que citam a contribuição e uso de agentes de software na Web Semântica, como e, e trabalhos que visam apoiar o desenvolvimento de aplicações deste tipo, como e o SemantiCore, que será apresentado mais adiante.
A Web Semântica é baseada na idéia de dinamicidade, heterogeneidade, e fontes de conhecimento compartilhadas provendo conteúdo processável por máquina.
Agentes de software podem usar este conhecimento para alcançar seus objetivos, produzindo novos conhecimentos que podem ser disseminados ou publicados dentro de uma framework comum.
A Web Semântica pode beneficiar- se de agentes autônomos e distribuídos, responsáveis por coletar ou agregar conhecimento, raciocinando ou inferindo novos fatos, identificando e gerenciando inconsistências, e provendo mecanismos de confiança e segurança.
Algumas das características básicas presentes em agentes são:
Autonomia, próatividade e interatividade.
A autonomia consiste na capacidade do agente agir sem intervenção externa;
A pró-atividade indica que o agente pode atuar de forma que suas ações não necessariamente sejam de resposta ao ambiente e a interatividade permite que ele possa se comunicar com outros agentes e com o ambiente em que está presente.
Outras características podem ser encontradas em agentes:
Adaptação: São capazes de modificar, em algum grau, os seus comportamentos devido a as mudanças de ambiente e de outros agentes.
Aprendizado: São capazes de modificar o seu comportamento baseado na sua experiência.
Racionalidade: São capazes de selecionar suas ações com base em seus objetivos.
Mobilidade: São capazes de se mover de um ambiente para outro.
Sociabilidade: Um agente pode interagir com outro agente.
A definição precisa do que é realmente um agente de software é um dos temas mais debatidos e controversos na área de ciência da computação.
Um agente de software pode ser definido de uma maneira simples como um objeto complexo com atitude.
Mais especificamente, um agente pode ser encarado como uma entidade autônoma que possui uma série de capacidades e objetivos definidos, que interage com um ambiente e com outros agentes e é capaz, através destas interações, de adaptar seu estado e comportamento.
Assim como a definição de agentes de software, a definição de sistemas multiagentes também é diferenciada na literatura.
Alguns autores consideram um sistema multiagentes como uma coleção de agentes que se coordenam através de suas interações.
Segundo estes autores, um SMA só existe se existe coordenação entre os agentes que o formam.
Para outros autores a definição de SMA deve incorporar um conjunto de agentes que interagem entre si e com objetos num ambiente.
O desenvolvimento orientado a agentes tem como principais objetivos:
A definição das entidades que serão representadas no sistema (domínio);
As percepções e ações que cada agente pode realizar;
A representação das crenças e objetivos e a definição dos relacionamentos de comunicação entre os agentes (protocolo de comunicação).
Os sistemas multiagentes estão ligados com o comportamento de uma coleção de agentes autônomos (possivelmente pré-existentes) focados em resolver um determinado problema.
Eles formam uma espécie de rede para resolução de problemas que estão além de suas capacidades individuais.
Um sistema que consiste de um grupo de agentes que potencialmente interagem entre si é chamado de Sistema Multiagentes.
A Figura 16 mostra um exemplo de uso de sistema multiagentes.
Em o exemplo, temos robôs jogando futebol, onde cada robô é controlado por um agente de software.
Em um sistema multiagentes, os protocolos de comunicação permitem aos agentes trocarem e entenderem mensagens.
Os protocolos de interação permitem aos agentes terem conversação, por meio de trocas estruturadas de mensagens.
Em a resolução distribuída de problemas, o conceito de agente é usado para simplificar a solução do problema.
Desta forma, os agentes são distribuídos em unidades colaborativas responsáveis por a resolução de tarefas específicas.
Em um SMA, os agentes podem ser organizados em sociedades.
Um grupo de agentes pode formar uma pequena sociedade em o qual desempenham diversos papéis.
O grupo define os papéis, e os papéis definem os comprometimentos associados a ele. Quando
um novo agente junta- se a um grupo, a ele é associado um ou mais papéis, e ele adquire o comprometimento para aquele papel.
Um agente junta- se a um grupo autonomamente, mas ele deve estar consciente dos comprometimentos associados ao papel adotado.
Os grupos definem também o contexto social, em o qual o agente interage.
O conceito de sociedades de agentes envolve abstrações da sociologia e teorias organizacionais.
A sociabilidade é importante para a cooperação, que promove a mudança do paradigma cliente-servidor para um paradigma flexível e distribuído (peer-topeer) que as modernas aplicações necessitam, e onde a tecnologia de agentes pode encontrar seu grande potencial.
Uma sociedade pode ser classificada sobre os seguintes aspectos:
Homogênea: Possui agentes do mesmo tipo (arquitetura).
Heterogênea: Agentes de tipos diferentes (arquitetura).
Fechadas: Agentes fixos no ambiente.
Abertas: Agentes podem migrar entre ambientes.
Baseada em leis:
Regras explícitas de comportamento para todos os agentes.
Sem leis:
Sem regras explícitas de comportamento para todos os agentes.
Os agentes recebem problemas com certo nível de abstração.
Cada agente deve então decompor o problema em subproblemas que lhes digam respeito e com as quais possa lidar, de acordo com os recursos e os conhecimentos que possui ou possa buscar com outros agentes.
Em um ambiente com recursos limitados, os agentes devem coordenar suas atividades para cumprirem seus próprios interesses ou para satisfazerem os objetivos do grupo.
As ações de múltiplos agentes necessitam ser coordenadas porque existem dependência entre estas ações, e existe também a necessidade de manter as restrições globais, e nenhum agente tem a competência, recursos ou informações suficientes para atingir sozinho, um objetivo de sistema.
Para produzir sistemas de coordenação, muitas pesquisas em inteligência artificial têm se concentrado em técnicas para distribuição de controle e dados.
O controle distribuído significa que os agentes têm um grau de autonomia na geração de novas ações, e podem decidir qual objetivo perseguir.
A desvantagem da distribuição de controle e dados é que o conhecimento geral do sistema fica disperso, e cada agente possui uma imprecisa e parcial perspectiva do sistema.
Existe então, um aumento de incerteza sobre as ações dos agentes, e, dessa forma, torna- se difícil a obtenção de um comportamento global coerente.
Podemos dizer que agentes estão cooperando, se eles assumem ações em comum após identificarem e adotarem um objetivo comum.
Em um ambiente cooperativo, a troca de informações entre agentes é fundamental, existindo assim, um compartilhamento da informação.
É possível distinguir de duas formas a cooperação:
Partilha de resultados:
Ocorre após a conclusão de um objetivo.
O agente verifica se existem outros agentes interessados nas informações provenientes do alcance de seu objetivo.
Partilha de tarefas:
Ocorre quando um agente detecta que não tem capacidade ou informação suficiente para a execução de determinada tarefa.
Mas para isso, o agente deve verificar se existem outros agentes com &quot;interesse «em ajudar.
Esta partilha pode ser vista como o balanceamento de carga computacional do sistema.
A cooperação acontece quando vários agentes planejam e executam suas ações de uma forma coordenada.
O problema da coordenação é o gerenciamento das interdependências entre as atividades desempenhadas por os agentes:
Mecanismos de coordenação são essenciais se as atividades que uma agente possui ocasionam a interação de alguma maneira.
A coordenação de agentes visa garantir que:
Todas as partes componentes de um problema estejam incluídas nas atividades de pelo menos um agente.
Os agentes interajam de forma a permitir que suas atividades sejam desenvolvidas e integradas no sentido de uma solução global.
Os membros do grupo de trabalho atuem de forma determinada e consistente.
O grupo de agentes respeite restrições globais a solução do problema.
Existam procedimentos que garantam a harmonia na execução de uma única ação de forma conjunta por mais de um agente.
Alguns requisitos são fundamentais para permitir a coordenação:
A comunicação entre os agentes.
O reconhecimento das potenciais interações entre os planos de ação dos agentes.
E a capacidade de negociação entre os agentes.
Em sistemas multiagentes, assim como para os humanos, a comunicação é a base para interações sociais e organizacionais.
Sem comunicação, o agente é meramente um indivíduo isolado, surdo e mudo para outros agentes, fechado em seu ciclo de percepção-deliberação- ação.
Isso porque, basicamente os agentes que se comunicam podem possivelmente cooperar e coordenar suas ações, entre outros aspectos.
Segundo Vlassis, interações são frequentemente associadas com alguma forma de comunicação.
A comunicação num SMA envolve o envio e recebimento de mensagens entre os agentes.
A comunicação pode ser usada em diversos casos, como por exemplo, para a coordenação entre agentes cooperativos ou para negociação entre agentes.
Entretanto, a comunicação adicionalmente gera o problema de saber qual o protocolo de rede deve ser utilizado, para permitir a troca de informações, e em qual linguagem o agente deve falar para entender os outros agentes (especialmente em ambientes heterogêneos).
Existem muitas formas de comunicação encontradas em sistemas mutiagentes, de entre as mais utilizadas, podemos citar os atos de fala, conversações, e linguagens de comunicação entre agentes, como o KQML e o FIPA ACL De entre as formas de comunicação, podemos citar duas estratégias comuns para a comunicação entre agentes, que são:
Comunicação através de troca de mensagens o Comunicação direta, onde os agentes lidam com sua própria coordenação.
Blackboard o É um repositório em o qual os agentes escrevem mensagens, armazenam resultados parciais e obtêm informações.
Normalmente é particionado em vários níveis de abstração, de acordo com o problema em questão.
Com o objetivo de permitir o desenvolvimento de SMAs para a Web, incorporando os requisitos necessários à criação da Web Semântica, foi desenvolvido em meados de 2002 a arquitetura Web Life.
Em essa época, falava- se muito sobre a Web Semântica, mas existiam poucas ferramentas que permitiam (ou ao menos objetivavam) que os seus requisitos fossem implementados.
O SemantiCore, apresentado inicialmente em 2004, surgiu a partir de uma extensão na arquitetura Web Life.
O SemantiCore é estruturado como um framework que abstrai a plataforma de implementação e provê primitivas para a criação de aplicações organizadas num conjunto de agentes que realizam suas tarefas no ambiente Web.
Com o surgimento de novas tecnologias, bem como com o aprimoramento das já existentes, foi apresentado o SemantiCore 2006.
Uma das principais inovações presentes na nova versão diz respeito ao modelo de arquitetura do agente.
Em o SemantiCore 2006, agentes de software podem ser descritos através de uma estrutura ontológica.
Ontologias são usadas para definir os conceitos de forma que os membros de uma comunidade ou domínio tenham o mesmo entendimento.
O SemantiCore é dividido em dois modelos:
O modelo do agente e o modelo do domínio semântico.
Os dois modelos dispõem de pontos de flexibilidade (hotspots) permitindo aos desenvolvedores associarem diferentes padrões, protocolos e tecnologias.
O modelo do agente possui uma estrutura orientada a componentes, onde cada componente contribui para uma parte essencial do funcionamento do agente, agregando todos os aspectos necessários a sua implementação.
Com a retirada de um ou mais componentes não relacionados ao desempenho das tarefas do agente é possível simplificar a sua arquitetura.
Os agentes são compostos basicamente por quatro componentes.
Cada componente é responsável por tarefas especializadas, onde cada componente é um processo de software independente, e que colaboram entre si como um grupo.
A estrutura de componentes do agente ajuda o desenvolvedor a focalizar o agente em partes.
Esta modularização oferece benefícios em termos de manutenção e organização do código.
O padrão de projeto Factory é usado para encapsular as instanciações que o agente necessita ao ser iniciado, isto é, a implementação dos pontos de flexibilidade.
Para perceber e capturar recursos que trafegam por o ambiente, o agente possui o Componente Sensorial (Sensorial Component).
Este componente agrupa os elementos que são habilitados à recepção de objetos através do ambiente.
O componente sensorial armazena os diversos sensores definidos por o desenvolvedor e também verifica se algum destes sensores deve ser ativado por o recebimento de um objeto semântico do ambiente.
Se um ou mais sensores forem ativados, os objetos são enviados para outros componentes para processamento.
O desenvolvedor pode definir diferentes tipos de sensores para capturar diferentes tipos de objetos no ambiente.
Um sensor RDF (RDF Sensor) é um tipo especial de sensor que captura objetos RDF no ambiente.
O Componente Decisório (Decision Component) encapsula o mecanismo de tomada de decisão do agente.
O mecanismo decisório presente no componente é um dos pontos de flexibilidade do SemantiCore.
O componente decisório opera sobre ontologias que permitem a definição de conceitos, também como um conjunto de relações, restrições, axiomas, instâncias e vocabulários.
Torna- se necessário o uso de uma linguagem apropriada para a definição semântica dos dados, como OWL.
Para que a saída gerada por o componente decisório possa ser entendida, ela deve ser uma instância de uma Ação (Action).
As ações mapeiam todos os possíveis comandos que um agente deve entender para trabalhar de forma apropriada.
As ações podem ser aplicadas internamente aos elementos do agente ou aos elementos do ambiente.
O desenvolvedor pode definir suas próprias ações através da extensão da classe Action (hotspot) presente no framework.
O Componente Executor (Execution Component) contém os planos de ação que serão executados por o agente.
Este componente trabalha com o mecanismo de workflow, e ele é necessário para o controle das transições de atividades dentro de um processo do workflow.
Toda publicação de um objeto semântico no ambiente requer um efetuador apropriado no agente.
Os efetuadores são controlados por o Componente Efetuador (Effector Component) do agente.
Este componente recebe dados dos outros componentes e encapsula estes em objetos para serem transmitidos no ambiente.
Assim como o mecanismo sensorial, o efetuador abstrai a representação do recurso, permitindo assim, diferentes representações para este conforme a necessidade.
Os objetos são encapsulados em mensagens para que possam trafegar por o ambiente.
Para que um agente possa atuar, é necessário ele estar dentro de um ambiente.
A camada de abstração do SemantiCore define o lugar onde um agente executa como um domínio semântico.
Um domínio semântico requer um domínio Web para operar.
Ele pode ser pensado como uma região no domínio Web em o qual os agentes vivem.
Um domínio contém sociedades de agentes que são organizadas para alcançar um objetivo.
A Figura 18 ilustra uma representação de domínio semântico.
Cada domínio semântico é composto por algumas entidades administratvas, tais como o Domain Controller e Environment Manager.
O Domain Controller é o agente responsável por o registro dos agentes no ambiente.
Este agente também é responsável por as características de segurança e por a recepção de agentes móveis vindos de outros domínios.
O Environment Manager é uma ponte entre o domínio do SemantiCore e os domínios Web convencionais.
Em esta seção será apresentado um exemplo de aplicação construída utilizandose o framework Semanticore 2006.
Este exemplo busca ilustrar os aspectos básicos envolvidos na criação de um agente no SemantiCore, cobrindo todos os elementos presentes no modelo de agente, conforme apresentado anteriormente na seção 2.6.1, e a troca de mensagens entre os agentes.
O exemplo consiste na troca de mensagens entre três agentes, sendo eles o AgResourceManager, AgMachine1 e AgMachine2.
O primeiro agente é responsável por coletar informações de hardware sobre os computadores de todos os agentes presentes no domínio.
As informações a serem coletadas são:
A capacidade de memória virtual e o número de processadores da máquina onde o agente está situado.
Após a coleta das informações, o agente é responsável por exibir os resultados no console da aplicação.
Em as próximas seções serão detalhados os aspectos de cada agente, e a execução do exemplo.
O agente Gerenciador de Recursos (AgResourceManager) possui um plano de ação que é responsável por realizar a busca das informações de hardware.
A execução deste plano envolve o envio de uma mensagem para os agentes do domínio, o recebimento das respostas, e a apresentação de um resultado para o usuário do sistema, neste caso, o resultado compreende a listagem das máquinas e suas informações de hardware, conforme descrito anteriormente.
O agente gerenciador de recursos possui um mecanismo decisório (AgResourceManagerDecision), um sensor (AgResourceManagerSensor), um mecanismo executor (AgResourceManagerExecution), um plano de ação (AgResourceManagerPlan) e uma ação (AgResourceManagerAction).
O sensor é responsável por receber mensagens do ambiente e repassar para o decisório.
O decisório por sua vez, é responsável por a tomada de decisão do agente, e neste caso, verifica se uma mensagem recebida contém o texto &quot;machine_ info «no campo assunto.
Essa mensagem contém a resposta de um agente perante a uma solicitação de informações de hardware.
A seguir é apresentado o código fonte da classe que implementa o AgResourceManager.
ActionPlan actionPlanAgResourceManager $ \&gt; O método setup contêm o código necessário para a inicialização do agente.
Após sua inicialização, o agente gerenciador de recursos realiza a execução do seu plano de ação.
Este plano contém uma única ação, responsável por realizar o envio da solicitação de informações de hardware para os demais agentes do domínio.
A seguir é apresentada a classe que implementa o mecanismo decisório.
Em o método decide é implementada a lógica decisória do agente.
O decisório verifica se o assunto da mensagem contém o texto &quot;machine_ info».
Caso o texto esteja contido, isto indica o recebimento de uma resposta à solicitação de informações por um dos agentes do domínio.
Após a verificação, as informações são exibidas no console da aplicação.
Toda mensagem de resposta que é recebia possui em seu campo &quot;conteúdo «um objeto do tipo MachineInfo.
Este objeto encapsula as informações de hardware, e contêm os atributos quantidade de memória e número de processadores.
Os agentes AgMachine1 e AgMachine2 são instâncias da classe AgMachine, que implementa um agente no SemantiCore.
A esta classe de agente, existem associados um mecanismo decisório (AgMachineDecision), um sensor (AgMachineSensor), um mecanismo executor (AgMachineExecution), um plano de ação (AgMachineActionPlan) e uma ação (AgMachineAction).
O sensor é responsável por receber mensagens do ambiente e repassar para o decisório.
O decisório é responsável por a tomada de decisão do agente, e neste caso, verifica se uma mensagem recebida contém o texto &quot;get_ machine_ info «no campo assunto.
A seguir serão apresentados os códigos-fonte das classes AgMachine, AgMachineSensor e AgMachineDecision.
O método setup contêm o código necessário para a inicialização do agente.
Package agent. Machine;
Através do método evaluate uma informação é recebida do ambiente.
Após o recebimento de uma informação, o sensor verifica se ela é uma mensagem (classe SemanticMessage).
Caso seja uma mensagem, esta é enviada para processamento por o componente decisório.
A seguir é apresentada a classe que implementa o mecanismo decisório.
O método decide, herdado da classe DecisionEngine, contém o código responsável por a tomada de decisão do agente.
Em este exemplo, a tomada de decisão do AgMachine é verificar se o assunto da mensagem contém o texto &quot;get_ machine_ info».
Caso contenha o texto, ele envia um sinal (objeto ExecuteProcessAction) para o componente executor, solicitando a execução do plano de ação &quot;ActionPlanGetInfo».
O plano de ação &quot;ActionPlanGetInfo «contém uma única ação, que é responsável por recuperar as informações de hardware da máquina local e enviar- las para o agente solicitante.
A seguir é apresentado o código-fonte da ação.
SemanticMessage reply $= transmit (reply);
O método exec contém o código necessário para a execução da ação.
A ação mostrada realiza a coleta de informações relativas à memória virtual disponível e o número de processadores da máquina, ambos estes comandos estão disponíveis através da API do Java.
As informações recuperadas são encapsuladas num objeto, definido através de classe MachineInfo, e este objeto é enviado via mensagem para o agente AgResourceManager, através do método transmit presente na classe Action.
O campo assunto da mensagem contém o texto &quot;machine_ info», que permitirá ao agente Gerenciador de recursos identificar que esta é uma mensagem de resposta a sua solicitação.
O método transmit enviará as informações para o componente efetuador do agente, e este por sua vez, invoca o efetuado padrão presente no agente, responsável por enviar uma mensagem no ambiente.
Após a instanciação das classes necessárias, e a construção da lógica de troca de mensagens e processamento de informações, são definidos os agentes que participam do sistema.
Para este exemplo, todos os agentes estão situados num mesmo domínio e presentes numa mesma máquina, sendo eles o AgMachine1, AgMachine2 e AgResourceManager.
A Figura 19 mostra a interface gráfica do semanticore e os agentes5 associados ao domínio semântico.
Após a execução do exemplo, é apresentado o seguinte resultado no console da aplicação:
Agent: AgMachine1 Machine info:
Virtual Memory:
7753728 Processors:
2 Agent:
AgMachine2 Machine info:
Virtual Memory:
7753728 Processors:
2 Como os agentes estão em execução na mesma máquina, as informações recuperadas são as mesmas.
Os agentes DomainController e CommunicationManager são agentes de controle do SemantiCore O Jena é um kit que foi desenvolvido por a Hp Labs6, com o objetivo de facilitar o desenvolvimento de aplicações que utilizam os modelos e linguagens da Web Semântica.
O Jena é uma interface de programação de aplicações (API7) e é disponibilizado como software livre.
O coração de sua arquitetura é a API RDF, como mostrado na Figura 20, que suporta a criação, manipulação e consultas em grafos RDF.
A API também suporta diversas tecnologias de armazenamento de dados, permitindo a associação de diferentes tecnologias.
Além de a API RDF, o Jena dispõe de uma API para a manipulação de ontologias.
Esta API é independente de linguagem, isto é, permite a utilização de várias linguagens para a representação de ontologias, como o OWL.
Esta API é responsável por a transformação de uma ontologia num modelo abstrato de dados orientado a objetos, e possibilita que suas primitivas (conceitos e relacionamentos) também possam ser tratadas como objetos.
O Jena também possui mecanismos de inferência.
Os principais usos destes mecanismos são para suportar o uso de linguagens como RDFS e OWL permitindo que fatos sejam inferidos das instâncias de dados e de suas descrições.
Entretanto, estes mecanismos são projetados para serem genéricos, e, em particular, incluem mecanismos genéricos de regras de inferência.
Além de as capacidades de processamento de linguagens e modelo semânticos, o Jena dispõe de mecanismos capazes de serem associados a fontes de dados na Web.
A Network API permite a uma aplicação o acesso e atualização a fontes de dados na Web, similarmente como um navegador acessa um web server.
A network API possui operações similares aos comandos do protocolo Http, como o GET e o PUT, utilizados para a recuperação de metadados.
Este mecanismo pode ser utilizado em aplicações cliente (no navegador ou outras aplicações que consumam conteúdos na Web) ou em servidores, para a publicação de conteúdos.
Em o contexto da presente proposta, o Jena é utilizado para permitir a manipulação das ontologias que são capturadas em páginas Web, permitindo que estas sejam encapsuladas e utilizadas como objetivos na linguagem Java, e para permitir aos agentes a capacidade de inferência e raciocínio baseada em regras sobre as ontologias capturadas.
Em os últimos anos têm crescido o número de iniciativas acadêmicas e industriais para implementar os requisitos da Web Semântica.
Ferramentas de anotação de conteúdos, editores de ontologias e mecanismos de inferência tem sido criados para permitir o desenvolvimento de aplicações que podem beneficiar- se das características da Web Semântica.
Nenhuma destas iniciativas provê uma solução que combine os esforços realizados anteriormente para permitir o desenvolvimento de aplicações para a Web Semântica.
Em a literatura não foram encontrados trabalhos que se propõem aos mesmos objetivos do presente trabalho.
Em este sentido, entre as propostas encontradas, existem algumas que se assemelham a esta proposta e contemplam parcialmente os requisitos para a execução de aplicações da Web Semântica.
Atualmente, existem diversas ferramentas disponíveis para darem suporte a Web Semântica.
Tais ferramentas podem ser classificadas em três grandes grupos:
Ontologias e editores de metadados, plugins e Apis, e mecanismos de inferência.
Entre as ferramentas existentes, podemos citar o Disco, que é um navegador que opera sobre conjuntos de fontes de dados na Web Semântica, exibindo informações que são encontradas em páginas Web que contenham um documento RDF associado;
O OntoBroker é uma máquina de inferência que processa ontologias e possibilita a construção de aplicações semânticas;
O Pellet é um mecanismo de inferência para o OWL Dl, construído em Java;
E o SEAL (SEmantic portAL) (MAEDCHE, 2001), que é constituído essencialmente por ontologias, sendo utilizado para busca semântica e compartilhamento de conhecimento na Web.
Esta seção irá abragerá em detalhes uma proposta que mais se assemelha com o presente trabalho.
Em é mostrado um navegador para a Web semântica que representa uma extensão de um navegador Web convencional, aumentando suas funcionalidades com a habilidade de atuar sobre recursos descritos em páginas Web e encontrar recursos semanticamente relacionados com uma página Web.
Em a visão dos autores, o protótipo construído provê três principais características:
A habilidade de encontrar e recuperar automaticamente ontologias que são relacionadas a uma página Web que o usuário está navegando.
Uma interface simples com o usuário para permitir a navegação entre os dados encontrados.
A habilidade para prover serviços capazes de aproveitar os dados descobertos.
A arquitetura consiste de dois componentes principais:
Uma interface com o usuário e um servidor (chamado de Power Magpie Server).
A interface com o usuário é uma extensão de um navegador Web convencional.
O servidor é o componente que atua como suporte a aplicação cliente, provendo as funções necessárias.
O cliente e servidor podem executar em diferentes máquinas.
A arquitetura do Power Magpie, em alto nível, pode ser vista conforme a Figura 21.
Para permitir a descoberta de ontologias, o Power Magpie pode contar com arquiteturas externas como o Swoogle, SWSE, Watson ou redes peer- to peer.
Entretanto, no protótipo atual, a principal fonte de informações é provida por a arquitetura Watson.
A Watson é uma arquitetura que coleta conteúdo semânticos disponíveis na Web Semântica, analisa e extrai metadados úteis e os indexa para permitir um eficiente acesso a estes metadados.
De essa forma, ela pode ser vista como um repositório de ontologias.
Segundo os autores, o resultado do trabalho é um framework que recupera em tempo real ontologias relacionadas a uma página Web.
O protótipo atual permite aos usuários explorarem as ontologias relacionadas e destacarem conceitos numa página Web.
Também são apresentados dois trabalhos futuros.
O primeiro é atacar o problema da ambigüidade que pode ser gerada por o uso de uma mesma palavra em diferentes domínios.
O segundo é prover serviços que aproveitem os conteúdos encontrados nas páginas Web.
Em relação a presente proposta, este trabalho apresenta alguns pontos em comum, que são:
Permitir a captura de conteúdos anotados semanticamente em páginas Web, a divisão de sua arquitetura em dois modelos, cliente e servidor, e a extensão de um navegador Web convencional.
Este trabalho difere- se da presente proposta em alguns aspectos.
O SWP utiliza a abstração de agentes de software, que serão os responsáveis por o processamento dos conteúdos anotados semanticamente que são capturados dinamicamente nas páginas Web, e não somente na visualização e armazenamento destas anotações, como acontece no Power Magpie, que cita o processamento dos conteúdos recuperados como trabalho futuro.
O SWP divide a arquitetura em Cliente e Servidor para permitir a integração do Semanticore a navegadores e servidores Web, possibilitando a formação de ambientes onde os agentes de software atuam.
E por fim, o protótipo do SWP também estende um navegador Web convencional, o Mozilla Firefox.
Em este trabalho, está sendo proposta uma arquitetura que permite a integração das tecnologias existentes para viabilizar o desenvolvimento de aplicações baseadas em agentes para a Web semântica, chamada Semantic Web Plugin (SWP).
A arquitetura possui o SWP cliente e servidor, que integram o SemantiCore a navegadores e servidores Web, de forma a permitir a criação de ambientes onde agentes de software atuam, estendendo a Web, sem interferir na sua estrutura atual.
A extensão do Semanticore agrega ao SWP o modelo de agente e o modelo domínio.
Em o Semanticore, o modelo de agente é orientado a componentes, agregando todos os aspectos necessários a sua implementação;
E o modelo de domínio define o ambiente onde os agentes atuam.
O modelo cliente permite o processamento de páginas que possuem anotação semântica por os agentes.
Após a leitura de páginas Web anotadas semanticamente, são extraídas as estruturas semânticas das demais informações da página e encapsuladas para envio posterior.
O formato de anotação utilizado é abstraído, permitindo o processamento de diferentes tecnologias de representação semântica.
Além de a captura e disponibilização de anotações semânticas em páginas Web, existe a possibilidade de que ambientes presentes em outros navegadores ou em servidores Web (que possuam o SWP servidor) sejam automaticamente reconhecidos.
Este reconhecimento torna- se possível através da utilização de marcadores especiais anexados ao protocolo de comunicação Http.
A arquitetura estabelece novas informações que são adicionadas ao cabeçalho da resposta a requisição feita ao servidor, indicando a identificação do domínio semântico.
Esta arquitetura altera o atual paradigma request-response usado na Web para um modelo híbrido request-response/ peer- to peer, onde, agentes atuando em ambientes associados a navegadores Web nas máquinas cliente podem comunicar- se diretamente com outros agentes distribuídos em outros ambientes que estejam acessíveis através da Internet.
A Figura 22 mostra um esquema de comunicação entre os diferentes ambientes providos por a integração com o SWP.
A figura ilustra a comunicação entre navegadores e servidores Web.
A comunicação entre os navegadores é possível após o acesso por eles a páginas providas por um servidor que possui o SWP.
De essa forma, este servidor atua como o mediador da descoberta de outros ambientes, informando a existência de outros ambientes para cada navegador que o acessa.
Após essa divulgação, os navegadores podem iniciar a comunicação de forma ponto a ponto, e, neste momento, já não é necessária a comunicação direta com o servidor.
A Figura 23 apresenta a arquitetura proposta.
Em esta figura é ilustrada a comunicação entre um navegador e um servidor Web habilitado como servidor web semântico, ambos com o SWP.
Em o primeiro momento, o navegador realiza uma requisição ao servidor, e na resposta desta requisição, são enviadas as informações que indicam a existência de um domínio web semântico.
Após a identificação do servidor por o navegador, é realizada a comunicação ponto a ponto entre os ambientes.
As páginas que contêm anotação semântica, e os servidores web semânticos identificados são mantidos em históricos.
O histórico de ambientes possibilita que o presente ambiente no navegador do usuário conecte- se a outros ambientes, formando assim uma rede, e, possibilitando a troca de mensagens entre os agentes, tornando possível a cooperação entre eles.
De essa forma, os agentes poderiam executar suas tarefas (visando o alcance de seus objetivos) sem necessariamente o usuário estar navegando na Web.
O SWP reconhece as anotações semânticas de uma página Web através de URLs inseridas no seu cabeçalho, como mostra a Figura 24.
A URL mostrada na figura é capturada e interpretada por o SWP.
Este então realiza a captura do conteúdo apontado por a URL, encapsula e disponibiliza este conteúdo para os agentes.
O elemento &quot;link», da linguagem Html, possui como atributos o &quot;rel», &quot;type «e &quot;href».
O atributo &quot;rel «descreve o relacionamento do documento Html com o endereço especificado em &quot;href».
Em este caso, estamos informando apenas que o conteúdo apontado é uma ontologia em Owl.
O atributo &quot;type «indica ao mecanismo que processa o Html o tipo do conteúdo que está associado ao endereço presente em href.
A indicação de um conteúdo em owl é dada através do valor &quot;text/ owl», informado no atributo type.
Esta convenção é utilizada no contexto do SWP, não sendo oficializada por a W3C.
Por fim, o atributo href especifica a localização de um recurso na Web.
Como pré-requisitos para o funcionamento de aplicações que utilizam a arquitetura do SWP, podemos citar:
O desenvolvimento dos agentes que atuam no ambiente, processando as ontologias capturadas, devem ser realizados conforme os formatos de desenvolvimento do framework Semanticore;
E as páginas Web que serão acessadas devem ser anotadas semanticamente para permitir a identificação e captura de ontologias por o SWP durante a navegação.
Devido a a limitação de tempo deste trabalho, foi realizada apenas a construção da arquitetura cliente, para permitir a integração a navegadores Web.
A arquitetura do SWP cliente, como mostrado na Figura 25 e representada através de um diagrama de classes UML, pode ser dividida em quatro partes principais, descritas nas próximas seções.
A Integração contém os elementos responsáveis por realizar a extensão do Semanticore, permitindo o controle sobre o ambiente onde os agentes atuam, e, a integração com o navegador.
A seguir serão detalhados os elementos que compõem a Integração, e a relação entre eles.
A classe SWP representa o núcleo da arquitetura.
Ela é a classe principal, sendo responsável por centralizar os principais elementos da arquitetura e também por estender as funções do framework Semanticore, através da relação de herança com a classe Environment.
Esta relação é necessária para permitir ao SWP o acesso aos agentes de software em execução, o controle sobre o ambiente e o envio das anotações semânticas capturadas das páginas Web para os agentes.
A classe Mediator é responsável por mediar a integração entre o navegador e o restante da arquitetura.
É nesta classe que estão às operações públicas que podem ser realizadas no SWP, tais como consultar os agentes presentes no domínio, o histórico semântico, os domínios semânticos conhecidos, entre outras.
O Gerenciamento de Conteúdos contém os elementos responsável por o processamento do conteúdo das páginas Web visitadas por o usuário, que foram capturados na Integração, e verificar a existência de anotações semânticas.
Caso uma anotação seja encontrada, esta é extraída das demais informações da página e encapsuladas para envio aos agentes presentes no ambiente.
O envio destas informações no ambiente é realizado na Integração.
A seguir serão detalhados os elementos que compõem o Gerenciamento de Conteúdos, e a relação entre eles.
Quando uma página Web é acessada, seu conteúdo é capturado e enviado por o SWP à classe ContentManager.
Esta por sua vez, é responsável por centralizar e organizar os elementos que realizam o processamento dos conteúdos capturados.
Estes elementos são chamados de Sniffers, e são representados por a classe ContentSniffer.
Um ContentSniffer possui a função de processar o conteúdo de uma página Web na tentativa de encontrar um determinado padrão.
Este padrão é definido através da classe Pattern.
Quando um padrão é reconhecido, a classe sniffer é responsável por extrair o conteúdo das demais informações da página e por encapsular esse conteúdo num determinado formato definido na classe Content.
É através destes elementos que são definidos os tipos de anotações que são reconhecidos por o SWP, como por exemplo, anotações em RDF e OWL.
O ContentManager também é responsável por enviar os conteúdos detectados de volta para a classe SWP.
Em este momento, o SWP fica responsável por encapsular os conteúdos no formato de mensagem do Semanticore e por disponibilizar- los para processamento por os agentes.
O diagrama oferece uma melhor compreensão do fluxo realizado por o SWP, que compreende o processamento e disponibilização de anotações semânticas das páginas Web.
Em, o SWP invoca a operação dataEvaluation da classe ContentManager.
Esta operação é responsável por realizar o envio do conteúdo Html para processamento por os Sniffers.
Para cada sniffer, é invocada a operação evaluate.
A o receber uma informação no evaluate, o sniffer verifica se a informação recebida combina com o seu padrão de reconhecimento, através da operação match presente na classe Pattern.
Caso um padrão seja reconhecido, a classe Sniffer realiza a extração do conteúdo, e o retorna para a ContentManager.
Após o processamento de todos os sniffers, a classe ContentManager gera um vetor contendo todos os conteúdos identificados, e este vetor é retornado para a classe SWP, que por sua vez possui a responsabilidade de publicar estes conteúdos no ambiente para uso dos agentes, através da operação publish.
O Histórico é responsável por armazenar a localização das páginas Web que foram identificadas como contendo anotações semânticas, os dados de acesso de outros ambientes com o SWP que foram identificados durante a navegação, e por prover os mecanismos necessários para permitir o acesso aos dados dos históricos por os agentes no ambiente.
Além de as funções de integração, a classe SWP é responsável por manter o histórico das páginas Web anotadas semanticamente.
Isto é realizado através da associação com a classe SemanticWebHistory.
Ela é a classe responsável por manter as informações necessárias de histórico, através da agregação de registros de histórico, representados por a classe HistoryElement.
Cada elemento do histórico possui os atributos date e url, que respectivamente representam a data de acesso e a localização da página com anotação semântica.
Este histórico, além de armazenar as páginas, serve como base para consulta dos agentes, podendo estes, por exemplo, visitarem as páginas do histórico na busca de informações atualizadas.
Como o SWP estende um navegador Web, é importante permitir que os agentes presentes no ambiente associado ao navegador possam solicitar interações com o usuário.
Estas interações são gerenciadas na Interação.
A Interação possui os elementos necessários para permitir que os agentes realizem suas ações e possam indicar ao SWP a existência de uma interação.
As interações ocorrem através de janelas que serão exibidas no navegador.
A exibição da janela, a captura dos dados informados por o usuário, e o envio destes dados até o agente solicitante são gerenciados na parte de Interação.
Além de o processamento de conteúdos e da possibilidade de ser mantido um histórico das páginas anotadas semanticamente, o modelo dispõe de elementos capazes de permitir que os agentes presentes no domínio especifiquem interações com o usuário.
Uma interação é possível através da utilização da classe UserInteraction.
Esta classe estende a classe Action do Semanticore, que representa a ação de um agente.
Para que um agente possa interagir com o usuário, seja para informar ou coletar dados, são necessários mecanismos que gerenciem tais operações de maneira transparente.
Em o SWP, essa interação ocorre através de janelas gráficas que são exibidas diretamente no navegador Web.
Estas janelas são representadas através da classe UserDialog, e possuem três especializações, ConfirmationDialog, MessageDialog InputDialog.
ConfirmationDialog possui o objetivo de obter uma confirmação do usuário, como por exemplo, uma questão com as alternativas &quot;Sim «ou &quot;Não».
A classe MessageDialog tem como função mostrar uma mensagem textual ao usuário.
A classe InputDialog possui a função de coletar dados textuais a serem informados por o usuário.
A classe UserInteraction possui duas operações principais.
A primeira operação permite que uma janela de interação seja registrada por o agente para envio ao navegador.
A segunda operação é responsável por receber os dados de retorno que foram informados por o usuário e o identificador da janela, caso a janela seja do tipo que requer entrada de dados.
O gerenciamento destas janelas é realizado na classe UserDialogManager.
Esta classe mantém uma fila de janelas registradas.
Ela é responsável por disponibilizar estas janelas para o navegador, e quando necessário, receber e enviar as respostas dos usuários para as Ações (UserInteraction) associadas com a janela.
A etapa de cadastramento e tratamento das janelas de interação com o usuário pode ser vista conforme o diagrama de seqüência UML, mostrado na Figura 27.
O diagrama representa o fluxo que compreende a criação, disponibilização e recebimento de uma resposta para janelas de interação com o usuário.
Em é criada uma janela de interação (UserDialog).
Após a criação em, em é invocada a operação registerDialog indicando que a janela criada deve ser registrada para ser disponibilizada para o usuário.
Este registro é feito na classe UserDialogManager, através do método addDialog.
Após o registro, a classe UserDialogManager é encarregada de ficar aguardando uma resposta da janela de interação.
A resposta é recebida de forma assíncrona, através da operação ProcessDialogResponse, e esta então invoca a operação, e passa o parâmetro capturado da janela de interação.
Após receber a resposta em, em é recuperada a janela referente a resposta recebida, em (3.2) é invocada a operação que indica a disponibilidade da resposta, e em é invocada a operação que finaliza o fluxo, e fornece para a ação do agente a resposta informada por o usuário para a janela de interação.
Em o próximo capítulo será apresentada a arquitetura do protótipo que permite a integração entre o SWP e o navegador Mozilla Firefox.
Devido a falta de navegadores para a Web Semântica capazes de trabalhar com o processamento de linguagens de representação de conhecimento, é apresentada neste trabalho uma iniciativa que visa dar um passo na direção desta concretização com o uso de navegadores amplamente aceitos no mercado.
Portanto, este trabalho visa utilizar o navegador Mozilla Firefox, que além de possuir uma grande aceitação no mercado, possui suporte a extensão de sua arquitetura, possibilitando novas funcionalidades.
Em o navegador Firefox, as extensões são pequenas adições que oferecem novas funcionalidades.
As extensões visam adicionar ou modificar componentes, que vão desde uma barra de ferramentas a uma característica completamente nova.
De essa forma, elas permitem que a aplicação seja personalizada para satisfazer as necessidades pessoais de cada usuário.
As interfaces com o usuário no Firefox são construídas utilizando as linguagens XUL e JavaScript.
A XUL é uma gramática XML que proporciona a definição de componentes gráficos como botões, menus, barras de ferramentas, árvores, etc..
O JavaScript é uma linguagem dinâmica de scripts que suporta a construção de elementos procedurais e orientados a objetos.
As ações do usuário nos componentes gráficos são gerenciadas através do JavaScript, que é utilizado para o controle de eventos dos componentes, e eventos internos do navegador, como por exemplo o evento gerado quando uma página Html é carregada.
Para este trabalho foi criada uma extensão que gera uma nova janela no navegador, permitindo ao usuário a visualização das informações do domínio semântico que é associado ao navegador, como mostrado na Figura 28.
A janela mostrada na figura possui três listas, que informam respectivamente:
Os agentes presentes no domínio semântico (Agents), os ambientes já identificados por o SWP (Domains), e o histórico das páginas Web detectadas contendo anotações semânticas (Semantic Web History).
O botão &quot;Status «indica se o SWP está ativo ou não.
O botão &quot;Options «exibe uma janela onde o usuário pode informar se deseja que o SWP processe o cabeçalho, o corpo da página, ou ambos, devido a possibilidade das anotações semânticas estarem dispostas em qualquer parte da página Web.
A seguir, será apresentada a arquitetura de integração com o navegador Firefox.
O protótipo da arquitetura SWP cliente foi desenvolvido utilizando a linguagem de programação Java.
O navegador Firefox é construído utilizando a linguagem C+.
De essa forma, não foi realizada uma integração nativa entre as diferentes arquiteturas.
Mesmo sendo possível a integração entre diferentes linguagens, isto acarretaria numa redução das funcionalidades do SWP, onde muitos dos recursos que são providos por a máquina virtual Java não estariam disponíveis.
Para cobrir essa necessidade de integração, foi realizada a construção de componentes de software que permitam a comunicação entre a extensão criada para o Firefox e o SWP.
A Figura 29 mostra o diagrama da arquitetura para a integração com o navegador.
A classe MozillaMediator estende as funcionalidades da classe Mediator do SWP.
Esta classe é responsável por cadastrar todas as possíveis operações que são realizadas com o navegador, e também por manter a classe que realiza a comunicação com o navegador, denominada Mozilla Connector.
A classe MozillaConnector opera como servidora, na espera de conexões (requisições) que são originadas na extensão do navegador.
Esta classe utiliza comunicação por sockets, e implementando o protocolo Http para a comunicação.
Em o navegador, as requisições para o SWP são implementadas utilizando a linguagem Javascript, que é responsável por acessar a API de socket que o Firefox disponibiliza para suas extensões.
Quando uma requisição é aceita, a classe ClientConnection é associada a requisição e esta é responsável por o gerenciamento dos dados trocados (leitura e escrita).
Os dados que são recebidos do navegador são encapsulados na classe Message e estes são passados para a classe MessageInterpreter.
A classe MessageInterpreter é responsável por analisar o conteúdo das mensagens e decidir qual operação o SWP deve realizar, gerando ou não uma resposta a ser enviada de volta ao navegador.
As operações são definidas através da classe Operation.
Esta classe é responsável por abstrair as operações que devem ser realizadas no SWP ou no navegador.
Como especializações dessa classe, encontramos as seguintes operações:
GetDialog, responsável por recuperar as janelas de interação que estão registradas por os agentes, e repassar- las para envio ao navegador;
GetSemanticWebHistory, responsável por recuperar os dados do histórico Web semântico, contendo a referência das páginas anotadas semanticamente que foram detectadas, e disponibilizar- los para envio ao navegador;
GetAgentsTable, responsável por recuperar os dados referentes aos agentes presentes no domínio semântico e disponibilizar- los para envio ao navegador;
ProcessDialogResponse, responsável por gerenciar o envio dos dados de uma janela de interação com o usuário e enviar- las ao agente responsável;
ProcessHTMLContent, responsável por receber e repassar o conteúdo Html de uma página Web acessada por o usuário da extensão para processamento no SWP;
GetServerHistory, responsável por recuperar os dados do histórico de domínios Web semânticos, e disponibilizar- los para envio ao navegador.
Em o próxima seção será descrito um exemplo de cenário que ilustrará a utilização do SWP na captura de anotações semânticas em páginas Web, e a comunicação entre ambientes presentes em navegadores e servidores Web, através da internet.
O modelo proposto oferece uma série de facilitadores para a construção de aplicações que possam consumir conteúdos anotados semanticamente em páginas Web, e permitir que agentes de software presentes em diferentes domínios na Web possam se comunicar.
Para ilustrar algumas das funcionalidades providas por o SWP, neste capítulo será apresentado o desenvolvimento de um exemplo de aplicação na Web Semântica.
Abaixo seguem as características do ambiente de desenvolvimento utilizado para a construção do exemplo:
Linguagem de programação Java.
Ambiente de desenvolvimento Eclipse.
Construção das ontologias através da ferramenta Protégé (PROTÉGÉ, Manipulação das ontologias em Java através do framework Jena (versão 2.2).
Linguagem Html para a codificação das páginas Web, e CSS para codificação de estilos.
Microsoft Visual Web Developer Express para a edição dos arquivos Html e CSS.
O exemplo proposto ilustra a captura de anotações semânticas em páginas Web, o processamento destas anotações por um agente de software presente no navegador do usuário, e a apresentação para o usuário, do resultado obtido por o agente a partir de o processamento das anotações semânticas, demonstrando o surgimento de links semânticos entre duas páginas não associadas a priori.
O exemplo é composto por duas páginas Web, onde a primeira página é uma notícia retirada da seção de economia do site O Globo8, e a segunda é uma notícia retirada do site Quatro Rodas9.
As páginas originais não possuem quaisquer tipos de anotações semânticas em suas codificações.
De essa forma, foi necessária a realização da captura do código Html das páginas e a adaptação destes para permitir a adição da anotação semântica.
Cada página foi armazenada num arquivo Html, e em seus cabeçalhos foram adicionadas informações que indicam a existência de ontologias que descrevem semanticamente o domínio de cada página, para permitir a detecção.
As ontologias, descritas na linguagem OWL, encontram- se nos apêndices A e B deste trabalho.
Abaixo seguem os marcadores que foram adicionados nas páginas.
Em a primeira notícia:
Em a segunda notícia:
A segunda notícia é um comparativo entre dois carros populares.
Esta página reúne informações referentes a consumo de combustível, o rendimento dos motores, entre outras informações.
Ambas as páginas são desassociadas, isto é, elas não possuem em sua codificação a declaração de links que indicam a existência uma da outra.
De essa forma, só existe uma relação semântica entre elas, referente a o conceito relativo ao petróleo, pois a primeira notícia fala sobre a alta do preço do petróleo, e a segunda notícia contém informações sobre o consumo de combustíveis derivados do petróleo.
Este exemplo também é composto por um agente de software que representa o usuário.
Este agente está em execução no domínio semântico presente no navegador Web do usuário.
A Figura 30 mostra o navegador Web e a extensão do SWP, onde na lista de agentes, aparece no nome do agente do usuário, chamado de PersonalAgent.
Em este caso, é mostrado &quot;PersonalAgent@ Mauricio», onde &quot;Mauricio «é o nome do domínio semântico.
Como o SWP é integrado ao framework SemantiCore, a programação do agente é feita de acordo com o modelo de agente definido por ele.
Em a Figura 31 é mostrado o código-fonte da classe que implementa o agente do usuário para este exemplo.
A classe PersonalUserAgent estende a classe SemanticAgent, do framework Semanticore.
O método addMessage, é o método do agente por onde chega uma mensagem vinda do ambiente.
Este agente só aceita conteúdos em OWL, e por isso, na linha 17 é feita uma conversão do conteúdo textual da mensagem para o objeto OntModel, que é o objeto responsável por encapsular uma ontologia, disponível através do uso do framework Jena.
O objeto gerado com o conteúdo recebido é enviado para o componente decisório do agente, conforme o método na linha 18.
Já nas linhas 23 a 25, é definido o método setup do agente.
Este método deve conter todo o código de inicialização do agente, e no caso deste exemplo, contém apenas a definição do mecanismo de tomada de decisão do agente (linha 24).
O mecanismo de tomada de decisão deste agente utiliza uma máquina de inferência provida por o Jena.
A cada mensagem recebida, o agente realiza o processo de inferência, e baseado em suas regras que também são definidas no formato do Jena, verifica se algum resultado é gerado.
Em a tabela 3 é apresentado o trecho de uma regra de inferência utilizada por o agente.
Esta primeira regra é responsável por verificar na ontologia se existe uma informação sobre Petróleo, e caso exista, verifica também se a tendência do preço está em alta.
Caso a tendência seja de alta, é gerado um novo fato, indicando um alerta para o preço do petróleo.
Já na segunda regra, conforme mostrado na tabela 4, existe um comparativo que recupera dois carros distintos na ontologia, e verifica a medida de consumo destes carros, comparando- as e gerando um novo fato que indica qual destes carros é o que possui melhor desempenho, isto é, menor consumo de combustível.
Após o usuário visitar a primeira página (com informações sobre o petróleo), o SWP identifica que existe uma ontologia associada a página e realiza a captura, extraindo o conteúdo OWL e o disponibilizando para o agente.
O agente do usuário captura o conteúdo e realiza a inferência, satisfazendo a primeira regra, mas um resultado não é gerado para o usuário, pois o agente inferiu somente a alta no preço do petróleo.
Após o usuário visitar a segunda página (contendo o comparativo entre os carros), que também possui uma ontologia associada, o agente realiza novamente a inferência.
Em esse momento, a segunda regra é satisfeita.
Após satisfazer as duas regras, o agente infere que o usuário possivelmente estava procurando por carros com baixo consumo de combustível.
Em este momento, o agente realiza uma consulta ao histórico de páginas web semânticas, e recupera uma informação previamente processada, onde um carro de baixo consumo já havia sido identificado.
O agente compara estes dados do histórico, com os dados capturados e infere que existe outro carro, que possui menor consumo do que os mostrados na notícia, e gera uma mensagem para o usuário, enviada através dos mecanismos do SWP, como mostrado na Figura 32.
A mensagem mostrada na figura é uma janela de interação com o usuário, provida por o SWP e mostrada diretamente no navegador.
Em este exemplo, o agente informa o endereço do site da fabricante de carros, que possui um carro com consumo de combustíveis menor do que os que ele inferiu baseado na notícia capturada no site em que o usuário estava navegando.
O exemplo de aplicação descrito neste capítulo procurou mostrar, em linhas gerais, as primitivas do modelo proposto e a forma de usar- las na definição das anotações necessárias nas páginas Web, e o modo como o agente processa um conteúdo capturado.
Como pôde ser visto ao longo de o capítulo, o uso do modelo não traz um aumento significativo de trabalho aos desenvolvedores, salvo as questões referentes à implementação dos agentes de software e a definição das ontologias necessárias para representa o conhecimento associado a um domínio, aspectos esses que poderiam ser considerados complexos não do ponto de vista de desenvolvimento, mas de entendimento do problema.
Durante a descrição do exemplo, não foram salientadas as questões referentes ao mapeamento entre as ontologias utilizadas nas notícias.
Para este exemplo, as ontologias possuíam a mesma base de conceitos, e dessa maneira, o agente consegue realizar a inferência e a associação direta entre os conceitos presentes nas duas ontologias utilizadas no exemplo.
O mapeamento e composição de ontologias de diferentes domínios ainda é um problema em aberto na área de Ontologias e Web Semântica, não sendo tratado neste trabalho, que preocupa- se apenas no reconhecimento de padrões de anotação semântica em páginas Web e a disponibilização destas anotações para o agentes num ambiente.
O principal requisito para a Web Semântica é a interoperabilidade.
As máquinas devem ser capazes de explorar os recursos na Web, podendo acessar- los e usar- los.
Consequentemente, os recursos devem estar abertos e compreensíveis, e não escondidos num sistema proprietário que publica informações somente em formatos ­ ou ferramentas ­ orientados a humanos.
Eles devem ser invocados e publicados num formato aberto e estruturado que permite as máquinas fazerem o melhor uso destes.
O atendimento aos requisitos da Web Semântica necessitará de diversas camadas de desenvolvimento.
A infra-estrutura permitirá a identificação, localização e transformação de recursos de forma robusta e segura.
As linguagens são necessárias para expressar o conteúdo da Web Semântica.
Recursos como as ontologias, transformações, metadados e banco de dados devem sustentar as camadas base da arquitetura da Web Semântica.
Em as camadas mais acima teríamos os recursos e as aplicações explorando estes recursos.
A falta de navegadores para a Web semântica capazes de trabalhar com o processamento de linguagens de representação, e que permitam a associação direta entre os usuários e os agentes associados a conteúdos em domínios Web motivaram a realização deste trabalho.
De conta disto, foi realizada a construção de uma arquitetura que estende as funcionalidade do framework SemantiCore, para ser integrada a navegadores e a servidores Web, permitindo a estes trabalharem com a Web Semântica.
A extensão do Semanticore agregou ao SWP o modelo de agentes de software e o modelo domínio semântico.
Em o Semanticore, o modelo de agente é orientado a componentes, agregando todos os aspectos necessários a sua implementação;
E o modelo de domínio semântico define o ambiente onde os agentes atuam, e contém entidades administrativas, responsáveis por o controle do domínio.
O Semanticore também abstrai as tecnologias de comunicação de dados -- permitindo a associação de diferentes protocolos e tecnologias -- e o controle de distribuição, reduzindo a complexidade no desenvolvimento de aplicações orientadas a agentes.
O modelo cliente do SWP permite que os agentes interpretem conteúdos anotados semanticamente na Web.
O SWP realizada a captura de anotações semânticas em páginas Web, onde estas anotações são extraídas das demais informações da página, e são disponibilizadas para os agentes associados ao ambiente no navegador.
Além de a captura e disponibilização de conteúdos, o SWP permite a identificação automática de outros ambientes que utilizam o SWP através da internet.
O modelo servidor é responsável por adicionar informações que indicam a existência de um ambiente criado por o SWP no cabeçalho da resposta a uma requisição Http feita para o servidor Web em o qual o SWP está integrado.
Estas informações permitem a identificação automática deste ambiente por o navegador Web.
Quando o navegado identifica o servidor, estes automaticamente conectam- se, formando uma rede.
O modelo servidor também é responsável por as políticas de divulgação de ambientes conhecidos, isto é, o servidor mantém uma lista de todos os ambientes que o estão acessando, e quando um novo ambiente o acessa, o servidor divulga a sua lista de ambientes, possibilitando assim, a formação de novas conexões e a expansão da rede virtual de ambientes.
Devido a a limitação de tempo, a integração com o servidor Web não foi realizada dentro deste trabalho.
Apenas foi realizada a construção da arquitetura cliente, e a arquitetura para viabilizar a integração com o navegador Mozilla Firefox.
O modelo servidor, portanto, foi simulado na construção dos cenários, e as informações necessárias para a identificação do ambiente foram adicionadas direto nas páginas Web do cenário exemplificado.
Os seguintes pontos são objetos de trabalhos futuros:
Embora seja proposta por o Tim Berners-Lee uma idéia, não existe atualmente a concretização destas idéias em softwares comerciais.
Esta é uma iniciativa que visa dar um passo na direção desta concretização com o uso de navegadores Web amplamente aceitos no mercado.
A questão de segurança da informação é um aspecto muito importante, especialmente por se tratar de um sistema presente na Internet.
Mecanismos de segurança devem ser incorporados, para garantir a integridade e segurança na troca de dados, sejam nas informações capturadas na Web, e na troca de mensagens entre os agentes de diferentes ambientes.
O estudo mais aprofundado das recomendações da W3C, para a utilização das tecnologias da Web semântica, e o avanço desta iniciativa podem direcionar a novas melhorias e a novas funcionalidades para esta proposta.
A possibilidade de serem agregados a atual proposta, mecanismos de identificação dinâmica dos objetivos dos agentes presentes em diferentes domínios, e mecanismos que permitam a composição e coordenação destes objetivos para permitir que os agentes alcancem a resolução de objetivos que vão além de suas capacidades individuais.
