Memórias Transacionais são consideradas por muitos pesquisadores como a mais promissora solução para resolver problemas de programação multicore.
Esse modelo promete escalabilidade com pequena granularidade, enquanto elimina os problemas comuns nos mecanismos convencionais de locks, como deadlocks por exemplo.
Durante esses quase vinte anos de pesquisas, diversos estudos foram realizados visando identificar abordagens para maximizar o uso de Memórias Transacionais no cenário de Programação Paralela.
Além disso, diversos sistemas Tm foram desenvolvidos em diferentes tipos de implementações, bem como novos Benchmarks foram propostos para avaliação e testes de sistemas Tm.
Entretanto, apesar de o avanço da área, Memória Transacional não é considerada uma solução pronta para comunidade científica devido a as perguntas ainda não respondidas na literatura, tais como:
&quot;Como identificar se uma aplicação terá vantagem na utilização de memórias transacionais?»
e &quot;Porque algumas aplicações não se beneficiam com o uso de Memórias Transacionais?».
Esse trabalho realiza uma avaliação comparativa de um conjunto de sistemas e aplicações transacionais, apresentando o estado da arte atual, compreendendo os problemas existentes e identificando oportunidades de crescimento nos sistemas STM de maneira a contribuir para responder as perguntas ainda em aberto na comunidade científica.
Palavras-chave: Memórias Transacionais;
Memórias Transacionais de Software;
Paralelismo; Programação Paralela;
Programação Multicore; Mecanismos de Controle de Sincronização.
A tecnologia multicore tem- se mostrado capaz de solucionar o problema de alto desempenho sem o aumento do consumo de energia.
Entretanto, para que seja utilizada toda a capacidade desta tecnologia, é necessário que as aplicações atingam um alto grau de concorrência.
Os mecanismos de sincronização tradicionais possuem diversas limitações em termos de complexidade de código, baixa granularidade, pouca escalabilidade, dificuldade de gerenciamento e propensão a deadlock.
Além disso, a programação paralela para processadores multicore é algo não trivial.
Aplicações necessitam explorar melhor as vantagens de tal tecnologia, facilitando a programação e gerenciando a sincronização de dados compartilhados de maneira mais efetiva.
Memórias Transacionais fornecem um mecanismo flexível e simples para programação paralela em processadores multicore, usando abstração de alto nível, ao contrário de o mecanismo de locks.
De essa forma, o problema de sincronização de dados é passado para o sistema de Memória Transacional, que se torna responsável por garantir um correto funcionamento da aplicação (sem deadlocks, condições de corrida, etc), explorando de fato, o paralelismo das aplicações.
Memória Transacional é considerada por muitos pesquisadores como a mais promissora solução para resolver problemas de programação multicore.
Entretanto, ao se abstrair o mecanismo de sincronização para o sistema de Memória Transacional (Tm -- Transactional Memory), ocorre perda de desempenho, e importantes decisões de projetos precisam ser tomadas para minimizar tal impacto.
Diversas propostas de Memórias Transacionais têm sido apresentadas por pesquisadores em diferentes maneiras de implementação, como software (STM -- Software Transactional Memory), hardware (HTM -- Hardware Transactional Memory) e híbrido (HyTM -- Hybrid Transactional Memory).
De entre as possibilidades, a analisada neste trabalho é a STM, devido a as seguintes vantagens:·
É mais simples de modificar e possui poucas limitações de arquitetura, em comparação ao hardware;·
Possui portabilidade da aplicação sem a necessidade de hardware específico;·
Pode possuir qualquer tamanho de transação ou tempo de duração, principal limitação de sistemas baseados em hardware.
Após quase vinte anos desde a primeira prosposta de Memória Transacional, ela ainda não é considerada uma solução final na área, devido a certas perguntas ainda não respondidas, tais como sobre as vantagens de uma aplicação na utilização de Memória Transacional ou sobre porque algumas aplicações não se beneficiam com o uso de Memória Transacional.
Para resolver essas questões, pesquisadores estão buscando investigar profundamente os sistemas Tm com o objetivo de identificar quais aplicações se beneficiam com eles, que características eles devem possuir para superar o desempenho de aplicações em comparação com mecanismos de locks, entre outros resultados que podem ser obtidos para análise dos sistemas e das aplicações Tm.
Resultados atuais apresentados em, indicam uma melhora no desempenho em relação a trabalhos mais antigos, embora ainda não seja suficientes se observado o contexto geral.
Além disso, apesar de a grande quantidade de implementações, bem como de benchmarks específicos existem poucos trabalhos que direcionam seu foco no entendimento de Memórias Transacionais.
É um desafio para a área saber que tipo de aplicações são beneficadas com o uso de Memórias Transacionais, pois faltam ferramentas e mecanismos para analisar e compreender seu estado atual.
Motivação e Objetivos Há um crescente aumento de trabalhos de pesquisa sobre Memórias Transacionais.
Segundo, com o passar dos anos, houve um crescimento no interesse de pesquisadores, inclusive vindo da indústria, por essa área.
Importantes empresas como Intel, IBM e Microsoft estão investindo esforços para o desenvolvimento de soluções Tm.
Durante esses quase vinte anos de pesquisas (primeira proposta em), diversos estudos foram realizados visando identificar abordagens para maximizar a programação paralela com o uso de Memórias Transacionais.
Além disso, diversos sistemas Tm foram desenvolvidos em diferentes tipos de implementação (Hardware, Software e Híbrido), e alguns benchmarks foram desenvolvidos exclusivamente para avaliação e testes desses sistemas.
Entretanto, Memória Transacional não é considerada, ainda, uma solução pronta para comunidade científica, devido a as perguntas ainda não respondidas por as pesquisas realizadas até o presente momento.
Algumas das perguntas não respondidas são listadas abaixo:·
Em relação a o desempenho, qual o estado atual dos sistemas STM propostos na literatura?·
Porque algumas aplicações não possuem desempenho satisfatório com Memórias Transacionais?·
Quais aplicações têm vantagem na utilização de Memórias Transacionais?·
Qual o impacto que as caraterísticas transacionais têm no desempenho das aplicações ao quando são utilizadas Memórias Transacionais?·
Qual as decisões de projeto utilizadas em sistemas de Memórias Transacionais possuem melhor desempenho?
Essas e outras perguntas são encontradas em trabalhos atuais de Memória Transacional.
Segundo, apesar de a grande variedade de implementações Tm, ainda é um desafio saber que tipo de aplicações pode realmente tirar proveito de sistemas Tm.
Além disso, em, o autor salienta que, embora vários sistemas Tm tenham sido propostos na literatura, ainda faltam ferramentas e mecanismos necessários para analisar e comparar os trabalhos propostos.
O trabalho recente, questiona a capacidade de sistemas STM proporcionar bom desempenho e sugere o termo &quot;research toy «(brinquedo de pesquisa) ao atual estado da área.
Isso é consequência das promessas realizadas sobre Memórias Transacionais há alguns anos atrás quando a área estava começando a ser explorada.
Entretanto, implementações e propostas atuais não conseguem garantir o desempenho e a facilidade de uso prometidas.
Esse trabalho tem por objetivo realizar uma avaliação comparativa de um conjunto de sistemas e aplicações transacionais, buscando apresentar o estado atual da área, compreendendo as perguntas da comunidade na prática, identificando melhorias e oportunidades de crescimento nos sistemas STM de maneira a contribuir para a comunidade responder às perguntas ainda em aberto.
Através de uma avaliação comparativa, é possível investigar o comportamento das aplicações para Memórias Transacionais, identificando suas características transacionais mais importantes, analisando seu desempenho, buscando entender seu comportamento.
Também é possível investigar o comportamento dos sistemas STM atuais, identificando problemas de implementação e apontando melhorias e oportunidades de crescimento.
Através da abordagem comparativa, é analisado o comportamento tanto das aplicações utilizadas, ao executar aplicações com diversos sistemas STM, bem como investigar os sistemas STM, ao comparar os resultados de aplicações entre os sistemas utilizados.
Estrutura do Texto O trabalho está organizado da seguinte forma:
Este capítulo apresenta uma introdução geral sobre contexto de Memórias Transacionais, além de a motivação e do objetivo para realização da trabalho.
Em o Capítulo 2, é apresentado o conceito de Memórias Transacionais, de onde surgiu e como é utilizado.
São também apresentadas as maneiras de se implementarem sistemas de Memórias Transacionais e as principais decisões de projeto necessárias para o desenvolvimento desses sistemas.
O conceito de transação foi utilizado inicialmente na área de pesquisa de banco de dados.
Uma Database Transaction é uma sequência de ações indivisível e instantânea.
De esse modo, Transaction Memory, ou Memória Transacional, é a utilização do conceito de transação de Banco de Dados para o contexto de acesso a memória de um sistema.
Memórias Transacionais são utilizadas para substituir regiões críticas protegidas por lock, em programas multi-thread, por transações (blocos atômicos).
Memórias Transacionais são consideradas por muitos pesquisadores como a mais promissora solução para resolver problemas de programação multicore.
Esse modelo promete escalabilidade com pequena granularidade, enquanto elimina os problemas comuns nos mecanismos convencionais de locks, como deadlocks por exemplo.
Em esse capítulo, é apresentado uma visão geral sobre Memória Transacional.
Primeiramente, é apresentado a motivação para o uso de Memórias Transacionais.
Após, são apresentados conceitos básicos, propriedades e comparações em relação a o mecanismo de locks (Seção 2.2).
Em seguida, as diferentes maneiras de implementar Memórias Transacionais são mostradas na Seção Transacionais na Seção 2.4.
Motivação A necessidade de alto desempenho, sem que se aumente o consumo de energia e calor, tornouse uma importante área de estudos.
A tecnologia multicore tem se mostrado capaz de realizar tanto desempenho quanto redução no consumo.
Processadores multicore são predominantes em servidores, desktops e também em sistemas embarcados.
Entretanto, desempenho e o baixo consumo só podem ser obtidos se as aplicações atingirem um alto grau de concorrência.
Apesar de o avanço da tecnologia, a programação paralela para processadores multicore é algo não trivial.
Aplicações necessitam de controle avançado de concorrência.
Um objeto concorrente é uma estrutura de dados compartilhada por processos concorrentes.
Técnicas convencionais de implementação de tais estruturas são baseadas em seções críticas de código, para garantir que apenas um processo por vez possa acessar o objeto concorrente.
Uma estrutura de dados compartilhados (ou objeto concorrente) é denominada sem bloqueios (lock-free), se suas operações não necessitam de exclusão mútua.
Segundo, estruturas lock-free eliminam problemas comuns associados a técnicas convencionais de bloqueio, como:·
Inversão de prioridade:
Ocorre quando processos de baixa prioridade são antecipados mantendo processos de maior prioridade bloqueados;·
Convoying: Ocorre quando um processo perde o processador (como quando ocorre uma inter-rupção ou devido a o limite de tempo excedido).
Quando interrupções desse tipo acontecem, outros processos prontos para execução são impossibilitados de prossegir;·
Deadlock: Pode ocorrer se processos decidem bloquear o mesmo conjunto de objetos em ordens diferentes.
Apesar de sua ampla utilização, locks possuem sérias limitações, salienta ao comparar as granularidades utilizadas em mecanismos de lock.
Segundo os autores, locks de alta granularidade que protegem uma grande quantidade de dados não são escaláveis.
Bloqueiam objetos compartilhados que não são conflitantes, tornando- se uma fonte de disputa.
Já locks de baixa granularidade (que protegem pequenas regiões de código) apresentam- se mais escaláveis, porém são difíceis de serem utilizados de uma maneira correta e eficaz.
Podem, inclusive, introduzir problemas de engenharia de software, visto que as convenções de associação de lock tornam- se mais complexas e propensas a erros.
De modo complementar, observou- se em alguns dos problemas enfrentados na utilização de mecanismos de sincronização tradicionais:·
São difíceis de gerenciar efetivamente, especialmente em sistemas complexos;·
Podem causar bloqueio, fazendo com que processos aguardem para liberação de um lock;·
São vulneráveis a falhas, como deadlocks;·
Limitam a escalabilidade e adicionam complexidade ao código fonte.
A Listagem 2.1 demonstra alguns dos problemas citados sobre o mecanismo de lock.
Em este exemplo, assume- se que o código necessita ser thread- safe e que múltiplas threads podem executar- lo concorrentemente.
Listagem 2.1: Código sem sincronização long c o u n t e r 1;
O primeiro problema, observado em refere- se a modelagem dos locks.
Em esse código, a utilização de um simples lock (apesar de implementado corretamente) tornaria a execução lenta, visto que f1 e f2 possuem variáveis não conflitantes.
Porém, a inclusão de dois locks também não é possível, pois nos outros dois métodos as variáveis acessadas são invertidas, sendo necessário, portanto, a inclusão de quatro locks (um para cada variável em questão).
Em este ponto, é possível identificar a dificuldade na definição de quantos locks e onde estes serão colocados no código fonte.
Após a definição dos locks, o código ficaria conforme apresentado na Listagem 2.2 (apresentando apenas 2 métodos, os outros são análogos):
Listagem 2.2: Código com a inclusão de locks l o c k;
Apesar de o código parecer pronto para execução, ainda pode- se identificar o problema de deadlocks se os métodos forem executados em threads separadas e em ordem diferente.
Através desse exemplo é possível verificar na prática a dificuldade na utilização de mecanismos de locks.
Por fim, locks podem causar vulnerabilidades em falhas de threads e delays, inibir concorrência (pois precisam ser usados de maneira conservadora) e possuem ainda desvantagens em termos de consumo de energia.
Conceitos Básicos Como citado anteriormente, o conceito de transação é herdado do conceito de database transactions.
Assim como transações de banco de dados, Memórias Transacionais possuem propriedades de modo a garantir o real funcionamento das transações em seu contexto.
Uma transação de banco de dados, possui as propriedades chamadas de ACID:
Atomicidade, consistência, isolamento e durabilidade.
Implementações gerais de Memórias Transacionais geralmente não fornecem as propriedades de consistência e durabilidade.
A primeira, devido a o fato de memórias serem voláteis.
A segunda, por sua vez, não é, geralmente, aplicada visto que Memórias Transacionais não possuem o conceito de metadados, não havendo regras de consistência a serem garantidas durante a transação.
Portanto, para Memórias Transacionais, as seguintes propriedades são válidas:·
Atomicidade: Refere- se à capacidade do sistema garantir que ou todas as tarefas de uma transação sejam executadas ou nenhuma de elas seja.·
Isolamento: Refere- se ao requisito que determina que outras operações não possam acessar os dados durante a execução da transação.
Abaixo são descritas algumas características do mecanismo de Memórias Transacionais, de maneira a exemplificar seu funcionamento:·
Antes do commit de uma transação, seu resultado não é visível fora de a transação;·
Cada transação é executada numa simples thread sem a aquisição de lock;·
Quando uma transação inicia, ela guarda um registro dos valores antigos, que pode ser restaurado se abortado;·
Uma transação não pode escrever diretamente na memória compartilhada.
Em vez de isso, seu resultado é armazenado num undo-log ou um write-- buffer mantido por o sistema;·
Se a transação completar sem conflito com outra transação, é feito commit e seu resultado é armazenado na memória compartilhada.
Caso contrário, se um conflito é detectado entre duas transações, uma de elas fará rollback, restaurando o registro guardado anteriormente;·
Para detectar conflitos read-- write ou write-- write, as referências de memória são monitoradas.
Segundo, transações possuem diversas vantagens quando comparadas com o mecanismo de locks.
Primeiramente, programadores não precisam se preocupar na eficiência e desempenho do esquema de locks.
Segundo, é garantido que um objeto compartilhado está consistente mesmo após um evento de falha.
Terceiro, transações são feitas naturalmente, o que torna o desenvolvimento de software multicore mais fácil.
Complementando, o modelo de programação em Memórias Transacionais oferece um novo meio de desenvolvimento de aplicações paralelas usando abstração de alto nível, ao contrário de o mecanismo de lock.
Esse modelo passa o problema de sincronização para o sistema de Memórias Transacionais, que é responsável por garantir que deadlocks não ocorram, condições de corridas sejam tratadas e locks sejam alocados numa granularidade que explorem de fato o paralelismo das aplicações.
Implementações Em esta seção são apresentadas as formas de implementação de Memórias Transacionais.
É apresentado inicialmente um exemplo de código com Memórias transacionais.
Como apresentado na Seção 2.1, utilizou- se o mesmo código fonte para demonstrar o resultado com Memórias Transacionais:
Listagem 2.3: Código com o uso de Memórias Transacionais i f O código fonte com a utilização de Memórias Transacionais torna- se extremamente simples.
Todo o controle de concorrência é realizado por o sistema de Memória Transacional.
Uma vez que há um crescente interesse de importantes equipes de pesquisadores, bem como empresas internacionais, na pesquisa sobre Tm, muitas soluções estão sendo propostas.
Memórias Transacionais podem ser implementadas em Hardware (HTM) ou em software (STM), ou com uma combinação híbrida de Hardware/ Software (HyTM).
Soluções HTM fornecem baixo overhead em comparação a soluções STM, mas possuem limitações de arquitetura.
Estão começando a ser disponbilizadas, visto que os mecanismos necessitam de hardware específico, além de possuírem limitações de espaço na cache.
Soluções STM, por outro lado, necessitam de mais overhead para gerenciar transações.
Entretanto, transações podem utilizar qualquer tamanho ou tempo de duração, e ainda são independentes de hardware.
Finalmente, soluções HyTM incorporam as vantagens de ambas as metodologias, usando HTM quando possível e recorrendo a STM se as transações forem maiores que a cache.
Em as próximas seções são apresentadas as características de cada solução, identificando as vantagens e desvantagens encontradas nas pesquisas desenvolvidas até o momento.
Geralmente, sistemas STM podem ser implementados como uma biblioteca de uma linguagem de programação ou diretamente no compilador.
A primeira alternativa, que é mais comum, precisa ser explicitamente adicionada no código fonte por o programador através de blocos atômicos.
Implementações como utilizam essa abordagem de desenvolvimento.
A segunda alternativa é a utilização de mecanismos Tm na implementação do compilador da linguagem.
Essa abordagem é utilizada por.
Segundo, a vantagem de uma solução STM para os programadores de sistema é que ela oferece flexibilidade na aplicação de diferentes mecanismos e políticas para essas operações.
Além disso, software é mais fácil de ser modificado e possui pouca limitação de tamanho, como estruturas de hardware.
Possui, ainda, uma grande vantagem para usuários finais em relação a portabilidade de aplicações sem a necessidade de hardware específico.
Em, soluções HTM possuem limitação de arquitetura, em as quais transações necessitam ser menores que o espaço da cache, tornando soluções HTM limitadas por o tamanho das transações e também por o tempo de execução.
Em, os autores acreditam que, mesmo que o suporte a HTM seja amplamente utilizado no futuro, apenas aplicações com transações de escala pequena serão complementamente utilizadas em hardware.
Enquanto isso, STM continuará sendo necessário para transações grandes.
Apesar de as diversas pesquisas, soluções STM possuem algumas limitações de desempenho e atomicidade de transações.
Segundo, muitas das pesquisas anteriores em STM possuam limitações em dois aspectos:
Primeiro, estudos utilizavam simulações e propostas com transações pequenas, gerando resultados com limitações;
Segundo, muitos dos sistemas utilizam soluções baseadas em bibliotecas de linguagens de programação.
Uma abordagem com base em biblioteca torna difícil lidar com cargas de trabalho complexas e grandes transações, pois necessitam de um controle maior do programador.
Porém, para a maioria de propostas STM, o desempenho baixo é uma séria desvantagem.
Outro desafio em soluções STM refere- se a propriedade de isolamento.
Em, os autores relatam tal desafio comparando os dois tipos de isolamento.
A o utilizar isolamento forte, o código não transacional não poderá ler/ escrever em dados não armazenados, prejudicando o desempenho do sistema.
A o utilizar isolamento fraco, o isolamento será utilizado apenas em transações e o código não transacional poderá ler/ escrever em dados não armazenados, trazendo assim alto desempenho, mas podendo gerar resultados não esperados.
Uma grande variedade de técnicas STM, inspiradas por algoritmos de banco de dados, foram explorados.
O grande desafio que enfrentam os pesquisadores STM é determinar a combinação adequada de estratégias que atendam aos requisitos de aplicativos concorrentes.
Entretanto, muitos experimentos STM foram avaliados utilizando benchmarks caracterizados por pequenas transações, dados simples e uniformes, ou ainda acesso a dados padrão.
Tais experimentos não representam os problemas encontrados em aplicações reais.
Finalmente, reduzir o overhead de soluções STM ao ponto de tornar- se viável é uma tarefa difícil, e resultados significativamente melhores precisam ser demonstrados.
De acordo com, mesmo com otimização de código por o compilador, sistemas STM podem sofrer queda de 40% no desempenho em cada thread de execução.
Ao contrário de as soluções STM, as soluções HTM implementam todas as suas funcionalidades em hardware.
A ideia básica desse sistema é modificar os protocolos de coerência de caches modernos, a fim de implementar transações.
Comparado com STM, HTM naturalmente possui vantagens de alto desempenho e atomicidade forte.
Tipicamente, sistemas HTM utilizam caches em hardware para guardar dados de leitura e escrita para cada transação, e utilizam o protocolo de coerência para detectar conflitos entre transações concorrentes.
Utilizando hardware, os sistemas Tm reduzem o overhead de mecanismos de locks de granularidade baixa, possuindo melhor desempenho não só em relação a soluções STM, mas também em sincronização baseada em locks.
Além disso, garantem atomicidade forte, com nenhum ou pouco overhead adicional.
Embora sistemas HTM são viáveis por manter overhead baixo, existem limitações de tamanho e comprimento de transações em hardware.
Estas limitações impedem os sistemas HTM de serem úteis na prática.
Um sistema HTM é tipicamente classificado por as escolhas de versionamento e mecanismos de detecção de conflitos.
Uma abordagem utilizada é o versionamento ansioso (eager versioning) e a detecção de conflitos ansiosa (eager conflict detection).
Em essa abordagem, os dados são armazenados diretamente na memória (sem armazenamento temporário) e as transações são abortadas assim que conflitos sejam identificados.
Essa abordagem garante uma boa escalabilidade, porém é propensa a deadlocks/ livelocks e necessita de políticas de contenção.
Já uma outra abordagem é a utilização de versionamento preguioso (lazy versioning) e detecção de conflitos preguiosa (lazy conflict detection).
Essa abordagem é livre de deadlocks, mas, em contra partida, ela prejudica a escalabilidade da solução.
Em, os autores salientam que ainda não é claro que sistemas HTM de grande escala fornecerão implementações práticas, semanticamente aceitáveis e com um bom custo-benefício.
Segundo eles, sistemas HTM possuem 3 principais problemas:·
Promovem arquitetura ambiciosa:
Fazendo com que o mercado exiga provas mais convincentes para garantir o investimento.·
Existem políticas não explícitas:
Decisões que não são atualmente compreendidas e que, ainda não possuem uma abordagem aceitável.·
Suporte apenas a máquinas atuais:
Programas projetados em sistemas HTM possivelmente não funcionarão em máquinas antigas.
Finalizando, sistemas HTM possuem outros desafios de implementação.
O relacionamento entre transações e operações de entrada e saída (I/ O) é um importante desafio de pesquisa.
Como operações desse tipo estão fora de o escopo do sistema Tm, é difícil utilizarmos o conceito de rollback.
Outro desafio em sistemas HTM é o fato de não haver, ainda, um padrão do conjunto de instruções suportadas (ISA).
Como observado nas Seções 2.3.1 e 2.3.2 existem limitações na implementação tanto de sistemas HTM como de sistemas STM.
Apesar de o desempenho de sistemas STM terem se tornado mais escaláveis com o aumento do número de núcleos em processadores multicore, o overhead desses sistemas em software é ainda significante.
Por outro lado, sistemas HTM apresentam diversas limitações impostas por o hardware.
De essa forma, uma técnica para solucionar a limitação de recursos de hardware e o overhead gerado no software é a utilização dos sistemas híbridos (HyTM).
Propostas de sistemas puramente HTM possuem a vantagem de serem rápidas, mas são altamente ambiciosas e incorporam políticas não reconhecidas.
Propostas de sistemas STM fornecem flexibilidade substancial de políticas, porém incluem um overhead significativo em versionamento e validação em relação a conflitos de transações.
Existem diversas formas de implementar sistemas híbridos.
Em, é proposta uma abordagem de implementação em software que utiliza HTM para aumentar o desempenho e não depender apenas do sistema STM.
Em, os autores propõem que o hardware serve apenas para otimizar o desempenho das transações que são fundamentalmente controladas por software.
Já em, sugerese que pequenas transações utilizem a cache e grandes transações utilizem software.
Entretanto, a interação entre o sistema de software precisa ser da mesma maneira como executada em hardware.
Porém, o principal desafio de sistemas Híbridos é detectar conflitos entre transações iniciadas em hardware e transações iniciadas em software. Como
visto nas seções anteriores existem três implementações possíveis para Tm, cada qual com suas vantagens e desvantagens.
De entre as possibilidades, a analisada neste trabalho é a STM, devido a as seguintes vantagens:·
É mais simples de modificar e possui poucas limitações de arquitetura, em comparação ao hardware;·
Possui portabilidade da aplicação sem a necessidade de hardware específico;·
Pode possuir qualquer tamanho de transação ou tempo de duração, principal limitação de sistemas baseados em hardware.
Além disso, pesquisas recentes de HTM ainda indicam a limitação do tamanho da cache como um problema para implementações Tm baseadas em Hardware.
Em, o autor salienta que mais trabalhos são necessários para avaliar estratégias para solucionar problemas como overflow do tamanho da cache e transações que abortam repetidas vezes devido a conflitos de dados.
A proposta HTM, por exemplo, não utiliza o sistema Tm para transações que excedem o limite do hardware.
Em, uma proposta HyTM, o autor salienta que sistemas híbridos funcionam corretamente se possuírem recursos de hardware suficientes, entretanto o desempenho é reduzido para execução linear se os recursos de hardware são excedidos.
Decisões de Projeto Existem diversos sistemas de Memória Transacional propostos na literatura, cada uma apresenta suas características e mecanismos para controle das transações.
Tais características são denominadas decisões de projeto (design choices), pois são definidas na fase de construção do sistema.
Basicamente, as seguintes decisões de projeto são levadas em consideração na construção de uma sistema de Memória Transacional de Software:·
Granularidade da transação (transaction granularity):
É a unidade de armazenamento em a qual o sistema detecta o conflito.
Para linguagens orientadas a objetos, é comum utilizar granularidade de objeto (object granularity), que detecta conflitos quando o estado do objeto é alterado.
Existem ainda granularidade de palavra (word granularity) que utiliza uma palavra de memória como unidade de conflito, ou de bloco (block granularity) que utiliza um bloco de palavras de memória.
A escolha na granularidade influência diretamente o desempenho do sistema Tm.
Essa característica também é conhecida na literatura por word-- based (baseado em palavra) ou object-base (baseado em objeto).
Um estudo sobre o tamanho ideal da granularidade é apresentado em, onde testes são realizados com diferentes tamanhos de granularidade.
O resultado apresenta granularidade de 4 palavras como o melhor em relação a o desempenho do que granularidade de blocos ou com 1 palavra em 4% a 5% respectivamente.·
Gerenciamento de Versão: (version management):
É o mecanismo que gerência versões diferentes do mesmo dado lógico:
As novas versões atualizadas vindas de diferentes transações e a versão antiga com o dado original em caso da transação falhar.
Geralmente, existem dois tipos de gerenciamento de versões:
Gerenciamento de versão preguiçoso (LVM -- Lazy Version Management) e Gerenciamento de versão ansioso (EVM -- Eager Version Management).
Em a literatura é possível encontrar variações para o termo Version Management como:
Lazy--versioning (versionamento preguiçoso) ou eager-versioning (versionamento ansioso).
Em sistemas que utilizam LVM, versões antigas se mantêm em seu lugar original e novas versões são armazenadas num buffer específico da transação.
Quando a transação executa o commit a versão nova substitui a versão antiga e o endereço do dado novo é removido do buffer temporário.
Quando a transação aborta, a versão nova é descartada do buffer temporário diretamente.
Portanto, LVM é mais eficiente em transações que abortam.
Além disso, múltiplas transações podem acessar objetos compartilhados concorrentemente, e cada uma manter uma versão privada em seu buffer.
Finalmente, LVM permite leitura e escrita concorrentemente de uma mesmo dado.
Em sistemas EVM, uma nova versão substitui versões antigas diretamente, enquanto a versão antiga é salva num buffer temporário.
Comparado com LVM, EVM reduz o custo de copiar todos os dados, pois a versão nova é armazena diretamente no endereço da versão antiga.
Entretanto, isso impossibilita a leitura do objeto modificado por outras transações, limitando a concorrência.
Com EVM, o commit de uma transação é simples, basta descarta os dados do buffer temporário.
Quando uma transação aborta, a versão antiga é restaurada do buffer temporário e a nova versão é descartada.
Portanto, EVM é mais eficiente para transações que executam com sucesso, especialmente quando o commit é frequente.·
Detecção de conflito: (conflict detection):
Um conflito acontece quando duas transações acessam o mesmo dado e pelo menos uma o modifica.
Quando um conflito é detectado, o sistema Tm busca solucionar o problema, geralmente, abortando uma das transações envolvidas.
Geralmente existem, três tipos de detecção de conflito em sistemas Tm:
Detecção ansiosa (ECD -- Eager Conflict Detection), detecção preguiçosa (LCD -- Lazy Conflict Detection) e detecção híbrida (HCD -- Hybrid Conflict Detection).
Em a literatura é possível encontrar variações para o termo Conflict Detection como:
Otimista (que corresponde a preguiçosa) ou pessimista (que corresponde a ansiosa);
Lazy-- acquire (aquisição preguiçosa) ou eager-acquire (aquisição ansiosa);
Commit-time (ao realizar o commit) e encounter-time (ao encontrar um conflito).
ECD detecta conflitos no momento que as transações acessam a memória enquanto LCD detecta conflitos quando a transação está para executar o commit.
ECD sempre trabalha em conjunto com EVM, visto que, é necessário para garantir que apenas uma transação escreva uma nova versão no objeto.
Portanto, o sistema deve detectar o conflito antecipadamente.
De a mesma forma, LCD trabalha, geralmente, com LVM visto que, todas as atualizações são privadas e invisíveis para as demais transações.
Portanto, o sistema detecta conflitos apenas no final de uma transação.
A combinação LVM e ECD é utilizada em alguns sistemas HTM, entretanto é raro em sistemas Tm baseados em software.
Por outro lado, EVM não pode trabalhar com conjunto com LCD pois, apenas uma nova versão pode ser armazenada no objeto, por esse motivo, detecção de conflito precisa ser verifica antecipadamente para garantir que apenas uma transação escreva no objeto.
Alguns sistemas STM utilizam HCD, que combina detecção ansiosa e preguiçosa.
Em esse modelo de detecção o gerenciamento de versão opera em EVM e utiliza ECD antes de uma transação modificar um dado, mas permite que transações leiam o dado compartilhado concorrentemente e também para atrasar a detecção de conflito antes do commit.
SwissTM, por exemplo, utiliza uma versão de HCD (denominada mixed acquire) que possui deteção de conflito otimista para conflitos de leitura/ escrita e detecção de conflito pessimista para conflitos de escrita/ escrita.
A o detectar conflitos escrita/ escrita antecipadamente, o sistema evita perder tempo e processamento com transações que irão abortar.
E detectando conflitos leitura/ escrita tardiamente possibilita uma maior concorrência.
Uma característica importante dos detectores de conflitos é a visibilidade das leituras na memória.
Uma transação T que lê o dado x pode ser visível (visible read) ou invisível (invisible read) para outras transações que detectam x.
Quando T é invisível, T necessita detectar conflitos no dado x se outra transação tentar escrever.
Isso é chamado na literatura de validação do conjunto de leitura.
O tempo necessário de um algoritmo de validação básico é proporcional ao tamanho do conjunto de leitura, porém existem mecanismos que diminuem esse tempo.
Existem 2 algortimos de validação conhecidos na literatura:
Global commit counter heuristic (utilizado no sistema RSTM) e time-based scheme (utilizado no SwissTM, TL2 e TinySTM).·
Gerenciamento de Contenção: (contention management):
É o mecanismo que determina qual a transação envolvida num conflito necessita ser desfeita.
Quando um conflito acontece, as transações envolvidas são divididas em duas partes:
Atacantes e defensores.
As atacantes são as transações requisitando acesso a memória compartilhada enquanto as defensoras são as transações que recebem a requisição das atacantes.
Em um sistema com detecção ansiosa, a transação atacante é a que está tentando ler da memória compartilhada.
Já no sistema com detecção preguiçosa, a transação atacante é a que está tentando realizar o commit de suas modificações.
Quando um conflito acontece, a decisão de qual transação (atacante ou defensor) ganhará é geralmente relacionada com políticas de detecção de conflito e gerenciamento de versão.
Para escolher qual transação abortar, existem diversas medidas, como o tamanho da transação, o número de aborts anteriores, tempo decorrido da transação, entre outros.
Diversos mecanismos foram prosposto para gerenciamento de contenção como:
Passive, Polite, Karma, Polka e Greedy.
Em o mecanismo Passive, também conhecido por timid (tímido), transações que detectam um conflito de escrita se auto abortam.
Em o mecanismo Polite, uma transação que descobre um conflito adia o acesso ao dado por um período determinado.
Se o limite de tempo for ultrapassado, a transação atacante aborta a defensora.
Esse mecanismos possibilita que muitos conflitos serjam resolvidos sem precisar abortar transações.
Em o mecanismo Karma, existe uma tentativa de favorecer transações que estão a mais tempo executando.
O mecanismo armazena o número de objetos transacionais acessados por a transação e dá prioridade para a transação com o maior número.
Em o mecanismo Greedy, é atribuido para cada transação um valor timestamp ao iniciar.
A transação com o menor timestamp sempre ganha.
Uma importante característica deste mecanismos é, ao contrário de outros mecanismos, ele evita starvation.
O mecanismo Polka mostrou o melhor desempenho em benchmarks de pequena escala, enquanto que Greedy apresenta melhores resultados com benchmarks de larga escala.
Por fim, o mecanismo timid, utilizado nos sistemas TinySTM e TL2, apresenta desempenho baixo para transações grandes.·
Mecanismo de sincronização (synchronization mechanism):
Uma importante característica de sistemas transacionais refere- se ao mecanismo de sincronização dos sistemas.
É possível classificar os sistemas STM de 2 tipos:
Obstruction-free e Lock--based.
O primeiro tipo não utiliza nenhum mecanismo de bloqueio (como locks), e garante o progresso mesmo quando algumas transações são atrasadas (Prosposto em).
Já Lock--based implementa o protocolo de bloqueio de duas fases e foi inicialmente utilizado em.
Sistemas lock-- based possuem melhor desempenho que implementações obstruction-free.
Este capítulo apresenta o estado da arte de Memórias Transacionais relacionadas com o assunto deste trabalho.
É apresentado na Seção 3.1, os sistemas STM mais citados na literatura de Memórias Transacionais.
A Seção 3.2 apresenta um conjunto de benchmarks pesquisados.
Em essa seção ainda é apresentado um detalhamento das aplicações utilizadas nos testes dos capítulos 5, 6 e 7.
Por fim, a Seção 3.4 encerra o capítulo descrevendo os sistemas STM e os benchmarks selecionados para os testes deste trabalho.
Sistemas STM O primeiro trabalho de Memórias Transacionais com foco exclusivamente em software foi.
Desde então vários trabalhos apresentam novos sistemas baseados em software e novos mecanismos para minimizar o overhead gerado por os sistemas STM.
Atualmente é possível visualizar um grande avanço nos sistemas desde a primeira proposta e novos trabalhos e aprimoramentos estão surgindo na área.
Em as seções seguintes são apresentados os principais sistemas STM da literatura.
SwissTM é um sistema STM recente que foi desenvolvido a partir de diversos experimentos com as principais decisões de projeto STM.
SwissTM é baseado em locks (lock-- based) e em palavras (word-- based) e possui 2 abordagens para detecção de conflito:
Deteção de conflito otimista (commit-time) para conflitos de leitura/ escrita e detecção de conflito pessimista (encounter-time) para conflitos de escrita/ escrita.
A o detectar conflitos escrita/ escrita antecipadamente, o sistema evita perder tempo e processamento com transações que irão abortar.
E detectando conflitos leitura/ escrita tardiamente possibilita uma maior concorrência.
Além disso, possui um gerenciador de contenção de duas fases que garante o progresso de transações longas enquanto não sobrecarrega transações curtas.
O gerenciador de contenção muda dinamicamente da politica Polite, que favorece transações pequenas, para a política Greedy, que desempenha melhor com transações grandes.
Por fim, SwissTM utiliza leituras invisíveis (invisible reads) e utiliza esquema baseado em tempo para validação do conjunto de leituras (time-based scheme).
O sistema foi desenvolvido para desempenhar satisfatoriamente com aplicações complexas com grandes cargas de trabalho mas também foi pensado para aplicações menores e com estruturas de dados simples.
Esse fator é importante pois, muitas vezes aplicações complexas possuem tanto transações grandes com um grande volume de dados, mas também transações curtas com acessos simples na memória.
Desde sua criação em 2009 tem se aprimorado e vem obtendo resultados melhores ao longo de os anos, possuindo sua última versão de Agosto de 2011.
SwissTM apresenta resultados satisfatórios em diversos trabalhos apresentados, como em.
SwissTM é open-source e pode ser encontrado no RSTM foi desenvolvido na Universidade de Rochester em 2006.
Em as primeiras versões o sistema era baseado em objeto (object-based) e livre de obstruções (obstruction-free).
Além disso, utilizava heurística de contador de commits global (global commit counter heuristic).
RSTM suportava leituras visíveis (visible reads) e invisíveis (invisible reads) e suportava detecção de conflitos ansiosa (eager) e preguiçosa (lazy) (4 variações de algoritmos).
Por fim, RSTM suportava uma variedade de gerenciadores de contenção como Polka, Polite, Greedy, entre outros.
Atualmente o sistema RSTM suporta múltiplos algoritmos e baseado em locks (lock-- based).
Cada algoritmo possui ainda, suas características próprias de detecção de conflito e gerenciamento de contenção além de mecanismos avançados específicos para cada objetivo.
O algoritmo padrão, utilizado neste trabalho, é chamado NoRec (Ver).
O algoritmo possui versionamento preguiçoso (lazy-- versioning) e aquisição também preguiçosa (lazy-- acquire) e é baseado em palavra (word-- based).
NORec combina 3 idéias chave:
Um sequence-lock global;
Um conjunto de escrita indexado;
E detecção de conflito baseado em valor.
O sistema RSTM possui sua última versão de Julho de 2011.
Desde a primeira versão até agora, o grupo criador do RSTM tem desenvolvido diversos algoritmos para incorporação do sistema.
Além disso, novos mecanismos estão sendo propostos e utilizados em novos algoritmos do sistema.
RSTM TL2 é um sistema STM baseado em locks (lock-- based).
TL2 possui uma variação do algoritmo de versionamento de relógio global (global version-- clock) do algoritmo original (Tl) proposto em.
Com essa variação, os autores solucionaram diversos problemas de segurança presentes em sistemas STM baseados em locks além de garantir que o código opere apenas em estados de memória consistentes.
Utiliza esquema baseado em tempo para validação do conjunto de leituras (time-based scheme), aquisição/ versionamento preguiçoso e leitura invisível (invisble reads).
O gerenciador de contenção é tímido, sempre aborta transações atacantes (com um possível atraso).
Um dos objetivos do TL2 é oferecer execução eficiente para transações somente leitura.
Para isso algumas etapas são necessárias para reduzir o custo ao executar tais transações.
Por outro lado, mais etapas são necessárias para executar transações com escrita, o que pode significar um custo alto no desempenho de aplicações.
O sistema TL2 possui sua última versão de Setembro de 2008.
Esse sistema STM, é um dos mais citados na literatura de entre os apresentados nesse trabalho.
TL2 é open-source e pode ser TinySTM é um sistema STM baseado em locks e em palavras (word-- based) também conhecido na literatura.
Utiliza versionamento global (contador compartilhado como relógio) para controlar conflitos entre transações e locks para proteger endereços de memória compartilhada.
TinySTM utiliza aquisição/ versionamento ansioso e leitura invisível (invisble reads).
Assim como no TL2, TinySTM utiliza um vetor de locks compartilhados para gerenciar o acesso a memória.
Cada lock cobre uma porção da memória e são mapeados numa função hash.
O gerenciador de contenção é tímido, assim como no sistema TL2.
O sistema TinySTM foi proposto em 2008 e possui sua última versão de Novembro de 2011.
Entretanto, os testes realizados neste trabalho utilizam a versão de Setembro de 2008, visto que foram desenvolvidos anteriormente a liberação da versão mais atual.
Esse sistema STM, é bastante citado na literatura.
TinySTM é open-source e pode ser encontrado no endereço Intel STM consiste num compilador C/ C+ e uma biblioteca STM em tempo de execução.
O compilador interage com toda a memória compartilhada (leituras/ escrita) dentro de transações através de barreiras.
O escopo do compilador inclui linguagem de extensão para especificar e definir seções atômicas.
A linguagem de extensão inclui diversas construções e palavras chaves para lidar com transações.
A biblioteca STM em tempo de execução suporta a geração de estatísticas transacionais simples que pode ajudar o usuário a entender o desempenho das aplicações e encontrar gargalos.
Algumas das informações são:
Número de vezes que uma transação executou, número de tentativas de execução de uma transação devido a conflito e quantidade de bytes de leitura e escrita transacionais.
A primeira versão do sistema Intel STM foi proposta em 2006 com o nome de McRT-STM.\&gt;
Benchmarks Muitos pesquisadores desenvolveram benchmarks e microbenchmarks para avaliação de sistemas STM.
Microbenchmarks são usualmente bem estruturados e utilizam um conjunto pequeno e regular de transações.
São fáceis de desenvolver, parametrizados e com estrutura de dados simples.
Além disso, são úteis para isolar casos particulares em sistemas STM e são fáceis de portar para outras linguagens/ arquiteturas.
Transações pequenas e simples são importantes para testar a mecânica do sistema STM e comparar detalhes de baixo nível de diferentes implementações.
Entretanto, eles não representam a carga de trabalho de uma aplicação completa.
Aplicações completas possuem transações que constistem em muitas operações em grande volume de dados e ainda possuem muitas operações paralelas e até mesmo sequenciais entre as transações.
Segundo, medir o desempenho de um STM num ambiente excessivamente simplificado pode ser não informativo e, no pior caso, pode causar enganos, pois pode orientar pesquisadores a otimizar aspectos irrelevantes de suas implementações.
Muitos microbenchmarks foram propostos na literatura e amplamente utilizados para avaliação de sistemas STM.
Para avaliações completas de sistemas STM é necessário utilizar benchmarks que representem aplicações reais.
As próximas seções apresentam os principais benchmarks propostos na literatura.
EigenBench é um microbenchmark leve e poderoso para avaliação de sistemas de memórias transacionais.
EigenBench fornece uma compreensão mais profunda do desempenho de Tm através de exploração das características Eigen (características ortogonais que representam a base do entendimento de uma aplicação transacional), avaliando, assim, detalhes das aplicações que não são facilmente alcançáveis por os demais benchmarks existentes.
O benchmark baseia- se nessas características para avaliar aplicações de maneira isolada, ou seja, é possível isolar uma das características sem alterar as demais e assim medir o impacto da mudança através de testes de desempenho.
As características Eigen são descritas com detalhes abaixo:
Essa característica é bastante utilizada na literatura;
Compartilhados aplicação (P $= ciclos).
Por ciclo compartilhado é definido como um ciclo de total de ciclos execução que possui um acesso compartilhado.
Essa característica indica a quantidade de ciclos não transacionais existentes na aplicação.
Por exemplo, se uma aplicação possui 10 ciclos no total, sendo 8 desses ciclos compartilhados, temos a equação P $= 10 $= 0.8, o que indica 80% de ciclos transacionais na aplicação.
Essa característica varia de 0.0 a 1.0, mas também pode ser expressada como baixa, média ou alta predominância;
Essa característica mede a quantidade de ciclos de operações não transacionais dentro de transações.
Por exemplo, se uma aplicação possui 10 ciclos não compartilhados sendo que, 2 $= 0.2, ou seja 80% das de esses são executados fora de transações, temos a equação D $= 10 operações não transacionais são realizadas dentro de transações.
Essa característica varia de Além disso, com o benchmark é possível simular aplicações reais através de um conjunto de parâmetros de entrada que derivadas definem as caracteristicas ortogonais da aplicação.
Em, o benchmark é utilizado para simular o compartamento de aplicações do benchmark STAMP.
Apesar de não ser o foco do benchmark, simular o comportamento de outras aplicações auxilia na comparação de resultados de desempenho.
A Tabela 3.1 apresenta os principais parâmetros de entrada que são utilizados para simular o comportamento de aplicações transacionais.·
Hot Array: Array compartilhado entre todas as threads.
As threads acessam os dados concorrentemente;·
Mild Array: Array acessado dentro de transações, porém, é divido para que cada thread acesse sua porção, ou seja, acessos simultâneos não causam conflitos;·
Cold Array: Array é particionado como o Mild Array, porém é utilizado somente para acesso não transacional.
Através do conjunto de parâmetros apresentados na Tabela 3.1 é possível derivar as características Eigen.
A Tabela 3.2 apresenta a derivação das características ortogonais.
As três características não derivadas apresentadas na Tabela 3.2 são complexas e dependem de informações adicionais do sistema utilizado.
Entretanto, o trabalho apresenta pouca informação a respeito.
Lee-TM é um benchmark baseado no algoritmo de roteamento de circuitos Lee que oferece carga de trabalho grande e realísta.
O algoritmo seleciona pares de pontos (por exemplo, de um circuito integrado) como entrada e produz rotas sem interseção entre eles.
Enquanto as transações de Lee-TM são significativas em tamanho, elas apresentam padrões de acesso muito regular -- cada transação primeiramente lê uma grande número de localidades (procurando por caminhos adequados) e após atualiza um pequeno número de elas (criação de um caminho).
Além disso, o benchmark usa objetos muito simples (cada um pode ser representado como uma váriavel inteira).
É interessante notar que o STAMP contém um aplicativo (chamado Labyrinth) que utiliza o mesmo algoritmo de Lee.
Entretanto, Lee-TM usa dados de entrada do mundo real o que o torna mais realísta do que o Labyrinth.
Lee-TM inclui dois conjuntos de entrada:
Memória e circuitos de placas mãe.
A limitação deste benchmark é o padrão de acesso regular presente nas transações e o fato de ter foco específico numa aplicação apenas, não exercitando assim, toda a amplitude dos comportamentos de um sistema STM.
Lee-TM é open-source e pode ser encontrado no endereço RMS-TM é uma suíte de aplicações para benchmark de Memórias Transacionais composto de 7 aplicações reais para mineração, reconhecimento e síntese (Recognition, Mining and Synthesis (RMS)).
Além de incluir os principais problemas das pesquisas com Tm como transações aninhadas, chamadas de sistema e operações de entrada e saída (I/ O), as aplicações fornecem uma variedade de transações pequenas e grandes com conjuntos de leitura/ escritas grandes e pequenos bem como níveis de contenção pequeno, médio e grande.
A suíte ainda possui versões das aplicações com locks, o que possibilita a comparação de versões transacionais com versões utilizando mecanismos tradicionais de sincronização.
Além de as características citadas acima, o benchmark suporta sistemas STM e HTM e tem uma boa escalabilidade.
A limitação desta suíte é o tamanho das transações que não é grande comparado com outros benchmarks bem como o tempo em transações também não é alto.
RMS-TM é open-source e pode STAMP é uma suíte de aplicações para benchmark de sistemas STM.
A suíte consiste em oito aplicações diferentes e dez cargas de trabalho.
Aplicações STAMP representam cargas de trabalho do mundo real para diversas áreas como bioinformática, engenharia, computação gráfica e aprendizado de máquina.
A Tabela 3.3 apresenta as aplicações do STAMP bem como sua área e uma breve descrição.
Para que seja possível realizar análises sobre os mais diversos sistemas de Memórias Transacionais, é necessário um benchmark com as seguintes características:·
Amplitude: Precisa utilizar aplicações e algoritmos que tenham benefício na utilização de Memórias Transacionais;·
Dimensão: Precisa cobrir uma grande quantidade de variações no design dos sistemas Tm, como tamanho de transações, tamanho do grão, políticas de decisão de aborts, etc;·
Portabilidade: Precisa ser compatível com um grande número de sistemas Tm, cobrindo software, hardware e soluções híbridas.
Com base nessas características foi criado o benchmark STAMP.
O STAMP possui um conjunto de 8 aplicações com 30 diferentes configurações e dados de entrada que exploram uma variedade de comportamentos transacionais.
O design deste benchmark é baseado nas características citadas, visto que baseou- se em elas para a seleção/ implementação das aplicações:·
Amplitude: As aplicações foram escolhidas de acordo com sua dificuldade de paralelismo e buscando diferentes tipos de algoritmos em diferentes áreas do conhecimento.
Em o conjunto de aplicações há 7 áreas diferentes, como por exemplo, bioinformática, engenharia e segurança;·
Dimensão: Em o conjunto de aplicações presente, existe uma ampla cobertura de comportamentos transacionais, tais como diversos graus de contenção, transações pequenas e grandes e diferentes tamanhos de conjuntos de leitura e escrita.
Além disso, existem aplicações que utilizam transações de granularidade alta e utilizam uma grande parcela do tempo das aplicações dentro de transações;·
Portabilidade: Em o STAMP é possível utilizar sistemas Tm de qualquer classe (hardware, software e híbrido), e o código é facilmente portável.
Para que se possa ter uma visão mais aprofundada das aplicações utilizadas, e que se possa analisar posteriormente os resultados obtidos nos sistemas Tm, é necessário conhecer detalhadamente as aplicações do benchmark, bem como suas características transacionais.
A seguir, serão apresentadas as aplicações, mostrando sua área do conhecimento, seu funcionamento e suas caraterísticas transacionais.
Em a versão Tm dessa aplicação, as fases de captura e remontagem são encapsuladas em transações.
A aplicação possui transações pequenas e seu nível de contenção oscila de médio a alto dependendo da frequência da fase de remontagem.
Além disso, possui uma quantidade moderada de tempo de execução total em transações;
Cada thread processa uma parcela de dados iterativamente e armezena num cluster central.
A versão Tm adiciona uma transação para proteger a atualização do cluster central, que ocorre durante cada iteração.
A quantidade de contenção entre as threads depende do valor de subconjuntos.
Com diversos subconjuntos ocorrerão menos conflitos, visto que menos provavelmente os dados serão guardados no mesmo subconjunto.
O tamanho da transação e dos conjuntos de leitura e escrita são pequenos nessa aplicação.
Por fim, a maior parte do tempo é utilizada para calcular o subconjunto a ser utilizado, e nesse momento não há transação, pois os dados são locais de cada thread.
Portanto, o tempo gasto em transações é relativamente pequeno;
Devido a isso, a aplicação gasta uma grande quantidade de tempo de execução em transações e suas transações possuem tamanho médio com conjuntos de leitura e escrita moderados.
Níveis baixos a moderados de contenção entre os segmentos podem ser criados, aumentando a fração de sessões que modificam grandes porções do banco de dados;
Delaunay. As estruturas de dados básicas são um grafo que armazena todos os triângulos da malha, um conjunto que contém os segmentos de fronteira da malha, e uma fila de tarefas que contém os triângulos que precisam ser refinados.
Em cada iteração, um triângulo compacto é removido da fila de trabalho, e uma reorganização dos triângulos é realizada sobre a malha, e quaisquer novos triângulos compactos resultantes são adicionados à fila de trabalho.
O acesso a fila de trabalho é encapsulado por uma transação, assim como o refinamento do triângulo.
Como quase todo o tempo de execução é gasto no cálculo de reorganização dos triângulos, a aplicação possui transações grandes e gasta quase todo o tempo em transações.
Além disso, possui conjuntos grandes de leitura e escrita e uma quantidade moderada de contenção.
A limitação desse benchmark são o tamanho das transações, que são pequenas comparado com os STMBench7 é um benchmark sintético onde suas cargas de trabalho visam representar aplicações orientadas a objetos realistas e complexas que são alvos importantes para STM.
Ele apresenta uma grande variedade de operações (de operações pequenas somente leitura até operações grandes que modificam grande quantidades de estrutura de dados) e carga de trabalho (de cargas contendo, principalmente, transações de somente leitura até transações com escrita dominante).
A estrutura de dados utilizada por o STMBench7 é diversas vezes maior do que outros típicos benchmarks STM.
Além disso, suas transações são maiores e acessam um maior número de objetos.
STMBench7 é inerentemente baseado em objeto e suas implementações utilizam a biblioteca padrão.
Pequenas modificações são necessárias para utilizar- lo em STMs baseados em palavra (word-- based).
Este benchmark é conhecido, na literatura, por testar os sistemas STM em busca de falhas.
Visto que seu diferencial é sua grande estrutura de dados e suas transações longas, o benchmark é, geralmente, utilizado para testes de estresse.
O trabalho apresenta testes realizados com STMBench7 em conjunto com diferentes sistemas STM onde todos falharam antes de finalizar a execução.
Apesar de ser um benchmark mais robusto o mesmo é focado num domínio de aplicação específico e não foi projetado para exercitar toda a amplitude dos comportamentos dos sistemas STM.
Ns /wiki/doku.
Php? Id $= stmbench7.
Trabalhos Relacionados Em a literatura de Memórias Transacionais de Software é possível encontrar inúmeras publicações tanto com foco em sistemas e em novos algoritmos para solucionar os principais problemas da área, como também aplicações com foco em avaliar os mecanismos e as principais decisões de projeto dos sistemas atuais.
Apesar disso, poucos trabalhos apresentam a visão geral da área, apresentando o contexto geral e focando no desempenho de sistemas e aplicações, que apresenta ser, de acordo com os trabalhos analisados, um dos principais problemas da área.
Além disso, falta trabalhos com foco na avaliação dos principais sistemas STM presentes na literatura, assim como falta entender as principais caraterísticas de aplicações transacionais.
Os trabalhos de avaliação existentes, geralmente, são voltados para testes de um benchmark ou sistema STM proposto e observações são realizadas com foco na proposta apresentada.
Tais trabalhos, possuem a avaliação apenas para comprovação de desempenho e não como investigação do comportamento do sistema ou benchmark.
Por conseguinte, ainda que existam proposta de novos sistemas e benchmarks que possuam avaliações de desempenho e comportamento, trabalhos com propostas similares a deste trabalho ainda são raros na literatura.
Entretanto, a comparação com os diferentes trabalhos propostos na literatura que possuam avaliações similares as apresentadas neste trabalho são de grande importância para substanciar os resultados deste trabalho.
As seções seguintes apresentam trabalhos científicos que possuem relação com a proposta deste trabalho.
Em a Seção 3.3.1 são apresentados os trabalhos que exibem avaliações de benchmarks e/ ou sistemas STM que possuem similaridade com os testes aqui apresentados.
A Seção 3.3.2 apresenta trabalhos que utilizam mecanismos avançados de análise de execuções de aplicações STM.
Diversas propostas de sistemas STM tem sido apresentadas na literatura, e para cada proposta é apresentado testes de desempenho utilizando apenas benchmarks ou comparativos com outros sistemas.
Entretanto diversas prospostas de sistemas apresentam testes com microbenchmarks que não representam uma aplicação transacional realista, conforme descrito na Seção 3.2 deste capítulo.
Em esta seção são apresentados os trabalhos que possuem testes similares com os testes realizados neste trabalho e que, são citados ao longo de o texto.
Apesar de os trabalhos apresentarem objetivos diferentes do apresentado neste trabalho, a comparação dos resultados são de grande importância para reforçar e complementar as conclusões realizadas.
Cascaval et al, apresenta uma comparação de desempenho com os sistemas TL2, Intel STM e XL.
As aplicações utilizadas na comparação são Kmeans, Genome e Vacation do benchmark STAMP e outros dois microbenchmarks.
Minh et al, propôs o benchmark STAMP composto por 8 aplicações de diferentes domínios e com 10 cargas de trabalho.
Em este trabalho é realizado uma comparação com o próprio benchmark e um simulador para HTM e STM.
Dragojevi et al, propôs uma nova implementação STM chamada SwissTM.
Em este trabalho é apresentado uma comparação utilizando os benchmarks STMBench7, Lee-TM, STAMP e um microbenchmark.
Além disso, foram utilizados os sistemas TinySTM, TL2 e RSTM Rui et al, apresenta uma comparação de desempenho com o benchmark STAMP.
Foram utilizados para esse teste os sistemas TL2 e TinySTM.
Dragojevi et al, apresenta uma comparação de desempenho recente utilizando o sistema SwissTM e os benchmarks STMBench7 e STAMP e um conjunto de microbenchmarks.
Em este trabalho porém, o código do SwissTM foi adaptado para realizar testes com suporte a privatização e a um compilador STM.
Hong et al, propôs um novo benchmark que apresenta um novo conceito de características transacionais.
O benchmark, através de parâmetros de entrada, simula o comportamento de aplicações do STAMP e realiza uma comparação de desempenho das versões simuladas com as versões originais.
Conforme citado na Seção 1.1, o objetivo deste trabalho é, inicialmente, entender o comportamento de sistemas STM e suas aplicações e também, compreender os problemas atuais da área e identificar melhorias e oportunidades de crescimento nos sistemas STM de maneira a contribuir para a comunidade.
Para tanto, pesquisadores estão buscando investigar os sistemas STM em camadas mais baixas do sistema, através de técnicas de tracing e profiling.
Ansari et al.,
modificou uma implementação STM para coleta de informações relevantes durante a execução de aplicações.
É apresentado um conjunto de 12 métricas para caracterizar aplicações Tm, tais como Speed-up e ApC (Aborts per Commit), métricas utilizadas nesse trabalho.
Foram selecionadas três aplicações do benchmark STAMP e o benchmark Lee-TM para investigar as métricas e compreender o impacto no sistema utilizado.
Lourenço et al.
Propôs um framework de monitoramento com baixo overhead, desenvolvido especificamente para monitoramento de aplicações Tm.
O framework coleta eventos transacionais e insere num arquivo de log.
Além disso foi desenvolvido uma ferramenta de visualização para apresentar os dados transacionais coletados.
Castro et al.,
propôs uma abordagem para coleta de informações relevantes sobre transações baseado numa biblioteca compartilhada do linux que monitora eventos das transações de uma aplicação e armazena num arquivo de log para posterior análise.
Foram monitorados eventos de commits e aborts e analisado os resultados de três sistemas Tm.
Zyulkyarov et al.,
propôs uma série de técnicas para traçar o perfil de aplicações Tm, que fornecem informações sobre o tempo perdido causado por transações abortadas.
O trabalho explora 3 direções distintas:
Técnicas para identificar potenciais conflitos;
Técnicas para identificar as estruturas de dados envolvidas nos conflitos;
Técnicas de visualização para apresentar resumidamente como as threads utilizando seu tempo e quais transações conflitam mas frequentemente.
A proposta deste trabalho difere dos trabalhos acima pois foca numa avaliação geral tanto de aplicações como de implementações STM sem a necessidade de alteração de código e abrangendo um conjunto abrangente de sistemas/ aplicações.
Essa abordagem tem por vantagem utilizar uma variedade maior de sistemas STM, ao contrário de os trabalhos que alteram o código de um único sistema STM para coleta de informações.
Adicionalmente, a abordagem sugerida não acrescenta overhead nas execuções ao realizar a análise, em oposto aos trabalhos que aumentam o tempo de execução das aplicações devido a o acréscimo de operações adicionais para a coleta de dados.
Por fim, é possível avaliar um maior número de sistemas STM e aplicações, visto que nenhum modificação é necessária, ao contrário de os trabalhos apresentados que utilizam poucas aplicações/ sistemas para coleta de informações.
Através dessa abordagem, é possível analisar o comportamento tanto das aplicações utlizadas, ao executar aplicações com diversos sistemas STM, bem como investigar os sistemas STM, ao comparar os resultados de aplicações entre os sistemas utilizados.
De entre os sistemas apresentados nas seções anteriores os selecionados para utilização neste trabalho são:·
SwissTM: Um sistema STM eficaz e com ótimos resultados na literatura.
Possui mecanismos avançados para reduzir o overhead e foi elaborado a partir de diversos experimentos com as principais decisões de projeto de sistemas STM.
Além disso, possui atualização constante e a última versão é do ano corrente;·
RSTM: Um sistema STM que possui diversas publicações e diversas citações em outros trabalhos na literatura.
Foi criado em 2006, porém apresenta características e mecanismos atuais para redução do overhead, visto que é atualizado constantemente.
Possui última versão do ano corrente;·
TL2: Apesar de não possuir atualização recente, é um dos mais importantes sistemas STM proposto na literatura, possuindo diversas citações;·
TinySTM: Sistema STM também muito citado na literatura.
Apresenta características semelhantes ao TL2, não é atualizado frequentemente, porém tem versão final do ano corrente (não utilizada neste trabalho devido a diferenças de datas).
Com relação a os sistemas STM escolhidos, todos são baseados em biblioteca.
O Intel STM Compiler, apesar de ser um STM atual conhecido na literatura, não foi selecionado pois não se encaixa com o padrão dos outros sistemas utilizados.
Primeiramente, de entre os benchmarks utilizados ou não tem suporte para o sistemas baseados em compilador ou a adaptação é não trivial.
Em segundo lugar, o sistema necessita licença para utilização, possuindo apenas período de avaliação de 30 dias.
Apesar de a possibilidade de avaliação, o foco do trabalho é utilizar sistemas STM disponíveis para a comunidade, onde o código fonte é disponibilizado para que melhorias sejam acrescentadas e utilizadas por toda a comunidade.
Por fim, diversos autores questionam a utilização desse tipo de sistemas devido a quantidade de overhead adicionada.
Foram apresentados também, os principais benchmarks propostos na literatura.
A Tabela 3.5 resume os benchmarks apresentados, a versão atual e a data da última atualização.
Ao contrário de alguns sistemas STM apresentados, os benchmarks não possuem atualizações frequentes e muitos não foram atualizados desde sua criação.
O benchmark STAMP, por exemplo, foi atualizado por a última vez em Setembro de 2008 e continua sendo amplamente citado e, principalmente, utilizado por a comunidade científica.
Por outro lado, atualizações são importantes para suportar novos sistemas STM, novas necessidades de avaliação e também para correção geral de bugs.
Em relação a o suporte a sistemas STM, o benchmark RMS-TM não possui suporte a sistemas STM baseados em biblioteca.
O benchmark STMBench7 não suporta a versão atual do sistema RSTM e as modificações para o suporte envolvem modificação de ambos os códigos fontes.
O benchmark Lee-TM suportava os sistemas TinySTM, TL2 e RSTM, porém não possui atualização recente e apresentou problemas ao executar nos sistemas com versões atuais (incluindo SwissTM).
Por fim, o benchmark EigenBench foi modificado para suportar o sistema RSTM e atualizado para suporte a última versão do sistema SwissTM.
De entre os benchmarks apresentados, os selecionados para utilização neste trabalho são:·
EigenBench: Apresenta inovação na avaliação de aplicações e sistemas STM através de características que representam a base do entendimento de uma aplicação transacional.
É importante para entender o comportamento transacional atual das aplicações, bem como explorar as características do sistemas STM através de testes de características ortogonais isoladas;·
STAMP: Benchmark completo que apresenta 8 aplicações de diferentes domínios.
É amplamente utilizado na literatura.
Apesar de não possuir transações tão grandes quanto outros benchmarks apresentados, o conjunto de oito aplicações com diferentes cargas de trabalho e grande volume de dados de entrada reduzem o impacto.
Além disso, é extremamente adaptável a novos sistemas STM e possui versão sequencial das aplicações do benchmark.
A listagem acima apresenta os benchmarks que melhor se encaixam com o perfil e objetivo deste trabalho.
De entre os sistemas excluídos, alguns não possuem compatibilidade com os sistemas selecionados e outros não se encaixam no objetivo do trabalho.
O RMS-TM, por exemplo, é um ótimo benchmark pois além de possuir 7 aplicações que abrangem diversos tamanhos de transação, tempos em transação e quantidade de contenção possui, ainda, características pouco exploradas como transações aninhadas, chamadas de sistemas e chamadas para outras bibliotecas dentro de transações.
Além disso, o benchmark ainda possui versão com locks para todas as aplicações, o que é um diferencial para comparação entre as abordagens paralelas.
Entretanto, apesar de as vantagens, o benchmark não pode ser utilizado devido a incompatibilidade com sistemas baseados em biblioteca.
Por outro lado, Lee-TM possui acesso regular a memória nas transações, o que não é necessariamente uma característica presente em aplicações reais.
Além disso, o benchmark não possui suporte a novos sistemas STM e não possui uma abordagem simples para suportar modificações que possibilitem o suporte.
Por fim, o benchmark STMBench7 apresenta caracaterísticas exigentes, visto que é o benchmark que mais estimula os sistemas STM.
Entretanto, o mesmo tem foco em testes de estresse.
Além disso, apresentou incompatibilidade com as últimas versões do sistema RSTM e não apresenta versão sequencial para comparação de resultados.
Conforme apresentado na Seção 1.1 a motivação deste trabalho é apresentar, de maneira clara, uma análise mais completa sobre Sistemas de Memórias Transacionais de Software bem como seus benchmarks presentes na literatura.
Por análise completa, entende- se analisar o desempenho dos sistemas STM, através de execuções com diversas aplicações Tm, de maneira crítica, tentando identificar o porque do comportamento das aplicações.
Essa análise visa identificar caminhos para contribuir para a comunidade responder as perguntas propostas na Seção 1.1, que são de grande importância para o futuro dos sistemas de Memórias Transacionais.
Segundo, ainda é um desafio saber que tipo de aplicações pode realmente tirar proveito de sistemas Tm.
O trabalho recente ainda questiona a capacidade de sistemas STM proporcionar bom desempenho devido a os resultados de baixo desempenho apresentados no trabalho.
Conforme identificado por é fundamental investigar o motivo do baixo desempenho em algumas execuções com aplicações Tm e ainda saber identificar previamente quais aplicações podem se beneficiar do paradigma.
Em os próximos capítulos são apresentados os testes executados, a metodologia utilizada em cada testes e os resultados obtidos.
Em a Seção 5 são apresentados os testes de desempenho com o benchmark STAMP, na Seção 6 são apresentados os testes de desempenho com o benchmark EigenBench e na Seção 7 são apresentados os testes específicos focados em características isoladas de aplicações transacionais.
Para a realização dos testes, é necessário identificar a arquitetura, geralmente utilizada, em testes de trabalhos relacionados na literatura.
Além disso, devido a grande quantidade de testes realizados é importante utilizar algum mecanismos para validar as execuções e garantir confiabilidade dos resultados.
Portanto, a Seção 4.1 apresenta um levantamento das arquiteturas utilizadas para testes de desempenho de sistemas STM na literatura, bem como a arquitetura utilizada neste trabalho e informações sobre o equipamento utilizado.
Por fim, é apresentado, na Seção 4.2, as técnicas e fórmulas da estatística utilizadas para garantir a confiabilidade dos resultados gerados neste trabalho.
Arquitetura Para a realização dos testes foram coletados os processadores utilizados nos diversos trabalhos estudados, buscando identificar o padrão de arquitetura que melhor se encaixe com o perfil de Memórias Transacionais.
O foco desta área é arquiteturas multicore.
Os trabalhos utilizam, em geral, computadores com dois ou mais cores.
A Tabela 4.1 apresenta um resumo dos computadores utilizados para testes em diferentes trabalhos realizados com Memórias Transacionais.
Os testes realizados nos trabalhos citados vão desde teste de sistema STM, benchmarks, testes de desempenho, entre outros.
É possível determinar o computador com perfil semelhante para executar os testes prospostos nesse trabalho.
A máquina selecionada para os testes é uma Dell PowerEdge R610 composto por 2 processadores Intel Xeon quad- core E5520 2.27 GHz Hyper--Threading, 16 GB de memória e 150 GB de HD.
A máquina totaliza 8 cores físicos e mais 8 cores virtuais.
A máquina selecionada se encaixa perfeitamente com o padrão utilizado nos demais trabalhos coletados.
É importante ressaltar que apesar de a máquina suportar Hyper--Threading, o recurso não foi utilizado, ou seja somente foram utilizados cores físicos.
Portanto, os testes deste trabalho foram executados com 1, 2, 4, 6 e 8 cores.
Análise Estatística Este trabalho utiliza métodos estatísticos para substanciar os resultados obtidos nos testes executados.
Isso torna os resultados mas próximos da realidade e garante uma confiabilidade dos números apresentados.
A o executar testes de desempenho como os descritos neste trabalho o valor final para uma única execução pode variar significativamente.
A o executar o mesmo teste diversas vezes chegamos a um conjunto de resultados possíveis.
A diferença entre os valores obtidos pode variar de acordo com a aplicação executada.
Além disso, execuções podem variar de resultado devido a outros fatores, tais como:·
Variações do ambiente:
Qualquer interrupção ou comando adicional do sistema operacional poderá influenciar no resultado final.·
Valor outlier:
Um outlier (ou valor discrepante) é um valor que se localiza muito distante de quase todos os outros valores.
Em o caso específico deste trabalho, dado um conjunto de execuções onde o valor de uma execução é muito diferente dos demais resultados.
Esse resultado diferente é um valor discrepante ou (outlier).
Em a literatura da área de estatística, testes como os descritos nesse trabalho devem ser executados mais do que 30 vezes.
Porém dependendo da variação dos valores nas execuções mais execuções tornam- se necessárias.
Em a seção seguinte serão utilizados termos específicos da área de estatística o que difere com os termos utilizados nas demais seções de testes deste capítulo.
Para minimizar essa diferença na terminologia e auxiliar o entendimento da estatística nesse trabalho são listados abaixo os termos específicos da área e sua equivalência nesse trabalho.·
População: É o conjunto de dados utilizados nos cálculos.
Em esse contexto, é infinito pois podemos realizar tantos testes quanto necessários, não há um limite de execuções;·
Amostra: É um membro da população, representa uma execução;·
Média amostral:
É a média dos valores do conjunto de amostras.
Em esse trabalho utiliza- se no mínimo 31 execuções.
A média amostral é portanto a média das 31 execuções realizadas.·
Desvio padrão amostral:
É o desvio padrão dos valores do conjunto de amostras.
Em esse trabalho utiliza- se no mínimo 31 execuções.
O desvio padrão amostral é portanto o desvio padrão das 31 execuções realizadas.·
População normalmente distribuída:
É uma população onde os dados são próximos e que não possua nenhum valor outlier (valor fora de o padrão dos demais valores).
Para complementar a utilização da estatística nesse trabalho a próxima seção apresenta mais detalhes do conceito de confiablidade, descrevendo as fórmulas e os conceitos necessários para os testes de desempenho.
Confiabilidade é o grau de confiança de um resultado, ou seja, indica o quão podemos confiar que um resultado está correto.
O nível de confiabilidade é representado através de porcentagem.
Em a literatura, é comum utilizar um nível de confiabilidade de 90%, 95% e 99%, sendo 95% o mais comum.
Através de fórmulas estatísticas é possível estimar a quantidade ideal (ou mínima) de execuções dos testes realizados garantindo assim resultados mais confiáveis.
De maneira geral, quanto mais execuções ocorrerem mais confiável fica o resultado final.
A fórmula 4.1 é utilizada para determinar a quantidade de amostras necessárias (execuções) para garantirmos uma confiabilidade de 95%:
E $= margem de erro desejada $= desvio padrão da população n $= quantidade de execuções necessárias Para encontrar o z crítico é necessário consultar a Tabela 4.2 retirada de.
O valor E indica o erro máximo desejado.
Esse valor deve ser atribuído conforme a variação desejada dos resultados, ou seja, um erro desejado de 1 segundo indica que 1 segundo de diferença entre os resultados é um valor aceitável.
Por fim, o desvio padrão da população não pode ser obtido visto que o número de execuções tende a infinito.
Para obter esse valor é necessário executar um teste piloto com 31 execuções e coletar o desvio padrão desses resultados.
Esse desvio padrão é chamado de amostral e pode substituir o desvio padrão da polução desde que n\&gt; 30 e a população é normalmente distribuída.
Esse desvio padrão é utilizado para calcular o verdadeiro valor de n, a quantidade de execuções.
Em este trabalho os valores selecionados para cada variável descrita na fórmula 4.1 são:
Z/ 2 $= 1.96 E $= 0.5 segundos (Admite um erro máximo de meio segundo) $= valor variável (Depende da execução das aplicações) Assim temos a seguinte fórmula pré-definida 4.2 para utilização no próximo capítulo onde será apresentado os testes.
Conforme citado anteriormente é necessário realizar um teste piloto com 31 execuções para obtermos o desvio padrão amostral.
Dependendo do resultado obtido na fórmula 4.1 mais execuções podem ser necessárias.
É importante ressaltar que mesmo obtendo valores inferiores a 31 na fórmula 4.2 os testes utilizaram 31 execuções no mínimo.
Além de estimar as execuções ainda é possível calcular o intervalo de confiança de um resultado indicando o intervalo de variação daquele valor para mais ou para menos.
Esse intervalo é importante pois indica uma faixa de valores onde o resultado final estará contido.
Segundo, intervalo de confiança consiste numa faixa (ou intervalo) de valores, em vez de apenas um único valor.
Um intervalo de confiança está associado a um nível de confiança, tal como 95%.
O nível de confiança nos dá a taxa de sucesso do procedimento usado para construir o intervalo de confiança.
Para calcular o intervalo de confiança é necessário selecionar uma distribuição.
A distribuição é selecionada conforme a população (resultados) e ela é importante pois as fórmulas de cálculo mudam de acordo com a distribuição escolhida.
A Tabela 4.3 apresenta as duas distribuições possíveis e os critérios de escolha de cada uma.
Como visto anteriormente todos os testes realizados nesse trabalho possuem n\&gt; 30, portanto ambas as distribuições podem ser escolhidas conforme esse critério.
Porém, não é possível termos (desvio padrão da população) conhecido visto que o número de execuções tende ao infinito.
Portanto, a distribuição escolhida é a distribuição t (também conhecida como t de Student).
A fórmula 4.3 é utilizada para determinar o intervalo de confiança.
Para determinar o intervalo de confiança é necessário calcular o erro encontrado na média dos resultados, ou seja, a diferença de valores dos resultados coletados.
Para calcular o erro utiliza- se a fórmula 4.4.
E $= t/ 2. Onde,¯ $=
média amostral E $= margem de erro onde, t/ 2 $= é o valor crítico s $= desvio padrão amostral n $= número de amostras Para calcular o valor crítico é necessário consultar a tabela da distribuição t, presente em.
Por exemplo, para um número de n $= 31 e o nível de confiança $= 95% chega- se a um t/ 2 $= 2.042.
Em o apêndice A são apresentados os valores de t/ 2 para conjunto de execuções.
Este capítulo descreve os testes de desempenho com o benchmark STAMP.
Em a Seção 5.1 é apresentada a metodologia, descrevendo- se como o testes são executados e seus objetivos.
Em a Seção 5.2 são apresentados os resultados e uma análise crítica com observações sobre os testes executados.
Por fim, na Seção 5.3 é apresentado um resumo com as considerações finais e as contribuições deste capítulo.
Metodologia O teste com o benchmark STAMP tem o objetivo inicial de avaliar o desempenho dos principais sistemas STM propostos na literatura de maneira neutra, ou seja, sem apresentação de nenhuma prosposta de sistema ou algoritmo para sistemas STM.
Apesar de diversos trabalhos na literatura realizar testes com o benchmark STAMP, não existe material com uma avaliação neutra dos principais sistemas STM da atualidade.
Outro importante objetivo do teste é identificar comportamentos no desempenho das aplicações presentes no benchmark.
Visto que, o STAMP é composto por diversas aplicações de domínios e comportamentos diferentes, o objetivo é analisar o desempenho dessas aplicações em conjunto com suas características transacionais.
Tal análise tem como propósito identificar o comportamento das transações e seus motivos.
Para a realização dos testes, são selecionados os quatro sistemas STM mais relevantes propostos na literatura conforme seleção apresentada na Seção 3.4.
A Tabela 5.1 resume os sistemas utilizados e apresenta a última versão de cada um e a data da última versão.
Os critérios de avaliação para seleção dos sistemas STM são sua relevância na literatura (quantidade de citações) e as últimas atualizações.
Como exemplo, há o SwissTM, que tem sua última versão de Agosto de 2011, mas que não é o sistema mais citado de entre os selecionados.
Em contrapartida, o TL2 não possui versão recente, porém, é citado em diversos trabalhos na literatura.
Conforme apresentado na Seção 3.2 o STAMP é composto por 8 aplicações diferentes e apresenta a mais completa variação de carga de trabalho e comportamentos transacionais entre os benchmarks atuais de STM.
Além disso, é composto por aplicações de diferentes áreas como computação gráfica, bioinformática, segurança e mineração de dados, conforme apresentado na Tabela 3.3.
Para garantir a confiabilidade dos resultados gerados, todas as aplicações são executadas mais de 30 vezes.
Em a Seção 4.2.1 são apresentados os cálculos realizados que indicam a quantidade de execuções por aplicação do STAMP.
Os testes foram executados numa máquina multicore descrita na Seção 4.1.
Para realizar a análise dos resultados, a seguinte métrica é utilizada:·
Speed-up: O cálculo de speed-up mostra o quão bem os sistemas STM escalam com um determinado número de core.
É calculado da seguinte forma:
Fração do tempo sequencial dividido por o tempo paralelo (Speed -- up $= tempo paralelo).
O resultado bom ou ruim é dependente do número de cores utilizados.
Para uma execução com dois cores, um speed-up $= 2 é o valor ideal;
Com quatro cores é esperado um speed-up $= 4 e assim por diante.
Isso significa que o tempo paralelo é 2/4 vezes mais rápido que o sequencial.
Um speed-up alto depende não somente do sistema STM, mas também da aplicação transacional.
O STAMP é facilmente configurável para diversos sistemas de Memórias Transacionais.
Por padrão, o sistema utilizado é o TL2, visto que a versão x86 da aplicação foi portada por o próprio grupo do STAMP.
Para executar as aplicações utilizando outra implementação de sistema Tm, é necessário modificar o arquivo common/ Defines.
Common. Mk, alterando o caminho da chave STM para a localização da biblioteca a ser utilizada.
As aplicações presentes no STAMP possuem diversos parâmetros a serem utilizados de modo a explorar o paralelismo dos sistemas STM, além de possibitar diversos tipos de execuções.
Em os testes realizados, as aplicações são executadas conforme configuração padrão apresentada em.
Conforme a listagem de parâmetros acima, todos as aplicações executaram com os maiores tamanhos possíveis de entrada, com exceção da aplicação Bayes, que apresentou problemas na execução com a biblioteca TL2 e rodou numa versão intermediária.
Além de os parâmetros citados, todas as aplicações recebem como parâmetro o número de threads em a qual o código deverá executar.
Para todas as aplicações são executadas a versão sequencial, presente na distribuição do STAMP, e até 4 versões STM:
2, 4, 6 e 8 threads.
Os sistemas SwissTM e RSTM são executados com 2, 4, 6 e 8 threads, enquanto os sistemas TL2 e TinySTM são executados com 2, 4 e 8 threads.
O benchmark STAMP possui uma limitação que impossibilita a execução com 6 threads nos sistemas TL2 e TinySTM.
A seção seguinte apresenta os resultados desse teste bem como a análise dos resultados obtidos.
Resultados Essa seção apresenta os resultados para os testes de desempenho com o benchmark STAMP.
As Figuras 5.1, 5.2 e 5.3 exibem os resultados do teste.
A Figura 5.1 apresenta os resultados com ênfase nos sistemas STM.
Em ela é possível ver o desempenho geral dos sistemas com todas as aplicações do benchmark.
As Figuras 5.2 e 5.3 apresentam os resultados com ênfase nas aplicações, mostrando um gráfico por aplicação.
Os dados são apresentados de duas formas diferentes para facilitar a interpretação dos resultados dependendo do objetivo.
A Figura 5.1 tem por objetivo a análise de desempenho dos sistemas testados, enquanto que as Figuras 5.2 e 5.3 têm ênfase no comportamento das aplicações.
Em relação a a comparação do desempenho geral dos sistemas testados, SwissTM e RSTM apresentam desempenho superior em relação a os outros dois.
Essa constatação era esperada devido as atualizações frequentes das ferramentas, visto que ambas possuem última versão finalizada em 2011.
As atualizações frequentes e recentes demonstram o esforço para se alcançarem melhores resultados, o que é comprovado na Figura 5.1.
Entre os dois sistemas, o SwissTM possui vantagens em diversas configurações de cores e aplicações.
O sistema que apresenta o pior desempenho nos testes é o sistema TL2.
Além de não possuir atualizações recentes desde sua criação, o sistema utiliza detecção de conflito preguiçosa, que é comumente conhecida na literatura como tendo o pior desempenho entre esse tipo de mecanismo.
Uma importante observação, que justifica em parte o baixo desempenho geral dos sistemas STM, é o fato de algumas aplicações não serem totalmente transacionais.
Isso significa que, é possível, identificar partes de código fonte não transacionais, ou seja, as aplicações não são 100% preparadas para serem executadas de maneira transacional e por isso, não são esperados valores de speed-up próximos do ideal.
Contudo, mesmo possuindo partes não transacionais, os resultados apresentados são insatisfatórios, e ainda é necessário investigar as características transacionais de tais aplicações em busca de motivos para o baixo desempenho.
De entre as oito aplicações, apenas duas atingiram desempenho bom ao ideal em alguma configuração de cores:
Genome e Labyrinth.
A aplicação Labyrinth apresenta ótimo desempenho com dois cores em todos os sistemas.
Já com quatro cores, apenas RSTM e SwissTM mantiveram desempenho bom.
Já a aplicações Genome alcançou desempenho com dois cores ideal com RSTM e muito próximo com os outros sistemas.
Acima de quatro cores, os sistemas SwissTM e RSTM apresentam melhor desempenho geral.
YADA que apresenta desempenho inferior em todos os sistemas.
O mesmo acontece com aplicações com desempenho superior, que é o caso da aplicação Labyrinth, que apresenta resultado ideal com dois cores em todos os sistemas, e a Genome, que apresenta resultado bom com dois cores.
Por padrão de comportamento entende- se que as aplicações tiveram resultados semelhantes entre os sistemas STM, apesar de existir diferenças de valores.
Esse padrão pode ser observado em todas as aplicações e fica mais evidente na Tabela 5.2.
A tabela mostra os resultados de apenas dois sistemas, apesar de o padrão encontrado existir em todas os sistemas.
A tabela apresenta somente 2 sistemas pois facilita a interpretação da tabela e também por ser os sistemas que obtiveram o melhor desempenho geral.
1. Aplicações com resultados ruins e sem escalabilidade:
Esse grupo apresenta aplicações que tiveram resultado ruim em todos os sistemas STM e ainda não tiveram escalabilidade (ou escalabilidade mínima) com o aumento de cores;
De maneira a clarificar os conceitos de bom e ruim utilizados neste trabalho, a Tabela 5.3 apresenta os critérios utilizados para caracterizar o desempenho das aplicações.
A tabela apresenta os níveis de desempenho, o valor mínimo do nível para cada configuração de cores e o critério do nível.
Por exemplo, para considerar um resultado como 'Bom' numa execução com dois cores, o speed-up deve estar acima de 1.6, ou seja, esse valor indica um desempenho superior a 80% do ideal.
É importante ressaltar que um resultado abaixo de o nível 'Baixo' indicam resultado ruim.
Tamanho da transação Conjunto L/ E Tempo em transações Nível de contenção Bayes Genome Intruder Kmeans Labyrinth Vacation Grande Médio Pequeno Pequeno Grande Pequeno Médio Grande Médio Médio Pequeno Grande Pequeno Médio Grande Alto Médio Baixo Alto Alto Alto Baixo Alto Baixo/ Médio Médio A o comparar as características transacionais presentes na Tabela 5.4 e os resultados apresentados nas Figuras 5.2 e 5.3, é possível identificar variações entre resultados e características.&amp;&amp;&amp;
Pode- se observar que a aplicação Labyrinth possui características transacionais rigorosas (severidade alta) e, mesmo assim, apresentou os melhores resultados do teste, diferente da aplicação SSCA2 que possui severidade baixa e apresentou um desempenho muito abaixo de o esperado.
A Tabela 5.5 resume essa observação, apresentando as aplicações separadas em grupos de acordo com o comportamento, e indica a severidade das características transacionais conforme Tabela 5.4.
A partir de a Tabela 5.5 conclui- se que as características apresentadas não são suficientes para investigar o desempenho das aplicações do STAMP e, portanto, um teste mais específico é necessário para entender o fluxo das aplicações.
Além disso, é necessário identificar características transacionais mais específicas.
De acordo com a Tabela 5.4, não é possível identificar se as aplicações possuem ou não acesso não transacional dentro de as transações, como também não é possível saber se as transações de uma aplicação possui mais leituras do que escritas.
Essas informações, bem como outras, são de grande importância para entender o funcionamento de uma aplicação transacional e a partir de isso, comparar seu resultado com suas características.
Por fim, observa- se discrepância entre as características apresentas na Tabela 5.4 e os resultados obtidos.
Em esse viés, as características apresentadas não são suficientes para compreender o desempenho de cada aplicação do STAMP.
Para investigar novas características e analisar mais profundamente as aplicações, o teste do próximo capítulo utiliza uma nova maneira de caracterizar aplicações transacionais.
As algumas das aplicações presentes neste teste serão simuladas para um novo teste de desempenho.
Confiabilidade Conforme citado na Seção 4.2.1 este trabalho utiliza métodos estatísticos para determinar a quantidade de execuções necessárias para cada conjunto de aplicação e sistema STM e ainda para determinar o intervalo de confiança dos resultados.
Em o Apêndice A. 1 são apresentados os resultados de todas as execuções deste teste.
As Tabelas A. 1, A. 2, A. 3, A. 4, A. 5 exibem o número de execuções de cada aplicação enquanto as Tabelas A. 6, A. 7, A. 8, A. 9, A. 10 exibem o intervalo de confiança de cada resultado.
Resumo do Capítulo Conforme observado na Seção 5.2, as aplicações do benchmark STAMP apresentam desempenho baixo em todos os sistemas utilizados, com exceção da aplicação Labyrinth.
Testes assim foram executados também em.
Em, foram obtidos resultados piores em relação a os apresentados neste trabalho.
Em a comparação dos sistemas utilizados, apenas o sistema TL2 está presente em ambos as pesquisas.
Em este trabalho, o sistema TL2 apresentou resultados insatisfatórios, tais como os apresentados em.
Além disso, aqui foram utilizados sistemas STM mais modernos e criados/ atualizados recentemente.
Em, o autor não apresenta resultados em valores numéricos, mas uma comparação percentual de sistemas.
É realizada uma comparação entre os sistemas SwissTM e TinySTM e entre os sistemas SwissTM e TL2.
Em ambas as comparações o sistema SwissTM apresenta desempenho de 10 a 50% maior que os outros sistemas.
Embora, nesse teste, o sistema SwissTM também possua desempenho superior a ambos, não é possível comparar os resultados, pois o trabalho não apresenta os parâmetros de execução utilizados nos testes.
O trabalho apresenta foco similar ao deste capítulo, propondo uma avaliação de sistemas STM com benchmark STAMP.
Entretanto, não utiliza os principais sistemas STM apresentados aqui:
SwissTM e RSTM.
Em o trabalho é possível identificar o mesmo comportamento encontrado nos testes.
As características transacionais são incompatíveis com os resultados obtidos.
O trabalho apresenta resultados semelhantes em algumas aplicações como SSCA2 e YADA.
Entretanto, demais aplicações apresentam resultados muito superiores aos apresentados aqui.
Com exceção da aplicação Bayes, que foi executada com parâmetros de entrada de tamanho médio, todas as demais aplicações apresentam os mesmos parâmetros de entrada em ambos os trabalhos.
Uma possível diferença entre os testes são as modificações realizadas no sistema STM do trabalho, que possui diversas versões nas execuções do teste.
Entretanto, a diferença de desempenho é muito significativa e não apresenta apenas como uma modificação de código.
Por fim, o trabalho também executa testes com aplicações do benchmark STAMP e apresenta resultados diferentes na maioria das aplicações de ambos os trabalhos, embora mais próximos dos resultados obtidos nos testes deste trabalho.
Ignorando as diferenças de resultados entre os trabalhos e assumindo os valores aqui mencionados como aceitáveis, pode- se concluir que o benchmark utilizado apresenta um conjunto de aplicações que exercitam de fato os sistemas STM.
Através de inúmeras variações de cargas de trabalho e parâmetros, o benchmark é importante para avaliar tais sistemas visto que, ainda não é encontrado um sistema STM capaz de obter resultados satisfatórios em todas as aplicações.
Isso indica o quão próximo o benchmark alcança aplicações reais.
A investigação de aplicações, tal como a proposta deste trabalho, é importante para entender melhor seu desempenho e identificar oportunidades de melhoria nos sistemas STM.
Como observado na Seção 5.2, não são esperados resultados próximos do ideal devido a o fato de algumas aplicações não possuirem código 100% transacional.
Entretanto, apesar de essa constatação, espera- se melhores resultados de sistemas STM com o benchmark STAMP no futuro devido a seguintes considerações:
Lee-TM; Escalabilidade.
Apesar de não ser possível investigar o comportamento das aplicações mais profundamente, o resultado dessas aplicações indica deficiência nos sistemas STM.
Por fim, observa- se discrepância entre as características transacionais apresentadas por o benchmark e os resultados obtidos.
Além disso, as características transacionais são apresentadas como adjetivos, tais como:
Grande, Pequeno, Médio e Alto.
Esses adjetivos são difíceis de mensurar e podem ser subjetivos.
Por exemplo, algumas aplicações do benchmark STAMP apresentam transações grandes, porém, as mesmas são consideravelmente menores do que as utilizadas no benchmark STMBench7.
Em essa perspectiva, é necessário identificar características transacionais que expliquem melhor as aplicações transacionais.
Tais características precisam representar a aplicação de maneira mais completa possível, indicando atributos de aplicações que possam influenciar na compreensão do desempenho.
A principal contribuição deste capítulo é a avaliação imparcial dos principais sistemas STM propostos na literatura, avaliação ainda não realizada na área.
Foi possível, através de testes com o principal benchmark para sistemas STM, identificar a superioridade da ferramenta SwissTM que, apesar de ser criada recentemente possui um conjunto de decisões de projeto eficaz.
Esse conjunto foi amplamente pesquisado e explorado no trabalho.
Outra contribuição importante deste capítulo é sobre o benchmark, que exercita, de fato, os sistemas STM apesar de caracterizar as aplicações de maneira substancial.
Por fim, outra contribuição é a constatação apresentada sobre os sistemas STM, que indica problemas ao utilizar muitos cores e não têm um desempenho satisfatório com determinados tipos de aplicações.
Este capítulo apresenta os testes de desempenho com o benchmark EigenBench.
Em a seção 6.1, é apresentada a metodologia, descrevendo como o testes são executados e seus objetivos.
Em a Seção Por fim, na Seção 6.3, é apresentado um resumo com as considerações finais e as contribuições deste capítulo.
Metodologia O teste de desempenho do benchmark EigenBench visa complementar o teste da Seção 5 através de uma análise também focada no desempenho dos sistemas STM e, principalmente, nas características transacionais de cada aplicação.
Em o teste, é utilizado o benchmark proposto recentemente, que apresenta uma nova maneira de classificar as características transacionais de aplicações Tm.
Além disso, com o benchmark é possível simular o comportamento de outras aplicações reais, como as utilizadas no benchmark STAMP.
O objetivo principal deste teste é, portanto, utilizar as mesmas aplicações do teste anterior, porém, expandindo- se a definição das características transacionais de cada uma para realizar uma análise mais completa do desempenho.
Apesar de não serem exatamente as mesmas aplicações, visto que são benchmarks diferentes, ao simular as aplicações do benchmark STAMP, obtêm- se o mesmo comportamento transacional das aplicações reais, conforme apresentado no trabalho.
As caracteristicas ortogonais propostas por o benchmark são de grande importância para analisar o comportamento das aplicações e seu desempenho.
Segundo, essas características ortogonais são a base do entendimento de uma aplicação transacional.
Em o teste em questão, são selecionados dois dos sistemas STM executados nos testes do capítulo anterior:
SwissTM e RSTM.
O critério de seleção é o desempenho obtido nos testes com o benchmark STAMP.
Os motivos para a seleção de dois sistemas STM ao invés de apenas o melhor, são:
Os sistemas apresentaram resultados bem similares em algumas aplicações no teste com benchmark STAMP;
A o utilizarem dois sistemas, é possivel comparar os resultados entre os sistemas para verificar comportamentos distintos;
O sistema RSTM é um sistema importante na literatura de Memórias Transacionais e não foi utilizado no trabalho.
Para utilizar o benchmark com os sistemas SwissTM e RSTM, são necessárias modificações sistema STM.
O pacote de distribuição do benchmark apresenta suporte para os sistemas SwissTM e TL2.
Para suportar a última versão do sistema SwissTM pequenas alterações no arquivo.
H são necessárias.
Já para suportar o sistema RSTM, é necessário escrever o arquivo.
H do zero e alterar o código do benchmark.
Para a realização deste teste são selecionadas 5 aplicações presentes no teste anterior, mencio-nadas abaixo:
STAMP (Capítulo 5) e que possuem características transacionais com severidade alta e média, respectivamente, conforme classificação da Tabela 5.5.
Para garantir a confiabilidade dos resultados gerados, todas as aplicações foram executadas mais de 30 vezes.
Em a Seção 4.2.1 são apresentados os cálculos realizados que indicam a quantidade de execuções por aplicação do STAMP.
Os testes foram executados numa máquina multicore descrita na Seção 4.1.
Para realizar a análise dos resultados, as seguintes métricas são utilizadas:·
Speed-up: Conforme descrito na Seção 5.1 o cálculo de speed-up mostra o quão bem os sistemas STM escalam com um número crescente de cores.
Um alto speed-up depende não somente do sistema STM mas também da aplicação;·
Aborts per Commit (ApC):
Mostra o percentual de transações que efetuaram aborts por transações que efetuaram commit.
Essa métrica auxilia na análise indicando quando uma execução teve excessos de aborts, o que indica perda de desempenho.
Para todas as aplicações são executadas a versão sequencial e 3 versões STM:
2, 4, 8 threads.
A seção seguinte apresenta os resultados desse teste bem como a análise dos resultados obtidos.
Resultados Conforme citado na seção anterior, este teste pretende analisar as características transacionais através de outro benchmark, porém, utilizando o mesmo perfil de aplicações.
Isso é possível, pois o benchmark simula o comportamento das aplicações STAMP através de um conjunto de parâmetros de entrada.
A Tabela 6.1 apresenta as características Eigen (em negrito) das aplicações do STAMP.
As demais características são complementares às características conjunto de trabalho e comprimento da transação e foram separadas em outra linha para facilitar a visualização.
As características conjunto de trabalho e comprimento da transação apresentam a média obtida.
Os resultados dos testes são apresentados de duas maneiras:
Primeiramente, a Figura 6.1 apresenta o desempenho focando nos sistemas STM.
Por fim, as Figuras 6.2 e 6.3 apresentam o desempenho invidivual por aplicação, focando no desempenho em ambos os sistemas.
A Figura 6.4 apresenta a métrica ApC das aplicações. Quando
observados os gráficos da Figura 6.1 pode- se notar que os resultados estão superiores ao encontrado nas execuções com as aplicações reais do STAMP (Figuras 5.2 e 5.3).
Entretanto, os valores apresentados na Figura 6.1 são semelhantes ao encontrado no trabalho original.
Uma das possibilidades para a diferença nos resultados é que o teste com o benchmark STAMP (Seção STM e reduzir o desempenho das aplicações.
O benchmark apresenta execuções das aplicações do STAMP, porém, não indica quais parâmetros de entrada foram utilizados nas aplicações originais para realizar a comparação das execuções.
A aplicação Labyrinth apresentou valores acima de o ideal pois seu código fonte favorece a programação paralela, eliminando problemas na versão paralela que degradam o desempenho na versão sequencial.
Conforme dito anteriormente, os valores apresentados são semelhantes aos encontrados no trabalho.
A aplicação Labyrinth apresenta valores muito próximos, enquanto a aplicação Genome apresenta diferença significativa apenas com 8 cores.
As demais aplicações apresentam valores próximos, sendo que os resultados deste trabalho são um pouco maiores.
Em relação a comparação entre os sistemas STM, é possível observar, novamente, uma superioridade do sistema SwissTM.
Ele apresenta melhores resultados em 4 das 5 aplicações testadas, com desempenho além de o ideal para a aplicação Labyrinth (com dois e quatro cores).
Adicionalmente, é possível identificar a superioridade do sistema ao analisar a aplicação Genome, cuja diferença entre os sistemas é considerável.
A Tabela 6.2 auxilia na interpretação dessa conclusão, apresentando a variação de speed-up entre os sistemas testados.
A tabela mostra os valores mínimos e máximos do speed-up para cada sistema STM independentemente da quantidade de threads executadas.
Os valores estão arrendondados para facilitar a interpretação.
A tabela não apresenta os valores da aplicação Genome, visto que a mesma apresenta valores distintos entre os sistemas STM.
Em a Tabela 6.2, observa- se valores mínimos muitos próximos entre os sistemas STM, analisando cada aplicação individualmente.
De a mesma forma, é possível observar o mesmo com os valores máximos, com exceção da aplicação Labyrinth, que apresenta valor máximo distante entre os sistemas STM.
Essa distância encontrada deve- se ao fato do sistema RSTM não desempenhar satisfatoriamente ao utilizar 8 cores.
O mesmo pode ser observado, em menor grau, nas demais aplicações.
Além disso, o sistema SwissTM consegue desempenhar melhor com 8 cores devido a o seu sofisticado mecanismo de resolução de conflito, que previne abortar transações longas com frequência.
Através dessa análise conclui- se, que ambos os sistemas estão apresentando desempenho semelhante ao comparar a mesma aplicação.
As características dos sistemas STM não impactam, nesse caso, na interpretação do desempenho das aplicações.
Para tanto, somente as caracaterísticas das aplicações são levadas em consideração na análise individual de cada aplicação.
A constatação sobre a semelhança nas execuções é nova na literatura, principalmente porque as últimas versões de ambos os sistemas são recentes e não existem trabalhos que apresentem uma avaliação sobre eles.
Essa constatação é importante para indicar o crescimento dos sistemas STM na literatura, e pode- se concluir que os sistemas estão convergindo para sistemas STM com desempenho superior.
Apesar desse ponto positivo, ainda é necessário investir nas ferramentas de STM para reduzir o overhead gerado com o aumento de cores.
Ambos os sistemas possuem um desempenho inferior ao executar com 8 cores, por exemplo.
Para realizar a análise individual de cada aplicação, são utilizados todos os recursos disponíveis.
São analisados os gráficos de desempenho, a métrica ApC (Figura 6.4), as características ortogonais de cada aplicação e o código fonte.
Em a listagem abaixo, são apresentadas as principais considerações para cada aplicação:·
Genome: Apresenta desempenho distinto entre os sistemas STM.
O resultado com o sistema SwissTM apresenta diferença do resultado apresentado em, apenas com 8 cores.
A aplicação possui diferentes comprimentos de transações, variando de 1 a 4000.
Apesar de o comprimento das transações mais frequente ser pequeno, algumas transações com comprimento maior foram utilizadas (investigadas a partir de o código fonte), o que impactou no desempenho geral da aplicação.
Predominância e densidade altas também influenciam no desempenho.
É possivel analisar ainda que a aplicação é a única, de entre aquelas utilizadas, a apresentar diferença significativa de desempenho entre os sistemas STM.
SwissTM obteve resultados baixos, porém conseguiu escalar até speed-up 3.7, enquanto o sistema RSTM não obteve speed-up maior que 2.0 (4 cores).
Esse comportamento ocorre devido as decisões de projeto utilizadas por o sistema SwissTM, que consegue lidar satisfatoriamente tanto com transações curtas como com transações longas, que é o caso específico da aplicação Genome.·
Intruder: Apresenta o pior desempenho entre as aplicações testadas, com speed-up máximo de 2.2 com o sistema SwissTM e 2.1 com sistema RSTM.
Em comparação com o trabalho, apresenta speed-ups melhores com dois e quatro cores e pior com oito cores.
A aplicação apresenta uma variedade de tamanhos de memória utilizada, além de possuir um nível de contenção considerável, conforme Tabela 6.1.
Entretanto, analisando- se a tabela, algumas características apresentadas são semelhantes a aplicação Labyrinth que teve um bom desempenho.
Apesar de as semelhanças, o principal motivo para a queda no desempenho da aplicação é o nível alto de contenção que sobrecarrega o sistema STM e acaba aumentando o número de aborts.
O percentual de aborts por commit comprova essa conclusão (Figura· Labyrinth:
Apresenta o melhor desempenho do teste.
O resultado com o sistema SwissTM apresenta diferença do resultado apresentado em, com speed-ups melhores com dois e quatro cores e pior com oito cores.
A aplicação Labyrinth possui uma distribuição uniforme no comprimento das transações, e a quantidade de memória utilizada frequentemente é pequena.
Apesar de possuir tamanho das transações grandes, elas possuem baixa densidade (muitas operações não transacionais dentro de a transação) e baixa predominância (muitas operações não transacionais na aplicação), como pode ser observado na Tabela 6.1.
A tabela informa, ainda, contenção baixa, que pode ser comprovado com o percentual baixo de aborts (Figura 6.4).
Além disso, a característica localidade é alta (muitas operações utilizando o mesmo conjunto de endereços de memória dentro de a transação).
Todas essas características sugerem que não é o overhead do sistema STM que governa o desempenho da aplicação, mas sim a eficiência da detecção de conflito dos sistemas STM.
Essa conclusão é comprovada por os resultados dos gráficos da Figura 6.1, onde o sistema SwissTM obteve speed-up maior do que o ideal para dois e quatro cores e quase ideal para oito cores.
Com sistema RSTM, apesar de a limitação de escalibilidade, obteve resultado ideal para dois e quatro cores e não escalou satisfatoriamente com oito cores devido a suas limitações.
De a mesma forma, o percentual de aborts para dois e quatro cores é insignificante para ambos os sistemas STM.
O percentual de aborts com oito cores difere entre os sistemas mas não impacta no desempenho geral.·
SSCA2: Apresenta desempenho baixo, um pouco superior ao encontrado nos testes com o benchmark STAMP (Seção 5.2).
O resultado com o sistema SwissTM apresenta diferença do resultado apresentado em, com speed-ups melhores em todos os cores.
Apesar de a aplicação apresentar comprimento da transação curta, ela possui uma grande quantidade de memória utilizada.
Essa combinação reduziu o desempenho da aplicação.
O interessante desta aplicação é que, ao contrário de a Intruder, ela não apresenta percentual alto de aborts.
Ou seja, a perda de desempenho dessa aplicação não está nos conflitos mas sim no overhead do sistema STM ao lidar ao mesmo tempo com comprimento de transações curto e muita memória.·
Vacation: Apresenta desempenho baixo, um pouco superior ao encontrado nos testes com o benchmark STAMP (Seção 5.2).
O resultado com o sistema SwissTM apresenta diferença do resultado de, com speed-ups melhores com quatro e oito cores e pior com dois cores.
A aplicação Vacation possui a seguinte combinação de características que degradam seu desempenho:
Grande volume de memória e diversos comprimentos de transação possuindo valor médio de 226.
Além disso, predominância e densidade alta auxiliam no comportamento dessa aplicação.
Um fator interessante sobre os resultados dessa aplicação é a comparação entre os sistemas STM.
Essa é a única aplicação que possui resultados superiores com o sistema RSTM, mesmo que essa diferença não seja tão grande.
Não é possível determinar qual aspecto do sistema RSTM garantiu um melhor desempenho nessa aplicação.
Entretanto, destaca a necessidade de uma nova avaliação de decisões de projeto como realizado em, que realiza testes de tentativa e erro utilizando diversas abordagens para as principais caraterísticas dos sistemas STM.
Isso é importante para avaliar o comportamento das decisões tanto isoladamente, como em conjunto.
A partir de as conclusões geradas através da análise individual das aplicações testadas, é possível também chegar a conclusões gerais sobre o comportamento geral do teste.
Em a listagem abaixo, são apresentadas as principais considerações do teste:·
Baixo desempenho sem nível alto de aborts:
Através do teste com a aplicação SSCA2, é possível concluir que não somente conflitos em transações é indício para a perda de desempenho, mas que outros fatores também contribuem para o desempenho desfavorável.
No caso de a aplicação SSCA2, a combinação transações de comprimento pequeno e grande quantidade de memória gerou overhead em ambos os sistemas testados, o que limitou o speed-up a valores muito abaixo de o valor ideal em todas as configurações cores.
O próprio sistema STM tem overhead interno ao lidar com grande volume de memória, e aplicações livres de aborts (ou com níveis baixos) não são garantia de desempenho superior;·
Desempenho semelhante entre os sistemas STM:
Ambos os sistemas STM possuem desempenho semelhante ao se comparar a mesma aplicação (com exceção da aplicação Genome), não levando em conta os número de speed-up gerados, mas sim o comportamento geral.
Como exemplo, temos a aplicação Labyrinth que desempenhou satisfatoriamente nos testes, apresentando ótimos resultados em ambas as ferramentas.
De a mesma forma, a aplicação Intruder apresenta desempenho baixo em ambos os sistemas, com pequena variação de speed-ups.
Esse comportamento é observado também no teste com benchmark STAMP, o que é esperado, visto que são simulações das aplicações reais do benchmark.
Isso não é necessariamente uma regra, mas apresenta indícios que ambas as ferramentas, que tiveram o melhor desempenho, estão convergindo para o mesmo lugar, indicando o crescimento dos sistemas STM na literatura.·
Desempenho satisfatório:
A aplicação Labyrinth é um exemplo para mais uma constatação.
Primeiramente, apresenta resultados excelentes com o sistema STM SwissTM, o que contradiz trabalhos que criticam o potencial de Sistemas de Memórias Transacionais de Software, como em.
Em comparação com esse trabalho, apenas o sistema TL2 é comum, pois os demais sistemas utilizados no trabalho são baseados em compilador.
Além disso, o sistema TL2 teve o pior desempenho dos testes com benchmark STAMP e não possui mecanismos atuais para lidar com overhead.
A aplicação RSTM também apresentou resultados ótimos para dois e quatro cores, porém perdeu desempenho com oito cores, conforme limitação já mencionada;·
Influência de mais de uma característica:
Pode- se observar nas conclusões individuais das aplicações que analisar o desempenho e identificar o motivo para o desempenho alcançado não é algo trivial, pois, geralmente, não há informações suficientes da aplicação para encontrar o real motivo.
Foi identificado que um conjunto de característica é necessário para determinar o desempenho, pois dificilmente apenas uma característica é responsável por os resultados.
Adicionalmente, não somente as caracaterísticas citadas como principais tornam o desempenho baixo ou alto, mas também características coadjuvantes com diferentes pesos.
Esse é o caso da aplicação Labyrinth, por exemplo, que tem como características principais para o bom desempenho:
Densidade, predominâcia e pouca memória.
Porém, analisando a Tabela 6.1 é possível identificar mais três características importantes, que auxiliam no bom desempenho da aplicação:
Localidade temporal (que indica que as transações utilizam geralmente o mesmo conjunto de endereços de memória), contenção (que apresenta 5% apenas de chance de uma transação ter conflito) e poluição (que indica que apenas 50% das operações em acessos compartilhados é escrita);·
Grande quantidade de memória:
Pode- se observar que, em geral, aplicações com grande quantidade de memória têm baixo desempenho.
A aplicações SSCA2 e Vacation são exemplos de isso:
Ambas possuem grande quantidade de memória independentemente do comprimento das transações da aplicação (SSCA2 apresenta tamanho fixo e pequeno enquanto Vacation apresenta diversos comprimentos e comprimento longo na média).
Essa constatação não pode ser expandido para qualquer aplicação de Memória Transacional mas é um indício de que é preciso mecanismos mais robustos para lidar com grande quantidade de memória nos sistemas Confiabilidade Conforme citado na Seção 4.2.1 este trabalho utiliza métodos estatísticos para determinar a quantidade de execuções necessárias para cada conjunto de aplicação e sistema STM e ainda para determinar o intervalo de confiança dos resultados.
Em o Apêndice A. 2 são apresentados os resultados de todas as execuções deste teste.
As Tabelas A. 11, A. 12, A. 13 exibem o número de execuções de cada aplicação enquanto as Tabelas A. 14, A. 15, A. 16 exibem o intervalo de confiança de cada resultado.
Resumo do Capítulo Conforme observado na Seção 6.2, as aplicações simuladas do benchmark STAMP apresentam desempenho baixo em todos os sistemas utilizados, com exceção da aplicação Labyrinth.
Testes como este foram executados também em.
Em, trabalho em o qual esse teste foi beaseado, apresenta o mesmo teste com as cinco aplicações STAMP e o sistema SwissTM.
Os resultados mostraram- se melhores do que o trabalho original.
Com exceção das aplicações Genome e Labyrinth, que apresentam resultados menores em alguma configuração de cores, todas as demais aplicações apresentam resultados melhores.
É possível listar duas justificativas para a diferença nos valores:
Os trabalhos executaram testes com versões diferentes do sistema SwissTM;
A arquitetura utilizada é diferente, o que pode influenciar no desempenho.
Ambas as justificativas apresentam- se coerentes visto que a diferença de resultados é aceitável.
Em relação a comparação entre os sistemas STM, o sistema SwissTM mostrou, novamente, superioridade nas execuções, obtendo melhores resultados com quatro das cinco aplicações.
As aplicações que mais chamaram a atenção, neste caso, foram Genome e Vacation.
Genome, apresentou diferença significativa entre os sistemas, cujo speed-up com oito cores foi 3.7 e 1.4, para os sistemas SwissTM e RSTM respectivamente.
Essa diferença considerável entre os sistemas indica ser consequência do comportamento da aplicação Genome, que apresenta variação entre comprimentos de transações curto e longo, conforme observado na Seção 6.2, e é melhor trabalhado no sistema SwissTM, devido a seus mecanimos voltados tanto para transações curtas como longas.
A aplicação Vacation, foi a única aplicação onde o sistema RSTM teve vantagem nos resultados.
Não é possível determinar o motivo da diferença, visto que a diferença não é significativa.
Mas esse fato indica que o sistema SwissTM ainda precisar melhorar seu desempenho, visto que não é satisfatório em 100% das aplicações transacionais.
Através da nova caracterização das aplicações transacionais, foi possível obter melhores resultados ao analisar o comportamento das aplicações.
O benchmark, apresenta características que melhor definem uma aplicação transacional, identificando comportamentos mais específicos, como são o caso das características densidade, predominância e localidade Temporal.
Além disso, a possibilidade de simular outras aplicações foi de suma importância para este trabalho, pois permitiu uma análise gradual das aplicações do STAMP, iniciando com as aplicações reais e, posteriormente, utilizando aplicações simuladas (com mesmo comportamento das originais) e utilizando uma nova maneira de caracterizar as aplicações de maneira mais detalhista.
Assim como observado na Seção 5.3, os sistemas STM ainda precisam melhorar no desempenho.
Os resultados de algumas aplicações ficaram, novamente, muito abaixo de o ideal, apesar desse comportamento ser o esperado, tendo em vista que as aplicações são simuladas e representam o comportamento das aplicações reais.
Em a comparação dos trabalhos, foram identificadas diferenças que, de acordo com as jusificativas apresentadas não são impactantes no resultado final, pois todas as aplicações apresentam o mesmo comportamento, independentemente do trabalho.
Devido essas constatações, também reforçadas por o trabalho, são esperados melhores resultados nos sistemas STM atuais.
A principal contribuição deste capítulo é a extensão do trabalho, ao suportar o sistema RSTM e realizar comparações com o sistema SwissTM.
Foi possível, através de testes reforçar a superioridade da ferramenta SwissTM que apesar de ser criada recentemente possui um conjunto de decisões de projeto eficaz.
Além disso, identificou- se similaridade entre os sistemas STM com o benchmark EigenBench, o que indica que os resultados apresentados em são coerentes e, ainda, que o desempenho dos sistemas estão muito próximo, embora o SwissTM seja superior em determinadas aplicações.
Outra contribuição importante deste capítulo é a avaliação detalhada de cada aplicação do benchmark STAMP através de uma nova ótica, utilizando- se características transacionais mais detalhadas e obtendo- se as características que mais interferem no desempenho de cada aplicação.
Este capítulo apresenta os testes de características com o benchmark EigenBench.
Em a Seção na Seção 7.2, são apresentados os resultados e uma análise crítica com observações sobre os testes executados.
Por fim, na Seção 7.3, é apresentado um resumo com as considerações finais e as contribuições do capítulo.
Metodologia O teste de características transacionais com o benchmark EigenBench visa complementar o teste do benchmark EigenBench (Capítulo 6), investigando- se de maneira mais isolada o impacto que cada característica transacional possui nas aplicações simuladas do benchmark STAMP.
Isso nos permite averiguar o comportamento das aplicações de maneira controlada, alterando- se uma característica por vez e avaliando- se as mudanças ocorridas nos resultados.
O teste da Seção 6 simula o comportamento das aplicações do STAMP e apresentam um novo conjunto de características para tais aplicações.
Este teste tem por objetivo, explorar essas características transacionais, de modo a complementar a análise das aplicações e verificar o impacto (importância) que essas características possuem no comportamento da aplicação.
O teste permite, inicialmente, validar os resultados obtidos, bem como encontrar informações adicionais não capturadas no teste anterior.
Para a realização desta etapa, são selecionadas as quatro aplicações que apresentam resultados baixos presentes no teste com benchmark EigenBench:
Genome, Intruder, SSCA2 e Vacation.
O objetivo desta seleção é justamente identificar oportunidades de melhoria no desempenho dessas aplicações, o que é algo mais complexo na aplicação Labyrinth, visto que ela apresenta speed-up maior que o ideal com dois e quatro cores e próximo de o ideal com oito cores.
Além disso, é selecionado o sistema que possui o melhor desempenho no teste, SwissTM, pois o foco deste teste é justamente as características da aplicação e não a comparação entre sistemas STM.
Os resultados deste teste são obtidos através da abordagem 'tentativa e erro', pois é preciso identificar como uma característica transacional irá impactar no desempenho da aplicação.
Entretanto, as tentativas são guiadas a partir de todo o conhecimento adquirido sobre as aplicações utilizadas, ou seja, são analisados os resultados obtidos, a tabela de características Eigen as execuções com esse benchmark apresentam desvio padrão menor que 0.1 em todas as execuções realizadas.
Para realizar a análise dos resultados, a seguinte métrica é utilizada:·
Speed-up: Conforme descrito na Seção 5.1 o cálculo de speed-up mostra o quão bem os sistemas STM escalam com um número crescente de cores.
Um alto speed-up depende não somente do sistema STM mas também da aplicação;
Para todas as aplicações são executadas a versão sequencial e 3 versões STM:
2, 4, 8 threads.
A seção seguinte apresenta os resultados desse teste bem como a análise dos resultados obtidos.
Resultados Conforme citado na seção anterior este teste pretende investigar as caraterísticas transacionais de maneira isolada.
De entre as características analisadas na Seção 6.2 algumas mostraram- se relevantes para determinar o desempenho de aplicações.
Como exemplo, pode- se citar:
Nível de contenção, que impactou o resultado da aplicação Intruder;
Localidade temporal, que auxiliou no bom resultado da aplicação Labyrinth;
Conjunto de trabalho, que impactou nas aplicações com grande quantidade de memória (SSCA2 e Vacation);
E, por fim, comprimento das transações, que impactou aplicações com transações tanto curtas como longas (Genome).
De entre as características citadas, não é possível realizar testes com a característica contenção, pois não é possível derivar a fórmula utilizada no trabalho, que oferece pouca informação a respeito.
As demais caraterísticas, tais como densidade e predominância, são também importantes e são citadas no teste da Seção 6.2.
Suas derivações, são não triviais e dependem de fatores do sistema, não apresentadas no trabalho.
Portanto, com exceção de contenção, densidade e predominância, as demais características apresentadas são exploradas nesse teste.
Como citado anteriormente, o conjunto de modificações disponíveis para realização do teste de tentativa e erro é vasto.
Para reduzir o escopo de parâmetros a serem modificados, é preciso analisar aqueles utilizados para a simulação das aplicações, suas características ortogonais e seu desempenho.
Através dessa análise, é possível identificar oportunidades de melhoria em alguma característica e a partir de isso, realizar testes e medir o desempenho.
As próximas seções apresentam a análise inicial, as modificações realizadas e os resultados obtidos para cada aplicação selecionada.
A aplicação apresenta desempenho baixo no teste com benchmark EigenBench (Capítulo 6).
Conforme observado na Seção 6.2, a aplicação possui comprimento de transação curto no geral, mas possui também algumas transações com comprimento longo que, em conjunto com predominância e densidade altas influenciam no desempenho da aplicação.
Analisando- se o conjunto de características ortogonais, é possível identificar que a aplicação possui um range grande de comprimento de transações.
Além disso, conforme citado acima, a variação de transações curtas e longas influenciaram o desempenho.
Observando- se, portanto, as características ortogonais, identifica- se a possibilidade de modificar a característica comprimento da transação.
A característica comprimento da transação pode ser derivada conforme Fórmula 7.1.
Tlen $= R1+ R2+ W 1+ W 2 Os parâmetros R1, R2, W1 e W2 são de entrada do benchmark e são descritos na Tabela 3.1 da Seção 3.2.1.
Os parâmetros de entrada da aplicação Genome são apresentados na Tabela 7.1.
Como pode ser observado na Tabela 7.1 e na Equação 7.1, diversas modificações podem ser realizadas para alterar o comprimento da transação.
Uma das possibilidades de modificação que melhora o desempenho da aplicação é a alteração de todos os parâmetros pertencentes a característica comprimento da transação.
Visto que essa aplicação é configurada com 3 threads diferentes, é preciso identificar qual de elas é relevante nesse caso.
Após algumas tentativas, é identificado que as threads que apresentam comprimento da transação maiores são as que apresentam maior overhead no sistema STM.
Portanto, as alterações no comprimento da transação são realizadas nas threads 2 e 3.
A Tabela 7.2 mostra as modificações realizadas nesses parâmetros para melhorar o desempenho da aplicação.
A tabela apresenta na primeira linha a versão original dos parâmetros e, nas demais linhas, as modificações realizadas.
A Figura 7.1 apresenta o desempenho das modificações apresentadas na Tabela 7.2.
A versão 4 ilustra o comportamento inverso ao esperado, cujo valores de todos os parâmetros são dobrados de tamanho.
As demais versões apresentam valores reduzidos uniformemente em busca de comprimento da transação menor.
Conforme observado na Figura 7.1, a redução do comprimento da transação nas threads 2 e 3 melhoram o desempenho da aplicação.
Além disso, ess modificação comprova a constatação da Seção 6.2, em que o motivo do baixo desempenho é a variação de transações longas e curtas.
A redução no comprimento de transações longas aumenta o desempenho significativamente.
É importante ressaltar que o resultado encontrado na Figura 7.1 não é considerado ideal e tem o objetivo apenas de apresentar o impacto da característica no conjunto de características da aplicação Genome.
As variações de speed-up entre as configurações testadas é pouco significativas;
Destacase, porém, o impacto que a variação no comprimento das transações tem no desempenho geral das aplicações.
A aplicação apresenta desempenho baixo no teste com benchmark EigenBench (Capítulo 6).
Conforme observado na Seção 6.2, a aplicação possui nível de contenção considerável e transações curtas.
Analisando- se o cojunto de características, é possível identificar que o nível de contenção é o mais alto entre todas as aplicações.
Entretanto conforme citado anteriormente, não é possível derivar a contenção das aplicações, e por isso, outra característica precisa ser explorada.
Outra possibilidade de modificação para a melhora do desempenho da aplicação é a alteração da característica localidade temporal, que mostrou- se importante no teste com aplicação Labyrinth.
A característica é mapeada diretamente com o parâmetro de entrada LCT e a Tabela 7.3 apresenta as modificações realizadas nesse parâmetro.
A tabela apresenta a versão original na primeira linha e, nas demais, as modificações realizadas.
O parâmetro LCT varia de 0 a 1024 com múltiplos de 256.
Quanto maior o número, maior a probabilidade de utilização dos mesmos endereços de memória numa transação.
Para cada configuração apresentada, uma linha representa uma thread que pode ser executada 1 ou mais vezes.
A Figura 7.2 apresenta o desempenho das modificações apresentadas na Tabela 7.3.
A versão 3 ilustra o comportamento inverso ao esperado, onde a localidade é menor do que na versão original.
Conforme observado na Figura 7.2, a alteração da característica localidade temporal altera o desempenho da aplicação consideravelmente mudando de 2.2 a 3.5 o speed-up para oito cores.
Entretanto, a característica tem efeito, mais significativo, a partir de quatro cores, visto que com dois cores os valores estão próximos.
Isso sugere que a característica demonstra melhores resultados ao escalar com mais cores.
Como citado na Seção 7.2.1, o resultado apresentado na Figura 7.2 não é considerado ideal e tem o objetivo apenas de apresentar o impacto da característica no conjunto da aplicação Intruder.
A aplicação apresenta desempenho baixo no teste com o benchmark EigenBench (Capítulo 6).
O principal motivo isso, conforme mencionado na Seção 6.2, é a grande quantidade de memória utilizada, considerada um dos fatores de queda no desempenho das aplicações.
Além disso, ao se analisar a tabela das características ortogonais, é possível identificar que o conjunto de memória é grande.
Portanto, identifica- se a possibilidade de modificar a característica conjunto de trabalho.
A característica pode ser derivada conforme Fórmula 7.2.
M emsize $= A1+ A2+ A3 Os parâmetros A1, A2 e A3 são de entrada do benchmark e são descritos na Tabela 3.1 da Seção 3.2.1.
Os parâmetros de entrada da aplicação SSCA2 são apresentados na Tabela 7.4.
A aplicação apresenta apenas uma thread de execução que é executada 1 ou mais vezes.
Como pode ser observado na Tabela 7.4 e na Equação 7.2, diversas modificações podem ser realizadas para alterar o conjunto de trabalho.
Uma das possibilidades de modificação que melhora o desempenho da aplicação é a alteração do parâmetro A3 (Tamanho do Cold Array -- array com dados não transacionais).
A Tabela 7.5 apresenta as modificações realizadas nesse parâmetro para melhorar o desempenho da aplicação:
É possível observar, na primeira linha, a versão original dos parâmetros e, nas demais linhas, as modificações realizadas.
A Figura 7.3 apresenta o desempenho das modificações apresentadas na Tabela 7.5.
As versões 1, 2 e 3 decrementam o tamanho do array em busca de um desempenho melhor.
Já a versão 4 ilustra o comportamento inverso, aumentando o tamanho do array.
Conforme observado na Figura 7.3, a alteração do tamanho de um dos arrays do benchmark é suficiente para melhorar o desempenho da aplicação, apesar de a melhoria ser pouco significativa a partir de a versão 2.
É importante ressaltar que diversas outras variações podem ser realizadas para alterar o conjunto de trabalho.
Aquela utilizada neste teste é apenas uma possibilidade e nos dá indício de que não apenas memória compartilhada em transações impacta no desempenho mas, também operações locais, que é o caso do parâmetro A3, que possui apenas dados não transacionais, conforme indica Tabela 3.1.
A aplicação apresenta desempenho baixo no teste com o benchmark EigenBench (Capítulo 6).
Assim como a aplicação SSCA2, esta aplicação apresenta conjunto de trabalho grande (256 MB na média), o que impacta consideravelmente no desempenho.
Devido a essa similaridade com a aplicação SSCA2, identifica- se a possibilidade de modificar também a característica conjunto de trabalho, porém, utilizando outro parâmetro.
Como visto na Seção 7.2.3, a característica conjunto de trabalho pode ser derivada conforme Fórmula 7.2.
Em este teste o parâmetro modificado é o A1 (Tamanho do Hot Array -- array com dados compartilhados, acessados concorrentemente) que representa o array principal da aplicação.
A Tabela 7.6 apresenta a versão original e as modificações realizadas.
A Figura 7.4 mostra o desempenho das modificações na aplicação Vacation.
A versão 4 ilustra o comportamento inverso ao esperado, onde o valor de A1 é dobrado de tamanho.
As demais versões decrementam o tamanho do array em busca de melhor desempenho.
Conforme observado na Figura 7.4 a alteração do tamanho do array principal impactou no desempenho da aplicação, apesar de apresentar variação pouco significativa.
Independentemente do desempenho não apresentar crescimento significativo entre os cores, a mudança no desempenho já é um indício da importância da característica no conjunto de caracteristicas da aplicação Vacation.
Resumo do Capítulo Conforme observado na Seção 7.2, as modificações realizadas nas aplicações simuladas do benchmark STAMP melhoraram o desempenho das aplicações, o que substancia as observações realizadas em relação a os testes de desempenho do benchmark EigenBench (Seção 6.2).
Como observado nas seções anteriores, os resultados encontrados após modificação dos parâmetros de entrada não são considerados ideais e tem o objetivo apenas de apresentar o impacto da característica no conjunto de características das aplicações.
A o se modificar os parâmetros de entrada do benchmark, foi possível isolar as características transacionais e comprovar sua influência no desempenho das aplicações.
O benchmark EigenBench, apresenta características que definem de maneira mais completa uma aplicação transacional, identificando comportamentos mais específicos.
Entretanto, a impossibilidade de derivação de 3 das 8 características Eigen impossibilitou uma análise mais detalhada dessas características transacionais, que tiveram grande importância no desempenho das aplicações.
A principal contribuição deste capítulo, além de a validação dos dados encontrados em, que oferece resultados similares aos apresentados neste trabalho, é a comprovação a respeito de o desempenho das aplicações da Seção 6.2 através de modificações nas características transacionais das aplicações com resultados não satisfatórios.
Esse é um importante passo para entender melhor o comportamento das aplicações transacionais. Quanto mais
for entendido o comportamento das aplicações, mais será possível aperfeiçoar os sistemas STM e, consequentemente, obter melhores resultados no futuro.
Essa contribuição é nova na literatura, visto que poucos trabalhos têm foco no entendimento das aplicações transacionais.
Memórias Transacionais fornecem um mecanismo flexível e simples para programação paralela em processadores multicore, usando abstração de alto nível, ao contrário de os tradicionais mecanismos de controle de sincronização, tais como locks.
Através desse mecanismo, o problema de sincronização de dados é passado para o sistema de Memória Transacional, que se torna responsável por garantir o funcionamento correto da aplicação, evitando os principais problemas ao utilizar mecanismos de locks (deadlocks, condições de corrida, etc) e, explorando de fato o paralelismo das aplicações.
Como apresentado neste trabalho, existe um aumento de trabalhos de pesquisa sobre Memórias Transacionais.
Segundo alguns autores, com o passar dos anos houve um crescimento no interesse de pesquisadores e também de empresas em pesquisas com Memórias Transacionais.
Esse interesse deve- se ao fato da simplificação que Memórias Transacionais possibilita aos programadores, além de melhorar a escalabilidade das aplicações.
Por entender a importância de Memórias Transacionais para a programação paralela em processadores multicore, este trabalho realizou uma avaliação comparativa de um conjunto de sistemas e aplicações transacionais, buscando apresentar o estado atual da área, compreendendo as perguntas ainda em aberto na comunidade e identificando oportunidades de melhorias nos sistemas de Memórias Transacionais de Software.
O resultado da avaliação realizada apresenta diversas contribuições para a comunidade científica, oferencendo um conjunto abrangente de resultados que são de grande importância para o crescimento da área.
Como citado anteriormente, apesar de existir diversas propostas atuais de sistemas e algoritmos, existem poucos trabalhos na literatura que apresentam avaliações comparativas e outras abordagens para entender o funcionamento de aplicações e sistemas de Memórias Transacionais.
Em o primeiro teste realizado (Capítulo 5), foi possível realizar uma comparação completa e imparcial dos principais sistemas STM prospostos na atualidade.
Diversas contribuições são apresentadas, como a eficiência do benchmark STAMP em avaliar os sistemas atuais.
Os resultados apresentados demonstram a necessidade de melhorias nos sistemas STM em geral, visto que todos os sistemas apresentaram desempenho muito inferior com algumas aplicações.
O teste apresenta, ainda, o sistema SwissTM como o que melhor desempenhou em todas as aplicações.
Além disso, o sistema RSTM apresentou desempenho similar ao SwissTM em diversas aplicações, apesar de perder desempenho na medida que aumenta o número de cores.
Por fim, identificou- se que para entender o comportamento de uma aplicação transacional é necessário caracterizar a aplicação de maneira mais detalhista, o que não ocorre com este benchmkark.
A comparação dos resultados e as características transacionais das aplicações apresentaram discrepância e não foi possível realizar uma análise mais detalhada.
Em o segundo teste realizado (Capítulo 6), foi explorada uma nova maneira de caracterizar aplicações transacionais, o que contribuiu positivamente para uma análise mais detalhada do comportamento das aplicações.
Foi possível realizar, através das caracaterísticas Eigen, observações sobre o comportamento de cada aplicação testada.
Além disso, foram apresentadas algumas constatações gerais como, o excesso de memória nas aplicações, que influenciou consideralvemente no desempenho.
Por fim, foi utilizado o RSTM no benchmark EigenBench, para comparar novamente os resultados com o sistema SwissTM.
Esse suporte adicional foi importante para novamente observar a diferenças entre os sistemas e o comportamento do sistema RSTM com o benchmark EigenBench.
O sistema SwissTM apresenta novamente melhor desempenho na maioria das aplicações.
Em o terceiro e último teste (Capítulo 7), foram apresentadas modificações nas características transacionais das aplicações, comprovando as observações realizadas no capítulo anterior.
Foram demonstrados na prática, a importância de entender as características transacionais das aplicações utilizadas.
Essa contribuição é nova na literatura, visto que poucos trabalhos têm foco no entendimento das aplicações transacionais.
Em resumo, as principais contribuições deste trabalho são:
O benchmark para Memórias Transacionais mais completo e mais utilizado na literatura;
Através do conjunto de testes realizados, foi possível entender melhor o estado atual da área de Memórias Transacionais.
Apesar de as contribuições apresentadas neste trabalho, bem como alguns trabalhos propostos na literatura, é preciso desenvolver mais trabalhos com foco no entendimento geral de Memórias Transacionais.
Como oportunidade para o futuro, é possível estender os testes deste trabalho utilizando algum mecanismo de tracing como o proposto em.
O mecanimo de tracing associado ao conjunto de sistemas e aplicações transacionais utilizados neste trabalho poderão investigar as execuções em camadas mais baixas do sistema e assim identificar problemas difíceis de observar em resultados convencionais.
Apesar de o overhead criado, a utilização de mecanismos de tracing irá complementar os resultados obtidos, identificando oportunidades de melhoria nos sistemas STM de maneira mais detalhista.
