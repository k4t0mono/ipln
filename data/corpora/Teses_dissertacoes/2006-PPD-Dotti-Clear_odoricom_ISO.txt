Gramática de Grafos Baseada em Objetos (GGBO) e uma linguagem visual formal adequada a especificação de sistemas distribuídos assíncronos baseados em trocas de mensagens.
Verificação de modelos GGBO é atualmente suportada e uma série de estudos de Casos têm sido desenvolvidos.
Entretanto, em muitas situações e necessario avaliar aspectos não funcionais como disponibilidade e desempenho dos sistemas considerados.
Em estes Casos, uma análise estocástica de sistemas é desejada.
Este trabalho apresenta uma analise estocástica de modelos GGBO.
Modelos GGBO com taxas de ocorrência associadas a regras são traduzidos para Redes de Autômatos Estocásticos (STOCHASTIC Automata Networks -- SAN).
SAN e um formalismo equivalente a Cadeias de Markov tendo como vantagem sua modularidade em termos de representação e uma compacta solução matemática, permitindo análises de modelos com maior espaço de estados.
Um aspecto muito importante durante o desenvolvimento de sistemas complexos e a habilidade em avaliar aspectos funcionais e não funcionais tão cedo quanto possível.
Esta habilidade pode reduzir os custos de projeto, alem de aumentar a confiabilidade do sistema resultante.
O desenvolvimento de sistemas distribuídos não é uma tarefa trivial, pois envolve aspectos como concorrência, sincronização, postergação, etc..
A analise destes aspectos torna- se ainda mais difícil ao considerar que ambientes podem apresentar alta latência, falhas parciais, perdas de mensagens, falhas de segurança, entre outros.
O uso de linguagens de especificação formal permite a criação de uma descrição precisa de um sistema com uma sintaxe e semântica bem definidas.
Desde que a semântica seja baseada em modelos matemáticos, e possível aplicar técnicas de verificação formal para mostrar que um sistema especificado apresenta algumas propriedades desejadas.
Além disso, um método analítico poderia ser aplicado aos modelos para avaliar aspectos de desempenho como tempo de resposta, throughput, atraso de sincronização, etc..
Entretanto, mesmo com as vantagens encontradas com o uso de métodos formais no desenvolvimento de sistemas, eles não têm sido muito utilizados na indústria.
Uma das razões atribuídas a isto é que usuarios encontram dificuldades em entender a notação matematica.
Gramática de Grafos Baseada em Objetos (GGBO) oferece uma técnica adequada de descrição formal para modelar sistemas distribuídos de maneira bastante intuitiva, mesmo para não teóricos, encorajando sua utilização.
Modelos descritos neste formalismo podem ser analisados usando verificação de modelos (model checking).
Embora Verificação de modelos seja um importante método de analise, em muitas situações a avaliação de aspectos quantitativos (não funcionais), como disponibilidade, carga de trabalho ou predição de desempenho, é desej avel ainda nas fases de especificação do sistema.
Portanto, muitas classes de aplicações não podem ter certas propriedades avaliadas.
Em estes casos, é importante poder associar probabilidades a satisfação ou não de determinada propriedade a ser verificada.
Processos estocásticos permitem modelar a interação de diferentes fenômenos, descritos por diferentes distribuições de probabilidade.
Entre vários processos estocásticos, Cadeias de Markov tem sido amplamente investigados e utilizados nas areas associadas a computação.
Cadeias de Markov são processos estocásticos de estados discretos que podem ter representação de escala de tempo contínua ou discreta, além de ter a propriedade memoryless.
Esta propriedade é importante por não haver a necessidade de conhecer os estados passados para determinar os estados futuros de um modelo, apenas o estado corrente e necessário.
A solução de uma Cadeia de Markov resulta na probabilidade de permanência em cada estado da cadeia, considerando uma situação estacionaria.
Desde que Cadeias de Markov são sistemas de transição rotulados com distribuições de probabilidade ou taxas de ocorrências, estas podem ser utilizadas como modelo subjacente para varios metodos.
Este é o caso de redes de Petri estocãsticas (STOCHASTIC Petri Nets -- SPN), onde o grafo de alcançabilidade da rede é o sistema de transição definido.
Similarmente para cálculo de processos estocástico, onde o sistema de transição e descrito por algum cálculo de processos, como por exemplo o 7 r-calculus.
Em uma primeira etapa para a analise estocástica de sistemas de transformação de grafos é dada.
Em essa contribuição, os autores associam distribuições (exponenciais) de probabilidade as regras.
Portanto, o sistema da transição obtido da gramática de grafos dá origem a uma Cadeia de Markov de tempo contínuo que pode ser analisada atraves de ferramentas existentes.
Em esta dissertação pretende-se definir um método para a analise estocástica de modelos em Gramática de Grafos Baseada em Objetos (GGBO).
GGBO e um formalismo restrito da gramática de grafos e, conseqüentemente, os resultados de são aplicados a GGBO também.
Entretanto, devido a o problema de explosão de espaço de estados, pretende-se evitar o uso de Cadeias de Markov e utilizar um método equivalente com melhor escalabilidade.
Redes de autômatos estocasticos (STOCHASTIC Autor/ Lata Networks -- SAN) e um formalismo equivalente a Cadeias de Markov que tem como vantagens sua modularidade em termos de a representação e uma forma matematica compacta para sua solução, permitindo a analise dos modelos com espaço de estados maior, se comparado as Cadeias de Markov.
Uma vez que um modelo é representado em SAN, e possível derivar as probabilidades associadas aos estados de interesse do modelo usando As principais contribuições desta dissertação são:
A proposta de uma extensão estocastica para GGBO;
A tradução do modelo estendido de GGBO para SAN, levando a semântica estocastica de GGBO;
E avaliar aspectos quantitativos de modelos através de formalismo de GGBO estocástico com o uso da ferramenta PEPS.
Este documento está organizado como segue.
O próximo capítulo apresenta formalismo GGBO, além disso, é modelado através de um exemplo um sistema que sera usado como estudo de caso ao longo de o trabalho.
O Capítulo 3 discute as principais características do formalismo SAN.
A extensão do formalismo GGBO para incluir comportamento estocastico, além de a tradução de GGBO para SAN é definida no Capítulo 4.
A aplicação do método definido é demonstrada com o uso de três estudos de caso apresentados no Capítulo 5.
Por fim, algumas considerações e trabalhos futuros são levantados no Capítulo 6.
Gramática de Grafos Baseada em Objetos Gramática de Grafos (GG) é uma linguagem visual de descrição de sistemas, que utiliza transformação de grafos.
Modelos de sistemas baseados em transformações de grafos são úteis para expressar situações complexas, como concorrência e dinamicidade, permitindo representar execuções em paralelo ou conexões entre nodos formando uma topologia de rede.
Características como estas tornam esse formalismo adequado para modelagem de sistemas distribuídos.
Uma GG é composta por um Grafo Tipo (representando os tipos dos vértices e arestas permitidos no sistema), um Grafo Inicial (representando o estado inicial do sistema) e um conjunto de regras (descrevendo as possíveis mudanças de estado do sistema).
Uma Gramática de Grafos Baseada em Objetos (GGBO) também e definida através de um Grafo Tipo, um Grafo Inicial e um conjunto de regras.
Entretanto, GGBO é uma restrição de GG com relação a os tipos de vértices e configurações de regras de modo a representar conceitos de linguagens baseadas em objetos.
O paradigma orientado a objetos acrescenta noções como encapsulamento (cada ob jeto possui um conjunto de atributos, que representam referências a objetos ou Tipos Abstratos de Dados (TADs)) e comunicação atraves de troca de mensagens (o mecanismo de troca de mensagens utilizado é assíncrono, uma vez que nada pode ser afirmado sobre o tempo de recebimento de uma mensagem).
Essa abordagem apresenta vantagens sob o ponto de vista de especificação, pois oferece ao projetista do modelo um estilo baseado em objetos, o que é bastante difundido e familiar a maioria dos usuarios.
Desta forma, facilita a modelagem de sistemas e o entendimento dos modelos, encorajando o uso deste formalismo.
Além disso, essa forma restrita oferece uma semântica composicional e reduz a complexidade na busca por uma ocorrência de regra no grafo (matchingl).
Um modelo descrito em GGBO é composto por a especificação de diferentes classes.
Cada classe e definida separadamente atraves de um Grafo Tipo, que contém os atributos da classe, referências a objetos e as mensagens que esta pode receber.
As mensagens podem carregar parâmetros, que são definidos através de TADs ou representados por referências a objetos.
Afigura 2.1 exibe o Grafo Tipo para duas classes, chamadas Coord) e Port (Figura foram retiradas de, que apresenta um modelo GGBO para o protocolo Two-- Phase Commit.
Porém, este modelo não está sendo apresentado na integra neste documento.
Pode- se observar o nome das classes (Coord e Part) seguido de um identificador, dado por o número inscrito no círculo, representando cada classe.
Após o nome da classe, segue a listagem dos atributos dentro de a caixa que representa a classe.
Os TADs definidos são byte e bool, sendo os valores dados por o conjunto dos números naturais menores que 255 assumidos para byte e false e true assumidos para bool.
Alem disso, c representa uma referência a alguma instancia da classe Coord e p, p] e p?
Referências a instâncias de Part..
As mensagens que aparecem nas Figuras 2.1 (a) e 2.1 (b) representam as possíveis mensagens que Coord e Part podem receber, respectivamente.
As mensagens StartC, Timeout e Abort, por exemplo, não possuem parametros.
No entanto, as mensagens Continue e Ack possuem um parâmetro, chamado id, do tipo byte.
O parâmetro 5 nd, presente nas mensagens Collect, é uma Ia expressão matching, do inglês, podera ser empregada através da palavra ocorrência.
Em este contexto, esta relacionada a ocorrência de um sub-grafo (lado esquerdo de um regra) no grafo do estado corrente, permitindo então a transformação do estado corrente (aplicação da regra).
Pode- se observar que as regras apresentadas possuem condições associadas, de modo a garan tir que estas apenas sejam aplicadas para determinados valores de atributos.
Todas as regras necessitam receber uma mensagem para que sejam aplicadas.
Em a regra ResponseAbort, a men sagem Collect carrega parametro, que no caso é uma referência a um objeto da classe Part..
Quando aplicada, uma regra leva o sistema a um novo estado, através da transformação do grafo atual do modelo, sendo que:
L representa um sub-grafo que descreve os itens que devem estar presentes no estado atual (grafo representando sistema) para que a regra seja habilitada.
As condições impostas ao lado esquerdo L de uma regra são as seguintes:
Deve haver exatamente um vértice mensagem, representando a mensagem de ativação da regra;
Apenas atributos do objeto receptor da mensagem de ativação da regra devem aparecer (nem todos os atributos do objeto precisam ser representados, apenas os que serão necessarios para o tratamento da mensagem);
Itens de um TAD podem ser variaveis, que serão instanciados em tempo de aplicação da regra.
Operações definidas no TAD podem ser usadas.
R é um sub-grato que descreve os itens que estarão presentes no grafo que representa o sistema após a aplicação da regra.
O lado direito da regra R consiste de:
Todos os objetos e atributos presentes em L, assim como novos objetos que podem ser criados por a aplicação de 1».
Os valores dos atributos podem ser modificados, mas nenhum atributo pode ser apagado;
Possíveis mensagens enviadas para os objetos presentes em R. A condição pode ser descrita por uma equação ou inequação definida através dos atributos do lado esquerdo e parâmetros da mensagem de ativação da regra.
A condição deve ser satisfeita para que a regra possa ser aplicada.
As regras do modelo descrevem como os objetos se comportam ao receber mensagens.
Para um mesmo tipo de mensagem, mais do que uma regra pode especificar a ação do objeto.
Dependendo das condições impostas por estas regras (com relação a os valores de atributos ou parâmetros de mensagens), elas podem ser mutuamente exclusivas ou não.
Em o último caso, uma das regras sera escolhida de modo não-determinístico para execução.
De essa forma, não ha uma estrutura de controle que governe a aplicação das regras.
Alem disso, a aplicação de uma regra se dá de forma atômica, ou seja, o consumo da mensagem de ativação da regra, as atualizações dos atributos e a geração de novas mensagens ocorrem num único passo.
Em a definição original de GGBO, é possível remover e criar objetos através da aplicação de regras, ou seja, vértices presentes em L que não estejam presentes em R são apagados, vértices presentes em L e em R são mantidos, e vértices presentes em R que não estão presentes em L são criados no grafo que representa o sistema.
No entanto, neste trabalho não está sendo considerada a criação dinamica de objetos.
Esta restrição é justificada no Capítulo 4.
A instanciação das classes é feita através da definição de um Grafo Inicial, que define os objetos, seus atributos e mensagens iniciais, estabelecendo então, um cenario inicial para a execução do modelo.
Como exemplo, a Figura 2.3 exibe um possível Grafo Inicial para o modelo Two--Phase Commit.
Em este Grafo Inicial estão representados dois objetos da classe Part e um da classe Coord.
O valor inicial de cada atributo é atribuído em cada objeto e as referências são apontadas entre os objetos descritos no grafo.
Por exemplo, a referência c em qualquer dos participantes, referência o objeto Coordl.
Por fim, uma mensagem Start e enviada para o objeto Coord.
A partir de então, qualquer regra que possua uma ocorrência da configuração descrita no Grafo Inicial podera ser aplicada (por exemplo a regra StartCommit mostrada na Figura 2.2).
A próxima seção apresenta um modelo descrito em GGBO para o protocolo Token Ring.
Para Ver outros exemplos de modelos definidos em GGBO, o leitor pode consultar os trabalhos, onde além de especificar modelos, simulações ou verificações de modelos são efetuadas.
Em esta seção é apresentado um modelo GGBO para o protocolo Taken Ring.
Este é um estudo de caso simples que possibilita ao leitor observar algumas características de modelos GGBO, sendo suficientemente conciso para descrever de forma adequada todos os passos do método de tradução que sera apresentado no Capítulo 4.
O protocolo Token Ring é utilizado para resolver problemas de acesso ao meio entre nodos numa topologia de rede em anel.
Em um Taken Ring, um padrão de bit especial, chamado taken, circula ao longo de o anel sempre que as estações estão ociosas.
Quando uma estação quer transmitir um frame, ela apanha o taken e o remove do anel antes da transmissão.
Havendo apenas um taken, apenas uma estação pode transmitir num dado instante, resolvendo desta forma o problema de acesso ao meio.
A estação destino copia o conteúdo da mensagem.
A mensagem circula até o seu remetente que, ao recebes- la, remove ela do anel e envia o taken para a próxima estação.
A direção do anel é fixa.
A Figura 2.4 mostra os componentes modelados num Grafo T ipa.
Os nodos (representados por a classe Nada) têm um atributo booleana chamado sent.
Duas mensagens podem ser recebidas por uma instância de Node:
Msg simbolizando um frame recebido e Taken que simboliza um taken.
O link para o próximo nodo da rede é representado por a referência a objetos nezt (a referência aponta para outra instância de Node).
As regras que definem o comportamento deste modelo são apresentadas na Figura 2.5.
O nodo que possuir o taken envia uma mensagem ou transmite o taken para o próximo nodo (regras taken não e transmitido (consumo da mensagem Taken no lado esquerdo da regra), o atributo sent é assinalado com true e uma mensagem Msg é enviada ao próximo nodo.
Caso contrário, 0 taken e transmitido (consumo e envio da mensagem Token na regra Token Pass).
Em a recepção de frames, dois casos são possíveis:
O nodo recebe a mensagem que foi enviada por ele mesmo originalmente, ou o nodo recebe uma mensagem que não foi gerada por ele inicialmente.
Em, o ciclo da mensagem foi finalizado e o taken é passado para o próximo nodo (consumo da mensagem Msg e envio da mensagem Token na regra Complete).
Em a situação, a mensagem Msg e entregue;
Ara um nodo e este nodo transmite essa mensagem para o próximo nodo (regra Transmit).
Para finalizar este modelo, é mostrado o Grafo Inicial na Figura 2.6.
O Grafo Inicial define as instâncias de classes do modelo, seus atributos e mensagens iniciais.
Para este modelo, quatro nodos foram definidos, chamados Nodel, Nada, Nodeâ and Node4.
A referência a objetos next é associada ao nodo seguinte.
Todos atributos sent têm seus valores iniciados em false e apenas um nodo recebe o taken.
Redes de Automatos Estocásticos. Este capítulo apresenta Redes de Autômatos Estocásticos (SAN -- STOCHASTIC Automata Network).
Este formalismo foi proposto por Plateau e tem como principal característica possibilitar a representação e avaliação de sistemas concorrentes através de urna forma de especificação que possibilita modularização.
Sua expressividade e equivalente a Cadeias de Markov, no entanto a descrição em módulos oferece uma abstração mais natural para projetistas.
Além disso, suas resoluções numéricas suportam um maior espaço de estados do que Cadeia de Markov, reduzindo a probabilidade de explosão do espaço de estados em alguns casos.
A vantagem obtida em termos de custo computacionall por SAN, em comparação a Cadeias de Mar/ cm), e uma importante característica.
Este ganho e possível devido a o uso de álgebra de tensores (GTA Generalized Tensor Algebra), que permite uma representação compacta do Descritor Mar/ comum).
Alguns métodos iterativos que definem procedimentos numéricos sobre GTA são discutidos em, porem não serão apresentados neste trabalho.
A organização deste capítulo segue através da definição informal de SAN, na Seção 3.1, seguida por a Seção 3.2 que apresenta uma formalização de alguns conceitos de SAN que serão empregados na tradução de modelos GGBO para SAN.
A ferramenta PEPSQOOS e abordada na Seção 3.3, visto que modelos SAN podem ser descritos e avaliados com esta ferramenta.
Por fim, a Seção 3.4 apresenta exemplos de modelagem e avaliação de sistemas com o formalismo 10 custo computacional neste contexto refere- se ao consumo de memória.
Em uma SAN, cada autômato e composto por um conjunto de estados e transições.
O conjunto de autômatos constitui uma rede de autômatos.
O estado corrente de um autômato é chamado de estado local e o estado global é dado por a composição dos estados locais de todos os autômatos.
Qualquer autômato pode atuar de maneira independente ou coordenada com outros autômatos.
Cada transição de um autômato pode ser disparada por um ou mais eventos.
Tais eventos podem ser locais a um autômato, ou comuns a varios autômatos.
Em o último caso, os eventos sincronizam a transição dos autômatos envolvidos e são chamados de eventos sincronizantes (synchronizing events).
Eventos locais são usados para modificar o estado local de um autômato sem afetar outros autômatos.
Em oposição a estes, eventos sincronizantes modificam o estado de dois ou mais autômatos simultaneamente.
Assim e possível representar interação entre autômatos numa Cada evento, local ou sincronizante, deve ser associado a uma taxa de ocorrência.
Para modelos SAN representados em escala de tempo discreta, a taxa de ocorrência e distribuída geometricamente, enquanto que com a representação na escala de tempo contínua, a taxa de ocorrência é distribuída exponencialmente.
Em este trabalho apenas a representação de modelos com escala de tempo contínuo esta sendo assumida.
Portanto, a taxa de ocorrência de um evento é a média de uma função exponencial que rege o intervalo de tempo entre duas ocorrências do evento.
Esta taxa pode ser fixa ou obtida por uma função.
Dado que um evento ocorre, se um mesmo evento está associado a mais de uma transição de saída de um estado, a probabilidade de rotação define a probabilidade de cada transição disparar como ocorrência do evento.
Como a representação em SAN é modular, o autômato equivalente à Cadeia de Markov é dado por o espaço de estados produto a partir de os autômatos descritos no modelo.
Para analise do modelo através da ferramenta PEPS, que sera apresentada na próxima seção, é necessário definir uma função capaz de identificar os estados alcançaveis dentro de o espaço produto.
Esta função é chamada de função de alcançabilidadez.
Para os estados alcançáveis, são calculadas as probabilidades associadas.
Um exemplo de aplicação desta função pode ser observado na Seção?
Em a literatura esta função também pode ser denominada função de atingihilidade.
Para a obtenção de resultados numéricos sobre o modelo, é necessário o uso de funções capazes de obter as probabilidades do modelo encontrar- se em determinados estados.
Para tanto, são definidas as funções de integração.
Além disso, é possível compor funções de integração que avaliem a probabilidade do modelo encontrar- se num conjunto de estados.
De essa forma, pode se obter índices de desempenho e confiabilidade do modelo.
Esta seção define formalmente os aspectos de Redes de Autômatos Estocásticos necessários para a tradução de GGBO para SAN3 apresentada no Capítulo 4.
Não será apresentada uma formalização genérica para SAN, mas apenas conceitos que são adotados no método de tradução proposto.
De essa forma, caracterizam- se autômatos, redes de autômatos estocãsticos e mudanças de estados, sem se preocupar em definir taxas funcionais e probabilidades de rotação, ja que estas características nunca são apresentadas nos modelos definidos por a tradução.
Um autômato é uma tupla A: (S, T, E, i) onde S é um conjunto finito de estados, E é um conjunto finito de eventos.
É a relação de transição e i E S e o estado inicial.
Dado um aatômato A, denotam- se seus componentes por SA, Te a, EA e iA.
Dado um estado s E S, denota- se o conjunto de eventos que podem ocorrer por outputEvents, e o conjunto de estados imediatamente atingiveis a partir de s dada a ocorrência de am evento e por outputStates (s, e) $ [ s'| É| (s, ES', 5').
Uma Rede de Autômatos Estocásticos (SAN) e uma tupla SAN: (SE, AL, T) onde SE é um conjunto finito de eventos, chamado synchronizing events, AL é uma lista de autômatos e r:
A definição de SAN determina o conjunto de eventos que são usados para sincronizar diferentes autômatos durante a execução.
As mudanças de estado de Redes de Autômatos Estocásticos são dadas por algum evento e são possíveis quando autômatos diferentes estão em algum estado 3 As definições encontradas nesta seção são propostas originalmente em.
Dada uma SAN SAN:
E Se um evento e está habilitado no estado s 2, uma mudança de estado pode ocorrer, levando para um estado¡ I x, se;
R E ontputStatesLsi, e) e G outputEventsÇsi), s:
PEPS2003 não possui interface gráfica, sendo necessário descrever redes de autômatos estocasticos atraves de arquivos texto de entrada.
Estes arquivos carregam a informação sobre a SAN, alem de possibilitar a definição de funções de integração e alcançabilidade.
As funções de alcançabilidade podem ser de dois tipos, alcançabilidade total ou parcial.
Em o primeiro caso, o usuário pode definir um conjunto de estados considerados alcançaveis, de forma que nenhum outro estado seja considerado atingível.
Caso o usuario opte por a segunda alternativa, a ferramenta auxilia o usuario a gerar o conjunto de estados alcançaveis a partir de um subconjunto considerado alcançável inicialmente.
Além disso, PEPS2003 oferece diferentes métodos de solução iterativa para os modelos.
Avaliações de vetores de probabilidades e acesso as estruturas de dados geradas durante a avaliação do modelo também são oferecidas.
Não serão apresentados neste trabalho detalhamentos sobre a sintaxe dos arquivos de entrada do PEPS2003, pois sintetizariam apenas uma convenção adotada sobre o conceito de SAN.
Isto pode ser encontrado no manual do PEPS.
Esta seção apresenta um exemplo completo de modelagem de sistemas utilizando SAN e aponta outras referências que apresentam estudos de caso modelados e avaliados com este formalismo.
Em, e modelado em SAN um sistema com compartilhamento de recursos.
Os recursos são considerados indistinguíveis, ou seja, todos são iguais e qualquer cliente pode alocar qualquer representando cada um dos N clientes.
Cada autômato pode estar em dois estados:
Um estado ocioso, representando que o cliente não está alocando nenhum recurso e outro estado ativo, representando que o cliente possui um recurso alocado.
A Figura 3.1 mostra o modelo SAN para compartilhamento de recursos.
A liberação de um recurso sera representada por um evento local líbi, que tem uma taxa;
L associada.
O evento aloe «é um evento local, que representa a alocação de um recurso, e é dado por uma taxa funcional f..
É necessario que a alocação de recursos seja dada por uma taxa funcional para que não seja permitido que mais do que R recursos sejam alocados, onde R é o número total de recursos do sistema.
A função f deve resultar num valor nulo quando não houver recursos disponíveis, caso contrário uma taxa não nula A a será retornada.
A função f é dada por:
A função nb retorna o número de autômatos no estado ativo.
Portanto, a função f retornará 0, se todos os recursos já estiverem alocados, ou retornará A, caso contrário.
É necessario definir uma função de alcançabilidade que limite os estados atingíveis onde mais do que R recursos estejam alocados, pois isso não refiete a realidade do sistema.
A função de alcançabilidade alcanc, pode ser definida como:
De essa forma, o número maximo permitido de autômatos no estado ativo é de R autômatos, ou seja, um estado global e alcançável se o número de clientes utilizando recursos seja menor ou igual a R (número total de recursos).
Alguns tipos de analises possíveis sobre esse modelo seriam, por exemplo, determinar a probabilidade de ter um número ac de recursos ocupados (supondo m menor que R).
Além disso, poderia também ser possível determinar o número medio de recursos ocupados.
Em, também está presente a representação deste modelo de acordo com a sintaxe da ferramenta PEPS2003.
Outros estudos de Caso modelados em SAN e avaliados com a ferramenta PEPS podem ser encontrados no próprio manual da ferramenta.
Estes exemplos de modelagem são apresentados inclusive de acordo com a sintaxe de descrição de modelos da ferramenta PEPS.
Em é utilizada avaliação quantitativa para geração de casos de teste de software.
Outros exemplos são apresentados em, alem de um modelo de um sistema tolerante a falhas em e uma modelagem de mecanismos de admissão de bufer.
Análise Quantitativa através de Gramática de Grafos Baseada em Objetos Este capítulo apresenta a abordagem utilizada para análise quantitativa de modelos GGBO.
Primeiramente o formalismo é estendido de modo a permitir a representação de modelos GGBO estocásticos.
Uma vez que um modelo estocástico é definido, a utilização de um metodo analítico permite a resolução do modelo, tornando possível obter índices de desempenho, disponibilidade, carga de rede, etc., através das probabilidades associadas aos estados do modelo.
O formalismo SAN apresenta- se como uma alternativa eficiente para representação e resolução de modelos estocasticos.
Tal formalismo possui equivalência com Cadeias de Mar/ mv, no entanto possibilita o tratamento de um número maior de estados.
De esse modo opta- se por traduzir os modelos estendidos de GGBO para SAN, resolvendo os modelos gerados com o uso da ferramenta PEPSQOOB.
A próxima seção apresenta Gramática de Grafos Baseada em Objetos Estocástica (GGBOE), a extensão definida para o formalismo GGBO.
A Seção 4.2 apresenta uma metodologia de resolução dos modelos estocasticos baseada na tradução de modelos GGBOE para SAN.
O modelo SAN traduzido para o modelo Token Ring, proposto no Capítulo 2, é apresentado na Seção 4.3.
As regras de nomenclatura utilizadas em todo o processo de tradução são definidas na Seção Ia escolha em apresentar esta seção após o metodo de tradução se deve à um maior entendimento da nomen Um tratamento formal, apresentado em, é aplicado ao modelo estendido de GGBO e ao metodo de tradução.
Foram apresentadas definições que apresentam a semântica dos modelos estocásticos e dos modelos traduzidos.
Portanto, a tradução descrita nesta dissertação pode ser formalmente definida através da discussão apresentada em.
Em esta seção é definida Gramática de Grafos Baseada em Objetos Estocástica (GGBOE), que é uma extensão de GGBO.
Em um grafo, mudanças de estados são modeladas por regras.
É natural associar taxas as regras de uma gramática de grafos, caracterizando o atraso levado para a transformação do grafo dada por a regra, uma vez que haja ocorrência desta regra no grafo.
Com o conhecimento destas taxas é possível avaliar a probabilidade de um sistema atingir um determinado estado num sistema de transição de estados do modelo.
Informações desta natureza são de grande valia em avaliação de sistemas concorrentes, complementando outras técnicas de análise, como verificação de modelos.
Predição de desempenho, disponibilidade, carga de rede, entre outras medidas quantitativas podem ser efetuadas com modelos estocásticos.
Em, Heckel et al apresenta um método para gerar Cadeias de Markov a partir de GG (Gramáticas de Grafos).
Este trabalho consiste na obtenção do sistema de transição gerado por uma GG e posterior associação de taxas às transições, tornando o sistema de transição rotulado.
Este sistema de transição com taxas associadas da origem a uma Cadeia de Mar/ mv, onde as taxas associadas as transições deverão expressar valores para uma distribuição exponencial.
Isto garante a propriedade de não depender de estados passados (memory/ less) de Cadeias de M arlcou.
O método de associa a cada nome de regra um número real positivo representando a taxa da distribuição exponencial para o atraso da aplicação de cada regra.
Essas taxas são usadas para gerar a matriz de incidência da Cadeia de Markov.
Algumas restrições para especificação de GG são adotadas em, de modo a garantir as condições necessarias para geração de uma matriz de incidência valida.
É necessario que o sistema de transição rotulado gerado seja Jínitely--branching, isto é, para todos estados gerados, em cada transição de um estado s para um estado s», o conjunto de todas as regras aplicáveis a s é finito.
Outra restrição é que o modelo deve ser estado-finito.
Como discutido no Capítulo 2, GGBO e uma forma restrita de GG, portanto o mesmo método clatura após o conhecimento dos autómatos e eventos gerados.
No entanto, é aconselhável que a leitura dessa seção seja intercalada com a Seção 4.2, a medida que ela for referenciada no texto.
Como discutido no Capítulo 3, a avaliação de modelos com Cadeia de Markov pode sofrer com o problema de explosão de espaço de estados.
Por outro lado, o formalismo SAN apresenta equivalência de representação e analítica com relação a Cadeias de Mar/ cm¡ e ainda possibilita, para alguns modelos, o tratamento de maior espaço de estados.
Desde que GGBO com taxas associadas origina uma Cadeia de Mar/ mv e desde que SAN é equivalente à Cadeias de Mar/ mv, então existe uma possível tradução de GGBO para SAN.
Além de apresentar uma vantagem eminente com relação a avaliação de modelos maiores, com uma tradução de GGBO para SAN, a representação modular, característica de ambos os formalismos, expressa outra vantagem para definição da tradução.
Conforme visto na Seção 4.1, GGBOE oferece uma alternativa para construção de modelos estocasticos usando GGBO.
No entanto, é necessario definir alguma abordagem para resoluçãoz destes modelos a fim de realizar analises quantitativas.
A alternativa adotada para resolver modelos GGBOE propõe uma tradução de modelos deste formalismo para SAN.
A resolução de modelos SAN gerados seguindo a tradução ocasiona a avaliação das probabilidades de permanência dos autômatos em cada estado.
A ferramenta 2 Resolver um modelo estocástico significa associar probabilidades aos estados possíveis do modelo.
PEPSZOOS é utilizada para obter as probabilidades dos estados gerados por o modelo traduzido.
Esta seção apresenta o método de tradução definido neste trabalho.
Aspectos relacionados a avaliação dos modelos traduzidos e o uso da ferramenta PEPS2003 são postergados para o Capítulo 5, onde estudos de caso modelos de GGBOE são traduzidos para SAN e índices quantitativos são extraídos dos modelos.
A proposta de traduzir modelos em GGBOE para SAN consiste em representar o estado interno de um objeto, assim como suas modificações (aplicações de regras), atraves de uma SAN.
Um sistema formado por vários objetos sera representado por uma SAN resultante da composição das SANs que representam Cada instancia.
Atributos, referências a objetos e mensagens de objetos GGBOE originam autômatos de uma SAN.
As regras são mapeadas para transições, eventos e taxas.
O estado de cada objeto é dado por um conjunto de estados de autômatos, sendo:
Um autômato para cada atributo;
Um autômato para cada referência a objeto;
Um ou mais autômatos para cada tipo de mensagem que o objeto pode receber.
Todos atributos, referências a objetos e mensagens (possuindo ou não parâmetros) existentes num objeto são dadas por o Grafa Tipo (Figura 2.4 mostra o Grafo Tipo para o modelo Token Ring) e são mapeados para autômatos.
Ha dois tipos de autômatos no método proposto:
Em esta proposta, a criação dinâmica de objetos não e suportada desde que é necessario ter um conjunto fixo de estados para a resolução do modelo estocastico.
Portanto, a representação em SAN é estática, ou seja, a rede de autômatos deve ser definida inicialmente e nenhum autômato poderá ser inserido dinamicamente.
De essa forma as referências a objetos devem apontar para um objeto que pertence a um conjunto finito de objetos existentes no modelo inicialmente.
Em uma extensão futura poderia ser considerada a ativação de autômatos existentes, que inicialmente estão inativos, simbolizando suas criações dinamicamente.
Em o Capítulo 6 ha uma discussão sobre trabalhos futuros propostos, onde esta alternativa é mencionada.
O Grafo Inicial de uma GGBOE é utilizado para obtenção de informação sobre os valores dos atributos dos objetos, referências a objetos e mensagens que podem existir no sistema iniCialmente.
Alem disso, o domínio de um tipo de dados é limitado de acordo com as possíveis aplicações de regra.
Partindo de um valor do Grafo Inicial, os possíveis desdobramentos dados por aplicações de regras devem formar o conjunto de valores possíveis para cada atributo.
O con junto de mensagens enviadas à espera de consumo também pode ser determinado por as possíveis aplicações de regra3.
As regras GGBOE serão dadas por transições e eventos de uma SAN, as taxas associadas às regras em GGBOE serão definidas como taxas de ocorrência de eventos da SAN correspondente.
Uma aplicação de regra por um objeto consiste no consumo de uma mensagem (mensagem de ativação da regra) e, possivelmente, modificações de valores de atributos (no objeto que recebe a mensagem de ativação) e geração de novas mensagens.
Regras serão representadas por transições disparadas por eventos em SAN, de forma a modificar os estados dos autômatos mensagem e atributo.
É necessário que todas as modificações (mudança de atributos, consumo e geração de mensagens) dadas por a aplicação de uma regra ocorram de maneira atômica.
Como quaisquer atributos ou mensagens são representados por autômatos, a aplicação de regra sera representada através de transições disparadas por eventos sincronizantes, capazes de modificar simultanea mente os estados destes autômatos.
O lado direito de uma regra exibe as atualizações nos atributos e novas mensagens que podem ser enviadas a algum (s) ob jeto (s), enquanto que o lado esquerdo de uma regra exibe a mensagem que sera consumida (mensagem de ativação da regra).
Dada uma GGBOE, é possível gerar todos os eventos possíveis de acordo com o conjunto de regras especificado no modelo.
Para cada regra, é possível determinar transições e eventos que descrevam a atualização de cada atributo modificado no lado direito da regra, além de descrever consumo e geração de mensagens, nos autômatos que representam mensagens.
O processo de tradução proposto pode ser separado em três partes.
Inicialmente devem ser definidos todos os possíveis eventos, seguido por a construção dos estados dos autômatos da SAN (autômatos atributos ou autômatos mensagens) e atribuição dos eventos as transições entre os estados dos autômatos.
A seguir é discutido como o conjunto de regras de uma GGBOE gera eventos em SAN.
As Seções 4.2.2 e 4.2.3 descrevem a geração do espaço de estados da SAN e a associação dos eventos gerados as transições dos autômatos atributo e autômatos mensagem da SAN.
O primeiro passo na definição da tradução de modelos GGBOE para SAN consiste na geração de todos os possíveis eventos que serão representados no modelo SAN.
Cada possível ocorrência de uma regra r deve ter um evento correspondente.
De essa forma, são geradas todas as combinações de valores possíveis para os elementos presentes no lado esquerdo de v «(atributos, referências a objetos e parametros de mensagens) e, para as combinações que caracterizam uma ocorrência da regra, são gerados eventos.
Qualquer evento definido para o modelo, de acordo com a tradução proposta, ê assumido como sincronizante.
A taxa de ocorrência associada ao modelo é obtida através do valor da taxa descrita na regra da GGBOE.
A probabilidade de rotação ê sempre igual a 1 nos modelos traduzidos, uma vez que não são modeladas situações onde mais do que uma transição diferente sai de um mesmo estado com o mesmo evento4.
Para o modelo Token Ring, apresentado no Capítulo 2, cada uma das quatro regras definidas irá gerar um conjunto de eventos representando situações onde uma ocorrência da regra pode ser encontrada num grafo do sistema.
A Figura 4.2 exibe as situações que geram todos os eventos referentes a aplicação da regra Token Pass por uma instancia do Grafo T ipo Node.
Os morfismos parciais apresentados na Figura 4.2 de (a) a (d) demonstram as configurações possíveis para os valores de nezt e Token, de forma a expressar todas as possíveis ocorrências da regra Token Pass para uma determinada instância.
Contudo, e necessario diferenciar eventos que simbolizem uma mesma aplicação de regra em instâncias diferentes, para manter os aspectos semãnticos de GGBO.
Uma vez que todos os eventos são sincronizantes, o uso de um mesmo evento para mais do que um autômato representando atributos de diferentes objetos dispararia transições em ambos os ob jetos, mesmo que a aplicação de regra tivesse se dado em apenas um dos objetos (vide Figura 4.3 (a) 5).
Portanto ê necessário utilizar eventos diferentes para instâncias diferentes, mesmo que estes representem uma mesma regra (vide Figura 4.3 Com base nos eventos gerados para a regra Token Pass (Figura 4.2), pode- se associar os quatro eventos gerados a cada instância.
Portanto, são definidos para Nodel os eventos Token 4 Em a definição formal de SAN, apresentada na Seção 3.2, não foi definida probabilidade de rotação pois esta característica não está presente nos modelos traduzidos.
De essa forma no processo de tradução este valor sera sempre igual a 1, para todos os eventos.
As demais instâncias também deverão ter eventos associadas a cada regra, como TokenPass_ next_ Node2_ Nodeâ', TokenPass_ nezt_ N ode2_ Norte.
E TokenPass_ nezt_ Nodeã_ Node4 6, por exemplo.
De maneira análoga, todas as ocorrências das outras regras do modelo também devem ser traduzidas em eventos.
O conjunto de eventos gerados ainda devera ser associado a cada instancia de mesma classe ao qual a regra é aplicada.
Ein suma, os eventos gerados cobrem todas as possíveis ocorrências das regras de uni modelo GGBOE.
Todos os eventos são sincronizantes e possuem suas taxas de ocorrência representadas de acordo com a taxa definida no conjunto de regras GGBOE.
Além disso, cada instância apresentada no modelo possui eventos exclusivos para serem associados às transições dos autômatos que representam a instância (autômatos atributo e autômatos mensagem).
Como mencionado anteriormente, para cada objeto representado no Grafo Inicial, será definido um conjunto de autômatos representando os atributos e referências a objetos.
Logo, cada atributo ou referência a objetos de cada instância das classes apresentadas no Grafo Inicial é representado por um autômato.
A seguir será descrito como gerar os estados dos autômatos atributo na Seção 4.2.2.1.
A Seção 4.2.2.2 descreve como as transições entre estes estados são geradas.
Os estados de cada autômato representam os possíveis valores que o atributo ou referência a objetos pode assumir.
Para atributos booleanos, por exemplo, e possível representar os possíveis valores através de dois estados:
False e true.
Para os demais tipos, tantos estados quantos forem necessarios serão usados para representar todos os valores possíveis durante qualquer execução do modelo.
E importante lembrar que os modelos devem ser estado-finito, logo o conjunto de valores utilizados nos atributos deve ser dado por um domínio finito.
Não ha a definição de um método automatizado para avaliar os elementos que compõem o domínio de um atributo.
Portanto, assume- se que o projetista do modelo deve declarar explicitamente o domínio de cada atributo.
Entretanto, urna analise estática do modelo baseada nas regras da GGBOE pode, em alguns casos, auxiliar na determinação dos limites de cada atributo.
Porém, este processo pode não ser trivial para modelos complexos.
Desta forma, propõe- se a aplicação de uma metodologia utilizando o verificador de modelos SPIN para determinar os limites do domínio dos atributos de acordo com o desdobramento de todas as aplicações de regras possíveis.
Em, foi apresentada uma ferramenta de edição de GGBO.
Esta ferramenta gera código PROMELA (linguagem de entrada do verificador SPIN) seguindo a tradução de GGBO para PROMELA proposta por.
Este código gerado e utilizado para a verificação de propriedades de modelos GGBO.
No entanto, o verificador de modelos possui uma opção de avaliação dos alcances das variaveis do modelo.
Logo, e possível descobrir os limites do domínio de cada atributo do modelo GGBO através do verificador SPIN.
Para referências a objetos, os estados dos autômatos representam um possível objeto que está sendo apontado por a referência.
Os possíveis objetos a serem apontados estão todos presentes no Grafo Inicial.
Isso decorre do fato de não ser possível criar objetos dinamicamente no processo de tradução.
De essa forma o domínio de uma referência a objetos de uma classe c é dado por as instâncias de c presentes no Grafo Inicial.
Cada estado do autômato representa um possível valor de acordo com o domínio do atributo ou referência a objetos.
Portanto, as transições num autômato atributo devem representar as modificações do valor do atributo ou referência a objetos que o autômato representa.
Estas transições são atreladas a eventos sincronizantes e as taxas de ocorrência associadas aos eventos são obtidas por as regras GGBOE correspondentes.
De acordo com o conjunto de regras GGBOE, são gerados todos os possíveis eventos em SAN segundo a descrição da Seção 4.2.1.
Cada evento estará atrelado a quaisquer autômatos de atributos e referências a objetos que forem modificados na regra que originou o evento.
Além disso, cada evento estara atrelado também aos autômatos que representam mensagens consumidas ou geradas durante a aplicação da regra que originou 0 evento;
No entanto, esta discussão é deixada para a Seção 4.2.3.
A associação dos eventos aos autômatos atributo se da através de transições que modificam os estados dos autômatos de acordo com a taxa do evento.
Como todos os eventos nesta tradução são sincronizantes, para que urn evento ocorra, e necessario que todas as transições dadas por um mesmo evento estejam habilitadas, ou seja, os autômatos devem estar nos estados de origem das transições.
A transição altera o estado de um autômato partindo de um estado de origem para um estado destino.
O estado de origem é informado por o evento ao qual a transição esta associada, uma vez que o evento representa a ocorrência de uma regra com um determinado conjunto de valores no lado esquerdo.
O estado destino é gerado segundo as modificações descritas por o lado direito da regra que originou o evento.
Em a Figura 4.4, os autômatos atributos sent_ Nodel e next_ Nodel representam o atributo sent e a referência a objetos next para o objeto Node] do modelo GGBOE para o protocolo Token Ring.
Os nomes dos eventos usados para rotular transições são compostos por o norne da regra aplicada, uma lista de nomes de atributos e o valor necessário para a ocorrência da mesma, e o objeto que recebe a mensagem.
Por exemplo, Transmit_ next_ Node2_ Node1 representa a aplicação da regra Transmtt por o objeto Nodel, tendo apontado em sua referência next o objeto Node27.
Para a aplicação da regra Send, por exemplo, as transições partem tanto de false quanto de true, visto que a ocorrência desta regra independe do valor de sent e, têm como destino o estado true, definido como atualização do atributo sent no lado direito da regra.
O valor de nezt permanece inalterado após a aplicação da regra, portanto transições refiexivas são definidas, de modo a manter o autômato no mesmo estado e garantir que apenas um evento Send_ next_ seja aplicado.
Em a Figura 4.4 o estado destacado indica que o Nodeâ e a referência apontado por next.
De essa forma, observa- se que apenas o evento Send_ next_ Nodeâ_ Node] estará habilitado, uma vez que em eventos sincronizantes todos os autômatos devem estar nos estados origem da transição para que o evento ocorra.
De acordo com a semântica de GGBO, o mecanismo de troca de mensagens e assíncrono.
Logo, não se pode afirmar nada sobre o tempo levado para o consumo e geração de mensagens.
Adieionalmente, não existe nenhum tipo de ordenação entre as mensagens.
Isso significa que objetos podem ter varias mensagens armazenadas para serem processadas.
Segundo o formalismo de GGBO, o processamento da mensagem representa o recebimento de uma mensagem previamente enviada (armazenada).
Para representar trocas de mensagens deve ser possível armazenar diferentes tipos de mensagens e mais do que uma mensagem de um mesmo tipo.
Além disso, é possível que mais do que uma mensagem armazenada possa ativar alguma regra, então deve ser possível também permitir a escolha de qualquer mensagem recebida, de modo não determinístico.
De essa forma, cada tipo de mensagem que um objeto pode receber é representado por uma cadeia de nascimento e morte.
Cada estado de uma cadeia de nascimento e morte é utilizado para contar o número de mensagens de um mesmo tipo que não tenha sido consumido ainda por o objeto destinado.
Geração e consumo de mensagens constituem nascimento e morte na cadeia, respectivamente e, são dados por transições com eventos associados, que representam aplicações de regra.
Em a Figura 4.5 são autômatos mensagem para o objeto Nadal, 7A Seção 4.4 discute com maior nível de detalhes a nomenclatura adotada por a tradução.
Para representar parâmetros de mensagens, e preciso descrever uma cadeia de nascimento e morte para cada possível combinação de valores do domínio destes parâmetros.
Por exemplo, para mensagens com um parametro booleano, são necessárias duas cadeias, uma expressando todas as mensagens entregues corn valor de seu parametro true e outra para mensagens com o valor do parametro false.
Para mensagens com mais de um parâmetro, é preciso obter o produto cartesiano entre os possíveis valores destes parâmetros.
Cada combinação possível será representada como uma cadeia de nascimento e morte.
A Figura 4.6 exemplifica a tradução de urna mensagem JW que possui dois parametros booleanos, p e q..
Note que a combinação para cada possível valor de cada parametro para esta mensagem é definida atraves de quatro cadeias de nascimento e morte.
Os nomes dos autômatos representam o nome da mensagem (dado por a letra M), o nome e valor de cada parametro (por exemplo p_ false_ q_ true) e, for fim, o objeto ao qual esta mensagem esta representada (para consumo ou geração).
Os estados de um autômato mensagem representam o número de mensagens enviadas esperando para serem consumidas.
Portanto, para cada autômato mensagem, ha um estado que representa a ausência de mensagens recebidas, e sucessivos estados representando quantas mensagens estão armazenadas, ou seja, foram enviadas, mas ainda não foram recebidas.
É importante enfatizar que apenas modelos estado-finito devem ser adotados nesta tradução.
Geração de um número indefinido de mensagens acarretaria numa cadeia de nascimento e morte infinita, o que não é possível de ser avaliado com modelos estocasticos.
Em a Figura 4.5, Token_ Node] e Msg_ Nadal mostram a representação de autômatos para as mensagens que Nude] pode receber.
O maximo valor para o tamanho da cadeia de nascimento e morte assumido foi de uma mensagem, isto é, ou existe uma mensagem ou não existe nenhuma de cada tipo.
A quantidade de mensagens para este modelo pode ser obtida por uma análise estática do modelo.
Cada nodo é conectado a um outro nodo apenas.
Assim, ha apenas uma fonte de recebimento de mensagens para cada nodo.
O número reduzido de regras permite observar que não mais do que uma mensagem Token e Msg será entregue a um mesmo nodo num ciclo do anel.
Em alguns casos, a análise estática pode ser bastante complexa, tornando- se inviável.
Para tanto, sugere- se a definição do modelo em passos iterativos, ou seja, para uma mensagem A1 (representada por uma cadeia de nascimento e morte), define- se um tamanho n para a cadeia e avalia- se a probabilidade de permanência no último estado se ela for nula, então este estado não é atingível, logo 0 número maximo de mensagens A/ I armazenadas seria n -- 1.
Caso a probabilidade de permanência não seja considerada nula, então se deve repetir o procedimento para tamanho n+ 1, até determinar o tamanho adequado de n..
É aconselhável obter a geração de um espaço de estados eficiente para reduzir a possibilidade de explosão de espaço de estados nos modelos SAN gerados.
Por isso a determinação de um número ótimo para o tamanho da cadeia de nascimento e morte torna- se desejável.
As transições de um autômato mensagem devem representar consumos e gerações de mensagem de regras GGBO.
Conforme apresentado na seção anterior, cada estado de um autômato mensagem indica o número de mensagens que foram enviadas ao objeto que o autômato representa.
Uma regra 7», representada por evento e, possui uma mensagem de ativação m..
De essa forma, os autômatos que representam m, deverão possuir transições no sentido morte da cadeia, ou seja, uma mensagem m é consumida.
Caso existam mensagens m¡ no lado direito de 7», deverão ser geradas transições no sentido nascimento dos autômatos que representam estas mensagens.
Caso uma mensagem enviada para uma determinada instancia seja consumida e enviada para a mesma instância, o número destas mensagens esperando por o consumo deve se manter inalterado.
O uso de transições reflexivas garantem esta situação, ou seja, representam o consumo e envio de uma mensagem por um mesmo objeto.
Em a Figura 4.5 observa- se o consumo de mensagens Token por o objeto Nadal, dado por a por as eventos Token_ Pass_ neact_ Nodel_ e Complete_ next_ Node1_ no entanto, observa- se que os eventos neste caso são disparados por a aplicação da regra por outras instâncias, mas Node] aparece como o receptor da mensagem (geração de mensagem no lado direito da regra).
Finalmente, o caso onde um mesmo objeto (neste exemplo, Nadal) consome e envia a mesma mensagem para si, é dado por as transições reflexivas disparadas por os eventos Te o ken_ Pass_ next_ Nodel_ Node] e Transmit_ next_ Nodel_ Nadal.
Após apresentar a metodologia de tradução empregada ao longo deste capítulo, é mostrado o modelo Token Ring descrito em SAN, segundo a abordagem proposta.
Em a Figura 4.7, os autômatos atributos sent_ Node] e nezt_ Node1 representam o atributo sent e a referência a objetos next para o objeto Nodel.
As mensagens que podem ser recebidas por Nude] são mostradas atraves dos autôrnatos Token_ Nodel e Msg_ Nodel.
Os eventos e transições são definidos como conforme discutido nas seções anteriores.
No entanto, com a representação de atributos e mensagens numa mesma imagem, fica mais fácil observar todas as ações da aplicação de uma regra.
Por exemplo, na regra Send, a atualização do atributo sent, consumo de mensagem Token e geração de mensagem Msg podem ser observados.
Alguns eventos foram emitidos da figura para aumentar a legibilidade do modelo.
Não há perda de informação com esta simplificação, visto que os eventos não representados nunca são ativados, devido a topologia da rede.
A referência a objetos next irá apontar para o vizinho do nodo ao qual pertence.
Uma vez que a topologia inicial nunca é alterada, ou seja, não ha modificação entre os vizinhos dos nodos, o nodo referenciado por next inicialmente nunca será alterado.
Portanto apenas os eventos onde next esta sendo avaliado como N ode? (
este é o vizinho de Nadal) são representados.
Além de a geração de todos os autômatos que definem a SAN, é necessário definir o estado inicial e o conjunto de estados alcançáveis da rede de autômatos estocasticos.
A configuração definida no Grafo Inicial pode desencadear diferentes derivações de regras do modelo, alterando possíveis buscas por solução estacionária no modelo SAN traduzido.
Para manter a semântica dos modelos GGBO, onde o estado inicial é bem definido, usa- se um recurso conhecido como alcançabilidade parcial.
A alcançabilidade parcial permite que um conjunto de estados seja considerado atingível a priori.
Qualquer estado que possa ser atingível partindo do conjunto inicial será também incluído no conjunto de estados atingíveis.
De essa forma, baseado no Grafo Inicial, é definida uma função de alcançabilidade parcial que identifique apenas os estados inicias.
Para o estudo de caso proposto inicialmente, o Grafo Inicial da Figura estados dos autômatos inicial é traduzido na seguinte função de alcançabilidade parcial (está sendo adotada a sintaxe da ferramenta PEPS):
M: 8585 858a A resolução da SAN gerada sera discutida no Capítulo 5, onde são apresentadas analises quantitativas relacionadas ao modelo.
Outros estudos de caso também serão apresentados nesse capítulo.
A geração de diferentes tipos de autôniatos, seus estados, transições e eventos ja foi apresentada na Seção 4.2.
Apesar de terem sido apresentados modelos SAN ao longo deste capítulo, não foi definida uma nomenclatura padrão para o método.
Esta seção descreve a alternativa adotada para rotular os autôniatos traduzidos, seus estados e eventos.
Em o processo de tradução proposto, cada autômato deve representar um atributo, referência a objetos ou mensagem recebida por um objeto.
De essa forma é definido um conjunto dos autômatos capazes de manter o estado interno de um ob jeto e armazenar as mensagens que foram enviadas a este objeto.
Para um determinado modelo, partindo do Grafa Inicial obtém- se o conjunto de instâncias de uma classe, logo devera existir um conjunto de autômatos para cada instancia.
A nomenclatura adotada para nomear aatômatos atributo rotula os autômatos com 0 nome do atributo ou referência a objetos seguida por o nome da instancia em a qual o autômato faz parte.
A sintaxe para rotulação de nomes de autômatos é dada por:
Nota- se que tanto os atributos quanto as referências a ob jetos são compostos por o seu próprio nome seguido da instância de classe ao qual este atributo ou referência pertence.
Por exemplo, para o modelo Token Ring, o atributo sent é definido para cada objeto do modelo (dado por o Grafo Inicial) como:
Sent_ Nodel, sent_ Nodeã, sent_ Node3 e sent_ Nodeá.
A referência a objetos next, por sua vez, é dada por next_ Nadal, next_ Nude?,
next_ Nodeã e next_ Node4.
Para os autômatos mensagem, há a possibilidade das mensagens que estão sendo representadas carregarem ou não parametros, conforme discutido na Seção 4.2.3.
A rotulação de mensagens sem parâmetro é dada de maneira análoga à rotulação dos aatômatos atributo, ou seja, o nome da mensagem seguido por o nome da instância ao qual a mensagem está sendo enviada:
Em o modelo Token Ring a mensagem Token é dada por autômatos rotulados por Token_ Nodel, Token_ Node2, Token_ Nodeâ e Token_ Node4.
A mensagem Msg também é representada por quatro autômatos que seguem o mesmo critério de rotulação.
A presença de parametros nas mensagens mantém a necessidade em rotular as mensagens para cada possível instancia, porém obriga que sejam definidos tantos autômatos quantas forem as combinações dos Valores de seus parâmetros (produto cartesiano).
A sintaxe para a rotulação destes autômatos e dada como segue:
Uma vez determinado 0 domínio dos atributos e o número máximo de mensagens que podem ser armazenadas, é bastante simples rotular os estados dos autômatos.
Para autômatos mensagens, os estados são rotulados por números de 0 a N, onde N é o número máximo de mensagens armazenadas num determinado instante.
Em os autômatos atributos, cada valor do domínio é usado para rotular um estado do autôrnato.
A Figura 4.7 apresenta o modelo Token Ring na forma de autômatos SAN.
É possível observar que os estados rotulados representam os valores de atributos (como false e true) ou referências a objetos (como Nodel, Nodeâ e Node4) ou número de mensagens armazenadas (neste caso 0 e 1).
A rotulação de um evento em SAN e baseada no conjunto de regras GGBOE.
Deve- se então observar se existem referências a objetos no lado esquerdo da regra.
Isso é necessário, porque diferentes transições são geradas dependendo do ob jeto que está sendo apontado por à referencia.
Para cada regra, nomeia- se um conjunto de eventos finito por instância definida no Grafo Inicial.
Conforme apresentado na Seção 4.2.1, os eventos referentes a urna regra r são gerados para cada possível combinação de valores de atributos ou parâmetros de mensagem capazes de determinar uma ocorrência da regra.
Portanto, cada evento ê rotulado atraves do nome da regra ao qual ele descende seguido dos atributos, referências a objetos ou parametros combinados com seus valores que definem uma ocorrência da regra.
A sintaxe para a rotulação destes eventos e dada a seguir:
Seguindo a sintaxe apresentada para a definição de eventos, e1emento\ índice\&gt; refere- se a um atributo, referência a objetos ou parâmetro de mensagens utilizado para determinar as possíveis ocorrências da regra.
Os valores que ocasionam a ocorrência da regra, para cada elemento, são apresentados como va1or\ e1emento\&gt; vá1ido\&gt;.
A Figura 4.7 apresenta o modelo Token Ring traduzido.
Os eventos descritos nesta figura seguem a nomenclatura apresentada nesta seção.
Para resolver modelos GGBOE, opta- se por traduzir tais modelos para SAN e então utilizar a ferramenta PEPS2003 na resolução dos modelos traduzidos.
Esta seção irá apresentar os algoritmos para tradução de modelos GGBOE para SAN, respeitando a nomenclatura descrita na Seção 4.4, semântica e restrições adotadas (Seção 4.2).
Para facilitar a legibilidade dos algoritmos, são definidas algumas abreviaturas.
Alguns conceitos de GGBO poderão ser encontrados com a abreviatura de suas letras iniciais, como GT genérica;
LE indica lado esquerdo de uma regra e LD o lado direito.
Além de estas abreviaturas, algumas funções que serão usadas nos algoritmos são definidas a seguir:
D (a) $ [ lista com valores do domínio de a| a e atributo ou a E parâmetroh pr0d_ cart 2 (lista de listas dada por o produto cartesiano entre as n listash aval (lista, pos) 2;
Os algoritmos que serão apresentados devem conduzir uma série de passos necessarios para cumprir a tradução.
Os passos que devem ser efetuados por os algoritmos são os seguintes:
Geração do espaço de estados dos autômatos que representarão o modelo SAN;
Definição de nomes para os autômatos e rotulação de seus estados;
Definição e rotulação dos eventos que serão usados nas transições entre os estados dos autômatos, baseada no conjunto de regras GGBOE;
Geração das transições entre os autômatos atributos;
Geração das transições nos autômatos mensagem, identificando consumo e geração de men sagens.
Para cada tipo de mensagem é necessario definir explicitamente o número maximo de possíveis mensagens armazenadas (na Seção 4.2.3 ha uma discussão sobre isso), que será utilizado para definir a cadeia de nascimento e morte.
Todas as instâncias de cada classe são obtidas do Grafo Inicial e seus atributos e mensagens, do Grafo Tipo.
O domínio dos atributos deve ser definido previamente, seja por o usuario ou através de metodos de analise dos limites dos atributos (veja discussão da Seção 4.2.3) (por exemplo, valores inteiros definidos por o intervalo (L4), booleanos por o intervalo (truafalse), etc).
Em a Seção 6.2 existe uma discussão sobre como o usuário poderia obter domínios reduzidos, de forma a gerar um espaço de estados menor.
O domínio de referências a objetos é definido de acordo com o número de instâncias da classe de mesmo tipo da referência, dado por o Grafo Inicial.
Este algoritmo para geração de espaço de estados e nomes de autômatos necessita avaliar todos os atributos, referências a objetos e mensagens do modelo.
Para tanto, avalia em cada Grafo Tipo, todas as instâncias deste tipo presentes no Grafo Inicial e, então define o espaço de estados referente a as mensagens, atributos e referências a objetos de cada instância.
Além disso, existe uma distinção entre mensagens corn ou sem parâmetros, pois como já foi discutido anteriormente, as mensagens com parâmetros são representadas por varios autômatos, cada um representando um conjunto possível de valores para os parâmetros.
A Figura 4.6 apresenta um conjunto de autômatos que representa uma mensagem que carrega parâmetros.
Estes autômatos são obtidos por a aplicação do algoritmo da Figura 4.8.
Para o modelo Token Ring, observa- se a tradução gerada na Figura 4.7.
A nomeação dos autômatos foi obtida de acordo com as linhas 6 e 18 do algoritmo da Figura 4.8.
Por exemplo, os nomes Sent_ Nodel e Msg_ Nodel são obtidos por a concatenação de msg-name_ obj mst e attribJbj-inst, respectivamente.
O espaço de estados de mensagens e atributos foram definidos seguindo as linhas 5 e 17.
O número máximo escolhido para as mensagens foi definido como uma mensagem, tanto para Token quanto para Msg.
Os eventos, responsaveis por disparar as transições entre os estados gerados por o primeiro algoritmo, serão obtidos do conjunto de regras do modelo GGBOE.
A notação usada para rotular os eventos é baseada na descrição dada na Seção 4.4 e é obtida por o algoritmo da Figura 4.9, constituindo o passo da tradução.
Outros algoritmos que serão definidos posteriormente farão uso de uma lista de eventos global chamada ev.
Esta lista possuirá os eventos que representam a ocorrência de todas as regras do modelo.
Para cada regra serão gerados todos os eventos referentes a cada instância ao qual a regra e aplicada.
Todas as combinações de valores entre os elementos que aparecem no lado esquerdo (estes elementos podem ser atributos, referencias a objetos ou parametros de mensagens) são geradas (linhas 3-4).
Cada combinação de valores é avaliada de forma a verificar se esta define uma ocorrência da regra (linhas 5-6).
Caso seja caracterizada a ocorrência, então e gerado um evento referente aquela combinação de valores encontrados no lado esquerdo.
Este evento deve ser sincronizante, deve possuir a mesma taxa descrita por a regra, alem de seguir a nomenclatura definida na seção anterior.
A função ocorrência (prod, R) verifica se os valores de prod referentes aos atributos, referências a ob jetos e parâmetros de mensagens presentes no lado esquerdo de R definem uma ocorrência desta regra.
Caso seja caracterizada uma ocorrência de R com o conjunto de valores apresentados em prod, a função retorna true, caso contrario, retorna false.
Por exemplo, numa regra onde atributos a, b e c apareçam no lado esquerdo e, uma condição associada à regra exija que:
A; A função ocorrência (prod, R) deve ser capaz de identificar, para qualquer valor da, b e c, se estes satisfazem as condições da regra.
Uma vez que a determinação de ocorrências de uma regra pode envolver resolução de sistemas lineares, deveria- se- definir um método numérico para resolução de tais sistemas.
Alem disso, o custo computacional para determinar ocorrências de regras pode ser elevado.
Estas observações devem ser consideradas numa possível implementação da tradução proposta neste trabalho.
Os próximos algoritmos irão apresentar as transições associadas a todos os possíveis eventos.
Cada transição caracteriza uma atualização de atributo ou referência a objetos, além de consumo e geração de mensagens.
A Figura 4.10 mostra o algoritmo utilizado para gerar as transições entre os estados nos autômatos atributo, referentes ao passo da tradução.
Os eventos gerados no passo, dados por a lista ev, definem todas as possíveis configurações de valores para os elementos numa aplicação de regra.
Para cada evento definido no modelo, algumas transições serão geradas, modificando ou não o estado dos autômatos (representando atributos ou referências) indicados no evento.
Primeiramente obtêm- se o nome da regra, valores representados no lado esquerdo (esta informação está explicitamente expressa no nome de ev) e instancia ao qual o evento se refere (linhas 2-4).
As funções nome_ regra (e), va1ores (e) e instância (e) obtém os valores referentes ao nome da regra, valores dos elementos que determinam a ocorrência da regra e, a instancia ao qual o evento e aplicado.
Estas informações estão explicitamente representadas por o nome do evento, Conforme a nomenclatura definida para eventos (vide Seção 4.4.3).
Os valores atualizados no lado direito são avaliados por a função atua1iza, onde são passadas como informações o nome da regra e os valores encontrados no lado esquerdo (linha 5).
Esta função deve ser capaz de avaliar valores de expressões utilizadas como atualização de atributos.
Em o caso mais simples, um atributo recebe um valor explicitamente, por exemplo, a $= 3.
No entanto, para uma implementação que abranja um maior conjunto de modelos, é desejável que esta função avalie expressões mais elaboradas (por exemplo:
A $= a+ b) 3.
Finalmente, transições são geradas atraves de transição em cada autômato atributo presente no lado direito da regra (linha 6-7).
Esta função define uma transição no autômato aut, disparada por o evento rótulo, partindo de origem e levando ao estado destino.
O passo da tradução define a geração e consumo de mensagens em modelos GGBOE, atraves de transições entre os estados dos autômatos mensagem em SAN.
A Figura 4.11 mostra este procedimento algorítmico que deve ser aplicado a cada evento definido no passo.
São obtidas as mensagens de ativação da regra m_ ativ (linha 4) e o conjunto de mensagens presentes no lado direito da regra (linha 5).
Para cada mensagem do lado direito é verificado se esta mensagem coincide com a mensagem 80s algoritmos apresentados nesta seção adotam um determinado nível de abstração, não sendo apresentadas as especificações de funções referentes à resolução de sistemas de equação, nem avaliação de expressões aritméticas.
Estudo de Caso Este capítulo apresenta a analise de três estudos de caso aplicando a metodologia proposta neste trabalho.
Inicialmente o modelo Token Ring descrito no Capítulo 2 e retomado para que a avaliação de índices referentes a ocupação da rede possam ser obtidos.
O segundo estudo apresenta um monitor de falhas de rede, onde um nodo monitor consegue detectar nodos falhos e ativar processos de recuperação nestes nodos.
Com este modelo são obtidos valores indicativos da disponibilidade dos nodos falhos.
Em o terceiro modelo, os dois modelos apresentados são integrados de modo a avaliar a influência do monitor numa rede Token Ring.
Para cada modelo que sera representado, taxas são associadas as regras de modo a representar os atrasos na aplicação de cada regra, conforme discutido na Seção 4.1.
Por exemplo, tempo medio entre falhas (MTBF -- Mean Time Between Failures) pode ser representado num modelo através de uma taxa indicando o período médio com que uma regra que ativa a falha no modelo ocorre.
Carga de rede pode ser expressa por a freqüência com que uma regra representando envio de mensagens ocorre.
No entanto, existem situações onde mais do que uma grandeza deve ser representada através da taxa associada a uma regra.
Supondo o envio de mensagens, pode ser de interesse representar uma taxa referente a o atraso decorrente da transmissão da mensagem atraves do meio de comunicação, assim como pode ser de interesse associar a mesma regra uma taxa referente a freqüência com que mensagens são enviadas.
Em este trabalho não foi definida uma estratégia capaz de combinar mais do que uma taxa por regra.
Portanto, as taxas utilizadas nas regras dos modelos estudados são didáticas, descrevendo de maneira experimental situações capazes de representar comportamentos desejáveis do modelo.
Como exemplos de comportamentos úteis para a analise quantitativa estão altas e baixas cargas de trabalho, tempo médio para reparo (MTTR -- Mean Time Te o Repair) lentos e rápidos, etc..
A Seção 6.3 discute uma alternativa para representar mais do que uma grandeza em aplicações de regra e suas implicações no modelo.
Todos os modelos gerados foram traduzidos manualmente respeitando os passos descritos no ferramenta PEPS2003.
Esta seção retoma o modelo Token Ring descrito na Seção 2.1 e, partindo da aplicação do método de tradução apresentado no Capítulo 4, é feita uma analise estacionárial do modelo SAN gerado.
A Figura 4.7 mostra um trecho do modelo SAN traduzido para o estudo de caso proposto.
Apenas a representação dos autômatos de uma instância de classe foi apresentada (Nodel), entretanto, todas as outras instâncias do modelo são da mesma classe, ou seja, o conjunto de autômatos que não esta sendo representado é idêntico ao da figura, exceto por os nomes de eventos e autômatos, que apresentam terminações diferentes.
São definidos diferentes cenários para avaliação do modelo.
De acordo com algumas combinações de taxas associadas as regras do modelo, pode- se representar uma rede onde se tem um alto índice de transmissão de mensagens, ou alternativamente, pode- se modelar uma rede com baixa utilização, onde mais freqüentemente são transmitidos tokens invés de mensagens.
As taxas escolhidas para representar o modelo Token Ring estocastico são ilustrativas.
Valores mais precisos poderiam ser obtidos através de medições de carga numa rede real, através da medição de tempo de comunicação, seja para transmitir tokens ou para transmitir mensagens.
Seguindo a proposta de inserção de taxas estocasticas associadas a modelos GGBO, apresentada no Capítulo 4 e com base no conjunto de regras definido na Figura 2.5, foram adotadas as seguintes taxas na versão estocastiça do modelo:
Regra Token_ Pass -- Taxa t_ tokenPass lEste modelo apresenta infinitos passos de computação, desde que sempre é possível aplicar alguma das regras definidas, Le.
Tomar algum passo de derivação.
A avaliação de modelos com esta natureza pode ser obtida através de análise das probabilidades de permanência nos estados do sistema em regime estacionário.
Regra Complete -- Taxa t_ Complete· Regra Transmit -- Taxa t_ Transmit Uma rede Token Ring com quatro nodos foi modelada, tendo uma topologia estática, ou seja, um nodo nunca tem seu vizinho modificado.
Como conseqüência da topologia estática do exemplo, a representação dos autômatos net_ Node1 a next_ Node4, referentes ao atributo next de cada instância, é desnecessária.
Portanto, quaisquer mensagens enviadas de um nodo para o seu vizinho terão sempre um único destino possível, não sendo necessario identificar o nodo vizinho através do estado de nezt.
Desta forma, cada nodo é modelado com três autômatos, um para o atributo sent e dois para as mensagens recebidas.
Ha dois estados em cada autômato (vide Figura 4.7), o que resulta em 12 autômatos e um espaço de estados produto de 4096 estados.
Entretanto, considerando o estado inicial dado por a função de alcançabilidade parcial apresentada no Capítulo 4, determinam- se apenas 20 estados alcançãveis.
A o associar taxas às regras do modelo e resolver a SAN correspondente, obtém- se a probabilidade associada a cada estado do modelo.
Com os resultados gerados pode- se analisar aspectos relacionados tanto ao comportamento quanto a o desempenho do modelo.
Como exemplo de analise do comportamento do modelo, são enunciadas algumas propriedades esperadas por o para o tocolo Token Ring.
Por exemplo: Propriedade 1: É impossível que mais do que um nodo receba um Token num mesmo instante;
Propriedade 2: Também não deve ser possível que dois ou mais nodos tenham mensagens suas sendo transmitidas no anel, simultaneamente;
Para analisar tais casos foram definidas, corn o uso da ferramenta PEPS2003, funções de integração.
Uma função de integração e uma expressão que utiliza as probabilidades calculadas dos estados do modelo SAN para obter índices referentes a aspectos quantitativos.
Para a propriedade 1, observa- se que a probabilidade de mais do que um nodo possuir um taken simultaneamente é igual a 00%.
A função de integração correspondente é:
A função nb retorna o número de autômatos (de Token_ Nude] até Token_ Node4) simultaneamente no estado 1.
Para a propriedade 2 a análise e análoga, porém a probabilidade de mais do que um nodo ter seus autômatos referentes ao atributo sent no estado true é avaliada.
Conforme esperado, esta probabilidade e 00%.
A função de integração correspondente e:
Para analises quantitativas desse modelo é analisada a probabilidade do sistema se encontrar num determinado estado.
Os estados analisados representam situações de interesse definidas atraves de funções de integração.
As probabilidades a serem avaliadas são:
A probabilidade da rede estar sendo usada por N ode] (isto é, a probabilidade do atributo sent_ Nodel ser true);
A probabilidade da rede não estar sendo usada por Node] (deveria ser o complemento de);
A probabilidade de ter mensagem de dados sendo transmitida por qualquer nodo (isto é, a probabilidade de qualquer dos autômatos sent_ Nada] a sent_ Nade4 estarem no estado true -- desde que todos os nodos têm as mesmas taxas, o anel deveria ser compartilhado igualmente e este valor deveria ser 4 vezes o valor de);
A probabilidade de não ter dados em transmissão (deveria ser o complemento de (iii));
A probabilidade de ter um taken em transmissão (deveria ser a mesma de (iv)).
A Tabela 5.1 mostra os resultados para estes casos, apresentando também a função de integração para cada situação.
O operador st aplicado ao autômato avalia o estado do autômato mencionado.
Em os cenarios 1 e 2, as taxas referentes ao recebimento e retransmissão de tokens ou mensagens são mantidas fixas.
Porém, as taxas que representam a freqüência em que a escolha e enviar um taken ou mensagem, além de a taxa de recebimento e retransmissão, são alteradas.
De essa forma são representadas redes com diferentes cargas de trabalho.
É possível verificar que quando a taxa associada ao envio de mensagens (t_ Send) diminui e a taxa associada a transmissão de tokens (t_ TokenPass) é aumentada, a ocupação do anel por dados de mensagens (função de integração (iii)) e reduzida, como esperado.
Este decréscimo e observado por a redução da probabilidade de envios de mensagens de 81.70% para 72.81%, nos cenários l e 2, respectivamente.
Por outro lado, a probabilidade da rede encontrar- se ociosa aumenta (sem envios de mensagens de dados), passando de 18.30% para 27.18%, nos cenários 1 e 2.
Diversas medições foram geradas com diferentes cenários, no entanto apenas os resultados de 3 cenários são exibidos.
A relevância dos cenários 1 e 2 esta na alteração da carga de trabalho da rede devido a alteração de apenas um aspecto:
A freqüência com que um nodo escolhe enviar tokens ou mensagens.
O cenário 3 foi escolhido por apresentar uma grande carga de trabalho na rede, ou seja, em grande parte do tempo dados são transmitidos por a rede.
Este valor torna- se ainda mais expressivo se comparado com a carga de rede exibida no cenário 2.
A execução dos modelos se da em dois instantes:
Primeiramente é descoberto o conjunto de estados alcançaveis partindo da função de alcançabilidade que representa o Grafo Inicial.
Finalmente, uma nova execução é refeita com 0 conjunto de estados alcançáveis corrigido.
O tempo de execução para a resolução destes modelos com a ferramenta PEPS2003 está.
Em a ordem dos segundos.
Para a determinação do conjunto de estados alcançãveis a execução levou aproximadamente 1,5 segundos, enquanto que a resolução do modelo com o conjunto de estados alcançáveis determinado levou cerca de 1,1 segundos.
Em esta seção um modelo de monitor de falhas em nodos de uma rede é traduzido segundo a metodologia proposta por este trabalho.
Além disso, são extraídas informações quantitativas baseadas na analise do modelo SAN gerado.
O método de detecção representado tem seu funcionamento baseado no recebimento de sinais de confirmação de que os nodos da rede estão operando corretamente.
Um monitor conhece o conjunto de nodos da rede, sendo que de tempos em tempos o monitor envia heartbeats para todos os nodos e aguarda a confirmação de que cada estação está funcionando corretamente.
Caso o monitor receba todas as mensagens, nenhuma suspeita de falhas na rede é levantada.
No entanto, se um nodo não responde durante um determinado tempo de espera, o monitor suspeita que o nodo esteja falho.
Para cada possível nodo suspeito de falha, o monitor aciona um procedimento de recuperação.
Não está sendo representado um detector de defeitos seguindo os modelos clássicos da literatura.
Em este modelo existe um único monitor que detecta um possível nodo falho e ativa um procedimento de recuperação deste nodo.
Não ha a geração e distribuição de lista de suspeitos entre os componentes da rede, portanto não há o conceito de suspeição de falhas, além de ser assumido que o monitor nunca falha.
Em o modelo proposto são definidos um monitor e quatro nodos na rede.
Cada nodo possui uma referência a objetos apontando para o monitor e este, uma referência para cada nodo.
De essa forma o monitor pode se comunicar com qualquer nodo e os nodos podem se comunicar com o monitor.
A troca de mensagens no modelo representa de modo intuitivo, comunicação entre os elementos da rede.
Contudo, a ausência de resposta num intervalo de tempo também está sendo representado por o envio de uma mensagem, Timeout.
Esta abstração é baseada em, no entanto, para este trabalho não esta sendo definido o comportamento de um determinado tipo de falhas.
Alem disso, um tempo medio referente a o timeout pode ser representado através de taxas, diferentemente da proposta de, onde não há qualquer informação sobre o tempo levado para a detecção.
A Figura 5.1 (a), (b) e (c) apresenta os Grafos Tipos para (a) o monitor e para os dois tipos de nodos, (b) os que nunca falham e (c) os defeituosos.
Para o Grafo Tipo referente a o monitor, observa- se a existência das referências nl, H2, n, que identificam os nodos conhecidos por o monitor (neste caso o objeto apontado por n] é um nodo defeituoso), um atributo Checked representando o número de respostas recebidas por o monitor, além de as mensagens Start (responsavel por iniciar um ciclo do monitoramento), Alive (resposta de que um nodo opera corretamente) e Timeout (representa a ausência de resposta do nodo dado por id).
Em a Figura 5.1 (b), ha uma referência do nodo ao monitor, dada por monitor e uma única mensagem capaz de ser recebida:
Heartbeat, que e a solicitação do monitor por uma resposta do nodo.
Em a Figura 5.1 (c), a classe FailNode herda a definição de Node e estende seu comportamento através do recebimento da mensagem Repair, que simboliza a ativação de algum procedimento de recuperação.
Mesmo que o processo de recuperação de um nodo falho esteja sendo acionado através de uma mensagem enviada a este nodo, esta abstração se mostra oportuna.
O atraso com que a regra é aplicada por o nodo falho representa o tempo levado para este nodo se recuperar, independente do método de recuperação adotado (este irão é o enfoque principal para esta avaliação).
Alem disso, associações de diferentes tempos de atraso na recuperação de nodos falhos podem representar a adoção de diferentes métodos de recuperação.
Portanto, e possivel avaliar a degradação no sistema, ocasionada por algum método específico.
O conjunto de regras definido para este modelo é descrito por as Figuras 5.2, 5.3 e 5.4, onde a primeira figura exibe as regras referentes ao monitor, a segunda, a única regra referente a cada nodo Node e, a terceira exibe as regras do nodo defeituoso.
Lmonllaring Receiving Lreceiving Checked: Ck Monitored:
A regra Monitoring é ativada através do recebimento de uma mensagem Start, cada nodo ira receber uma mensagem Heartbeat como efeito da aplicação desta regra.
A regra Receiving, ao ser ativada por a mensagem Alive, indica o recebimento de mais uma mensagem, portanto o valor do atributo Checked é incrementado.
Caso a última mensagem Alive seja recebida (regra Monitored), um novo ciclo de monitoração da rede será acionado (envio da mensagem Start para o próprio monitor e aplicação da regra Monitoring).
Por fim, se o monitor recebe uma mensagem Timeout, então este desconfia de que o nodo dado por id esteja falho.
De essa forma, o monitor aciona o serviço de recuperação do nodo suspeito, através do envio da mensagem Repair para o nodo3.
Para cada nodo, a regra Ok representa a solicitação e resposta para o monitor de que um nodo está em perfeito funcionamento (Figuras 5.3 e 5.4).
Caso 0 nodo possa falhar, a regra Fail também representa a solicitação por resposta sobre o estado funcional do nodo, no entanto, neste caso o nodo não deve responder, o que é representado por o envio de uma mensagem Timeout.
Para este par de regras, pretende-se utilizar uma freqüência associada a regra Fail, fazendo com imaginar como alternativa a substituição do nodo falho por um backup.
No entanto, este procedimento não é representado, mas a taxa associada à regra representaria o período levado para que o backup fosse ativado.
As taxas associadas a regra Fail determinam, para este modelo, maior ou menor ocorrência de falhas, onde este dado poderia ser obtido atraves de índices de M TBF, por exemplo.
Além disso, o período com que um nodo falho torna- se novamente operacional também pode ser representado com diferentes taxas (M TTR), associadas a regra Fixed.
As demais taxas, representam maior ou menor freqüência de envios mensagens de solicitação dadas por o monitor (regra Start), além de expressarem os atrasos entre o envio e recebimento de mensagens, como Alive e Heartbeat, por exemplo.
A Figura 5.5 exibe o Grafo Inicial definido para este estudo de caso.
Existe um monitor e quatro nodos na rede.
O nodo dado por a referência n] do monitor é um nodo defeituoso.
Os demais nodos não irão falhar em momento algum.
Inicialmente, o monitor recebe uma mensagem Start, que irá desencadear o processo de monitoramento (ativação da regra Monitoring).
A geração do modelo SAN para este modelo segue o procedimento de tradução definido no exibe a SAN correspondente ao objeto Monitor.
Os nodos são representados por as SANs das Figura 5.7 (a) e 5.7 (b), onde a primeira figura expressa nodos confiáveis e a segunda a extensão desta classe, que permite a falha.
Em estas figuras estão representados apenas os nodos Nada?
E FNodel.
Esta seção mostra alguns resultados obtidos através da resolução do modelo Monitor de Falhas em diferentes cenários.
Os resultados foram gerados com o uso da ferramenta PEPSZOOB e o modelo SAN utilizado segue a descrição da seção anterior.
Este modelo oferece, para um nodo defeituoso, a alternativa deste responder a uma solicitação (regra Ok) ou não (regra Fail), uma vez que o segundo comportamento representa a falha do nodo.
A taxa representada por a regra Fail a freqüência com que o nodo falha, não respondendo ao monitor.
A modificação desta taxa permite avaliar modelos com grande ou pequena incidência de falhas por nodo, ao longo de o tempo.
Além disso, M T TR pode ser representado por a taxa associada a regra Fixed.
Novamente, é possível definir grandes ou pequenos atrasos levados para a recuperação de um nodo falho.
De essa forma, foram definidos diferentes cenários, onde diferentes combinações destas taxas caracterizam grande ou alta indisponibilidade de um nodo não confiavel.
A seguir são apresentadas as propriedades enunciadas para a avaliação do modelo e suas respectivas funções de integração:
Detecção de nodo fálho:
Esta propriedade descreve um percentual do tempo levado para que o monitor detecte a presença de um nodo falho.
A função de integração é dada como segue:
Reparo de nodo:
Esta função descreve o percentual do tempo em que um deterrni «nado nodo está em fase de recuperação.
Indisponibílidade do nodo:
Esta função descreve o percentual do tempo em que um nodo fica indisponível para o sistema.
A Tabela 5.2 exibe cenários com diferentes taxas associadas as regras do modelo.
Os nomes das taxas são os mesmos apresentac os nas Figuras 5.2 e 5.3.
Para os dados da Tabela 5.2, foram mantidos fixos os valores referentes a tempos de envio e recebimento de mensagens, como por exemplo as regras Receiving e Monitored.
A freqüência com que o monitor verifica o funcionamento dos nodos da rede também foi mantida fixa para esta verificação (t_ monitoring).
No entanto, as alterações das taxas t_ fail e t_ fixed simbolizam a variação dos valores de MTBF e MTTR4.
O cenário 1 apresenta uma baixa ocorrência de falhas e um tempo de recuperação alto, de modo que a detecção de nodo falho é rapida (baixa probabilidade de ocorrência da propriedade Para o cenario 2 o processo de recuperação possui o mesmo tempo de serviço (dado por a taxa t_ fixed), no entanto aplicou- se um maior número médio de falhas.
Como esperado o nodo defeituoso tem um aumento no tempo em que permanece indisponível.
Para os cenários 3 e 4 repete- se o experimento, porém o tempo levado para um nodo voltar ao funcionamento correto (tempo de recuperação) e mais longo.
Ocorre um aumento considerável no tempo de reparo (propriedade (ii)) deste nodo, se comparado aos cenários 1 e 2.
De essa forma o período de indisponibilidade do nodo é prejudicado também.
Esta comparação poderia se dar devido a o experimento de diferentes técnicas de recuperação, onde a primeira (índices usados nos cenários 1 e 2) mostra- se mais rapida que a segunda (cenários 3 e 4).
Por fim, no cenario 5 é apresentado um caso com grande ocorrência de falhas e baixo tempo de recuperação do nodo FNodel, o que demonstra o caso mais crítico da tabela.
O nodo FNodel passa 26.13% do tempo indisponível.
Outras avaliações interessantes poderiam ser obtidas variando a taxa de solicitações dos estados dos nodos por o monitor.
Uma maior freqüência de envio de heartbeats leva a uma detecção dos nodos falhos mais rapida, o que parece vantajoso.
No entanto, uma vez que este detector esteja associado a uma rede onde exista uma carga de trabalho consideravelmente alta, deve- se procurar um equilíbrio, de modo que a comunicação inserida por o monitoramento não comprometa os tempos de comunicação efetiva entre os nodos da rede.
Esta seção demonstra algumas verificações feitas sobre o modelo Token Ring combinado com o modelo Monitor de Falhas.
Este estudo de caso foi escolhido por expor aspectos favoráveis no formalismo de especificação baseado em objetos, alem de demonstrar a avaliação de interferências de um mecanismo de detecção numa rede Token Ring.
AA taxa tifail não representa diretamente MTBF, uma vez que existe outra regra, dada por uma taxa tiok, capaz de alterar o estado onde a falha pode ocorrer.
Um aprofundamento nos significados das taxas é proposto como trabalho futuro.
A utilização de um formalismo baseado em objetos permite 0 reuso de classes previamente Inodeladas, ou até mesmo prover herança entre classes.
Para o modelo desta seção, utilizou- se o Grafo Tipo Monitor, tal como foi descrito na Seção 5.2.1.
Para a representação dos nodos, entretanto, pode- se imaginar o conceito de herança múltipla, onde tanto os atributos e mensagens de Nude do modelo Token Ring quanto os atributos e mensagens de Monitor de Falhas são utilizados.
O conjunto de regras para Node neste modelo segue as regras de Token Ring, porém um atributo e condição e adicionado ao modelo.
O atributo fault do tipo booleano e adicionado ao Grafo Tipo e, para cada regra herdada do modelo Token Ring é adicionada a condição fault:
Para as regras herdadas do modelo Monitor de falhas, o atributo fault torna- se true quando a regra Fail é aplicada e false quando a regra Fixed é aplicada.
O modelo SAN gerado não sera mostrado nesta seção, pois e análogo aos modelos apresentados anteriormente.
Tanto as regras apresentadas no modelo Token Ring, quanto no modelo Monitor de falha são apresentadas nos autôrnatos referentes aos nodos.
No entanto um atributo fault é adicionado e as regras referentes a comunicação de dados e tokens só é ativada quando este autômato atributo estiver no estado false.
Isso é garantido através de transições refiexivas no estado false, de modo que os eventos associados a esta transição só serão disparados quando o nodo não estiver falho.
O Grafo Inicial representado para este modelo é a união entre os grafos dados por os modelos descritos nas seções anteriores.
De essa forma existe um monitor que conhece todos os nodos.
Estes, por sua vez, conhecem seu vizinho e o monitor.
Uma mensagem Start é enviada para o monitor e uma mensagem Token é enviada para um dos nodos (neste exemplo, o nodo FNodel).
O espaço de estados produto gerado para este modelo é de 20.971.520 estados.
No entanto, o conjunto de estados atingíveis, partindo da função de alcançabilidade é de 1.760 estados.
As propriedades enunciadas anteriormente, nas Seções 5.1 e 5.2.2 são utilizados para avaliar este modelo.
As propriedades estão organizadas da seguinte forma:
Detecção de nodo falho:
Esta propriedade descreve um percentual do tempo levado para que o monitor detecte a presença de um nodo falho.
A função de integração e dada como segue:
Reparo de nodo:
Esta função descreve o percentual do tempo em que um determi nado nodo esta em fase de recuperação.
Indisponibilidade do nodo:
Esta função descreve o percentual do tempo em que um nodo fica indisponível para o sistema.
FNodel usando a rede:
A probabilidade da rede estar sendo usada por FNodel transmiting_ FNode1:
Rede Ocupada:
A probabilidade de ter mensagem de dados sendo transmitida por qualquer nodo transmiting 7 (nb true)\&gt; O;
Rede Ocíosa: A probabilidade de não ter cados em transmissão idle:
Os cenários definidos para esta avaliação combinam os casos de maior e menor ocupação da rede, definidos na avaliação do modelo Token Ring e período de indisponibilidade de nodo falho grande e pequeno.
Portanto, os cenários 1, 2, 3 e 4, na Tabela 5.3, respectivamente, representam rede com alta carga de serviço e períodos logos de indisponibilidade de nodos, rede com alta carga de serviço e períodos curtos de indisponibilidade de nodos, rede com baixa carga de serviço e períodos logos de indisponibilidade de nodos e rede com baixa carga de serviço e períodos curtos de indisponibilidade de nodos.
Os índices referentes à detecção não são alterados, como previsto, uma vez que a comunicação inserida para detecção é pequena.
Alem disso, a natureza de transmissão de mensagens seqüencial, inerente ao modelo Token Ring, permite que a adição de comunicações externa de um nodo com um monitor, por exemplo, não interfira prejudicialmente na comunicação interna a rede Token Ring.
No entanto, a ocorrência de falhas infiuência na transmissão de informações na rede, uma vez que um nodo defeituoso pode demorar mais tempo para repassar as mensagens que lhe são enviadas5.
O uso de um detector de defeitos permite que seja avaliado o quão freqüente estas falhas ocorrem, alem de oferecer a possibilidade de ativar um serviço de recuperação.
Esse efeito é percebido através dos dados encontrados na tabela, uma vez que no Cenário l a ocupação da rede por os nodos e reduzida de 94.33% para 91.78% em casos onde um nodo fica indisponível por um período considerável.
O Cenário 3, para a mesma carga de trabalho, não apresenta diminuição de ocupação da rede.
Isso é previsto porque o período de inatividade do nodo e pequeno e, novamente, devido a o carater seqüencial de transmissão de mensagens em redes Token Ring, na maioria das vezes que o nodo estiver falho, este não vai estar participando da comunicação.
Através desse modelo, nota- se que a detecção não e prejudicada por a comunicação da rede e a comunicação também não é prejudicada por a detecção.
No entanto os períodos de falha são percebidos em situações onde uma carga de trabalho alta esta sendo aplicada.
Entretanto, se o método de detecção envolvesse troca de mensagens através da própria topologia da rede, ou se o protocolo para comunicação utilizado adotasse múltiplos tokens, a influência entre os modelos seria muito mais acentuada.
A execução de cada cenario descrito na Tabela 5.3 corn a ferramenta PEPS2003 levou em média 23 horas.
A execução é dividida em dois instantes.
Primeiramente é descoberto o conjunto de estados alcançaveis partindo da função de alcançabilidade que representa o Grafo Inicial.
Finalmente, uma nova execução é refeita com o conjunto de estados alcançaveis corrigido, de modo a definir os resultados encontrados na tabela.
Considerações Finais O objetivo desta dissertação foi definir uma versão estocãstica de Gramática de Grafos Baseada em Objetos e possibilitar avaliação de aspectos quantitativos destes modelos.
A extensão ao formalismo GGBO é denominada Gramática de Grafos Baseada em Objetos Estocástica (GGBOE).
Taxas são associadas as regras do modelo origem para definir esta extensão do formalismo.
Urna vez descrito um modelo estocástico, é possível extrair probabilidades associadas a cada estado do modelo através de um método analítico.
Portanto foi definido um processo de tradução de GGBOE para redes de autômatos estocãsticos (SAN).
Os modelos gerados são resolvidos atraves da ferramenta PEPS2003, a qual oferece metodos numéricos para o calculo das probabilidades associadas aos estados dos modelos.
Os formalismos utilizados foram descritos neste trabalho, além de a extensão proposta (GGBOE) e a metodologia de tradução.
Para exemplificar a utilização e avaliação de índices quantitativos, como carga de trabalho numa rede e disponibilidade, por exemplo, foi definido um capítulo onde estudos de caso foram submetidos ao processo modelagem atraves de GG BOE, tradução destes modelos para SAN e analise dos modelos traduzidos com a ferramenta Este capítulo acrescenta considerações relacionadas ao processo de tradução proposto, na próxima seção.
Algumas otimizações sobre o metodo são apresentadas na Seção 6.2.
Experiências e observações obtidas com a implementação dos estudos de caso propostos são descritas na Seção S4 Capítulo s.
Considerações Finais A metodologia proposta para traduzir modelos GGBOE para SAN descrita nesta dissertação é beneficiada por os mecanismos capazes de representar aspectos similares em ambos os formalismos.
A modularidade inerente aos modelos SAN, expressa através de autômatos que podem modificar seu estado local de maneira conjunta ou independente de outros autômatos ofereceu um bom nível de especificação para representar modelos GGBO.
Componentes isolados em GGBO (atributos, referências a objetos e mensagens) são descritos como autômatos em SAN.
A sincronização oferecida por eventos em SAN, por sua vez, demonstrou- se adequada para expressar a atomicidade necessaria na modificação de atributos e geração e consumo de mensagens em aplicações de regras GGBO.
Além disso, a garantia de que eventos sincronizantes sejam aplicados num único passo também evita condições de confiito entre diferentes regras GGBO ocorram e, possibilita que regras não-conflitantes possam ser executadas em paralelo.
Esta proposta de mapeamento entre formalismos baseados em objetos e de especificação modular gera como resultado modelos facilmente compreensíveis e, desta forma, auxilia na validação do funcionamento do modelo traduzido.
Esse é um fator positivo, visto que também foi possível definir a metodologia através de procedimentos algorítmicos, no Capítulo 4, além de ter sido definido numa descrição formal da tradução.
O comportamento observado na avaliação dos estudos de caso também é um indício de que a semântica do formalismo original está sendo conservada com a tradução.
Por outro lado, algumas alternativas adotadas podem não parecer facilmente automatizaveis, como a necessidade de especificação de domínios para atributos e definição do número maximo de mensagens recebidas, para cada tipo de mensagem.
No entanto, foi sugerido o uso de algumas alternativas conhecidas, como analise estática, representação abstrata, além de um método iterativo para determinação de um valor ótimo para o número máximo de mensagens armazenadas.
Com relação a o domínio dos atributos, foi apresentada uma discussão na Seção 4.2.2.1, onde o uso conjunto do editor de gramática de grafos com o verificador de modelos SPIN é capaz de determinar os valores limites de cada atributo de um modelo.
Esta seção apresenta uma discussão sobre possíveis otimizações aplicáveis ao metodo proposto no Capítulo 4.
A geração da SAN segundo o metodo proposto basicamente define autômatos referentes a atributos, referências a objetos e mensagens com e sem parâmetros.
Uma redução no tamanho destes autômatos pode ser bastante significativa, visto que cada autômato e replicado de acordo com o número de instâncias, no Grafo Inicial, da classe que ele representa.
Para autômatos que representam mensagens, basta não expressar estados desnecessários (não atingíveís) na cadeia de nascimento e morte que se estará representando a forma mais otimizada.
A Seção 4.2.3 apresenta uma discussão sobre como proceder para obter um tamanho adequado para cada cadeia de nascimento e morte.
Para a representação de referências a objetos e atributos foram detectadas algumas possibilidades de redução do espaço de estados gerado.
Para representações de modelos com referências a objetos que definam uma topologia estática é possível não expressar os autômatos que representam a referência a objetos.
Entende- se por topologia estática uma configuração onde as referencias entre os objetos permanecem sempre as mesmas.
Isso é detectado por a avaliação do conjunto de regras.
Desde que não haja modificações de referências no lado direito de qualquer regra, o modelo e caracterizado como modelo de topologia estática.
Como conseqüência desse tipo de topologia, os autômatos que representam referências podem ser omitidos, já que existe um único e bem definido objeto apontado, dado por o Grafo Inicial.
De essa forma, qualquer regra que tenha em seu lado esquerdo uma referência representada, e possivelmente envios de mensagens para o objeto referenciado, sera associada a apenas um evento.
Conforme a tradução para o modelo Token Ring (vide Figura 4.7), Send_ next_ Node2_ Node1 não competiria com eventos como Send_ nezt_ Node1, Send_ nezt_ Node3_ Nortel e Send_ next_ Node4_ Nodel, pois o valor de next para Nude] é sempre Node2.
Outra otimização surge corn relação a autômatos que mantêm seus valores constantes durante a execução do modelo.
Isso é comum na modelagem de atributos que representam um identificador.
A ideia e análoga a descrita acima, para referências a objetos.
Uma vez que um autômato, representando um atributo, esta expressando um único valor, não existem regras que atualizem tal atributo (mudanças de estado no autômato) e condições envolvendo o atributo têm suas avali ações previamente conhecidas.
Logo, no processo de tradução, é possível omitir estes autômatos e apenas definir as transições baseadas no conhecimento do valor dado a estes atributos por o Grafo Inicial.
Eventos referentes a regras com consumo de mensagem apenas, ou consumo geração de mesma mensagem para a mesma instância de classe podem ser definidos atraves de eventos locais.
Isso pode ser possível porque apenas um autômato (autôrnato referente a mensagem de ativação da regra) é infiuenciado por este tipo de regras.
As otimizações apresentadas ate o momento são referentes ao processo de tradução;
No entanto, algumas técnicas comuns na literatura poderiam ser empregadas ainda no processo de modelagem.
Por exemplo, técnicas como representação abstrata poderiam ser aplicadas na definição dos atributos do modelo, de modo a reduzir o alcance dos atributos e, conseqüentemente, o espaço de estados gerado.
A definição dos estudos de caso avaliados no Capítulo 5 permitiu a observação de modelos traduzidos que apresentam diferentes situações, como por exemplo:
Aplicação do método proposto para tradução de mensagens com e sem parâmetros, envios de mensagens para diversos objetos (dado por o lado direito da regra), regras com condições associadas, pares de regras com o mesmo lado esquerdo (que definem uma mesma ocorrência dada por o lado esquerdo da regra) e atualizações no lado direito dadas por valores explícitos ou através de operações aritméticas.
O modelo Token Ring é suficientemente pequeno, permitindo descrever neste trabalho todos os passos de tradução efetuados para a sua geração no formalismo SAN.
Além disso, a escolha dos estudos de caso evidência aspectos positivos com relação a o uso de GGBO para modelagem de sistemas.
O paradigma baseado em objetos facilita a representação da comunicação entre processos numa rede, visto que esta é feita normalmente por troca de mensagens.
A capacidade de reuso de classes (dadas através de Grafos Tipos) foi explicitada através do reuso do Grafo Tipo Monitor em dois modelos diferentes.
Apesar de não ter sido apresentada uma semântica definindo herança em GGBO nas referencias bibliográficas apresentadas, para a construção do nodo no terceiro estudo de caso, nota- se o reaproveitamento das características presentes nos nodos definidos no primeiro e segundo estudos de caso (herança múltipla).
Ainda que os modelos escolhidos sejam relativamente pequenos, estes estudos de caso re tratam protocolos reais utilizados em sistemas distribuídos.
A avaliação quantitativa elaborada para estes estudos de caso possibilitou a extração de importantes aspectos em diferentes areas de estudo, como redes de computadores e tolerância a falhas.
Portanto, outras aplicações também poderiam ser representadas de forma sucinta sem perder suas principais características e ainda permitirem obtenção de importantes informações para a avaliação de sistemas.
As taxas representadas nos modelos estudados no Capítulo 5 foram escolhidas para formar cenários de interesse para analises quantitativas.
A descrição destas taxas não foi definida através de valores reais de transmissão de mensagens em redes em anel, ou M TBF e M TTR, por exemplo.
Adicionalmente, não foi definida uma forma para representar o período levado para que seja aplicada uma regra que descreve mais do que uma grandeza física (por exemplo, taxa referente a o atraso de transmissão de uma mensagem através do rneio de comunicação e taxa referente a freqüência com que esta mensagem e enviada).
No entanto, uma possível estratégia seria modelar estes casos através da decomposição de urna regra em duas ou mais regras.
Supondo uma regra r que é ativada por uma mensagem de ativação ma e envia uma mensagem m..
Esta regra pode expressar o atraso levado para o envio de uma mensagem m e um período medio entre envios de m..
Uma alternativa para representar estas duas grandezas seria decompor a regra r em duas regras:
T1 e T2.
De essa forma T1 pode ser ativada por ma, com uma taxa que expressa o caso, e gerar uma mensagem auxiliar mam, que servira de mensagem de ativação da regra T2.
A regra T2, por sua vez, é ativada por mau¡ de acordo com a taxa que expressa a situação e gera a mensagem m..
Esta alternativa podera ser adotada para representar regras que dependem de mais do que uma taxa para serem aplicadas.
No entanto, a criação de regras e mensagens auxiliares implica num aumento no tamanho do modelo ocasionado por a geração de novos autômatos representando cadeias de nascimento e morte para as mensagens de cada instância que aplique as regras auxiliares.
Este custo adicional, assim como outras alternativas, deve ser investigado em trabalhos futuros.
Outra constatação que se pode fazer com base nos estudos de caso apresentados está relacionada ao tamanho dos modelos traduzidos.
O tamanho do modelo gerado em SAN, mesmo que para um exemplo pequeno, é grande em termos de produto de estados gerados.
No entanto o conjunto de estados alcançável é bem reduzido.
A utilização da ferramenta PEPS2003 foi adequada para os modelos propostos.
No entanto, o modelo do Jantar dos Filósofos, apresentado em foi definido seguindo esta proposta de tradução e acabou gerando um produto de estados incapaz de ser tratado por a ferramenta.
Isto decorre do fato de que a ferramenta, apesar de apenas utilizar o espaço de estados atingível, precisa determinar o espaço produto.
Uma futura implementação da ferramenta PEPS2003 esta sendo definida e busca otimizar ou mesmo evitar o calculo do produto de estados.
Essa otimização ampliaria o conjunto de modelos possíveis de serem avaliados com esta proposta de tradução.
Com relação a a definição do método, além de novas otímizações, existem questões em aberto com relação a uma possível implementação da tradução de GGBOE para SAN.
Além disso, uma estratégia mais elaborada para definição de taxas e análise merece atenção.
Mesmo que os algoritmos e definições formais apresentados neste trabalho e em[ MDROSL quando aplicados aos estudos de caso dêem indícios que a semântica esta sendo preservada, é fundamental que um processo de formal de validação do metodo seja efetuado.
Apenas desta forma será garantido que as propriedades de GGBO se preservam no modelo SAN gerado.
O processo de tradução dos modelos GGBOE envolve a geração de todas as ocorrências de todas as regras do modelo.
Esse procedimento pode apresentar uma complexidade computacional elevada dependendo das condições envolvidas nas regras.
Em alguns casos é necessario resolver um sistema de equações lineares, o que pode revelar um alto custo computacional.
Portanto, uma analise mais apurada sobre determinação de ocorrência de regras em gramática de grafos deve ser levantadal.
Um novo conjunto de estudos de casos poderia ser definido, de forma a intensificar os testes feitos com os modelos traduzidos e a avaliação do impacto causado devido a o tamanho dos modelos gerados.
O uso de modelos com taxas baseadas em sistemas reais seria de grande importância, uma vez que a adoção das taxas neste trabalho foi desenvolvida de uma maneira que permitisse a geração de cenários de interesse.
No entanto, não foi possível observar um cenário gerado através de um conjunto de taxas representando grandezas em sistemas reais.
Em a seção anterior foi iniciada uma discussão acerca de a forma como as taxas podem representar mais do que uma grandeza física, como por exemplo, o atraso referente a o envio de mensagens e a freqüência com que as mensagens são enviadas.
Foi sugerida uma alternativa baseada na Ia Seção 4.5 descreve o procedimento algoritmo para efetuar a tradução, porém aponta esta dificuldade para definição dos eventos em SAN.
No entanto este método não foi validado.
Alem disso, essa alternativa originaria um maior número de mensagens no modelo.
Esta questão devera ser estudada em trabalhos futuros, de modo a aplicar esta estratégia, levantando os custos adicionais, ou então, buscar uma alternativa matemática capaz de gerar uma única taxa em função de todas as grandezas físicas que se pretenda representar.
Com relação a as restrições impostas por o método, poderá ser proposta uma alternativa capaz de efetivar a criação dinâmica de objetos por aplicação de regras.
Alguns autômatos inativos poderiam ser definidos no modelo e estes poderiam passar a um estado ativo, de modo a representar objetos criados dinamicamente.
Por fim, uma vez que se tenha o modelo traduzido, pode ser importante estudar uma metodologia de análise, de forma a evitar que o usuário seja obrigado a conhecer em detalhes da representação do modelo traduzido.
Deve ser observado como propriedades investigadas poderão ser descritas em função de os autômatos gerados por esta tradução.
