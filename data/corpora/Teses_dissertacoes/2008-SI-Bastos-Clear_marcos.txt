Em o contexto da engenharia de software, processos de desenvolvimento de software definem um conjunto de &quot;atividades», &quot;papéis», e &quot;artefatos «que são utilizados durante o ciclo de vida da construção de um produto de software.
Entretanto, tais processos representam artefatos como documentos monolíticos, que são compostos de informações fracamente estruturadas.
Isto ocorre dado o fato da construção dos artefatos ser feita a partir de processadores de textos, levando a um problema na computação da estrutura, da organização e do conteúdo, uma vez que limita a potencial formalização dos artefatos utilizados.
Diante deste contexto, o desafio é construir artefatos de software que podem ser controlados e gerenciados através de ferramentas que trabalhem com maior nível de formalização.
Em este sentido, apresentamos uma abordagem que visa à representação de artefatos de forma bem estruturada, separando artefatos em dois níveis:
&quot;estrutura «e &quot;conteúdo».
Além disso, este trabalho também auxilia na utilização de artefatos de forma genérica, independente de processo, o que é conhecido na literatura por camadas de &quot;definição «de artefatos e &quot;uso «em processos.
Desta forma, nossa abordagem consiste na utilização de um paradigma diferente de manipulação de artefatos, numa tentativa de melhoria no controle da informação desde a fase de autoria e definição do processo de desenvolvimento de software.
Palavras-chave: Artefatos de Software, Autoria, Processos de Desenvolvimento de Software, Metamodelo, SPEM v2, UML.
O Processo de Desenvolvimento de Software (PDS) caracteriza- se por a descoberta e documentação das informações sobre o domínio do sistema em construção.
Geralmente isto é feito num ciclo tipicamente incremental, de modo a sincronizar as necessidades dos usuários com a implementação dos desenvolvedores.
Entretanto, para construir um PDS que seja efetivo, não basta apenas escolher um ciclo de vida de processo, deve- se considerar a complexa inter-relação organizacional, cultural, tecnológica e econômica.
Sendo assim, deve- se ter em mente que criar um processo capaz de conservar todas essas variáveis não é uma tarefa fácil.
De entre estas variáveis, estão definidas atividades, papéis e artefatos que serão utilizados durante o desenvolvimento de software.
As atividades especificam as tarefas que devem ser executadas durante o processo, os papéis descrevem as pessoas que cumprirão com as atividades do processo e os artefatos armazenam as informações criadas durante a realização das atividades.
Em este sentido, as atividades do PDS estão concentradas na criação, manipulação e gerenciamento de Artefatos de Software que representam desde a especificação do Software até a sua implementação, passando por etapas como planejamento, testes e controle de qualidade.
A construção de um Produto de Software (PS) deve ser feita mediante a execução de um PDS, sendo que cada execução é única e gera diferentes tipos de artefatos e em diferentes quantidades.
Tais artefatos são necessários para que exista boa comunicação entre todos os interessados no desenvolvimento do produto.
Para garantir uma comunicação eficiente faz- se necessário conhecer as informações contidas num artefato, assim como os responsáveis por estas informações.
O Artefato de Software (As) é vital para o PDS e deve ser tratado de maneira adequada para evitar o surgimento de problemas como, falha no preenchimento, má interpretação e duplicação das informações.
Além disso, a manipulação torna- se mais trabalhosa quando eles apresentam inconsistência e ambigüidade, visto que isto é proveniente da má estruturação do seu conteúdo, já que artefatos são constituídos a partir de estruturas lógicas e representações particulares de informação.
Portanto, neste trabalho apresentamos uma solução para que seja possível:
Categorizar, organizar, classificar, versionar e definir níveis de maturidade de ASs;
Formalizar e definir representações na estrutura e nos tipos de informações de ASs;
Reutilizar a estrutura, a informação e as possíveis versões de ASs;
Em um PDS.
Como já era esperado, muitos processos de desenvolvimento de software encontrados na literatura, assim como Rational Unified Process (RUP), Object-oriented Process, Environment and Notation (OPEN) e SCRUM, compreendem artefatos de forma monolítica.
A o analisarmos um processo específico é possível perceber a real importância dos artefatos para a obtenção do produto.
No caso de o RUP, são definidos aproximadamente 100 artefatos que, em sua grande maioria, são renderizados através de processadores de texto como o Microsoft Office WordTM ou Open Office Writer1.
Conforme já foi mencionado, ASs são utilizados à medida que um PDS é executado (enactment), porém eles são especificados durante a definição do PDS, ou seja, na autoria (authoring).
O nível de autoria de um PDS é realizado em duas fases, Definição de elementos do PDS e Uso dos elementos por o PDS.
Desta forma, pode- se consumir os elementos que forem necessários para projetar um PDS efetivo para um determinado domínio.
Definição dos Elementos de PDS Conceitualmente cada artefato deve ser preenchido com informações específicas que surgem durante a execução de algum projeto em que fazem parte.
Entretanto, à medida que se conhece o comportamento do projeto e com base na experiência em construção dos artefatos, muitas vezes já se sabe o que e como devem ser preenchidos, mesmo que não exista um projeto, mas apenas o processo.
Este é o tipo de informação necessária para que seja possível determinar um arcabouço conceitual que define como serão os artefatos.
Em a Figura 1.1 podem ser vistos o modelo conceitual de artefato e sua instância na fase de autoria.
Em a estão os elementos Definição de Artefato, que neste caso representa um As, e Tipo de Informação, num relacionamento n:
M ou seja, o mesmo artefato pode possuir muitos tipos de informação e uma informação, por sua vez, pode estar em vários artefatos ao mesmo tempo.
Além disso, em b é visto o que comumente acontece, um único tipo de informação (T) é representado através de diferentes tipos, muito parecidos que são utilizados várias vezes por diferentes artefatos sem que seja percebida.
Diante deste contexto, o mesmo tipo de informação será utilizado despercebidamente e perde- se o reuso.
Outros pontos fracos são:·
a mesma estrutura geralmente será utilizada para representar a mesma informação.
Sem reuso da estrutura o reuso da informação poderá não ser identificado;·
existe muita confiança no papel que será responsável por a produção do artefato que, sem conhecer exatamente os padrões e estruturas estará livre para fazer o que quiser;·
sem possuir uma estrutura formal é computacionalmente impossível utilizar a informação, a exemplo disto, pode- se fazer um paralelo com linguagens de programação, que são formalizadas para que possam ser computáveis.
Uso dos Elementos já criados por um PDS Em a Figura 1.2 estão o modelo conceitual de artefato e sua instância no que se diz respeito ao seu uso.
Em a estão os elementos Artefato e Informação, numa agregação n:
M ou seja, um artefato pode possuir muitos tipos de informação ou ao menos um, portanto, cada informação pode estar em mais de um artefato.
Em b pode ser observado como se dá a sua construção e, supostamente, a mesma informação pode ser repetida em I1, I2 e I3, estando dentro de os artefatos.
Sendo assim, existe pouco reuso da informação que, ao se repetir (utilização de copia e cola), gera redundância.
Outros pontos fracos são:·
podem ser feitas muitas cópias da mesma informação;·
como são cópias de uma mesma informação, I1, I2 e I3 podem ter sido alteradas separadamente à medida que foram introduzidas nos artefatos, estando em versões diferentes e denominando falta de controle;·
não há rastreabilidade entre os artefatos e as informações, ou seja, difícil identificar se a mesma informação está disposta em diferentes artefatos.
Segundo, a demanda por softwares cada vez mais complexos é maior do que a capacidade de produzir- los através dos processos e metodologias conhecidas até então.
Baseados nesta idéia, muitos autores tenderam ao desenvolvimento de metodologias baseadas em casos de uso (use- case methodology) (Williams, 2004).
Portanto, houve mudança na construção dos processos de software.
Tal mudança foi feita para suportar uma nova metodologia dirigida por a documentação de um projeto.
Engenheiros do Software acreditam que a documentação de um produto ajuda no entendimento não só funcional, mas também em nível de projeto e em detalhes de implementação do mesmo.
Sem documentação, os Engenheiros de Software são forçados a confiar apenas no código-fonte do produto.
Uma boa documentação com qualidade ajuda e facilita a conclusão das tarefas, em a qual várias e complementares perspectivas são fornecidas para melhor entendimento de um sistema.
Produzir o melhor software possível, juntamente com a melhor documentação possível é um dos principais objetivos da Engenharia de Software.
Para, o controle de informações é feito a partir de um processo de documentação divido em três partes:
Coleta a partir de múltiplas fontes de informação, processamento de toda a informação coletada e publicação da mesma através de vários tipos de artefatos (geralmente documentos como manuais e descritores).
Entretanto, algumas vezes a documentação é considerada plano de fundo e não tão importante quanto o próprio software.
Para, a falta ou baixa qualidade da documentação é a maior causa de erros e necessidades de manutenção num produto de software.
Portanto, é notável a necessidade e a importância de documentação num processo de software.
Problematica 01 PDSs entendem artefatos como representações monolíticas, visto que todo o processo gira em torno de a produção de ASs ao invés de a informação contida no mesmo.
Sendo assim, ao se deparar com um As, não é possível saber como o mesmo está estruturado ou ao menos quais são as informações necessárias para preencher- lo.
Portanto, o processo enxerga a informação como um conjunto, não como os elementos de uma composição de várias estruturas de informação existentes.
Problematica 02 (P2) Linguagens de Modelagem de Processos não possuem os níveis de profundidade necessários para definir todos os elementos necessários de um PDS.
Sendo assim, dentro de o escopo de As mais especificamente, tais linguagens não determinam alguma representação em níveis de informação.
Isto demonstra que não é possível se obter o detalhamento do As, evitando que sua definição seja desmembrada de sua utilização.
Tal fato implica em ambigüidade e inconsistência.
Além disso, deixa dúvidas durante a execução do PDS, tais como:·
Qual formato dos artefatos?
Como é sua estrutura interna?
Quais informações devem preencher- lo (e.
g gráficos, imagens, links)?·
Como artefatos devem ser preenchidos ou gerados?
Existe alguma particularidade no estilo ou maneira de tornar um artefato mais familiar ou mais compreensível?·
Como versionar o artefato identificando onde houve modificação e por quem?·
Como identificar e evitar redundância tanto na estrutura quanto no conteúdo dos artefatos numa tentativa de reuso?
Problematica 03 (P3) Não existe uma maneira clara para (i) determinar e especificar ASs e definir qual o fluxo a ser realizado durante a definição e o uso de ASs.
Conforme visto anteriormente, processos como RUP, OPEN e SCRUM, comumente utilizados tanto na indústria quanto na academia, tratam seus artefatos de maneira monolítica.
Não obstante, linguagens para descrição de processos são bastante genéricas e tratam os componentes do processo da mesma forma.
Este tipo de prática pode levar a problemas como, por exemplo, ambigüidade e inconsistência na autoria dos artefatos e diminuição do grau de reuso de informação.
Como estes artefatos são, em sua maioria, semi-estruturados, a falta de um formalismo pode causar problemas ao se computar as informações existentes.
Portanto, surge a questão de pesquisa:
Como deve ser a autoria de Artefatos de Software de forma que estes não sejam monolíticos?
Embora artefatos sejam vistos como se fossem pedaços de informação sem estrutura ou forma definida, estes possuem estruturas lógicas internas e diferentes representações de informação.
Nem sempre é possível perceber ou verificar a existência de redundância sem entender o artefato como um todo.
Como existem diferentes ASs, a solução deste problema requer conhecimento sobre a estrutura de cada um de eles desde que cada um possua uma estrutura interna diferente.
Infelizmente, este tipo de tratamento não é verificado em linguagens de autoria ou execução de PDSs.
Em este contexto, alguns desafios são:
Baseados nestas dúvidas nosso objetivo é desenvolver uma abordagem que provê a autoria de artefatos determinando maiores detalhes sobre suas estruturas de informação.
Diante de isto nossos objetivos específicos são:
A abordagem em desenvolvimento representa esforços para a solução dos problemas apontados nas seções anteriores.
Além de isto, este trabalho apresentará contribuição para autoria de artefatos.
Um breve resumo das contribuições a serem geradas por a pesquisa descrita neste trabalho é apresentado a seguir:
Especificação de um Guia para a Autoria de Artefatos:
Conforme a necessidade de conhecer ASs e suas estruturas, foi desenvolvido um guia para definir a autoria de PDSs juntamente com a de ASs em detalhes, permitindo reuso de definição e uso dos mesmos.
Além disso é apresentado como elaborar o desenvolvimento de artefatos em partes menores, onde papéis atuarão nestes fragmentos.
Levantamento de estruturas de informações contidas em artefatos conhecidos:
Com a obtenção de conhecimento sobre o formato estrutural dos ASs e seu preenchimento será possível um melhor entendimento sobre o ciclo de produção do mesmo.
As informações que permeiam a forma do artefato poderão ser verificadas e avaliadas iterativamente, onde poderemos utilizar versionamento tanto na definição, quanto no uso dos artefatos.
Além de o mais, o aumento no compartilhamento de conteúdo e estrutura, baseado no reuso, poderá diminuir o tempo de elaboração e produção dos artefatos.
Criação de uma Meta-Linguagem:
Com uma linguagem de definição de ASs podemos construir- los em detalhes, utilizando estruturas lógicas e organização bem definida.
Portanto, criamos um metamodelo que permite a autoria e produção de ASs numa linguagem com vários níveis de formalismo, servindo como base para os esforços futuros na área de autoria de PDSs, assim como, para o desenvolvimento de aplicações neste contexto.
Em esse sentido, foram desenvolvidos:
Um metamodelo que define a sintaxe e semântica do problema e regras de boa formação que especificam as restrições necessárias;
Ferramenta Protótipo de Suporte: A implementação do metamodelo conforme um plugin construído com base no Eclipse Modeling Framework (EMF) (Duddy, 2003) disponibilizará recursos para a autoria de ASs.
O trabalho está dividido em etapas que agrupam as atividades relacionadas.
Tais etapas se relacionam através de fluxo de atividade que pode ser visualizado na Figura 1.3 e serão descritas conforme a ordem em que foram realizadas:·
Etapa 1: Realizar o levantamento bibliográfico sobre os PDSs.
Esta etapa foi contínua e visou verificar o impacto de outros trabalhos na área na abordagem proposta;
Fazer levantamento sobre tipologia de artefatos através de estudo teórico;
Fazer aprofundamento de estudos sobre os mecanismos de extensão de metas-linguagem baseadas em autoria de PDSs ou ASs.·
Etapa 2: Identificar os artefatos mais utilizados nos PDSs analisados na Etapa 1;
identificar a tipologia dos ASs, selecionando um mapeamento para cada estrutura de informação diferente;
Propor a criação, utilização ou extensão de uma linguagem ou meta-linguagem para permitir a quebra do As numa estrutura mais granular de acordo com as tipologias encontradas.·
Etapa 3: Realizar a análise dos resultados obtidos das etapas 1 e 2 para:
Especificar a meta-linguagem que defina as tipologias inspecionadas;
Elaborar o guia de autoria de ASs;
Propor uma ferramenta de suporte para verificação da abordagem;
Análise e projeto da ferramenta;
Implementação da ferramenta proposta;·
Etapa 4: Realização de caso de teste sobre o protótipo, objetivando a prática do que foi desenvolvido nas etapas anteriores;
Finalização da escrita e submissão de artigos;
Para a realização da Autoria de Artefatos em Processos de Software foram definidas as seguintes atividades:·
Atividade 1: Capturar e identificar os artefatos, conhecer suas estruturas internas (Gráficos, textos, figuras, seções, listas), elaborar e estudar a fundamentação teórica e identificar trabalhos relacionados.·
Atividade 2: Estudo dos PDSs, ASs, tipologias e linguagens PDSs.
Foram realizados estudos sobre PDS mais populares, a fim de examinar os tipos de ASs existentes.
Também foi feito exame sobre as especificações de PDS e metamodelos que representam artefatos específicos de processos.·
Atividade 3: Realizar uma análise dos resultados obtidos das etapas 1 e 2 para:
Identificar e filtrar os artefatos mais utilizados nos PDSs analisados;
Identificar a tipologia dos ASs inspecionados, selecionando um mapeamento para cada estrutura de informação diferente;
Propor a criação de uma metalinguagem que permita a quebra de um As numa estrutura mais granular.
Em esta atividade definimos a utilização da linguagem padrão de PDS ao longo de o trabalho, entendendo o seu funcionamento e definindo alguns pontos problemáticos existentes que inviabilizam a criação de ASs em detalhes até então.·
Atividade 4: Especificação formal das tipologias a serem utilizadas e especificação da meta-linguagem.
Esta atividade foi fundamental para a definição dos conceitos necessários para a extensão da linguagem selecionada na Atividade 3.
Sendo assim, foi definido Ponto de Conformidade (Compliance Point) a ser utilizado.·
Atividade 5: Análise e projeto da ferramenta.·
Atividade 6: Implementação de um protótipo da ferramenta.·
Atividade 7: Testes e verificação.
Realização dos casos de teste sobre o metamodelo desenvolvido com o uso do protótipo da ferramenta a ser implementado na Atividade 6.·
Atividade 8: Preparação e apresentação de Seminário de Andamento.·
Atividade 9: Redação de artigos científicos.·
Atividade 10: Redação e revisão da Dissertação de Mestrado.·
Atividade 11: Entrega e defesa da Dissertação.
Este trabalho se encontra organizado da seguinte maneira:
Proposta, sob uma visão comparativa;
Em este capítulo apresentamos um resumo explicativo sobre os principais conceitos utilizados nesta dissertação.
Nosso objetivo é facilitar a leitura deste trabalho, determinando a base da fundamentação teórica estudada durante a pesquisa.
Este capítulo está definido da seguinte forma:
Em a Seção 2.1 está definido o conceito de As juntamente com alguns exemplos;
A Seção exemplos de PDS existentes e bastante conceituados;
A Seção 2.3 apresenta fundamentação sobre modelagem e metamodelagem;
E, por fim, a Seção 2.4 apresenta um breve resumo sobre a linguagem de modelagem de PDS utilizada no decorrer deste trabalho.
Artefato de Software é identificado como um dos principais elementos que fazem parte do núcleo de PDSs, que descreve quem está fazendo o que, como e quando.
Em este caso, um Artefato de Software é o que está sendo feito.
Segundo, um artefato é um pedaço de informação que é produzida, modificada ou utilizada por um processo.
O que é uma definição bem razoável de um ponto de vista mais amplo.
Além disso, o mesmo autor ainda afirma que estes devem ser elementos tangíveis de um projeto, produzidos durante a construção de um produto final.
Entretanto, para, ASs são produtos de trabalho finais ou intermediários produzidos e usados durante os projetos, os quais são utilizados para capturar e transmitir informações do projeto.
Restringindo um pouco o domínio para PDSs, artefatos são inerentes à execução de alguma atividade, para a qual pode ser tanto uma entrada, para que a atividade possa ser executada, como uma saída ou resultado de uma execução que poderá ser utilizado em outras atividades.
Sendo assim, artefatos podem ser de várias formas ou formatos diferentes.
De entre eles podendo ser:·
um modelo, assim como Modelo de Casos de Uso da UML;·
um elemento de um modelo, que é um elemento dentro de um modelo, assim como um Caso de Uso (UC);·
um documento, como por exemplo o documento Visão do RUP;·
executáveis, como um Protótipo executável por exemplo.
Como artefato é um termo utilizado no RUP, em inglês artifact, outros processos podem utilizar termos bem diferentes como produto de trabalho, unidade de trabalho e outros, para designar o mesmo elemento.
Sendo assim, não existe uma padronização.
Para tornar isto mais claro e por questões de definição de uma nomenclatura padrão, apresentamos a Tabela 2.1, que utiliza uma tradução para a terminologia em diversos outros processos.
Como pode ser observado, embora o a utilização de Product seja feita com maior freqüência de entre os PDSs analisados, continuaremos a utilizar o termo Artefato de Software (As).
IBM Global Services Method descrição de produto de trabalho Work Product Description Por fim, em termos de construção, um As pode ser documentado de duas formas:
Através de formalização, com uso de ferramentas ou informalmente, capturados através de e-mails, por exemplo.
A noção de processo é comum e faz parte das atividades humanas e em sua definição mais elementar é dado como sendo uma forma sistemática de criação de um produto de acordo com algumas tarefas pré-determinadas.
Processo é um verbete de origem direta do Latim processus, que significa a idéia do que segue adiante, do que avança no eixo do tempo.
Este verbete exibe uma origem etimológica mais distante, seu significado tem a ver com a palavra grega proodoz (leia- se próodos) que traduz progresso, progressão, avanço.
Processos são geralmente utilizados para se criar formas efetivas e, possivelmente, genéricas na construção de algum produto.
O processo, em sua essência, é visto como o alcance de uma solução e, conforme as descrições dos passos do processo, executar- lo como uma instância.
Esta instância servirá para resolver problemas mais específicos.
Entretanto, muitas vezes não é fácil entender um processo, e isto se dá por existir uma diferença fundamental entre a descrição e o próprio processo.
Para Dijkstra, 1979, enquanto a descrição do processo é uma entidade estática e de fácil análise e compreensão, o processo em si é dinâmico e um pouco mais difícil de ser compreendido.
Como exemplo, pode- se tomar uma receita de bolo:
A receita simplesmente descreve como o bolo deve ser feito;
O processo será o preparo do bolo.
Em este exemplo, fica claro que enquanto um processo é um instrumento para se fazer algo, sua descrição especifica como algo deve ser feito.
Em o contexto da computação, um processo é uma tarefa em execução inserida num dispositivo computacional.
No entanto, não existe um consenso entre os autores no tocante a definição de um Processo de Desenvolvimento de Software (PDS).
De acordo com, um PDS pode ser definido como um conjunto de atividades, métodos, práticas e transformações que as pessoas empregam para desenvolver e manter o software e os produtos associados (por exemplo, planos de projeto, documentos de projeto, design, código, casos de teste, manual do usuário).
Não muito obstante, para Soares, 2004, um processo de software é um conjunto coerente de atividades e resultados associados que auxiliam na produção de software.
Para, processo de software nada mais é que um conjunto coerente de ações (policies), estruturas organizacionais, tecnologias, procedimentos e artefatos necessários para conceber, desenvolver, implantar e manter um produto de software.
Um PDS define a seqüência em que os métodos serão aplicados, como os produtos serão entregues, os controles que ajudam a assegurar a qualidade e a coordenar as mudanças, e os marcos de referência que possibilitam aos gerentes de software avaliar o progresso do desenvolvimento.
Sendo assim, PDSs são importantes porque tentam uniformizar a realização dos Produtos de Software (PS) através de projetos, reduzindo o tempo de produção e custos.
Caso um processo esteja explicitamente correto, o desenvolvimento do software será feito de forma sistemática e ordenada.
Conforme, existe uma relação quase que direta entre a qualidade de um PS e o PDS que o produziu.
Desta forma, o PDS faz parte da camada mais importante da Engenharia de Software (ES) e se constitui no elo de ligação entre as ferramentas e os métodos, além de possibilitar um desenvolvimento racional do software.
Em este caso, a ES caracteriza- se por a produção de um PS através de processos de qualidade.
Entretanto, para construir um PDS que seja efetivo, não basta apenas escolher um ciclo de vida de processo, deve- se considerar a complexa inter-relação organizacional, cultural, tecnológica e econômica.
Sendo assim, deve- se ter em mente que criar um processo capaz de conservar todas essas variáveis não é uma tarefa fácil. Segundo,
a criação, construção e utilização de processos envolve a captura e a análise de práticas existentes dentro de a construção de algum produto ou fornecimento de serviço, redesenho e simulação, instalação e gerenciamento, captura e auditoria do histórico dos acontecimentos e refinamento e melhoria.
O ciclo da gerência de processos é apresentado na Figura 2.1 e está dividido em três instantes.
Em o instante 0, em branco, está a modelagem do PDS, de o qual este instante é conhecido por autoria (authoring).
O instante 1, em tom mais escuro, apresenta a execução (enactment) do PDS.
Entre esses dois instantes, em tom claro, pode- se adicionar um instante de re-análise e remodelagem (tailoring).
Em as próximas Seções serão apresentados PDSs já consolidados.
Em a Seção 2.2.1 é apresentado o RUP, um exemplo de PDS baseado em metodologias tradicionais de desenvolvimento;
Já a Seção 2.2.2 está o Scrum, como instância de metodologia ágil.
Rational Unified Process O Rational Unified Process (RUP) é um Processo de Desenvolvimento de Software desenvolvido por a Rational Software da IBM.
Atualmente o RUP é bastante conhecido, pois provê uma abordagem disciplinada que determina tarefas e responsabilidades, e muito utilizado devido a o fato de ser um arcabouço de processos de software (process framework).
Isto faz com que possa ser adaptado ou estendido de acordo com as necessidades do contexto organizacional.
A estrutura do RUP é dividida numa arquitetura com duas dimensões, Figura 2.2.
O eixo horizontal representa o tempo, caracterizando o ciclo de vida do processo.
Este eixo representa os aspectos dinâmicos do processo (enactment), e utiliza ciclos, fases, iterações e milestones.
Já o eixo vertical representa as principais disciplinas que agrupam um conjunto de atividades, onde estas são consideradas a parte estática do processo.
Em esta dimensão estão os componentes do processo, ou seja, as atividades, disciplinas, artefatos e papéis.
Estrutura Estática -- Descrição do Processo O modelo do RUP descreve quem (who) está fazendo o que (what), como (how) e quando (when)!
Portanto, o Rational Unified Process é representado por cinco elementos principais:·
Papéis (Roles), quem (Who).
Define o comportamento e as responsabilidades de um indivíduo ou um grupo.
Cada papel é associado a um conjunto de características que são requisitos para quem o atuará.
Existem cinco tipos de papéis:
Analyst, developer, tester, manager e production/ support;·
Atividades (Activities), como (How).
É uma unidade de trabalho para que determinado indivíduo, atuando em determinado papel requerido, produza algo que faça sentido ao projeto em questão.
Atividades são quebradas em etapas (Steps), de os quais podem ser divididos em três categorias principais:
Thinking steps, performing steps e reviewing steps;·
Artefatos (Artifacts), o que (What).
Um artefato é qualquer pedaço de informação que é produzido, alterado, ou modificado através do processo.
Além de isto, artefatos são unidades tangíveis de um projeto.
Os artefatos são apresentadas com maiores detalhes mais adiante;·
Fluxos (Workflows), quando (when).
É uma sequência de atividades que produzem um resultado.
O RUP possui três tipos de fluxos:
Core workflows, workflow details e iteration plans;·
Disciplinas (Disciplines).
São contêineres que agrupam os primeiro quatro elementos anteriores.
As disciplinas são apresentadas com maiores detalhes mais adiante.
Arquitetura Uma boa parte do RUP é baseada em modelagem.
Modelos ajudam a entender melhor um problema para imaginar uma solução.
Um modelo na verdade é simplificação da realidade, ajudando a reduzir o domínio e diminuir a complexidade.
Um único modelo não é suficiente para cobrir todos os aspectos do desenvolvimento de software.
Desta forma, é necessário obter múltiplos modelos que devem estar corretamente relacionados e consistentes.
Baseado nas arquiteturas existentes, o RUP sugere uma abordagem com cinco perspectivas:
Logical View, Implementation View, Process View, Deployment View e Use-Case View Figura 2.3.·
Logical View: Esta perspectiva endereça os requisitos funcionais do sistema, em outras palavras, o que o sistema deve fazer.
Esta perspectiva é uma abstração do modelo, identificando como devem ser os pacotes, subsistemas, classes, entre outros.·
Implementation View: Esta perspectiva descreve como a parte estática do software deve ser organizada em módulos (código-fonte, arquivos de dados, componentes, executáveis, entre outros), dentro de um ambiente em termos de empacotamente e configuração.·
Process View: Esta perspectiva endereça os aspectos concorrentes de um sistema em tempo de execução.
São analisados deadlocks, tempo de resposta, isolamento de funções e falhas.·
Deployment View: Esta perspectiva define como os vários executáveis e outros componentes de execução são mapeados para uma plataforma computacional.
São endereçados problemas como instalação e performance.·
Use-Case View: A última perspectiva, baseada em casos de uso, contém os cenários do sistema.
Inicialmente esta perspectiva é utilizada para direcionar a descoberta e projeto da arquitetura nas fases inicial e elaboração.
Artefatos Um artefato é qualquer pedaço de informação que é produzido, alterado, ou modificado através das atividades de um PDS.
Além disso, artefatos são unidades tangíveis de um projeto e sua soma determina o PS final.
Um artefato pode ser de várias formas ou características, de entre elas:
Um modelo, um elemento de um modelo, um documento, código fonte e executáveis;
O RUP é muito famoso por pregar que sua documentação seja feita com alto grau de burocracia.
São definidos aproximadamente 100 artefatos de os quais, aproximadamente 55, são editados através de processadores de texto.
O padrão estabelecido para definição dos artefatos é baseado em templates e exemplos.
Tais templates são moldes em linguagem natural que definem como os artefatos devem ser preenchidos.
Os exemplos são instâncias de templates já preenchidos.
Disciplinas Disciplinas, são conjuntos de atividades do processo, organizadas logicamente.
Existem nove disciplinas e elas são divididas entre técnicas e de suporte:·
Disciplinas Técnicas:
Modelagem de Negócio, Requisitos, Análise e Projeto, Implementação, Teste e Instalação.·
Disciplinas de Suporte: Gerência de Projeto, Configuração e Mudanças e Ambiente.
Scrum O Scrum é um processo de gerenciamento de software de o qual, pode- se criar um projeto de desenvolvimento de software de forma iterativa e incremental.
Tal PDS foi introduzido em 1995 por a Advanced Development Methodologies, ganhando popularidade depois da formação da Agile Alliance, em 2001.
O processo em si é ágil (agile) e leve (lightweight), permitindo também, a combinação com novos processos ágeis, podendo funcionar como um empacotador.
Conforme, o Scrum oferece uma abordagem empírica, permitindo que membros de uma equipe trabalhem de forma independente e coesiva, dentro de um ambiente criativo.
Desta forma, este PDS reconhece a importância do aspecto social em ES.
Segundo o trabalho de Schwaber, em 2004, o processo em si é bastante rápido, adaptativo, e organizado, além de ser bastante diferente dos processos de software seqüenciais.
Em a verdade, o Scrum acredita que um software não deve ser desenvolvido como se fosse um produto manufaturado, ou seja, de uma forma repetitiva.
O coração e o esqueleto do Scrum Todas as práticas do Scrum são feitas dentro de um esqueleto de processo incremental e iterativo, Figura 2.4.
O ciclo mais abaixo representa uma iteração para as atividades em desenvolvimento que ocorre uma após a outra.
As saídas de cada iteração serão incrementos do produto.
Enquanto que, o ciclo mais acima representa a inspeção diária feita sobre a iteração, onde os membros da equipe são convidados a inspecionarem- se (uns aos outros), verificando suas atividades a fim de adaptar- las caso seja conveniente.
Uma iteração é direcionada através de uma lista de requisitos e este ciclo se repete enquanto o projeto for financiado.
Baseado neste conceito, o funcionamento do esqueleto do Scrum opera da seguinte maneira:
A o iniciar uma iteração, o time revê tudo o que deve ser feito.
Em seguida, o time seleciona as potenciais funcionalidades em que ele acredita que possam ser entregues até o final da iteração.
A partir de aí, o time utilizará o tempo restante da iteração para fazer as funcionalidades previstas.
A o final da iteração o time apresenta o incremento de funcionalidades que foi construído a partir de um stakeholder, que inspeciona o que foi feito e pode propor modificações no projeto.
Papéis do Scrum O Scrum implementa seu esqueleto iterativo e incremental através de três papéis:
Product Owner; O time (Team);
E o Scrum Master.
Todo o gerenciamento de responsabilidades de um projeto será dividido entre esses três papéis.
O Product Owner é responsável por representar os interesses de todos os participantes do projeto e do sistema resultante.
O Product Owner consegue o financiamento através do levantamento dos requisitos globais dos entregáveis.
A lista de requisitos é chamada de Product Backlog.
O Product Owner é responsável por utilizar a Product Backlog para garantir que um recurso mais necessário seja feito primeiro;
Isto é alcançado priorizando a lista de requisitos, freqüentemente, utilizando uma fila de funcionalidades por ordem de necessidade.
O Team é responsável por desenvolver as funcionalidades.
Os Teams são auto-gerenciáveis, auto-organizados, sendo responsáveis por descobrir como transformar a Product Backlog numa funcionalidade incremental dentro de a iteração, gerenciando o próprio tempo e trabalho.
Os membros de um Team possuem a responsabilidade coletiva do sucesso do projeto em cada iteração até completar- lo.
O Scrum Master é o responsável por o processo, por ensinar Scrum a todos os envolvidos no projeto e por implementar o Scrum de forma que se encaixe culturalmente na organização.
Fluxo do Scrum no Scrum, um projeto inicia com visão sistêmica, ou seja, uma visão global de todo o sistema a ser desenvolvido.
Esta visão poderá ser vaga inicialmente, mas será clareada a medida que o projeto for desenvolvido.
O Product Owner é responsável por o financiamento do projeto, visualizando uma maneira de maximizar o retorno do investimento.
Além disso, o Product Owner deve formular um plano para executar- lo, plano este que inclui a Product Backlog.
Todos os dias, o Team se reúne por quinze minutos (chamado de Daily Scrum), onde, todos os membros do Team respondem três perguntas:
O propósito da reunião diária é sincronizar os membros do Team.
Horas. Em esta reunião o Team mostra ao Product Owner (e os stakeholders envolvidos), o que foi desenvolvido durante o Sprint.
A idéia é decidir de forma colaborativa, o que o Team fará a mais preparados para o próximo Sprint.
Scrum. A cada 24 horas Daily Scrum Sprint Product Backlog Nova funcionalidade é demonstrada ao final do Sprint Product Backlog Selecionada Product Backlog:
Artefatos do Scrum· Product Backlog -- os requisitos do sistema ou produto, a ser desenvolvido através de um projeto são listados na Product Backlog.
O Product Owner é o responsável por o conteúdo, priorização e avaliação desta lista.
A Product Backlog nunca é completa e é utilizada para planejar as estimativas para os requisitos iniciais.
Esta lista é constantemente atualizada, de acordo com a mudança ou identificação de novos requisitos, além disso, enquanto durar o projeto, a Product Backlog também existirá.
Para visualizar a quantidade de trabalho através do tempo é utilizado um gráfico chamado brundown chart.
Este gráfico é bastante utilizado para verificar a quantidade de trabalho restante em determinado ponto no tempo, ou seja, é possível visualizar o progresso do projeto.
Product Backlog. O Team forma uma lista inicial das tarefas que serão feitas na segunda de trabalho que o Team planeja fazer durante o Sprint.
De acordo com, um metamodelo é um modelo que serve para modelar um outro modelo conceitual, ou seja, é uma forma de descrever como um modelo deve ser modelado.
Um metamodelo também pode ser utilizado para modelar metadados, assim como configuração de um software ou os metadados dos requisitos, por exemplo.
Metamodelos provêm mecanismos e soluções independentes de plataforma que especificam:·
a estrutura, sintaxe e semântica para ferramentas, frameworks ou tecnologias com metamodelos compartilhados;·
um modelo compartilhado para qualquer espécie de metadado;·
uma padronização de formatos para permitir troca de dados.
Em as próximas Seções serão apresentadas linguagens padrões de metamodelagem e modelagem utilizadas durante o trabalho.
Em a Seção 2.3.1 é apresentado o MetaObject Facility, que se promove como linguagem padrão de construção para construção de metamodelos, de a qual fizemos uso.
Mais adiante, na Seção 2.3.2, é apresentada a Unified Modeling Language.
MetaObject Facility A Object Management Group (OMG), através do MetaObject Facility (MOF), adotou um padrão que, provê um arcabouço para gerenciamento de metadados.
Além disso, o MOF contém um conjunto de serviços para o desenvolvimento e interoperabilidade de sistemas desenvolvidos a partir de Modelos da Unified Modeling Language (UML) e que utilizam metadados.
O MOF pode ser utilizado para especificar e integrar famílias de outros metamodelos, bastando utilizar o conceito de modelagem de classes.
Como exemplo, na Figura 2.6 é apresentado a definição da UML que é especificada a partir de o MOF v2.
Em esta figura também é possível verificar que o MOF utiliza de reflection para se auto definir.
A especificação do MOF é integrada e reusa o pacote Core do metamodelo da UML, provendo um arcabouço mais consistente para a utilização de Model Driven Architecture (MDA) 1.
Tal pacote é discutido em mais detalhes na Seção 2.3.2.
A MDA fundamenta- se na separação entre as especificações de um sistema e os detalhes de sua implementação onde, para isto, existe uma classificação das linguagens de acordo com o nível de abstração em que elas estão.
A MDA possui uma arquitetura que contempla quatro camadas (Figura 2.7) onde, cada abstração está situada numa das camadas que são chamadas de M0, M1, M2 e M3.
Em o nível mais abstrato (M3), encontra- se a meta-metalinguagem, neste caso, a própria linguagem se auto-define e descreve as metalinguagens.
O MOF é uma linguagem que possui artifícios que a torna capaz de se auto-definir.
Somente a partir de esta camada, as metalinguagens (M2) irão descrever as linguagens (M1), ou seja, o MOF irá descrever uma metalinguagem capaz de definir uma linguagem.
Contudo, as meta-metalinguagens, metalinguagens e linguagens estão nas camadas de meta metamodelos, metamodelos e modelos, da arquitetura do MOF, respecitivamente.
Em a última camada estão as instâncias do modelo.
Para maior facilidade de compreensão, a Figura 2.8 apresenta um exemplo de utilização dos mesmos níveis de abstração desenvolvidos na Figura 2.7 para a linguagem UML sendo que:
Em a camada M3 está o MOF;
Em a camada M2 está o metamodelo da UML criado a partir de o MOF;
Modelos baseados no MOF utilizam alguns conceitos para aumentar o reuso através de outros modelos e metamodelos.
Desta forma, diferentes tipos de metadados podem ser criados.
A especificação do MOF é dividida em dois pacotes principais que sugeram dois Pontos de Conformidade (Compliance Points) diferentes:
O Essential MOF (EMOF) e o Complete MOF (CMOF).
Isto foi feito para separar em pacotes as diferentes capacidades (ou propostas de metamodelagem) do MOF.
O MOF contém algumas funcionalidades que são necessárias para a metamodelagem.
Tais funcionalidades estão localizadas em pacotes diferentes que estão mesclados através de package merge entre os Pontos de Conformidade supracitados.
As funcionalidades são:·
Reflexion (pacote de reflexão), provê habilidade de se auto-definir;·
Identifiers (pacote de identificadores), provê um identificador único para cada elemento;·
Extension (pacote de extensão), significa estender elementos do modelo, tanto o nome, quanto os valores existentes.
A o se definir um metamodelo baseado em MOF pode- se utilizar diferentes níveis de formalismo, para:
Aumentar o nível de corretividade na descrição dos elementos da linguagem;
Diminuir ambiguidades e inconsistências;
Validar o metamodelo utilizando técnicas complementares;
E melhorar a legibilidade;
Como é bastante comum para especificação de linguagens, primeiramente pode- se definir a sintaxe da linguagem, para depois acrescentar suas semanticas (static semantics e dynamic semantics).
Em esse sentido, a sintaxe define os construtores da linguagem e como estes podem ser construídos a partir de outros construtores.
Já a semântica é definida da seguinte forma:
Static semantics, define como uma instâncias de construtorres devem estar conectadas para que exista algum sentido e geralmente são construídas a partir de regras de boa formação (wellformed rules) (ii) dynamic semantics, define o significado de um construtor desde que este esteja em seu estado correto (well-- formed).
Diante de isso, o MOF e seus metamodelos podem ser dotados de sintaxe e semântica.
Além disso, foi definida uma notação que funciona de forma idependente, sendo uma linguagem gráfica.
A partir de o mapeamento entre a notação para uma linguagem gráfica, definindo uma nova sintaxe (i.
e abstract syntax) pode- se obter uma sintaxe concreta (concrete syntax).
Embora existam esses níveis de formalismos, a descrição dos modelos e metamodelos formados a partir de o MOF não possuem uma especificação totalmente formal.
Unified Modeling Language Conforme, a Unified Modeling Language (UML) é uma linguagem padrão para projetar, visualizar, especificar, construir e documentar um Produto de Software O escopo da linguagem UML é muito abrangente e diversificado, cobrindo vários domínios em aplicações bem diferentes.
Nem sempre toda esta capacidade de modelagem é utilizada para todos os domínios.
Baseado neste contexto, a UML é dividida em diversos módulos que, podem ser selecionados de acordo com necessidade de utilização da linguagem.
Sendo assim, a UML v2 possui duas especificações que são complementares:·
Infrastructure, define os alicerces estruturais.·
Superstructure, define as estruturas necessárias para interação em nível de usuário.
Em a definição da UML existe um vocabulário e regras específicas que aumentam a facilidade de comunicação.
Isto foi feito por que a utilização de uma linguagem de modelagem é feita para aumentar o entendimento sobre o sistema.
No entanto, apenas um único modelo não foi suficiente para representar todo um sistema, sendo necessária a existência de vários modelos que estejam interconectados.
Portanto, a UML permite a utilização de diferentes visões de um mesmo sistema.
A UML dispõe de contêineres de abstrações visualizáveis na forma de diagramas.
Os diagramas servem para representar um mesmo sistema ou software sobre diversas perspectivas.
Para que isto seja possível, a UML dispõe de treze diferentes tipos de diagramas:
Diagrama de Classes;
Diagrama de Objetos;
Diagrama de Componentes;
Diagrama de Casos de Uso; Diagrama de Seqüência;
Diagrama de Colaboração;
Diagrama de Estados;
Diagrama de Atividades;
Diagrama de Implantação;
Diagrama de Pacotes;
Diagrama de Tempo;
Diagrama de Interação;
E Diagrama de Estrutura.
Como em qualquer linguagem, a UML possui uma série de regras para especificar como deve ser um modelo bem formado (well-- formed).
Estes tipos de modelos precisam ser semanticamente auto-contidos e estar em harmonia com modelos relacionados.
Tais regras são tanto sintáticas quanto semânticas a fim de definir:·
nomes, como devem ser os nomes das abstrações, dos relacionamentos e dos diagramas;·
escopo, o contexto em que estão os nomes, garantido sentido;·
visibilidade, como os nomes podem ser vistos e utilizados por outros;·
integridade, como as abstrações devem ser relacionadas;·
execução, execução ou simulação de um modelo dinâmico.
Além disso, para uma melhor organização e padronização, a UML possui quatro mecanismos que a fazem consistente:·
Specification, provê um pano de fundo que garante valor semântico para as construções feitas graficamente;·
Adornments, cada elemento da UML possui uma notação gráfica única, provendo representação visual;·
Common divisions, na modelagem de sistemas orientados a objetos, o mundo sempre é dividido em diferentes caminhos para se chegar a um mesmo destino;·
Extensibility mechanisms, para que a UML pudesse ser utilizada, representando um número maior de domínios específicos, foram definidos mecanismos de extensão:
­ stereotypes, estende o vocabulário da UML, permitindo a criação de novos blocos de construção para resolver um problema específico;
Diante de a possibilidade de restringir a UML para determinado domínio, foram criadas duas transformar- lo num modelo específico de plataforma (platform specific model -- PSM) (OMG, 2003 a).
A segunda estratégia é chamada de heavyweight extensibility mechanism, sendo o seu principal objetivo estender a UML adicionando novas metaclasses e outros metaconstrutores.
A seguir estão descritas a duas especificações da UML:
UML Infrastructure e UML Superstructure.
UML Infrastructure O metamodelo da UML é uma representação de linguagem dividida em diversos módulos, os quais constróem o pacote UML Core, também denominado por Infrastructure Library.
O principal objetivo deste pacote é ser reutilizado por diversos outros metamodelos como base para metamodelagem.
Como podemos ver na Figura 2.9, além de outras abordagens, o próprio MOF utiliza este pacote para definir sua família de metamodelos.
No entanto, o excesso de flexibilidade acaba por permitir a incompatibilidade entre duas ferramentas para modelagem UML distintas, que suportarem diferentes subconjuntos da linguagem.
Conseqüentemente, há algumas regras que exigem um balanço entre os módulos e a facilidade de troca de dados.
Entretanto, como a flexibilidade precisa ser mantida, UML provê o conceito de language units.
Uma language unit consiste numa coleção de conceitos de modelagem bem definidos que provêm o poder de representar aspectos de um sistema de acordo com um paradigma ou formalismo pré-determinado e escolhido.
Isto significa que um usuário somente precisa conhecer o subconjunto que julgar necessário de acordo com os modelos que irá utilizar.
Contudo, os grupos providos por os language units e os incrementos que se constituem, servem para simplificar a definição das regras de conformidade (compliance rules) da UML.
Isto é, o conjunto de conceitos do modelo da UML é particionado em camadas horizontais, chamadas de níveis de conformidade (compliance levels).
Cada ponto em que seja necessária alguma conformidade será chamado de ponto de complacência ou conformidade (compliance point).
Para facilitar a troca de modelos existem apenas dois níveis de conformidade definidos para a UML Infrastructure:·
Nível 0.
Este nível contém apenas uma language unit que provê os tipos de estruturas (todas class-based) necessárias para modelar as linguagens OO mais populares.
Portanto, existe um primeiro nível (nível de entrada) que permite a modelagem.
Contudo, esta camada serve como base para a existência de interoperabilidade entre diferentes categorias de ferramentas para modelagem.·
Metamodel Constructs (LM).
Este nível adiciona alguns language unit extras para obter estruturas (também class-based) mais avançadas.
Estas estruturas são utilizadas para a criação de metamodelos, assim como da própria UML (utilizando CMOF).
Em o modelo da Figura 2.10, UML é, originalmente, um pacote vazio que simplesmente estende (utilizado merge) o conteúdo do pacote Basic do UML Infrastructure.
Este pacote possui os conceitos mais elementares tais como Class, Package, DataType, Operation.
Em o nível LM, o conteúdo do pacote UML, mesclam (utilizam package merge) o pacote Constructs, Figura 2.11.
Como pode ser visto, o nível LM não se mescla (merge) explicitamente com o pacote Basic, pois essse já esta incorporado no pacote Constructs.
Arquitetura da UML Toda a especificação da UML é definida utilizando o metamodelo desenvolvido por a OMG.
Este metamodelo ajusta, ou melhor, acomoda as especificações formais e técnicas da UML.
Embora esta o metamodelo não apresente todas as formalidades da especificação rigorosamente, ele oferece vantagens por ser mais intuitivo.
A arquitetura da UML foi desenvolvida baseada em alguns princípios e padrões, sendo eles:·
Modularity -- O princípio básico de alta coesão e baixo acoplamento.
Este padrão é aplicado ao se determinar grupos e separar- los em pacotes, agrupando as características em metaclasses;·
Layering -- Layering é aplicado no metamodelo da UML de duas formas:
De o metamodelo das construções que as utilizam.·
Partitioning -- Utilizado para organizar os conceitos de uma mesma área, dentro de a mesma camada.
No caso de a biblioteca da Infrastructure, é utilizado um particionamento com granulação bastante fina, afim de provêr maior flexibilidade.
No caso de o metamodelo da UML, o particionamento é pouco granular, aumentando a coesão entre os elementos internos de um pacote e baixando o acoplamento entre eles.·
Extensibility -- A UML pode ser extendida de duas formas diferentes:
De o pacote Infra-- Struture Library, aumentando- a com as devidas metaclasses e metarelationships.
Em o primeiro caso é definido um novo dialeto da UML, no segundo, é definido um novo membro da família de linguagens baseadas na UML.·
Reuse -- Uma biblioteca de metamodelo flexível e com alta granularidade é fornecida desde que seja reutilizada para definir o metamodelo da UML, assim como outros metamodelos relacionados (como o Meta Object Facility).
UML Superstructure A UML Superstructure é a segunda parte de duas especificações complementares.
A primeira de elas (Infrastructure) (OMG, 2007 b) é o alicerce arquitetural para a Superstructure.
Essas duas especificações se constituem na especificação completa da UML 2.
A UML Superstructure não está dentro de o escopo deste trabalho.
O Software and System Process Engineering Metamodel (SPEM v2) (OMG, 2008 b) é um metamodelo para engenharia de PDSs assim como um arcabouço conceitual, provendo os conceitos necessários para modelar, documentar, apresentar, gerenciar, inter-mutabilidade e execução de métodos e processos de software.
Estrutura do Processo x Conteúdo O SPEM v2 separa a engenharia do processo em dois momentos principais:
Criação de uma biblioteca (Method Library), que armazenará o conteúdo (Method Content) e sua utilização num PDS (Method Structure), Figura 2.12.
Method content é tudo aquilo que provê explicações passo- a- passo, descrevendo como os objetivos serão alcançados independente ciclo de desenvolvimento.
Em esse sentido, um PDS fará uso dos elementos que formam o Method Content configurando- os para uma execução específica.
Desta forma, o SPEM v2 descreve estruturas necessárias para expressar formalmente o domínio de PDS.
Além disso, seu metamodelo foi definido através do MOF v2, que é uma meta linguagem de modelagem padrão definida por a OMG, neste caso, um meta-metamodelo.
Definição do metamodelo Para a definição do SPEM v2 foi utilizado o MOF.
A partir de o MOF é possível definir novas metalinguagens, criando novos construtores.
De a mesma forma, a UML também foi definida com a utilização de MOF.
Mas, partindo desse princípio, quem define o MOF?
Como o MOF possui operações de reflection, ele pode ser auto-definir, criando o seu próprio metamodelo.
Este conceito é chamado de bootstrapping, onde o próprio MOF utiliza a UML, linguagem que ele próprio define, como ponto de início.
A Figura 2.13 apresenta o uso do MOF v2 e da UML v2 para a modelagem e utilização do SPEM v2.
Como pode ser observado, a Figura define dois instantes:
A e b.
Em a está a modelagem e definição do SPEM v2 mostrado numa arquitetura de três camadas, utilizando o MOF.
Em a camada M3 está o MOF v2 que é instanciado por a camada M2 para definir o metamodelo da UML v2 e do SPEM v2, mesma camada em que o metamodelo do SPEM v2 estende o metamodelo da UML v2.
Finalmente, na camada M1 está uma instância de M2, mostrando a definição da Method Library a partir de dois pontos diferentes, metamodelo do definidos especialmente para o este domínio.
Definição dos Pacotes No tocante a o metamodelo, o SPEM v2 foi estruturado em sete pacotes principais, Figura Os pacotes apresentados na Figura 2.14 são abaixo descritos:·
Process Behaviour -- pacote que permite uma extensão do metamodelo do SPEM v2 para que a execução de um processo possa ser acompanhada.·
Managed Content -- pacote que adiciona conceitos para documentação e descrição textual.·
Method Content -- pacote que permite que os usuários do SPEM v2 criem uma biblioteca com conhecimento reutilizável e independente de processos para uso posterior.
Structure com seus conteúdos, definidos por o pacote Method Content.·
Method Plugin -- pacote que define os conceitos necessários para criar, gerenciar e manter bibliotecas e PDSs.
Pontos de Conformidade Segundo a sua especificação, o SPEM v2 é definido a partir de três pontos de conformidade:
SPEM Complete O SPEM Complete compreende todos os sete pacotes do metamodelo do SPEM v2, descritos em 2.4.3.
Este Ponto de Conformidade é recomendado para aqueles que desejam utilizar todo o metamodelo e suas capacidades.
Em a Figura 2.15 é apresentado um espaço de nomes e os pacotes Method Plugin, Process Behavior, compondo através de transitividade todos os outros pacotes do SPEM v2.
Audiência: Fornecedores em larga escala de ferramentas para bibliotecas de PDSs e conteúdos.
De o SPEM v2, descritos em 2.4.3.
Em a Figura 2.16 é apresentado um espaço de nomes chamado SPEM2-Process-Behavior-Content, o qual utiliza- se de package merge para compor:
O LM, um nível de conformidade definido por a UML 2 Infrastructure Library, descrita em 2.3.2;
e os pacotes Managed Content e Process Behavior do SPEM v2, que por transitividade compõem também os pacotes Process Structure e Core.
Audiência: Fornecedores de ferramentas com foco em compatibilidade com o SPEM v1.
X e modelagem.
SPEM Method Content O SPEM Complete compreende todos os três pacotes do metamodelo do SPEM v2, descritos em 2.4.3.
Este Ponto de Conformidade é recomendado para aqueles que desejam utilizar todo o metamodelo e suas capacidades.
Em a Figura 2.17 é apresentado um espaço de nomes chamado SPEM2-Method-Content, o qual utiliza- se de package merge para compor:
O LM, um nível de conformidade definido por a UML 2 Infrastructure Library, descrita em 2.3.2;
e o pacote Method Content, compondo através de transitividade os pacotes Managed Content e Core do SPEM v2.
Audiência: Fornecedores de bases de conhecimento organizacional e responsáveis por documentação.
3 Trabalhos Relacionados Em esta seção apresentamos os principais trabalhos relacionados à construção de ASs.
Nosso objetivo foi analisar a literatura atual e observar se autoria de As tem sido objeto de pesquisa na comunidade da Engenharia de Software.
Porém, chegou- se a conclusão que os trabalhos mais recentes não possuem foco em Autoria de ASs, divergindo para outros fins.
Portanto, como o principal interesse desta pesquisa está relacionado à identificação das necessidades e soluções para a especificação e construção de uma Autoria de ASs, foram analisados os trabalhos que mais contribuíram com nossa abordagem.
Tais trabalhos são divididos nas Seções artefatos de software e 3.2, que demonstra a comparação com trabalhos que procuraram utilizar metamodelagem como meio da abordagem.
Em esta Seção, a análise comparativa das abordagens é baseada nos critérios de Autoria, Representação, Capacidades e Avaliação ou Testes.
Além disso, cada abordagem será apresentada conforme sua descrição e relação com o trabalho aqui proposto.
Em o que se constitui a Autoria, analisamos como as abordagens atacam os problemas em autoria de ASs em si.
Desta forma, definidos os atributos:· (
A) Paradigma de construção, como a abordagem trata os artefatos?
Artefatos são vistos como uma união de fragmentos de informação?
Artefatos possuem estrutura lógica?· (
B) Guia de construção, existe algum diagrama com fluxos?
Se sim, quais são os passos necessárias para se realizar a construção ou classificação dos artefatos?· (
C) Escopo da abordagem, a abordagem permite a construção de que tipos de artefatos?· (
D) Separação de Conteúdo, há uma clara divisão entre a estrutura do processo (Process Structure) e o seu conteúdo (Method Content)?
Em relação a Representação, verificamos como as abordagens atacam os problemas em autoria de ASs no tocante a utilização ou criação de uma linguagem própria.
Baseados em, analisamos os atributos:
No tocante a análise das capacidades existentes na autoria de ASs, verificamos conceitos ligados a categorização, manuseio e extensibilidade de cada uma das abordagens.
Os atributos utilizados foram:·
Extensibilidade, a abordagem admite ou possui pontos de extensibilidade, para posterior melhoria ou acréscimo de funcionalidades?·
Classificação, a abordagem permite que os artefatos sejam classificados ou categorizados de acordo com seus conteúdos?·
Controle de Versões, na abordagem é possível criar diferentes versões de um mesmo artefato?
A abordagem permite o retorno a uma versão anterior de um artefato sem perder as alterações mais atuais?·
Controle de Maturidade, a abordagem dispõe algum mecanismo que permita definir o nível de maturidade de artefatos?
Finalmente, verificamos como as abordagens são validadas, verificadas ou quais avaliações foram feitas por os autores dos trabalhos analisados.
Partindo deste princípio, tomamos por base os atributos:·
Instanciação, a abordagem foi instanciada através de exemplos?
Foram feitas comparações analíticas com base na utilização da abordagem?
Existe alguma validação científica, assim como estudo de caso real ou experimentos?·
Implementação, a abordagem foi implementada, existe alguma implementação padrão para utilização e testes?·
Ferramental ou Protótipo, foi desenvolvida alguma implementação específica?
A abordagem foi consolidada em forma de ferramenta?
Existe algum protótipo que automatize a utilização da proposta?
Abordagem Akpotsui, 1992 Esta abordagem considera que documentos são estruturas lógicas, também podem ser vistos como árvores estruturadas, feitas a partir de elementos que tornam a estrutura capaz de representar organização.
Descrição: Através de um modelo de estrutura, cada documento possui uma estrutura bem específica, derivada da estrutura genérica.
Como cada nó possui um tipo, para a estrutura genérica existe um conjunto de tipos T construídos a partir de um conjunto básico de tipos e Autoria:
Esta abordagem é bastante complexa e trabalha com o paradigma de documentos com boa formação, sendo esta logicamente estruturada.
Infelizmente ela não traz um guia que explique como fazer a autoria e seu escopo é limitado apenas a documentos.
Como o foco desta abordagem não está em formação de ASs, ela também não compreende separação entre estrutura e conteúdo de PDSs.
Representação: Esta abordagem se constitui de três níveis de representação.
Inicialmente é apresentada a descrição semântica dos elementos a serem modelados.
Depois disso, é utilizada uma linguagem abstrata simples de visualização em árvore, baseada na linguagem concreta baseada em XML, juntamente com a definição de um DTD, possuindo também regras de boa formação baseadas na teoria de conjuntos.
Capacidades: A abordagem não apresenta nenhuma das capacidades analisadas.
Validação ou Testes:
Em esta abordagem não foi encontrada nenhuma consideração sobre qualquer avaliação ou testes.
Relação com a abordagem proposta:
Esta abordagem não considera autoria de ASs, mas a criação e edição de documentos sob uma conceitualização de suas estruturas internas.
A abordagem também não apresenta categorização, versionamento ou controle de maturidade, os quais pertencem ao escopo de edição de documentos.
Embora possua boa representação, este trabalho não demonstra qualquer preocupação com a criação de pontos de extensão.
Além disso, não é apresentada qualquer diferenciação entre a definição, uso e instância do documento.
Abordagem Buchner, 2000 Esta abordagem consiste na construção de um arcabouço para Documentos Compostos (Compounding Documents) chamado HotDoc, que permite a construção de documentos que não possuam somente texto, mas sejam flexívels a partir de partes dinâmicas, como tabelas, figuras, diagramas, gráficos, sons e vídeos.
Descrição: Cada documento é dividido em partes de diferentes tipos que podem ser aninha- das até formarem uma árvore.
Desta forma, as partes podem compartilhar mesmo modelo de dados através de ligações entre si, desde que as ligações sejam entre modelos compatíveis.
Autoria: Esta abordagem adiciona funcionalidades para a autoria de documentos, permitindo que o autor combine diferentes partes do documento.
Seu principal objetivo foi detectar a mudança de paradigma na construção de documentos.
Esta abordagem não apresenta um guia que explique como fazer a autoria e seu escopo é limitado apenas a documentos.
Além disso, não é apresentada separação entre estrutura e conteúdo de PDSs.
Representação: Em nossas análises não detectamos nenhum tipo de representação ou modelo.
Entretanto, algumas regras de formação são brevemente comentadas, mas sem nenhuma formalidade ou linguagem específica.
Capacidades: A abordagem não apresenta nenhuma das capacidades analisadas.
Validação ou Testes:
Esta abordagem consiste numa ferramenta implementada a partir de um arcabouço para Documentos Compostos.
O HotDoc foi implementado utilizando o padrão arquitetural Model-View--Controller (MVC) para VisualWorks Smalltalk.
A ferramenta permite que documentos possam ser construídos a partir de a inserção de novas partes num tipo de área de trabalho de usuário (workspace).
A interface com usuário permite o uso de objetos reposicionáveis e redimensionáveis, juntamente com a funcionalidade drag and drop.
Relação com a abordagem proposta:
Esta abordagem possibilita a criação de documentos baseando- se na montagem do mesmo por estruturas internas, tais documentos conhecidos como documentos compostos (compounding documents).
Esta abordagem não foi desenvolvida especificamente para autoria de ASs, entretanto, abrange a montagem de documentos, ou seja, determina um escopo menor.
Sobre questões de gerenciamento ou controle, não há qualquer referência sobre classificação, maturidade e versionamento.
Além disso, nenhuma representação ou conceitualização foi apresentada e embora seja um arcabouço, não foram apresentados pontos de extensão.
Finalmente, não foi identificado qualquer suporte para diferenciação entre a definição do documento, seu uso e sua instância.
Abordagem Cattaneo, 2000 Esta abordagem visa a permitir que documentos possam ser estruturados com base numa definição de XML.
Descrição: Pensando na estruturação de artefatos, os autores definiram um gerenciador de artefatos baseado na Web chamado Labyrinth.
Esta ferramenta permite a definição de artefatos através de XML Schema (XSD).
Autoria: Esta abordagem apresenta autoria com estruturação de artefatos e permite que o conteúdo esteja separado da definição.
Além disso, esta solução possui escopo em artefatos, mas não contempla nenhuma espécie de guia ou fluxo de autoria.
Representação: A solução abordada no trabalho destes autores apresenta uma definição de artefatos baseada em XSD e o protótipo foi modelado sobre diagrama Entidade Relacionamento (Er).
Entretanto, não há qualquer explicação sobre o XSD e o modelo Er apresentado e não é possível concluir que exista alguma semântica bem definida.
As linguagens utilizadas, por si só já possuem sintaxe e notação.
Capacidades: A abordagem não apresenta nenhuma das capacidades analisadas.
Validação ou Testes:
Para verificação foi desenvolvido um protótipo para Web e alguns exemplos de utilização são apresentados.
O protótipo apresenta como características navegação e preenchimento de documentos, controle de incosistências e sistema de notificações, que avisa quando um artefato foi modificado.
Relação com a abordagem proposta:
Conforme os autores, este trabalho possibilita a criação de documentos compostos, baseando- se na montagem dos mesmos a partir de outras estruturas.
Assim como em, esta abordagem não foi desenvolvida especificamente para autoria de ASs, e seu escopo se reduz à montagem de documentos.
Além disso, não há formas de efetuar classificação, maturidade ou versionamento e nenhum ponto de extensão foi apresentado.
Por fim, esta abordagem não diferência entre definição, uso e instância.
Abordagem Herzner &amp; Hocevar, 1991 Esta abordagem apresenta um Banco de Dados Orientado a Objetos que permite a gerência de documentos.
Descrição: Nomeada como Compound Document access and Management (CDAM) esta abordagem provê um tratamento de documentos de forma a se tornarem coleções de partes ou componentes, formando uma agregação de pedaços de informações estruturadas com a propriedade de se auto definir.
Autoria: Em o contexto de autoria, esta abordagem apresenta uma construção de documentos sob o mesmo paradigma apresentado em, mas da mesma forma, não apresenta um guia explicativo para autoria e seu escopo também é sob documentos.
Além disso, não é apresentada separação entre estrutura e conteúdo de PDSs.
Representação: Em esta abordagem pode ser vista uma descrição semântica dos conceitos utilizados para autoria de documentos, utilizando linguagem natural.
Nenhuma outra forma de representação foi encontrada.
Capacidades: A abordagem não apresenta nenhuma das capacidades analisadas.
Validação ou Testes:
Não é definida nenhuma validação mas sim uma verificação através do uso de um protótipo implementado sobre um sistema de nome CDAM.
Tal sistema foi desenvolvimento seguindo os seguintes passos:
Inicialmente foi projetado um modelo, este modelo foi mapeado para um ambiente de banco de dados orientado a objetos e deste ambiente, foi criado um banco de dados relacional;
E que consiste num Bancos de Dados Relacional, um Sistema de Banco de Dados Orientado a Objetos, uma API geral de controle e uma API para suporte a métodos.
O Banco de dados Orientado a Objetos possui as seguintes tabelas que contém todas as informações:
Structure_ class:
Representa as partes;
Structure_ instance:
Representa as instancias;
TYPE_ CLASSES:
Representa os tipos de dados pré-definidos;
Data: Representa os tipos de dados elementares.
Relação com a abordagem proposta:
Conforme os autores, este trabalho possibilita a criação de documentos estruturados, baseando- se na montagem dos mesmos a partir de outras estruturas definidas num documento XSD.
Assim como em alguns trabalhos anteriores, esta abordagem não foi desenvolvida especificamente para autoria de ASs, e seu escopo se reduz à montagem de documentos.
Além disso, não há formas de efetuar classificação, maturidade ou versionamento e nenhum ponto de extensão foi apresentado.
Abordagem Laitinen, 1992 Esta abordagem possui um foco em classificação de artefatos produzidos num projeto, numa tentativa de controlar- los e gerenciar- los uniformemente.
Descrição: O autor dessa proposta sugere uma nomenclatura com base em uma classificação gerencial d documentação, que segue:
Software Description, Utilization Documents, Development Plans, Quality Control Documents and Administrative Documents.
Autoria: Diferente das abordagens anteriores, este trabalho não consiste em autoria de artefatos.
Seu foco é apenas em documentos no paradigma padrão.
Entretanto, é apresentado um guia resumido para utilização da abordagem, a partir de um arcabouço de classificação.
Representação: Em esta abordagem existe uma breve descrição semântica dos conceitos utilizados para classificação dos documentos, utilizando linguagem natural e uma tabela demonstrativa.
Nenhuma outra forma de representação foi encontrada.
Capacidades: De entre as capacidades analisadas, esta abordagem demonstra classificação de artefatos do tipo documentos.
Validação ou Testes:
O trabalho não apresenta nenhuma implementação, teste ou aplicação.
Relação com a abordagem proposta:
Como o foco desta abordagem é apenas classificar documentos produzidos durante a execução de um PDS, a única relação que pode- se fazer é conforme classificação.
A abordagem proposta possui classificação para um escopo maior, no caso artefatos, enquanto esta abordagem apresenta apenas classificação para documentos.
Por fim, não é apresentada qualquer validação, verificação ou teste.
Abordagem Tilley&amp; Müller, 1991 Esta abordagem se constitui num facilitador para a documentação de artefatos do tipo código-fonte.
Segundo o próprio autor, sem uma boa documentação, o único meio de entender o código-fonte é analisando- o e mesmo que o código esteja bem documentado, muitas vezes está fora de o padrão utilizado por a companhia ou incompleto.
Descrição: O autor sugere uma ferramenta que age como um facilitador em hipertexto que permite anotar documentos de forma não intrusiva, o INFO.
A documentação e todos os comentários pertinentes são persistidos num arquivo texto, enquanto isso são utilizadas tags que correspondem as chamadas das informações contidas no código-fonte.
Autoria: O contexto desta abordagem é bastante específico, servindo apenas para determinar documentação de código-fonte.
Portanto, esta abordagem não apresenta nenhuma característica para autoria de artefatos.
Entretanto, o próprio autor demonstra como editar os documentos para acrescentar as tags previstas por a abordagem.
Representação: Esta abordagem apresenta uma linguagem de anotações baseada em tags, devendo possuir sintaxe e semântica.
Entretanto, existem apenas alguns exemplos de utilização e não é possível inferir que a semântica, embora exista, esteja bem definida.
Mesmo assim, algumas regras de formação são especificadas.
Capacidades: A abordagem não apresenta nenhuma das capacidades analisadas.
Validação ou Testes:
Houve a implementação do conceito e o próprio autor demontra exemplos de utilização e aplicação da abordagem, conforme dados sobre a experiência do usuário.
No tocante a ferramenta, o autor a julga desnecessária.
Relação com a abordagem proposta:
Esta abordagem apresenta um diferencial em relação as propostas anteriores, pois trabalha com artefato do tipo código-fonte.
Embora o foco não seja estrutura, o autor apresenta uma maneira de documentação diferente das abordagens utilizadas na indústria.
Além disso, esta abordagem não se trata de autoria, mas sim da criação de uma metalinguagem.
Em esse contexto, não foi possível encontrar os níveis esperados de formalismo no tocante a descrição e especificação da linguagem.
Por fim, não é possível concluir que exista alguma ferramenta específica ou protótipo para a utilização da abordagem.
Abordagem Visconti &amp; Cook, 1993 Esta abordagem identifica um meio de melhorar processos de desenvolvimento de software por meio de a definição de níveis de maturidade para a documentação.
Descrição: A abordagem dos autores identifica um meio de melhorar o processo e definir quatro níveis de maturidade para a documentação do mesmo:
Ad-hoc, inconsistente, definido e controlado.
Cada nível é descrito por os seguintes campos:
Nome, descrição simples, palavraschaves, principais áreas do processo, principais práticas, principais indicadores, principais desafios e principais significados.
Autoria: Assim como, esta abordagem não consiste em autoria de artefatos e seu foco é apenas em documentos.
Além disso, é apresentado um guia resumido para utilização da abordagem, a partir de um arcabouço conceitual para definição de níveis de maturidade.
Representação: Em esta abordagem é apresentada uma descrição semântica dos termos utilizados para definir os níveis de maturidade dos documentos, utilizando linguagem natural e uma tabela demonstrativa.
Nenhuma outra forma de representação foi encontrada.
Capacidades: De entre as capacidades analisadas, esta abordagem demonstra apenas a maturidade de artefatos do documentos.
Validação ou Testes:
O trabalho não apresenta nenhuma implementação, teste ou aplicação.
Relação com a abordagem proposta:
Como o foco desta abordagem é apenas definir níveis de maturidade em documentos produzidos durante a execução de um PDS, única relação que pode- se fazer é conforme maturidade.
Esta abordagem proposta define níveis maturidade para um escopo menor, ou seja, apenas para documentos.
Em esta Seção, a análise comparativa das abordagens é baseada nos critérios de Tipo de Extensão da UML, Níveis de formalismo da Linguagem, Modificações feitas no metamodelo UML, Tipos de Modelos existentes e Validação ou Testes.
Além disso, cada abordagem será apresentada conforme sua descrição e relação com o trabalho aqui proposto.
Em o que se constitui ao Tipo de Extensão da UML, analisamos como as abordagens criam seus metamodelos em relação a o mecanismo de extensão da UML, podendo ser do tipo:·
heavyweight extensibility mechanism, durante a extensão foram criados novos constructors?
Houve alteração ou remoção de constructors já existentes no metamodelo da UML?
Expressar algum domínio específico?
Em relação a Níveis de formalismo da Linguagem, verificamos como as abordagens formalizam seus metamodelos nos seguintes níveis de linguagem:·
Semântica Estática, existe alguma descrição semântica para utilizar os contrutores do metamodelo?·
Semântica Dinâmica, é definido algum modo de identificar se os construtores possuem algum sentido?
Existe alguma descrição dos construtores?·
Sintaxe Abstrata, o metamodelo possui alguma notação para faciliar seu uso?
Existe alguma forma visual de representação gráfica?·
Sintaxe Concreta, a linguagem pode ser representada formalmente?
Existe alguma representação em XML ou XMI por exemplo?·
Regras de boa formação, a linguagem traz com si regras que definem a boa construção da abordagem?
Existem regras para auxiliar o entendimento?
No tocante a Modificações feitas no metamodelo UML, analisamos o que foi feito para que o metamodelo estendesse a UML a partir de o MOF, sendo possível:·
remover construtores existentes para evitar alguma má construção que esteja ocorrendo;·
adicionar algum construtor, diante de alguma herança ou relacionamento para aumentar a especialidade da linguagem;·
alterar construtores existentes, melhorando e tornando o metamodelo mais específico.
Finalmente, verificamos como as abordagens são validadas ou quais avaliações são feitas por os autores dos trabalhos analisados.
Partindo deste princípio, tomamos por base os atributos:·
Instanciação, utilização da abordagem a partir de ferramentas externas ou sem apoio computacional;·
Implementação, implementação da abordagem em alguma linguagem computacional ou implementação de processo de utilização não computacional;·
Ferramental ou Protótipo, implementação da abordagem criando alguma ferramenta ou protótipo.
Abordagem Descrição: Esta abordagem consiste na definição e modelagem de um Processo de Software, utilizando UML como linguagem de modelagem.
Por se tratar de uma definição, os autores percorrem muitos conceitos de Orientação a Objetos e Processos de Software, formando a conceitualização de Processo como um Objeto.
Segundo os autores, tal contribuição permite o uso de ferramentas para automatizar a execução do Processo.
Tipo de Extensão da UML:
Segundo nossas análises, para a conclusão desta abordagem não foi feita nenhuma extensão da UML.
Níveis de formalismo da Linguagem:
Em este caso, por não se tratar de uma especialização da UML, não fica explícita a criação de uma linguagem própria.
Entretanto, é definido um domínio com características próprias a partir de os diagramas UML.
Tipos de Modelos existentes:
Em esta abordagem á apresentada apenas um nível de modelagem.
O modelo conceitual criado para modelar Processos de Software é um modelo de nível de usuário, que utiliza- se da própria UML.
Validação ou Testes:
Os autores deste trabalho não apresentam nenhuma implementação ou ferramenta capaz de automatizar a utilização da abordagem.
Também não foi encontrada nenhuma verificação, qualquer tipo de teste ou experimento.
Ao invés de isto, é apresentado um estudo de caso vinculado a um exemplo, não sendo um estudo de caso real.
Relação com a abordagem proposta:
Os autores trazem um trabalho de modelagem de PDSs utilizando paralelamente a definição de objetos, assim como nossa abordagem, que se constitui na modelagem de Artefatos de PDSs utilizando Orientação a Objetos.
Além disso, em nossa abordagem utilizamos os níveis de formalismo de linguagem abstrata e concreta e também apresentamos regras de boa formação e descrições semânticas.
Outro ponto bastante relevante é sobre a representatividade do modelo, uma vez que os autores dessa abordagem utilizam apenas um modelo de usuário UML.
Abordagem Descrição: Esta abordagem trabalha com a modelagem e metamodelagem dos conceitos de política de acesso a tarefas (task assignment policy) de Processos de Software.
Em este trabalho foram explorados os recursos possíveis de executar tarefas diversas, com base em política de acesso conforme três aspectos:
Organização, com foco sobre papéis organizacionais, assim como Gerente de Projetos e Gerente de Configuração;
Processo, com foco em algumas fases do ciclo de vida, hierarquia de atividades e os papéis executores;
E produto, no intuito de policiar artefatos de entrada e/ ou saída, além de controlar os papéis responsáveis por tais artefatos.
Tipo de Extensão da UML:
A UML foi especializada utilizando- se o mecanismo extensão heavyweight, caracterizando- se como uma modificação direta em seu metamodelo.
Segundo os autores, tal alteração é bastante sensível e não altera o comportamento inicial da UML.
Ao invés de isso, esta abordagem apenas adiciona novos construtores de linguagem, tornando este trabalho flexível e com três níveis de modelo:
Meta, conceitual e de instância.
Níveis de formalismo da Linguagem:
Quanto a os níveis de formalismo, este trabalho traz uma metalinguagem baseada em MOF e que estende UML, trazendo com si notação gráfica.
Entretanto, outros níveis de formalismo não foram encontrados.
Tipos de Modelos existentes:
São utilizados três diferentes tipos de modelos:
Meta, que consiste nos conceitos utilizados para criar metalinguagem;
Conceitual, definido por o meta;
Validação ou Testes:
No tocante a validação, este trabalho traz uma implementação feita através de softwares de geração de código.
Além disso, mostra uma instância da abordagem utilizando modelos em diagramas UML e exemplos.
Entretanto, nenhuma ferramenta é apresentada e não foram feitos estudos de caso ou experimentos para testar as funcionalidades, além disso, não há exemplos analíticos ou comparativos com casos reais e atuais.
Relação com a abordagem proposta:
Os autores desta abordagem utilizaram a extensão da UML, criando um metamodelo para permitir a modelagem de política de acesso em atividades e artefatos num PDS.
Em comparação com nosso trabalho, esta abordagem foi feita a partir de o mecanismo heavyweight de extensão da UML, enquanto nossa abordagem utiliza ambos os mecanismos de extensão.
Outro ponto de comparação é em relação a a falta de definição da semântica e regras de boa formação.
Além disso, os autores não trazem nenhuma ferramenta.
Abordagem Descrição: Baseados no fato de UML ser altamente aceita como linguagem de representação de Softwares, os autores desta abordagem propõem um metamodelo que estende a UML para permitir representação de domínio do estilo arquitetural específico.
Como os próprios autores se reservam a afirmar, esta abordagem é bem menos ambiciosa, por se limitar aos conceitos de uma única linguagem específica de arquitetura.
Tipo de Extensão da UML:
Esta abordagem utiliza- se do mecanismo de extensão da UML, adicionando novos metaconstrutores e criando uma nova metalinguagem para definir e prover modelagem arquitetural de software.
Segundo os autores, a utilização de estereótipos não seria suficiente para representar os elementos arquiteturais.
Níveis de formalismo da Linguagem:
Esta abordagem só não apresenta a linguagem de representação concreta.
Em este caso, tanto as regras de boa formação quanto uma linguagem abstrata devem estar presentes, além de as especificações semânticas.
Tipos de Modelos existentes:
Apresenta apenas o metamodelo e não dispõe de exemplos.
Validação ou Testes:
Os autores não apresentam nenhuma validação ou teste.
Relação com a abordagem proposta:
Em este trabalho foi desenvolvido um metamodelo para noção de Arquitetura de Software de acordo com o estilo C3.
Tal abordagem foi desenvolvida utilizando o mecanismo heavyweight de extensão da UML.
Assim como nossa abordagem, este trabalho também apresenta descrição semântica dos construtores da linguagem e uma linguagem abstrata, porém não descreve nenhuma linguagem concreta.
Os autores não mostram nenhum modelo de instância ou mesmo o modelo conceitual criado a partir de o metamodelo constituído.
Por fim, não é apresentada nenhuma implementação, teste, ou ferramenta.
Abordagem Descrição: Esta abordagem apresenta uma solução de modelo para os elementos que constituem a disciplina de Engenharia de Software.
Os autores utilizaram UML para modelar sua especificação, desde o metamodelo até a instância real da Engenharia de Software.
Estes modelos identificam os níveis de abstração da disciplina, desde seus pilares filosóficos, caindo por fim, na Engenharia de Software.
Desta forma, neste trabalho a Engenharia de Software é uma especialização da Engenharia, que possui seus fundamentos na Ciência, que por sua vez se baseia na filosofia.
Tipo de Extensão da UML:
Embora esta abordagem utilize- se de UML para construir os modelos, definindo vários domínios específicos, não há clara evidência de extensão da UML.
Níveis de formalismo da Linguagem:
Por não se tratar de uma especialização da UML, a linguagem descrita por os autores é apresentada como um modelo UML definido por os diagramas.
Embora existam os níveis de modelagem previstos para os diferentes aspectos da disciplina de Engenharia de Software, não foi possível identificar como as ligações de instância desses modelos foram restringidas.
Em outras palavras, não foi apresentado de forma clara como a Engenharia de Software pode ser uma instância da Ciência.
Tipos de Modelos existentes:
Embora não tenham sido identificados como modelos de definição de outros modelos, mas sim diferentes modelos de usuário da UML sem ligação entre si, aparentemente eles se constituem em metamodelo (Filosofia), modelo conceitual e (Ciência) e instância (Engenharia e Engenharia de Software).
Validação ou Testes:
Esta abordagem apresenta um exemplo para utilização de diferentes modelos chamados:
Functional Solution Model, Technical Problem Model e Technical Solution Models.
Estes modelos foram implementados em linguagem Java, com o banco de dados e seu acesso gerado em linguagem DDL e interface gráfica em Html, tudo isto utilizando geradores de código.
Em termos de validação ou testes, esta abordagem apresenta um exemplo de utilização de um Projeto European Institute, que se compromete em suportar processos de negócio entre os Estados-Membros Europeus e a European Commission.
Relação com a abordagem proposta:
Este trabalho não utiliza o MOF para criação de uma meta-linguagem, pois utiliza a própria UML para definir vários níveis de modelos que se instanciam entre si.
Em este trabalho também é apresentado implementação, porém nenhuma realização de ferramenta específica ou protótipo foi encontrado.
Os critérios de comparação da Figura 3.1 foram definidos anteriormente na Seção 3.1.
A partir de a Figura 3.1 observa- se que:
Linguagem Abordagem Autoria Documento Artefato Testes Documento Akpotsui1992 Características Documento Buchner2000 Cattaneo2000 Herzner1991 Laitinen1992 Visconti1993 Nossa Abord.
A -- Paradigma de construção.
B -- Guia de Etapas da construção.
C -- Escopo da abordagem (S -- Contempla Documentos Compostos, N -- Paradigma Tradicional).
D -- Separação de Conteúdo Código-Fonte X Artefato X N X Documento IV Inst_ Impl_ Prot.·
Linguagem: Os níveis de formalismos de todas das abordagens analisadas são incompletas.
Apenas possui semântica estática e de todas, a mais completa é, que traz com si os outros níveis de formalismo exigidos.
Além disso, apenas em duas abordagens, das sete analisadas, existe notação e linguagem concreta.·
Autoria: Em o que se diz respeito a autoria, a grande maioria das abordagens (cinco) possuem foco apenas em artefatos do tipo documentos, apenas uma em artefatos do tipo código-fonte, e apenas uma outra compreende artefatos em geral.
Como pôde ser visto, das abordagens analisadas, apenas os trabalhos de e trouxeram evidências no tocante a existência de um Guia para a construção.
Por fim, a separação de conteúdo não aparenta ser algo muito popular de entre as abordagens, entretanto, os paradigmas de construção de artefatos fica bastante dividido.·
Características: De entre as características analisadas, foi observado que poucas ou nenhuma das abordagens corresponderam ao esperado.
Nenhuma das abordagens implementa ou sugere algum tipo de mecanismo para permitir extensibilidade da proposta e controle de versões dos artefatos.·
Testes: Nenhuma da abordagens analisadas faz uso ou algum tipo de testes de instância, entretanto, a grande maioria utiliza- se de protótipos ou ferramentas computacionais.
Resultado: Metamodelagem Os critérios de comparação da Figura 3.2 foram definidos anteriormente na Seção 3.3.2.
A partir de a Figura 3.2 observa- se que:·
Mecanismo de extensão da UML:
Entre as abordagens analisadas, apenas e fazem extensão da UML.
Tal extensão utiliza o mecanismo heavyweight, que como pode ser visto na Seção 2.3.2, caracteriza- se por adicionar ou alterar construtores da linguagem, conforme a necessidade de restrições.·
Linguagem: No que se refere aos níveis de formalismo, apenas implementa o valor semântico de sua linguagem por completo, juntamente com regras de boa formação, o que não ocorre nas outras abordagens.
Entretanto, todos os trabalhos analisados utilizam notação em linguagem abstrata, porém, apenas dispõe de uma linguagem concreta.·
Modificações feitas sobre UML:
Como pode ser observado, apenas as abordagens e alteram o metamodelo da UML, adicionando construtores a linguagem.
Porém, os próprios autores advertem que preferiram não alterar a UML numa tentativa de tornar suas linguagens mais independentes.·
Tipos de modelos utilizados:
Para os tipos de modelos, foi analisada a existência de metamodelo e sua instância.
De os trabalhos analisados apenas não dispõe de metamodelo e apenas não continha um modelo conceitual que instanciasse o metamodelo proposto.·
Testes: Embora e tenham proposto implementação e uso de suas abordagens, seus trabalhos não apresentam nenhuma ferramenta ou mesmo um protótipo.
Os outros trabalhos não apresentam nenhuma validação, verificação, formas de uso ou testes.
Extensão Abordagem Linguagem Lee2002 Mart' inez2003 Borsoi2008 Testes Inst.
Impl. Prot.
H -- Mecanismo de extensão da UML -- Heavyweight L -- Mecanismo de extensão da UML -- Lightweight 1 -- Semântica Estática 2 -- Semântica Dinâmica 3 -- Linguagem Abstrata (notação) 4 -- Linguagem Concreta 5 -- Regras de boa formação Modelos Rosener2006 Nossa Abord.
Em este Capítulo apresentamos os caminhos utilizados no tocante a uma solução dos problemas e desafios identificamos no Capítulo 1.
Para atingir os objetivos, nossa abordagem consiste na identificação de uma estrutura lógica que foi desenvolvida para ser genérica, dentro de o escopo dos ASs participantes dos PDSs analisados.
Além disso, também foram identificados diferentes níveis de estruturação, tanto dos ASs quanto das informações armazenadas.
Desta forma, nossa proposta de estruturação de ASs consiste na criação de uma metalinguagem desenvolvida sobre o metamodelo da UML, sendo o seu cerne a utilização de contêineres de informações capazes de coordenar e organizar os artefatos estruturalmente, assim como utilizar os tipos de informações convenientes.
Este Capítulo está descrito nas Seções:·
4.1 Artefatos x Templates:
Uma vez determinado o escopo da nossa proposta, nesta Seção são apresentados detalhes maiores sobre ASs e como se comportam de entre as fases existentes em PDSs.·
4.2 Identificação do escopo:
Em esta Seção é apresentada a solução em questão, desde o seu princípio em PDSs até chegarmos ao foco do nosso trabalho, neste caso, Autoria de Artefatos de Software;·
4.3 Definição de Artefatos:
Após a identificação do escopo e apresentação dos detalhes necessários para um melhor esclarecimento sobre como ASs e PDSs são entendidos dentro deste trabalho, nesta Seção está a identificação dos problemas existentes com maiores detalhes, juntamente com a apresentação de uma solução conceitual em detrimento de a solução atual utilizada, comparando nossa abordagem.·
4.4 Uso de Artefatos:
Último passo para concluir a autoria de artefatos.
Essa Seção mostra como foi modelado o uso do que foi definido durante a Seção 4.3.·
4.6 Guia para Autoria de Artefatos de Software:
Em esta seção é apresentado um guia revisado para a construção de artefatos, desde a especificação até seu uso e instância.·
4.7 Regras para a Autoria de Artefatos de Software:
São apresentadas as principais regras definidas para a construção de artefatos bem estruturados.·
4.8 Níveis de Formalismo e Pontos de Conformidade:
Em esta seção são apresentados as características da abordagem, os níveis de formalismo utilizados no Metamodelo e UML Artefatos de Software são os elementos principais e o objetivo de existência de um PDS, pois espera- se que após o término de sua execução, todos os artefatos necessários tenham sido produtos.
Desta forma, o conjunto formado por os artefatos produzidos durante a execução de um PDS permite a criação de um Produto Final.
Entretanto, mediante a existência de vários e diferentes PDSs, nem sempre os termos e nome dos elementos são os mesmos aqui empregados.
Por isso, de acordo com o PDS utilizado, é bem comum encontrar nomenclaturas totalmente diferentes, mas que possuem o mesmo significado.
Desta forma, para fins de conhecimento e um melhor vocabulário comum, a Tabela 4.1 traz uma tradução dos diferentes termos encontrados nos PDSs atualmente mais comuns, no que se refere a Papel, Atividade e Artefato.
Todo AS possui sua própria organização interna e isto é o que os diferência de entre os demais.
Por exemplo, um artefato do tipo Código-Fonte é totalmente diferente de um Documento de Visão.
Mesmo assim, não existe um padrão que determine como deve ser um artefato e não sabemos quem, ou o que, os construirá.
Por isso é complicado definir como os artefatos devem ser preenchidos sem a utilização de algum guia.
Partindo deste princípio e utilizando as facetas de definição, uso e instância pode- se definir artefatos para um Processo específico, assim como o RUP.
O RUP utiliza- se de uma lista de templates (definição) que especificam como devem ser os artefatos.
Além disso, são fornecidas informações sobre quais atividades e papéis devem ser utilizados para construir instâncias a partir de o template (uso).
Tais templates contam com breves descrições de conteúdo e estrutura para determinar como serão os artefatos (instância) do Projeto.
Por exemplo, para desenvolver o artefato Visão, do RUP, primeiro precisaríamos descobrir seu objetivo e conhecer seu template.
Desta forma podemos investigar sua estrutura e organização, encontrando dados para saber como deve ser o seu preenchimento e utilização dentro de o projeto.
Após isso, devemos saber quais atividades criam, alteram ou lêem o documento Visão e quais são os papéis atuantes neste artefato.
Após isto, segundo teremos informações suficientes para criar o artefato Visão durante um Projeto.
No entanto, artefatos devem ser especificados durante a fase de definição do PDS authoring, que por sua vez possui dois instantes de criação, Method Content e Process Structure.
Diferentemente, seu preenchimento, ou seja, sua produção é feita no decorrer de a execução do PDS (enactment) em forma de projeto.
Além disso, diferentes PDSs poderão produzir diferentes tipos de artefatos, que são na verdade a união de várias camadas para representação da informação.
Vejamos: (a) camada de informação ou conteúdo:
em esta está toda informação considerada realmente importante e que poderá ser transformada em conhecimento.
Além disso, é levado em conta que diferentes informações possuirão diferentes níveis de restrições, os quais podem ser determinados através do tipo de informação (Numérico, string, data) ou sua necessidade (Empty, null, unique).
Diferentes processos podem utilizar diferentes metodologias ou métodos e produzir diferentes tipos de artefatos como resultado (Planilhas, documentos, arquivos XML).
Essa estrutura de camadas para construção de artefatos ajuda na definição dos papéis responsáveis por as fases do PDS.
Diferente dos atores existentes num PDS, os atores que o constrõem atuam em papéis exclusivos.
Sendo assim, poderíamos definir papéis como:
Engenheiros de Conteúdos ou Conhecimento, para investigar informações necessárias;
Engenheiro de Documentos para definir a estrutura de documentos e criar o Method Content;
E o Engenheiro de Processos para criar o Process Structure.
Portanto, sabemos que os artefatos armazenarão informações, utilizando- se de uma estrutura própria para o armazenamento e apresentando de forma com que o leitor entenda a informação disponível.
Embora nossa solução cause impacto explicitamente sobre PDSs, esta acaba por ser um pouco mais pontual, no tocante a algumas fases específicas.
Desta forma, para que pudessemos focar exatamente no ponto em que precisaríamos, procuramos entender um pouco melhor a natureza de PDSs, estudando também o seu ciclo de vida.
De acordo com, um PDS possui três fases durante seu ciclo de vida de desenvolvimento e cada uma de elas é responsável por pontos específicos:
Authoring, criação ou autoria;
Tailoring, adaptação ou configuração;
E enactment, execução.
Além de determinarem o ciclo de vida, tais fases servem para definir as facetas admitidas para um PDS, de acordo com o ponto de vista em que ele for observado.
A Figura 4.1 apresenta as diversas facetas que podem ser encontradas durante o ciclo de vida de um PDS.
Desta forma, com o PDS em fase de authoring, poderemos encontrar duas facetas:
Sua Method Content, que é uma biblioteca de conteúdos com os elementos necessários para montar Process Structure, que é a estrutura do PDS feita a partir de a biblioteca.
Em fase de tailoring será encontrado como Processo Padrão (Standard Software Development Process), o qual serve de base para um novo Processo Adaptado (Specific Software Development Process).
Finalmente, na fase de enactment, o processo é se transforma numa instância de si mesmo, onde é executado e acompanhado com a faceta de Projeto, que segundo, é um esforço temporário empreendido para criar um produto, serviço ou resultado exclusivo.
Como pode ser visto na Figura 4.2, existe uma biblioteca com o conteúdo a ser utilizado para montar a estrutura do PDS, para só então, instanciar- lo como um projeto.
Desta forma, são definidos três diferentes repositórios, dividindo os níveis de informação.
Por fim podemos ver que as fases de authoring e tailoring podem se utilizar do mesmo repositório.
Como visto na Seção 2.1, existem vários elementos que compõe um PDS, assim como Artefatos, Atividades e Papéis.
Diante de as fases existentes, tais elementos possuem dependências entre si, caracterizando diferentes facetas.
Desta forma, em nível de Method Content, todos os elementos estarão com a faceta de Definição.
Em nível de Project Structure, a faceta utilizado é a de Uso e somente na camada de projeto que o elemento se tornará uma instância real.
Sendo assim, os elementos Artefatos, Atividades e Papéis estarão nas seguintes facetas da Figura 4.3.
De acordo com o alinhamento entre os problemas e objetivos apresentados no Capítulo 1, nosso escopo reduz- se ainda mais, explorando o elemento Artefato.
Portanto todo o nosso foco estará em melhorar os problemas identificados neste elemento.
Assim como definido na especificação da UML, nossa idéia é definir um metamodelo para a autoria de ASs especificando a sintaxe e a semântica da linguagem, utilizando como base os princípios de:
Modularidade; Layering;
Partitioning; Extensibilidade;
Reuso;· sintaxe:
Representada através de notação UML, mostrando as metaclasses que definem os construtores da linguagem (como por exemplo:
Association, Operation, Property, entre outros) e seus relacionamentos;
Além de a existência de uma sintaxe computável;·
regras de boa formação:
Trata- se de um conjunto de regras de boa formação que são descritas usando OCL ou linguagem natural;·
semântica: Para cada construtor da linguagem é associado um significado.
Para isto é usado linguagem natural.
O uso da linguagem natural para especificar os elementos que compõem a linguagem, como a semântica, as regras de boa formação e sintaxe abstrata citados anteriormente, favorece o surgimento de ambigüidade.
Conseqüentemente, implica em dificuldades em estender o metamodelo da linguagem.
Este trabalho não tem como um de seus objetivos apresentar uma especificação formal da extensão do SPEM v2, mas sim uma descrição de autoria de ASs, seguindo as recomendações de extensão do metamodelo apresentada da especificação da linguagem.
Embora na literatura existam diversas maneiras de definir como devem ser PDSs, a utilização de UML para representar uma linguagem gráfica que permita reproduzir a criação de processos vêm se tornando cada vez mais popular.
Diversos metamodelos que explicam como devem ser os modelos de um processo determinado já foram ou estão sendo concluídos, assim como o metamodelo do RUP e do OPEN.
Entretanto, nenhum dos processos analisados possui um metamodelo que defina ASs de forma detalhada, constituindo- se a construção de forma manual, desde sua definição até o seu uso e instância.
Geralmente, no tocante a definição, uso e preenchimento é utilizada linguagem natural (como português e inglês) o que dificulta análise computacional posterior.
Desta forma, se quisessemos apenas obter ASs na forma tradicional, poderíamos determinar o nome e uma breve descrição e deixar a produção por conta dos papéis responsáveis.
Sendo assim, partindo do objetivo do trabalho, reutilizamos a linguagem UML para que seja possível a construção de um metamodelo que represente ASs detalhadamente, a partir de a extensão do metamodelo do SPEM v2.
Para evitar conflitos de nomes com os metamodelos da própria UML e SPEM v2, o metamodelo definido nesse trabalho também utilizada nomenclatura em inglês.
Conforme apresentado na Seção 2.3.2, ao se criar ou extender uma linguagem baseada no metamodelo da UML, deve- se utilizar o MOF.
Em a Figura 4.4 estão as camadas relativas ao que estamos propondo.
Em a camada M3 está o MOF, característico por permitir a criação de metamodelos, como os da camada M2.
O foco da modelagem da nossa proposta consiste em criar uma linguagem em nível M2, ou seja, uma metalinguagem, permitindo o seu uso na camada M1.
O modelo de domínio determinado através da nossa proposta de metamodelo pode ser realizado na camada M1, mesmo nível dos usuários da UML.
Em a camada M0 estão as instâncias, ou seja, elementos reais do processo, assim como artefatos, papéis e atividades.
Dado o SPEM v2, nossa extensão acrescenta os elementos cruciais para criação de artefatos em detalhes.
No decorrer de esta Seção estão apresentados os diversos problemas identificados por este trabalho, juntamente com a solução encontrada.
Tal solução é apenas uma breve descrição das partes modeladas para a constituição de um metamodelo comum ao SPEM v2 e a UML, sua especificação completa pode ser vista no Apêndice B. 2 As análises foram feitas a partir de ASs definidos em dois processos de software diferentes, RUP (processo tradicional) e SCRUM (processo ágil).
Para o RUP foram utilizados os artefatos definidos em e comparados com os mesmos dos software Rational Unified Process, baseado na Web.
Já para o SCRUM foram utilizados os artefatos definidos em.
Cenário 1 -- Tipificação dos Artefatos envolvidos Atualmente, ASs são preenchidos com a utilização de ferramentas específicas e que trabalham de acordo com o tipo do artefato.
Porém, durante um projeto, estes tipos estão fortemente atrelados a informação da extensão do arquivo.
Desta forma, se um artefato possui uma extensão compreendida por algum software específico, poderá então ser manuseado.
Alguns exemplos de ferramentas bastante utilizadas são:
Microsoft Office WordTM ou Open Office Writer, para ASs que possam ser preenchidos como documentos;
Microsoft Office ExcelTM ou Open Office Calc, para ASs a serem preenchidos como planilhas de cálculos ou matrizes;
IMB Eclipse1 ou Sun Microsystems NetBeans2, geralmente utilizados para artefatos de código-fonte;
IBM Rational Modeler 3 ou Enterprise Architect 4, para modelagem Orientada a Objetos utilizando UML.
Pontos Fracos Conforme nossas análises, os pontos fracos desta abordagem são:
Não existe uma lista que apresente os tipos de ASs existentes;
O tipo de cada As é determinado a partir de sua extensão ou ferramental utilizado.
Exemplos Exemplo 1: O artefato Glossário, do RUP, é uma lista de termos juntamente com seus significados, entre outros dados significativos.
Entretanto, não existe uma definição sobre o tipo deste As.
Desta forma, caso sua representação seja uma tabela com os termos, podemos afirmar que o Glossário é uma planilha.
Apesar de isto, um Glossário também poderia ser um documento com listas em tuplas do tipo termos/ significado.
Além desses, um Glossário poderia ser um arquivo XML, com os termos e seus significados mapeados através de XML tags definidas a partir de um XML Schema ou DTD.
XML ou ferramentas com base em alguma linguagem específica.
Desta forma, partindo destes dois exemplos, fica mais evidente os problemas existentes por falta de uma definição do tipo dos ASs.
Análise e Resultados De a análise feita sobre os processos, extraímos os seguintes resultados:·
RUP: 108 artefatos -- dos tipos documento, modelo UML, código-fonte, planilha e binário.
Infelizmente, 2 artefatos não foram encontrados e em outros 16 não foi possível concluir qualquer tipo.
Entretanto, dos artefatos analisados, apenas 37 são fortemente estruturados.
A grande maioria utiliza- se de templates como definição;·
SCRUM: 8 artefatos -- dos tipos planilha, diagrama/ gráfico, código-fonte e binário.
Nenhum de eles é fortemente estruturado embora os artefatos do tipo planilha apresentem estrutura quase padrão de representação.
Utiliza- se template como definição.
Desta forma, mostra- se necessário a definição de tipagem de artefatos para os tipos Documento, Planilha, Diagrama, Gráfico, Modelo UML, Código-Fonte e Binário.
Portanto o metamodelo deverá possuir construtores para utilizar a tipificação de artefatos baseada nos resultados obtidos.
Solução encontrada A solução escolhida para modelar o conceito apresentado neste cenário tem por base a criação de uma enumeração de tipos.
Esta enumeração é capaz de representar os tipos existentes que, aliados a uma metaclasse Artefato, permite a tipificação.
A Figura 4.5 apresenta a solução com base na metaclasse ArtifactDefinition, juntamente com um atributo artifact kind de nome akind que referência os literais da enumeração ArtifactKinds.
Comparação com abordagens atuais Com a introdução de tipificação, podemos determinar os possíveis tipos de ASs, desde a definição até o preenchimento dos mesmos.
Além disso, é possível criar categorias de ASs baseados nos tipos, uma vez que são conhecidos.
Cenário 2 -- Definição das Estruturas das Informações participantes Conforme analisado, diferentes ASs possuem diferentes informações.
Tais informações carregam com si uma determinada estrutura e possivelmente formas diferentes de visualização.
Entretanto, atualmente não existe um padrão ou formato para estas informações, dificultando tanto sua definição estrutural, quando o seu preenchimento posterior.
Pontos Fracos Esta abordagem tráz com si alguns problemas como:
Falta de conhecimento prévio da estrutura a ser utilizada em determinada informação;
Má interpretação do tipo ou estrutura a ser utilizada;
Preenchimento ambíguo por conta da decisão de estrutura tardia;
Falta de padronização estrutural.
Exemplos Exemplo 1: O artefato Modelo de Caso de Uso demonstra alguns problemas em relação a sua estrutura.
Apesar de ser baseado em UML, no RUP é utilizado um Template que especifica uma estruturação para cada caso de uso.
Desta forma, temos que construir Casos de Uso UML a partir de sua especificação.
Isto gera bastante confusão na estrutura a ser utilizada, pois pode- se utilizar tabelas, texto livre ou até uma estrutura específica para a especificação enquanto que seu modelo poderia ser em UML ou até mesmo uma representação em forma de figura.
Portanto, fica difícil determinar o que será um caso de uso, pois é dependente de contexto.
Exemplo 2: O SCRUM apresenta o mesmo problema.
O artefato BurnDown Chart é representado através de um gráfico em forma de imagem, seus dados são coletados em planilhas.
Sendo assim, este artefato poderia ser representado através de uma tabela simplificada ou de listas.
Embora isso ocorra, naturalmente existe uma padronização do gráfico, mas não da estrutura que este deve utilizar.
Análise e Resultados Conforme verificações em templates de ASs, obtivemos os seguintes resultados:·
RUP: De 108 artefatos apenas 39 possuem templates e 21, exemplos;
Não há artefatos de tipos binários, planilha e código fonte que possuam templates ou exemplos;
De 32 artefatos do tipo modelo UML, apenas 3 possuem templates e outros 4 possuem exemplos;
De 50 artefatos do tipo documento, 36 de eles possuem templates e destes, 17 possuem exemplos;·
SCRUM: De os 8 artefatos analisados, todos possuem templates e apenas 2 não possuem exemplos.
Em este próximo passo classificamos os tipos de informações existentes, utilizando três tipos possíveis de classificação:
Simples ou Primitiva, sendo os tipos mais simples possíveis;
Complexa, informação que deve possuir alguma estruturação mínima e que utiliza os tipos simples;
Após a classificação, os resultados obtidos foram:·
RUP: 97 tipos de estruturas, sendo 2 simples, 9 complexas e 86 específicas.·
SCRUM: 14 tipos de estruturas, sendo 2 simples, 5 complexas e 7 específicas.
Concluindo, os tipos encontrados foram:
Simples -- Texto, Texto com Etiqueta e Imagem;
Solução encontrada Para modelar o conceito apresentado neste cenário utilizamos a criação de diferentes tipos de informações, os quais, cada um possui uma diferente estrutura.
Contudo, nossas análises indicam ao menos três tipos possíveis de estrutura, e isso esta representado no metamodelo.
Desta forma, modelamos então três pacotes, conforme a Figura 4.6: SimpleTypes, ComplexTypes e SpecificTypes;
Além disso, adicionamos um quarto pacote, Diagram Types, preparado para permitir a construção de modelos a partir de diagramas da UML Superestructure.
As metaclasses responsáveis por a estruturação da informação estão dentro de os seus respectivos pacotes.
A Figura 4.7 apresenta as metaclasses Pai, ou seja, as super metaclasses de cada conjunto de tipos de estrutura que estão nos pacotes supracitados.
Como pode ser observado na Figura 4.7, a metaclasse abstrata SimpleInformation Element generaliza a metaclasse ComplexInformationElement que é especificada por as metaclasses SpecificInformationElement e Diagram.
Além disso, também é possível notar que os diagramas UML são submetaclasses de UMLDiagram.
Comparação com abordagens atuais Com a estruturação das informações podemos padronizar sua utilização nos ASs em que estarão dispostas.
Além disso, existirá uma menor preocupação com corretividade estrutural da informação, uma vez que esta já foi determinada desde a definição do As.
Desta forma, durante a fase de definição do Method Content podemos utilizar os tipos de informação para montagem, ou seja, autoria dos ASs, fazendo com que se tornem Compounding Documents.
Com isso, podemos definir todos os tipos de informação existentes em cada um dos artefatos que desejamos criar.
Já na fase de uso, ao se utilizar um As específico, toda a hierarquia, assim como a estrutura afixada na definição do As será também copiada, permitindo que o PDS base possua As com estrutura de informações pré-definidas.
Finalmente, durante a fase de projeto, por se tratarem de instâncias dos elementos do Process Structure, serão preenchidos base nas estruturas já determinadas.
Conforme apresentaremos mais adiante (em 4.3.4), informações tipificadas conforme suas estruturas possibilitam o reuso de definição estrutural e, posteriormente no preenchimento, reuso do próprio conteúdo.
Cenário 3 -- Determinar a Estrutura Interna dos artefatos envolvidos Cada AS possui uma estrutura interna que serve para viabilizar o acesso as informações expondo- as eficientemente.
Conforme existem diferentes artefatos, também podem existir diferentes estruturas.
Além disso, muitas vezes um conteúdo informativo sofre avanços ou incrementos no decorrer de o projeto.
Outras vezes, a mesma informação sofre correções ou refinamentos.
Desta forma, a informação estará sendo exposta de diferentes maneiras a medida que evolui, sendo importante que a estrutura de um artefato esteja flexível o bastante para suportar essas mudanças na informação.
Geralmente, a estrutura escolhida para um artefato é dada para organizar informações.
Caso contrário, informações estariam jogadas no artefato conforme a estrutura específica de cada uma.
Pontos Fracos De acordo nossas análises, os pontos fracos desta abordagem são:
Não existe uma informação que caracterize a estrutura do artefato em relação a o seu tipo;
Por o preenchimento ser dependente de ferramenta do tipo Office, a abordagem torna- se bastante flexível, porém sem estrutura bem definida;
Não é possível determinar ou categorizar a informação estruturalmente, apenas visualmente.
Exemplo O artefato Lista de Riscos possui uma estrutura baseada em seções, dividindo as informações sobre os riscos em vários níveis.
Desta forma, embora a própria informação possua uma estrutura é importante que o próprio artefato possa categorizar- la, para melhor disponibilizar as informações existentes.
Análise e Resultados Dados artefatos de ambos os processos supracitados, encontramos as estruturas do tipo:
Árvore, comum em documentos;
Lista; E tabela, comum em planilhas;
Solução encontrada Conforme observamos, todas as estruturas encontradas podem ser derivadas de uma única estrutura genérica baseada em composição, que é uma solução bastante comum em estrutura de dados.
Optamos por utilizar uma estrutura mais genérica em detrimento de estruturas específicas por o fato de haver maior flexibilidade pois, aparentemente, não parecia haver ganho em introduzir uma modelagem mais complexa com diferentes estruturas especificas de ASs.
A Figura 4.8 apresenta a modelagem que foi feita para tornar possível a estruturação do As.
Em esta mesma Figura está a metaclasse responsável por definir a estrutura geral de As, a ContainerDefinition.
Como pode ser visto, cada contêiner possui ainda dois relacionamentos do tipo pai/ filho, melhor representado a partir de a metaclasse ContainerDefinition_ Relationship criando uma espécie de estrutura composta genérica que permite a criação de vários contêiners alinhados.
Desta forma, cada contêiner pode ser utilizado para guardar as informações que estão estruturadas através de subclasses da metaclasse abstrata FragmentDefinition.
A exemplo, a classe de tipos de informações SimpleInformationElement será uma dessas subclasses de representação da informação.
Por fim, a metaclasse de relacionamento Artifact Container_ Relationship permite que cada contêiner esteja aliado a um artefato.
Tal ligação também faz com que um As, definido por a metaclasse ArtifactDefinition possa utilizar de muitos contêineres.
Não diferente disto, a metaclasse abstrata Fragment_ Relationship permite o relacionamento entre as informações dispostas nos fragmentos e seus contêineres e artefatos.
Comparação com abordagens atuais Atualmente os artefatos possuem uma estrutura definida por o tipo em que se apresenta.
Caso seja um documento, este será estruturado como uma árvore hierárquica.
Diferente disto, nossa abordagem permite que o mesmo artefato possua diferentes estruturas, mas devido a o fato das ferramentas atuais tornarem o preenchimento de artefatos bastante flexível, pode- se alcançar este mesmo feito a partir de a abordagem atual.
Entretanto, nossa abordagem define como a estrutura de um artefato deverá ser e isto ocorre independente de ferramental.
Cenário 4 -- Classificação dos diferentes ASs Como a idéia central para a produção de artefatos de software é armazenar informações pertinentes para concluir um produto de software específico.
Entretanto, a falta de indexação pode causar problemas, tornando difícil um possível busca alguma informação necessária.
Em esse contexto, basicamente não existem soluções de recuperação que não sejam ferramentas de busca de terceiros.
Mesmo assim, muitas vezes sabe- se sobre a informação, mas não se consegue recuperar- la através de buscas baseadas em palavras-chaves.
Conforme visto em, nesta abordagem também classificamos ASs de acordo com os tipos de conteúdo que eles conterão.
Assim tornando mais completa a classificação do tipo de armazenamento a ser feito diante de as informações de um artefato.
Pontos Fracos De esta forma, sabemos que existem dificuldades na classificação da informação armazenada, tendo em vista problemas de recuperação da informação por falta de organização dos ASs num projeto.
Exemplo A busca de informações durante o desenvolvimento de um Produto acaba por ser facilitada, desde que seja uma informação essencial ou bastante conhecida.
Desta forma, caso desejássemos localizar alguma nova solicitação feita por o Stakeholder, por exemplo, conseguiríamos encontrar o As através das próprias divisões do processo, como disciplinas e atividades específicas, utilizando algum rastreamento.
Em todo caso, uma vez terminado o projeto, determinar as solicitações ocorridas, quando esta informação já foi esquecida por os antigos membros do projeto, tornará- se- um problema.
Solução encontrada A Figura 4.9 apresenta as metaclasses quer permitem a classificação de artefatos de acordo com a abordagem vista em.
Como pode ser visto, a metaclasse abstrata ClassifiedElement possui um relacionamento com ClassElement, permitindo que suas subclasses sejam classificadas de acordo com a enumeração ClassElementKind.
Todo elemento que possa ser classificado de acordo com os tipos definidos na enumeração deve ser um ClassifiedElement, neste caso os artefatos.
Comparação com abordagens atuais Classificações para informação são feitas geralmente sobre documentação e na maioria das vezes, sobre documentação pronta de um projeto.
Além disso, faz- se o uso de classificações externas aos documentos, através de tabelas ou com utilização de hierarquias feitas por algum sistemas de arquivos.
Nossa abordagem provê uma implementação para o trabalho de que se constitui em classificar mais do que documentos, ou seja, ASs e de forma que seja internamente, sem a necessidade de outra ferramenta ou recurso.
Cenário 5 -- Definição de níveis de Maturidade Partindo do princípio que artefatos são pontos de medidas para determinar o nível de maturidade de um PDS, adicionamos a definição de níveis de maturidade baseados em.
Desta forma, existe a gerência de artefatos em relação as modificações feitas durante a autoria e uso dos mesmos, verificando o quão próximo de o ideal está o PDS.
Pontos Fracos Atualmente as abordagens de maturidade são feitas com base nos Processos, inclusive PDSs.
Desta forma, os ASs são analisados para determinar o nível de maturidade em que se encontram, medindo o PDS e a empresa que o adota.
A grande maioria das análises é feita conforme gabarito externo aos artefatos que, mediante consulta e rastreabilidade, consegue- se determinar o quanto cada artefato está maduro dentro de um Projeto.
Em estas abordagens, os pontos fracos são:
A forma subjetiva para determinar o nível de maturidade de cada um dos artefatos já preenchidos;
A necessidade de rastrear os artefatos mediante tabela de maturidade;
Uso de gabarito comparativo que determina apenas o instantâneo em relação a o preenchimento dos artefatos, não a sua estrutura anterior.
Exemplo Em o RUP, o artefato Visão do Negócio é um reflexo criado a partir de o Template sugerido na fase de autoria do PDS.
O objetivo do documento é capturar os objetivos relacionados a modelagem de negócios num nível bastante abstrato.
O documento Visão do Negócio é criado na fase de Iniciação de um projeto e usado como base para o Caso de Negócio e como primeiro rascunho do documento de Visão.
Por isso, está intrinsecamente relacionado ao projeto, desde o esforço de Engenharia do Software até o Caso de Negócios e o documento de Visão.
Desta forma, por ser um artefato complexo faz- se necessário verificar qual o nível de maturidade em que se encontra durante o projeto.
Mesmo assim, apenas isso só poderá ser feito após a execução de algumas atividades, por conta de necessidade de preenchimento.
De acordo com, podemos verificar o nível de maturidade do artefato ainda em seu template, mas será medido o nível de maturidade do Processo, não sua execução.
Solução encontrada Sendo assim, modelamos a solução vista em, incluíndo os diversos níveis de maturidade definidos no mesmo trabalho.
Em a Figura 4.10 estão as metaclasses Maturity Element, que define elementos que possuem nívels de maturidade e Matyrity Element Level, que determina os indicadores e valores do elemento a ser analisado.
Por fim, a enumeração de tipos LevelTypes determina o nível de maturidade através de classificações de acordo com a tabela de.
Comparação com abordagens atuais Com a utilização desta solução é possível definir de um modo mais granular o nível de maturidade de um projeto.
Desta forma, podemos definir o quanto cada artefato nas diversas camadas do PDS, desde o Method Content, Process Structure até o Process Enactment.
Cenário 6 -- Inserção de Mecanismo de Versionamento A o se trabalhar com informação, principalmente em grandes quantidades, são utilizados repositórios de dados, na busca por garantias de armazenamento.
Muitos repositórios funcionam com base em instantâneos feitos durante períodos de tempo, garantindo que diferentes versões da mesma informação sejam guardadas.
Devido a o fato de PDSs se constituírem em três camadas (authoring, tailoring e enactment) o nível de dados existentes sobre um único PDS é bastante alto, necessitando de repositórios capazes de armazenas os diversos instantâneos gerados a medida que as alterações ocorrem.
Desta forma, além de produzir histórico das informações, existe a necessidade de rastrear tais alterações futuramente.
Portanto, devido a esta necessidade adicionamos esta característica aos artefatos, permitindo criação de várias versões com controle interno.
Pontos Fracos Atualmente as informações são encapsuladas em artefatos que são guardados inteiramente nos repositórios dos projetos.
Ou seja, não existe identificação de que tipo de informação foi adicionada, removida ou alterada;
Difícil identificar como a informação foi alterada e por quem.
Diversas famílias de PDSs são criadas a partir de um PDS base.
Tais famílias são modeladas em ferramentas com base em linguagens que não possuem versionamento.
Desta forma, os arquivos que constituem as informações sobre os PDSs e suas famílias são armazenados por inteiro, apresentando os mesmos problemas vistos anteriormente.
Além disso, nesta abordagem não é possível determinar as ligações entre o Process Structure e o Method Content.
Durante a criação do Method Content várias versões de Papéis, Atividades e Artefatos são feitas.
Muitas vezes tais versões são alteradas, não havendo maneiras de serem reconstituídas, por se tratarem, geralmente, de um conjunto de elementos de uma biblioteca estática.
Basicamente, perde- se as versões existentes, mas mesmo que fossem versionadas rastrear as alterações e suas implicações em todas as camadas acima não é uma tarefa fácil.
Exemplos Exemplo 1: Dado o preenchimento do artefato Modelo de Casos de Uso, do RUP, ao qual foram inicialmente definidos dois atores e três casos de uso, pode- se armazenas- lo num repositório.
Mais adiante caso haja a necessidade de reparos ou atualizações, como adição de mais um caso de uso, por exemplo, este artefato será recolocado no repositório, juntamente com as informações sobre o que ocorreu.
Entretanto, caso os comentários feitos por o responsável por as alterações não sejam suficientes, a menos que comparemos os artefato em ambas as versões nós não saberemos o que foi modificado.
Além disso, a utilização de mecanismos de diferenciação é desencorajada, por não se tratar de um artefato constituído apenas de texto.
Exemplo 2: Durante a modelagem de um PDS podem existir diversas alterações e refinamentos.
Dada a autoria, poderiam ser criadas duas atividades, 1 papel e 3 artefatos, juntamente com suas ligações.
A partir deste momento pode- se enviar o arquivo com o modelo do PDS para o repositório.
Caso seja necessário alterar a estrutura previamente definida e outro arquivo deva ir ao repositório, possivelmente existirão problemas na identificação do que foi alterado.
Infelizmente, se o Engenheiro de Processos responsável por a modelagem não for bastante cuidadoso, terá que rastrear os elementos da própria linguagem de modelagem do PDS para verificar onde ocorreram as alterações.
Exemplo 3: Dado uma família de PDSs previamente definida, a qual cada PDS é derivado tornando- se uma versão do PDS Base, neste caso o RUP.
Para uma melhor adaptação do PDS para um determinado domínio especifico atividades, papéis ou outros elementos do PDS Base foram excluídos, gerando a árvore de variabilidades de PDS.
Sendo assim, da mesma forma que no Exemplo 2, caso não haja a informação explicita do que foi alterado, deve- se rastrear os arquivos de modelagem dos PDSs para verificar suas diferenças em relação a o PDS Base, percebendo então, as mudanças.
Exemplo 4: Existe um Method Content com quatro artefatos, os quais estão em primeira versão, e será necessário alterar- lo para que um dos artefatos seja dividido em dois.
As alterações foram feitas e enviadas ao repositório.
Após a alteração foi necessário verificar o que foi modificado, entretanto, não existe a informação de como um artefato se transformou em dois, nem ao menos qual artefato sofreu tais modificações e fora excluído.
Além disso, deve ser avaliado o impacto da alteração, que ocorrerá nas camadas superiores, gerando mais problemas.
Solução encontrada Conforme utilizaremos metamodelagem para definir o Method Content e Process Structure, escolhemos utilizar o próprio MOF Repository para gerenciar as versões nos níveis de metamodelo e modelo.
O MOF Repository estende o MOF, adicionando metaclasses que representam controle de versão.
Em a Figura 4.12 estão as principais metaclasses responsáveis por o versionamento.
Desta forma, todos os elementos das camadas de meta-metamodelo, metamodelo e modelo poderão ser versionados e não apenas artefatos.
Como se trata de uma extensão do MOF, o MOF Repository adiciona estas metaclasses na própria camada M3.
Desta forma, qualquer linguagem definida a partir de esta extensão do MOF, poderá ser versionada.
Como pode ser visto na Figura 4.12 a metaclasse VersionedExtent herda Extent.
Em o contexto do MOF, um Extent é responsável por aplicar algumas das capacidades a elementos do MOF, assim como gerar a identificação através de Uniform Resource Identifier (URI).
Através de VersionedExtent é possível obter versões e históricos do que foi alterado.
O MOF Repository ainda contém metaclasses responsáveis por determinar workspaces, Baselines e definir sessões.
Comparação com abordagens atuais Com a utilização do MOF Repository é possível verificar o que exatamente foi alterado dentro de as camadas existentes num PDS.
Além disso, também é possível saber o papel responsável por as alterações.
Finalmente, é possível rastrear os elementos da modelagem nas diversas camadas modeladas para um PDS.
Cenário 7 -- Relacionar os artefatos utilizando diferentes níveis de reuso e compartilhamento Existe uma grande preocupação por parte de a indústria no modo como é feito o armazenamento de informações durante a execução de um processo.
Como sabemos, estas informações são guardadas nos artefatos, porém, a preocupação está em armazenar- las corretamente.
Assim como num banco de dados, quando tratamos com informações existem problemas relacionados a forma estrutural e o conteúdo, que são tratados como duas coisas diferentes.
Desta forma, para relacionar os artefatos com suas respectivas informações, de forma a reduzir a redundância e a inconsistência pode- se tentar aumentar o reuso.
Pontos Fracos Um grande problema visto na maioria dos projetos é a manutenção dos artefatos.
Seja um pequeno trecho de código alterado, que pode vir a reduzir a consistência com o modelo, ou algum documento de negócios ou de gerência, que pode vir a estar desatualizado.
Durante a execução do processo, na medida do possível tanto a estrutura quanto o conteúdo são reutilizados.
Entretanto, isto geralmente é feito através de procedimentos de cópia-e-cola das informações.
O que pode causar problemas de manutenção dos artefatos supracitados.
Um outro problema é a inconsistência causada por falta de comunicação, o que pode levar a redundâncias.
Isto ocorre geralmente quando diferentes atores trabalham com diferentes artefatos que deveriam reutilizar estrutura ou conteúdo.
Como os atores não se comunicaram, possivelmente os mesmos conceitos serão guardados de formas diferentes, e em diferentes artefatos.
Exemplos Exemplo 2: Um bom exemplo de perda de reuso estrutural pode ser visto na configuração atual dos artefatos do RUP.
A grande maioria desses artefatos possuem uma seção introdutória da seguinte maneira5:
Esta estrutura poderia ser feita apenas uma vez, reaproveitantoa em todos os artefatos que fosse necessária.
Exemplo 2: Ainda utilizando o Exemplo anterior, podemos afirmar que existe uma grande perda de reuso de conteúdo.
Em a Subseção 1.3 temos os definições, acronismos e abreviações que devem estar no Glossário ou algum Dicionário de Dados, ambos artefatos bastante utilizados.
A partir de o momento em que essas informações são repetidas, perde- se totalmente o reuso de conteúdo.
Um problema ainda maior pode ser causado se essas informações foram alteradas no Glossário, sendo necessário uma conferência em todos os artefatos para a atualização dos dados.
Exemplo 3: Outro reuso bastante importante poderia ser feito utilizando- se as informações já existentes num artefato, caso este fosse bem estruturado, ao invés de refazer- la.
Isto também pode ser encontrado no primeiro exemplo.
Todas as referências a artefatos, tanto externos quanto internos, são armazenadas na Seção Referências e assim como no Exemplo 2, qualquer alteração culminaria numa grande perda de tempo nas atualizações, caso tudo ocorresse de forma correta.
Solução encontrada A solução deste problema foi parcialmente resolvida na Seção 4.3.3, a partir de o momento em que definimos uma maneira de organizar os artefatos e suas informações.
Devido a utilização de contêineres e fragmentos de informação é possível constituir vários níveis de reuso, dependendo da necessidade.
Ou seja, apenas com a utilização de contêineres pode- se agrupar as informações, fazendo com que desta forma os artefatos utilizem- se dos mesmos contêineres, evitando redundância de informação.
Especificamente, o reuso ocorre nas ligações entre artefatos e contêineres, artefatos e tipos de informações e entre contêineres e informações.
Para aumentar ainda mais o nível de reuso, acrescentamos tipos para essas ligações, definido exatamente o tipo de reuso esperado.
Os tipos definidos foram:·
content: As ligações pare esse tipo de reuso devem prover reuso tanto estrututural quando de a informação contida.
Este tipo deve ser utilizado apenas quando se tem certeza de que não apenas a estrutura mas o conteúdo a ser inserido será o mesmo nas diversas vezes que for utilizado.
Um exemplo bastante típico é na utilização de termos ou definições de um glossário.
A estrutura de um termo ou uma definição são praticamente imutáveis e podem ser reaproveitados, da mesma forma, o conteúdo das informações também serão os mesmos, não importando onde essas definições serão utilizadas.
Como pode ser visto, o Artefato 2 (fonte) herda toda a estrutura existente do Artefato 1 (alvo).
Por padrão, este tipo de reuso é apenas estrutural, porém fixo, uma vez que é feita a extensão, a estrutura do elemento fonte variará conforme a estrutura herdada de seu alvo.
Ou seja, se em algum momento o Container 1 for excluído, isto será refletido no Artefato 2.·
localContribution: As ligações desse tipo devem prover um mecamismo de reuso definindo contribuições ou acréscimos especificamente locais.
Este tipo de reuso pode ser utilizado quando é necessário adicionar novos sub-elementos a um conjunto de elementos existentes, Figura 4.14.
Como pode ser visto, o Container 2 (fonte) é contribuído com a adição de mais um fragmento (Fragmento 2), que é adicionado após o Fragmento 1.
Este tipo de ligação também provê apenas reuso estrutural, e da mesma forma como em extension, também é fixo.·
localReplacement: As ligações desse tipo devem prover um mecamismo de reuso para substituir tanto estrutura, quanto conteúdo de forma local.
Com a utilização de ligações desse tipo pode- se substituir elementos existentes anteriormente a extensão, trocando- os por os elementos herdados.·
reference: Este é o tipo padrão utilizado para reuso estrutural de contêineres e tipos de informação.
Em a Figura 4.16 é apresentado o reuso de contêiner e fragmento utilizando duas ligações do tipo reference.
Como pode ser visto, a segunda ligação não possui nenhuma indicação sobre o tipo, entretanto, por padrão é utilizado o tipo reference.
Além disso, todos estes tipos de ligação podem ser feitos juntamente com um tipo de ligação extension, caso seja utilizado num nível mais alto no que se refere à hierarquia, ou seja, num elemento mais externo.
Desta forma, o tipo de ligação mais interno sobrescreverá o extension.
Esta parte da nossa abordagem foi implementada conforme o metamodelo da Figura 4.17.
Em esta figura estão as metaclasses responsáveis por os relacionamentos entre:·
artefato e contêiner:
ArtifactContainer_ Relationship;·
artefato e tipo de informação:
ArtifactFragment_ Relationship, que é subclasse de Fragment_ Relationship;·
e contêiner e tipo de informação:
ContainerFragment_ Relationship, que também é subclasse de Fragment_ Relationship.
Assim como visto no Cenário 4 (Seção 4.3.3).
Em este sentido, todas as metaclasses responsáveis por os relacionamentos entre artefatos, contêineres e tipos de informação herdam da metaclasse ReuseRelationship, que possui o atributo type.
Este atributo por sua vez é do tipo ReuseType, que nada mais é do que uma enumeração que contém os tipos de reuso existentes, citados anteriormente.
Desta forma, ao definir qualquer um desses relacionamentos, podemos indicar qual o tipo de reúso desejado.
Comparação com abordagens atuais Como pôde ser visto nos Exemplos 1, 2 e 3, as abordagens analisadas não contemplam o reuso de informações ja previamente utilizadas, ou seja, o reuso de conteúdo e estrutura, na maioria das vezes, é perdido, levando ao surgimento de redundância e inconsistência.
Com nossa abordagem podemos reutilizar estruturas já previamente definidas.
Os Exemplos 1, 2 e 3 podem ser resolvidos facilmente, utilizando as ligações de reuso.
Além disso, pode- se evitar a criação de estruturas de forma repetitiva, evitando uma série de inconsistências, retrabalho e redundância.
Cenário 8 -- Envolver a estruturação de ASs com o PDS Em o cenário atual de modelagem de PDS, papéis, artefatos e atividades estão interligados entre si.
Desta forma, é possível identificar quais atividades são responsáveis por dado artefato e seus respectivos papéis.
Conforme identificado em alguns PDSs, assim como RUP e OPEN, é bastante comum a utilização de sub-atividades, ou seja, dividir uma atividade em pedaços menores.
Muitas vezes uma atividade chega a ser subdividida a ponto de ser tornar uma tarefa (task), empregada apenas um papel exclusivamente.
Além disso, também é bastante comum o desenvolvimento de grupos de papéis (Composite Role), que juntos contém competências, ou qualificações suficientes para atuar em atividades um pouco mais exigentes.
Assim como as tarefas são exclusivas e interligadas com papéis específicos, que muitas vezes são agrupados, um artefato também precisa se relacionar desta forma, para que as restrições de execução da atividade, em meio de tarefas e papéis, sejam correspondidas.
Portanto, diante de o fato de nossa abordagem subdividir ASs, devemos também alinhar tais fragmentos e contêineres as atividades e papéis correspondentes.
Pontos Fracos Atualmente, já que PDSs tratam ASs de forma monolítica, ou seja, inteiros e sem divisões, existem alguns problemas conforme a ligação entre os papéis atuantes e as atividades correspondentes, tais como:
Artefatos são produzidos inteiramente, sem identificar quais pontos serão produzidos durante aquela atividade;
Necessária experiência e conhecimento prévio sobre construção do artefato para seu preenchimento correto durante atividade;
Os papéis precisam conter maior quantidade de competência ou qualificações para executarem uma atividade dado o fato de produzirem artefatos inteiros;
Em um artefato não existem informações suficientes para identificar as atividades que foram responsáveis, nem quais partes foram construídas.
Exemplo A construção do artefato Visão, é feita parte a parte, ou seja, ao longo de a execução de diversas atividades do PDS, neste caso o RUP.
Para a execução dessas atividades são necessários diferentes papéis.
A exemplo temos as atividades Capturar um Vocabulário Comum que requisita um Analista de Sistemas, Localizar Atores e Casos de Uso de Negócios que precisa de um Analista de Processo de Negócios e Localizar Entidades e Trabalhadores de Negócios que utiliza um Designer de Negócios, e assim por diante.
Como pode ser visto, um mesmo As pode ser construído por diversos papéis diferentes, em diversas atividades diferentes.
Embora a documentação do RUP apresente quais passos devem ser feitos para executar as atividades, não fica claro quais partes que constituem o artefato Visão devem ser feitas por Quem (Papel) e Quando (Atividade).
Desta forma, após o preenchimento do artefato, tais informações são praticamente impossíveis de rastrear dentro de um PDS.
Entretanto, muitas vezes a experiência adquirida num PDS específico permite que este conhecimento seja formado ao longo de o tempo.
Porém, muitas vezes não se usa o mesmo processo inteiramente, além disso, suas execuções são diferentes entre si.
Solução encontrada Para este fim o SPEM v2 foi estudado cuidadosamente, sendo identificados seus pontos de extensão.
Por ser um metamodelo flexível e uma extensão da UML para desenvolvimento de um domínio específico, sua construção foi feita determinando diferentes níveis de conformidade (compliance levels).
Por fim, devemos integrar a extensão do metamodelo com o metamodelo original, combinando assim a autoria de ASs com a autoria de PDSs já definida por o SPEM v2.
Como o próprio SPEM v2 já possui a conexão entre artefatos, papéis e atividades, dadas por as metaclasses WorkProductDefinition/ WorkProductUse, RoleDefinition/ RoleUse e ActivityDefinition/ ActivityUse, para haver integração é necessário definir como será a interação entre os mesmos em relação a os conceitos acrescentados no metamodelo.
Devido a extensão, artefatos e suas informações contêm tipo e estrutura interna, para adicionar este conhecimento aos papéis e atividades, deve existir uma ligação que permita tal sincronia.
Em a Figura 4.18 estão algumas das metaclasses da extensão feita sobre o SPEM v2, em tons mais claros.
As metaclasses ArtifactDefinition, ContainerDefinition e FragmentDefinition, já definidas anteriormente em 4.3.3, foram remodeladas como sub-classes de WorkProductDefinition, herdando o auto relacionamento previamente definido por a metaclasse do SPEM v2 WorkProductDefinitionRelationship.
A metaclasse abstrata SimpleInformationElement tambem é uma dessas subclasses, por transitividade.
Desta forma, passa a existir uma conexão entre o metamodelo definido por a OMG e a extensão realizada nesse trabalho.
Vale notar também, que qualquer alteração na metaclasse WorkProductDefinition será espelhada para suas subclasses.
Além disso, na Figura 4.19 é apresentado um diagrama que contém a solução de modelagem para relacionar ASs com seus respectivos papéis proposta no metamodelo do SPEM v2.
Em o metamodelo estão as metaclasses RoleDefinition e WorkProductDefinition que estão relacionadas através de Default_ ResponsibilityAssignment.
Embora apenas ArtifactDefinition esteja exposta no diagrama, todas as subclasses de WorkProduct Definition possuem o relacionamento com RoleDefinition.
Para definir a interação entre artefato e atividade foi reutilizada a estrutura do SPEM v2.
Em a Figura 4.20 está definido um diagrama que representa esta ligação.
Através da metaclasse Default_ TaskDefinitionParameter do SPEM v2 pode- se criar um elo de ligação entre as subclasses de WorkProductDefinition e TaskDefinition, que especializa WorkDefinition.
A metaclasse WorkDefinition modela o conceito de trabalho a ser realizado podendo ser um sinônimo para atividade, embora mais geral.
Por fim, a Figura 4.21 apresenta as ligações existentes entre os conceitos de papel e atividade.
Como pode ser observado, uma TaskDefinition especializa a metaclasse abstrata WorkDefinition, que é uma representação geral do conceito de atividade.
Desta forma, existe a relação entre TaskDefinition e RoleDefinition através da metaclasse do SPEM v2 Default_ ResponsibilityAssignment.
Comparação com abordagens atuais Desta forma, tanto a estrutura da informação, quanto a estrutura do artefato devem possuir relacionamentos com papéis e atividades.
A partir deste ponto pode ser visto que é possível determinar, exatamente, o que cada papel será responsável em produzir, conforme ação específica a ser feita numa atividade que deva manipular um artefato.
Em a Seção anterior houve a especificação da Definição dos ASs, tornando possível utilizar uma linguagem para a permitir a Autoria de ASs, conforme essa especificação.
Entretanto, apenas definir como deve ser um artefato não basta para que ele possa estar num PDS.
Para solucionar este problema devemos adicionar uma camada que permite a utilização dos artefatos por os PDSs, sem alterar suas definições.
Portanto, para que exista uma autoria completa, apresentaremos nessa Seção como se deu a construção da camada de ligação entre a definição dos artefatos e a definição da estrutura de PDSs, conhecida por Process Structure, ou simplesmente por uso.
Assim como na última Seção, utilizaremos uma estrutura comparativa entre este paradigma e o atual, mostrando:
Pontos fracos do paradigma atual, a nossa solução e, por fim, a comparação entre as soluções.
Pontos Fracos Dentro de a abordagem tradicional, mais especificamente nos processos avaliados (Scrum e RUP), notamos a utilização constante de templates, exemplos e guias de utilização.
Os templates são na maioria das vezes esqueletos dos artefatos originais, publicados de forma que sejam auto-explicativos.
Além disso, notamos que os templates são utilizados para definir como devem ser artefatos do tipo documentos e dificilmente são feitos templates para outros tipos de artefatos, embora seja possível.
Em esse sentido, existe um grande problema:
Já que nem todos os artefatos possuem templates, como pode- se utilizar- los, já que não existe a própria definição?
Ou seja, o maior problema está na parte de utilização desses templates.
Embora sejam documentos que indicam a estrutura de seções e como devem ser preenchidos, não há uma clara definição de certo ou errado quanto a os tipos de informação.
Para tentar corrigir esta situação, são utilizados exemplos, guias e ferramentas específicas, porém, o sucesso depende puramente da interpretação do responsável por o preenchimento do artefato.
Além disso, os templates nem sempre são utilizados por completo, ou seja, neste paradigma não ficam claras as alterações feitas no que se diz respeito a utilização dos templates (i.
e remoção, alteração, adição de definições), durante a criação do PDS.
A construção do artefato Visão, é feita parte a parte, ou seja, ao longo de a execução de diversas atividades do PDS, neste caso o RUP.
Para a execução dessas atividades são necessários diferentes papéis.
A exemplo temos as atividades Capturar um Vocabulário Comum que requisita um Analista de Sistemas, Localizar Atores e Casos de Uso de Negócios que precisa de um Analista de Processo de Negócios e Localizar Entidades e Trabalhadores de Negócios que utiliza um Designer de Negócios, e assim por diante.
Solução encontrada Em este contexto, a solução que foi utilizada é a mesma encontrada na especificação do SPEM v2.
O metamodelo da OMG já traz a noção de separação do conteúdo do Processo, de sua estrutura.
Desta forma, os artefatos podem ser utilizados através do padrão Proxy, conforme a Figura 4.22.
Comparação com abordagens atuais Em relação as abordagens atuais, nossa abordagem permite entender o relacionamento entre a definição dos ASs e o seu uso em PDSs.
As abordagens atuais não permitem avaliar este relacionamento, pois não utilizam o conteúdo separado da estrutura, sendo assim, dificilmente conseguem estabelecer ligação entre a instância do artefato e seu template.
Em nossa abordagem o uso dos artefatos é feito a partir de uma definição, ou seja, todos os artefatos obrigatoriamente terão uma definição única.
Por isso é possível saber qual foi o tipo de uso, percebendo se houve alguma alteração a partir de o próprio modelo.
Atualmente nem todos os artefatos possuem definição e mesmo o que são providos de templates ou até mesmo exemplos, dependem de interpretação de definições feitas em linguagem natural.
Em este trabalho a extensão da UML e do SPEM foram feitas através do uso de dois mecanismo de extensão:
Lightweight e heavyweight.
A extensão feita a partir de o mecanismo lightweight permite que os modelos gerados sejam utilizados por diversas ferramentas Case já existentes.
Como este mecanismo não altera o metamodelo da UML, é favorecida a troca de dados.
Já a extensão feita a partir de o mecanismo heavyweight impossibilita a troca de dados entre ferramentas que implementam o metamodelo padrão da UML.
Geralmente, uma extensão deste tipo também é acompanhada de ferramentas que suportem as alterações feitas.
Entretanto, a troca de dados só poderá ser feita através dessas ferramentas específicas.
Mesmo assim, a utilização desse tipo de extenção permite a criação de semântica muito mais rica do que UML Para a implementação da nossa abordagem estendemos tanto a UML quanto o SPEM v2.
Embora o metamodelo proposto possua mais de 100 metaclasses, nas seções 4.3 e 4.4 foram apresentados as metaclasses principais, constituindo o cerne deste trabalho.
Para maiores deta- lhes, em é apresentado em detalhes e por completo o metamodelo SPEMXt, que é a extensão do SPEM v2.
Diante de as análises dos paradigmas atuais da Engenharia de Software, não foi encontrado consenso sobre as atividades e as particularidades inerentes a autoria de PDSs, muito menos uma descrição ou esboço das características de soluções em autoria de ASs.
Como conseqüência, trabalhos que abordem o tema precisam de um grande investimento de tempo e esforço.
Com o objetivo de modificar tal realidade, foi analisado um conjunto de trabalhos visando fazer um levantamento dos requisitos básicos, das atividades e das necessidades pertinentes à autoria de PDSs.
Feito isto, foi elaborado um guia que tem como principal objetivo auxiliar a construção de bibliotecas de PDSs e ASs.
De esse modo, o guia aqui elaborado especifica um fluxo de atividades a ser seguido a fim de obter um Processo de Software que utilize Artefatos de Software conforme a abordagem explicitada nesta dissertação.
Além disso, o guia visa representar boas práticas e tornar tão compreensível quanto possível os papéis necessários para a concretização da autoria.
Em a Figura 4.24 é apresentado um Diagrama de Atividades que representa um fluxo inicial sobre Processos de Software.
Este fluxo é baseado no Ciclo de Vida para PDSs visto na Seção a pergunta é bastante simples:
Qual fase quer prosseguir?
Em este ponto pode- se escolher entre reconfigurar um PDS já existente, adaptar- lo para um domínio específico ou criar família de processos para soluções diversas;
Executar um PDS já anteriormente criado, concebendo um novo projeto;
Ou criar um novo PDS, que é o foco deste trabalho.
A fase de criação de um PDS pode vir a ser bastante longa, consistindo na adição de elementos pertencentes ao processo, formando uma autoria.
Por existirem muitas atividades inerentes a autoria de PDSs, elas foram agrupadas em quatro macro-atividades, Figura 4.25:· Definir nova Biblioteca:
Aqui estão agrupadas as atividades responsáveis por definir uma biblioteca de configuração.
Esta biblioteca permitirá a criação de conteúdos e estruturas de PDSs.·
Criar Method Content: Aqui estão agrupadas as atividades responsáveis por definir o conteúdo.
Desta forma pode- se utilizar o conteúdo previamente definido para construir a estrutura de até mesmo uma família de PDSs.·
Definir Process Structure: Aqui estão agrupadas as atividades responsáveis por definir a estrutura de um PDS.
Tal estrutura especifica exatamente como deve ser o uso de um conteúdo prévio, fazendo ligações e relacionamentos com os elementos que constituintes da biblioteca de conteúdo.·
Publicar Processo: Em esta última macro-atividade estão agrupadas atividades afins no contexto de publicar o PDS criado a partir de as macro-atividades anteriores.
Além disso, a Figura 4.25 também apresenta os papéis responsáveis por a execução das atividades supracitadas, assim como os artefatos de os quais são responsáveis:·
Configurador: O ator deste papel deve ser responsável por configurar todo o Ambiente de Autoria de Processos.
Desta forma, ele deverá produzir o artefato Biblioteca (Spemxt Library) e preparar- lo para receber os dados das próximas atividades.
Em este momento o Spemxt Library encontra- se vázio no que se refere a PDSs.·
Engenheiro de Conhecimento: O ator deste papel deve ser responsável por criar conteúdo reutilizável por o processo, definido elementos como papéis, atividades e artefatos.
O conteúdo produzido deverá entrar no Spemxt Library.·
Engenheiro de Processos: O ator deste papel deve ser responsável por criar a estrutura do Processo reutilizando os elementos produzidos por o Engenheiro de Conhecimento.
O Engenheiro de Processo deve ser capaz de combinar os diversos elementos existentes no conteúdo para criar um Processo geralmente específico para um domínio.
Toda a estrutura produzida, assim como os relacionamentos criados para se utilizar os elementos do conteúdo deverão entrar no Spemxt Library.
Além disso, o Engenheiro de Processo ainda deve publicar o PDS para que este possa ser utilizado, criando o Artefatos diversos, geralmente em páginas Html.
Após descrever esta visão geral sobre o fluxo de atividades que descrevem o guia para autoria, apresentaremos as macro-atividades com maiores detalhes nas Seções a seguir.
Definir nova Biblioteca Primeiramente, para criar uma nova biblioteca deve- se definir o espaço necessário para o armazenamento dos dados.
Conforme nossa abordagem, toda a biblioteca será definida num arquivo, entrentanto, deve- se ter em mente que podem ser utilizadas outras tecnologias, assim como banco de dados.
Logo após sua criação, a biblioteca deve ser nomeada.
Além disso, também é interessante, mas não obrigatório, deixar breves descrições para que ela possa ser identificada mais adiante, preparando- a para o uso posterior.
Conforme a necessidade de identificação, o nome, ou talvez um identificador externo deve ser único, evitando problemas de ambiguidade.
O fluxo de atividades para a criação de uma nova Biblioteca pode ser visto na Figura 4.26.
Criar Method Content Continuando o fluxo do Guia, o próximo passo é criar o Method Content, ou seja, definir o conteúdo dos PDSs.
O Method Content possui diversos elementos a serem definidos, assim como papéis, atividades, tarefas e ferramentas.
Desta forma, variando conforme o que será utilizado para a construção do PDS, pode- se obter diferentes elementos num Method Content.
Conforme o objetivo deste Guia, mostraremos apenas o fluxo para a construção de elementos de definição de ASs, visto na Figura 4.27.
O fluxo de atividades visto na Figura 4.27 apresenta o fluxo para a criação de Artefatos de Software e, como pode ser visto, a construção depende da criação de Tipos de Informação e Contêineres.
Em a primeira atividade de criação são adicionados tipos de informação ao Method Content.
Posteriormente são adicionados os contêineres, reponsáveis por organizar os tipos de informações, agrupando- os.
Por fim, a definição de artefato é criada através da seleção dos tipos de informações e contêineres desejados.
A construção de ASs não possui um fluxo complexo, precisando apenas de dois, no máximo três, passos para ser concluída.
A definição de ASs deve ser feita de forma detalhada, por isso é importante utilizar os contêineres, agrupando as informações quando necessário, porém, isto não é obrigatório.
Em a Figura 4.28 é apresentado o diagrama que explica como configurar os artefatos conforme nossa abordagem.
Esta configuração só pode ser feita quando os conteineres e tipos de informações a serem utilizados já estiverem criados.
Conforme esse diagrama, devese inserir os contêineres selecionando também o tipo de relacionamento entre eles e o artefato.
Definir Process Structure Após criar o Method Content, segundo o Guia, já é possível incluir o Process Structure.
Sendo assim, o próximo passo é criar a estrutura dos PDSs.
Esta atividade é quase exclusiva, pois deve ser feita para cada PDS existente.
O Process Structure também possui diversos elementos a serem definidos, na verdade, ele funciona como um espelho do Method Content, refletindo todos os elementos existentes no conteúdo, assim como papéis, atividades, tarefas e ferramentas, com exceção de que, esses elementos só deverão existir, caso sejam necessários para a estruturação do PDS.
Conforme o objetivo deste Guia, mostraremos apenas o fluxo para a construção de elementos de definição de ASs, que pode ser visto na Figura 4.29.
O fluxo de atividades visto na Figura 4.29 apresenta o fluxo para o uso da definição de ASs.
Após a seleção da definição de um ou mais artefatos (primeira Atividade), todo o resto deve ser também utilizado, ou seja, o uso dos contêineres (segunda Atividade) e tipos de informação (última Atividade) devem ser feitos em cascata.
Durante a utilização dos elementos internos dos ASs, pode- se também selecionar o tipo de uso que deve ser feito.
Esta característica permite que o uso de um artefato possa ser diferente de sua definição, desde que este seja um subconjunto.
Ou seja, pode- se em tempo de uso desistir de alguns Tipos de Informação ou mesmo Contêineres, dependendo do que se desejar.
Este tipo de utilização, embora seja possível neste momento é muito mais comum durante a fase de tailoring, adaptação e geração de famílias de processos.
Publicar Processo A última atividade do Guia é reponsável por exportar os dados armazenados na biblioteca.
Como foi dito anteriormente, esses dados são armazenados num arquivo XMI preparado para troca posterior.
Porém, permitir o uso apenas de arquivos do tipo XMI não é suficiente para que exista troca de dados entre outras ferramentas.
Ou seja, deve ser possível de se utilizar a biblioteca, ou ao menos os dados que ela possui, a partir de outras ferramentas, principalmente ferramentas comuns ao uso na indústria.
Desta forma, a publicação permite troca de dados para diferentes ferramentas, mesmo que estas não utilizem arquivos do tipo XMI.
Para a quantidade de ferramentas capazes de utilizar os dados contidos na biblioteca, pode- se exportar- los em arquivos do tipo Html ou XHML, através da especificação padronizada por a W3C 6 e OOXML, padrão Microsoft para Office Open XML's vocabularies and document representation and packaging 7, entre outros.
Diante deste contexto, o Guia criado permite à publicação a partir de o momento em que se define qual o tipo de arquivo a ser exportado, partindo então para uma decisão sobre o que deve ser publicado.
Para isto, deve- se escolher entre dois níveis de publicação:
O primeiro nível (a) diz respeito a publicação do PDS como um todo;
Já o segundo nível (b) permite a publicação apenas de ASs, independente do PDS.
Ambos os níveis possuem uma tomada de decisão sobre o que exatamente deve ser publicado.
Conforme a Figura 4.30, as atividades referentes ao nível (a) permitem uma escolha entre Method Content, Process Structure ou toda a Spemxt Library.
Desta forma pode- se extrair todos os dados existentes.
O fluxo de atividades em (b) servem para a publicação exclusiva de ASs, ecolhendo- se entre sua definição, o seu uso, ou ambos.
Em nossa abordagem, assim como na UML, utilizamos os termos source e target para definir os elementos participantes de um relacionamento:
Source ­ has ­\&gt; target.
Regras Estruturais As regras estruturais servem para garantir o valor semântico do domínio de autoria de artefatos, no tocante a utilização do metamodelo.
A regra estrutural fundamental é:
Regra E0:
Nenhum auto-relacionamento deve ser feito entre a mesma instância.
Evita- se então que um elemento seja &quot;pai «ou &quot;filho», diferenciando- se um target de um source.·
Regra E1:
Um artefato deve possuir ao menos &quot;um tipo de informação «ou &quot;um container».
Ou seja, não devem existir artefatos vazios.·
Regra E2:
Os relacionamentos entre artefatos só podem ser feitos através da metaclasse WorkProduct_ Relationship.·
Regra E3:
Os relacionamentos entre contêineres só podem ser feitos através da metaclasse ContainerDefinition_ Relationship.·
Regra E4:
Os relacionamentos entre tipos de informação só podem ser feitos através de seus relacionamentos internos, definidos em nível M2.·
Regra E5:
Os relacionamentos entre artefatos e contêineres devem ser feitos através da metaclasse ArtifactContainer_ Relationship.·
Regra E6:
Os relacionamentos entre artefatos e tipos de informação devem ser feitos através da metaclasse ContainerFragment_ Relationship.·
Regra E7:
Os relacionamentos entre contêineres e tipos de informação devem ser feitos através da metaclasse ArtifactFragment_ Relationship.
Regras para Reuso Existem cinco níveis de reuso definidos na Seção 4.3.7: Content, extension, local contribution, local replacement e reference.
A regra fundamental para a utilização dos conceitos de reuso é:
Regra R0:
Nenhum dos níveis de reuso pode ser aplicado mais de uma vez entre os mesmos elementos.
Isto é expressado em OCL da seguinte forma:
I -- Quanto a utilização de apenas um nível numa mesma hierarquia as regras definidas são:·
Regra R1:
O reuso do tipo content deve reutilizar tanto a estrutura quanto o conteúdo.
Desta forma, ao se aplicar esse tipo, o elemento source do relacionamento deverá adquirir toda a estrutura do elemento target, assim como todo o seu conteúdo.·
Regra R2:
O reuso do tipo content não pode ser utilizado entre um elemento source Contêiner e um elemento target Artefato.·
Regra R3:
O reuso do tipo content não pode ser utilizado entre um elemento source Tipo de Informação e um elemento target Artefato.·
Regra R4:
O reuso do tipo content não pode ser utilizado entre um elemento source Tipo de Informação e um elemento target Contêiner.·
Regra R5:
O reuso do tipo content deve reutilizar a estrutura.
De esse modo, ao se aplicar esse tipo de reuso, o elemento source do relacionamento deverá adquirir toda a estrutura do elemento target.·
Regra R6:
O reuso do tipo extension deve reutilizar toda a estrutura interna do elemento que está sendo reutilizado.·
Regra R7:
O reuso do tipo extension somente pode ser utilizado entre elementos de mesma metaclasse.·
Regra R8:
O reuso do tipo local contribution deve reutilizar a estrutura interna do elemento a ser reutilizado.
Desta forma, um elemento source obterá a mesma estrutura hierárquica de seu target, aliada a estrutura que já possuia anteriormente.·
Regra R9:
Em o reuso local contribution, todo elemento a ser reutilizado será sempre adicionado após o último elemento da mesma hierarqui no source.·
Regra R10:
Em o reuso local contribution, todo elemento a ser reutilizado será sempre adicionado após o último elemento da mesma hierarqui no source.·
Regra R11:
Em o reuso local contribution, caso haja conflito de reuso por motivos de existência do mesmo elemento em mesmo nível de hierarquia, este elemento não será afetado.·
Regra R12:
Em o reuso local replacement, os elementos internos do elemento target deverão substituir os elementos internos de um source.·
Regra R13:
Em o reuso reference, um elemento source apenas referência um elemento target, entretanto não é criada estrutura física.
II -- Quanto a utilização de mais de um nível numa mesma hierarquia as regras definidas são (estension pode ser sobreescrito.
Vide reconstrucão da regra R5):·
Regra R14:
O reuso do tipo extension, quando aplicado, deve ser feito de forma que englobe o elemento de maior nível hierárquico (mais próximo de a raiz possível).
Pois, não faz sentido aplicar- lo mais de uma vez numa mesma hierarquia.·
Regra R15:
Quanto a utilização de mais de um o reuso do tipo extension não deve aplicado de forma fique em nível hierárquico inferior a qualquer outro tipo de reuso.·
Regra R16:
O reuso do tipo extension pode ser sobrescrito por todos os tipos de reuso, com exceção de reference.
Em o que se constitui a nossa abordagem para a Autoria de Artefatos de Software, foram definidas algumas características a serem atendidas.
Tais características foram elaboradas para possibilitar uma melhoria em relação as propostas já existentes e analisadas no Capítulo 3.
De essa forma, visamos construir uma série de conceitos para atingir o nosso objetivo de estrutura artefatos, no tocante a conseguir introduzir tais características de maneira tal que não comprometesse esse trabalho.
Haja visto, foram abordados os seguintes conceitos:·
Paradigma de construção -- em nossa abordagem os artefatos são vistos como uma união de fragmentos de informação definidos através de estrutura bem definida.
Este paradigma se opõe ao paradigma atual, onde artefatos são elementos monolíticos, auto-contidos e fechados.
A escolha por um paradigma praticamente oposto ao utilizado na maioria dos PDSs atuais, foi feita com base na nossa hipótese de que o controle das informações de um artefato estruturado pode ser melhorado, em relação a um artefato monolítico, no tocante a estruturação, categorização, organização, controle de versão e reuso;·
Guia de construção -- foram definidos diagramas com fluxos de atividades mostrando quais atividades, etapas ou passos são necessárias para se realizar a autoria de artefatos.
Embora nenhuma outra abordagem analisada apresente algo nesse sentido, acreditamos (hipótese H2) que a utilização de um Guia permite construções mais bem definidas, pois o guia representa um processo a ser seguido, diferentemente de produção ad hoc;·
Escopo da abordagem -- a abordagem permite a construção de quaisquer tipos de artefatos, desde que eles estejam no conjunto dos artefatos analisados com base nos processos RUP e SCRUM.
A modelagem de outros tipos de artefatos, vistos outros diferentes processos, não é garantida;·
Separação de Conteúdo -- assim como no SPEM v2, nossa abordagem possui uma clara divisão entre a estrutura do processo (Process Structure) e o seu conteúdo (Method Content).
Ou seja, a hierarquia de atividades, ou disciplinas, definidas na maioria das vezes por estruturas do tipo Work Breakdown Structures (WBS) está separada da definição dos papéis, atividades e artefatos, entre outros elementos de PDS.
Com base nesse conceito definido no SPEM v2, acreditamos na hipótese (H3) de que separando um PDS nesses dois níveis é possível se obter adaptabilidade de processos.
Desta forma, pode- se utilizála como princípio para estruturar os conceitos de reuso de estrutura e conteúdo, tanto de artefato quanto de suas informações.
Em relação a representação da nossa abordagem, ao optarmos por desenvolver uma linguagem própria, verificamos que seria necessário atender a uma série de requisitos, principalmente com relação a UML.
Por isso, da mesma forma como foi definido na UML, utilizamos a técnica de especificação da sintaxe da linguagem, para só depois definir sua semântica.
Temos por base as convenções e tipologia definidas em.
Nosso metamodelo compreende os seguintes níveis de formalismo:·
Sintaxe: Define quais os contrutores existentes na linguagem, mostrando como podem ser construídos a partir de outros construtores.
Foram utilizados dois níveis de sintaxe:
Como pode ser visto no Apêndice, nossa abordagem possui um metamodelo completo que utiliza a mesma notação da UML.
Além disso, na Seção 5.1 é apresentada a linguagem concreta, feita em XMI e derivada da utilização do MOF.·
Semântica: Define os significado dos construtores utilizados na linguagem, bem como o que representam.
Em nossa abordagem foram definidos três níveis de semântica:
Por fim, uma vez que o metamodelo foi definido utilizando os princípios de empacotamento definidos na UML, houve a necessidade de especificar os níveis de conformidade a serem utilizados, definindo os pontos de conformidade a serem implementados por Tool Vendors.
Em esse sentido foram definidos dois níveis de conformidade:·
Extended Method Content, que define a utilização dos pacotes responsáveis por a criação apenas de elementos de definição de PDS.
Esse nível se constitui num ponto de conformidade para implementadores que necessitem apenas definir bibliotecas de conteúdo;·
All, que define a utilização de todos os pacotes do metamodelo.
Este nível estabelece a implementação de todo o metamodelo, focando na construção de PDSs completos e reutilizáveis.
Em este capítulo apresentamos as formas de verificação desta abordagem.
As análises foram feitas com base em testes analíticos, comparando este trabalho com outras abordagens existentes.
A verificação aqui apresentada aplica tudo o que foi discutido nos capítulos anteriores, demonstrando na prática exemplos de uso da abordagem proposta.
Contudo, implementamos uma ferramenta de suporte para demonstração da nossa solução.
O restante deste capítulo se apresenta da seguinte forma:
Em a Seção 5.1 é apresentado o protótipo desenvolvido para a aplicação da proposta, tecnologias utilizadas, arquitetura, funcionalidades e implementação;
Em a Seção 5.2 apresentam- se os cenários de testes, utilizando comparações de forma analítica;
E, por fim, a Seção 5.3 apresenta as nossas conclusões sobre a abordagem após a execução dos testes.
Com o objetivo de automatizar e colocar em prática a abordagem proposta, foi desenvolvida uma ferramenta de autoria de artefatos de software chamada Software Artifact Specification Tool (SwAT).
Juntamente com sua utilização foi feita uma avaliação deste trabalho.
Tecnologias Utilizadas Durante o desenvolvimento do protótipo foram utilizadas diferentes tecnologias e ferramentas.
Em esta Seção serão apresentadas as principais tecnologias utilizadas.
Eclipse Modeling Framework O Eclipse Modeling Framework (EMF) (Steinberg, 2008) trata- se de um arcabouço para desenvolvimento de modelos baseados no MOF, com suporte a geração de código através de linguagem Java.
Além disso, o EMF provê persistência dos dados utilizando XMI, linguagem padrão para definição de troca de dados da UML.
Quanto a geração do código, o EMF cria a base do modelo, constituída de Java Interfaces e sua implementação, utilizando Java Classes.
Já a geração da Interface Gráfica é feita baseada no padrão Adapter, possibilitando visualização e edição do modelo através de um editor básico.
Os modelos definidos por o EMF são baseados no ECore.
O ECore pode ser considerado uma implementação simples do MOF, sendo utilizado para definir a sintaxe e a semântica dos modelos manipulados por o EMF.
Isto implica na capacidade de construir elementos como classes, interfaces e associações.
Basicamente, os modelos criados a partir de o EMF são formados por EClasses (elementos equivalentes às classes definidas no MOF) as quais podem ter EAttributes (elementos equivalentes as propriedades definidas no MOF) e, por fim, é possível estabelecer relacionamento entre as EClasses (esses relacionamentos são equivalentes à associações definidas no MOF).
IBM Rational Modeler (RSM) O IBM Rational Software Modeler (RSM) é uma ferramenta Case desenvolvida por a IBM Rational Software.
Foi construída para facilitar modelagem de sistemas Orientados a Objetos utilizando UML.
O foco dessa ferramenta é sua capacidade de permitir a modelagem visual dos conceitos definidos por a Model Driven Development (MDD) (Atkinson &amp; Kühne, 2003).
Desta forma, essa ferramenta possibilita:
Modelagem específica de domínio utilizando UML;
Criação de diagramas simples, com base em uma modelagem visual e assistente de gera documentos e relatórios a partir de os modelos UML;
E suporte a desenvolvimento descentralizado, facilitando a decomposição, comparação e merge do modelo.
Além disso, essa ferramenta possui suporte para construção de modelos do tipo ecore, sendo compatível com o EMF.
Devido a esse fato, o desenvolvimento do modelo feito sobre o RSM pode ser importado por o EMF, permitindo a geração de código e implementação do modelo.
Tal característica facilita os testes sobre a modelagem, uma vez que pode ser feita automaticamente.
Visão Geral Embora existam esforços referentes a definição de PDSs, pouco se fala em Autoria de Artefatos de Software.
Geralmente, durante um Projeto e de acordo com o PDS utilizado, diferentes ferramentas ou técnicas de captura de conhecimento serão realizadas, com objetivo de se conseguir os ASs necessários para obter um Produto de Software.
Entretanto, toda a questão sobre a definição do Artefato é praticamente ignorada, dado o fato que tais ferramentas ou técnicas possuem maior foco em preenchimento da informação.
Além disso, a existência de diversos tipos de ASs diferentes, causa um aumento da dificuldade de seu preenchimento (responsável) e entendimento (leitor), ainda mais quando tais artefatos são feitos de forma distribuída.
Sendo assim, a utilização de uma ferramenta que automatize parcial ou completa a definição e uso dos ASs poderá trazer significantes melhorias.
Diante desse contexto, o protótipo de ferramenta SwAT foi desenvolvido com o objetivo de permitir a definição e uso de ASs, dentro de o domínio de PDSs.
Escopo e limites da ferramenta protótipo Sob o ponto de vista do Engenheiro de Conhecimento, é necessário que exista uma interação que permita a definição dos ASs, para conduzir- lo a um correta configuração do Method Content.
Para o Engenheiro do Processo, deve ser possível utilizar a biblioteca construída a partir de o Engenheiro de Conhecimento, para montar o Process Structure.
Tendo isso em mente, foi elaborada uma ferramenta que auxilia a Autoria de Artefatos de Software.
De um modo geral, a ferramenta permite:·
permite a Autoria de Artefatos conforme definido no Capítulo 4, utilizando os princípios de separação de conteúdo (Method Content) e estrutura (Process Structure);·
verificar problemas que surgem durante a autoria, ou seja, problemas de integridade, de campos entre outros;·
importar, carregar e salvar os modelos construídos, permitindo a troca de dados através de outras ferramentas que venham a implementar esta abordagem utilizando os mesmos princípios de extensão da UML e do SPEM v2.
A execução (enactment) de PDSs não faz parte do escopo dessa abordagem.
De essa forma, não é necessária sua implementação nessa ferramenta.
Entretanto, é possível preencher os ASs e visualizar- los com base nas informações em que se constituem.
Arquitetura A arquitetura da SwAT é dividida em camadas funcionais de acordo com a Figura 5.1.
Meta Model Meta Meta Model Infra-- estrutura:
Eclipse Project Em essa camada estão as funcionalidades básicas para a criação de um plug-in baseado no Projeto Eclipse1.
Eclipse é uma comunidade para produtos de código-livre, de os quais seus projetos possuem foco em construção de uma plataforma extensível e aberta.
De essa forma, o protótipo utiliza- se de plug-ins desenvolvidos para o Eclipse, reutilizando o seu editor e toda a infra-estrutura de seu WorkBench, assim como o JFaces e o SWT para construção de aplicações Rich Client Platform (RCP).
Infraestrutura: EMF Assim como o Eclipse, o Eclipse Modeling Framework também provê funcionalidades de infraestrutura reutilizáveis e por se constituir basicamente do ECore, fornece diversas funcionalidades de modelagem, tais como:
Persistência em XMI ou Objeto Relacional, validação de integridade de modelo e gerência dos dados do modelo com utilização de transação.
Modelo A camada de modelo possui toda a implementação do metamodelo proposto no Capítulo 4.
Toda a implementação foi feita com a utilização de linguagem Java, dessa forma, nesta camada também estão os contratos e restrições, feitos a partir de Java Interfaces.
Interface Gráfica A interação entre a ferramenta e o seu usuário é realizada através desta camada.
Toda a interface gráfica utiliza SWT e baseia- se no conceito de Views, Perspectives e Wizards, assim como os encontrados na plataforma Eclipse.
Isto ocorre por o fato da ferramenta SwAT funcionar como um plugin para o Eclipse, estendendo suas funcionalidades.
Funcionalidades Em esta sessão estão dispostas as funcionalidades básicas da ferramenta de autoria SwAT.
Para especificar- las, foi tomado como partida à visão do modelador.
As funcionalidades aqui apresentadas foram modeladas com a utilização de UML em dois diagramas bastante comuns:
Diagrama de Casos de Uso e Diagrama de Atividades, somente para as principais funcionalidades.
Em esse sentido, utilizamos a ferramenta de modelagem Rational Software Modeler.
As funcionalidades principais da SwAT estão definidas nos pacotes:·
Artifact Authoring -- as funcionalidades existentes nesse pacote possuem relação com a autoria de ASs, permitindo a criação dos construtores definidos na extensão do SPEM v2.·
Process Authoring -- as funcionalidades existentes nesse pacote possuem relação com a autoria de PDSs, permitindo a criação dos construtores de processos, já existentes no SPEM v2 e redefinidos na extensão proposta neste trabalho.·
Authoring Configuration -- as funcionalidades existentes nesse pacote configuram o projeto de autoria, permitindo a criação de pacotes de bibliotecas, separando o conteúdo do processo em si.
Durante o projeto da ferramenta SwAT, mais especificamente durante sua fase de análise e elaboração, foi tomada a decisão de modelar cada funcionalidade como um caso de uso, tomando os devidos cuidados em relação as dependências e relacionamentos existentes.
Para facilitar a visualização, foram modeladas quatro perspectivas, agrupando os casos de uso conforme similaridade e que serão apresentadas com mais detalhes a seguir.
Perspectiva de Configuração Em essa perspectiva estão os casos de uso responsáveis por as funcionalidades referentes a configuração básica do projeto de autoria.
Além disso, nessa mesma perspectiva são encontrados dois atores referentes aos papéis Administrator e Authoring Project Configurer, que são responsáveis por os casos de uso desta perspectiva, Figura 5.2.
A seguir estão descritos os casos de uso o cujo papel Administrator é responsável:
CRUD -- Project -- este caso de uso é na verdade um caso de uso composto, pois agrupa as funcionalidades de criação, remoção, atualização e recuperação do Projeto de Autoria.
Um Projeto de Autoria nada mais é do que um projeto SwAT que possibilita a autoria de PDSs, assim como também permite a autoria de ASs.
Para uma melhor visualização desse caso de uso, os fluxos básicos para os cenários de criação e remoção se encontram nos diagramas de atividades das Figuras 5.3 e 5.4, respectivamente.
Como pôde ser percebido através dos casos de uso anteriores, as funcionalidades de persistência de dados foram agrupadas.
Para maior facilidade e reuso de modelo, os casos de uso foram modelados com a utilização de UML Building Blocks.
Essa técnica de modelagem permite o aproveitamento de blocos de construção que podem ser utilizados em diversos pontos do mesmo projeto.
O Building Block modelado para prover tal facilidade chama- se CRUD (sigla para as funcionalidades Create, Retrieve, Update e Delete) e pode ser visto na Figura 5.6.
Entretanto, é importante entender que embora as quatro funcionalidades de CRUD estejam agrupadas através de UML Include Relationship, marcadas através do estereótipo include, não existe a obrigatoriedade de implementação de todas estas funcionalidades.
Embora o Building Block possa ser utilizado por completo, as vezes não existe tal necessidade, permitindo apenas um uso parcial.
Mesmo assim, todas às vezes que utilizaremos o CRUD, este será por completo.
Perspectiva Method Content Em esta perspectiva estão os casos de uso responsáveis por as funcionalidades referentes à criação de uma biblioteca de conteúdo.
O responsáveis por os casos de uso desta perspectiva é o papel Engenheiro de Conhecimento, como visto na Figura 5.7.
Destaque para o caso de uso CRUD -- Artifact Definition Elements, que será detalhado mais adiante e apresenta o fluxo utilizado para construir a especificação dos artefatos.
Os casos de uso cujo papel de Engenheiro de Conhecimento é responsável são:
CRUD -- Method Content -- este caso de uso representa as funcionalidades de criação, remoção, atualização e recuperação do Method Content.
Um Method Content, como visto anteriormente na Seção 2.4, nada mais é do que o conteúdo a ser utilizado para a estruturação de PDSs.
Para a conclusão desse caso de uso é necessário também a execução de outros três casos de uso.
Estes casos de uso estão descritos a seguir.
CRUD -- Process Definition Elements -- nesse caso de uso estão as funcionalidades de criação, remoção, atualização e recuperação dos elementos pertencentes ao Method Content.
Existem inúmeros elementos que podem ser adicionados, assim como papéis, atividades, tarefas, guias, ferramentas, entre outras.
O fluxo básico para o cenário de criação desse caso de uso se encontra no diagrama de atividade da Figura 5.8, que apresenta um fluxo paralelo de possíveis elementos a serem adicionados.
CRUD -- Artifact Definition Elements assim como o caso de uso anterior, neste estão funcionalidades para elementos pertencentes ao Method Content, exceto que, apenas elementos relacionados a extensão proposta.
Desta forma, apenas os elementos artefato, contêiner e tipos de informações podem ser adicionados, removidos, alterados ou recuperados.
Este caso de uso põe em prática um dos objetivos deste trabalho, pois permite a construção de artefatos de forma que sua organização interna esteja bem estruturada.
Por ser bastante complexo, apresentaremos quatro diagramas de atividades, explicando- os em seguida.
A Figura 5.9 apresenta o diagrama de atividades com o fluxo principal.
Como pode ser visto as atividades necessárias para que seja possível obter uma boa definição do artefato são:
Criar os tipos das informações necessárias, agrupar- las em contêineres, quando necessário e finalmente a criação dos artefatos.
Já na Figura 5.10 está o diagrama com o fluxo esperado para a atividade, que é utilizada para a criação dos tipos de informações.
Tal fluxo é bastante simples, bastando determinar o tipo da informação e, caso necessário, inserir um pequeno conteúdo descritivo para uma melhor identificação posterior.
Essa descrição é totalmente opcional, porém com o seu uso é possível definir vários níveis de descrição (i.
e descrição principal, breve descrição, nome de apresentação, propósito) assim como vários níveis de seções para criar notas ou comentários em categorias.
A criação de contêineres fica por conta do diagrama da Figura 5.11.
Esse diagrama contém o fluxo esperado para a atividade, que é utilizada para a criação dos contêineres.
A o criar um contêiner é necessário preencher todos os atributos obrigatórios e assim como no diagrama anterior, caso necessário, pode- se inserir um pequeno conteúdo descritivo.
Esse Diagrama de Atividades é um pouco mais complexo, pois apresenta duas iterações diferentes.
Uma de elas é a iteração para o agrupamento de tipos de informação que é feita em três atividades:
Seleciona- se um tipo de informação desejado;
Define- se o índice, como se trata de um relacionamento ordenado, caso não seja definido, ficará na ordem em que o tipo de informação foi adicionado;
E, por fim, agrupa- se o tipo de informação confirmando a escolha.
A outra iteração é responsável por o aninhamento de contêineres, permitindo relacionamentos do tipo parent/ child.
Além disso, como se trata de um relacionamento ordenado, pode- se alterar a ordem de construção determinando o &quot;nível de aninhamento».
Por último, o fluxo para a criação da definição de ASs está representado através do diagrama da Figura 5.12.
Como pode ser visto, para criar uma boa definição de Artefatos de Software deve- se primeiro definir Quais contêineres Ou tipos de informações serão utilizados.
Isso ocorre por que o fluxo permite a adição de ambos paralelamente.
Em a verdade, o que ocorre é que um As pode possuir ambos, entretanto, é requisito, visto na Regra E1, que exista ao menos um de eles.
Ou seja, não deve ser possível que exista um As vazio.
Em esse fluxo pode ser visto também que durante a adição dos contêineres deve- se selecionar o tipo de relacionamento desejado e qual o índice.
Specify Elements Relationships -- este caso de uso permite relacionar todos os elementos do Method Content através de relacionamentos específicos.
Assim, é possível relacionar atividades com papéis, artefatos com tipos de informações, entre outros.
Perspectiva Process Structure Em essa perspectiva estão os casos de uso responsáveis por as funcionalidades referentes a criação da estrutura de PDS a partir de uma biblioteca existente.
Dentro de a nossa abordagem o único papel passível de construção de processos é o Engenheiro de Processo, que é o ator dos casos de uso dessa perspectiva.
O diagrama de casos de uso pode ser visto na Figura 5.13.
Como pode ser visto na Figura 5.13, os casos de uso principais são CRUD -- Process Structure e Create Process Family and Adaptabilities, descritos a seguir:
CRUD -- Process Use Elements -- neste caso de uso estão as funcionalidades de criação, remoção, atualização e recuperação dos elementos pertencentes ao Process Structure.
Existem inúmeros elementos que podem ser criados para formar a estrutura de um PDS, assim como papéis, atividades, tarefas, guias, ferramentas, entre outras.
CRUD -- Artifact Use Elements -- assim como o caso de uso anterior, neste também estão funcionalidades para elementos pertencentes ao Process Structure, exceto que, apenas elementos relacionados a extensão proposta.
De essa forma, apenas os elementos artefato, contêiner e tipo de informação podem ser criados, removidos, alterados ou recuperados.
Este caso de uso põe em prática um dos objetivos deste trabalho, pois permite a criação do uso de ASs de forma estruturada.
Use Method Content Elements -- por fim é possível alinhar a estrutura do processo conforme os elementos existentes no Method Content.
Os elementos de uso, criados para a estrutura do processo, devem utilizar dos elementos de conteúdo.
Este caso de uso põe em prática outro objetivo deste trabalho, pois permite a utilização da definição dos ASs.
Create Process Family and Adaptabilities -- este caso de uso adiciona uma funcionalidade que está fora de o escopo deste trabalho, porém, de bastante ajuda para àqueles que desejarem criar famílias de processos.
De essa forma, como o metamodelo proposto no Capítulo 4 estende as propriedades do SPEM v2, permitir a criação de famílias de processos e dar suporte à adaptabilidade de processos de software foi uma escolha feita para manter a compatibilidade com o nível de complacência escolhido, ou seja o SPEM v2 Complete.
Além disso, este caso de uso estende as funcionalidades existentes no caso de uso CRUD -- Process Structure.
Perspectiva de Artefato de Software Em esta perspectiva estão os casos de uso responsáveis exclusivamente por as funcionalidades sobre ASs.
Como pode ser visto na Figura 5.14, nesta mesma perspectiva são encontrados os atores referentes aos papéis Artifact Responsible e Artifact User.
Os casos de uso desta perspectiva representam funcionalidades além de o foco do trabalho em questão e foram modelados para fins de complemento da ferramenta SwAT.
Os casos de uso desta perspectiva são:
Fill Artifact -- a partir de o momento em que a estrutura do Processo está pronta é possível criar instâncias dos elementos existentes.
Desta forma, com este caso de uso é possível preencher os artefatos de um PDS já previamente criado.
Conforme foi visto anteriormente, os artefatos deverão ser preenchidos de acordo com os tipos de informação contidos, mantendo a organização previamente definida na fase de autoria.
Use Read-Only Artifacts -- da mesma forma que é possível preencher as instâncias dos artefatos, também pode- se utilizar- las somente para leitura.
Sendo assim, o conteúdo das informações existentes nos As previamente preenchidos podem ser visualizadas sem a necessidade exportação ou qualquer tipo de publicação.
Export Artifact -- embora as instâncias de As possam ser lidas dentro de a própria ferramenta, isto é bastante limitado, pois a ferramenta não possui um editor avançado.
Para corrigir esse problema, a funcionalidade de exportação de dados foi modelada, possibilitando a troca de dados através de outros tipos de arquivos.
Interface Um ponto importante para à autoria de ASs é a iteração entre a ferramenta e os atores usuários.
Uma das formas para aumentar a compreensão e facilitar a interação entre os usuários e a ferramenta é através da utilização de uma interface amigável.
Tais interfaces geralmente são ambientes gráficos do inglês Graphical User Interfaces (GUI).
Dado o fato da ferramenta SwAT estender as funcionalidades do ambiente Eclipse através de plug-ins, são utilizados os conceitos de interfaces gráfica tais como:
Views, menus e perspective.
A interface definida e integrada ao modulo de interface da arquitetura da SwAT.
Um visão geral da interface gráfica da SwAT é apresentada na Figura 5.15.
Como pode ser visto a GUI está dividida entre várias janelas diferentes:·
em a) está a janela Package Hierarchi View que provê uma iteração com os projetos existentes e seus conteúdos internos, apresentados de forma hierárquica.·
em b) e c) estão as janelas que disponibilizam as funcionalidades da biblioteca Spemxt.
Em b) a biblioteca é aberta através de uma View amigável, permitindo o manuseio da biblioteca a partir de seis modos diferentes, inclusive em árvore, constituindo a linguagem abstrata, entretanto, ainda sem uma notação em diagramas.
Já em c) é apresentada em formato XMI o que consiste na linguagem concreta.·
em d) é mostrada a janela Problems View que permite ver os problemas e erros encontrados na biblioteca durante o processo de autoria.
Essa janela também disponibiliza a localização dos problemas encontrados durante a validação do modelo.·
por fim, em e) está a Properties View.
Essa janela permite a iteração com os atributos e relacionamentos existentes entre os elementos do modelo.
Em outras palavras, estão os atributos tanto da biblioteca quanto dos elementos que a constituem.
O objetivo da Figura 5.15 é apresentar um visão geral da ferramenta mostrando suas telas de maneira geral.
Durante o restante desta Seção essas telas serão discutidas detalhadamente.
A janela Package Hierarchi View, vista em a) a partir de a Figura 5.15, é reponsável por a criação e manutenção dos projetos atrelados a autoria de ASs.
O principal objetivo dessa janela é permitir que atores do papel Authoring Project Configurer façam seus trabalhos, criando o projeto de autoria e a biblioteca Spemxt conforme os casos de uso apresentados anteriormente.
A criação do projeto é padronizada por o próprio Eclipse, entretanto, a criação da biblioteca seque os passos a seguir:·
inicialização: Para criar uma nova biblioteca deve- se selecionar o projeto ao qual ela deva ser adicionada e utilizar o pop-up de criação através do botão direito do mouse.
Em esse com que surja uma tela de fácil entendimento para a criação da biblioteca, bastando agora apenas configurar algumas opções.·
passo 0: Neste passo basta selecionar SpemxtComplete ou SpemxtMethodContent de entre as opções existentes, para criar uma nova biblioteca juntamente com o seu wizard, Figura níveis de conformidade (compliance levels), o All, que implementa todo o metamodelo e o Extended Method Content, apenas para a utilização de definições e criação de conteúdo.·
passo 1: Após decidir qual tipo de biblioteca deve ser criada é necessário também decidir onde ela será criada.
Este é o primeiro passo do wizard e por padrão define que a biblioteca deve sempre ser criada no projeto pré-selecionado e mais especificamente no pacote src.
Esse passo permite configurar exatamente o caminho e projeto da biblioteca.
Como exemplo de possível configuração, poderia ser criado um pacote bibliotecas, e configurar a criação nesse pacote ao invés de o caminho padrão.·
passo 2: Em esse último passo deve ser selecionado qual o construtor inicial.
Como deve ser criada uma nova biblioteca, basta selecionar o construtor Method Library, Figura 5.19.
Em a janela principal, vista em b) na Figura 5.15, estão as abas para visualização e manuseio do modelo criado e adicionado a biblioteca.
A partir de a Figura 5.20 podem ser vistas as abas utilizadas para permitir uma melhor iteração entre o usuário e a biblioteca.
Tais abas são explicadas a seguir:·
em a) está a primeira aba, chamada Selection.
Tomada como aba padrão ela apresenta a biblioteca de forma hierárquica dependendo de qual elemento está selecionado.
A partir de um elemento e selecionado pode- se interagir com ele, criando novos elementos na mesma hierarquia (irmão) ou interior (filho), conforme o metamodelo e suas restrições;·
em b) está a aba Parent que apresenta todos os elementos anteriores (pai) a um elemento e selecionado.
Essa aba é útil quando existe a necessidade de detectar todos os elementos que estejam acima na hierarquia existente;·
em c) está a aba List que permite a visualização em lista de todos os elementos de mesmo nível hierárquico (irmãos) a um elemento e selecionado;·
em d) está a aba Tree que permite uma visualização em árvore.
Desta forma, a partir de um elemento e selecionado, serão mostrados todos os seus elementos filhos;·
em e) está a aba Table que apresenta uma tabela utilizada para relacionar tipo e instância dos elementos selecionados.
Desta forma pode- se estabelecer explicitamente qual a metaclasse que o elemento da biblioteca instancia, já que nem sempre é possível fazer esta verificação apenas visualizando os ícones de cada um desses elementos;
A partir de a aba Selection pode- se selecionar os elementos que se deseja alterar ou remover e visualizar os elementos já criados.
Além disso, ainda é possível adicionar novos elementos, conforme a Figura 5.21.
Para isto deve- se utilizar um pop-up menu que possibilita a criação de novos elementos (New Child) ou elementos irmãos (New Sibling).
Em a janela Problems View, vista em d) na Figura 5.15, está a janela responsável por relatar os problemas e erros existentes durante a criação da biblioteca.
Como sabemos a criação da biblioteca na verdade é uma instância do metamodelo apresentado no Capítulo 4.
Por isso, ao criar uma biblioteca estamos na verdade criando um modelo que deve obedecer às restrições e regras existentes no metamodelo.
Entretanto, mesmo com as restrições existentes nem sempre é possível deixar um modelo num estado correto.
Contudo, para descobrir a existência desses tipos de erros ou inconformidades devemos então validar o modelo.
A Figura 5.22 apresenta uma validação feita sobre um elemento da biblioteca.
Conforme pode ser visto, existe uma série de conformidades, dispostas na janela de validação.
Desta forma todos os erros encontrados serão apresentados, inclusive erros em elementos filhos.
Isto ocorre por que a validação funciona em cascada, procurando por inconformidades existentes no interior de um elemento selecionado, portanto, seus relacionamentos fortes, ou seja do tipo composição, serão validados.
Diferentemente, caso o elemento selecionado seja um elemento folha, apenas seus atributos e relacionamentos serão verificados.
Como o elemento validado está numa hierarquia bastante alta, todos os erros de conformidade existentes em seus elementos filhos serão revelados.
Esses problemas de validação estão dispostos através de mensagens e estas mensagens possuem um formato típico.
O formato em que se apresentam não traduz a localização exata de problema, embora traga informações importantes sobre qual restrição e como supostamente resolver.
Desta forma, é necessário completar a quantidade de informações para uma melhor correção desses problemas.
Em a Figura 5.23 está a janela Problems View, que complementa as informações sobre as inconformidades mostrando qual o elemento incorreto e sua localização.
Além disso, todos os elementos que possuem problemas são marcados com um ícone diferente e bastante intuitivo, apontando os problemas localmente.
Essas marcações são feitas em todos os problemas, marcando todo o caminho até encontrar o elemento problemático, tanto no Package Explorer quanto na janela principal.
A última janela a ser detalhada é a Properties View, Figura 5.24.
Conforme supracitado, nessa janela deve estar os atributos e relacionamentos existentes num elemento selecionado.
Como pode ser visto na Figura 5.24, os atributos existentes estão alinhados ao lado esquerdo da janela, enquanto que os valores devem ser informados ao lado direito.
Além disso, pode ser visto o ícone para entrada de dados, indicando que o valor do atributo pode ser informado.
Existem seis tipos de entradas:
Entradas de texto, onde podem ser inseridos valores de caracteres;
Em essa Seção serão apresentados os testes e exemplos feitos sobre a abordagem.
Para isto foram criados dois testes diferentes, apresentando o uso da abordagem através do protótipo da ferramenta SwAT e o de diagramas UML.
Como se trata de uma extensão conservativa do SPEM v2 e da UML, essa abordagem se configura na criação de diversas camadas de abstração, previstas em.
Partindo desse pressuposto, uma idéia mais clara pode ser obtida a partir de o ponto de vista da Figura abordagem está dividida em três níveis possíveis:
Metamodelo (M2), modelo (M1) e instância Em este trabalho, como normalmente é feito na literatura, através de trabalhos como (Lee, 2002) e (Borsoi &amp; Becerra, 2008), vistos nos Capítulo sobre Trabalhos Relacionados (mais especificamente na Seção 3.2), consideramos a camada M2 uma abstração para a criação da camada M1, a camada M2 como camada de abstração para a camada M1 e, por fim, a camada M1 definirá como será a camada M0.
Em este sentido, a camada M3 é o próprio MOF.
Para uma maior clareza, a Figura 5.2 ilustra essas quatro camadas.
A camada M3 é responsável por definir M2 e a si própria.
Em essa camada estão o MOF e o MOF Versioning.
O MOF é capaz de definir outros metamodelos e através de operações de reflection consegue se auto definir.
Ainda utilizando reflection, o MOF Versioning acaba por inserir a capacidade de versionamento através de VersionedExtent, como pode ser visto na Figura 5.26.
Como pode ser observado, a Figura 5.26 contém apenas uma pequena ilustração do metamodelo através de Artifact que se relaciona com uma coleção de Information, que pode do tipo Text, Image ou List.
Isto foi feito para facilitar o entendimento do metamodelo, pois na realidade ele possui mais de 100 metaclasses.
Utilizando o M2, poderíamos, por exemplo, criar um artefato A que possui título, uma imagem com rótulo da seguinte forma:
Artifact A $= (Text:
Diferente da camada de artefatos, a camada M1, definida como Camada de Processos, possui elementos mais específicos, justamente para a modelagem dos artefatos específicos de processos de desenvolvimento de software.
Em essa camada são utilizadas instâncias de elementos da camada M2.
Em M1 devem estar instâncias das metaclasses definidas na camada de artefatos para a construção de classes que modelem os artefatos de um processo específico.
Como resultado disso, não existe um modelo M1 definitivo, variando conforme a necessidade de criação ou adaptação do processo a ser modelado.
A exemplo, na Figura 5.26 está modelado um documento de Visão, do RUP, que instancia Artefato, de M2.
Em essa mesma figura pode ser visto ainda que o documento de Visão se relaciona com Requisitos e Stakeholders, ambos instâncias de tipos de Informação.
Por fim, na camada M0, neste trabalho definida como Camada de Projetos, estão as instâncias reais dos artefatos construídos com informações reais de um projeto que executa um PDS específico, definido em M1.
Estas instâncias são condizentes com a camada M1, pois são instâncias do que foi modelado nessa camada.
Desta forma, como pode ser visto na Figura 5.26, existe uma instância de Visão que contém dois stakeholders, Marcos S. E Bastos R. E dois requisitos, Requirement $= Imprimir Fatura;
Requirement $= Pagamento em Cartão).
Embora o foco da nossa abordagem seja a autoria de ASs, programamos os conceitos existentes através de uma linguagem com base na UML.
De a mesma forma como feito no SPEM v2, existem duas extensões claras:
Uma de elas é definida através de um metamodelo que estende o SPEM v2 restringindo- o a um domínio mais específico;
A outra é baseada na criação de novos Partindo deste princípio, foram feitos dois cenários de testes diferentes, monstrando:
A utilização abordagem através da ferramenta SwAT, que é uma implementação do metamodelo proposto;
E a aplicação do catálogo de estereótipos definidos através de comuns.
Os Cenários foram testados a partir de a utilização de artefatos do RUP.
Ao invés de modelar todo o PDS, foram escolhidos diferentes artefatos das disciplinas desse processo, procurando atender aos pontos chaves da abordagem.
Escolhemos artefatos conforme o nível de complexidade, utilização e necessidade.
Entretanto, essas variáveis foram determinadas através de experiência própria.
Em esse sentido e conforme nosso objetivo, escolhemos então modelar os artefatos:
Glossário de Negócios, da disciplina de Modelagem de Negócios; (
A2) Glossário e (A3) Especificação de Caso de Uso, da disciplina de requisitos; (
A4) Modelo e (A5) Modelo, da disciplina de Análise e Design.
Levando- se em consideração que tais artefatos já foram definidos por o RUP, deve- se então fazer um mapeamento dos templates originais, geralmente em Microsoft WordTM, formando um modelo conforme nossa abordagem.
A Figura 5.27 mostra como isto deve ser feito.
Iniciamente, em a) existe uma conceitualização de como é um artefato, partindo de seu template.
Deve- se então selecionar quais os tipos de informação e como agrupar- las de forma a conseguir estruturar o artefato conforme o nossa proposta, mapeando os conceitos do template, para conceitos existentes no nível M2.
Por fim, deve- se construir o modelo de nível M1 utilizando- se dos elementos existentes no nível M2, previamente mapeados.
O objetivo geral dos testes é mostrar que cada um desses artefatos pode ser definido através da camada M2, criando elementos na camada M1.
Além disso, será apresentada uma amostra da camada M0, com o intuito de demonstrar que é possível se obter uma instância real de artefatos ao final do processo de autoria.
Todavia, para que isto seja possível deve- se levar em conta a ordem de construção ser feita.
Tal ordem, previamente definida na Seção 4.6, será seguida, permitindo também que o Guia para Autoria de Artefatos de Software seja testado.
Cenário de Teste 1 Em esse primeiro cenário será utilizado o protótipo da ferramenta SwAT para instanciar a camada M2, criando assim a camada M1.
Este protótipo implementa a camada M2, dando suporte a construção da camada M1.
Além disso, a ferramenta de suporte também implementa o Guia para Autoria de Artefatos de Software, automatizando- o.
Criação de Novo Projeto de Autoria De esta forma, vamos então criar um novo PDS, inciando uma autoria.
Esse é o primeiro passo a ser executado, segundo o Guia.
Como este passo já está implementado, basta utilizar a ferramenta para criar um novo projeto de autoria do Processo de nome SwAT.
Test.. Os próximos passos a serem seguidos são:
Criar uma nova biblioteca;
Criar um Method Content para a biblioteca e criar um Process Structure.
O responsável por a publicação não está implementado nessa versão do protótipo.
Criação de Biblioteca Seguindo então para o próximo passo, devemos criar uma nova biblioteca, Figura 5.28.
Este passo é composto por dois sub-passos:
Criar o espaço de biblioteca e nomear e descrever biblioteca.
Sendo assim, criaremos um arquivo XMI que suporta o modelo de nível M1.
Embora neste trabalho o arquivo XMI seja considerado a biblioteca (SPEMxt Library), na verdade ele é uma implementação de um dos níveis de formalismo definidos para a construção de linguagens com base na OMG, sendo a linguagem concreta desta abordagem.
Para completar, nomearemos esta biblioteca de RUP Test e a descreveremos como Uma biblioteca para testes utilizando o RUP, tudo isto pode ser visto na Figura Criação do Method Content Após criamos a biblioteca vamos partir para a autoria de ASs iniciando com a criação do Method Content.
Como já definido anteriormente, o Method Content é como se fosse uma biblioteca específica que guarda apenas os elementos que participam da definição do que pode ser utilizado em PDSs.
Ou seja, definições de artefatos, atividades, papéis, entre outros.
Para o nosso contexto, é importante definir a criação dos elementos necessários para a autoria de artefatos.
Para isto, precisamos criar os tipos de informação e contêineres necessários para organizar detalhadamente todos os artefatos a serem modelados.
Embora seja simples, este passo requer um pouco mais de perícia para ser executado.
Sendo assim, partindo do princípio descrito na Figura 5.27, primeiro faremos um mapeamento de todos os artefatos escolhidos para só então modelar- los.
A o identificarmos a estrutura, podemos obter então a modelagem em nível M1.
Em a Figura 5.29, está uma amostra do resultado obtido no mapeamento.
Em esta amostra estamos utilizando o artefato Especificação de Caso de Uso, que possui diversas seções e diferentes tipos de informação.
Como o mapeamento foi feito a partir de templates definidos no software Rational Unified Process, optamos por manter os nomes e termos em inglês, evitando possíveis problemas na tradução.
Para uma melhor exposição, a Figura 5.29 está organizada em colunas, correpondendo as metaclasses utilizadas do modelo M2.
As respectivas instâncias, agrupadas no modelo M1, estão abaixo de suas metaclasses.
Como exemplo, a classe FlowOfEvents, afixada na segunda coluna (da esquerda para a direita) indica que ela é uma instância da metaclasse ContainerDefinition.
É importante notar que a primeira coluna a esquerda é uma captura do artefato real, sendo possível observar seu nome e os títulos das seções que o constituem.
Uma análise dos elementos modelados para especificar o documento Especificação de Caso de Uso pode ser vista a seguir:·
Use-Case Specification, como é a representação do artefato foi modelado como uma instância da metaclasse ArtifactDefinition;·
em este exemplo nós apresentamos cinco tipos diferentes de informação.
Todas elas são subclasses de FragmentDefinition:
SpecificInformationElements. Uma vez que queremos testar a flexibilidade da nossa abordagem, preferimos utilizar os tipos genéricos em detrimento de a definição de um tipo específico;·
em a Figura 5.29 também são mostrados os relacionamentos existentes entre esses elementos, demonstrados com a utilização de cinco diferentes tipos de setas.
É necessário também deixar claro que cada seta representa uma metaclasse diferente:
De a metaclasse ArtifactFragment_ Relationship meta-class, pois Use-Case é uma instância de um fragmento do tipo Group.
Este relaciomanento é denotado a partir de ligações em seta tracejada;
Esta amostra foi escolhida por representar alguns elementos primordiais nessa abordagem, pois houve aumento no reuso e em sua organização estrutural, uma vez que o artefato agora está representado numa linguagem UML-Like.
Desta forma, os mesmo elementos podem ser utilizados para compartilhar informação sobre os possíveis tipos, a estrutura e o conteúdo.
A criação desse modelo utilizando a SwAT foi feita acrescentando- se os tipos de informação, contêineres e artefatos encontrados no mapeamento, tomando o cuidado de criar as ligações entre eles.
Como era de se esperar, a implementação desse passo confere ao que está definido no Guia de Autoria, entretanto, na SwAT pode ser feito de forma mais flexível.
Isto se deve ao fato de seguir estes três sub-passos (criar tipos de informação, criar contêineres e criar artefatos) exatamente como no guia ser menos vantajoso do que deixar- los livres, ou seja, menos engessados.
Mesmo assim, para a utilização com maior clareza, recomenda- se seguir o Guia.
Os tipos de informação foram divididos em vários pacotes para permitir uma maior facilidade de identificação.
Este tipo de divisão pode ser feito para facilitar a visualização dos elementos, pois o modelo tende a crescer e tornar- se muito grande.
Os pacotes são:·
Abreviação -- instância da metaclasse LabeledText que representa um texto rotulado.
Um exemplo real da aplicação de uma abreviação seria:
Abreviação $= (rótulo:
Doutor, valor:
Dr);· Definição -- instância da metaclasse LabeledText.
Um exemplo real seria:
Definição $= (rótulo:
Reta, valor: (
Conceito primitivo) É um conjunto infinito de pontos alinhados de tal forma que os segmentos com extremidades em dois quaisquer desses pontos);·
Termo -- instância da metaclasse LabeledText.
Um exemplo real seria:
Termo $= rótulo:
Login, valor:
Login de usuário da aplicação;·
Abreviações, Acrônimos, Definições e Termos -- instâncias da metaclasse List que representa uma estrutura de dados do tipo lista para um conjunto de elementos que podem ser ordenados, enumerados e rotulados.
Estas listas agrupam os tipos de informação Abreviação, Acrônimo, Definição e Termo, respectivamente.
Um exemplo real da aplicação de lista seria:
Caso a lista seja ordenada, RS virá primeiro que RUP, caso seja enumerada são adicionados identificadores de numeração, caso seja rotulada, pode- se adicionar um rótulo extra para cada elemento da lista.
Análise e Modelo de Design, que são:·
Análise e Design de Casos de Uso -- ambos são instâncias da metaclasse BehaviorDiagram que representa um diagrama comportamental da UML;·
Análise e Design de Classes -- ambos são instâncias da metaclasse StructureDiagram que representa um diagrama estrutural da UML;·
Diagrama de Casos de Uso e Diagrama de Classes -- ambos são instâncias da metaclasse SimpleImage que representa uma imagem, figura ou instantâneo.
Em o presente caso, ambas instâncias são utilizadas para representar os diagramas de análise e design anteriores.
Caso de Uso, que são:·
Ator -- instância da metaclasse Group, que representa um agrupamento de tipos de informação a serem estruturados de forma ad hoc, &quot;sob medida «e exclusiva.
Em este caso, estamos tratando de um Ator que executará um Caso de Uso.
Como pode ser observado na Figura 5.30, o tipo de informação texto, representado através de uma instância de Text é agrupado para representar este tipo de informação.
Embora este caso seja simples, poderíamos adicionar outros tipos de informação, tornandoo um caso mais complexo.
Um exemplo real de utilização de um Ator seria:·
Caso de Uso -- instância da metaclasse Group.
Em este caso, estamos tratando de um Caso de Uso como definido por o RUP.
Como pode ser observado na Figura 5.30, este Caso de Uso contém os tipo de informação texto nome e descrição, representados através de instâncias da metaclasse Text.
Um exemplo real de utilização seria:
Caso de Uso $= (nome:
Login, descrição:
Caso de uso para a ação de login executada· Condição -- instância da metaclasse Group.
Em este caso, estamos tratando de uma condição a ser obedecida na execução de um Caso de Uso.
Foram utilizados dois tipos de condição:
Pré-condição, que sugerem uma condição a ser obedecida anteriormente ao início do Caso de Uso;
E pós-condição, a ser obedecida após a execução do Caso de Uso;·
Fluxo -- instância da metaclasse Group.
Em este caso, estamos tratando do fluxo a ser seguido durante a execução de um Caso de Uso.
Em esse sentido foram definidos dois tipos de fluxos:
O fluxo básico a ser seguido e fluxo alternativo, que pode determinar algum fluxo excepcional;·
Ponto de Extensão -- instância da metaclasse Group.
Conforme a necessidade de alterações num Caso de Uso, este artefato é definido por o RUP com a capacidade de ser estendido a partir de um ponto de extensão.
Sendo assim, um ponto de extensão é um conjunto de informações que possibilita identificar como e onde um Caso de Uso deverá ser estendido;·
Requisito -- instância da metaclasse Group.
Um requisito é uma exigência imprescindível para a consecução de um Caso de Uso, sendo, é um agrupamento de informações sobre exigências especiais;·
Condições, Pontos de Extensão, Fluxos e Requisitos -- instâncias da metaclasse List que, como visto anteriormente, representa uma estrutura de dados do tipo lista, permitindo a criação de um conjunto de elementos que podem ser ordenados, enumerados e rotulados.
Partindo para o próximo passo, após serem definidos os tipos de informação utilizados podemos então organizar estas informações utilizando os contêineres.
Conforme a Figura 5.31, os contêineres estão agrupados no mesmo pacote dos artefatos.
Entrentanto, falaremos da modelagem dos relacionamentos entre artefatos, contêineres e tipos de informação utilizando a SwAT posteriormente.
Em a Figura 5.31, ainda podem ser vistos os atributos referentes a descrição do artefato Modelo de Análise.
A utilização de um conteúdo de descrição permite introduzir informações específicas sobre um artefato, assim como finalidade, escopo e diferentes tipos de descrição.
Em o caso específico dos artefatos selecionados, utilizamos os contêineres para representar as seções dos artefatos.
Sendo assim, todas as seções são instâncias da metaclasse ContainerDefinitions.
Tais seções, vistas na Figura 5.31 são:·
Introdução -- este contêiner foi modelado para poder agrupar o tipo de informação utilizada para descrever um dado artefato;·
Referências -- modelado para agrupar os tipo de informação responsáveis por representarem as referências e citações utilizadas em dado artefato;·
Definições, Acrônimos e Abreviações -- modelado para agrupar os tipos de informação que estruturam os termos de glossário utilizados num dado artefato;·
Fluxo de Eventos e Fluxos Alternativos -- modelado para conter os tipos de informação necessários para representar os fluxos existentes na execução de um Caso de Uso;·
Pré-condições e Pós-condições -- modelado para organizar os tipos de informação necessários para a representação das condições de execução de um Caso de Uso;·
Requisitos Especiais-modelado para organizar os tipos de informação necessários para a representação das requisitos especiais, ou seja, além de os já existentes para um sistema de informação e que servem para a execução de um Caso de Uso;·
Pontos de Extensão -- modelado para organizar os tipos de informação utilizados para identificar as extensões existentes num Caso de Uso.
Os artefatos modelados foram:
Especificação de Caso de Uso, Glossário, Glossário de Negócios, Modelo.
Todos são instâncias da metaclasse ArtifactDefinitions e, além disso, possuem uma instância da metaclasse ContentDescription, que permite adicionar descrições como finalidade, nome de apresentação, contexto e escopo.
Por último na Figura 5.32 apresentamos a parte do modelo que permite utilização de instâncias de metaclasses de relacionamentos entre artefatos, contêineres e tipos de informação.
Em essa mesma Figura, em é visualizada a existência de uma instância da metaclasse ArtifactContainer_ Relationship, que permite o relacionamento entre artefatos e contêineres, em estão instâncias da metaclasse ContainerDefinition_ Relationship, que permite o auto relacionamento entre contêineres, em estão instâncias da metaclasse ContainerFragment_ Relationship, que permite o relacionamento entre contêineres e tipos de informação, por fim, em estão instâncias da metaclasse ArtifactFragment_ Relationship, que permite o relacionamento entre artefatos e tipos de informação.&amp;&amp;&amp;
Assim como foi visto na modelagem dos tipos de informação, durante a modelagem dos relacionamentos também foram criados três pacotes para facilitar a visualização:·
introducao_ referencias -- relacionamento do tipo &quot;contêiner x contêiner «que instancia a metaclasse ContainerDefinition_ Relationship e relaciona as seções Introdução e Referências do artefato Especificação de Caso de Uso.
Desta forma Introdução será &quot;Pai «de Referências, que será subseção de Introdução;·
introducao_ definições -- relacionamento do tipo &quot;contêiner x contêiner «que instancia a metaclasse ContainerDefinition_ Relationship e relaciona as seções Introducão e Definições, Acrônimos e Abreviações, ambas fazem parte do artefato Especificação de Caso de Uso;·
fluxoDeEventos_ fluxosAlternativos-relacionamento do tipo &quot;contêiner x contêiner «que instancia a metaclasse ContainerDefinition_ Relationship e relaciona as seções Fluxo de Eventos e Fluxos Alternativos, ambas fazem parte do artefato Especificação de Caso de Uso;·
fluxoDeEventos_ fluxos-relacionamento do tipo &quot;contêiner x tipo de informação «que instancia a metaclasse ContainerFragment_ Relationship e relaciona a seção Fluxo de Eventos com o tipo de informação Fluxos que é uma instância de List e representa o fluxo básico.
Fluxos é uma lista que possui o tipo de informação Fluxo, como conteúdo interno.
Fluxo é uma instância da metaclasse Group;·
fluxosAlternativos_ fluxos-relacionamento do tipo &quot;contêiner x tipo de informação «que instancia a metaclasse ContainerFragment_ Relationship e relaciona a seção Fluxos Alternativos com o tipo de informação Fluxos;·
precondicoes_ condicoes- relacionamento do tipo &quot;contêiner x tipo de informação «que instancia a metaclasse ContainerFragment_ Relationship e relaciona a seção Pré-condições com as condições a serem satisfeitas antes da execução do Caso de Uso.
Como visto anteriormente, condições é uma lista de condição.
Esses tipos de informação instanciam as metaclasses List e Group, respectivamente;·
poscondicoes_ condicoes- relacionamento do tipo &quot;contêiner x tipo de informação «que instancia a metaclasse ContainerFragment_ Relationship e relaciona a seção Pós-condições com as condições a serem satisfeitas após a execução do Caso de Uso;·
requisitosEspeciais_ requisitos -- relacionamento do tipo &quot;contêiner x tipo de informação «que instancia a metaclasse ContainerFragment_ Relationship e relaciona a seção Requisitos Especiais com os requisitos necessários para a execução do Caso de Uso.
Em esse sentido, como visto anteriormente, requisitos é uma lista de requisito e instanciam as metaclasses List e Group, respectivamente;·
pontosDeExtensao_ pontos -- relacionamento do tipo &quot;contêiner x tipo de informação «que instancia a metaclasse ContainerFragment_ Relationship e relaciona a seção Pontos de Extensão com os pontos de extensão existentes no Caso de Uso.
Em esse sentido, como visto anteriormente, pontos de extensão é uma lista de ponto de extensão e instanciam as metaclasses List e Group, respectivamente.
Glossário de Negócios e Glossário, que são:·
glossarioDeNegocios_ definições -- relacionamento do tipo &quot;artefato x tipo de informação «que instancia a metaclasse ArtifactFragment_ Relationship e relaciona o artefato Glossário de Negócios com os tipos de informação Abreviações, Acrônimos, Definições e Termos.
Todos estes tipos de informação são instâncias da metaclasse List;·
glossario_ definições -- relacionamento do tipo &quot;artefato x tipo de informação «que instancia a metaclasse ArtifactFragment_ Relationship e relaciona o artefato Glossário com os tipos de informação Abreviações, Acrônimos, Definições e Termos;·
secaoDefinicoes_ definições -- relacionamento do tipo &quot;contêiner x tipo de informação «que instancia a metaclasse ContainerFragment_ Relationship e relaciona a seção Abreviações, Acrônimos e Definições com os seus respectivos tipos de informação.
Modelo de Análise e Modelo de Design, que são:·
modeloDeAnalise_ diagramas -- relacionamento do tipo &quot;artefato x tipo de informação «que instancia a metaclasse ArtifactFragment_ Relationship e relaciona o arte-fato Modelo de Análise com seus diagramas de Análise de Caso de Uso e de Classes;·
modeloDeDesign_ diagramas -- relacionamento do tipo &quot;artefato x tipo de informação «que instancia a metaclasse ArtifactFragment_ Relationship e relaciona o artefato Modelo de Design com seus diagramas de Design de Caso de Uso e de Classes.
Enfim concluímos todos os passo de criação do MethodContent utilizando a SwAT.
Como foi apresentado, tanto os tipos de informação quanto os relacionamentos foram modelados em diferentes pacotes para fornecer uma melhor visualização.
Entretanto, não é aconselhável a divisão de instâncias da mesma metaclasse em diferentes pacotes.
Embora isso não faça diferença no modelo, pode- se cometer erros ao não visualizar as informações por estas estarem em outro pacote.
Isso também pode ocasionar uma pequena confusão no conceito de tipos de informação e reuso, pois estes tipos de informação e contêineres não pertencem necessariamente a um artefato específico, pelo contrário, são elementos a serem compartilhados.
Criação do Process Structure Partindo então para o último passo, usaremos tudo que foi definido no Method Content para criar o Process Structure.
Em a Figura 5.31 pode ser visto a utilização dos artefatos definidos no Method Content.
Em este exemplo o uso de elementos de definição não é demonstrado de forma efetiva.
Entretanto, isto permite que na camada M1, que contem modelos para PDS específicos, sejam criados processos independentes das modificações feitas no Method Content.
Como nosso foco é testar a autoria de artefatos, não faz sentido modelar todo um PDS para provar que a divisão entre definição e uso adiciona ganhos na modelagem, uma vez que isso já foi demonstrado em.
A Figura 5.33 apresenta a modelagem do Process Structure através da ferramenta SwAT.
Como pode ser visto, a estrutura do processo foi criada a partir de as classes existentes no Method Content.
Sendo assim, cada classe do Process Structure necessariamente possui uma relação com alguma classe de mesmo tipo do Method Content.
Este tipo de ligação é chamado de Method Content Trace.
A partir de a construção do Process Structure utilizando a ferramenta SwAT, conseguimos colocar em prática essa parte da abordagem.
Versionamento e Reuso Tendo em vista os testes feitos sobre a estruturação de artefatos, daremos continuidade a este cenário tratando sobre Versionamento e Reuso de informação, optando por utilizar uma visão com base nas camadas apresentadas na Figura 5.26.
A o se tratar de grandes quantidades de informações estruturadas, duas grandes questões a serem levadas em consideração são o controle de versão e reutilização.
De acordo com o cenário apresentado, essas questões transformam- se em necessidades, assim como em ambientes em que tais informações são manipuladas por várias pessoas e durante um longo período de tempo.
Versionamento Conforme visto na Seção 4.3.6, por meio versionamento é possível inspecionar as mudanças que ocorreram sobre alguma informação, guardando seus estados.
Desta forma, quando necessário, consegue- se reverter para uma mudança num estado anterior.
Entretanto, existem vários fatores que descaracterizam esse tipo de característica, portanto nem sempre é possível manusear todos os vários estados que pode possuir dada informação.
Atualmente, o controle de versões sobre artefatos é feito através de software do tipo SVN (Subversion) 2, dado o fato que apenas objetos reais, de nível M0 são versionados.
Além disso Softwares como esse tratam artefatos conforme blocos monolíticos de informação, impossibilitando discussões sobre os detalhes das modificações e possíveis inferências, como qual informação sofreu maiores alterações, por exemplo.
Embora sistemas como o SVN sejam bem adaptados quanto a utilização de artefatos apenas texto, assim como código-fonte ou arquivos do tipo txt, eles falham quando se trata de documentos mais complexos, assim como documentos do tipo Office, como documentos do Microsoft WordTM e Microsoft ExcelTM.
Reuso A reutilização permite que as informações sejam organizar com prudência, já que evita duplicações de partes de conteúdo ou estrutura comum.
Hoje em dia a reutilização de artefatos de software é feita através do uso de templates, que possuem espaços em branco a serem preenchidos.
Embora essa solução permita a reutilização da estrutura de artefatos, ela falha quanto a o reuso de conteúdo e, o que é ainda pior, reforça o uso de procedimentos do tipo´ cópia-e-cola, o que pode facilmente propagar as informações e gerar diversas inconsistências.
Em nossa abordagem, o reuso de informação é baseado em pontos de variabilidades.
Tais pontos consistem em firmar relacionamentos entre elementos de mesmo tipo, determinando características comuns ou particularidades.
Embora este tipo de nomenclatura seja mais usual em trabalhos sobre adaptação e tailoring de PDSs, também é possível determinar o reuso de infor2 subversion.
Tigris. Org mação utilizando esse mesmo princípio.
Em esse sentido, o próprio SPEM v2 especifica pontos próprios de variabilidade e, além disso, indica o curso a ser seguido para construir famílias de PDSs.
Entretanto, como o foco desta abordagem é a autoria de ASs, esta característica do SPEM v2 foi extendida, conforme pode ser visto na Seção 4.3.7.
De essa forma, adicionamos maior semântica e novas regras para a utilização do reuso, possibilitando, além de o reuso de estrutura, o reuso de conteúdo.
Integração De esta forma, essa seção tem como objetivo mostrar como nossa abordagem funciona em relação a controle de versão e reuso.
Tais características já estão integradas, provendo a capacidade de acompanhar as mudanças na estrutura e conteúdo de artefatos.
Para maior facilidade no entendimento, uma visão geral é apresentada Figura 5.34.
Essa figura apresenta uma ilustração dessas capacidades, mostrando diversas revisões nas camadas M2, M1 e M0.
Ela está organizada como uma tabela em a qual as colunas indicam as revisões e as linhas indicam qual a camada e os papéis que são responsáveis por as alterações.
Além disso em cada célula da tabela existe um conjunto de classes e observações que indicam o que foi modificado.
É importante entender que na Figura 5.34, as barras cinzas no alto de cada linha diz respeito à versão do metamodelo, processo ou projeto.
A Figura 5.34 também apresenta três atores, na coluna mais a esquerda, indicando qual o papel responsável por as modificações em cada camada:
O Tool Vendor é responsável por manter o metamodelo para autoria de artefatos, ou seja, a camada M2;
o Engenheiro de Processo é responsável por criar os modelos para definição e uso de artefatos utilizando a camada M2, ou seja, é responsável por a camada M1;
por fim, o Engenheiro de Software é responsável por criar o projeto na camada M0 que utilizará um processo definido na camada M1.
O mecanismo de versionamento pode ser visto a partir de a Revision:
0 (segunda coluna), quando foi feito o primeiro commit.
Em esta coluna uma representação da metaclasse ArtifactDefinition da camada M2, que foi utilizada para moldar os artefatos Especificação de Caso de Uso e Glossário, da camada M1.
Já na terceira coluna está a Revisão -- 1.
Em essa revisão houve uma pequena modificação em ArtififactDefinition.
Agora, ela possui o atributo mandatory que indica quando um artefato é, ou não, obrigatório no processo de desenvolvimento, indicando se ele deve ser criado e preenchido.
Ou seja, foi feita uma modificação apenas no nível M2, que possivelmente implicaria numa nova versão da ferramenta de modelagem de artefatos, que deve ser feita por o Tool Vendor.
Por esta razão, os artefatos modelados a partir de o metamodelo da Revisão -- 1 indicam se são obrigatórios.
Em o exemplo apresentado na Figura 5.34, o artefato Especificação de Caso de Uso é obrigatório, enquanto que Glossário não o é.
Outro fato que pode ser visto na Revisão -- 1 é que conforme houve modificação em M2, os modelos M1 e M0 também foram afetados.
Em esse sentido, ao alterar o metamodelo de nível M2, criando a nova Revisão -- 1, todas as novas instâncias de nível M1 se utilizarão dessas alterações.
De a mesma forma, um novo projeto de nível M0 que instanciar um processo modelado em M1 a partir de a nova revisão em M2.
Entretanto, em nossa abordagem, os projetos anteriores a essa revisão, assim como os processos modelados, não partilharão dessas alterações.
É importante perceber que o mecanismo de versionamento utilizado na nossa abordagem é baseado na integração com a camada M3, como visto na Figura 5.26.
Como resultado, todos os elementos do Metamodelo para a autoria de ASs estão relacionadas com a metaclasse VersionedExtent, do MOF Versioning.
Além disso, o MOF Versioning provê metaclasses para:
Controle e gerência de versionamento através de operações de:
Check-in, check-out, revert, delete, commit e look-up versions;
Identificação de versão, utilizando ids e rótulos;
Marcação de versões através de datas e timestamps;
Histórico de versões;
Utilização de sessões em revisões inseridas numa workspaces;
E, por fima criação de versões de baselines conforme suas configurações.
Em este caso a Figura 5.35 ilustra uma instância real do artefato Especificação de Caso de Uso, utilizando anteriormente.
Como pode ser visto, as caixas que estão dentro de os quadrados de contornos pontilhados representam os conteúdos deste artefato.
Sendo assim, essas caixas são instâncias das classes correspondentes, que estão dentro de as caixas em tom cinza e que foram definidas na Camada de Processos.
A o observar a Figura 5.35 é possível visualizar que o artefato é uma instância da classe UseCaseSpecification, podendo então ser preenchido utilizando informações de um projeto real.
Para fins de exemplo nós consideramos um caso de uso para o caso de Login.
Esse caso de uso possui:
Nome; Descrição;
Fluxos, um fluxo básico e alguns alternativos;
Requisitos; Précondições e pós-condições;
Além de atores.
Em esse exemplo temos que:·
Os fluxos definem o que o User deverá fazer para executar uma determinada ação do Caso de Uso.
Ou seja, o fluxo básico define o fluxo mais evidente ou esperado (como no exemplo:
&quot;use the ok option&quot;), enquanto que os fluxos alternativos definem os passos para algum comportamento excepcional (como no exemplo:
&quot;use the cancel option&quot;);·
os requisitos definem o que é necessário para executar um caso de uso, no exemplo existem os requisitos 3.1 Id must unique e 3.2 Password must be 6-8 characters, que na verdade mostram a necessidade de restrições para a validação dos campos Id e Password;·
as pré-condições 4.1 e 4.2 descrevem o estado inicial para a execução do caso de uso, ou seja, é necessário que o usuário a fazer login esteja cadastrado e que a página com o formulário de login esteja renderizada;·
a pós-condição 5.1 da uma idéia do estado esperado após a execução do caso de uso.
Desta forma, é essencial que o User esteja &quot;logado «na aplicação.
Cenário de Teste 2 metamodelo da UML, criando assim um modelo UML no nível de usuário.
O metamodelo para autoria de ASs e que define a camada M2 pode ser representado através de um catálogo de, este tipo de extensão é bastante limitado em comparação a extensão por meio de o próprio metamodelo.
Diante de algumas limitações, a autoria de artefatos não pode ser feita da mesma forma como no cenário de teste anterior, (Seção 5.2.2).
Partindo desse princípio, temos em mente que ao utilizar o catálogo de estereótipos perderemos algumas restrições necessárias mas que não puderam ser definidas, assim como os valores semânticos existentes em alguns conceitos destacados nesta dissertação.
As limitações são:·
Os relacionamentos obedecerão apenas os tipos de associações da UML, não suportando as restrições para relacionamentos entre diferentes tipos, assim como &quot;artefato x contêiner», &quot;contêiner x artefato», &quot;contêiner x tipo de informação «e &quot;artefato x tipo de informação».·
Os níveis de reuso podem ser utilizados, entretanto são meramente ilustrativos.·
O versionamento não pode ser garantido.
Uma vez que este mecanimos foi implementado na camada M3 é necessário que a distribuição UML a ser utilizada tenha sido construída com base no MOF Repository.·
A regras de restrição do metamodelo, definidas em linguagem OCL, foram utilizadas.
Assim como no cenário anterior, iremos utilizar uma ferramenta para facilitar esta tarefa.
Embora tenhamos desenvolvido uma ferramenta própria para apresentar o Cenário de Teste 1, neste cenário, por motivos de preferência e maior viabilidade, utilizamos a Case Tool proprietária IBM Rational Software Modeler.
Entretanto, esta ferramenta não implementa o Guia de Autoria de Artefatos, sendo assim, seguiremos o Guia manualmente.
Criação de Biblioteca De a mesma forma que no primeiro cenário, queremos criar um novo PDS para iniciar a autoria.
Como estamos utilizando o IBM Rational Software Modeler devemos criar um novo Projeto para modelar UML.
A Figura 5.36 apresenta a criação desse novo Projeto de Modelagem, que pode ser visto em a).
A criação de projetos utilizando essa ferramenta é feita utilizando wizards.
Já em c) esta nova biblioteca que foi feita através da adição de um novo Modelo de nome RUP Test. Agora já podemos criar a biblioteca adicionando um empacotador para o modelo.
Como se trata do uso de UML em nível de usuário, adicionamos um pacote de nome RUP Library, marcando- o com o estereótipo MethodLibrary.
Criação do Method Content O próximo passo é criar um novo PDS dando início a autoria.
Em esse sentido, a autoria de artefatos deve iniciar com a criação de um Method Content.
Para este fim foi criado o pacote UML de nome Content utilizando o estereótipo MethodContent, para identificar- lo como um pacote de conteúdo da autoria.
Em a Figura 5.38 estão os pacotes utilizados para a criação de um Method Content.
Desta forma, nessa Figura fica evidenciada a criação de outros três pacotes, visto em (A):
Artifacts, containers e fragments, com os respectivos estereótipos, ArtifactPackage, ContainerPackage e InformationPackage.
Com a utilização de estereótipos também é possível criar vários pacotes de informação.
Isso pode facilitar a divisão de fragmentos, porém, dificulta a visualização de um possível reuso posterior.
Sendo assim, optamos por dividir apenas a visualização dos artefatos, utilizando por base a criação de namespaces.
Desta forma, foram definidos diagramas UML de nível de usuário.
Tais diagramas são utilizados para gerar abstrações dos artefatos conforme a perspectiva necessária, visto em B. Além disso, na Figura 5.38 também é possível visualizar o pacote de biblioteca criado anteriormente, estando marcado com o estereótipo MethodLibrary, também visto em (A).
A descrição da biblioteca pode ser vista em (C) e as propriedades e atributos estão dispostas em (D).
Durante a criação do Method Content foi feito um paralelo entre o conceito de artefato a ser criado e seu modelo, assim como no Cenário de Teste 1.
Entretanto, no atual cenário de testes foi levado em consideração apenas o catálogo de estereótipos, que é mais restrito do que o metamodelo utilizado no cenário de teste anterior.
Entretanto, deve- se tomar cuidado em relação a metaclase base do estereótipo.
A exemplo, caso o estereótipo possua uma metaclasse do tipo relacionamento, este não pode ser aplicado em classes, mas sim, em associações.
Todos os estereótipos do catálogo podem ser vistos no Apêndice A. 8, assim como suas respectivas metaclasses base.
Embora sejam duas extensões totalmente diferentes do ponto de vista da UML, pode- se perceber através da Figura 5.39, que conceitualmente o resultado não parece demonstrar muitas diferenças.
Entretanto, é muito mais difícultada se chegar nesse resultado através dos estereótipos do que através do metamodelo, uma vez que existe menos semântica e restrições.
FragmentRelationship e estão agrupados no pacote associations (B), que faz parte do modelo.
A notação utilizada para expressar esses tipos de relacionamento é uma seta com diamente escuro, utilizado para denotar associações de composição da UML.
O próximo passo do Guia para Autoria é a modelagem dos contêineres.
Desta forma, adicionamos todos os contêineres mapeados dentro de o modelo adicionando- se o estereótipo ContainerDefinition.
Além disso, foram definidos os relacionamentos entre os contêineres, todos feitos através do estereótipo ContainerDefinitionRelationship e expressados através de setas com diamante branco, utilizados para denotar associações de agregação da UML.
Esses contêineres podem ser vistos na Figura 5.41, que apresenta um diagrama de nome Containers (mostrado em (D)).
Além disso, nessa Figura pode também ser visto a aplicação do estereótipo ContainerDefinition ao contêiner Actors (em (E)), assim como os tagged values existentes já previamente preenchidos (pode ser visto em (F)):·
briefDescription, utilizado para expressar uma descrição resumida do contêiner;·
mainDescription, utilizado para expressar a descrição principal do contêiner;·
kind, herdado do catálogo de estereótipos do SPEM v2, esse atributo não faz sentido nesse contexto, por isso não foi utilizado nesse caso, entretanto, seu valor determina qual metaclasse da UML ele esta representando;·
presentationName, utilizado para expressar um nome de apresentação para um contêiner;·
purpose, utilizado para expressar o propósito ou a finalidade do contêiner;
Por fim, na Figura 5.41 estão todos os relacionamentos que foram adicionados ao modelo, vistos através da espansão do pacote associations.
O próximo passo a ser seguido é a modelagem dos artefatos.
Adicionamos todos os artefatos mapeados, vistos na Figura 5.39, ao modelo, criando também os relacionamentos entre eles, os contêineres e os tipos de informação existentes.
Os artefatos foram modelados através de classes UML com a aplicação do estereótipo ArtifactDefinition.
Além disso, os relacionamentos existentes foram marcados com o estereótipos:·
ArtifactContainer_ Relationship, quando os relacionamentos são ligações entre artefatos e contêineres;·
ArtifactFragment_ Relationship, quando os relacionamentos são ligações diretas entre artefatos e tipos de informação;·
WorkProductDefinition_ Relationship, quando são utilizados auto-relacionamentos entre artefatos.
A notação utilizada para representar estes relacionamentos é uma seta com linha sólida, mas apenas a notação do auto-relacionamento determinado por o estereótipo WorkProductDefinition_ Relationship possui navegabilidade.
Conforme pode ser percebido, existe uma notação própria Em todo caso, não existe nenhuma regra ou determinação semântica explicita para que isto seja feito.
Em a Figura 5.42 é apresentada a parte final da modelagem do Method Content.
Em (F) estão todos os artefatos, modelados através de classes UML com a aplicação do estereótipo ArtifactDefinition.
Em (G) estão os diagramas criados para definir diferentes visões lógicas do modelo, em cada uma de elas, está um dos artefatos presentes nos testes da abordagem.
Todos esses diagramas podem ser visualizados no Apêndice B. 2.
Mais uma vez os relacionamentos podem ser vistos no pacote associations, em (H).
Estes relacionamentos.
Criação do Process Structure A modelagem do Process Structure acontece da mesma forma como no primeiro cenário, ou seja, basta definir um elemento de processo que precise utilizar um elemento de definição do Method Content.
Conforme a Figura 5.43, criamos o uso do artefato Especificação de Caso de Uso, lado direito da Figura, que pertence ao pacote AtifactsUse, com o estereótipo ArtifactPackage.
Além disso, o pacote que estrutura o Process Structure possui o estereótipo Desta forma, utilizamos o diagrama ArtifactUse, visto a direita da Figura, para criar a visão lógica que representa a ligação entre o Uso do artefato e sua definição.
Esta ligação foi feita através do relcionamento de dependência definido por o próprio SPEM v2.
Em esse capítulo foram utilizados dois cenários para avaliar a abordagem proposta, de forma a comprovar, mesmo que de forma analítica, as hipóteses levantadas na Seção 4.8.
Com o uso possível definir sua autoria.
A ferramenta SwAT, elaborada especificamente para fins de teste do mtamodelo se mostrou bastante prestativa, permitindo efetuar uma avaliação em forma de prova de conceito, apresentando os problemas e erros existentes, permitindo suas correções.
Além disso, os testes feitos através da modelagem de artefatos reais, de processos reais, mostraram que a abordagem permite atingir o objetivo deste trabalho, que era prover a autoria de artefatos determinando maiores detalhes sobre suas estruturas de informação, Seção 1.4.
Por isso, afirmamos que, com bases nos testes, vencemos os desafios lançados no capítulo introdutório desse trabalho:
Embora não tenham sido feitos testes formais, algum estudo de caso aplicado em ambiente real, ou algum tipo de experimento, somos confiantes em afirmar que, devido a os testes feitos, as hipóteses:·
pode ser ao menos parcialmente satisfeita, uma vez que:
Os artefatos estão estruturados através de UML, que é uma estruturação bem formada;
Há categorização dos artefatos;
Tipificação das informação;
Organização estrutural e de conteúdo;
Controle de versão;
E reuso.
Entretanto, não podemos provar formalmente, que nossa abordagem é melhor nesse sentido, embora exista um sentimento positivo quanto a isso.· (
H2) não pode ser comprovada sem um teste exaustivo ou prova formal.
Entretanto, a utilização do Guia para a Autoria de Artefatos de Software, implementado tanto diretamente Podemos afirmar ainda, com base na experiência que tivemos na execução dos testes, que sem um Guia, a autoria de artefatos em detalhes poderia ser dificultada, uma vez que nenhuma das abordagens encontradas utiliza o mesmo paradigma.· (
H3) pode ser atendida, pois foi possível criar diferentes níveis de reuso através da utilização dos pontos de variabilidade definidos sobre elementos de Method Content.
Essa hipótese pode ser ainda expandida para englobar PDSs, uma vez que a especificação do SPEM v2 possui muitas provas de conceito implementadas através de ferramentas, diagramas e provas analíticas.
Por fim, diante de os destes feitos, corrigimos os problemas encontrados tanto na abordagem, quanto na sua implementação.
Tais problemas são descritos a seguir:·
Problemas resolvidos no contexto da abordagem:
Encontrados problemas no reuso de algumas partes dos artefatos, principalmente artefatos com grandes quantidades de informação e em versões mais maduras.
Desta forma, foram adicionados os conceitos de reuse, local contribution e local replacement, com base no que já havia sido definido no próprio SPEM v2.·
Problemas resolvidos no contexto da implementação como metamodelo:
Todos os novos tipos da abordagem.·
Problemas resolvidos no contexto da utilização da ferramenta SwAT:
Notamos que a visibilidade do modelo era bastante comprometida.
Conforme a necessidade de utilização de processos para a construção de produtos, em Engenharia de Software, o foco dos Processos de Desenvolvimento de Software é visar a um Produto de Software final a partir de a construção de vários Artefatos de Software.
Diante deste fato, problemas no tratamento de tais artefatos caracterizam um provável erro de paradigma, visto que ao tratar- los como elementos monolíticos, os processos desconhecem as interações e mudanças ocorridas nos artefatos durante sua evolução.
Diante deste contexto foram apresentados alguns desafios e os problemas descritos no Capítulo 1, todos culminando na solução de um objetivo comum:
Construir artefatos de forma que sua organização interna esteja bem estruturada e definir diversas versões, autores e estruturas de informação aos artefatos durante sua autoria.
A partir de o qual foi criada a Questão de Pesquisa para este trabalho:
Como deve ser a autoria de Artefatos de Software de forma que estes não sejam monolíticos?
Em este sentido, a construção de um modelo capaz de facilitar a estruturação e manipulação desses artefatos traz um novo paradigma, uma vez que deixa de orientar o processo as atividades, aumentando o foco nos artefatos, uma vez que serão mais bem estruturados.
Desta forma, neste trabalho foi feito uso de linguagens de especificação que permitem a representação de informações relacionadas aos artefatos presentes no processo utilizando conceitos de modelagem Orientada a Objetos.
Para que tal feito pudesse ser concretizado, houve a extensão do metamodelo SPEM v2 e da UML, apresentando soluções para versionamento, organização e estruturação lógica interna tanto no conteúdo quanto na estrutura, utilizando- se de informações com tipos bem definidos e compartilhados.
Por fim houve a criação de um ferramental para nossa abordagem que permitiu avaliar a capacidade de utilização do metamodelo.
A idéia de autoria de artefatos, juntamente com seus detalhes foi concretizada a partir de o seu uso no protótipo SwAT, visto no Capítulo 5, dando conta da solução das problemáticas citadas no Capítulo 1 e atendendo o objetivo supracitado.
Em esta seção são apresentadas algumas limitações deste trabalho:
Com foco em detalhamento de ASs em processos inteiros, assim como os utilizados em indústria de grande porte.
Além disso, não foram feitos estudos empíricos.
Entretanto, existem diversos pontos de extensão que permitem tal melhoria.
Em esta dissertação foram respondidas algumas questões importantes relacionadas à autoria de Artefatos de Software.
Apesar de esta contribuição, a abordagem ainda precisa ser melhorada, principalmente no quesito avaliação, com o objetivo de ser consolidada.
Apesar de avaliações iniciais terem demonstrado a aplicabilidade e corretude da abordagem, maiores investigações devem ser feitas quanto sua aplicabilidade na indústria.
Desta forma, alguns trabalhos a serem realizados futuramente estão listados a seguir:·
Melhorias a serem feitas na Abordagem:
­ Executar mais casos de testes:
Possivelmente, após a execução de novos casos de testes mais completos novos dados serão coletados, surgindo a oportunidade de se fazer novas avaliações;·
Ferramenta de Autoria de Artefatos: ­ Análise de desempenho:
Apesar de os testes realizados, é necessária a execução de testes reais e de grande porte utilizados na industria, a fim de verificar o desempenho e o comportamento da ferramenta nestes cenários.
Possivelmente possa ocorrer queda de desempenho conforme o aumento da biblioteca em que os artefatos se encontram.
De esse modo, uma avaliação destes pontos pode vir a ser importante e representa um relevante e provável futuro investimento.
O resultado desta avaliação permitirá prover melhorias na ferramenta.·
Guia de Autoria de Artefatos: ­ Aplicabilidade do guia de Autoria de Artefatos:
A aplicação do guia de composição definido neste trabalho em diferentes tipos de artefatos é indispensável para avaliação de sua aplicabilidade, consolidação e evolução.
