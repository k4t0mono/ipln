Frameworks e Padrões vêm sendo considerados como tecnologias importantes de reutilização em desenvolvimento de software.
Particularmente, linguagens de padrões têm sido usadas como uma alternativa à documentação tradicional de software.
O objetivo desta dissertação é avaliar e demonstrar as contribuições que uma linguagem de padrões pode trazer para o desenvolvimento de software, usando como um estudo de caso uma arquitetura de desenvolvimento de Sistemas de Apoio à Decisão (SAD) baseado em frameworks.
Esta arquitetura propõe o desenvolvimento de SADs específicos através da reutilização de frameworks de diferentes tipos, que desempenham diferentes papéis dentro de um SAD.
A arquitetura caracteriza a natureza destes frameworks, organiza- os em múltiplas camadas, e orienta o seu processo de adaptação e conexão.
Tentando resolver algumas das limitações identificadas nesta arquitetura, propõe- se uma linguagem de padrões para guiar o desenvolvimento e conexão de frameworks genéricos para o desenvolvimento de SADs específicos.
A linguagem endereça o problema complexo de conexão de frameworks, separando e interligando subproblemas independentes de conexão, dando soluções satisfatórias que consideram sempre aspectos de genericidade e adaptabilidade dos frameworks.
Com isto, espera- se resolver alguns dos problemas originais da arquitetura, melhorando a sua documentação e dando melhores soluções de projeto que facilitem o processo de adaptação e conexão de frameworks.
Em este trabalho, são descritas as características e as contribuições da linguagem de padrões proposta, ilustradas através de uma porção da linguagem que contempla um subproblema de conexão de frameworks.
A complexidade de desenvolvimento de software é cada vez mais crescente, e o processo de desenvolvimento é ainda muito baseado em empirismo e sujeito a erros.
Pode- se dizer que o paradigma da orientação a objetos (OO) surgiu com o objetivo de lidar melhor com a crescente complexidade de software, e aumentar a produtividade na tarefa de desenvolvimento de software.
Captura de elementos do mundo real para modelagem de software, facilidade de transição de modelos de análise para implementação, foco na representação de entidades de domínio ao invés de processos, etc., são algumas das propriedades da OO que contribuem para o desenvolvimento de software.
Acredita- se que uma das características mais importantes da OO é a de promover e aumentar a reusabilidade de software em geral.
Reutilização é um ponto chave para produtividade, sendo também um dos atributos considerados na avaliação de qualidade de software.
A tecnologia de reutilização ideal seria simplesmente conectar componentes de software prontos para criar um novo sistema.
Em a prática, a criação de software através da reunião e composição de componentes existentes não é muito fácil de ser obtida.
Mesmo antes da orientação da objetos surgir, algumas formas de reutilização já existiam em desenvolvimento de software.
A organização de funções e procedimentos em bibliotecas é uma das formas mais primitivas, que antecede a reutilização das chamadas Estruturas de Dados Abstratas ­ EDA (Abstract Data Structures -- ADS) e Tipos de Dados Abstratos ­ TDA (Abstract Data Types ADT).
Estas formas de reutilização favoreciam principalmente a reutilização de código.
Outras tecnologias de reutilização surgiram juntamente (e de certo modo paralelamente) com a OO, procurando contemplar a reutilização de outros elementos envolvidos na concepção de software.
Dentro de a OO, a reutilização de código é contemplada por o uso de bibliotecas de classes de uso geral, algumas vezes chamadas de toolkits, como aquelas encontradas na maioria dos ambientes de desenvolvimento OO para representar estruturas de dados (vetores, grafos, etc.) e interfaces gráficas.
A tecnologia de frameworks orientados a objetos endereça reutilização em maior escala, preocupando- se principalmente com o reutilização de projeto de software, o qual envolve muito mais empirismo e criatividade por parte de o desenvolvedor, quando comparado com a tarefa de implementação.
Frameworks podem ser definidos como &quot;um projeto reutilizável de uma parte ou de todo um sistema, que é representado por um conjunto de classes abstratas e pelo modo que elas interagem».
Eles definem os aspectos fixos de um (sub) sistema genérico de software, que são as responsabilidades comuns das classes e as colaborações básicas existentes, e deixam em aberto aspectos variáveis que devem ser determinados no processo de adaptação de um framework para representar um (sub) sistema concreto.
Simplesmente projetar software orientado a objeto não significa que ele vai ser potencialmente reutilizável e flexível.
Diversas técnicas, heurísticas, princípios de bom projeto, devem ser aplicados para criar software reutilizável e flexível.
Como argumenta, &quot;reutilização de software não acontece por acidente», o que é complementado em, &quot;a criação de software orientado a objeto é difícil, mas a criação de software orientado a objeto reutilizável é mais difícil ainda».
É sabido que só o que é bem concebido e modelado, levando em conta genericidade e flexibilidade, está apto a ser reutilizável.
Boas técnicas e heurísticas de projeto de software orientado a objeto são obtidas através de experiência.
Desenvolvedores experientes se depararam com diversos problemas recorrentes de projeto, e criaram soluções satisfatórias para resolver- los.
Eles não desenvolvem aplicações partindo do zero:
Reutilizam a sua experiência, aplicando e adaptando as soluções desenvolvidas na resolução de problemas recorrentes semelhantes.
Porém, isto muitas vezes é feito de modo empírico e intuitivo, quando o desenvolvedor tem sensações de &quot;déjà-vu», a de que já se resolveu problemas semelhantes, mas não se lembra dos detalhes.
A reutilização de experiência é o que diferência desenvolvedores experientes dos novatos.
Muitas vezes os novatos têm que passar por os mesmos problemas encontrados por os experientes, quando não existe registro e transferência do conhecimento desses desenvolvedores experientes para os novatos desfrutarem.
Frameworks e Toolkits são o resultado da experiência de desenvolvedores, que disponibilizam produtos para outros desenvolvedores reutilizarem e adaptarem às particularidades das suas aplicações.
O desenvolvedor que usa estes produtos não sabe como é sua construção interna, quais as decisões de projeto tomadas, etc., pois concentra- se principalmente em como adaptar esses componentes de software às suas necessidades.
Isto é importante quando ele quer tratar- los realmente como &quot;caixas-pretas, porém em muitas situações os desenvolvedores se sentem desencorajados a reutilizar algo que não sabem como foi construído, o «porquê «de um determinado projeto.
Além disso, como frameworks e toolkits são fruto do conhecimento de desenvolvedores experientes, boas técnicas e heurísticas que eles adquiram durante o tempo foram utilizadas no desenvolvimento, as quais não podem ser expressas em classes, e que poderiam ser destacadas e disseminadas para desenvolvedores menos experientes as reutilizarem.
O conceito de Patterns (padrões) surgiu com o propósito de dar algum formalismo para o registro e disseminação de experiência.
Um padrão pode ser definido com o encapsulamento da descrição abstrata e estruturada de uma solução satisfatória para um problema que ocorre repetidamente dentro de um contexto, dado um conjunto de forças ou restrições que atuam sobre o problema.
O conceito de padrões foi proposto inicialmente na área de Arquitetura, e vêm sendo gradualmente incorporado na comunidade de software.
Em resumo, padrões de software visam à reutilização de experiência em desenvolvimento de software.
Um dos trabalhos mais famosos em padrões de software é o catálogo de design patterns de, que apresenta um grupo de 24 padrões que endereçam problemas de projeto de software orientado a objeto, independentes de domínio.
Em a sua grande maioria, estes padrões tratam de problemas relacionados com reusabilidade e flexibilidade de frameworks, e pode- se dizer que foram abstraídos de projetos bem sucedidos de frameworks executados por os pesquisadores que publicaram o catálogo.
Padrões são identificados por nomes, que, com o tempo, são incorporados no vocabulário dos desenvolvedores.
Além disso, padrões descrevem o &quot;porquê «das decisões tomadas para resolver os problemas, quais as justificativas, que estão diretamente relacionadas com as forças que atuam sobre os problemas.
Em o projeto de frameworks, as forças principais são normalmente relacionadas com aspectos de genericidade e facilidade de adaptação.
Enquanto um padrão endereça um problema elementar, uma linguagem de padrões endereça um problema complexo, sendo formada por um conjunto de padrões interligados colaborando para resolver o problema complexo.
Dentro de o projeto de software, pode- se comparar padrões a classes individuais e linguagens de padrões a frameworks, de acordo com os papéis que exercem para resolver um problema de projeto.
Linguagens de padrões têm sido consideradas por a comunidade de software como uma boa alternativa aos tipos de documentação tradicionais usados em desenvolvimento de software, como de padrões publicadas mostram como construir frameworks genéricos ou como utilizar (adaptar e estender) frameworks, em diversos domínios de aplicação.
Em Engenharia de Software, diversos trabalhos em padrões e linguagens de padrões têm sido publicados, endereçando vários domínios de aplicação (Comunicação, Distribuição, Interfaces, Hipermídia, etc.), como também as diversas fases e atividades relacionadas com desenvolvimento de software (Organização de Equipes, Análise de Requisitos, Análise, Projeto, Implementação, etc.) O presente trabalho visa contribuir com a pesquisa que vem sendo desenvolvida em, que propõe o uso de frameworks para aumentar a qualidade e produtividade no desenvolvimento de Sistemas de Apoio à Decisão (SAD).
Sistemas de Apoio à Decisão são &quot;sistemas que têm o objetivo de auxiliar pessoas em tomada de decisão, ajudando- os a usar modelos e dados para resolver problemas de decisão semi-estruturados a nãoestruturados».
O trabalho de consiste essencialmente numa Arquitetura para Desenvolvimento de SADs específicos através da conexão de frameworks reutilizáveis de diferentes tipos, que endereçam papéis distintos a serem executados num SAD.
Esses diferentes tipos de frameworks são resultado da identificação e isolamento de diferentes aspectos que podem ser reutilizados em diversos SADs que atendem determinadas propriedades.
Basicamente, estes frameworks representam classes de problemas de decisão (frameworks de situação de decisão), técnicas de resolução de problemas de decisão (frameworks de resolução), estruturas de apresentação de modelos de decisão (frameworks de apresentação) e componentes de diálogo (frameworks de diálogo).
A Arquitetura atua como um guia para o desenvolvimento de SADs específicos, salientando o protocolo de cooperação destes diferentes tipos de componentes.
O desenvolvimento de SADs baseado em frameworks, de acordo com a Arquitetura, foi validado através do uso de dois estudos de caso, que contemplam os domínios de Capital Budgeting (análise de investimentos) e Planejamento de Atividades Industriais.
Para cada estudo de caso, é mostrado como os frameworks de diferentes tipos devem ser projetados genericamente, e adaptados para serem conectados no desenvolvimento de SADs específicos.
Embora esta abordagem tenha sido considerada viável, alguns problemas foram identificados em.
Já no desenvolvimento dos estudos de caso, foi observado que o processo de adaptação dos frameworks genéricos para conexão com frameworks de diferentes camadas é trabalhoso, resultando em muitas subclasses, aumentando bastante a complexidade de projeto.
Além disso, a arquitetura foi considerada de difícil entendimento na parte que guia a criação e conexão de frameworks.
Estes problemas estão relacionados diretamente com as soluções de projeto dos frameworks utilizadas nos estudos de caso, como também com a documentação do guia proposto.
O objetivo desta dissertação é avaliar e demonstrar as contribuições que padrões podem trazer para o desenvolvimento de software, usando a Arquitetura de Desenvolvimento de SAD baseado em Frameworks de como um estudo de caso, tentando resolver alguns dos problemas que foram identificados na sua utilização.
O presente trabalho está inserido no contexto de uma pesquisa que visa analisar as contribuições de padrões encontrados no uso desta Arquitetura, motivada por os benefícios observados no uso de padrões em desenvolvimento de frameworks para aplicações em geral.
Para atingir o objetivo, está sendo proposta uma linguagem de padrões para guiar a conexão de frameworks para o desenvolvimento de SADs específicos, de acordo com esta arquitetura.
A linguagem tem como objetivo mostrar como frameworks genéricos devem ser projetados e adaptados/ estendidos para serem conectados no desenvolvimento de SADs específicos, focando portanto apenas aspectos de conexão de frameworks de diferentes camadas, que são os aspectos invariantes existentes no desenvolvimento de qualquer SAD através do uso da Arquitetura.
A linguagem endereça o problema complexo de conexão de frameworks de diferentes camadas, separando e interligando subproblemas independentes de conexão, fornecendo soluções satisfatórias que tentam resolver as forças principais contraditórias de genericidade e adaptabilidade.
Em este trabalho, são descritas as características e as contribuições da linguagem de padrões para conexão de frameworks da Arquitetura, ilustradas através de uma porção da linguagem que contempla um subproblema de conexão de frameworks das camadas de apresentação e situação de decisão.
A porção desenvolvida não é um produto final, mas sim uma primeira proposta de contribuição de padrões para o desenvolvimento de SADs baseado em frameworks.
Pretende-se com isso resolver alguns dos problemas originais da Arquitetura, melhorando a documentação e dando melhores soluções de projeto que facilitem o processo de adaptação de frameworks, sem comprometer a sua reusabilidade.
Este documento está dividido em 8 Capítulos, estruturados da seguinte maneira:
Necessidade de usar boas técnicas de projeto para criar software reutilizável.
O Capítulo 3 apresenta o conceito de frameworks, e algumas características importantes de projeto e utilização de frameworks.
Em o Capítulo 4, os conceitos de padrões e linguagens de padrões são descritos, mostrando rapidamente as suas origens, diferentes usos e interpretações na comunidade de software, e quais as suas propriedades que se sobressaem sobre documentação tradicional.
A Arquitetura de Desenvolvimento de SAD, é detalhada no Capítulo 5, mostrando também os principais problemas encontrados na sua abordagem original, que são a base de motivação deste trabalho.
Em o serem atingidas, como vão ser tratados os problemas da Arquitetura, caracterizando as propriedades da linguagem de padrões produzida.
O Capítulo 7 à porção desenvolvida da linguagem, que é a linguagem de padrões para guiar a conexão de frameworks de apresentação e situação de decisão.
Por fim, o Capítulo 8 descreve as conclusões do trabalho, quais as suas contribuições e limitações, e também trabalhos futuros.
Este capítulo tem por objetivo destacar algumas das propriedades do paradigma da Orientação a Objetos (OO) que ajudam a lidar com a complexidade encontrada no desenvolvimento de software, visando o aumento de produtividade, através da criação de software reutilizável e facilmente adaptável a situações específicas, que vão definir um vocabulário padrão que será usado durante todo este documento.
As seções 2.1 a 2.4 mostram algumas destas características específicas da OO que a diferência de outros paradigmas.
Algumas técnicas, princípios, heurísticas gerais de boa concepção de software são mostrados na seção 2.5.
Aplicações orientadas a objeto são construídas com objetos que se comunicam e colaboram para resolver o problema de software endereçado por a aplicação.
Um objeto é composto de dados e comportamento, de acordo com a especificação da classe do objeto.
Uma classe define a estrutura de informações que cada objeto mantém e também o comportamento de todos os objetos da classe.
Cada objeto possui um estado específico, que representa os valores dos dados que mantém, o qual é encapsulado no objeto (não acessível diretamente a outros objetos).
Um objetos são criados através da instanciação de uma classe, tornando- se uma instância da classe.
O comportamento de um objeto é dado por um conjunto de serviços que ele pode executar.
Esses serviços são normalmente chamados de operações ou métodos, os quais normalmente manipulam o estado do objeto.
As operações são invocadas através de mensagens (ou pedidos) enviados por objetos clientes.
Quando um objeto envia uma mensagem, ele está executando o papel de cliente de um outro objeto fazendo papel de servidor.
Objetos se comunicam exclusivamente através do envio de mensagens.
O conjunto de mensagens que um objeto pode responder (serviços que oferece) é chamado de protocolo ou interface, que é definido por a classe do objeto.
Um tipo é um nome usado para denominar uma determinada interface.
Um objeto possui um determinado tipo se ele aceita todas as mensagens definidas para a interface nomeada por o tipo.
Um objeto pode então ter diversos tipos, e diversos objetos podem compartilhar do mesmo tipo.
Interfaces podem conter outras interfaces como subconjuntos, então convenciona- se que um tipo é um subtipo de um outro se a sua interface contém a interface do seu supertipo, onde o subtipo herda a interface de seu supertipo.
Interfaces são muito importantes em aplicações OO porque objetos se conhecem e se comunicam apenas através de suas interfaces.
Isto é importante porque objetos não assumem conhecimentos sobre a representação interna e de detalhes de implementação de outros objetos.
Objetos se comprometem com a interface de outros objetos, e objetos que têm implementações completamente diferentes podem ter a mesma interface.
Isto quer dizer que um determinado objeto que envia uma mensagem para outro objeto está comprometido com uma interface particular, possibilitando que o objeto que recebe a mensagem possa ser substituído por qualquer outro (qualquer implementação) que esteja conforme a interface esperada por o objeto que envia a mensagem.
Esta característica de substituição de objetos, que dá flexibilidade no desenvolvimento de software, é dada por os conceitos de polimorfismo e ligação dinâmica.
Ligação dinâmica significa que, quando um objeto cliente comprometido com a interface de um objeto servidor envia uma mensagem, ela só é associada à operação correspondente em tempo de execução, de acordo com a implementação do objeto associado à interface.
Polimorfismo (várias formas) refere- se à idéia de que o objeto que o cliente espera se comunicar (respeitando uma interface) pode se comportar de diversas maneiras, de acordo com a implementação associada.
Uma situação do mundo real pode ser usada para exemplificar o uso de polimorfismo e ligação dinâmica.
Um amplificador pode receber entrada de som de diversos dispositivos, amplificando o sinal e enviando para um outro dispositivo de saída.
O objeto amplificador está relacionado com um objeto que contenha a interface (seja do tipo)` Dispositivo de Entrada'.
Este tipo pode ser usado por diversas implementações de objetos de entrada de som, como` Leitor de CD',` Câmera de Vídeo', tipo` Dispositivo de Entrada', que define apenas uma operação básica que é` Pegar Informação de Som'.
O objeto amplificador envia mensagens` Pegar Informação de Som 'para recuperar as ondas sonoras que estão sendo capturadas ou emitidas por os objetos` Dispositivo de Entrada'.
O objeto` Dispositivo de Entrada' conhecido por o objeto amplificador pode se comportar de diversas maneiras, de acordo com a implementação do objeto que está associado, isto é, qual dispositivo de entrada que está conectado ao amplificador.
A mensagem` Pegar Informação de Som' é associada à operação da implementação associada somente no momento em que a mensagem é enviada.
Objetos Classes definem a interface dos seus objetos, e também suas implementações.
Novas classes podem ser definidas baseadas em classes existentes, através do mecanismo de herança.
A herança de classes permite que uma nova classe incorpore todas as características de uma outra classe, englobando especificação dos dados e definição de comportamento, podendo adicionar ou modificar funcionalidades, através da criação ou modificação das operações da classe base.
A classe especializada é chamada de subclasse, e a classe base é a superclasse.
Os objetos de uma superclasse contém um subtipo do tipo das suas subclasses, o que significa que um objeto de uma subclasse pode sempre ser usado no lugar do objeto da superclasse.
O mecanismo de herança permite que sejam criadas hierarquias de classes, onde as classes posicionadas mais ao topo da hierarquia são as mais genéricas.
Normalmente, classes que contêm subclasses são classes abstratas.
Classes abstratas são classes que não podem ser instanciadas, sendo seu propósito definir uma interface padrão e um comportamento básico para suas subclasses, isto é, focam o aspecto de reutilização.
Uma classe abstrata implementa algumas operações e deixa em aberto a implementação de outras operações, que serão definidas por subclasses específicas.
As operações que uma classe abstrata declara mas não implementa são chamadas de operações abstratas.
As subclasses podem então adicionar operações ou redefinir operações da superclasse.
Este processo de redefinição de operações é chamado de sobrescrita de operações.
Operações abstratas, herdadas de classes abstratas, devem ser ter seu comportamento definido (sobrescritas) em subclasses que vão ser instanciadas.
Classes que podem ser instanciadas, ou seja, completamente implementadas, são chamadas de classes concretas.
A reutilização de funcionalidade em OO é normalmente obtida através dos mecanismos de herança e composição de objetos.
Em o primeiro caso, o processo de reutilização é feito a partir de a criação de subclasses, sendo geralmente chamado de reuso white-box, porque os detalhes internos de implementação das superclasses ficam expostos às suas subclasses.
Já a composição de objetos permite que uma nova funcionalidade seja gerada através da combinação de objetos existentes, através de interfaces padronizadas bem definidas.
Reutilização através de composição é chamada de black-box porque continua respeitando o princípio do encapsulamento de informações, ou seja, nenhum detalhe de implementação dos objetos são disponibilizados externamente.
Em reuso white-box, superclasses passam a responsabilidade de implementar os pontos variáveis (operações abstratas) e adicionar funcionalidade para suas subclasses.
Em black-box, os pontos variáveis são preenchidos com a composição de objetos que implementam as operações que representam estes pontos, que são executadas por as classes adaptadas.
É importante salientar que muitas linguagens e métodos OO não fazem a distinção entre tipos e classes, apesar de os desenvolvedores saberem da diferença e usarem os dois conceitos na prática.
Como uma classe define tanto o tipo como a implementação de um objeto, classes são normalmente utilizadas para explicitamente representar tipos, sendo na verdade classes abstratas que não possuem nenhum detalhe de implementação, apenas especificação da interface.
Conseqüentemente, relacionamentos entre tipos e subtipos são definidos através de herança de classe, construindo hierarquias de classes.
Outro ponto a ser destacado é o fato de que muitas linguagens e métodos OO diferem é na questão da compatibilidade de tipos de objetos.
Um objeto conhece um outro objeto através de uma referência.
Em algumas linguagens, como C+ e Eiffel, deve ser definido explicitamente o tipo do objeto referenciado, que é dado através da atribuição do nome de uma classe a esta referência.
O compilador do código verifica se em algum momento está sendo atribuído um objeto a esta referência que seja incompatível com o tipo declarado, isto é, se o tipo do objeto que está sendo associado não é um subtipo do tipo declarado.
Isto é definido como verificação de tipos.
Em linguagens mais dinâmicas, como Smalltalk, não existe verificação de tipos.
Se um determinado objeto associado não puder responder a uma mensagem enviada (não contém interface esperada), um erro em tempo de execução é gerado.
Um detalhe adicional que tem que ser observado em linguagens com verificação de tipos (tipadas) é a perda de informação de tipo.
Isto ocorre quando um objeto é acessado a partir de uma referência que está declarada como um supertipo deste objeto, mas é desejado enviar mensagens para ele que não pertencem a esse supertipo, mas sim ao seu tipo real.
Apresenta exemplos interessantes que levantam os problemas inerentes da perda de informação de tipo.
Para enviar então uma mensagem específica de um subtipo daquele declarado para a referência, pode- se aplicar um comando de downcasting, convertendo o tipo da referência para o tipo desejado.
Um outro recurso semelhante é o de templates, disponível em alguns métodos e linguagens que trabalham com tipos.
O uso de templates permite que classes recebam como parâmetros os tipos dos objetos que a classe compõe (referencia).
Assim, no momento da instanciação de um objeto desta classe, são passados os tipos dos objetos que o novo objeto estará referenciando.
Como já foi destacado, simplesmente projetar software orientado a objeto não significa que ele será reutilizável, flexível e adaptáveis, atributos inerentes à qualidade do software desenvolvido.
Por isso, existem diversas publicações que descrevem um grande número de boas técnicas, heurísticas, princípios, que devem ser aplicados juntamente com o desenvolvimento OO para tentar promover reuso e flexibilidade.
Para criar software reutilizável e flexível, é importante fazer uma antecipação dos possíveis usos dos elementos de software, identificando, isolando e encapsulando aspectos potencialmente variáveis e fixos.
A separação de aspectos que variam independentemente facilitam a evolução do software.
Como é dito em, o desenvolvedor deve tomar uma atitude &quot;design for change».
A criação de software monolítico, onde todos os elementos estão fortemente ligados, e não há uma separação de aspectos que evoluem independentemente, leva o desenvolvedor a cair num ciclo vicioso de reprojeto e reimplementação.
Qualquer mudança nos requisitos do software ou num componente específico causa um impacto muito grande quando os componentes estão fortemente ligados.
Um dos princípios básicos de desenvolvimento OO que deve ser adotado é de projetar para uma interface, não para uma implementação específica.
Classes não devem declarar referências de objetos para uma determinada classe concreta, isto é, comprometer- se com uma determinada implementação.
Ao invés de isso, classes devem se comprometer com interfaces, para permitir que as implementações destas interfaces possam ser substituídas durante o processo de evolução do software sem maiores impactos, como também permitir uma maior adaptabilidade dinâmica para o software, colocando em funcionamento os importantes mecanismos de polimorfismo e ligação dinâmica.
Dependências sobre implementações restringem reuso e flexibilidade.
Todos estes princípios, técnicas, regras, padrões, etc., são o resultado da experiência que desenvolvedores adquiram nas tarefas de desenvolvimento de software em geral, e de software orientado a objeto em particular.
Problemas comuns de projeto foram encontrados por estes desenvolvedores, e boas soluções foram identificadas e desenvolvidas durante o tempo para aumentar o reuso e flexibilização de software.
Existem diversas definições para o termo framework orientado a objeto.
Um framework pode ser considerado como &quot;um projeto reutilizável de uma parte ou de todo um sistema, que é representado por um conjunto de classes abstratas e pelo modo que elas interagem».
Outra definição é &quot;uma aplicação reutilizável, semi-completa, que pode ser especializada para produzir aplicações específicas».
Uma das definições mais clássicas para framework é &quot;um conjunto de classes que definem um projeto abstrato de soluções para uma família de problemas relacionados».
Analisando- se as definições existentes e os diferentes propósitos de frameworks, pode- se dizer que um framework é um conjunto de classes (abstratas e concretas) e objetos que representa genericamente um (sub) sistema de software, cujas classes podem ser adaptadas e estendidas para representar um (sub) sistema específico.
Frameworks são abstrações de subsistemas de software, assim como classes abstratas são para classes concretas (completamente implementadas).
Frameworks diferem de bibliotecas de classes porque apresentam uma inversão do fluxo de controle entre os frameworks e os desenvolvedores usuários dos frameworks.
Projetos baseados em bibliotecas de classes tradicionalmente forçam o desenvolvedor a escrever todo o fluxo de controle da aplicação.
Ao contrário, projetos baseados em frameworks colocam o framework no controle do fluxo, onde o desenvolvedor escreve apenas métodos especiais que adaptam a funcionalidade do framework, os quais são chamados por o próprio framework.
Por esta razão, geralmente é dito que frameworks obedecem o &quot;Princípio de Hollywood «(&quot;Don' t call us, we call you.&quot;).
Frameworks são desenvolvidos focando principalmente o aspecto de reutilização de software.
Desenvolver software pensando em reutilização leva a duas diferentes disciplinas, que são desenvolvimento para reutilização e desenvolvimento com reutilização, algumas vezes chamadas de Application Engineering (Engenharia de Aplicação) e Application Development (Desenvolvimento de Aplicação).
Os papéis executados por desenvolvedores nestas disciplinas normalmente são nomeados como abstractor e elaborator, respectivamente.
Em resumo, desenvolvedores abstractors criam frameworks genéricos e reutilizáveis que serão usados e adaptados por elaborators para contextos específicos.
Um dos primeiros frameworks que pode ser encontrado na literatura é o Model-View--Controller (MVC), disponível em ambientes de desenvolvimento Smalltalk, para o desenvolvimento de interfaces para o usuário (GUI).
Outros frameworks famosos endereçando o domínio de GUI que pioneiros endereçarem principalmente criação de interfaces gráficas, atualmente existem frameworks para diversos domínios, como editores diagramáticos (Hotdraw, FOIBLE objetos distribuídos e comunicação (CORBA, Java RMI).
A seção 3.1 mostra um exemplo de framework bastante conhecido, o Model-View--Controler (MVC).
A seção 3.2 apresenta os principais tipos de frameworks, em relação a a propósito, encontrados no desenvolvimento de software.
Aspectos de desenvolvimento e utilização de frameworks são dados na seção 3.3.
Para ilustrar o funcionamento básico de um framework, esta seção descreve rapidamente os componentes básicos do frameworks MVC, que é provavelmente um dos frameworks mais conhecidos na comunidade de software.
O MVC é usado para a construção de interfaces gráficas, e surgiu no ambiente do Smalltalk-80.
Ele divide uma aplicação em três abstrações, que são model (modelo), view (visão) e controller (controlador).
A abstração Modelo define a semântica da aplicação, mantém seu estado e define seu comportamento.
Cada abstração Visão permite uma forma de apresentação visual do modelo para os usuários da aplicação, podendo um mesmo modelo estar associado a várias visões.
Controladores definem o modo de interação do usuário com os modelos e visões da aplicação, e estão relacionados com dispositivos de entrada de dados (teclado, mouse, etc.).
Cada uma destas abstrações corresponde a uma classe abstrata no framework MVC, e elas cooperam através de um protocolo de interação bem definido.
As classes são definidas da seguinte maneira:
Classe Model:
Um objeto Model pode manter objetos dependentes (views e controllers), e enviar mensagens de notificação de modificações no modelo para os dependentes.
A classe Model define um protocolo de mensagens específico para estes propósitos.
Um modelo de uma aplicação é uma instância de uma subclasse de Model, que deve implementar comportamento específico da aplicação.
Classe View: Um objeto View representa pode ser decomposto em outros objetos View, chamados de subvisões.
A classe View define protocolo para interagir com objetos controller e model, interagir com suas subvisões, coordenando ações de transformação e apresentação.
Um objeto View numa aplicação é uma instância de uma subclasse de View.
A subclasse tem que fornecer a implementação para o protocolo de apresentação, para definir detalhes específicos do modelos que representa.
Classe Controller: Define protocolo para manipular objetos Model e View, a partir de mensagens de interação enviadas por o usuário através de dispositivos de entrada de dados.
Alguns autores tentam classificar frameworks em diferentes dimensões, caracterizando tipos distintos de frameworks de acordo com os seus propósitos.
Divide frameworks em infraestrutura, integração e domínio de aplicação:
Frameworks de Infra-- estrutura:
São usados para dar suporte a diversos tipos de aplicação, independentemente dos domínios endereçados por estas aplicações.
Exemplos seriam frameworks para sistemas operacionais, comunicação, redes e construção de interfaces.
Frameworks de Integração: Normalmente são usados para integrar aplicações e componentes distribuídos, como frameworks CORBA ORB, DCOM, implementações do padrão ODMG, etc..
Frameworks de Domínio de Aplicação: Representam esqueletos de aplicações para domínios específicos, como telecomunicações, manufatura e engenharia financeira.
Frameworks deste tipo capturam elementos invariantes de domínio, e deixam em aberto aspectos específicos de cada aplicação.
Frameworks de Infra-- estrutura e Integração preocupam- se basicamente com problemas internos de desenvolvimento de software e são independentes de domínio de aplicação, enquanto frameworks de Domínio de Aplicação têm o objetivo de apoiar o desenvolvimento de aplicações dirigidas ao usuário e produtos em domínios específicos.
Comparados com as outras categorias, frameworks de Domínio de Aplicação são os mais difíceis e custosos para se desenvolver e comercializar Um framework define os seus aspectos fixos ou estáveis, que correspondem aos aspectos comuns a todos os contextos em que o framework será reutilizado, e deixa em aberto os seus aspectos variáveis, específicos de contexto de utilização do framework, sobre os quais os aspectos fixos podem estar baseados.
Os aspectos fixos são definidos nas classes de um framework como pontos de estabilidade, enquanto aspectos variáveis são previstos nas classes como pontos de variabilidade, normalmente chamados de frozen-spots e hot-spots, respectivamente.
Um desenvolvedor reutiliza um framework adaptando- o ao contexto específico em que será usado, através do preenchimento dos pontos de variabilidade que foram previstos e adicionando novas funcionalidades.
Os pontos de estabilidade e variabilidade de um framework são representados nas classes que o compõem na forma de métodos (ou operações) chamados respectivamente de métodos template e hook.
Métodos template implementam os pontos de estabilidade, e normalmente são baseados em métodos hook, que representam os pontos de variabilidade, os quais devem ser implementados no processo de adaptação e extensão das classes do framework para um uso específico.
A definição e o preenchimento de pontos de variabilidade (implementação de métodos hook) depende da abordagem utilizada no desenvolvimento e adaptação de uma classe de um framework, de acordo com as definições de reutilização white-box e black-box (Seção 2.3).
Em a abordagem white-box, métodos hook são representados em classes abstratas por operações abstratas ou com uma implementação padrão, as quais devem ser sobrescritas em subclasses concretas.
Preencher um ponto de variabilidade na abordagem white-box significa sobrescrever e implementar um método hook.
Usando abordagem black-box, classes são adaptadas por a composição de objetos que estão de acordo com uma interface pré-definida para os pontos de variabilidade.
As operações definidas nesta interface são os métodos hook das classes a serem adaptadas, variando as implementações das operações de acordo com o objeto que está sendo composto.
Em outras palavras, neste contexto preencher um ponto de variabilidade significa compor um objeto que respeita a interface de adaptação que implementa os métodos hook correspondentes.
As Figura 2 (a) e Figura 2 (b) mostram exemplos de métodos template e hook usando as duas abordagens de adaptação das classes, usando diagramas de classes UML.
Em a Figura 2 (a), fluxo de execução, mostrado por o pseudocódigo das operações das classes, que chama dois métodos implementação básica, podendo também ser sobrescrito nas subclasses de B. Isto reflete o uso da abordagem white-box para preenchimento de pontos de variabilidade.
A Figura 2 (b) mostra como um método hook é implementado através da abordagem black-box.
A implementado por qualquer objeto que respeite a interface definida por a classe B, sobre a qual a classe A está comprometida, através da referência bRef declarada.
A nomeação de uma operação como template ou hook depende do contexto em que se está Pode- se dizer que a identificação e definição dos pontos de estabilidade e variabilidade em frameworks é bastante importante, principalmente para criar frameworks flexíveis, evitando tarefas de reprojeto e reimplementação em cada situação em que forem detectados novos usos ou novas possibilidades de reutilização de um framework.
A Seção 2.5 destaca o fato de aspectos de software que variam independentemente devem ser isolados e encapsulados, para permitir uma evolução suave e sem grandes impactos nas mudanças (princípio de Separação de Aspectos).
A identificação de métodos template e hook é a separação e o encapsulamento de aspectos fixos e variáveis de um framework, que variam e evoluem independentemente.
Dependendo do modo como um framework é adaptado e estendido, ele pode ser classificado como white-box ou black-box.
Como os nomes sugerem, frameworks white-box são adaptados principalmente através de uso de abordagem white-box, onde pontos de variabilidade são preenchidos através do uso de herança e redefinição de operações.
Por outro lado, frameworks black-box usam abordagem black-box para adaptação, em a qual pontos de variabilidade são preenchidos através da composição de objetos em interfaces de adaptação pré-definidas.
Em relação a os frameworks white-box, pode- se dizer que o uso de herança faz com que aspectos internos das superclasses sejam expostos às suas subclasses, pois &quot;herança quebra encapsulamento».
Normalmente, frameworks white-box são mais difíceis de usar que black-box, uma vez que forçam o desenvolvedor a ter bastante conhecimento sobre detalhes de implementação do framework.
Subclasses ficam ligadas fortemente às suas superclasses, fazendo com que qualquer mudança na superclasse cause impacto nas subclasses.
Além disso, o uso de herança para combinar funcionalidade pode levar a uma proliferação de subclasses, aumentando a complexidade de software.
Normalmente, adaptar e estender frameworks black-box é mais fácil do que white-box, uma vez que só é necessário conhecer a interface para conexão de objetos que preenchem os pontos de variabilidade.
Além disso, a adaptação é mais dinâmica, podendo ser feita em tempo de execução, através da substituição do objeto que está atualmente atribuído a interface de adaptação do framework (plug&amp; play).
Em contraste, black-box são mais difíceis de projetar, uma vez que a interface para conexão dos componentes deve ser elaborada com cuidado, prevendo usos futuros, já que interfaces não bem elaboradas podem limitar as oportunidade de reutilização dos frameworks.
Atualmente, diversos especialistas em orientação a objetos favorecem a utilização de frameworks black-box sobre white-box, formando sistemas mais flexíveis e dinâmicos.
Em trabalhos como, é destacado o fato de que frameworks imaturos, onde o desenvolvedor ainda não tem muito conhecimento sobre o domínio que será usado, nem sobre quais os seus aspectos fixos e variáveis, devem começar com a abordagem white-box, já que não se tem ainda condições de elaborar uma interface estável de adaptação do framework.
Idealmente, frameworks imaturos devem evoluir para frameworks black-box, quando o conhecimento dos usos futuros do framework for maior.
O conceito de Padrão (Pattern) pode ser definido como o encapsulamento da descrição abstrata e estruturada de uma solução satisfatória para um problema que ocorre repetidamente dentro de um contexto, dado um conjunto de forças ou restrições que atuam sobre o problema.
Padrões visam melhorar e formalizar a documentação de experiência, de conhecimento.
Têm o objetivo de registrar de maneira estruturada as soluções que pessoas mais experientes encontraram ao se defrontar com problemas repetitivos, para que possam ser transmitidas de maneira mais eficiente a pessoas menos experientes, para evitar que essas passem por as mesmas dificuldades, ou que cometam os mesmos erros que os primeiros (mais experientes) cometeram.
Padrões são identificados por nomes, que com o tempo vão sendo incorporados no vocabulário das pessoas.
A Seção 4.1 fornece uma introdução aos conceitos de padrões e linguagens de padrões, levantando alguns dados históricos.
A Seção 4.2 caracteriza rapidamente o trabalho pioneiro de padrões na área de Arquitetura, apresentado em.
Em a Seção 4.3 são levantados os elementos essenciais que devem estar presentes na descrição de um padrão.
A Seção 4.4 destaca os diferentes tipos de padrões existentes na área de software, como também alguns exemplos de padrões publicados.
As propriedades especiais de linguagens de padrões são faladas na Seção 4.5.
Padrões são o resultado da abstração da análise de problemas semelhantes e das soluções utilizadas.
Aprendemos com a natureza diversos padrões que aplicamos no nosso cotidiano.
Um exemplo disto é o padrão que pode ser chamado de Joins (juntas).
Uma junta é um mecanismo abstrato que conecta dois elementos, flexibilizando o movimento.
As juntas, que são encontradas em todos os vertebrados, são uma solução para o problema (genérico) de conectar duas partes permitindo livre movimentação de ambas.
Em o corpo humano, joelhos, tornozelos e ombros são exemplos de juntas.
Nós abstraímos a solução de juntas, aplicada por a natureza, e fizemos nossos próprios usos, como por exemplo em máquinas industriais.
O trabalho pioneiro do arquiteto Cristopher Alexander introduziu o conceito de padrões, catalogando um número de 253 padrões usados para resolver problemas da área de arquitetura, partindo de problemas de grande escala, como a organização do mundo em regiões, cidades, definição de espaços para agricultura, etc., até padrões de menor escala, na construção de casas, como colocação de janelas numa casa, criação de alcovas, e assim por diante.
Os padrões de Alexander não trabalham apenas isoladamente, mas sim são interligados para resolver um problema mais genérico, formando uma linguagem de padrões (pattern language).
Uma linguagem de padrões endereça um problema complexo que é divido em subproblemas, os quais são tratados por um grupo de padrões interligados (ou relacionados).
As ligações entre os padrões define um grafo que pode indicar uma determinada ordem na aplicação dos padrões para resolução dos problemas.
Em a linguagem de padrões de Alexander, os relacionamentos entre os padrões são definidos de acordo com a escala de aplicação, onde os padrões de maior escala contêm e são complementados por os de menor escala, e vice-versa.
Os conceitos de padrões e linguagens de padrões começaram a ser introduzidos na comunidade de software no fim dos anos 80 e no início dos anos 90, mas foram realmente conhecidos e popularizados com a publicação dos design patterns, da chamada Gang-of-Four (GoF), formada por os pesquisadores Erich Gamma, Ralph Johnson, Richard Helm e John Vlissides.
Eles criaram um catálogo de padrões para o projeto de software orientado a objeto, documentando as suas experiências na resolução de problemas de projeto independentes de domínio de aplicação.
O catálogo registra diversas soluções satisfatórias que eles encontraram durante o desenvolvimento de frameworks, relacionados principalmente por problemas de reusabilidade, flexibilidade, Em engenharia de software, diversos trabalhos em padrões e linguagens de padrões têm sido publicados, endereçando vários domínios de aplicação (Comunicação, Distribuição, Interfaces, Hipermídia, etc.), como também as diversas fases e atividades relacionadas com desenvolvimento de software (Organização de Equipes, Análise de Requisitos, Análise, Projeto, Implementação, etc.).
Um grupo de arquitetos, liderados por Cristopher Alexander, desenvolveu uma linguagem de padrões endereçando problemas genéricos nas áreas de arquitetura e construção.
A linguagem desenvolvida tem como alvo pessoas comuns, que podem utilizar- la na construção de suas casas, peças, jardins, etc., dando soluções satisfatórias encontradas e elaboradas por pessoas mais experientes, para que leigos possam reaproveitar essa experiência nos seus problemas particulares.
A linguagem é dividida em diversos níveis, e cada nível agrupa um determinado número de padrões.
Estes níveis começam em problemas de grande escala, desde como organizar cidades em regiões e subregiões, dividir cidades em bairros, demarcar territórios para agricultura, até níveis de escala menor, mostrando como projetar casas levando em conta aspectos como posicionamento de Uma certa ordem na aplicação dos padrões é sugerida por a linguagem, através de conexões formadas entre esses padrões de acordo com a escala (ou nível de abstração).
Um padrão está conectado com um determinado grupo de padrões de maior escala, que são descritos antes de ele, e a um determinado grupo de padrões de menor escala, que são descritos depois.
Um padrão ajuda a completar os padrões de maior escala que estão acima de ele, e ele é completado por padrões de menor escala que estão abaixo de ele.
Isto significa que um determinado padrão deve preferencialmente ser usado dentro de um contexto resultante do uso de padrões de maior escala, de maneira que auxilie a aplicação dos padrões de menor escala.
Por exemplo, o padrão Accessible Green está conectado primeiramente com determinados padrões maiores:
Subculture Boundary, Identifiable Neighborhood, Work Community e Quiet Backs;
E é completado por alguns padrões menores:
Positive Outdoor Space, Tree Places e Garden Wall.
Os padrões da linguagem são numerados, nomeados e descritos textualmente, obedecendo um certo formato preestabelecido de apresentação.
Define o formato utilizado na descrição dos seus padrões da seguinte maneira:
Em resumo, cada padrão contém vários elementos descritivos.
Em primeiro lugar, é definido o contexto em que ele se enquadra.
Normalmente a descrição do contexto contém referências para padrões de maior escala, aplicados anteriormente, que interferem diretamente no estabelecimento do contexto do padrão.
Depois há um relato do problema genérico encontrado, normalmente através de uma situação concreta para exemplificar o problema, e uma lista de restrições que são levadas em consideração para a resolução do problema.
Após, a solução para o problema é apresentada, mostrando como ela deve ser construída, respeitando as restrições impostas sobre o problema.
Após a descrição da solução, geralmente são colocadas referências a outros padrões da linguagem que completam o padrão, que podem resolver problemas gerados ou não resolvidos por o padrão em questão.
Uma amostra de um padrão de Alexander que pode ser mostrada é o Accessible Green, padrão nº 60 da linguagem.
Ele trata o problema de fornecer a uma comunidade diversas áreas verdes, como praças e parques, porque é importante para as pessoas que elas saiam de suas residências e procurem lugares deste tipo.
Porém, as áreas verdes não podem estar muito distantes de suas casas, senão as pessoas perdem a motivação de visitar- las.
Abaixo é mostrado um fragmento do texto original em:
Parks are meant to satisfy this need.
But parks, as they are usually understood, are greens ­ are scattered so widely, and so profusely, that every house and every Therefore:
Pay special attention to old trees, look after them ­ TREE PLACES;
Shape the green walls, or buildings, but not roads or cars ­ Positive Outdoor SPACE, GARDEN Existem diversos formatos ou templates para a descrição de padrões.
Alguns são quase puramente textuais, escritos em prosa livre, semelhantes ao formato original utilizado por Alexander, enquanto outros são mais estruturados, como aquele utilizado por a Gang-of-Four (GoF).
Não existe um formato padronizado por a comunidade de software, principalmente porque diferentes tipos e domínios de padrões podem exigir diferentes maneiras de apresentar os padrões.
Mesmo assim, há um certo consenso geral sobre elementos essenciais que devem ser contemplados e comunicados por qualquer padrão, independentemente do formato utilizado.
Estes elementos são Nome (Name):
Todo padrão deve ter um nome significativo, que dê identidade ao padrão, permitindo que ele seja facilmente incorporado no vocabulário dos usuários do padrão.
O nome normalmente deve sugerir a solução encontrada para o problema tratado.
Por exemplo, descreve um padrão para tratar o problema de permitir que vistas bonitas e distantes possam estar acessíveis (serem visualizadas) de uma casa, o qual ele chama de Zen View, derivado da solução usada por a cultura japonesa.
Problema (Problem):
Descreve o problema recorrente que o padrão endereça.
O problema se enquadra dentro de um determinado contexto, e sofre a ação de diversas forças, que são levadas em consideração na resolução do problema.
Contexto (Context):
Contém os pré-requisitos para a aplicação do padrão, define o &quot;ambiente «em que o problema é encontrado e onde a solução apresentada é válida ou satisfatória.
O contexto determina a aplicabilidade do padrão, ou seja, as situações onde o problema é encontrado e o padrão pode ser aplicado.
Forças (Forces):
Define um conjunto de forças e restrições que atuam sobre o problema, e que influenciam a decisão da solução.
São critérios, normalmente contraditórios, que são levados em consideração na elaboração de uma solução.
Por exemplo, desempenho e uso de recursos são forças consideradas na elaboração de algoritmos.
Solução (Solution):
Apresenta a solução que melhor resolve o conjunto de forças que atuam sobre o problema, o que pode ser dito de modo informal:
A melhor relação custo-benefício.
A solução de um padrão deve mostrar passo a passo como que a solução genérica deve ser construída, e quais aspectos da solução são dependentes da aplicação real do padrão.
Outros elementos podem ser adicionados na descrição de padrões, para melhorar seu entendimento ou para simplesmente fornecer informações adicionais que possam ser relevantes para um determinado contexto ou domínio da aplicação dos padrões.
Alguns destes elementos seriam:
Exemplos (Examples):
Ilustrações de contexto e problema concretos, situações reais onde o problema genérico é encontrado.
Exemplos descrevem também a aplicação da solução concreta, e também porque outras soluções que poderiam ser usadas não são melhores do que a aplicada.
Exemplos descrevem a parte concreta de um padrão, o que é bastante importante, visto que as pessoas se sentem mais à vontade com elementos concretos do que abstrações.
Além disso, como é bem colocado por John Vlissides em, &quot;as pessoas parecem entender melhor os conceitos quando eles são primeiramente apresentados em termos concretos, e depois em termos abstratos».
Justificativa (Rationale):
Justificativa da escolha da solução para o problema, mostrando como a solução resolve as forças impostas sobre o problema.
Pode também citar outras possíveis soluções que são menos satisfatórias do que a escolhida.
Contexto Resultante (Resulting Context):
Define o contexto resultante após a aplicação do padrão, incluindo o levantamento de outros problemas que podem surgir com o uso do padrão.
Enquanto o contexto determina as preconditions, o contexto resultante dá as postconditions do padrão, e pode apresentar as forças que foram resolvidas por a solução e aquelas que ainda permanecem não resolvidas, e quais padrões são agora aplicáveis (dentro ou não de uma linguagem de padrões).
Relacionamentos (Relationships):
Dentro de uma linguagem, padrões estão relacionados de diversas maneiras, para resolver o problema mais genérico endereçado.
Padrões podem também estarem ligados com outros padrões que estão fora de o contexto de uma linguagem, pertencentes a outras linguagens ou descritos isoladamente.
Estes relacionamentos são dados de diversas maneiras.
Por exemplo, um padrão pode levar a um outro padrão que resolve um problema gerado por o primeiro ou que resolve um problema mais específico.
Outros elementos opcionais algumas vezes encontrados em padrões são Indications (sintomas do problema), Code Samples (amostras de implementação da solução), Aliases (outros nomes por os quais um padrão é conhecido), Acknowledgements (agradecimentos a pessoas que contribuíram na elaboração do padrão).
É sabido que a popularização do conceito de padrões na comunidade de software foi dada por os design patterns da Gang-of-Four.
Eles descrevem boas soluções para o projeto de software orientado a objeto, mais especificamente, resolvem problemas comuns (independentes de domínio) encontrados principalmente no projeto de frameworks reutilizáveis.
Desde então, diversos padrões e linguagem de padrões têm sido desenvolvidos endereçando diversos domínios de aplicação, como também diferentes fases e atividades relacionadas com o desenvolvimento de software.
Fazendo- se um apanhado dos trabalhos existentes em padrões e linguagens de padrões, identifica- se algumas dimensões que podem ser usadas para classificar e agrupar os padrões e linguagens produzidos.
Cabe salientar que esta classificação não é definitiva, nem as dimensões são totalmente ortogonais, sendo apenas uma tentativa de organizar os trabalhos existentes na área de padrões.
Algumas dessas dimensões seriam:
Fase de Desenvolvimento de Software OO:
Categoriza padrões de acordo com o nível de abstração dos problemas de software tratados, que reflete a fase de desenvolvimento OO endereçada por o contexto, tipo de problema e solução levantados.
De acordo com, as fases são Análise de Domínio (Domain Analysis), Análise de Requisitos (Requirement Analysis), Análise de Sistema (System Analysis), Projeto Arquitetural (Architectural Design), Projeto Detalhado (Detailed Design), Implementação (Implementation), Teste (Testing), Manutenção (Maintenance).
Suporte ao Desenvolvimento de Software:
Classifica padrões que não estão relacionados diretamente com o desenvolvimento de software, mas sim com disciplinas que dão suporte a desenvolvimento.
Esta dimensão organiza padrões relacionados com práticas e organização de equipes de desenvolvimento, como também treinamento de profissionais.
Exemplos de valores para esta dimensão são Processos, Organizações, Gerenciamento de Configuração de Software, Pedagogia.
Domínio de Suporte:
Relacionados com técnicas de elaboração de software destinado a suporte de aplicações, assim como são classificados frameworks de suporte na Seção 3.2.
Alguns domínios seriam Comunicação, Sistemas Distribuídos, Sistemas Adaptáveis, Bancos de Dados, Interfaces de Usuário, CORBA, Segurança, Www.
Domínio de Aplicação:
Representa domínios de aplicação específicos, normalmente relacionado com as categorias de empresas e corporações em que os softwares são aplicados.
Padrões enquadrados nesta dimensão endereçam domínios como Manufatura, Transportes, Sistemas de Alarme de Incêndio, Telecomunicações, Telefonia e outros.
Domínio de Aplicação Mais Genérico:
Também relaciona- se com domínios de aplicação, só que mais genéricos do que os domínios de aplicação da seção anterior.
Engloba domínios como Hipermídia, Workflow, Sistemas de Negócio, Sistemas de Informação Geográficos, Sistemas Multi--agentes.
As principais categorias de padrões e linguagens de padrões, resultantes da combinação de algumas destas dimensões, são descritas e exemplificadas nesta seção.
Um design pattern é definido em como:
A design pattern describes a basic scheme for structuring subsystems and components of a software architecture as well as their relationships.
It identifies, names, and abstracts a common design principle by describing its different parts, their collaboration and responsibilities.
O termo design pattern refere- se a problemas encontrados na etapa de projeto detalhado de software orientado a objeto (Projeto Detalhado), e foi batizado por a GoF.
Em o desenvolvimento de software, a etapa de projeto detalhado preocupa- se com o espaço de solução do problema endereçado por o software, cuja representação (do problema) é dada por a etapa de análise (System Analysis).
Então, os problemas tratados por design patterns estão normalmente relacionados com aumento de reusabilidade, flexibilidade, modularidade, e outros atributos qualitativos e quantitativos do software resultante da fase de projeto.
A GoF descreve um grupo de 23 design patterns, organizados num catálogo, que descrevem boas soluções de projeto de software de uso geral, ou seja, independentes de domínio de aplicação.
Esses padrões são resultado da experiência dos componentes da GoF no desenvolvimento de software OO, mais especificamente frameworks, buscando atingir flexibilidade e reusabilidade para as soluções desenvolvidas.
Em resumo, um design pattern é composto por três partes principais:
Uma descrição abstrata de estrutura de classes ou objetos que se comunicam e colaboram;
A questão de projeto endereçada por a estrutura;
As conseqüências de aplicar a estrutura abstrata a uma arquitetura de sistema.
Os design patterns catalogados em possui um formato de descrição bastante estruturado, o qual é dividido num 13 seções, os quais representam os elementos essenciais que devem existir na descrição de padrões (Seção 4.3).
Transcrevendo diretamente do catálogo, a descrição de cada design pattern é dada no seguinte formato:
Intent: A short statement that answers the following questions:
What dões the design pattern de o?
What is its rationale and intent?
What particular design issue or problem dões it address?
Motivation: A scenario that illustrates a design problem and how the class and Applicability:
What are the situations in which the design pattern can be applied?
Participants: The classes and/ or objects participating in the design pattern and their responsibilities.
Collaborations: How the participants collaborate to carry out their responsibilities.
Consequences: How dões the pattern support its objectives?
What are the trade-offs independently?
Sample Code:
Code fragments that illustrate how you might implement the pattern in C+ or Smalltalk.
Related Patterns: What design patterns are closely related to this one?
What are the important differences?
With which other patterns should this one be used?
Segundo a GoF, estas seções capturam os elementos essenciais que devem ser comunicados num padrão.
O problema e o contexto são apresentados em Intent e Aplicabilidade, assim como um exemplo do problema é descrito em Motivation.
A solução é dividida nas seções Structure, Participants, Collaborations e Implementation.
O contexto resultante e a rationale da solução são de certa maneira tratados em Consequences.
Apesar de os design patterns da GoF não formarem uma linguagem de padrões, relacionamentos com outros design patterns são identificados em Related Patterns.
Um exemplo de design pattern que pode ser extraído do catálogo e apresentado resumidamente é o Observer.
O objetivo do padrão Observer é &quot;definir uma dependência de um-para- vários entre objetos, de maneira que quando um objeto modifica seu estado, todos os seus dependentes são notificados e atualizados automaticamente».
Para uma descrição completa do padrão, consultar o texto original nas páginas 293 a 303 em.
Um exemplo de situação real é apresentado na seção Motivation:
O padrão descreve então como a solução deve ser construída, na seção Structure, baseada nas duas abstrações principais, como mostra o diagrama de classes abaixo (Figura 3).
O problema descrito por Observer está inserido dentro de a fase de projeto detalhado de software.
Portanto, a solução do padrão descreve um determinado grupo de classes que colaboram para resolver o problema, juntamente com as responsabilidades básicas de cada uma de elas (ver Figura 3).
&quot;Considerando sistemas particionados em grupos de classes cooperantes, normalmente é necessário manter a consistência entre objetos relacionados.
Porém, promover a consistência ligando estas classes fortemente reduz as possibilidades de reutilização.
Por exemplo, muitos toolkits de interface gráfica de usuário separam os aspectos de apresentação da interface, dos dados internos da aplicação.
Classes que definem dados da aplicação e de apresentação podem ser reutilizadas independentemente.
Elas podem trabalhar juntas, também.
Tanto um objeto de planilha eletrônica quanto um objeto de gráfico de barras podem apresentar informações sobre os mesmos objetos de dados da aplicação, usando diferentes apresentações.
A planilha e o gráfico não se conhecem, permitindo portanto o reutilização apenas onde é necessário.
Mas eles se comportam como se ambos se conhecessem.
Quando o usuário muda a informação na planilha, o gráfico de barras reflete as mudanças imediatamente, e vice-versa.
Este comportamento implica que a planilha e o gráfico são dependentes do objeto de dados e, portanto, devem ser notificados de qualquer mudança em seu estado.
Isto não significa que apenas a planilha e o gráfico são os únicos dependentes;
Podem existir outras interfaces de usuário dependentes sobre os mesmos dados.
O padrão Observer descreve como estabelecer estes relacionamentos.
Os objetos chave (as abstrações chave) do padrão são Observer e Subject.
Um subject pode ter um número qualquer de observers dependentes.
Todos observers são notificados quando ocorre uma mudança de estado em subject.
Em resposta, cada observer consulta o Normalmente, a solução engloba dois aspectos.
Em primeiro lugar, classes genéricas são usadas para representar a solução genérica para o problema genérico endereçado por o padrão, juntamente com responsabilidades básicas de cada uma destas classes.
Além disso, a solução mostra como estas classes devem ser personalizadas ou adaptadas para a resolução de problemas mais específicos, de acordo com situações reais encontradas, como a descrita na seção de motivação do padrão.
A estrutura mostra as responsabilidades básicas das abstrações principais Subject e Observer para permitir o funcionamento do mecanismo de notificação/ atualização.
Elas fazem parte da representação da solução genérica para o problema.
A classe Subject conhece seus objetos observers, e fornece uma interface para incluir e retirar observers do seu conhecimento.
Esta interface é representada por as operações Attach e Detach.
Já a classe Observer define uma interface para objetos que devem ser notificados de modificações em subject.
A operação abstrata Update representa esta interface.
A classe ConcreteSubject mostra como a classe Subject deve ser adaptada para um problema específico.
Ela mantém um estado que é de interesse de seus objetos observadores, representados por a classe ConcreteObserver, e envia uma notificação para estes observers quando seu estado muda.
O atributo subjectState representa o estado mantido por cada objeto da classe, e a operação GetState genericamente indica como o estado dos objetos ConcreteSubject pode ser recuperado por os ConcreteObservers.
A classe ConcreteObserver mantém uma referência ao seu objeto observado (ConcreteSubject), armazena estado que deve estar consistente (observerState) com o objeto subject e implementa a interface de atualização para que o objeto se mantenha consistente com o estado de subject (Update), como mostra o pseudocódigo de Update.
Um exemplo clássico de utilização deste padrão é na implementação do framework MVC (Seção padrão, já que as visões de um modelo devem ser atualizadas todas as vezes que o estado do modelo é alterado.
Os design patterns da GoF são organizados no catálogo de acordo com dois critérios ou dimensões principais, que são propósito e escopo.
O primeiro critério, chamado propósito, reflete o que o padrão faz, e pode ser creational (criacional), structural (estrutural) ou behavioral (comportamental).
Padrões criacionais preocupam- se com o processo de instanciação de objetos, estruturais tratam de problemas de composição de classes e objetos, e comportamentais definem a modo em que classes e objetos interagem e distribuem responsabilidades.
O critério escopo especifica se o foco do padrão é dado sobre classes ou objetos, e podem ser class (classe) ou object (objeto).
Em resumo, padrões com escopo classe trabalham com relacionamentos entre classes e subclasses, através do mecanismo de herança, e padrões com escopo objeto trabalham com relacionamentos entre objetos, obtidos através do mecanismo de composição de objetos.
O critério escopo reflete, na verdade, o uso de abordagens white e black-box na definição da estrutura de classes e objetos da solução de cada padrão (ver Seção 3.3).
O trabalho de sugere outros tipos de critérios para classificação dos design patterns do catálogo.
Semelhante ao trabalho de, apresenta um catálogo de padrões que endereçam as fases de architectural design, detailed design e implementation.
Os autores de fazem parte de uma equipe de pesquisadores da Siemens, e são normalmente referenciados como a Gang-of-Five (GoV).
Os padrões da fase de detailed design são design patterns que endereçam problemas de projeto praticamente independentes de domínio de aplicação.
Muitos dos problemas tratados são semelhantes aos apresentados em, e soluções iguais ou ligeiramente diferentes para estes problemas são apresentadas.
A GoV usa um formato ligeiramente diferente para apresentação dos padrões, mas que contém todos os elementos essenciais.
Para maiores detalhes, consulte.
Os chamados metapatterns não são considerados patterns no sentido do termo dado inicialmente por o trabalho de Alexander, nem mesmo são descritos na forma básica contexto-problema- solução.
Os metapatterns são um conjunto de sete design patterns básicos que são utilizados freqüentemente no desenvolvimento de frameworks OO, mais abstratos e genéricos que os padrões da GoF e da GoV.
Esses padrões mostram como os pontos de estabilidade e variabilidade de frameworks podem ser definidos e preenchidos, chamados de frozen e hot-spots, os quais são representados em classes por métodos template e hook (Seção 3.3), permitindo a evolução e extensão dos frameworks através destes pontos de variabilidade.
Basicamente, os padrões descrevem como métodos template baseiam- se em métodos hook, e como estes métodos hook podem ser preenchidos (implementados).
Estes métodos hook podem então ser implementados através de herança e sobrescrita, ou através de composição de objetos e delegação.
A classe que um método template que baseia- se em outros métodos hook é chamada de classe template.
Por sua vez, a classe que dá implementação a um método hook é chamada de classe hook Os diagramas da Figura 4 mostram os sete metapatterns de.
A classe Template é indicada por a letra T, e a classe Hook por a letra H. Os metapatterns em que a mesma classe desempenha papéis de Template e Hook são identificados por unification, e aqueles onde as classes Template e Hook são diferentes são identificados por connection.
Instâncias do padrão Unification podem ser encontradas nas soluções dos design patterns Factory Method e Template Method de, assim como Strategy é uma instância de 1: N Connection.
Existem diversos design patterns que descrevem boas soluções de projeto OO para domínios específicos de aplicação.
Conforme as dimensões de classificação de padrões de software apresentadas no início da Seção 4.4, pode- se dividir estes domínios em domínios de suporte (comunicação, ambientes distribuídos), domínios genéricos de aplicação (hipermídia, sistemas de negócio) e domínios específicos de aplicação (transportes, manufatura).
Alguns dos trabalhos existentes nesta categoria de padrões são linguagens, que obviamente endereçam problemas de projeto de software OO.
Muitos destes padrões relacionam- se de alguma maneira com design patterns mais genéricos, como os de e, principalmente no projeto de frameworks OO, com os metapatterns de.
Estes relacionamentos são dados de diversas formas;
Um padrão dependente de domínio pode usar um padrão genérico existente na desenvolvimento de sua solução, ou mesmo ser uma especialização de um padrão mais genérico.
Um exemplo interessante de design pattern dependente de domínio pode ser extraído da linguagem foi desenvolvida para tratar problemas no projeto de sistemas de transporte.
O padrão ponto, e suporta múltiplos papéis concorrentes exercidos por um ponto numa rede de transporte.
Um ponto é usado para definir rotas, e rotas são caminhos entre uma seqüência ordenada de pontos numa rede de transportes».
Para entender o real problema endereçado por o padrão Point, deve- se ter um conhecimento maior sobre o domínio de sistemas de transportes, o que está fora de o escopo deste trabalho.
Para fins de praticamente igual ao da GoF.
A solução apresentada é um refinamento ou especialização da solução dada por o padrão State, e até mesmo do metapattern (mais genérico) 1: N Connection.
Assim como para os padrões da GoF e da GoV, a solução apresenta as abstrações chave da estrutura de classes, as responsabilidades básicas de cada uma de elas, e como a solução deve ser adaptada interface para encapsular o comportamento associado com um particular papel exercido por um ponto.
Os conceitos de design patterns e frameworks são confundidos em algumas vezes, apesar de existires algumas diferenças fundamentais.
Ambos são elementos de projeto que contém microarquiteturas de classes e objetos cooperantes para resolver um problema recorrente de projeto OO.
Em, são apresentadas três diferenças importantes entre design patterns de propósito geral (como os da GoF e da GoV) e frameworks:
Os padrões arquiteturais (architectural patterns) são aqueles relacionados com a etapa de projeto arquitetural.
Em esta etapa é feito o projeto de software num alto nível de concepção, mais abstrato que design patterns, mas ainda relacionado com o espaço de solução do problema representado por a etapa de análise.
Define padrões arquiteturais da seguinte maneira:
&quot;An architectural pattern expresses a fundamental structure organization schema for responsibilities, and includes rules and guidelines for organizing the relationships between them.»
Padrões arquiteturais servem então como modelos para a criação de arquiteturas concretas de software.
Em, são apresentados diversos padrões arquiteturais, como por exemplo o Model-View--Controller (MVC), para aplicações interativas, que é uma representação em forma de padrão do framework MVC apresentado na Seção 3.1.
As soluções apresentadas por padrões arquiteturas mostram como a especificação de um software feita nas fases de Análise de Requisitos ou Análise de Sistema pode evoluir para uma determinada arquitetura de subsistemas, de acordo com o tipo de problema endereçado por o software, e também com diversas forças que atuam sobre o problema.
A partir de as características comuns de diversos padrões arquiteturais, eles são classificados por a GoV em quatro grupos:
De Lama a Estrutura:
Padrões desta categoria ajudam a evitar um &quot;mar «de componentes ou objetos.
Em particular, eles suportam uma decomposição controlada de uma tarefa global do sistema em tarefas cooperativas.
Sistemas Distribuídos: Fornecem infra-estruturas completas para dar suporte a aplicações distribuídas.
Sistemas Interativos: Suportam a estruturação de softwares que trabalham com interação homem-máquina.
Sistemas Adaptáveis: Suportam a extensão de aplicações e sua adaptação à evolução da tecnologia e a mudanças em requisitos funcionais.
O formato utilizado por a GoV para apresentação de padrões arquiteturais é semelhante ao da GoF, que é o mesmo utilizado para os design patterns da GoV (Seção 4.4.2).
Um padrão arquitetural que pode ser resumidamente apresentado aqui é o Layers, cuja descrição completa encontra- se em.
O padrão Layers &quot;ajuda a estruturar aplicações que podem ser decompostas em grupos de subtarefas em que cada grupo de subtarefas está em determinado nível de abstração».
Em resumo, ele indica a organização de subsistemas de software que executam tarefas em diferentes níveis de abstração, na forma de múltiplas camadas, iniciando com a camada de mais baixo nível até a de mais alto nível, definindo também um protocolo básico de comunicação entre os níveis.
A descrição do problema endereçado por o padrão Layers pode ser resumida assim:
&quot;Imagine que você está elaborando um sistema cuja característica dominante é uma mistura de questões de baixo e alto nível, onde as operações de alto nível dependem das de baixo nível.
Algumas partes do sistema tratam diretamente com aspectos de baixo nível, como elementos de hardware, e outras partes são responsáveis por questões de comunicação consiste em pedidos movendo- se de alto para baixo nível, e respostas para partes de um sistema devem ser substituíveis.
Componentes devem poder ser pode ser necessário construir outros sistemas num outro momento com os mesmos aspectos de baixo nível do sistema atualmente em desenvolvimento.»
Assim como todos os padrões arquiteturais descritos em, a construção da solução é mostrada primeiramente de forma textual.
A estrutura da solução mostra como os blocos de construção ou subsistemas para resolver o problema arquitetural devem ser projetados, usando a notação de CRC-cards.
Cada subsistema é descrito através de um CRC-card, que define as responsabilidades básicas e colaborações de cada um, em alto nível de abstração.
Para o padrão Layers, a primeira parte da solução seria:
&quot;Solução: De um ponto de vista de alto nível, a solução é extremamente simples.
Estruture seus sistema num número apropriado de camadas, colocando cada camada no topo de uma outra.
Comece com a de mais baixo nível ­ chame- a de Layer 1.
Esta é a base do sistema.
Vá construindo a &quot;escada «de abstrações colocando a camada (Layer) J no topo da camada (Layer) J-1, até que seja atingida o nível mais alto de funcionalidade ­ chame- a de Layer N. Uma camada individual pode ser descrita por o seguinte CRC-card:
Class Layer J Responsibility· fornece serviços usados por Layer J+ 1 Collaborator· Layer J-1· delega subtarefas a Layer A principal característica estrutural do padrão Layers é que os serviços de Layer J são Client uses Layer N highest level of abstraction Layer N-1 Layer 1 lowest level of abstraction A construção da solução do padrão ainda continua, mostrando textualmente os aspectos dinâmicos da estrutura de múltiplas camadas, ou seja, como as camadas vão se comunicar, através do envio de pedidos das camadas de mais alto nível para as de mais baixo nível, e como as de mais baixo nível vão comunicar respostas, entradas de dados e notificações de eventos ocorridos para as de camadas mais altas.&amp;&amp;&amp;
Após isto, aspectos específicos de implementação da solução, e variantes da solução original, são considerados e apresentados.
Um exemplo comum de aplicação do padrão Layers é na definição de protocolo de redes da International Standardization Organization (Iso), que define o modelo arquitetural OSI 7-Layer.
A Arquitetura de Desenvolvimento de SAD (Capítulo 5) propõe a estruturação de sistemas de apoio à decisão orientados a modelos num grupo de quatro camadas, e pode ser considerada com uma instância de aplicação do padrão Layers.
Os padrões de implementação, ou padrões de código, resolvem problemas recorrentes na etapa de implementação de software e, portanto, são dependentes de uma linguagem de implementação específica, não necessariamente sendo uma linguagem OO.
Uns dos trabalhos pioneiros desta categoria é o de, que apresenta diversos padrões de implementação (chamados de idiomas), apesar destes padrões não estarem documentados na forma básica contexto-problema- solução.
Aspectos tratados por estes tipos de padrões são por exemplo definição de nomes significativos para variáveis, escrever laços, definição de construtores default de objetos (específico de C+), etc..
Uma linguagem de padrões pode ser vista como um &quot;super-padrão», que é dividido em diversos padrões menores que colaboram para resolver o problema mais genérico endereçado por este superpadrão.
Uma linguagem de padrões pode tanto ser comparada a um livro didático do tipo &quot;how-to», como a um manual de referência, já que pode ser usada passo a passo, começando por os padrões mais genéricos, que expõem os problemas mais genéricos tratados por a linguagem, seguindo para outros padrões mais específicos através das conexões formadas entre eles, e que também pode ser usada como guia de referência, onde o usuário da linguagem procura por um padrão específico, de acordo com critérios pré-estabelecidos.&amp;&amp;&amp;
Linguagens de padrões diferem de coleções, catálogos ou sistemas, como os trabalhos de.
Uma linguagem de padrões é um conjunto de padrões fortemente ligados, que cobre os problemas relevantes de um determinado domínio.
Idealmente, uma linguagem de padrões deve ser computacionalmente completa.
Alguns autores definem catálogos e sistemas similarmente, como &quot;coleções de soluções para coleção de problemas», onde padrões estão pouco ou informalmente relacionados, organizados de acordo com esquemas de classificação.
Outros autores consideram bastante sutil a diferença entre linguagem e sistema de padrões, argumentando que sistemas podem evoluir para linguagens de padrões, sendo que para isto devem tornar- se computacionalmente completos e tratar todos os problemas relevantes do domínio endereçado.
Além disso, outros autores utilizam os termos proto-padrão e proto-linguagem de padrões para denominar padrões e linguagens de padrões que encontram- se num estágio inicial de elaboração.
A estrutura de uma linguagem de padrões pode ser comparada a um grafo, onde padrões são os nós e os relacionamentos são as arestas.
Os relacionamentos podem determinar a ordem de aplicação dos padrões, e o usuário da linguagem pode escolher caminhos deste grafo para tratar subproblemas ou grupo de subproblemas da linguagem, gerando diversas combinações.
Os relacionamentos entre os padrões de uma linguagem são formados através de referências explícitas definidas na descrição textual de cada padrão.
Normalmente, as partes dos padrões que descrevem solução, contexto resultante e padrões relacionados mostram quais padrões podem ou devem ser usados após a aplicação de um padrão, enquanto contexto pode especificar quais padrões são pré-requisito de um padrão, isto é, quais padrões devem ser usados antes de usar um determinado padrão.
Algumas linguagens de padrões publicadas tentar dar uma apresentação geral do grafo de padrões da linguagem, através do desenho de grafos, ou através de resumos que guiam a ordem de aplicação de padrões.
Apesar de não existir nenhum registro formal e um consenso na comunidade de padrões, existem diferentes tipos de relacionamentos formados entre padrões.
Em a linguagem de Alexander (Seção 4.2), esses relacionamentos são dados por escala.
Padrões de maior escala são completados por os de menor escala, e os de menor escala dependem dos de maior escala.
Existem alguns trabalhos que tentam capturar e classificar diferentes espécies de relacionamentos que existem em padrões, como os de.
O trabalho de identifica os três tipos primários de relacionamentos básicos descritos abaixo:
Usa (Uses):
Padrões usam outros padrões que o completam.
Este tipo de relacionamento é o único explicitado em.
Os padrões de são organizados de maneira que cada padrão é seguido por outros padrões de menor escala que ele usa.
Especializa (Refines):
Um padrão é uma especialização de outro padrão quando endereça um problema que é uma especialização do problema tratado por o padrão mais genérico.
Por exemplo, o design pattern Factory Method é uma especialização do metapattern Unification.
É Conflitante (Conflicts):
Padrões são conflitantes quando fornecem soluções exclusivas para um problema semelhante.
Por exemplo, os design patterns Prototype e Factory Method são conflitantes porque dão soluções diferentes para o problema de criação de objetos, cada uma com diferentes conseqüências no projeto.
Estas características de linguagens de padrões ressaltam a utilização como guia passo a passo, e como podem ser utilizadas como alternativa à documentação tradicional como estilos &quot;how-to», Como guia de referência, o usuário de uma linguagem pode procurar por um padrão que atenda os critérios de um problema específico.
Estes critérios podem estar ligados com as propriedades de contexto, problema, forças, contexto resultante, etc., que se deseja encontrar num determinado padrão.
O usuário pode rastrear uma linguagem procurando algum padrão que atenda os requisitos, ou usar recursos de índice de procura, que são normalmente oferecidos por linguagens de padrões.
Os catálogos e sistemas de tentam facilitar a busca de padrões dando classificações especiais para os padrões.
Por exemplo, em, os padrões são classificados de acordo com propósito e escopo.
O propósito está relacionado com o ponto de variabilidade principal de um projeto endereçado por um padrão, enquanto o escopo reflete se o padrão sugere abordagem white-box ou black-box.
Para estas classificações, é criado um índice que o usuário pode consultar para procurar um padrão.
Outro índice fornecido em apresenta rapidamente qual o problema de projeto que cada padrão trata.
Algumas linguagens de padrões tentam classificar e organizar padrões de acordo com determinados critérios, oferecendo também índices de procura.
Por exemplo, os padrões são classificados e agrupados de acordo com a escala de aplicação de cada padrão, como Regiões, Cidades, Bairros, o problema tratado e, além disso, os padrões são agrupados em quatro categorias, para facilitar a utilização da linguagem.
Um Sistemas de Apoio à Decisão (SAD) é um software que têm o objetivo de auxiliar as pessoas no processo de tomada de decisão, é &quot;um sistema de informação computadorizado que afeta ou pretende afetar o modo como pessoas tomam decisões».
Como o próprio nome diz, um SAD não tem o objetivo de tomar o papel de decisores na tomada de decisão, mas sim fornecer recursos, subsídios, para que os decisores possam tomar decisões com maior eficiência.
Em o desenvolvimento de SAD, duas questões importantes devem ser consideradas.
Em primeiro lugar, é necessário rapidez e flexibilidade (produtividade) nas tarefas de desenvolvimento e manutenção dos sistemas, uma vez que eles devem refletir as rápidas mudanças que ocorrem nas necessidades de suporte à decisão das organizações.
Isto não é uma preocupação exclusiva do campo de SAD, faz parte dos problemas gerais da área de Engenharia de Software.
Em segundo lugar, os SADs devem dar capacidade de manipulação dos problemas de decisão para os decisores.
Em outras palavras, SADs devem permitir que decisores manipulem seus problemas de decisão diretamente, sem a necessidade de um especialista.
Normalmente, se decisores não entendem ou não participaram do processo de estruturação dos problemas de decisão, eles sentemse desencorajados a utilizar os sistemas.
A Arquitetura OO de Desenvolvimento de SAD proposta em tem como objetivo tentar resolver ou minimizar estes dois problemas potenciais de desenvolvimento de SAD.
A arquitetura mostra ainda como a produtividade em desenvolvimento de SAD pode ser aumentada através da reutilização e conexão de frameworks genéricos de diferentes naturezas, baseada nos mesmos benefícios esperados da orientação a objetos para aplicações em geral.
Ela tem como aplicações alvo SADs que incorporem diversas propriedades que facilitam a definição de problemas de decisão para os decisores, oferecendo conceitos do seu mundo cognitivo.
A Arquitetura pode ser considerada como um guia para o desenvolvedor de SADs.
A Seção 5.1 descreve o conceito de Sistemas de Apoio à Decisão, e a Seção 5.2 caracteriza o conceito de modelos de decisão.
A Seção 5.3 descreve com detalhes a Arquitetura de Desenvolvimento de SAD baseado em frameworks apresentada em, e a Seção 5.4 mostra algumas limitações e problemas encontrados na Arquitetura, que fazem parte da motivação deste trabalho.
Existem diversas definições para SAD, e muitas são as fontes de discordância nas suas definições.
Uma definição geralmente aceita para SAD é a de que &quot;são sistemas que têm o objetivo de auxiliar pessoas em tomada de decisão, ajudando- os a usar modelos e dados para resolver problemas de decisão semi-estruturados a não-estruturados «(Figura 6).
A arquitetura funcional de SADs proposta por Sprague identifica três principais componentes funcionais, chamados de componente de modelos (MBMS), componente de dados (DBMS) e componente de diálogo (DGMS), que é apresentada na Figura 7.
Estes componentes foram propostos como uma referência para identificar as capacidades técnicas que um SAD deve possuir.
Os SADs que obedecem esta arquitetura funcional normalmente são classificados como SADs orientados a modelos.
O componente de diálogo (Dialog Generator and Management System -- DGMS) é responsável por a gerência do elementos de interface com o usuário.
O componente de dados (Database Management Systems -- DBMS) representa os Sistemas de Gerência de Bancos de Dados, que são uma tecnologia madura, e seu conjunto de funcionalidades é bem conhecido por a comunidade de engenharia de software.
O componente de modelos (Model Base Management Systems -- MBMS) tenta dar para modelos o que há muito tempo a tecnologia de DBMS conseguiu para dados, considerando modelos como um recurso organizacional importante.
Modelos são instrumentos que auxiliam a tomada de decisão, transformado dados em informação.
Uma das mais importantes contribuições do movimento de SAD foi a identificação de modelos como parte integral de Sistemas de Informação, além de dados.
Infelizmente, MBMS não é uma tecnologia bem compreendida, principalmente quando comparada a DBMS.
Entre as capacidades que um MBMS deve possuir, estão:
Em a arquitetura funcional de Sprague, o termo modelo é usado para designar um procedimento ou subrotina computadorizados, o que leva a várias interpretações, desde operações básicas matemáticas/ lógicas e procedimentos independentes de problema (programação linear, regressão, correlação), até procedimentos específicos dependentes de problema (ex:
Um modelo representando um problema particular de mistura de alimentos).
Apesar de a arquitetura funcional de Sprague ser uma referência bastante aceita para a definição de SAD, há muitas fontes de discordância na definição deste tipo de sistema, como já mencionado.
Por exemplo, sistemas como Executive Support Systems (ESS), Executive Information Systems (Eis), Datawarehouse, etc., também apoiam decisores, mas não fornecem o componente modelo, sendo comumente chamados de SADs orientados a dados.
A necessidade de considerar dados com um recurso importante a ser gerenciado sistematicamente por as organizações tem sido reconhecida já a bastante tempo.
A filosofia de SAD argumenta que uma abordagem equivalente deve ser dada a modelos.
Em resumo, um modelo é o resultado do processo de estruturação de um problema.
Assim como são usados modelos de classes para estruturar problemas de projeto de software orientado a objeto, são usados também modelos para a especificação de problemas de decisão.
Modelos de decisão permitem que dados sejam transformados em informação relevante para a tomada de decisão.
A rápida proliferação do uso de modelos dentro de organizações, particularmente desde o surgimento de ambientes individuais de modelagem (ex.:
Softwares de planilha eletrônica, linguagens de planejamento financeiro), permitindo que pessoas não-especialistas construam seus próprios recursos de auxílio à decisão, tem levado a um crescente reconhecimento da necessidade de gerenciar modelos organizacionais de uma maneira similar ao gerenciamento de dados organizacionais através de DBMS.
Em resumo, a descentralização da construção, propriedade e uso de modelos, normalmente resulta em representações e definições inconsistentes, levando a circunstâncias onde um modelo apropriado existe mas não é reconhecido, ou um modelo existente é aplicado inadequadamente.
Portanto, os mesmos problemas que eram evidentes no reconhecimento da necessidade de gerência de dados, também existem em ambientes de modelagem, como redundância e inconsistência, integridade, falta de padronização e compartilhamento, e independência física/ lógica.
Isto demonstra a real necessidade de considerar modelos como um recurso organizacional que precisa ser efetivamente gerenciado, como por exemplo através de sistemas generalizados de gerência de modelos (Generalized MMS) A representação de modelos é uma questão importante em sistemas de gerência de modelos, onde não existe consenso na definição.
Particularmente, um modelo de decisão possui diversas interpretações e representações, que refletem visões de diferentes níveis, desde visões orientadas a usuário até orientadas a execução.
Por exemplo, um decisor pode formular um modelo para um problema de decisão de domínio financeiro, relacionando conceitos do domínio como vendas, preço, quantidade, e dimensões como período e produto.
Ele pode especificar estas relações usando um modelo algébrico de representação, mostrando que o valor das vendas de um determinado produto, dentro de um período, corresponde ao preço do produto multiplicado por a quantidade vendida no produto:
O mesmo modelo pode ser representado através de Structured Modeling, uma notação gráfica bastante para a representação de modelos de decisão específicos:
Vendas quantidade tempo preço produto Estas representações são orientadas a domínio, pois o modelo é expresso diretamente usando os conceitos derivados do domínio que o decisor trabalha.
Por outro lado, este problema tem que ser resolvido, e para isto o modelo deve ser expresso de maneira que possa ser aplicado a uma técnica de resolução existente, como capacidades de planilhas eletrônicas, programação linear, regressão Usando um software de planilha eletrônica para resolver o problema, o decisor especifica o seu modelo de decisão usando células, colunas e linhas.
Os conceitos vendas, preço e quantidade, e suas relações, são expressos numa planilha usando valores e fórmulas definidos em células, como por exemplo:
A célula D2 representa venda, e seu valor é definido através da multiplicação do conteúdo das células D3 e D4, que representam respectivamente preço e quantidade.
Esta é a fórmula para um valor de dimensão temporal (período) e para um produto apenas.
Para calcular o valor das vendas para todos os valores das dimensões período e tempo, o decisor que está usando o software de planilha eletrônica normalmente faz uma cópia relativa do conteúdo destas células contemplando todos os valores das dimensões, preenchendo posteriormente os valores correspondentes.
Este tipo de representação é orientada a execução.
O grande problema deste tipo de abordagem é a falta de significado para o decisor, causando dificuldade no entendimento do modelo.
Para o decisor, é muito mais fácil e familiar visualizar o seu modelo de decisão usando conceitos do seu mundo cognitivo, orientados a domínio, como vendas e preço de produto, do que valores e fórmulas em células de uma planilha.
A aceitação de SADs orientados a modelo, por parte de os decisores, como ferramenta de suporte à tomada de decisão, ainda é limitada.
Isto porque a especificação e implementação de modelos é normalmente feita por especialistas, e decisores não se sentem confortáveis em utilizar modelos que eles não entendem, sobre os quais tiveram pouca ou nenhuma participação no desenvolvimento.
Um dos assuntos de pesquisa mais importantes em SAD está relacionado com o fornecimento de ambientes de modelagem para usuários que não são especialistas em modelagem, principalmente permitindo que decisores manipulem seus problemas de decisão diretamente, sem intermediários, usando conceitos do seu mundo cognitivo.
A Arquitetura de Desenvolvimento de SADs mostra como produzir SADs específicos através da reutilização e conexão de diferentes tipos de frameworks, que executam diferentes papéis em SAD específico.
Os diferentes tipos de frameworks são resultado da identificação de aspectos independentes que podem ser reutilizados separadamente em diferentes aplicações, de acordo com as características especiais dos SADs alvo da Arquitetura.
A Seção 5.3.1 destaca as propriedades especiais do tipo de SAD endereçado por a Arquitetura.
A Seção 5.3.2 mostra como a Arquitetura divide frameworks de diferentes tipos para a produção de SADs de múltiplas camadas, e quais as responsabilidades de cada camada numa aplicação.
As seções 5.3.3 e 5.3.4 mostram com mais detalhes as características dos frameworks das camadas que compõem interface e semântica de uma aplicação.
O processo de conexão de frameworks de diferentes camadas para a produção de um SAD específico é mostrada na Seção 5.3.5.
Em a Seção 5.2, é destacada a dificuldade de aceitação de SADs orientados a modelos por parte de os decisores, principalmente porque geralmente os decisores não são envolvidos no processo de modelagem dos seus problemas, e portanto sentem- se desencorajados a utilizar aquilo que não entendem ou que tiverem pouca ou nenhuma participação na elaboração.
Basicamente, para dar a decisores capacidades de modelagem, a Arquitetura OO de Desenvolvimento de SADs proposta em guia a criação de SADs que ofereçam conceitos do mundo cognitivo dos decisores para a manipulação de problemas de decisão.
A idéia principal é capturar os conceitos do domínio dos problemas, tornando o processo de formulação de modelos simplesmente escolher, aplicar e relacionar estes conceitos para descrever um problema de decisão específico, compatível com as práticas comumente usadas por os decisores.
Outras características especiais dos SADs produzidos com o uso da Arquitetura são:
Payback Period. Modelos para esta classe de problemas de decisão podem ser formulados em termos de conceitos como período de duração de um projeto de investimento, receitas e mostram alguns destes conceitos, através de um SAD exemplo, e a Figura 12 mostra a instanciação do conceito Time, que é o período de duração de um projeto.
Específico de Capital Budgeting A estrutura hierárquica entre itens orçamentários, formada por as dependências entre os diferentes tipos de itens, pode ser representada por uma estrutura de árvore.
A árvore de itens genéricas apresentada na Figura 10 mostra ao usuário a natureza dos itens que podem ser especificadas, e os relacionamentos válidos entre elas.
Um item pode ser uma receita (R), uma despesa (D), um investimento (I) ou um saldo, que representa a diferença entre itens de diferentes naturezas.
Itens elementares (receitas, despesas, investimentos) podem ser agregados.
A Figura 11 mostra uma árvore representando um problema específico de Capital Budgeting.
Figura 12 ­ Definição do Tempo de Duração do Projeto A Arquitetura de Desenvolvimento de SADs baseada em frameworks proposta em foi criada considerando- se as características dos SADs alvo destacadas na Seção 5.3.1.
Ela é baseada no fato de que é possível isolar componentes freqüentemente encontrados em SADs desta natureza, e representar- los através de frameworks reutilizáveis.
Por exemplo, SADs completamente distintos podem ser construídos usando estruturas gráficas comuns (ex.:
Tabelas, grafos) ou com as mesmas técnicas de resolução (ex.:
Planilha, programação linear).
A Arquitetura identifica a natureza de componentes potencialmente reutilizáveis, seu papel genérico dentro de SADs específicos, e o tipo de relacionamento com os demais tipos de componentes.
Assim, espera- se desta abordagem as mesmas vantagens em termos de qualidade e produtividade esperada do uso de frameworks OO para aplicações em geral, em Engenharia de Software.
A Arquitetura segue o mesmo princípio de aplicações interativas, que distinguem a semântica da interface, para que ambas possam evoluir de maneira independente.
Mais especificamente, a Arquitetura divide a interface em duas camadas, guias e apresentação, enquanto a semântica é representada por as camadas situação de decisão e resolução, como mostrado na Figura 13.
Cada camada define o conjunto de responsabilidades a serem assumidas por suas classes:
Camada de Situação de Decisão:
Suas classes são usadas para descrever soluções genéricas para classes de problemas de decisão, representando modelos orientados a problema.
Operações são oferecidas para modelagem de problemas.
Camada de Resolução:
Suas classes são usadas para descrever diferentes técnicas e métodos de resolução de problemas de decisão.
Operações são oferecidas para modelagem, consulta e resolução dos problemas de decisão.
Camada de Apresentação:
Suas classes são usadas para descrever como estruturas genéricas de representação, como tabelas e grafos, que podem ser adaptadas para se tornarem a representação visual para os conceitos capturados na camada de situação de decisão.
Operações são oferecidas para tratar com o significado conceitual de uma estrutura de apresentação, e com seu comportamento gráfico.
Camada de Diálogo:
Suas classes capturam todos os aspectos de diálogo da interface, definindo os cenários de interação para as atividades de modelagem e resolução.
Figura 13 ­ Camadas de Frameworks Reutilizáveis e Criação de SAD Através da Conexão de Frameworks A Arquitetura deve ser vista sob dois pontos de vista:
Decomposição e composição.
De o ponto de vista de decomposição, cada camada define o papel que frameworks de uma determinada natureza assumem num SAD.
A cada camada corresponde um tipo de framework, discutidos em mais detalhes nas seções 5.3.3 e 5.3.4.
De o ponto de vista de composição, um SAD específico não necessita ser criado a partir de o zero, mas sim através da seleção, adaptação e conexão de frameworks genéricos, formando um SAD de múltiplas camadas.
A Arquitetura atua assim como um guia de desenvolvimento de SADs específicos, destacando os tipos de componentes e suas responsabilidades, definindo o protocolo genérico de interação entre os objetos de diferentes camadas, e mostrando como SADs específicos podem ser construídos através de adaptação e conexão de frameworks.
A construção de um SAD específico é feita, como mostra a Figura 13, através da seleção e conexão de frameworks genéricos, e ligação das instâncias dos frameworks, formando um SAD de múltiplas camadas, definindo um protocolo básico de comunicação entre os objetos de diferentes camadas, que reflete o modo com os objetos cooperam e interagem para dar a funcionalidade completa ao SAD específico.
A Figura 14 mostra diferentes cenários de colaboração entre objetos de diferentes camadas, iniciados a partir de a camada superior da aplicação, com a qual o usuário da aplicação interage, definindo o comportamento básico de um SAD de múltiplas camadas.
A Arquitetura foi validada em através do desenvolvimento de dois estudos de caso, Atividades Industriais.
Será tomado como exemplo nesta dissertação aspectos parciais do estudo de caso de Capital Budgeting, apresentado resumidamente na Seção 5.3.1 e disponível com mais detalhas no Anexo 1 deste documento, para ilustrar alguns aspectos do desenvolvimento e conexão de frameworks na produção de um SAD específico para esta classe de problemas.
O termo modelo de decisão possui diversas interpretações, que refletem visões de diferentes níveis, desde visões orientadas a usuário até orientadas a execução.
Para o propósito desta arquitetura, um modelo de decisão é a representação, de acordo com alguma notação, dos elementos que caracterizam um problema de decisão, com o objetivo de procurar, analisar e avaliar possíveis soluções.
Como qualquer modelo, um modelo de decisão é sempre uma representação incompleta e aproximada da realidade, constituindo uma abordagem particular para tratar com o problema de decisão original, podendo ser expresso de acordo com sucessíveis níveis de abstração.
Fazendo- se uma analogia com o campo de Engenharia de Software, a expressão de um modelo de decisão é feita de acordo com três níveis de abstração, chamados de especificação, projeto e implementação.
O primeiro nível está ligado ao espaço de problema, enquanto os outros lidam com o espaço de solução.
O espaço de solução no campo de SAD preocupa- se com a escolha do método ou técnica para resolver o problema.
Entre os métodos e técnicas de resolução mais conhecidos, pode- se citar pressupõe um determinado paradigma de modelagem, consistindo num conjunto de conceitos específicos e relacionamentos, do mesmo modo que o problema de decisão foi estruturado.
Por exemplo, se um modelo de decisão é formulado como um programa linear, então a modelagem do modelo consiste em identificar as variáveis de decisão e os coeficientes, e estruturar- los como uma função objetivo linear e um conjunto de restrições lineares.
A o nível de projeto, pode- se abstrair detalhes de implementação, como a escolha de algoritmos (ex.:
Simplex, branch&amp; bround) e das particularidades de linguagens disponíveis em ferramentas de implementação.
O espaço de problema em SAD consiste em caracterizar a situação de decisão, independentemente da técnica para resolver- lo.
Uma das maneiras de abordar um problema de decisão ao nível de especificação é através do uso de uma teoria existente para uma classe de problemas de decisão.
Esta abordagem é tratada em como Teoria de Domínio.
Se uma teoria de domínio é usada, seus conceitos e relacionamentos podem guiar a identificação dos elementos no problema de decisão que podem ser usados para analisar e avaliar- lo, assim como auxiliar a estruturação destes elementos no modelo de decisão.
Por exemplo, a aplicação da teoria do domínio de capital budgeting para especificar um problema de investimento envolve a caracterização de um projeto de investimento por os seus período de vida e fluxo de caixa, a seleção de critérios de Baseado então no reconhecimento dos espaços de problema e solução na formulação de um modelo, foram identificadas em dois tipos distintos de frameworks para desenvolver a camada de semântica de um SAD, gerando as camadas de situação de decisão e resolução.
Um framework de situação de decisão fornece um paradigma de formulação de modelos genéricos para uma classe de problemas de decisão, de acordo com problemas específicos da classe que podem ser especificados, independentemente de como eles podem ser resolvidos.
Um framework de situação de decisão é, portanto, um conjunto de classes que interagem e que representam conceitos de modelagem orientados a domínio, derivados de uma teoria de domínio.
Problemas de decisão específicos podem ser expressos por a criação de instâncias destes conceitos.
Para agir como um paradigma de formulação de modelos, um framework de situação de decisão tem que capturar não apenas os conceitos e relacionamentos sob uma teoria de domínio, mas também os aspectos genéricos de sua utilização para representar o problema particular.
Entretanto, a aplicação de uma teoria de domínio para especificar um modelo de decisão não é feita através de um processo determinístico, sendo normalmente baseada em empirismo.
Como o número de transposições de uma teoria de domínio para modelar um problema particular é muito grande, possivelmente infinito, é impossível capturar todas elas.
Portanto, a genericidade de um framework de situação de decisão, relativa a uma classe de problemas de decisão, recai nos elementos invariantes que podem ser identificados na modelagem de problemas de decisão desta classe, com os conceitos e relacionamentos implícitos numa teoria de domínio.
Em a representação destes elementos invariantes de modelagem, as classes que compõem um framework de situação de decisão são abstrações que:
Capturam conceitos e relacionamentos da maneira que aparecem na teoria de domínio, ou;
Fatorizam características comuns a um conjunto de conceitos para representar abstrações de alto nível, ou;
São especificamente adicionadas para propósitos de estruturação, ou para permitir maior flexibilidade no processo de definição do modelo.
Os métodos das classes permitem criação, atualização e eliminação de instâncias, com também recuperação de informações associadas a elas.
Em são considerados também métodos para definir questões típicas que alguém queira aplicar sobre os problemas da classe de decisão.
Questões típicas para os problemas de capital budgeting seriam, por exemplo, questões são abstratos, uma vez que frameworks de situação de decisão são independentes de frameworks de resolução.
Isto fica claro porque diferentes técnicas de resolução podem ser aplicadas a mesma especificação do problema, e os frameworks de situação de decisão e modelo de resolução só são conectados no desenvolvimento de SAD específicos.
A Figura 16 apresenta um diagrama de classes UML com a modelagem simplificada do framework de situação de decisão para Capital Budgeting.
A modelagem completa do framework Capital Budgeting pode ser encontrada em.
Item é a classe que contém tudo o que é comum entre os conceitos de receita, despesa, investimento e saldo, os quais são considerados naturezas de um item orçamentário.
Os itens são organizados numa hierarquia, que forma uma estrutura de árvore, que é representada por ItemHierarchy.
ItemHierarchy marca na verdade o início da árvore, mantendo uma referência ao elemento raiz da árvore, que é o fluxo de caixa do projeto.
Os relacionamentos entre os itens é dado por a associação com papel components da classe Item.
As operações new, SetLabel, etc., são operações correspondentes às mensagens de modelagem que podem ser enviadas para um objeto Item, de acordo com a Figura 14.
Um framework de resolução captura de um lado o paradigma genérico de modelagem implícita numa determinada técnica de resolução e, de outro lado, os detalhes algorítmicos desta técnica.
Em a captura do paradigma de modelagem, o conjunto de classes que compõem um framework de modelo de resolução captura os conceitos, relacionamentos e premissas essenciais necessários para a formulação de um modelo de decisão no espaço de solução.
Além de o paradigma de modelagem, ele também contém métodos que implementam os algoritmos para resolução, análise sensitiva e otimização de modelos, ou também define uma interface com funções de implementação de ferramentas/ geradores de SAD.
A segunda alternativa é baseada na observação de ferramentas de implementação para várias técnicas de resolução já existem disponíveis no mercado, como por com a solução adotada, o framework pode conter classes adicionais para representar estruturas de dados necessárias para aplicar os algoritmos de resolução, assim como os procedimentos de transformação.
Por exemplo, para resolver um programa linear, ele deve ser transformado de um conjunto de expressões algébricas (paradigma de formulação de modelo) para uma matriz que contém apenas coeficientes das variáveis de decisão.
Entre as tecnologias e técnicas de resolução mais conhecidas, pode- se citar programação linear, Um exemplo simplificado de um framework de resolução é mostrado no diagrama UML da Figura Algébrico Descritivo), que é essencialmente baseado na especificação de relacionamentos causais dirigidos entre variáveis.
Ele assume uma técnica de resolução quanto os valores atribuídos às variáveis são explicitamente fornecidos ou deduzidos por a aplicação de relacionamentos.
Portanto, esta técnica é similar àquela encontrada em planilhas eletrônicas.
A Figura 17 apresenta apenas os principais relacionamentos estruturais entre estas classes.
As operações consideradas para as classes permitem a criação, atualização, recuperação e eliminação de instâncias.
Também considera métodos de resolução, usados para resolver o modelo.
Inicialmente, um DAM pode ser visto como um conjunto de variáveis, onde cada variável é caracterizada por uma expressão de avaliação, definindo como os valores são atribuídos à variável.
Outros dois principais conceitos completam o framework, chamados de VariableType e Dimension.
Cada variável está relacionada com um tipo de variável (VariableType), e depois é classificada como SimpleVariable ou DimensionedVariable, dependendo se a variável está associada ou não a dimensões.
Uma variável simples é uma abstração para um valor único, enquanto uma variável dimensionada é uma abstração para um conjunto ou seqüência de valores.
Por exemplo, dado o tipo de variável &quot;sales «e a dimensão &quot;product», é possível definir a variável dimensionada &quot;salesproduct «(as vendas por produto) e a variável simples &quot;sales «(o total de vendas dos produtos).
Operações como SetName, SetIndex e SetEvaluationExpr da classe Dimension correspondem a mensagens de modelagem que são enviadas por a camada de situação de decisão, e operação Evaluate corresponde a uma mensagens de resolução, de acordo com a Figura 14.
A modelagem completa do framework DAM pode ser encontrada em.
O principal objetivo da camada de apresentação é extrair da parte de semântica os conceitos que são relevantes para a especificação e resolução de problemas de decisão de uma determinada classe, fornecendo aos usuários do SAD uma visão coerente e homogênea de modelos, compatível com seu mundo cognitivo.
Em, o autor baseia- se na premissa de que existe um número de estruturas de apresentação de propósito geral com as quais os decisores estão familiarizados, e que podem ser convenientemente adaptadas e usadas com uma representação visual de uma variedade de problemas de decisão.
Uma tabela, por exemplo, pode convenientemente representar um problema de capital budgeting, um problema de orçamento, um problema de formulários, estruturas hierárquicas, grafos, fórmulas algébricas textuais.
Frameworks que descrevem estas estruturas de apresentação de propósito geral são considerados como frameworks de apresentação.
Estruturas de apresentação de propósito geral podem ser caracterizadas por um número de conceitos, relacionamentos e comportamento, independentemente do uso particular que pode ser feito de elas.
Isto determina, por um lado, as propriedades visuais básicas da estrutura e, por outro lado, como ela pode ser manipulada.
Por exemplo, um grafo é composto de um conjunto de nós e arestas, sendo manipulado através da inserção, remoção e atualização de nós e arestas.
Operações definidas por as classes de frameworks de estrutura de apresentação manipulam tanto as propriedades semânticas de apresentação (uma aresta parte de um nó origem e chega a um nó destino), como suas propriedades visuais (tamanho, cor de fundo, etc.).
Operações como New, AddNode e RemoveNode da classe Graph correspondem a mensagens de modelagem enviadas por a camada de diálogo, enquanto Draw, Erase, etc., da classe Node, correspondem a mensagens gráfica que podem ser enviadas por a camada de diálogo ou geradas a partir de o recebimento de mensagens de modelagem.
A modelagem completa do framework Graph pode ser encontrada em 1.
Em, ainda é apresentado o framework Tree, criado como especialização de Graph.
A camada de diálogo captura todos os aspectos de conversação da interface, definindo cenários de interação para formulação e execução do modelo.
O domínio de interfaces homem-máquina é bastante rico em termos de componentes genéricos reutilizáveis disponíveis para desenvolvimento.
Esta genericidade vai desde unidades reutilizáveis de maior granularidade, como os componentes oferecidos por toolkits e classes de interface de usuário (ex.:
Janelas, caixas de diálogo, botões) disponíveis em bibliotecas de ambientes de desenvolvimento de interfaces, até sistemas de Qualquer um de eles é de grande importância para o desenvolvimento da parte de guias, uma vez que ela requer componentes reutilizáveis para o desenvolvimento do diálogo.
Até agora, foi discutido o processo de decomposição, através do isolamento de frameworks em diferentes níveis de abstração e com diferentes papéis num SAD específico, ligado a atividades Em, o framework Graph é chamado de DAG (Directed Acyclid Graph).
A conexão de frameworks é, basicamente, um processo de criação de correspondências entre as classes de frameworks de diferentes camadas, adaptadas para que seus objetos se comuniquem e colaborem, definindo o comportamento de um SAD de múltiplas camadas.
Mais especificamente, as atividades de desenvolvedores elaborators para a criação de SADs específicos são:
Selecionar frameworks para as diferentes camadas;
Conceitualmente, definir as correspondências entre classes de diferentes camadas;
Adaptar classes de diferentes camadas para que seus objetos possam se comunicar e colaborar de acordo com os cenários apresentados na Figura 14.
A Figura 19 dá a visão geral do processo de conexão de frameworks para a construção de um SAD para o domínio de Capital Budgeting.
O SAD específico mostrado da Figura 8 a Figura 12 é usado para ilustrar a características do processo de conexão de frameworks.
Cabe salientar que o processo não se limita a combinação de frameworks de diferentes camadas, mas também permite a conexão de frameworks de mesma camada.
Entretanto, o foco das seções seguintes é demonstrar como é feito o processo de conexão de frameworks de diferentes camadas.
Qualquer framework de construção de interface gráfica (GUI) pode ser usado para a parte de escolhidos foram Table e Tree, sendo o último modelado como uma especialização do framework Graph.
Para a parte de situação de decisão, o framework de Capital Budgeting foi criado para representar os conceitos e relacionamentos da teoria de domínio.
Finalmente, o framework DAM, representando a técnica de resolução de planilhas eletrônicas, foi escolhido para resolver problemas de Capital Budgeting no SAD.
Até este momento, cada framework foi projetado independentemente um do outro.
Assume- se que eles já existam e estão disponíveis para conexão.
As seções seguintes mostram com mais detalhes a adaptação dos frameworks de diferentes camadas para conexão.
Em a camada de Semântica, um framework de situação de decisão deve obrigatoriamente ser conectado a pelo menos um framework de resolução, para garantir que modelos formulados em alto nível de abstração possam ser analisados e resolvidos.
Primeiramente, deve- se capturar as correspondências entre os conceitos de decisão e suas representações equivalentes em termos de conceitos de resolução, como também automatizar a transição de um para outro.
A Figura 20 mostra algumas correspondências existentes entre o framework de Capital Budgeting e o framework de resolução DAM.
As classes de um framework de situação de decisão devem ser adaptadas para permitir a comunicação entre os objetos de decisão e os objetos de resolução, de acordo com os cenários de interação que podem ser iniciados.
Por exemplo, a criação de uma instância de um objeto de decisão deve disparar a criação de uma instância de um objeto de resolução correspondente, estabelecendo uma cadeia de comportamento entre as duas camadas.
O pedido da instanciação de um objeto de decisão é um exemplo de mensagem semântica, ou mais especificamente uma mensagem de modelagem, como pode ser observado na Figura 14.
Por exemplo, instanciar um objeto Item do framework Capital Budgeting causa a criação de um objeto VariableType do framework DAM, de acordo com as correspondências dadas na Figura 20.
Além disso, questões de resolução formuladas na camada superior devem ser relacionadas com as operações dos objetos de resolução correspondentes.
Isto é demonstrado na Figura 14 por as mensagens de resolução, que também são mensagens semânticas, as quais são iniciadas na camada de diálogo e propagadas por a camada de situação de decisão até a camada responsável, que é a de resolução.
Como já foi mencionado, modelos de decisão devem possuir uma representação visual, é através dessa representação visual que os usuários poderão manipular (modelar e resolver) modelos de decisão.
De acordo com as características da classe de problemas endereçada e estudos cognitivos, uma ou mais estruturas de apresentação são selecionadas para constituir a camada de apresentação de um SAD específico.
A conexão um framework de apresentação com um de situação de decisão engloba vários aspectos.
Em primeiro lugar, deve- se estabelecer as correspondências das classes dos frameworks de apresentação genéricos com as classes de situação de decisão.
Através disto é feita a associação de um significado aos componentes de estruturas de apresentação genéricas.
Os elementos visuais não são mais componentes vazios, mas sim elementos de decisão que têm propriedades gráficas especiais.
Por exemplo, na conexão do framework Graph com o framework CapitalBudgeting, os elementos nó são usados para representar itens orçamentários (Node corresponde a Item), de acordo com as correspondências dadas na Figura 21.
As classes do framework de apresentação devem ser adaptadas para, em primeiro lugar, darem a aparência visual específica dos objetos de decisão que vão representar.
Considerando o SAD exemplo da Seção 5.3.1, foi dada a nós associados a itens orçamentários a aparência gráfica de um círculo anexado a um retângulo, onde a natureza e a descrição de um item são mostrados dentro destes elementos gráficos.
Portanto, na conexão com CapitalBudgeting, a classe genérica Node tem que ser adaptada para dar esta aparência gráfica especial aos objetos Item.
Além disso, as classes de um framework de apresentação devem ser adaptadas para permitir a comunicação entre os objetos de apresentação e os objetos de situação de decisão, de acordo com os cenários de interação que podem ser iniciados.
Por exemplo, a criação de uma instância de um objeto de apresentação deve disparar a criação de uma instância de um objeto de decisão correspondente, estabelecendo uma cadeia de comportamento entre as duas camadas.
O pedido da instanciação de um objeto de apresentação é uma mensagem semântica, ou mais especificamente uma mensagem de modelagem, como pode ser observado na Figura 14.
Esta mensagem de inclusão gerar mensagens gráficas na camada de apresentação, relacionadas com atitudes tomadas para atualizar a aparência gráfica e a estrutura de uma instância de um framework de apresentação.
Por exemplo, instanciar um objeto Node do framework Graph causa a criação de um objeto Item do framework Capital Budgeting, de acordo com as correspondências dadas na Figura 21.
A instância do framework Graph deve apresentar visualmente o novo objeto Node criado.
Os diagramas da Figura 22 até a Figura 24 mostram, com um pouco mais de detalhe, como é feita a adaptação das classes para conexão dos framework Tree (especialização de Graph) e CapitalBudgeting, em.
A Figura 23 mostra a conexão dos frameworks Tree e CapitalBudgeting, mais especificamente a conexão das classes TreeNode e Item.
Para isto, é criada uma subclasse de TreeNode, chamada de ItemNode, que sabe como representar visualmente um objeto Item.
Ela adiciona uma referência a um objeto Item, implementa uma série de operações visuais abstratas, herdadas de Node, para dar a aparência gráfica desejada ao objeto Item.
Ela também adiciona uma operação SetLabel, que permite a alteração da descrição do objeto Item, delegando a operação SetLabel do objeto Item, e chamando a operação Draw para refletir as alterações semânticas na aparência visual do elemento.
A Figura 24 mostra três cenários de colaborações entre os objetos ItemNode e Item, de acordo com o tipo de mensagem enviada por um objeto da camada de diálogo.
Em o primeiro cenário, é pedida a inclusão de um objeto ItemNode, que causa a inclusão de um objeto Item.
Em o segundo, é solicitada a remoção de um objeto ItemNode, que implica na exclusão do objeto Item que está representando.
Em o último cenário, o objeto de diálogo envia uma mensagem para alterar a descrição de um ItemNode que está representando um Item.
O objeto ItemNode repassa a mensagem para o objeto Item e executa a operação Draw para atualizar a aparência visual do Item, refletindo a nova descrição do objeto.
Finalmente, o diálogo para os cenários de modelagem e resolução devem ser desenvolvidos, adaptando- se as classes dos frameworks de construção de interface gráfica de usuário (GUI).
Esta é uma tarefa comum no desenvolvimento de aplicações GUI, não existindo nenhum aspecto particular sugerido por a Arquitetura para conexão das duas camadas.
O importante é que, após o processo de adaptação das classes de diálogo, o usuário da aplicação do decisor possa iniciar os três cenários de comunicação entre os objetos de diferentes camadas mostrados na Figura 14.
Em o desenvolvimento dos estudos de caso em, assim como no desenvolvimento de protótipos usando- se a arquitetura como guia, foi observado que o processo de conexão de frameworks de diferentes camadas é bastante complexo.
Ele exige a criação de diversas subclasses, definição de diversos novos relacionamentos entre as classes de diferentes frameworks que estão sendo conectados, o que aumenta bastante a complexidade de projeto.
Quanto a o uso da arquitetura para o desenvolvimento de outras aplicações, foram observados dois problemas.
O primeiro está relacionado com a documentação.
A arquitetura foi considerada de difícil entendimento na parte que guia a criação e conexão de frameworks de diferentes camadas.
O segundo problema é gerado por as soluções de projeto utilizadas no desenvolvimento e extensão/ adaptação dos frameworks dos estudos de caso em, que aumentam a complexidade do projeto.
Em, foi feita uma análise dos problemas principais encontrados na documentação da arquitetura e das soluções de projeto dadas para adaptação dos frameworks.
Para estes problemas, diversas causas são identificadas e descritas, e também é colocado como estes problemas poderiam ser tratados ou minimizados.
O uso de design patterns foi importante como referencial conceitual para ajudar a identificar as causas dos problemas encontrados.
Em o desenvolvimento dos estudos de caso em, as principais dificuldades foram encontradas na extensão/ adaptação de frameworks genéricos criados, como também na conexão dos frameworks de diferentes camadas.
As principais causas destes problemas detectadas até agora, que estão bastante interligadas, podem ser classificadas da seguinte maneira:
Conceitos de Domínio Oriundos da Fase de Análise Presentes no Projeto dos Frameworks:
Os frameworks desenvolvidos para os estudos de caso foram modelados principalmente com componentes de domínio, resultantes da etapa de análise do desenvolvimento de software.
Os frameworks eram então uma representação do problema, orientada a domínio, e não necessariamente resultavam num projeto flexível, reutilizável e facilmente extensível e adaptável.
Por exemplo, a Seção 5.3.4.1.
Mostra como o framework genérico Tree é criado através da especialização do framework genérico Graph.
Enquanto Graph pode ser usado para representar estruturas de grafo em geral, Tree é especializado para representar árvores, que são grafos acíclicos, não dirigidos, conexos, que possuem um nó raiz.
Em, é observado que o processo de adaptação de Graph em Tree gerava diversas subclasses, acrescentando pouca funcionalidade, aumentando desnecessariamente a complexidade de projeto para uma simples adaptação.
Isto é devido principalmente porque em buscou- se modelar os frameworks de exemplo como uma representação do domínio do problema.
Então, em é proposta uma alternativa de projeto para Graph, aplicando o design pattern Strategy para isolar um componente variável responsável por a validação das restrições estruturais de um grafo, dependendo do seu tipo (Figura 25).
Em o projeto original, as classes do framework Tree não adicionavam quase nenhuma funcionalidade em relação a suas superclasses, servindo apenas para destinguir propriedades estruturais de dois tipos diferentes de grafos.
O que realmente difere grafos são as relações estruturais que podem existir.
Por exemplo, um grafo normal pode ter nós que não possuam nenhuma aresta, enquanto uma árvore, que é um grafo com a propriedade conexo, exige o contrário.
Estas restrições na formação da estrutura de um grafo são isoladas num componente que encapsula um algoritmo de restrições, que é composto dinamicamente num objeto da classe Graph.
Esta nova alternativa de projeto facilitou bastante o processo de especialização de frameworks para representar vários tipos de grafos, evitando a criação de várias subclasses que não adicionavam funcionalidade, e permitindo que um grafo mude de tipo dinamicamente, através da substituição do objeto de algoritmo de restrição.
Outro exemplo que pode ser dado é na conexão do framework Tree para conexão com o framework de Capital Budgeting, resultando no framework especializado ItemTree, que pode ser vista na Seção cada tipo de natureza de item encontrada, é criada uma subclasse de ItemNode, resultando nas classe IncomeNode, ExpenseNode, BalanceNode e InvestmentNode, que correspondem a itens de receita, despesa, saldo e investimento.
Estas classes não tem praticamente nenhuma diferença em comportamento e estrutura, servindo apenas para destacar os diferentes componentes de domínio do problema.
Previsão Deficiente de Pontos de Estabilidade e Variabilidade:
Como é apresentado no Capítulo 3, na Seção 3.3, frameworks definem os aspectos fixos do problema de projeto genérico que modelam, e deixam em aberto aspectos variáveis que podem ser adaptados para cada uso específico do framework.
Estes aspectos variáveis podem ser previstos e definidos como pontos de variabilidade de um framework, que podem ser preenchidos usando- se de abordagens white-box ou black-box.
Isto é importante para permitir a separação de elementos que variam e evoluem separadamente, evitando o reprojeto de um framework, permitindo a produção de frameworks mais flexíveis, com maior facilidade de extensão e adaptação, sem limitar a sua potencialidade de reutilização.
Uma das causas de dificuldade de extensão/ adaptação e conexão de frameworks na arquitetura proposta é a previsão deficiente destes pontos de estabilidade e variabilidade nos frameworks produzidos.
Em a conexão de frameworks de diferentes camadas, inúmeras subclasses tinham que ser criadas adicionando toda a funcionalidade requerida para fazer a conexão e a comunicação entre os objetos dos diferentes frameworks.
Poucos aspectos relacionados com conexão foram previstos nas classes genéricas, portanto tornando o trabalho de adaptação dos frameworks mais complexo.
Além disso, na adaptação de classes para conexão com outras de diferentes camadas, muitos aspectos comuns eram encontrados, que tinham que ser definidos manualmente a cada processo de conexão.
Estes aspectos comuns relacionados com a conexão de frameworks poderiam ser previstos como pontos de variabilidade e estabilidade dos frameworks genéricos, onde os pontos de variabilidade poderiam ser preenchidos em cada conexão.
Fazendo- se isto, os pontos de estabilidade e variabilidade são separados, reutiliza- se aquilo que é comum no projeto dos frameworks para a conexão com diferentes camadas, o impacto das mudanças fica mais localizado, e a adaptação e a extensão em geral do framework torna- se mais fácil.
A ênfase no uso de abordagem white-box para adaptação/ extensão e conexão dos frameworks é causada, principalmente, por a falta de previsão de pontos de estabilidade e variabilidade dos frameworks.
Portanto, a única abordagem que pode ser utilizada neste contexto é a white-box (ver Seção 3.3).
A white-box baseia- se nos mecanismos de herança para adaptar e adicionar funcionalidade a classes genéricas, portanto existe total liberdade na adaptação de uma classe, podendo- se adicionar qualquer nova funcionalidade nas subclasses criadas, ao contrário de a abordagem black-box, que exige interfaces de pontos de variabilidade pré-definidas para permitir a adaptação/ extensão e conexão de um framework.
Como é apresentado na Seção 3.3, o uso indiscriminado de abordagem white-box pode levar a uma explosão de subclasses no projeto, aumentando a sua complexidade.
Isto porque qualquer simples adaptação leva a criação de uma subclasse, como também a combinação da funcionalidade de duas ou mais classes leva a criação de subclasses adicionais.
Falta de Guia Genérico e Sistemático para Conexão Além de o problema de adaptação e extensão dos frameworks genéricos, outro problema principal encontrado no uso da arquitetura está relacionado com a documentação.
A arquitetura foi considerada de difícil entendimento, principalmente na parte que documenta e guia a criação e conexão de frameworks de diferentes camadas.
A primeira causa do problema de documentação da arquitetura está ligada ao fato de não ter sido fornecido um guia sistemático e genérico para a criação e adaptação de frameworks pensando em conexão.
Para usar a arquitetura de desenvolvimento de SAD proposta, um desenvolvedor tem que, em algumas situações, observar o processo de criação de frameworks genéricos e conexão em termos concretos, mostrado para os dois estudos de caso.
O desenvolvedor tem então que abstrair algumas das técnicas e dos métodos utilizados em exemplos concretos e aplicar aos seus problemas específicos de projeto.
É importante então que sejam capturados os aspectos de conexão invariantes, aplicáveis a qualquer SAD endereçado por a arquitetura.
Outro aspecto importante do problema de documentação está ligado com a falta de justificativas das soluções de projeto dadas na conexão dos frameworks, que também está de certa forma interligado com as causas de dificuldade de adaptação/ extensão e conexão dos frameworks.
Como foi apresentado no Capítulo 5, a arquitetura de desenvolvimento de SAD pode ser definida como um guia para desenvolvedores de SAD, mostrando como incorporar nos SAD produzidos características de facilidade de manipulação de modelos de decisão, beneficiando os decisores usuários das aplicações.
Além disso, a arquitetura mostra como desenvolvedores podem reutilizar frameworks de diferentes naturezas, organizados em diferentes camadas, e conectar estes para a produção de aplicações específicas.
Em, são apresentados dois estudos de caso para demonstrar a viabilidade da arquitetura, para as classes de problemas de Capital Budgeting e Planejamento de Atividades Industriais.
É mostrado o processo de desenvolvimento de framework genéricos para as diferentes camadas, e a conexão destes frameworks para a produção de SADs destinados à manipulação de problemas das classes endereçadas.
Em a Seção 5.4, são descritos alguns problemas encontrados na abordagem original da arquitetura em, observados principalmente no desenvolvimento dos estudos de caso, e as suas principais causas, que formam a base da motivação deste trabalho, sendo resumidos a seguir:
Problemas Identificados em Adaptação/ Extensão de Frameworks e Conexão de Frameworks de Diferentes Camadas Causas· Conceitos de domínio oriundos da fase de análise presentes no projeto dos frameworks;
Previsão deficiente de pontos de estabilidade e variabilidade para adaptação/ extensão e conexão dos frameworks;
Ênfase em abordagem white-box na adaptação/ extensão e conexão dos frameworks.
Documentação do Processo de Conexão· Falta de um guia genérico e sistemático para o desenvolvimento de frameworks genéricos e conexão de frameworks;
Ausência de justificativas de decisões de projeto.
Este capítulo tem por objetivo apresentar as principais propriedades da linguagem de padrões proposta neste trabalho e suas contribuições para os problemas identificados na Arquitetura.
A Seção 6.1 destaca os objetivos do trabalho e suas principais contribuições.
A Seção 6.2 descreve rapidamente o problema mais genérico tratado por a linguagem.
A Seção 6.3 caracteriza qual o público alvo da linguagem, ou seja, quem deve utilizar e quais os pré-requisitos que estas pessoas devem possuir.
A Seção 6.4 destaca o uso de um estudo de caso para facilitar o entendimento dos padrões.
A Seção 6.5 fala sobre os grafos que são utilizados como instrumentos para facilitar o uso da linguagem, e das classificações usadas para representar os diferentes tipos de padrões e relacionamentos identificados.
Em a Seção 6.6 é detalhado o formato de descrição escolhido para os padrões da linguagem.
A Seção 6.7 mostra como a linguagem pode ser usada por desenvolvedores tanto como guia passo a passo como guia de referência.
O objetivo geral deste trabalho é demonstrar e avaliar a contribuição que padrões podem trazer para o desenvolvimento de software, usando a Arquitetura de Desenvolvimento de SAD baseado em Frameworks como estudo de caso, tentando resolver alguns dos problemas que foram identificados no seu uso, destacados na Seção 5.4.
Para isto, está sendo produzida uma linguagem de padrões para guiar o desenvolvimento de frameworks genéricos e a adaptação dos frameworks, pensando apenas em aspectos de conexão entre diferentes camadas.
Espera- se, com a linguagem produzida, resolver ou minimizar os problemas destacados em relação a as soluções de projeto usadas e sugeridas em para conexão de frameworks de diferentes camadas, como também em relação a a documentação do processo de conexão usado em.
A linguagem produzida é o resultado de um primeiro esforço, devendo sofrer diversas alterações na sua estrutura e no conteúdo de seus padrões.
Como ela se encontra neste estado embrionário, alguns autores poderiam classificar- la neste momento como um sistema de padrões ou como uma proto-linguagem composta de proto-padrões (Seção 4.5).
Para tentar resolver os problemas das soluções de projeto sugeridas para o desenvolvimento dos frameworks de diferentes camadas para serem poderem ser conectados na produção de SADs específicos, os padrões da linguagem tentarão fornecer melhores soluções de projeto, levando sempre em consideração as duas forças principais que atuam sobre estes problemas de conexão:
Estas forças são normalmente contraditórias.
As atitudes tomadas que pretendem dar melhores soluções para os problemas são:
Em relação a problemas de documentação encontrados no uso da arquitetura, o uso uma linguagem de padrões para guiar o processo de conexão pode apresentar diversos benefícios, que são derivados da tecnologia de padrões e linguagens de padrões, que a comunidade de software acredita que destaca- se sobre métodos tradicionais de documentação de experiência.
De acordo com as discussões do Capítulo 4 sobre linguagens de padrões, a linguagem de padrões proposta, que endereça o problema mais genérico de conexão de frameworks, apresenta as seguintes propriedades:
Separação de subproblemas independentes:
A linguagem divide o problema mais genérico de conexão de frameworks num grupo de subproblemas independentes, os quais estão interligados para resolver o problema geral endereçado por a linguagem, adotando uma abordagem do tipo &quot;dividir para conquistar «para facilitar o tratamento do problema mais genérico por parte de o desenvolvedor usuário da linguagem.
Abstração dos problemas de projeto relacionados com a conexão de frameworks:
Os problemas e soluções de projeto sugeridos em para o desenvolvimento de frameworks pensando em aspectos de conexão são, na maioria das vezes, descritos em termos concretos, demonstrados apenas nos estudos de caso desenvolvidos.
Os padrões da linguagem tentam abstrair estes problemas, capturando os seus elementos invariantes, para que possam ser utilizados igualmente para qualquer SAD, de diferentes domínios, que possa ser desenvolvido com o uso da Arquitetura.
Uso como guia passo a passo:
Os relacionamentos entre os padrões formam um grafo, onde os nós são os padrões e as arestas são os relacionamentos.
A linguagem permite que o problema mais genérico seja tratado passo a passo, começando no padrão inicial e mais genérico da linguagem, que conduz o usuário da linguagem a outros padrões, de acordo com os relacionamentos definidos.
O caminho que um usuário da linguagem (desenvolvedor) percorre ao navegar de um padrão para outro é uma das diversas combinações de soluções que podem ser criadas para resolver o problema mais genérico.
Para facilitar a navegação por os padrões da linguagem, são fornecidos dois tipos de grafo, formados por padrões e seus relacionamentos.
Uso como guia de referência:
Além de poder ser usada passo a passo, a linguagem pode ser usada como guia de referência.
O usuário pode procurar por um padrão que atenda um subproblema específico de conexão, sem ter que passar por todos os padrões da linguagem.
Esta busca é facilitada através do fornecimento de um índice dos padrões da linguagem.
Descrição das justificativas das soluções de projeto:
A solução de cada padrão descreve como resolve as forças que atuam sobre o problema, quais forças não são resolvidas e quais problemas são deixados em aberto ou mesmo gerados por as soluções escolhidas, que vão ser tratados por padrões subseqüentes da linguagem.
Como já foi destacado, é importante justificar as decisões de projeto descritas para que desenvolvedores as entendam e sintam- se à vontade para reutilizálas em seus próprios projetos.
Este trabalho concentrou- se no desenvolvimento detalhado de apenas uma porção da linguagem, devido a limitações de espaço e tempo, que endereça o subproblema de conexão de frameworks das camadas de apresentação e situação de decisão.
A elaboração da linguagem completa é um trabalho exaustivo, de longo prazo, e espera- se com a porção da linguagem desenvolvida dar uma idéia da linguagem completa, demostrando suas contribuições sobre os principais problemas identificados na Arquitetura.
O problema mais genérico endereçado por a linguagem de padrões pode ser definido em &quot;Como projetar frameworks genéricos e adaptar estes frameworks para o desenvolvimento de SADs específicos de acordo com a Arquitetura de Desenvolvimento de SAD baseado em frameworks de, considerando- se apenas aspectos de conexão dos frameworks de diferentes camadas?».
Como a linguagem apresentada neste trabalho restringe- se apenas às camadas de apresentação e situação de decisão, o problema mais genérico endereçado por a linguagem é limitado à conexão dos frameworks destas camadas.
O público alvo da linguagem são desenvolvedores de SAD, com as seguintes características:
Possuir um bom domínio dos conceitos de orientação a objetos, devendo saber desenvolver e utilizar frameworks e trabalhar com padrões de projeto (design patterns);
É importante salientar que a linguagem não faz distinção entre os papéis de desenvolvedores elaborators e abstractors (ver introdução do Capítulo 3), ao contrário de o que foi feito na abordagem original em.
Isto porque as decisões tomadas para resolver os problemas de projeto de frameworks levam em conta ambas as atividades de desenvolvedores abstractors e elaborators, sendo então esta distinção desconsiderada e as atividades integradas numa comum, que é o desenvolvimento e a conexão de frameworks.
A distinção de papéis não é mais feita também porque fica difícil encontrar limites padrões de atuação de abstractors e elaborators neste processo.
Padrões são descrições abstratas de problemas recorrentes.
Porém, as pessoas têm mais facilidade de lidar com aquilo que é concreto, do que com abstrações.
Como colocam, além de a descrição abstrata de problema-contexto- solução dada por os padrões, é importante dar exemplos de situações onde o padrão pode ser aplicado, onde aparecem instâncias do contexto, problema e forças atuantes, e solução.
Portanto, para que os padrões da linguagem objeto do trabalho sejam melhor entendidos, e que as soluções fornecidas sejam validadas e justificadas, será usado um pequeno estudo de caso na apresentação de exemplos de uso dos padrões.
Chama este tipo de estudo de caso compartilhado por todos os padrões de uma linguagem de estudo de caso.
Assim como para a apresentação da arquitetura SAD feita no capítulo 5, vai ser utilizado como estudo de caso (running example) da linguagem um pequeno aspecto de um SAD para a manipulação de problemas de capital budgeting, usando estruturas de apresentação de grafo e árvore indentada para a especificação dos modelos de decisão de capital budgeting.
O estudo de caso é descrito na introdução da linguagem e na seção Exemplo do padrão mais genérico da linguagem, e uma descrição mais detalhada da classe de problemas de capital budgeting é dada no Anexo 1 deste documento.
Como já foi dito na Seção 6.1, os padrões da linguagem podem ser representados de maneira sucinta na forma de grafos, onde os nós são padrões e as arestas seus relacionamentos.
Um grafo de padrões visa facilitar a utilização passo a passo da linguagem, fornecendo de certa forma uma visão geral do problema complexo endereçado por a linguagem e como ele é dividido.
Baseado no reconhecimento de propriedades semânticas distintas existentes nos padrões e seus relacionamentos, foi proposta uma classificação para padrões e relacionamentos.
Assim, cada tipo de padrão/ relacionamento tem uma notação especial em sua representação nos grafos da linguagem, com o objetivo de facilitar a utilização da linguagem.
As Seções 6.5.1 e 6.5.2 descrevem estes diferentes tipos identificados de padrões e relacionamentos.
Como tratam de problemas de projeto de frameworks orientados a objeto dependentes de domínio, os padrões da linguagem são considerados como design patterns dependentes de domínio de aplicação.
A linguagem contém padrões que podem ser classificados em dois tipos, que são os orientados a problema e os orientados a solução.
Os padrões orientados a problema representam os subproblemas invariantes que compõem o problema mais genérico de conexão de frameworks.
Para estes problemas, podem existir soluções variantes aplicáveis em contextos ou contextos resultantes específicos, em que uma solução se destaca sobre a outra resolvendo melhor as forças que atuam sobre um problema.
Estas soluções são encapsuladas em padrões distintos, chamados de padrões orientados a solução, os quais são especializações de um padrão que define o problema tratado.
Por exemplo, os padrões Ligação de Instâncias Wb e Ligação de Instâncias BB são padrões orientados a solução, encapsulando soluções distintas para o padrão orientado a problema Ligação de Instâncias.
O padrão Ligação de Instâncias Wb dá mais ênfase à resolução da força reusabilidade que atua sobre o problema de Ligação de Instâncias, enquanto Ligação de Instâncias Wb concentra- se mais na adaptabilidade da solução.
A diferenciação de padrões orientados a problema e a solução é usada para auxiliar a utilização da linguagem, destacando estes diferentes aspectos semânticos dos padrões da linguagem.
Em primeiro lugar, isto é importante quando existe mais de uma solução para um mesmo problema, que devem ser usadas em contextos ligeiramente distintos.
Com isto, são isoladas as partes invariantes de um padrão, que são o contexto geral, o problema e as forças que atuam sobre o problema, encapsulando- se as soluções distintas para o problema em padrões orientados a solução, os quais são especializações do padrão orientado a problema.
Em os padrões orientados a solução são descritos os aspectos de contexto ou contexto resultante que variam, juntamente com a solução proposta por cada um para o problema compartilhado.
Além de facilitar a utilização da linguagem, a existência de padrões orientados a problema e a solução facilita a evolução da linguagem, permitindo que novas soluções para um problema, representado por um padrão orientado a problema, possam ser introduzidas mais facilmente na linguagem.
Outra vantagem desta abordagem é que facilita a procura de padrões de acordo com o problema, através de índices de procura (Seção 6.7).
A linguagem fornece um grafo orientado a problema para o uso passo a passo da linguagem, onde, como o próprio nome sugere, são apresentados apenas os padrões orientados a problema e os relacionamentos existente entre eles.
Ela também apresenta um grafo orientado a solução, englobando os padrões orientados a solução da linguagem.
Estes grafos são apresentados na Seção As diferentes formas de relacionamentos entre os padrões da linguagem formam um grafo, onde os padrões são representados por nós e os relacionamentos por arestas, percorrendo diversos caminhos por os quais a linguagem pode ser navegada, isto é, sobre os quais o usuário da linguagem pode iniciar num padrão e passar por diversos outros, seguindo os relacionamentos definidos entre eles.
Isto é uma propriedade das linguagens de padrões, caracterizada na Seção 4.5 deste documento.
Os grafos para padrões orientados a problema e a solução da linguagem são apresentados na Seção 7.1 deste documento.
Baseado no reconhecimento de diferentes tipos de relacionamentos existentes entre os padrões da linguagem, foi proposta a seguinte classificação, semelhante àquela realizada em:
&quot;guarda de trânsito», dividindo um problema mais genérico num grupo de subproblemas, endereçados por padrões que o completam, levando a estes padrões.
Em, este tipo de relacionamento é correspondente a uses.
Em os grafos, este relacionamento é definido por uma seta que interliga os padrões, imitando o tipo de representação dada em UML para agregation em diagramas de classes.
Aparência Gráfica leva a Comportamento Semântico, já que normalmente após resolver o problema de definição de aparência gráfica dos objetos de decisão, passa- se a resolver o problema de incorporar o comportamento de objetos de decisão em objetos de apresentação, que pode ter sido deixado em aberto.
Em a descrição de um padrão, o relacionamento leva a pode ser dado nas seções 'Padrões Relacionados` ou' Contexto Resultante' do padrão origem.
Em, este tipo de relacionamento é correspondente a uses.
Em o grafo, este relacionamento é definido por uma seta vazada que interliga os padrões, imitando o tipo de representação dada em UML para association em diagramas de classes.
Aparência Gráfica, deve ser aplicado antes, para certificar que objetos de apresentação podem ser ligados a objetos de decisão antes de ser definida a sua aparência gráfica.
Em a descrição dos padrões, o relacionamento é pré-requisito de pode ser dado nas seções 'Solução', 'Contexto Resultante` ou' Padrões Relacionados` do padrão origem, e na seção 'Contexto' do padrão destino, que é o padrão que depende do uso do padrão origem para ser aplicado.
Em, este tipo de relacionamento é correspondente a uses.
Em os grafos, este relacionamento é definido por uma seta que interliga os padrões, imitando o tipo de representação dada em UML para association em diagramas de classes.
Além de caracterizar que um padrão possui especializações, este tipo de relacionamento também pode atuar como leva a, sugerindo a aplicação ou mesmo se comportar como prérequisito das especializações.
Por exemplo, o padrão Inclusão de Objetos de Decisão é uma especialização de Comportamento Semântico, e Comportamento Semântico é um pré-requisito de Inclusão de Objetos de Decisão.
Em os grafos, este relacionamento é definido por linhas que interligam os padrões, imitando o tipo de representação dada em UML para generalization em diagramas de classes.
Objetos Wb e Ligação de Objetos BB.
Em os grafos, este relacionamento é definido por uma seta bidirecional pontilhada que interliga os padrões.
A classificação de diferentes padrões têm o objetivo de facilitar para o usuário da linguagem a navegação entre os padrões.
Os diferentes tipos ajudam a destacar aspectos semânticos distintos dos relacionamentos, permitindo que o usuário que está manipulando o grafo geral da linguagem possa determinar quais padrões deve ou pode usar, de acordo com o contexto específico em que ele se encontra, sugerindo- se caminhos prováveis de uso passo a passo da linguagem.
Para descrever os padrões da linguagem, foi escolhido um formato que é uma mescla de diversos formatos utilizados por a comunidade de padrões, que contempla os elementos essenciais de descrição apresentados na Seção 4.3.
As seções utilizadas para a descrição dos padrões são detalhadas a seguir.
É importante salientar que nem todos os padrões utilizam todas as seções definidas.
Algumas seções estão presentes em todos os padrões, como Nome, Problema, Contexto, etc., enquanto outras são usadas em algumas situações para facilitar o entendimento e uso de um padrão.
Além disso, de acordo com os tipos distintos de padrões da linguagem, discutidos na Seção 6.5, algumas seções tornam- se mais ou menos apropriadas na descrição.
Por exemplo, as seções Estrutura e Participantes estão presentes apenas em padrões orientados a solução, isto porque estas seções são usadas para descrever com maiores detalhes como a solução para os problemas deve ser construída, o que obviamente relaciona- se apenas com padrões que dão soluções para os problemas tratados.
Já a seção Solução está presente nos dois tipos de padrões, e em padrões orientados a problema a Solução simplesmente remete ao uso dos padrões orientados a solução relacionados.
O formato escolhido é formado por a seguintes seções:
Nome de identificação do padrão.
Contexto: Determina a aplicabilidade do padrão, quando ele deve ser usado, e também quais os pré-requisitos de um padrão, relacionados com padrões anteriores que devem ter sido usados antes de aplicar o padrão em questão.
Problema: Descrição do problema específico de conexão de frameworks que o padrão endereça.
Este se enquadra dentro de um determinado contexto, e sofre a ação de diversas forças, que são levadas em consideração na resolução do problema.
Um problema de conexão é sempre relacionado com projetar e adaptar classes genéricas para que frameworks possam ser conectados.
Forças: Define um conjunto de forças e restrições que atuam sobre o problema, e que influenciam a decisão da solução.
As forças dos problemas de conexão baseiam- se principalmente nos critérios de reusabilidade e adaptabilidade dos frameworks, isto é, por um lado deseja- se que frameworks sejam bastantes genéricos, e por outro lado deseja- se que o processo de adaptação para conexão dos frameworks seja fácil.
Exemplo: Exemplo concreto do problema abstrato endereçado por o padrão, juntamente com as forças que atuam sobre ele.
O exemplo está relacionado com aspectos determinados por o estudo de caso da linguagem (ver Seção 6.4), de o qual todos os exemplos derivam.
Solução: Descrição textual abstrata da solução para o problema.
Mostra como as classes devem ser projetadas genericamente, normalmente mostrando quais pontos de estabilidade e variabilidade devem ser previstos, e como elas devem ser adaptadas para a conexão dos frameworks, geralmente mostrando como os pontos de variabilidade previstos são preenchidos.
A solução tenta resolver as forças que atuam sobre o problema, principalmente as forças contraditórias reusabilidade e adaptabilidade.
Estrutura: Diagramas de classes UML mostrando como as classes envolvidas na solução padrão devem ser projetadas genericamente e adaptadas.
Em algumas situações, fragmentos de código das operações das classes são apresentados, usando para implementação a linguagem C+, apenas como propósito de ilustração.
As soluções não dependem de linguagem de implementação, e quanto houver necessidade de destacar aspectos de implementação das soluções que são influenciados por a linguagem escolhida, eles serão destacados.
Participantes: Apresenta as classes participantes da solução abstrata para o problema, quais os seus papéis na solução, e as responsabilidades que cada uma assume para a resolução do problema.
Solução do Exemplo: Mostra como a solução abstrata do padrão pode ser aplicada para resolver o problema específico descrito na seção Exemplo.
Esta seção tenta mostrar como os elementos concretos se relacionam como os elementos abstratos da solução proposta.
Justificativa da Solução: Justificativa da escolha da solução para o problema, mostrando como a solução resolve as forças impostas sobre o problema.
Pode também citar outras possíveis soluções que são menos satisfatórias do que a escolhida.
Contexto Resultante: Define o contexto resultante após a aplicação do padrão, mostrando problemas que ainda não foram resolvidos, ou problemas que foram gerados por a solução do próprio padrão.
Esta seção pode então levar a outros padrões da linguagem ou mesmo a padrões externos à linguagem, disponíveis na literatura.
Padrões Relacionados: Mostra quais padrões estão relacionados a um determinado padrão, sendo que estes relacionamentos podem ser dados de diversas maneiras, como define a seção Como já foi discutido, a linguagem de padrões de conexão de frameworks de apresentação e situação de decisão pode ser usada como guia passo a passo, guiando o usuário da linguagem (desenvolvedor) na aplicação dos padrões, mostrando caminhos que podem ser percorridos para tratar o problema complexo endereçado por a linguagem.
Além disso, a linguagem pode ser usada como guia de referência, onde o usuário procura por padrões específicos, de acordo com critérios de Para usar a linguagem passo a passo para resolver o problema de conexão de frameworks de apresentação e situação de decisão, o usuário da linguagem deve iniciar por o padrão mais genérico Conexão Apresentação e Situação de Decisão, que se comporta como um &quot;guarda de trânsito», introduzindo o problema complexo e levando aos padrões que resolvem os subproblemas principais da linguagem.&amp;&amp;&amp;
O usuário pode seguir passo a passo (navegar) os padrões da linguagem, usando os relacionamentos definidos entre os padrões, gerando o projeto dos frameworks incrementalmente.
Um dos caminhos que podem ser percorridos por o usuário da linguagem no uso passo a passo, de acordo com o grafo orientado a problema apresentado na Seção 7.1.1, é mostrado na Figura 26.
Note que as setas apresentadas na Figura 26 não têm correspondência com as notações para diferentes tipos de relacionamentos utilizadas nos grafos da linguagem, servindo apenas para mostrar a ordem de aplicação dos padrões.
Como guia de referência, o usuário pode procurar por padrões que atendam os seus critérios de Para facilitar a busca de padrões que atendam as necessidades dos usuários, a linguagem vai oferecer um índice dos padrões orientados a problema.
Em este índice, serão colocados os nomes dos padrões e a intenção de cada um de eles, isto é, qual o problema específico que eles tratam.
Por exemplo, o usuário se encontra com o problema de projetar classes de apresentação genérica de maneira que possam ser adaptadas para dar a aparência gráfica de classes de decisão específicas, após o processo de conexão.
Procurando por um padrão no índice fornecido por a linguagem, o usuário encontra Aparência Gráfica, cujo nome já é bastante sugestivo, com a seguinte intenção:
&quot;Mostra como projetar genericamente e adaptar as classes dos frameworks de apresentação e situação de decisão para que, no processo de conexão, os objetos de uma classe de apresentação saibam dar a aparência gráfica desejada e específica dos objetos de decisão que estarão representando».
Este é o padrão que endereça diretamente o problema pesquisado por o desenvolvedor usuário da linguagem.
Este capítulo apresenta a linguagem de padrões desenvolvida para o subproblema de conexão de frameworks específico para as camadas de apresentação e situação de decisão da arquitetura de desenvolvimento de SADs baseado em frameworks.
Através desta porção da linguagem apresentada, visa- se ilustrar:
Baseado nisto, e considerando o perfil de usuários alvo da linguagem descrito na Seção 6.3, optouse por tentar deixar a linguagem o mais auto-contida possível, permitindo que um desenvolvedor a utilize isoladamente, isto é, sem exigir a leitura dos demais capítulos que compõem este documento.
Como conseqüência, neste capítulo há algumas redundâncias, comparando com os outros capítulos deste documento, principalmente em relação a a base conceitual do processo de conexão de frameworks e também ao estudo de caso utilizado para demonstrar o uso da linguagem.
A Seção 7.1 apresenta os grafos dos padrões orientados a problema e orientados a solução da linguagem, assim como as notações utilizadas para apresentar os padrões e seus relacionamentos.
A Seção 7.2 apresenta o índice de padrões orientados a problema da linguagem, que contém nome, intenção e número da página onde pode ser encontrado cada padrão.
Em a Seção 7.3 é detalhado o estudo de caso da linguagem, que será considerado por cada padrão nas seções Exemplo e Solução do Exemplo.
Cabe salientar que os padrões Trader para Inclusão de Objetos, Exclusão de Objetos de Decisão, Exclusão de Objetos de Decisão Wb e Exclusão de Objetos de Decisão BB não serão apresentados neste documento, por motivos de limitação de espaço e tempo.
Quanto houver uma referência a um destes padrões na linguagens, seus nomes serão seguidos de Np (Não Publicado).
Notação/ Tipo Tipo Orientado a Problema representam os subproblemas invariantes que compõem o problema mais genérico de conexão de frameworks.
Tabela 2 ­ Legenda de Tipos de Relacionamentos da Linguagem de Padrões Nome do Padrão Intenção Página Conexão Apresentação e Mostra como projetar genericamente e adaptar as classes dos frameworks de Situação de Decisão apresentação e situação de decisão para que, após o processo de conexão dos frameworks, as instâncias dos frameworks de apresentação possam dar a aparência gráfica desejada e incorporar o comportamento das instâncias dos frameworks de situação de decisão que estão sendo conectadas.&amp;&amp;&amp;
Ligação de Instâncias Mostra como projetar genericamente e adaptar as classes dos frameworks de apresentação e situação de decisão para que, após o processo de conexão dos frameworks, os objetos de apresentação possam ser ligados ou associados aos objetos de decisão que estarão representando, de forma que possam se comunicar e colaborar.
Aparência Gráfica Mostra como projetar genericamente e adaptar as classes dos frameworks de apresentação e situação de decisão para que, após o processo de conexão, os objetos de uma classe de apresentação saibam dar a aparência gráfica desejada e específica dos objetos de decisão que estarão representando.
Comportamento Semântico Mostra como projetar genericamente e adaptar as classes dos frameworks de apresentação e situação de decisão para que, após o processo de conexão, os objetos de apresentação possam incorporar o comportamento semântico dos objetos de decisão aos quais estão ligados, dando a sensação para a camada de diálogo de que, quando está interagindo com um objeto de apresentação, está interagindo diretamente com os objetos de decisão representados por ele.
Conduto de Mensagens Semânticas Mostra como projetar genericamente e adaptar as classes dos frameworks de apresentação e situação de decisão para que, após o processo de conexão, os objetos de apresentação possam atuar como canais de transmissão de mensagens de modelagem, certificando- se de repassar estas mensagens para os objetos de decisão que representam, os quais são os responsáveis por o tratamento adequado deste tipo de mensagens.
Apresentação Trata Mensagens Semânticas Mostra como projetar genericamente e adaptar as classes dos frameworks de apresentação e situação de decisão para que, após o processo de conexão, os objetos de apresentação possam dar um tratamento adequado às mensagens semânticas, especialmente mensagens de modelagem, que são conduzidas para os seus objetos de decisão, refletindo possíveis alterações de estado ocorridas nos objetos de decisão, ou apenas bloqueando repasse das mensagens.
Notificação de Modificações Semânticas Mostra como projetar genericamente e adaptar as classes dos frameworks de apresentação e situação de decisão para que, após o processo de conexão, objetos de apresentação que estão representando simultaneamente um mesmo objeto de decisão possam, após a condução de uma mensagem de modelagem ao objeto de decisão por um objeto de apresentação específico, refletir possíveis alterações de estado ocorridas no objeto de decisão, por as quais os objetos de apresentação são influenciados.&amp;&amp;&amp;
Inclusão de Objetos de Decisão Mostra como projetar genericamente e adaptar as classes dos frameworks de apresentação e situação de decisão para que, após o processo de conexão, instâncias de frameworks de apresentação possam delegar a instanciação e inclusão de objetos no modelo de decisão e criar objetos de apresentação correspondentes para representar- los.
Como estudo de caso da linguagem, será considerado um aspecto limitado de um SAD para a classes de problemas de Capital Budgeting.
Para esta demonstração, são usadas estruturas de apresentação Grafo e Árvore Indentada para representar um modelo de Capital Budgeting.
O objetivo destas estruturas é facilitar o entendimento e a manipulação da estrutura hierárquica inerente formada por itens orçamentários e seus relacionamentos.
Todos os padrões da linguagem compartilham este estudo de caso.
Em a seção 'Exemplo', cada padrão descreve seu problema específico aplicado a alguns elementos do estudo de caso, cuja solução é mostrada na seção 'Solução do Exemplo'.
Os projetos dos frameworks apresentados nesta seção servem como um ponto de partida para a demonstração do uso dos padrões da linguagem, que vão guiar o projeto genérico e adaptação destes frameworks, focando exclusivamente aspectos dependentes de conexão.
Portanto, os frameworks foram projetados de maneira mais genérica possível, sem considerar nenhum aspecto de conexão com outros frameworks, procurando representar as suas principais classes e propriedades básicas estruturais.
O projeto destes frameworks foi inspirado nos apresentados em, e cabe salientar que não é objetivo deste trabalho criar frameworks completos e profissionais, mas sim usar- los para demonstrar os problemas invariantes de conexão e soluções que podem ser aplicadas.
A Seção 7.3.1 descreve rapidamente a classe de problema de decisão de Capital Budgeting e quais os aspectos que vão considerados para o desenvolvimento do estudo de caso, e a Seção 7.3.2 apresenta o projeto do framework genérico CapitalBudgeting.
A Seção 7.3.2.2.
Apresenta a estrutura genérica de apresentação Grafo, como deve ser a sua aparência gráfica e comportamento quando conectada ao framework CapitalBudgeting, juntamente com o projeto do framework Graph que modela a estrutura Grafo.
A Seção 7.3.2.3.
Faz o mesmo para a estrutura de apresentação genérica Árvore Indentada, que é modelada por o framework IndentTree.
A classe de problemas de Capital Budgeting envolve decisões sobre investimentos cujo retorno é esperado para além de o período de um ano.
O período de duração de um projeto pode se estender por vários anos, e isto implica registrar todas as receitas e despesas ocorridas neste período.
A lucratividade de um investimento pode ser avaliada por vários critérios, como Net Present Value decisão podem ser formulados em termos de conceitos como período de duração de um projeto de Em este contexto, apenas será considerado o aspecto de problemas de Capital Budgeting relativo à modelagem de itens orçamentários e seus relacionamentos.
Um modelo de decisão de Capital Budgeting é especificado através de um determinado número de itens orçamentários elementares, que representam receitas, despesas e investimentos previstos para o período de duração do projeto, como também de itens usados para representar resultados intermediários, que poderiam ser agregações de receitas, despesas e investimentos, ou diferenças entre itens de diferentes tipos, que são chamadas de saldos.
Portanto, cada item é classificado de acordo com a sua natureza, que pode ser receita, despesa, investimento ou saldo.
Os relacionamentos entre os itens orçamentários, criados através das dependências formadas por itens de agregação ou saldos, definem uma estrutura hierárquica, onde o elemento raiz é sempre o fluxo de caixa (cash flow) de um modelo de Capital Budgeting.
O framework de CapitalBudgeting foi modelado apenas para contemplar a estrutura hierárquica formada por os relacionamentos entre itens orçamentários de um modelo de decisão de Capital Budegting, como mostra a Figura 29.
CapitalBudgeting Item_ Root:
Item RemoveItem (i:
Item)_ Root_ Children:
Collection_ Father:
Item_ Father SetLabel (l:
Char) SetNature (n:
Char) AddChild (i:
Item) RemoveChild (i:
Item)_ Children_ Children-\&gt; Remove (c);
Classe Item: Representa um item orçamentário, e define operações para gerenciar os relacionamentos entre itens e para manipulação das propriedades de um item.
SetLabel, GetLabel:
Operações de definição e recuperação da descrição de um item.
SetNature, GetNature:
Operações de definição e recuperação da natureza de um item, a qual pode assumir os valores &quot;R», de receita, &quot;D», de despesa, &quot;I», de investimento, e &quot;S «de saldo.
AddChild, RemoveChild:
Operações de gerenciamento dos relacionamentos existentes entre itens.
Permitem que itens filhos sejam adicionados ou removidos de um item pai.
Um item pai significa um item que é uma agregação (ex.:
Soma de receitas, soma de despesas) ou um saldo (ex.:
Diferença de receita e despesa), dependente de itens filhos de diversas naturezas.
GetFather: Informa qual o objeto Item pai de um determinado Item.
Remove, RemoveChild:
Operações incluídas para manutenção de integridade de estrutura.
RemoveChild promove a exclusão dos itens filhos de um determinado item, enquanto Remove deve ser executada para que um item tome as atitudes necessárias ao ser excluído.
Classe CapitalBudgeting:
Representa um modelo de decisão de capital budgeting.
Pode ser chamada de &quot;fachada «do framework de Capital Budgeting, de acordo com o que propõe o design pattern Facade.
Através um objeto CapitalBudegting pode- se instanciar e incluir objetos Item no modelo de decisão, e também manipular todos os objetos Item que compõem o modelo.
Além disso, mantém e gerência automaticamente o objeto Item raiz da hierarquia de itens do modelo de decisão.
GetRoot: Informa qual o objeto item raiz da hierarquia de itens do modelo de decisão.
Retornando o novo objeto Item.
AddItem, RemoveItem:
Operações que adicionam e removem itens do modelo.
Em a verdade, a execução destas operações é delegada às operações AddChild e Remove de objetos Item, já estes são os responsáveis diretos por a manutenção dos relacionamentos entre os itens da hierarquia.
O framework Graph tem o objetivo de modelar uma estrutura de grafo genérica, oferecendo classes para os elementos visuais' nó` e'arestas', o qual poderá ser usado para representar uma grande faixa de modelos de decisão.
O projeto do framework Graph é apresentado na Figura 30, considerando apenas aspectos estruturais e gráficos básicos.
Glyph_ Nodes.
Add (n);
Draw (w:
Window) Erase (w:
Window) Intersects (p:
Point) n-\&gt; RemoveOutEdge (e);
Classe Glyph: Classe abstrata que representa um elemento visual genérico, o qual pode ser apresentado graficamente e é capaz de reconhecer e receber comandos do mouse, num ambiente gráfico de janelas.
Draw: Operação abstrata (método hook) que deve ser implementada nas subclasses de Glyph, responsável por a definição da aparência gráfica e desenho do objeto numa Window.
Erase: Operação abstrata (método hook) que deve ser implementada nas subclasses de Glyph, responsável por apagar o elemento visual de uma Window.
Bounds: Retorna a área retangular ocupada por a aparência gráfica do objeto Glyph, encapsulada numa estrutura GlyphArea.
Classe Node: Classe abstrata que representa o elemento visual 'nó' do grafo.
É uma subclasse de Glyph, e portanto herda todas as propriedades gráficas definidas em Glyph.
Contém operações de manutenção da estrutura do grafo, como a manutenção do conjunto de arestas que partem e chegam em cada objeto Node.
AddInEdge, RemoveInEdge:
Operações destinadas à manutenção de integridade do grafo, que respectivamente adicionam ou removem objetos Edge que chegam até um objeto Node.
AddOutEdge, RemoveOutEdge:
Operações destinadas à manutenção de integridade do grafo, que respectivamente adicionam ou removem objetos Edge que partem de um objeto Node.
InEdges, OutEdges:
Retornam as coleções de objetos Edge que chegam e partem de um objeto Node.
Classe Edge: Classe abstrata que representa o elemento visual 'aresta' do grafo.
Assim como Node, é uma subclasse de Glyph, e portanto herda todas as propriedades gráficas definidas em Glyph.
Contém operações de manutenção da estrutura do grafo, que definem e informam quais os objetos Node que um objeto Edge conecta, isto é, o nó origem e o nó destino de uma aresta.
InNode, OutNode:
Retornam os objetos que uma Edge conecta, isto é, o nó de o qual ela parte (OutNode) e o nó em que ela chega (InNode).
Classe Graph: Representa uma estrutura de apresentação Grafo.
Pode ser chamada de &quot;fachada «do framework Graph, de acordo com o que propõe o design pattern Facade.
Através um objeto Graph pode- se instanciar e incluir objetos Node e conectar- los com objetos Edge, e também manipular todos os objetos Node e Edge que formam a estrutura.
CreateAndAddNode, CreateAndAddEdge:
Operações responsáveis por a instanciação das classes Node e Edge, e também inclusão das instâncias na estrutura de apresentação.
Retornam o novo objeto criado.
AddNode, RemoveNode:
Operações destinadas à manutenção de integridade do grafo, que respectivamente adicionam ou removem objetos Node de um grafo.
AddEdge, RemoveEdge:
Operações destinadas à manutenção de integridade do grafo, que respectivamente adicionam ou removem objetos Edge de um grafo.
Estas operações colaboram com as operações AddInEdge, AddOutEdge, RemoveInEdge, RemoveOutEdge, de objetos Node, para manter a integridade da estrutura.
O projeto do framework IndentTree é apresentado na Figura 32, considerando apenas aspectos estruturais e gráficos básicos.
Assim como para Graph, não se pretende aqui desenvolver um framework IndentTree profissional, com todas as funcionalidades necessárias para ser utilizado numa aplicação real, mas sim destacar alguns aspectos importantes de projeto do framework genérico e da conexão com o framework de CapitalBudgeting.
IndentTree Glyph_ Root:
TreeNode Draw (w:
Window) Erase (w:
Window) Intersects (p:
Point) AddNode (n:
TreeNode) RemoveNode (n:
TreeNode) CreateAndAddNode (fth:
TreeNode): TreeNode Draw (w:
Window)_ Children-\&gt; Remove (c);_
Root_ Father-\&gt; RemoveChild (this);
Classe Glyph: Classe abstrata que representa um elemento visual genérico, o qual pode ser apresentado graficamente e é capaz de reconhecer e receber comandos do mouse, num ambiente gráfico de janelas.
Draw: Operação abstrata (método hook) que deve ser implementada nas subclasses de Glyph, responsável por a definição da aparência gráfica e desenho do objeto numa Window.
Erase: Operação abstrata (método hook) que deve ser implementada nas subclasses de Glyph, responsável por apagar o elemento visual de uma Window.
Bounds: Retorna a área retangular ocupada por a aparência gráfica do objeto Glyph, encapsulada numa estrutura GlyphArea.
Classe TreeNode:
Classe abstrata que representa o elemento visual 'nó' na árvore indentada.
É uma subclasse de Glyph, e portanto herda todas as propriedades gráficas definidas em Glyph.
Contém operações de manutenção da estrutura da árvore, como a manutenção do conjunto de nós filhos de um determinado nó.
AddChild, RemoveChild:
Operações de gerenciamento dos relacionamentos existentes entre objetos TreeNode.
Permitem que nós filhos sejam adicionados ou removidos de um nó pai.
GetFather: Informa qual o objeto TreeNode pai de um outro objeto TreeNode.
Remove, RemoveChild:
Operações incluídas para manutenção de integridade de estrutura.
RemoveChild promove a exclusão dos nós filhos de um determinado nó, enquanto Remove deve ser executada para que um nó tome as atitudes necessárias ao ser excluído.
Expand, Collapse:
Operações relacionadas com a aparência gráfica.
Expand faz com que todos os filhos ligados diretamente a um TreeNode sejam mostrados na árvore, enquanto Collapse faz com que estes objetos filhos sejam escondidos.
Classe IndentTree:
Representa uma estrutura de apresentação de Árvore Indentada.
Pode ser chamada de &quot;fachada «do framework IndentTree, de acordo com o que propõe o design pattern Facade.
Através um objeto IndentTree pode- se instanciar, incluir e conectar objetos TreeNode, e também manipular todos os objetos TreeNode que formam a estrutura.
GetRoot: Informa qual o objeto TreeNode raiz de uma árvore indentada.
CreateAndAddNode: Cria e inclui objetos TreeNode na árvore, retornando o novo objeto TreeNode.
AddNode, RemoveNode:
Operações que adicionam e removem objetos TreeNode da estrutura.
Em a verdade, a execução destas operações é delegada às operações AddChild e Remove de objetos TreeNode, já que eles são os responsáveis direto por a manutenção dos relacionamentos entre nós da árvore.
Contexto Você é um desenvolvedor de SAD que possui os seguintes pré-requisitos:
Em este momento, você quer desenvolver frameworks de apresentação e de situação de decisão reutilizáveis, ou você tem à sua disposição frameworks de apresentação e de situação de decisão genéricos e deseja conectar- los para a produção de um SAD específico.
Problema A Arquitetura de Desenvolvimento de SAD proposta por mostra como estruturas genéricas de apresentação, modeladas em frameworks de apresentação, podem ser usadas para representar diferentes modelos de decisão, modelados em frameworks de situação de decisão.
Em uma aplicação específica, do ponto de vista do usuário, uma estrutura de apresentação é o próprio modelo de decisão representado.
A estrutura de apresentação é um &quot;rosto bonito «para o modelo de decisão, tem o objetivo de facilitar a manipulação de modelos de decisão, fazendo com que sejam mais facilmente entendidos e modelados por o usuário da aplicação.
Por o aspecto da decomposição, a arquitetura mostra a motivação da criação de frameworks de apresentação reutilizáveis, encapsulando estruturas de apresentação genéricas, que possam representar diferentes tipos de modelos de decisão, e da criação de frameworks de situação de decisão reutilizáveis, encapsulando modelos de decisão, que possam ser representados por diferentes frameworks de apresentação.
Por o aspecto de composição, na construção de uma aplicação específica, um framework de apresentação é conectado a um framework de situação de decisão, sofrendo um processo de adaptação para que possa representar um framework de situação de decisão com suas particularidades e requisitos específicos.
O processo de conexão de um framework de apresentação com um de situação de decisão pode ser caracterizado da seguinte maneira:
De o ponto de vista da camada de diálogo, objetos de apresentação são simplesmente objetos de decisão com aparência gráfica.
Em uma aplicação específica, a camada de diálogo interage com objetos de decisão exclusivamente através de objetos de apresentação, enviando mensagens de modelagem e resolução.
As mensagens de modelagem devem chegar até a camada de decisão através dos objetos de apresentação, já que os objetos de decisão é que são os responsáveis por processar- las.
Porém, mensagens de modelagem podem necessitar também de um tratamento na camada de apresentação, gerando mensagens gráficas, para refletir possíveis alterações ocorridas no modelo de decisão que processou as mensagens.
Para a camada de diálogo, objetos de apresentação incorporam o comportamento semântico dos objetos de decisão que representam.
Portanto, no processo de conexão, as classes de apresentação devem ser adaptadas para incorporar o comportamento semântico das classes de decisão.
Como projetar genericamente e adaptar as classes dos frameworks de apresentação e situação de decisão para que, após o processo de conexão dos frameworks, as instâncias dos frameworks de apresentação possam dar a aparência gráfica desejada e incorporar o comportamento das instâncias dos frameworks de situação de decisão que estão sendo conectadas?
Forças Reusabilidade requer que frameworks de apresentação sejam genéricos, utilizáveis numa maior gama de diferentes tipos de modelos de decisão, assim como que frameworks de situação de decisão sejam genéricos para poder ser representados por diversos frameworks de apresentação.
Adaptabilidade requer que a adaptação dos frameworks de apresentação e situação de decisão no processo de conexão seja fácil, evitando o aumento de complexidade do projeto.
Transparência para usuários das aplicações requer que usuários não sejam afetados por decisões de projeto de frameworks.
Para os usuários das aplicações, o processo de conexão deve ser transparente, fazendo com as instâncias dos frameworks de apresentação dêem a impressão de que o usuário está interagindo com o próprio modelo de decisão representado por elas.
Separação de diferentes aspectos requer que a separação de diferentes aspectos nas camadas de apresentação e situação de decisão seja respeitada.
Frameworks de apresentação não devem assumir responsabilidades de frameworks de situação de decisão, e vice-versa.
Integridade requer que várias instâncias de frameworks de apresentação possam estar ligadas a uma mesma instância de framework de situação de decisão, e sincronizados com o seu estado atual.
Conectividade requer que frameworks de apresentação possam ser facilmente conectados ou desconectados de um framework de situação de decisão, tanto estática como dinamicamente, minimizando impactos em outros frameworks de apresentação e de situação de decisão.
Exemplo Considerando o estudo de caso da linguagem (Seção 7.3), deseja- se usar os frameworks genéricos de apresentação Graph e IndentTree para representar o framework de situação de decisão CapitalBudgeting.
Em relação a a reusabilidade, os frameworks de apresentação devem ser projetados de maneira que possam ser reutilizados e representar diversos tipos de modelos de decisão, assim como o framework de CapitalBudgeting deve ser modelado de maneira que possa ser representado por diversos frameworks de apresentação.
Em relação a a adaptabilidade, o processo de conexão dos frameworks Graph e IndentTree com CapitalBudgeting deve ser o mais fácil possível, evitando um aumento excessivo de classes no projeto, tornando o processo o mais plug' n'play possível.
Para fazer a conexão, em primeiro lugar deve- se estabelecer as correspondências das classes dos frameworks Graph e IndentTree às classes de CapitalBudgeting.
Através disto é feita a associação de um significado aos componentes das estruturas de apresentação.
Os elementos visuais após isto não são mais componentes vazios, mas sim elementos de decisão que têm propriedades gráficas especiais.
Em a conexão do framework Graph com o framework CapitalBudgeting, os elementos nó são usados para representar itens orçamentários (Node corresponde a Item), de acordo com as correspondências entre as classes dadas na Figura 33.
Em a conexão do framework IndentTree com o framework CapitalBudgeting, o elemento visual nó também é usado para representar itens orçamentários (TreeNode corresponde a Item), de acordo com as correspondências entre as classes dadas na Figura 34.
Após o processo de conexão dos frameworks, três problemas principais devem ser resolvidos:
Objetos dos frameworks Graph e IndentTree devem poder ser ligados aos objetos correspondentes do framework CapitalBudgeting, de maneira que possam se comunicar e colaborar;
ItemNode na instância do framework Graph e a inclusão de um objeto TreeNode na instância do framework IndentTree.
Portanto, o problema neste exemplo, tratado por este padrão, é como projetar genericamente e adaptar as classes dos frameworks de apresentação Graph e IndentTree e de situação de decisão CapitalBudgeting, para que, no processo de conexão dos frameworks, as instâncias dos frameworks de apresentação possam dar a aparência gráfica desejada e incorporar o comportamento das instâncias dos frameworks de situação de decisão que estão sendo conectadas, levando em consideração as forças que atuam sobre o problema.&amp;&amp;&amp;
Solução Em primeiro lugar, aplique Ligação de Instâncias para que objetos de apresentação possam ser ligados aos objetos de decisão que vão representar em aplicações específicas.
Para que classes de apresentação dêem a aparência gráfica específica das classes de decisão com as quais poderão ser conectadas, use Aparência Gráfica.
Para que objetos de apresentação incorporem o comportamento semântico dos objetos de decisão que representarão, aplique Comportamento Semântico.
Solução do Exemplo Veja as soluções dos exemplos dos padrões Ligação de Instâncias, Aparência Gráfica e Comportamento Semântico.
Contexto Você está usando Conexão Apresentação e Situação de Decisão.
Problema Como projetar genericamente e adaptar as classes dos frameworks de apresentação e situação de decisão para que, após o processo de conexão dos frameworks, os objetos de apresentação possam ser ligados ou associados aos objetos de decisão que estarão representando, de forma que possam se comunicar e colaborar?
Forças As mesmas do padrão mais genérico Conexão Apresentação e Situação de Decisão.
Exemplo Em a conexão dos frameworks genéricos Graph e CapitalBudgeting, é feita a correspondência conceitual das classes dos dois frameworks, associando- se a classe Graph com a classe CapitalBudgeting, e a classe Node com a classe Item.
As instâncias dos frameworks Graph e CapitalBudgeting têm que, de alguma forma, ser ligadas para permitir que seus objetos se comuniquem e colaborem, de acordo com a interação do usuário com a camada da diálogo.
Por exemplo, para que objetos da classe Node possam se comunicar e colaborar com os objetos da classe Item, eles têm que conhecer estes objetos.
Em relação a a reusabilidade, o framework de apresentação Graph deve ser projetado genericamente, de maneira que possa ser utilizado na representação de diversos frameworks de situação de decisão, assim como o framework de situação de decisão Capital Budgeting deve ser projetado evitando assumir conhecimentos sobre os frameworks de apresentação que o representarão, para não limitar reutilização.
Em relação a a adaptabilidade, estes frameworks devem ser facilmente adaptados para que seus objetos possam ser interligados em SADs específicos.
Portanto, como projetar os frameworks genéricos Graph e CapitalBudgeting e adaptar- los para que seus objetos sejam interligados, podendo se comunicar e colaborar, considerando as forças que atuam sobre o problema?
Solução Use Ligação de Instâncias Wb ou Ligação de Instâncias BB para resolver o problema.
Estes dois padrões são conflitantes, isto é, apenas um de eles deve ser utilizado para solucionar o problema não resolvido.
O padrão Ligação de Instâncias Wb, como o próprio nome diz, usa uma abordagem white-box na adaptação de classes de apresentação para que seus objetos sejam ligados a objetos de decisão, isto é, mais baseada em herança e sobrescrita, exigindo desenvolvedor um estudo mais aprofundado das classes para adaptação, enquanto Ligação de Instâncias BB usa abordagem blackbox, através da composição de objetos de decisão em objetos de apresentação, exigindo a definição de interfaces padrão.
Solução do Exemplo Veja as soluções específicas dos exemplos em Ligação de Instâncias Wb e Ligação de Instâncias Contexto Resultante Após a aplicação do padrão Ligação de Instâncias, você pode usar Aparência Gráfica para que classes de apresentação possam dar a aparência gráfica desejada a classes de decisão às quais serão conectadas, ou usar Comportamento Semântico para que objetos de apresentação incorporem o comportamento semântico de objetos de decisão que representarão.
Contexto Você está usando o padrão Ligação de Instâncias para que objetos de uma classe de um framework de apresentação possam conhecer (ser ligados a os) os objetos de uma classe de um framework de situação de decisão.
Porém, você não tem um grande conhecimento sobre os usos futuros da classe de apresentação, a quais classes de diferentes frameworks de situação de decisão ela pode ser conectada, e não pode fazer previsão se um objeto desta classe de apresentação será ligado a um número fixo de objetos de decisão.
Problema Como projetar genericamente e adaptar as classes dos frameworks de apresentação e situação de decisão para que, após o processo de conexão dos frameworks, os objetos de uma classe de apresentação possam ser ligados ou associados aos objetos de decisão que estarão representando, de forma que possam se comunicar e colaborar?
Forças Herdadas de Ligação de Instâncias. Exemplo Usando o exemplo dado em Ligação de Instâncias, considere que no contexto deste problema é difícil fazer uma previsão dos usos futuros da classe de apresentação Node, e conseqüentemente do número e das classes de situação de decisão que Node possa ser utilizada para representar.
Em a situação específica de conexão do framework Graph com CapitalBudgeting, um objeto Node estará ligado a apenas um objeto de decisão, que é da classe Item.
Mas, em outras situações onde Graph pode ser conectado a outros frameworks de situação de decisão, não é possível prever se um objeto Node estará associado a um ou mais objetos de decisão.
Então, como projetar e adaptar os frameworks Graph e CapitalBudgeting, de forma que objetos Node possam ser ligados a objetos de frameworks de situação de decisão, como objetos Item de CapitalBudgeting?
Solução A Figura 37 mostra como a solução deve ser construída, através de um diagrama de classes UML.
Projete a classe de apresentação genérica sem assumir conhecimento algum sobre objetos de decisão, de diferentes frameworks de situação de decisão, aos quais seus objetos poderão ser ligados.
Em o processo de conexão com um framework de situação de decisão específico, crie uma subclasse da classe de apresentação, incluindo referências diretas aos objetos das classes de decisão aos quais ela está sendo associada.
Em a subclasse de apresentação (conectada), deve ser incluída uma operação para a composição da referência de cada objeto de decisão.
Estas operações normalmente são executadas automaticamente por a operação de inicialização de objetos da classe de apresentação (construtor).
De acordo com o diagrama de classes e os participantes da solução, a ligação de um objeto de apresentação aos seus objetos de decisão é dada através da instanciação da classe ConnectedPresentation e executando as operações de composição de objetos de decisão SetDSObj1, operação de inicialização de objetos, pode- se passar como parâmetro os objetos de decisão na instanciação do objeto de apresentação.
Isto é ilustrado no fragmento de código da operação newPresentation da classe Client.
Estrutura Decision1 ds1;
Decision2 ds2; ConnectedPresentation presObj $= new ConnectedPresentation;
Client GenericPresentation instantiates ConnectedPresentation_ DSObj1:
DSClass1_ DSObj2:
DSClass2 SetDSObj1 SetDSObj2 (obj:
DSClass2) new SetDSObj1;
SetDSObj2 (obj2);
Participantes GenericPresentation classe genérica de apresentação ConnectedPresentation classe de apresentação adaptada para conhecer os objetos de decisão que seus objetos representarão.
Define referências às classes de decisão conectadas.
Define operações para compor os objetos de decisão.
Opcionalmente, define uma operação de inicialização que chama automaticamente as operações de composição de objetos (new) Decision1, Decision2 Classes de um framework de situação de decisão conectadas com a classe ConnectedPresentation.
Client Representa conceitualmente o papel de uma classe cliente que instancia um objeto de apresentação e o liga aos objetos de decisão que representará.
Solução do Exemplo A Figura 38 mostra como a solução para o exemplo deve ser construída através de um diagrama de classes UML.
A classe de apresentação Node (GenericPresentation) foi projetada sem assumir conhecimento algum sobre objetos de decisão, de diferentes frameworks de situação de decisão, que poderá ser usada para representar.
Em o processo de conexão com a classe Item, uma subclasse de Node é criada, com o nome de ItemNode (ConnectedPresentation), a qual adiciona uma referência direta a classe Item (Decision), e define uma operação para composição do objeto Item que será representado por um ItemNode, que é SetItem (SetDSObj).
Além disso, um método construtor é definido, recebendo como argumento o objeto Item que será ligado a um objeto ItemNode, chamando automaticamente a operação SetItem.
A ligação de um objeto ItemNode ao seu objeto Item é mostrada na classe Client, que instancia um objeto ItemNode, passando como parâmetro o objeto Item que representará.
A operação de inicialização da classe ItemNode (new) recebe como argumento um objeto Item e chama a operação de composição de objeto SetItem automaticamente, promovendo a ligação dos objetos.
Node Client instantiates ItemNode_ Item:
Item SetItem (i:
Item) new (i:
Item) uses Item_ Item SetItemObj;
Justificativa da Solução O uso de abordagem white-box permite que classes genéricas sejam adaptadas e estendidas com bastante liberdade, sem a necessidade de previsão de pontos de variabilidade.
Como, no contexto deste padrão, não é possível fazer uma previsão do número de objetos de decisão aos quais objetos de uma classe de apresentação serão ligados, fica difícil a previsão de pontos de variabilidade neste sentido, para não comprometer a reusabilidade da classe de apresentação.
Por outro lado, o processo de adaptação é um pouco mais trabalhoso, já que todas as medidas de adaptação da classe de apresentação devem ser feitas caso a caso no processo de conexão.
Outra conseqüência do uso de abordagem white-box é que em cada adaptação da classe de apresentação genérica, é gerada uma subclasse.
Em alguns casos, este efeito pode ser considerado indesejado, já que é sabido que o aumento de classes num projeto aumenta também a sua complexidade.
Padrões Relacionados O padrão Ligação de Instâncias BB é conflitante com Ligação de Instâncias Wb, o qual é mais recomendado quando podem ser feitas previsões sobre o número de objetos de decisão aos quais um objeto de apresentação será ligado, e também quando se quer evitar a criação de subclasse na adaptação da classe genérica.
Contexto Você está usando o padrão Ligação de Instâncias para que objetos de uma classe de um framework de apresentação possam conhecer (ser ligados a os) os objetos de uma classe de um framework de situação de decisão.
Você possui um certo conhecimento sobre possíveis usos futuros de uma classe genérica de apresentação, e pode determinar o número de objetos de decisão que seus objetos poderão representar.
Problema Como projetar genericamente e adaptar as classes dos frameworks de apresentação e situação de decisão para que, após o processo de conexão dos frameworks, os objetos de uma classe de apresentação possam ser ligados ou associados aos objetos de decisão que estarão representando, de forma que possam se comunicar e colaborar?
Forças Herdadas de Ligação de Instâncias. Exemplo Usando o exemplo dado em Ligação de Instâncias, considere que no contexto deste problema podese fazer uma alguma previsão dos usos futuros da classe de apresentação Node em diferentes SADs específicos, relacionada principalmente com o número de objetos de decisão que objetos Node poderão representar.
Em a situação específica de conexão do framework Graph com CapitalBudgeting, um objeto Node estará ligado a apenas um objeto de decisão, que é da classe Item.
Pode- se prever que em outras situações, onde Graph pode ser conectado a outros frameworks de situação de decisão, um objeto Node estará ligado a apenas um objeto de decisão.
Então, como projetar e adaptar os frameworks Graph e CapitalBudgeting, de forma que objetos Node possam ser ligados a objetos de frameworks de situação de decisão, como objetos Item de CapitalBudgeting?
Solução A Figura 39 mostra como a solução deve ser construída, através de um diagrama de classes UML.
Projete a classe genérica do framework de apresentação, definindo referências para composição dos objetos de decisão aos quais seus objetos podem ser ligados.
As referências devem ser da classe de decisão genérica, uma superclasse de todas as classes de decisão que poderão ser representadas por a classe de apresentação.
Para isto, pode ser criada uma classe de decisão genérica sem nenhuma funcionalidade, apenas para padronizar os tipos dos objetos de decisão, ou então usar uma superclasse comum a todas as classes, disponível numa metodologia ou linguagem OO, normalmente chamada de Object.
Em metodologias e linguagem OO que utilizam verificação de tipo, a classe genérica de apresentação deve poder recuperar a informação de tipo que é perdida na composição de objetos, já que as referências aos objetos de decisão são do tipo mais genérico.
Então, a classe deve ser parametrizada, na instanciação, com o tipo de cada objeto de decisão aos quais seus objetos serão ligados.
Defina também operações para fazer a composição dos objetos de decisão nas referências definidas.
Opcionalmente, estas operações podem ser executadas automaticamente por uma operação de inicialização de objetos da classe de apresentação (construtor).
Portanto, na classe genérica são determinados dois pontos de variabilidade.
O primeiro é definido através de referências para composição de objetos de decisão, e o segundo, específico para metodologias e linguagens tipadas, é definido por a parametrização dos tipos das classes de decisão que serão representadas por um objeto de apresentação.
Em o processo de conexão com um framework de situação de decisão específico, não é necessário criar subclasse de apresentação.
De acordo com o diagrama de classes e os participantes da solução, a ligação de um objeto de apresentação aos seus objetos de decisão é dada através da instanciação da classe GenericPresentation e executando as operações de composição de objetos de decisão tiver uma operação de inicialização de objetos, pode- se passar como parâmetro os objetos de decisão na instanciação do objeto de apresentação.
Isto é ilustrado no fragmento de código da operação newPresentation da classe Client.
No caso de metodologias e linguagens tipadas, a adaptação da classe de apresentação para ligação dos objetos é dada também através da parametrização da classe com os tipos dos objetos de decisão, na instanciação de um objeto de apresentação.
Participantes GenericPresentation Classe genérica de apresentação.
Define referências a classe de decisão genérica (GenericDecision) para cada objeto de decisão ao qual seus objetos serão ligados(_ DSObj1,_ DSObj2).
Define operações para compor os objetos de decisão.
Opcionalmente, define uma operação de inicialização que chama automaticamente as operações de composição de objetos.
GenericDecision Classe genérica de decisão, que é a superclasse de todas as classes de decisão.
Em metodologias e linguagens OO que oferecem uma superclasse comum (como Object em Smalltalk), pode- se usar esta superclasse para exercer o papel de GenericDecision.
Decision1, Decision2 classes de um framework de situação de decisão.
Client representa conceitualmente o papel de uma classe cliente que instancia um objeto de apresentação e o liga aos objetos de decisão que representará.
Solução do Exemplo A Figura 40 mostra como a solução do exemplo deve ser construída, através de um diagrama de classes UML.
A classe de apresentação Node (GenericPresentation) define uma referência para conhecer um objeto de decisão representado por um objeto Node.
A referência definida é do tipo genérico GenericDecision, que a superclasse de todas as classes de decisão.
Como sugere a solução do padrão, é criada uma operação para compor o objeto de decisão (SetDSObj), que é chamada automaticamente por a operação de inicialização da classe (new).
Além disso, a classe é parametrizada por o tipo da classe concreta do objeto de decisão que será representado por Node.
Em o processo de conexão do framework Graph com o framework de Capital Budgeting, um objeto Node é ligado ao seu objeto Item (Decision) quando ele é passado como parâmetro na instanciação de Node.
Em o momento da instanciação, é passado como parâmetro também o tipo concreto da classe representada por Node, que neste caso é Item.
Isto é ilustrado no fragmento de código da operação newPresentation da classe Client.
DSClass Node_ DSObj:
DSClass_ DSObj GenericDecision SetDSObj (obj:
DSClass) new (obj:
DSClass) instantiates SetDSObj (obj);
Justificativa da Solução O uso de abordagem black-box permite que classes genéricas sejam adaptadas e estendidas com maior facilidade, preenchendo- se os pontos de variabilidade previstos.
Como, no contexto deste padrão, é possível fazer uma previsão do número de objetos de decisão aos quais objetos de uma classe de apresentação serão ligados, são previstas referências genéricas a objetos de decisão aos quais objetos de apresentação podem ser ligados.
Por outro lado, se a previsão dos pontos de variabilidade não é correta, pode- se limitar a reusabilidade da classe de apresentação e, implicando assim, tarefas de reprojeto, o que não é desejado.
Como conseqüência positiva do uso de abordagem black-box para ligação dos objetos, evita- se a criação de uma subclasse para cada adaptação da classe de apresentação.
Como conseqüência negativa, inerente ao uso de abordagem black-box, perde- se um pouco da semântica do projeto, já que a grande maioria das metodologias e linguagens OO dão suporte direto maior à representação de classes e seus relacionamentos, em relação a objetos e composições de objetos.
Além disso, o número de objetos aumenta, em relação a a abordagem white-box, o que deve ser observado quando há uma preocupação com os recursos (memória) alocados.
Em linguagens e metodologias tipadas, é necessário recuperar a informação de tipo da classe real dos objetos de decisão representados, porque com o uso dos padrões Aparência Gráfica e Comportamento Semântico, um objeto de apresentação normalmente precisa conhecer toda a interface dos objetos de decisão para que possam se comunicar.
Padrões Relacionados O padrão Ligação de Instâncias Wb é conflitante com Ligação de Instâncias BB, o qual é mais recomendado quando é difícil fazer previsões sobre o número de objetos de decisão aos quais um objeto de apresentação será ligado.
Contexto Você está usando Conexão Apresentação e Situação de Decisão, e já utilizou Ligação de Instâncias para que objetos de apresentação possam ser ligados a objetos de decisão, no processo de conexão de frameworks.
Problema Em o processo de conexão de frameworks, primeiramente classes genéricas de um framework de apresentação são conceitualmente associadas a classes de um framework de situação de decisão.
As classes de apresentação são selecionadas para executar o papel das classes de decisão, dando uma aparência gráfica aos objetos de decisão.
Um framework de apresentação conectado a um framework de situação de decisão tem que saber dar a aparência gráfica desejada e específica do framework de situação de decisão.
Internamente, as classes de apresentação têm que dar a aparência gráfica específica das classes de decisão que estão sendo associadas.
Dar uma aparência gráfica específica de uma classe de decisão implica, em primeiro lugar, apresentar o elemento visual endereçado por a classe de apresentação com diversas propriedades visuais específicas das classes de decisão associadas, isto é, comuns a todos os objetos das classes de decisão.
Em segundo lugar, implica mostrar as partes desejadas do conteúdo dos objetos de decisão, que são dependentes de cada objeto de decisão.
Como projetar genericamente e adaptar as classes dos frameworks de apresentação e situação de decisão para que, no processo de conexão, os objetos de uma classe de apresentação saibam dar a aparência gráfica desejada e específica dos objetos de decisão que estarão representando?
Forças As mesmas do padrão mais genérico Conexão Apresentação e Situação de Decisão.
Exemplo Em a conexão dos frameworks genéricos Graph e CapitalBudgeting, a classe Node é associada conceitualmente à classe Item, isto é, ela é escolhida para representar objetos Item.
Para isto, objetos Node têm que dar a aparência gráfica desejada e específica para objetos Item.
Quanto representando objetos Item, objetos da classe Node devem saber dar a aparência gráfica personalizada desejada eles.
Suponha- se que após a conexão de Graph e CapitalBudegting, desejase que um objeto Node apresente graficamente um círculo e um retângulo, mostrando dentro de o retângulo a descrição do item (GetLabel), e dentro de o círculo a letra inicial da natureza do item (GetNature).
As propriedades gráficas da classe Node que dependem exclusivamente da classe Item são as formas` círculo 'e o` retângulo'.
O que é colocado dentro de o retângulo e do círculo depende do objeto Item que está ligado a um objeto Node.
Em outras palavras, círculo e retângulo são propriedades visuais dependentes da classe associada (classe Node representa classe Item), e as partes internas do círculo e do retângulo são propriedades visuais dependentes da ligação de objetos (objeto Node ligado a objeto Item).
O que é mostrado dentro de o círculo e do retângulo é determinado em tempo de execução, de acordo com o conteúdo do objeto Item.
A Figura 41 mostra as dependências da aparência do elemento visual nó sobre a classe e os objetos Item representados.
Entretanto, Graph poderia ser conectado com outro framework de situação de decisão, e então a classe Node poderia ser associada conceitualmente a uma outra classe de decisão, exigindo uma aparência gráfica completamente diferente.
Por exemplo, um modelo de decisão para avaliação de como mostra a Figura 42.
Este modelo poderia ser representado também por Graph, e a classe Node teria ser adaptada para dar a aparência gráfica específica destes outros elementos de decisão.
Em relação a a reusabilidade, a classe de apresentação Node deve ser projetada genericamente, de maneira que possa ser adaptada e dar aparência gráfica desejada a classes de diferentes frameworks de situação de decisão, com as quais poderá ser conectada.
Para isto, os pontos de variabilidade devem ser deixados em aberto, relacionados com as propriedades visuais dependentes das classes e dos objetos de decisão que poderá representar.
Além disso, a classe de situação de decisão Item deve ser projetada evitando assumir conhecimentos sobre classes de apresentação que poderão representar- la, e também sobre aspectos da camada de apresentação.
Em relação a a adaptabilidade, a classe Node deve ser facilmente adaptada para dar a aparência gráfica específica de uma classe de decisão com a qual será conectada.
Classes são mais fáceis de adaptar principalmente quando pontos de estabilidade e variabilidade que variam e evoluem independentemente são separados e previstos nas classes.
Então, como projetar e adaptar as classes Node e Item e adaptar- las, para que a classe Node saiba dar a aparência gráfica específica de objetos Item, levando em conta forças que atuam sobre o problema?
Solução Para não limitar a reutilização, projete a classe de apresentação deixando em aberto os dois pontos de variabilidade principais e genéricos de aparência gráfica, que são as propriedades visuais que dependem das classes e dos objetos de decisão que a classe de apresentação poderá representar.
O foco deste padrão é destacar a existência destes pontos de variabilidade e a necessidade de deixar- los em aberto.
Dentro desses dois pontos de variabilidade, identifique e separe pontos de estabilidade e outros pontos de variabilidade mais específicos.
A identificação e separação de pontos de estabilidade e variabilidade mais específicos pode diminuir o espectro de reusabilidade, mas pode facilitar a adaptação da classe de apresentação.
Para isto, você pode criar classes de apresentação mais genéricas, porém mais difíceis de adaptar, e desenvolver subclasses da classe de apresentação definindo pontos de estabilidade e variabilidade mais específicos, com espectros menores de reutilização, porém mais fáceis de serem adaptadas.
Estes pontos de estabilidade e variabilidade podem ser expressos através de métodos template e hook.
O comportamento dos métodos hook pode ser definido ou adaptado através de sobrescrita (abordagem white-box) ou composição de objetos (abordagem black-box).
Isto é amplamente discutido na literatura.
Justificativa da Solução A solução do padrão é bastante abstrata, não define qual abordagem de adaptação utilizar (whitebox ou black-box), porque soluções específicas dependem de contextos variáveis que não podem ser previstos, ficando a cargo de o desenvolvedor (usuário da linguagem) decidir qual abordagem utilizar, baseando seu julgamento em boas técnicas de projeto, design patterns, etc., descritos na literatura, sempre levando em consideração as forças contraditórias de reusabilidade e adaptabilidade.
Solução do Exemplo Para a construção da solução do exemplo apresentado, em primeiro lugar é definida uma classe genérica Glyph que representa um elemento visual simples, que pode ser apresentado numa janela (num ambiente gráfico de janelas), ocupa um espaço retangular na janela e pode identificar se o mouse está apontado para a área visual da janela ocupada por o elemento.
A classe Node é definida como uma subclasse de Glyph, incorporando a funcionalidade gráfica básica para permitir que objetos Node sejam apresentados numa janela.
Cabe lembrar que além de a parte visual, Node define comportamento relacionado com aspectos estruturais, como a manipulação dos objetos Edge relacionados com um objeto Node.
Os pontos de variabilidade que são deixados em aberto por Node com o objetivo de dar uma aparência gráfica a diferentes tipos de objetos de decisão são na verdade herdados da superclasse Glyph.
A operação abstrata Draw deve ser implementada por subclasses de Node, dando a aparência gráfica desejada para classes de decisão conectadas.
Draw é a representação genérica dos dois tipos de pontos de variabilidade que devem ser deixados em aberto nas classes de apresentação.
Em a implementação de Draw, devem ser definidas as propriedades gráficas especiais que dependem das classe de decisão conectadas (comuns a todos os objetos da classe), e também as propriedades que dependem do conteúdo de cada objeto de decisão.
A Figura 43 mostra a criação de uma subclasse de Node, ItemNode, que é adaptada para dar a aparência gráfica específica de objetos Item.
O fragmento da implementação da operação Draw mostra como é feita a definição das propriedades dependentes dos elementos de decisão.
Em primeiro lugar, são desenhados o círculo e o retângulo que compõem a aparência gráfica dos itens, que são propriedades específicas do tipo de objeto de decisão representado.
Depois, são apresentados a descrição e a letra inicial da natureza do objeto Item representado por um objeto de apresentação, dentro de o retângulo e do círculo.
Obviamente, estas são as propriedades gráficas que dependem de cada objeto Item representado.
Para apresentar o conteúdo do objeto Item, cada objeto de apresentação precisa conhecer o seu objeto Item para poder recuperar o seu conteúdo.
Como pré-requisito deste padrão, já deve ter sido aplicado o padrão Ligação de Instâncias.
Em o diagrama acima, foi usado a solução variante encapsulada em Ligação de Instâncias Wb, apenas para fins de demonstração.
A outra solução, disponível em Ligação de Instâncias BB, poderia ser usada igualmente.
Padrões Relacionados A camada de diálogo pode enviar mensagens de manipulação de elementos de decisão, chamadas de mensagens semânticas, através instâncias de frameworks de apresentação ligadas a uma instância de framework de situação de decisão, usando- se Comportamento Semântico.
Estas mensagens podem causar alterações no estado do modelo de decisão, que normalmente devem ser refletidas por a aparência gráfica dos objetos de apresentação.
Contexto Você está usando Conexão Apresentação e Situação de Decisão, e já utilizou Ligação de Instâncias para que objetos de apresentação possam ser ligados a objetos de decisão, no processo de conexão de frameworks.
Problema De o ponto de vista da camada de diálogo, uma instância de um framework de apresentação, ligada a uma instância de um framework de situação de decisão, é o próprio modelo de decisão representado, apenas com um aparência gráfica especial.
Em uma aplicação específica, a camada de diálogo interage com objetos de decisão exclusivamente através de objetos de apresentação, enviando mensagens de modelagem e resolução, denominadas genericamente de mensagens semânticas.
As mensagens semânticas devem chegar até a camada de decisão através dos objetos de apresentação, já que os objetos de decisão é que são os responsáveis por processar- las.
Porém, mensagens semânticas, especialmente mensagens de modelagem, podem necessitar também de um tratamento por parte de os objetos de apresentação, gerando mensagens gráficas, para refletir possíveis alterações ocorridas no modelo de decisão que processou as mensagens.
As mensagens semânticas podem causar alterações estruturais numa instância de framework de situação de decisão, como inclusão e eliminação de objetos de decisão, ou alterações de conteúdo de objetos de decisão.
Como projetar genericamente e adaptar as classes dos frameworks de apresentação e situação de decisão para que, após o processo de conexão, os objetos de apresentação possam incorporar o comportamento semântico dos objetos de decisão aos quais estão ligados, dando a sensação para a camada de diálogo de que, quando está interagindo com um objeto de apresentação, está interagindo diretamente com os objetos de decisão representados por ele?
Forças As mesmas do padrão mais genérico Conexão Apresentação e Situação de Decisão.
Exemplo Em a conexão dos frameworks genéricos Graph e CapitalBudgeting, foi feita a correspondência conceitual das classes dos dois frameworks, associando- se a classe Graph com a classe CapitalBudgeting, e a classe Node com a classe Item.
Após o processo de conexão dos frameworks Graph e CapitalBudgeting, a instância do framework Graph tem que se comportar para a camada de diálogo como a própria instância do framework de CapitalBudgeting que está ligada.
A camada de diálogo deve poder enviar mensagens de manipulação de objetos de decisão (mensagens semânticas) através dos objetos de apresentação que os representam.
Por exemplo, a camada de diálogo deve poder enviar a mensagem SetLabel através de um objeto Node para modificação da descrição do objeto Item que está ligado, sendo de responsabilidade de Node fazer este pedido chegar até Item.
Além de atuar como um condutor de mensagens semânticas, uma instância de Graph deve também dar um tratamento adequado às mensagens semânticas, quando estas causam alterações no estado dos objetos de decisão que interferem no estado dos objetos de apresentação que os representam.
No caso de a mensagem SetLabel, o objeto Node tem atualizar a sua aparência gráfica após a alteração da descrição do objeto Item, devendo então gerar mensagens gráficas para isto.
Como projetar genericamente e adaptar as classes dos frameworks Graph e CapitalBudgeting para que, após o processo de conexão dos frameworks, uma instância de Graph incorpore o comportamento semântico da instância de CapitalBudgeting que estará ligada?
Solução Para que as mensagens semânticas originadas na camada de diálogo cheguem até os objetos de situação através dos objetos de apresentação que os representam, use Conduto de Mensagens Semânticas.
Após o uso de Conduto de Mensagens Semânticas, é necessário que objetos de apresentação dêem tratamento adequado às mensagens semânticas, caso causem alterações de estado nos objetos de decisão que interfiram no estado dos objetos de apresentação, usando Apresentação Trata Mensagens Semânticas.
Para manter o sincronismo entre objetos de apresentação de diferentes frameworks e os objetos de decisão aos quais estão ligados, use Notificação de Modificações Semânticas.
Solução do Exemplo Veja os exemplos em Conduto de Mensagens Semânticas, Apresentação Trata Mensagens Semânticas e Notificação de Modificações Semânticas.
Padrões Relacionados O padrão Inclusão de Objetos de Decisão trata do problema específico de envio de mensagens semânticas de inclusão de objetos de decisão por a camada de diálogo.
O padrão Exclusão de Objetos de Decisão (Np) trata do problema específico de envio de mensagens semânticas de exclusão de objetos de decisão por a camada de diálogo.
Contexto Você está usando Comportamento Semântico.
Problema Como é determinado por o padrão Comportamento Semântico, a camada de diálogo envia mensagens de modelagem para objetos de apresentação, que por sua vez devem repassar essas mensagens para os objetos de decisão aos quais estão ligados, já que é de responsabilidade da camada de situação de decisão processar mensagens de modelagem.
De certa forma, objetos de apresentação devem ser canais de transmissão de mensagens semânticas, enviada por objetos de diálogo, até os correspondentes objetos de decisão.
Como projetar genericamente e adaptar as classes dos frameworks de apresentação e situação de decisão para que, após o processo de conexão, os objetos de apresentação possam atuar como canais de transmissão de mensagens de modelagem, certificando- se de repassar estas mensagens para os objetos de decisão que representam, os quais são os responsáveis por o tratamento adequado deste tipo de mensagens?
Forças As mesmas do padrão mais genérico Conexão Apresentação e Situação de Decisão.
Exemplo Em a conexão dos frameworks genéricos Graph e CapitalBudgeting, foi feita a correspondência conceitual das classes dos dois frameworks, associando- se a classe Graph com a classe CapitalBudgeting, e a classe Node com a classe Item.
Após a execução do processo de conexão, os objetos destas classes de apresentação devem poder repassar mensagens de modelagem, que recebem de objetos de diálogo, para os objetos de decisão aos quais estão ligados.
Por exemplo, um objeto Node representando um objeto Item deve poder receber mensagens como SetLabel e SetNature, e repassar estas mensagens para o respectivo Item dar o tratamento adequado.
Como projetar genericamente e adaptar as classes dos frameworks Graph e CapitalBudgeting para que, após o processo de conexão, objetos Node possam conduzir mensagens semânticas, originadas na camada de diálogo, até os objetos de decisão aos quais estão associados?
Solução Use Conduto de Mensagens Semânticas Wb ou Conduto de Mensagens Semânticas BB para resolver o problema.
Estes dois padrões são conflitantes, isto é, apenas um de eles deve ser utilizado para solucionar o problema não resolvido.
O padrão Conduto de Mensagens Semânticas Wb, como o próprio nome diz, usa uma abordagem white-box na adaptação de classes de apresentação para que seus objetos sejam ligados a objetos de decisão, isto é, mais baseada em herança e sobrescrita, exigindo desenvolvedor um estudo mais aprofundado das classes para adaptação, enquanto Conduto de Mensagens Semânticas BB usa abordagem black-box, aproveitando- se do que gerou a aplicação do padrão Ligação de Instâncias.
Solução do Exemplo Veja as soluções para o exemplo em Conduto de Mensagens Semânticas Wb e Conduto de Mensagens Semânticas BB.
Contexto Resultante Mensagens de modelagem repassadas por objetos de apresentação para objetos de decisão podem também ter que ser tratadas por os objetos de apresentação, refletindo possíveis alterações de estado nos objetos de decisão que interfiram no estado dos objetos de apresentação ligados.
Para isto, use Apresentação Trata Mensagens Semânticas.
Contexto Você está usando Conduto de Mensagens Semânticas.
Problema Como projetar genericamente e adaptar as classes dos frameworks de apresentação e situação de decisão para que, após o processo de conexão, os objetos de uma classe de apresentação possam atuar como canais de transmissão de mensagens de modelagem, certificando- se de repassar estas mensagens para os objetos de decisão que representam, os quais são os responsáveis por o tratamento adequado deste tipo de mensagens?
Forças Herdadas de Conduto de Mensagens Semânticas. Exemplo Veja a seção exemplo do padrão Conduto de Mensagens Semânticas.
Solução A Figura 44 mostra como a solução deve ser construída, através de um diagrama de classes UML.
Projete a classe de apresentação genérica (GenericPresentation) sem prever qualquer ponto de variabilidade relacionado com a recepção e envio de mensagens de modelagem.
Em o processo de conexão de um framework de apresentação genérico com um de situação de decisão, para permitir que objetos da classe de apresentação recebam e enviem mensagens semânticas aos objetos de decisão correspondentes, adapte a classe genérica criando uma subclasse (ConnectedPresentation), incluindo operações que representem as operações dos objetos de decisão associados, as quais são correspondentes às mensagens semânticas que a camada de diálogo pode enviar através dos objetos de apresentação.&amp;&amp;&amp;
Estas novas operações da subclasse de apresentação desempenham o papel das operações nas classes de decisão, do ponto de vista da camada de diálogo.
Internamente, estas operações delegam a responsabilidade de execução para as operações dos objetos de decisão, podendo tomar atitudes antes e depois de repassar as mensagens, como é mostrado no fragmento de código da operação dsOperation1 Decision1 de ConnectedPresentation.
A operação dsOperation1 Decision1 é a correspondente da operação Operation1 da classe de decisão Decision1.
Como pré-requisito deste padrão, já deve ter sido aplicado o padrão Ligação de Instâncias, para permitir que objetos de apresentação conheçam os seus objetos de decisão e possam enviar mensagens para eles.
Em a solução deste padrão, é usada a solução variante do padrão encapsulada em Ligação de Instâncias Wb, para fins de ilustração, sendo igualmente possível aplicar Ligação de Instâncias BB.
Note que a classe adaptada (ConnectedPresentation) corresponde àquela criada em Ligação de Instâncias Wb.
A solução também mostra como uma classe da parte de diálogo (Client) interage com um objeto de apresentação, enviando uma mensagem semântica através de ele, de acordo com o fragmento de código da operação SendsSemanticsMessage.
Estrutura GenericPresentation_ dsObj1 Decision1 Operation1 (paramList) Operation2 (paramList) ConnectedPresentation_ dsObj1:
Decision1_ dsObj2:
Decision2 dsOperation1 (paramList) dsOperation2 Decision1 (paramList) dsOperation1 Decision2 (paramList) dsOperation2 Decision2 (paramList) Decision2_ dsObj2 Operation1 (paramList) Operation2 (paramList) uses\&gt; Participantes GenericPresentation classe genérica de apresentação ConnectedPresentation classe de apresentação adaptada para receber e repassar mensagens de modelagem para objetos de decisão que seus objetos representarão.
Define operações representando cada uma das operações dos objetos de decisão, aos quais seus objetos estarão ligados, correspondentes às mensagens semânticas que a camada de diálogo pode enviar.
Cada uma destas operações delega execução aos objetos de decisão.
Decision1, Decision2 classes de um framework de situação de decisão conectadas com a classe ConnectedPresentation, que oferecem operações para manipulação de seus objetos Client Representa conceitualmente o papel de uma classe cliente, da camada de diálogo, que envia uma mensagem de modelagem a um objeto de apresentação.
Solução do Exemplo A Figura 45 mostra como a solução do exemplo deve ser construída, através de um diagrama de classes UML.
A aplicação da solução vai ser mostrada sobre a parte do exemplo que trata da conexão das classes Node e Item.
A solução apresentada considera que foi usado Ligação de Instâncias Wb para possibilitar que objetos Node conheçam os objetos Item que representam.
A classe genérica Node (GenericPresentation) não prevê nenhum ponto de variabilidade relacionado com a recepção e repasse de mensagens de modelagem.
Em a adaptação de Node, é criada a subclasse ItemNode (ConnectedPresentation), que inclui as operações dsSetLabel, dsGetLabel, dsSetNature e dsGetNature, que correspondem respectivamente às operações da classe de decisão Item SetLabel, GetLabel, SetNature, GetNature.
As operações de ItemNode delegam a execução às operações correspondentes no objeto Item que está sendo representado.
A camada de diálogo interage exclusivamente com as operações criadas em ItemNode como se estivesse tratando com a própria classe de decisão Item (DecisionClass).
Node Client uses ItemNode_ Item:
Item_ Item-\&gt; SetLabel (l);
Justificativa da Solução Com a classe de apresentação incorporando as operações de modelagem disponíveis nas classes de decisão conectadas, fica mais fácil para objetos de diálogo interagirem com os objetos de apresentação, já que do ponto de vista da camada de diálogo, os objetos de apresentação são os próprios objetos de decisão aos quais estão ligados, com uma aparência gráfica especial.
Além disso, isto permite que seja feito um controle, por parte de os objetos de apresentação, no envio das mensagens para os objetos de decisão, o que é particularmente importante para Apresentação Trata Mensagens Semânticas, quando se necessita dar um tratamento adequado às mensagens de modelagem dentro de a camada de apresentação, antes ou depois das mensagens serem conduzidas aos respectivos objetos de decisão.
A reusabilidade da classe genérica de apresentação não é afetada, uma vez que não é necessário fazer previsão de pontos de variabilidade.
Porém, o processo de adaptação é mais trabalhoso, exigindo a definição e implementação na classe de apresentação conectada das operações correspondentes às mensagens de modelagem que podem ser enviadas por a camada de diálogo, que delegam execução aos objetos de decisão.
Contexto Resultante Herdado de Conduto de Mensagens Semânticas.
Padrões Relacionados O padrão Conduto de Mensagens Semânticas Wb é conflitante com Conduto de Mensagens Semânticas BB.
Contexto Você está usando Conduto de Mensagens Semânticas.
Problema Como projetar genericamente e adaptar as classes dos frameworks de apresentação e situação de decisão para que, após o processo de conexão, os objetos de uma classe de apresentação possam atuar como canais de transmissão de mensagens de modelagem, certificando- se de repassar estas mensagens para os objetos de decisão que representam, os quais são os responsáveis por o tratamento adequado deste tipo de mensagens?
Forças Herdadas de Conduto de Mensagens Semânticas. Exemplo Herdadas de Conduto de Mensagens Semânticas.
Solução A Figura 46 e a Figura 47 mostram como a solução deve ser construída, através de diagramas de classes UML.
A solução está baseada principalmente no uso de Ligação de Instâncias, que é prérequisito deste padrão, permitindo que objetos de apresentação conheçam objetos de decisão que representam.
Basicamente, a solução proposta é criar operações na classe de apresentação que permitam a recuperação das referências aos objetos de decisão representados por objetos de apresentação.
Assim, a camada de diálogo deve usar estas operações para recuperar o objeto de decisão desejado, através do objeto de apresentação, e enviar mensagens de modelagem diretamente.
Se foi utilizado o padrão Ligação de Instâncias Wb, a classe de apresentação genérica (GenericPresentation) não precisa prever nenhum ponto de variabilidade.
Em a classe de apresentação adaptada (ConnectedPresentation) gerada por a solução de Ligação de Instâncias Wb, crie as operações para recuperar os objetos de decisão que estarão ligados aos objetos de apresentação.
Se foi utilizado o padrão Ligação de Instâncias Wb, a classe de apresentação genérica (GenericPresentation) deve incluir operações para recuperar os objetos de decisão que serão representados por os objetos de apresentação.
O processo de adaptação consiste basicamente em instanciar os objetos de apresentação ligando- os aos objetos de decisão.
A camada de diálogo, representada nos diagramas da seção Estrutura como a classe Client, envia uma mensagem semântica através de um objeto de apresentação recuperando a instância do objeto de decisão associado e então enviando a mensagem semântica diretamente a ele.
Isto é demonstrado no fragmento de código da operação SendsSemanticsMessage.
Estrutura Usando Ligação de Instâncias Wb:
Semânticas BB Usando Ligação de Instâncias Wb Usando Ligação de Instâncias BB:
Semânticas BB Usando Ligação de Instâncias BB Participantes Decision1, Decision2 classes de um framework de situação de decisão conectadas com a classe ConnectedPresentation, que oferecem operações para manipulação de seus objetos Client representa conceitualmente o papel de uma classe cliente, da camada de diálogo, que envia uma mensagem de modelagem a um objeto de apresentação.
Usando Ligação de Instâncias Wb:
GenericPresentation classe genérica de apresentação.
ConnectedPresentation classe adaptada de apresentação.
Define operações para permitir a recuperação dos objetos de decisão representados por um objeto de apresentação.
Usando Ligação de Instâncias BB:
GenericPresentation classe genérica de apresentação.
Define operações para permitir a recuperação dos objetos de decisão representados por um objeto de apresentação.
Solução do Exemplo A Figura 48 mostra como a solução do exemplo deve ser construída, através de um diagrama de classes UML.
A aplicação da solução vai ser mostrada sobre a parte do exemplo que trata da conexão das classes Node e Item.
A solução apresentada considera que foi usado Ligação de Instâncias BB para possibilitar que objetos Node conheçam os objetos Item que representam.
Tudo que a classe genérica Node (GenericPresentation) tem que fazer é oferecer uma operação que permita a recuperação do objeto Item representado, que é GetDSObj.
A camada de diálogo usa esta operação para obter o objeto Item (DecisionClass) e envie mensagens semânticas diretamente para ele.
A operação SetLabelCurrentNode da classe Client mostra como a camada de diálogo pode mandar uma mensagem SetLabel através de um objeto Node, considerando que o objeto Node foi ligado a um objeto Item e parametrizado por o tipo da classe de decisão, que é Item.
Justificativa da Solução A solução apresentada permite que mensagens de modelagem sejam conduzidas por os objetos de apresentação até os objetos de decisão exigindo pouco esforço no processo de conexão das classes.
Basicamente, quase toda a modelagem que dá suporte ao envio e repasse de mensagens é dada por a aplicação do padrão Ligação de Instâncias.
Em relação a a reusabilidade da classe de apresentação genérica, deve- se verificar diretamente a justificativa da solução dos padrões Ligação de Instâncias Wb e Ligação de Instâncias BB, já que a solução deste padrão não causa nenhuma influência nesta força que atua sobre o problema.
Contexto Resultante Como a camada de diálogo interage diretamente com os objetos de decisão, recuperando referências a estes objetos através dos objetos de apresentação que os representam, a camada de apresentação perde o controle sobre as mensagens que fluem da camada de diálogo para a camada de situação de decisão.
Normalmente, mensagens de modelagem necessitam também ser tratadas na camada de apresentação, para refletir possíveis alterações no estado dos objetos de decisão.
Para que as mensagens de modelagem possam receber tratamento adequado dos objetos de apresentação, use Apresentação Trata Mensagens Semânticas BB, que na verdade o levará até Notificação de Modificações Semânticas.
Padrões Relacionados O padrão Conduto de Mensagens Semânticas BB é conflitante com Conduto de Mensagens Semânticas Wb.
Contexto Você usou Conduto de Mensagens Semânticas.
Problema Após o uso de Conduto de Mensagens Semânticas para conexão de uma classe de apresentação com as classes de decisão associadas, os objetos de apresentação são capazes de atuar como condutores de mensagens semânticas, originadas na camada de diálogo, para os objetos de decisão aos quais os objetos de apresentação estão ligados.
Porém, mensagens semânticas, especialmente mensagens de modelagem, podem necessitar também de um tratamento por parte de os objetos de apresentação, gerando mensagens gráficas para refletir possíveis alterações ocorridas no modelo de decisão que processou as mensagens, ou mesmo bloquear o repasse destas mensagens.
As mensagens semânticas podem causar alterações estruturais numa instância de framework de situação de decisão, como inclusão e eliminação de objetos de decisão, ou alterações de conteúdo de objetos de decisão.
Como projetar genericamente e adaptar as classes dos frameworks de apresentação e situação de decisão para que, após o processo de conexão, os objetos de apresentação possam dar um tratamento adequado às mensagens semânticas, especialmente mensagens de modelagem, que são conduzidas para os seus objetos de decisão, refletindo possíveis alterações de estado ocorridas nos objetos de decisão, ou apenas bloqueando repasse das mensagens?
Forças As mesmas do padrão mais genérico Conexão Apresentação e Situação de Decisão.
Exemplo Em a conexão dos frameworks genéricos Graph e CapitalBudgeting, foi feita a correspondência conceitual das classes dos dois frameworks, associando- se a classe Graph com a classe CapitalBudgeting, e a classe Node com a classe Item.
Após a execução do processo de conexão e aplicação do padrão Conduto de Mensagens Semânticas, os objetos destas classes de apresentação são capazes de atuar como condutores de mensagens semânticas, recebidas de objetos de diálogo, para os objetos de decisão aos quais estão ligados.
Porém, muitas vezes estas mensagens semânticas, especialmente mensagens de modelagem, devem receber também um tratamento dos objetos de apresentação.
Por exemplo, um objeto Node representando um objeto Item deve poder receber mensagens como SetLabel e SetNature, e repassar estas mensagens para o objeto Item dar o tratamento adequado.
Porém, a aparência gráfica dos objetos Node depende do estado dos objetos Item aos quais estão associados (ver Aparência Gráfica).
Se a mensagem SetLabel é enviada para um Item, alterando a sua descrição, o objeto Node que conduziu a mensagem deve mudar a sua aparência gráfica para refletir a nova descrição.
Como projetar genericamente e adaptar as classes dos frameworks Graph e CapitalBudgeting para que, após o processo de conexão, objetos Node possam dar um tratamento adequado às mensagens semânticas, originadas na camada de diálogo, que são conduzidas até os objetos de decisão, para refletir possíveis alterações de estado ocorridas nos objetos de decisão que influenciam os objetos de apresentação, ou apenas bloquear o repasse das mensagens?
Solução Use um dos padrões que encapsulam soluções variantes para o problema, que são Apresentação Trata Mensagens Semânticas Wb e Apresentação Trata Mensagens Semânticas BB.
O padrão Apresentação Trata Mensagens Semânticas Wb baseia- se no uso de Conduto de Mensagens Semânticas Wb, que é pré-requisito deste padrão.
A solução dada por Apresentação Trata Mensagens Semânticas BB é dependente diretamente da aplicação de Conduto de Mensagens Semânticas BB.
Padrões Relacionados Normalmente, as atitudes tomadas por objetos de apresentação, quando são enviadas mensagens de modelagem, estão relacionadas com Aparência Gráfica.
Contexto Você já usou o padrão Conduto de Mensagens Semânticas Wb, e agora está usando Apresentação Trata Mensagens Semânticas,.
Problema Como projetar genericamente e adaptar as classes dos frameworks de apresentação e situação de decisão para que, após o processo de conexão, os objetos de uma classe de apresentação possam dar um tratamento adequado às mensagens semânticas, especialmente mensagens de modelagem, que são conduzidas para os seus objetos de decisão, refletindo possíveis alterações de estado ocorridas nos objetos de decisão, ou mesmo bloqueando o repasse das mensagens?
Forças Herdadas de Apresentação Trata Mensagens Semânticas.
Exemplo Veja a seção exemplo em Apresentação Trata Mensagens Semânticas.
Solução A Figura 49 mostra como a solução deve ser construída, através de um diagrama de classes UML.
Como pré-requisito deste padrão, já foi aplicado o padrão Conduto de Mensagens Semânticas Wb, que não prevê nenhum ponto de variabilidade na classe genérica de apresentação, mas define diversas operações na interface da classe adaptada (ConnectedPresentation), que simplesmente delegam a execução às operações correspondentes dos objetos de decisão representados.
Simbolicamente, por exemplo, a operação dsOperation1 Decision1 da classe ConnectedPresentation corresponde à operação Operation1 da classe Decision1.
A solução deste padrão também não prevê nenhum ponto de variabilidade.
As operações da classe adaptada, criadas no uso de Conduto de Mensagens Semânticas Wb, devem ser implementadas de maneira que, além de conduzir as mensagens semânticas para os objetos de decisão, os objetos de apresentação possam dar o tratamento adequado a elas, mantendo a consistência com os objetos de decisão que representam ou apenas controlando o repasse das mensagens.
O tratamento às mensagens pode ser dado antes e/ ou depois de repassar uma mensagem para um objeto de decisão, como mostra o fragmento de código da operação Operation1 de ConnectedPresentation.
As operações DoBeforeOperation1 Decision1 DoAfterOperation1 Decision1 representam simbolicamente a funcionalidade que pode ser adicionada antes ou depois da condução de uma mensagem semântica.
A solução também mostra como um objeto da classe de diálogo (Client) interage com um objeto de apresentação, enviando uma mensagem semântica através de ele, de acordo com o fragmento de código da operação SendsSemanticsMessage.
Assim como foi estabelecido para o padrão antecessor Conduto de Mensagens Semânticas Wb, já deve ter sido aplicado o padrão Ligação de Instâncias, para permitir que objetos de apresentação conheçam os seus objetos de decisão e possam enviar mensagens para eles.
Em a solução deste padrão, é usada a solução variante do padrão encapsulada em Ligação de Instâncias Wb, para fins de ilustração, sendo igualmente possível aplicar Ligação de Instâncias BB.
Note que a classe adaptada (ConnectedPresentation) corresponde àquela criada em Ligação de Instâncias Wb.
Estrutura GenericPresentation Decision1_ dsObj1 ConnectedPresentation dsObj1:
Decision1 dsObj2: Decision2_ dsObj2 dsOperation1 Decision1 (paramList) dsOperation2Decision (paramList) Operation1 (paramList) Operation2 (paramList) uses Operation1 (paramList) Operation2 (paramList) Client\&gt; Participantes GenericPresentation classe genérica de apresentação.
ConnectedPresentation classe de apresentação adaptada.
Inclui operações para o tratamento de mensagens semânticas antes e/ ou depois de repassar- las para os objetos de decisão representados Decision1, Decision2 classes de um framework de situação de decisão conectadas a classe ConnectedPresentation.
Client Representa conceitualmente o papel de uma classe cliente, da camada de diálogo, que envia uma mensagem semântica a um objeto de apresentação.
Solução do Exemplo A Figura 50 mostra como a solução do exemplo deve ser construída, através de um diagrama de classes UML.
A aplicação da solução vai ser mostrada sobre a parte do exemplo que trata da conexão das classes Node e Item.
A solução apresentada considera que foi usado Conduto de Mensagens Semânticas Wb, que é pré-requisito deste padrão, e para fins de ilustração, que objetos de apresentação são ligados a objetos de decisão através de Ligação de Instâncias Wb.
A classe genérica Node (GenericPresentation) não inclui nenhum ponto de variabilidade.
Em a aplicação de Conduto de Mensagens Semânticas Wb, são criadas na classe adaptada ItemNode (ConnectedPresentation) as operações dsSetLabel, dsGetLabel, dsSetNature e dsGetNature com o objetivo de conduzir mensagens semânticas aos objetos Item.
A solução deste padrão mostra como a operação dsSetLabel deve ser implementada para que, após a alteração da descrição de um objeto Item, um objeto Node que delega a execução à operação SetLabel do objeto Item possa atualizar sua aparência gráfica, refletindo a nova descrição do objeto, o que é representado simbolicamente por a chamada a operação Draw.
Um objeto de diálogo, representado no diagrama como Client, interage com o objeto ItemNode simplesmente executando a operação dsSetLabel, e o restante é feito por o objeto ItemNode.
Justificativa da Solução A solução aplicada baseia- se praticamente no uso do padrão antecessor Conduto de Mensagens Semânticas, portanto as justificativas da solução deste padrão remetem imediatamente às justificativas da solução de Conduto de Mensagens Semânticas.
Para fazer o tratamento das mensagens semânticas antes e/ ou depois do repasse aos objetos de decisão, a solução mostra como as operações especiais na classe de apresentação, que fazem este trabalho de condução de mensagens, devem ser implementadas, simplesmente adicionando- se funcionalidade para o tratamento das mensagens antes e/ ou depois da delegação da execução da operação de um objeto de apresentação à operação correspondente num objeto de decisão.
Contexto Resultante A solução deste padrão mostra como os objetos de apresentação que recebem mensagens semânticas da camada de diálogo podem dar um tratamento imediato a elas, antes e depois de conduzirem estas mensagens até os objetos de decisão responsáveis por processar- las.
Porém, outros objetos de apresentação, que não receberam uma mensagem semântica da camada de diálogo, mas que estejam ligados ao mesmo objeto de decisão simultaneamente, devem de alguma maneira reconhecer alterações de estado causadas no objeto de decisão e dar o tratamento adequado.
Para resolver este problema, deve- se usar o padrão Notificação de Modificações Semânticas.
Padrões Relacionados O padrão Apresentação Trata Mensagens Semânticas BB é conflitante com Apresentação Trata Mensagens Semânticas Wb.
Contexto Você está usando Apresentação Trata Mensagens Semânticas.
Problema Como projetar genericamente e adaptar as classes dos frameworks de apresentação e situação de decisão para que, após o processo de conexão, os objetos de uma classe de apresentação possam dar um tratamento adequado às mensagens semânticas, especialmente mensagens de modelagem, que são conduzidas para os seus objetos de decisão, refletindo possíveis alterações de estado ocorridas nos objetos de decisão, ou mesmo bloqueando o repasse das mensagens?
Forças Herdadas de Apresentação Trata Mensagens Semânticas.
Exemplo Veja a seção exemplo em Apresentação Trata Mensagens Semânticas.
Solução Deixe em aberto o problema de tratamento de mensagens semânticas por parte de os objetos de apresentação, passando imediatamente a aplicar o padrão Notificação de Modificações Semânticas.
Solução do Exemplo Veja as soluções para o exemplo em Notificação de Modificações Semânticas.
Justificativa da Solução A solução baseia- se no que foi gerado após a aplicação do padrão Conduto de Mensagens Semânticas, a partir de o qual objetos de apresentação atuam como condutores de mensagens semânticas para os objetos de decisão.
Em um cenário específico, em que um objeto de apresentação recebe e repassa uma mensagem de decisão para um objeto de decisão que represente, outros objetos de apresentação podem estar ligados ao mesmo objeto de decisão simultaneamente.
Este objeto de apresentação que recebe a mensagem pode dar imediatamente o tratamento adequado a ela, mas os outros objetos de apresentação precisam de alguma maneira serem notificados da mensagem enviada, para tomar as devidas atitudes.
Para isto, deve- se aplicar o padrão Notificação de Modificações Semânticas.
Os padrões Apresentação Trata Mensagens Semânticas e Notificação de Modificações Semânticas tratam basicamente do mesmo problema, que é o tratamento de mensagens semânticas por parte de os objetos de apresentação.
A diferença principal de problema entre os padrões está no modo como os objetos de apresentação reconhecem as mensagens semânticas enviadas e possíveis alterações causadas nos objetos de decisão.
Por isso, a solução deste padrão tenta padronizar o modo como é feito o tratamento de mensagens semânticas, deixando em aberto o problema para Notificação de Modificações Semânticas.
Uma conseqüência negativa do uso deste padrão é que os objetos de apresentação perdem o controle das mensagens semânticas repassadas, e não podem mais bloquear- las aos objetos de decisão.
Padrões Relacionados O padrão Apresentação Trata Mensagens Semânticas BB é conflitante com Apresentação Trata Mensagens Semânticas Wb.
Contexto Você usou Apresentação Trata Mensagens Semânticas.
Problema Após o uso de Conduto de Mensagens Semânticas para conexão de uma classe de apresentação com as classes de decisão associadas, os objetos de apresentação são capazes de atuar como condutores de mensagens semânticas, originadas na camada de diálogo, para os objetos de decisão aos quais os objetos de apresentação estão ligados.
Após o uso de Apresentação Trata Mensagens Semânticas, que é pré-requisito deste padrão, os objetos de apresentação que recebem e conduzem as mensagens semânticas até os objetos de decisão associados, podem dar um tratamento adequado imediatamente a estas mensagens, especialmente mensagens de modelagem, gerando mensagens gráficas para refletir possíveis alterações ocorridas nos objetos de decisão.
Vale lembrar que as mensagens de modelagem podem causar alterações estruturais numa instância de framework de situação de decisão, como inclusão e eliminação de objetos de decisão, ou simplesmente alterações de conteúdo de objetos de decisão.
Porém, considerando um cenário onde vários objetos de apresentação, de diferentes frameworks, estão ligados simultaneamente a um mesmo objeto de decisão, e camada de diálogo envia uma mensagem semântica para um destes objetos de apresentação.
Os outros objetos que não receberam a mensagem também têm que, de alguma maneira, reconhecer e refletir as alterações ocorridas no objeto de decisão.
Como projetar genericamente e adaptar as classes dos frameworks de apresentação e situação de decisão para que, após o processo de conexão, objetos de apresentação que estão representando simultaneamente um mesmo objeto de decisão possam, após a condução de uma mensagem de modelagem ao objeto de decisão por um objeto de apresentação específico, refletirem possíveis alterações de estado ocorridas no objeto de decisão, por as quais os objetos de apresentação são influenciados?
Forças As mesmas do padrão mais genérico Conexão Apresentação e Situação de Decisão.
Exemplo Em a conexão dos frameworks genéricos Graph e CapitalBudgeting, foi feita a correspondência conceitual das classes dos dois frameworks, associando- se a classe Graph com a classe CapitalBudgeting, e a classe Node com a classe Item.
Já na conexão dos frameworks genéricos IndentGraph e CapitalBudgeting, IndentTree é associada com a classe CapitalBudgeting e TreeNode é associada a Item.
Após a execução do processo de conexão e aplicação do padrão Conduto de Mensagens Semânticas, os objetos destas classes de apresentação são capazes de atuar como condutores de mensagens semânticas, que recebem de objetos de diálogo, para os objetos de decisão aos quais estão ligados, e, com o uso do padrão antecessor Apresentação Trata Mensagens Semânticas, os objetos de apresentação que recebem mensagens semânticas podem dar um tratamento adequado imediato, refletindo possíveis alterações de estado ocorridas nos objetos de decisão.&amp;&amp;&amp;
Vamos considerar um cenário onde um objeto Node, do framework Graph, e um objeto TreeNode, do framework IndentTree, estão ligados simultaneamente a um mesmo objeto Item.
A camada de diálogo envia uma mensagem para alteração da descrição do item, usando o objeto Node, que conduz esta mensagem, executando a operação SetLabel do objeto Item.
Supondo que a aparência gráfica dos objetos Node depende do estado dos objetos Item aos quais estão associados (ver Aparência Gráfica).
Se a mensagem SetLabel é enviada para um Item, alterando a sua descrição, o objeto Node que conduziu a mensagem pode imediatamente reconstruir sua aparência gráfica para refletir a nova descrição.
Porém, o outro objeto de decisão TreeNode, cuja aparência gráfica igualmente depende da descrição do objeto Item, tem também que reconstruir a sua aparência gráfica.
O problema é que o objeto TreeNode não recebeu e repassou a mensagem semântica que causou as alterações e, portanto, deve- se criar um meio do objeto TreeNode receber também a mensagem ou simplesmente reconhecer a alteração ocorrida e tomar as atitudes apropriadas.
Como projetar genericamente e adaptar as classes dos frameworks Graph, IndentTree e CapitalBudgeting para que, após o processo de conexão, objetos de apresentação que estão representando simultaneamente um mesmo objeto de decisão possam, após a condução de uma mensagem de modelagem ao objeto de decisão por um objeto de apresentação específico, refletirem possíveis alterações de estado ocorridas no objeto de decisão, por as quais os objetos de apresentação são influenciados?
Solução Use a solução para o problema encapsulada em Notificação de Modificação Semânticas Wb.
Contexto Você está usando Notificação de Mensagens Semânticas.
Problema O mesmo de Notificação de Mensagens Semânticas.
Forças Herdadas de Notificação de Mensagens Semânticas. Exemplo Veja a seção exemplo em Notificação de Mensagens Semânticas.
Solução A Figura 53, a Figura 54 e a Figura 55 mostram como a solução deve ser construída, através de diagramas de classes UML.
O problema descrito é tipicamente tratado através do uso do design pattern Observer.
Em a solução do padrão, é usado um design pattern que é uma variante de Observer, chamado de Event Notification, para que objetos de decisão notifiquem implicitamente as modificações para os objetos de apresentação.
O padrão Event Notification permite que objetos dependentes (Observer) sejam notificados de eventos ou alterações ocorridas num objeto observado (Subject), sem que o objeto observado conheça seus dependentes explicitamente.
Além disso, objetos dependentes podem escolher os tipos de notificações que querem receber dos objetos observados.
Objetos observados oferecem interfaces de conexão representando diferentes eventos e modificações de estado, através de objetos da classe StateChange.
Objetos dependentes conectam ou desconectam objetos EventStub nas interfaces das modificações, usando as operações Register e Unregister da classe StateChange, definindo as suas dependências sobre os objetos observados.
Objetos observados notificam alterações através das interfaces de objetos StateChange para objetos EventStub conectados, usando a operação Forward, os quais sabem quais operações dos observadores devem executar para tratar as alterações.
A Figura 51 mostra como o objeto observado (Subject) notifica o objeto observador (Observer) de uma maneira implícita, sem que Subject conheça Observer.
A mensagem de notificação flui através das conexões StateChange e EventStub, até chegar numa operação específica do objeto Observer que sabe tratar a modificação ou evento notificado.
Para que objetos de apresentação possam reconhecer e dar o tratamento adequado a diferentes mudanças de estado que possam ocorrer, as classes genéricas de um framework de situação de decisão devem executar o papel de Subject do design pattern Event Notification.
Cada classe de decisão deve ser projetada genericamente criando referências à classe StateChange para representar cada diferente mudança de estado que possa ocorrer e que possa exigir um tratamento diferenciado por os objetos de apresentação.
Estas referências StateChange atuam como interfaces para a conexão de objetos EventStub que recebem as notificações de mudanças de estado e conduzem estas notificações até objetos Observer.
Portanto, alguns pontos de estabilidade são previstos nas classes de decisão genéricas, que são as diferentes interfaces para notificação de modificações de estado.
Um ponto de variabilidade previsto está relacionado com os objetos Observer que devem receber notificações, o qual é preenchido através da conexão e desconexão de diversos objetos EventStub das interfaces StateChange.
As classes de apresentação genéricas (GenericPresentation) executam o papel de Observer do Event Notification.
Em a conexão de um framework de apresentação com um de situação de decisão, cada classe genérica é adaptada numa subclasse (ConnectedPresentation), que define uma operação para cada tipo de mudança de estado, oferecidas por cada classe de decisão que está conectada, de as quais os objetos de apresentação precisam ser notificados e dar um tratamento adequado.
Para que um objeto StateChange possa notificar os objetos de apresentação dependentes, um objeto de apresentação deve criar e personalizar objetos EventStub, os quais são registrados no objeto StateChange desejado e responsáveis por carregar as notificações até as operações definidas no objeto de apresentação para tratar as modificações.
A Figura 52 mostra conceitualmente como funciona a solução de notificações de modificações de estado dada por o design pattern Event Notification, em que, no problema tratado por Notificação de Modificações Semânticas Wb, objetos de apresentação recebem notificações dos objetos StateChange através de objetos EventStub, chegando até as operações adequadas para o reconhecimento da modificações ocorridas em objetos de decisão.
Em uma classe de decisão genérica, as operações que podem causar modificações de estado devem se encarregar de executar a operação Announce dos objetos StateChange, correspondentes às modificações ocorridas, para permitir que objetos de apresentação reconheçam as alterações e dêem o tratamento adequado na camada de apresentação.
Isto é demonstrado no fragmento de código da operação Operation1 da classe Decision1.
Este é outro ponto de estabilidade que deve ser previsto nas classes de decisão genéricas:
Executar Announce de um StateChange após ocorrer modificação de estado.
Cada classe genérica de apresentação (GenericPresentation) define pontos de variabilidade para criação, registro e retirada de objetos EventStub, representados por três operações abstratas (métodos hook) que devem ser sobrescritas no processo de conexão (ConnectedPresentation), que são CreateEventStubs, ConnectEventStubs e DisconnectEventStubs.
A operação CreateEventStubs deve ser implementada para instanciar e personalizar os objetos EventStub que serão registrados nos objetos StateChange oferecidos por os objetos de decisão.
Já ConnectEventStubs e DisconnectEventStubs devem ser implementadas para registrar e retirar objetos EventStub dos objetos StateChange que serão observados.
Retirar objetos EventStub significa não mais ser notificado das modificações de estado.
A solução deste padrão considera, para efeitos de ilustração, que já foram aplicados os padrões Ligação de Instâncias Wb, Conduto de Mensagens Wb e Apresentação Trata Mensagens Semânticas BB.
As outras soluções variantes dos problemas tratados por estes padrões poderiam ser utilizadas igualmente.
Considerações de projeto quando for usado Apresentação Trata Mensagens Semânticas Wb:
Como pré-condição deste padrão, você já aplicou o padrão Apresentação Trata Mensagens Semânticas.
Alguns detalhes da solução deste padrão dependem da solução variante de Apresentação Trata Mensagens Semânticas utilizada.
Se foi utilizado o padrão Apresentação Trata Mensagens Semânticas Wb, as operações que conduzem as mensagens semânticas para os objetos de decisão e que, ao mesmo tempo, dão o tratamento adequado a estas mensagens na camada de apresentação, devem desconectar os objetos EventStub antes de repassar as mensagens semânticas, conectando novamente após o repasse.
Isto é necessário porque, quando um objeto de apresentação recebe uma mensagem da camada de diálogo e repassa ao objeto de decisão, ele dá o tratamento imediatamente, e, portanto, não precisa mais ser notificado das alterações ocorridas, porque já foram tratadas.
Se isto não é feito, as alterações dos objetos de decisão seriam refletidas duas vezes por o objetos de apresentação que conduz as mensagens geradas na camada de diálogo.
A Figura 55 ilustra como isto deve ser feito, no fragmento de código de dsOperation1 em ConnectedPresentation.
Projeto para o uso de Apresentação Trata Mensagens Semânticas Wb Participantes GenericPresentation classe genérica de apresentação.
Define operação abstratas para a criação, conexão e desconexão de objetos EventStub em objetos StateChange, que subclasses de GenericPresentation devem definir.
ConnectedPresentation classe de apresentação adaptada para representar uma ou mais classes de decisão.
Implementa as operações para criação e personalização, conexão e desconexão de objetos EventStub (CreateEventStubs, Connect EventStubs, DisconnectEventStubs).
Mantém os objetos EventStub criados e configuras.
Define operações que vão receber as notificações de objetos StateChange, através de objetos EventStub, que devem dar o tratamento adequado às modificações ocorridas nos objetos de decisão associados (evnDoForDecision1 SC1, evnDoForDecision1 Decision1 Classe de um framework de situação de decisão representadas por a classe ConnectedPresentation.
Definem referências à classe StateChange para representar as diferentes mudanças de estado que podem ocorrer(_ evnSC1, evnSC2,· Oferece operações para conexão e desconexão de objetos EventStub em cada objeto StateChange(_ evnSC1Register,_ evnSC1Unregister,· Contém operações que provocam modificações de estado e que devem se encarregar de notificar as modificações executando o método Announce dos objetos StateChange correspondentes Client Representa conceitualmente o papel de uma classe cliente, da camada de diálogo, que envia uma mensagem semântica a um objeto de apresentação.&amp;&amp;&amp;
Solução do Exemplo A Figura 56, a Figura 57 e a Figura 58 mostram como a solução deve ser construída, através de diagramas de classes UML.
A classe genérica de decisão Item, que é uma subclasse de Subject, define interfaces StateChange para duas mudanças de estado específicas que podem ocorrer, relativas a alteração das propriedades Nature e Label, que são evnLabelChange e evnNatureChange.
A operação SetLabel é redefinida, executando agora a operação Annouce da interface StateChage_ evnLabel, após a alteração do valor do atributo_ Label.
Isto faz com que todos os objetos EventStub conectados a_ evnLabel sejam notificados da alteração ocorrida.
A classe de apresentação genérica Node é uma subclasse de Observer, e simplesmente define as operações abstratas para criação e configuração, conexão e desconexão de objetos EventStub (CreateEventStubs, ConnectEventStubs e DisconnectEventStubs).
A classe adaptada ItemNode, já existente e criada após o uso de Ligação de Objetos Wb, permite que objetos ItemNode sejam ligados a objetos Item, possui operações que delegam as mensagens semânticas aos objetos Item, graças a o uso de Conduto de Mensagens Semânticas Wb.
Nenhum tratamento é dado às mensagens semânticas por as operações que as conduzem até os objetos de decisão, segundo a aplicação de Apresentação Trata Mensagens Semânticas BB.
A classe adaptada ItemNode implementa as operações CreateEventStubs e ConnectEventStubs para a criação, configuração e conexão de objetos EventStub, que são_ evnStubNature e_ evnStubLabel, nas interfaces_ evnNatureChange e_ evnLabelChange de um objeto Item, para conduzirem as notificações de mudanças das propriedades Label e Nature de um Item até as operações responsáveis por o tratamento em ItemNode, que são evnDoForLabelChange e evnDoForNatureChange.
Essas operações simplesmente executam a operação Draw para que a aparência gráfica de um ItemNode seja reconstruída, refletindo as alterações ocorridas na descrição e/ ou na natureza de um Item.
Observer ObserverClass_ evnStubNature_ evnStubLabel Node ItemNode_ Item:
Item_ evnStubLabel:
EventStub_ evnStubNature:
EventStub Draw (w:
Window) SetItem (i:
Item) EventStub_ Observer:
ObserverClass\&gt; Apresentação Genérica Node e Classe de Apresentação Adaptada ItemNode O diagrama de colaborações de objetos abaixo mostra como os objetos de apresentação e de decisão se comunicam, a partir de o envio de uma mensagem SetLabel de um objeto de diálogo, representado por aClient, para um objeto ItemNode (aNode).
O objeto aNode conduz então diretamente a mensagem SetLabel ao objeto anItem ao qual está ligado.
Como resultado da alteração da descrição do item, o objeto anItem executa a operação Announce do objeto StateChange correspondende à mudança da propriedade Label.
O objeto StateChange notifica todos os EventStubs conectados, representados por Stub1 e Stub2.
Aqui, considera- se que a classe TreeNode também foi conectada à classe Item, gerando a classe TreeItemNode, do mesmo modo usado para conectar Node, apesar de isto não ser mostrado nos diagramas deste exemplo.
Então, o objeto Stub1, que foi configurado e conectado por aNode, conduz a notificação até a operação evnDoForLabelChange do objeto aNode, que foi quem repassou a mensagem SetLabel enviada por o objeto de diálogo.
A operação evnDoForLabelChange reflete a alteração ocorrida, chamando a operação Draw, que reconstrói a aparência gráfica.
O outro objeto de apresentação que está ligado simultaneamente ao objeto anItem também recebe a notificação da mudança, por o objeto Stub2, que conduz a notificação até a operação evnDoForLabelChange do objeto aTreeNode, que toma as mesmas atitudes para reconstrução da aparência gráfica.
Node Stub1: Event Stub aTreeNode:
Tree ItemNode Stub2: Event Stub anItem:
Item aStateChange:
Objetos de Apresentação e Decisão a Partir do Envio da Mensagem SetLabel Justificativa da Solução A solução não limita a reusabilidade das classes genéricas de decisão e apresentação.
As classes de decisão expõem as diferentes mudanças relevantes de estado que possam ocorrer, e que necessitam de um tratamento diferenciado por parte de os objetos de apresentação.
Se um objeto só quiser saber quando genericamente um objeto de decisão muda de estado, pode- se criar uma interface genérica que englobe todas as modificações.
As classes de decisão têm que oferecer interfaces StateChange para as diferentes mudanças de estado, e dinamicamente objetos EventStub são conectados por objetos de apresentação de diversos frameworks, sem que isso cause qualquer impacto.
A única coisa que objetos de decisão genéricos tem que fazer é notificar as alterações.
A camada de decisão continua independente da camada de apresentação, já que não são misturados aspectos independentes das camadas.
Objetos de decisão estão loose coupled com objeto de apresentação, em relação a o conhecimento dos objetos que devem ser notificados.
A adaptação das classes de apresentação consiste em conectar e desconectar instâncias EventStubs, oferecendo operações para o tratamento de cada diferente mudança.
É possível dinamicamente conectar e desconectar EventStubs, não causando interferências em outras instâncias de frameworks de apresentação e de situação de decisão.
Uma das vantagens de Event Notification sobre Observer é a capacidade de isolar as diferentes mudanças relevantes de estado que possam ocorrer, representadas por interfaces StateChange, o que permite a objetos de apresentação escolher as mudanças que desejam ser notificados.
Padrões Relacionados Normalmente, as atitudes tomadas por objetos de apresentação, quando são enviadas mensagens de modelagem, estão relacionadas com Aparência Gráfica.
Contexto Você está usando Comportamento Semântico.
Problema O problema endereçado por este padrão é uma especialização do problema de Comportamento Semântico.
Em o processo de conexão, conceitualmente as classes dos frameworks de apresentação genéricos são associadas às classes de um framework de situação de decisão.
Um dos aspectos destas associações é que, do ponto de vista da camada de diálogo, instanciar uma determinada classe de apresentação deve ser o mesmo que instanciar a classe de decisão associada.
Portanto, instâncias de frameworks de apresentação devem poder receber e repassar mensagens de inclusão de objetos de decisão, criando também objetos de apresentação correspondentes, para que a integridade entre as camadas permaneça.
Além disso, outras instâncias de frameworks de apresentação que representam simultaneamente o mesmo modelo de decisão, mas que não receberam a mensagem da camada de diálogo, devem poder reconhecer novos objetos de decisão e criar objetos de apresentação correspondentes para representar- los.
Como projetar genericamente e adaptar as classes dos frameworks de apresentação e situação de decisão para que, após o processo de conexão, instâncias de frameworks de apresentação possam delegar a instanciação e inclusão de objetos no modelo de decisão e criar objetos de apresentação correspondentes para representar- los?
Forças As mesmas do padrão mais genérico Conexão Apresentação e Situação de Decisão.
Exemplo Em a conexão dos frameworks genéricos Graph e CapitalBudgeting, é feita a correspondência conceitual das classes dos dois frameworks, associando- se a classe Graph com a classe CapitalBudgeting, e a classe Node com a classe Item.
Já na conexão dos frameworks genéricos IndentGraph e CapitalBudgeting, IndentTree é associada com a classe CapitalBudgeting e TreeNode é associada a Item.
Vamos considerar um cenário onde a classe CapitalBudgeting é responsável por a inclusão de objetos Item dentro de o modelo de decisão representado por o framework de situação de decisão CapitalBudgeting.
Então, após o processo de conexão dos frameworks, os objetos Graph e IndentTree que estão ligados a um objeto CapitalBudgeting devem possibilitar para a camada de diálogo a inclusão do elemento de decisão Item no modelo, sendo este elemento representado por a classe de decisão Item.
A camada de diálogo interage exclusivamente com objetos de apresentação, tratando- os como se fossem os próprios objetos de decisão que representam, apenas com algumas propriedades gráficas especiais.
Portanto, a camada de diálogo não solicita diretamente a inclusão de um objeto Item, mas sim a inclusão de um objeto Node ou de um objeto TreeNode, que são as representações visuais de um objeto Item.
A instanciação de uma destas classes de decisão deve causar a instanciação de Item.
Porém, como as instâncias dos frameworks devem estar integradas com o modelo de decisão, a inclusão de um objeto de decisão deve ser reconhecida por todas as instâncias, inclusive aquelas que não receberam uma mensagem de inclusão da camada de diálogo, para instanciar objetos de apresentação que vão representar- lo.
Como projetar genericamente e adaptar os frameworks Graph, IndentTree e CapitalBudgeting para que, após o processo de conexão, instâncias de Graph e IndentTree possam incluir objetos de decisão de CapitalBudgeting e criar objetos de apresentação correspondentes para representar- los?
Solução Use um dos padrões que encapsulam soluções variantes para o problema Inclusão de Objetos de Decisão Wb e Trader de Inclusão de Objetos (Np).
Solução de Exemplo Veja as soluções dos exemplos apresentados em Inclusão de Objetos de Decisão Wb e Trader de Inclusão de Objetos (Np).
Contexto Você está usando Inclusão de Objetos de Decisão.
Problema Como projetar genericamente e adaptar as classes dos frameworks de apresentação e situação de decisão para que, após o processo de conexão, instâncias de frameworks de apresentação possam delegar a instanciação e inclusão de objetos no modelo de decisão e criar objetos de apresentação correspondentes para representar- los?
Forças Herdadas de Inclusão de Objetos de Decisão. Exemplo Veja a seção exemplo em Inclusão de Objetos de Decisão.
Solução A Figura 59 e a Figura 60 mostram como a solução deve ser construída, através de um diagramas de classes UML.
Em primeiro lugar, projete os frameworks genéricos de apresentação e de situação de decisão, definindo uma classe que atua como uma &quot;fachada «de um framework, centralizando a manipulação de seus objetos, fornecendo meios de instanciar e incluir objetos no modelo de decisão.
Esta classe específica é geralmente chamada de classe facade, cujo nome é derivado da aplicação do design pattern Facade.
O design pattern Facade mostra como criar classes para atuarem como &quot;fachadas «de frameworks.
Em a associação de classes de apresentação e situação de decisão, as classes facade dos frameworks de apresentação e de situação de decisão dever ser associadas conceitualmente para possibilitar a instanciação e inclusão de objetos de decisão, como também dos objetos de apresentação correspondentes.
Como pré-requisito deste padrão, considera- se que já foi aplicado o padrão Ligação de Instâncias para permitir a ligação de objetos facade de apresentação e situação de decisão.
Com propósitos de ilustração, vai ser usada a solução variante encapsulada em Ligação de Instâncias Wb.
Aplique Conduto de Mensagens Semânticas Wb para permitir que mensagens de instanciação e inclusão de objetos de decisão sejam conduzidas de objetos facade de apresentação para objetos facade de decisão.
Após isto, aplique Apresentação Trata Mensagens Semânticas Wb para que um objeto facade que recebe uma mensagem de inclusão de um objeto de decisão possa instanciar objetos de apresentação correspondentes e ligar- los ao novo objeto de decisão.
Então, para que objetos facade de diferentes frameworks de apresentação ligados a um mesmo modelo de decisão reconheçam a instanciação de um objeto de decisão e tomem as atitudes necessárias para instanciação e ligação de objetos de apresentação correspondentes, use Notificação de Mensagens Semânticas.
Para que um objeto facade de apresentação possa ligar um novo objeto de apresentação a um objeto de decisão recém-criado, considera- se que foi usado Ligação de Instâncias Wb na conexão das classes de apresentação e de decisão destes objetos.
A classe facade genérica de decisão oferece operações para a instanciação de cada tipo de objeto de decisão e inclusão no modelo de decisão.
Ela deve oferecer uma interface StateChange para cada diferente tipo de objeto que pode ser instanciado e incluído no modelo de decisão.
Em a verdade, cada mudança de estado no modelo relacionada com inclusão de objeto é representada por um objeto da classe StateChangeNewObj, que é uma subclasse de StateChange.
Objetos StateChangeNewObj informam para as operações que recebem as notificações qual o novo objeto criado, disponível por a operação GetNewObj de StateChangeNewObj.
A operação CreateDecision1 mostra como é feita a notificação de inclusão de um objeto Decision1.
A classe facade genérica de apresentação (GenericPresentationFacade) simplesmente define operações abstratas para criação e configuração, conexão e desconexão de EventStubs sobre os objetos de decisão desejados, como propõe o padrão Notificação de Mensagens Semânticas.
A classe facade adaptada de apresentação (ConnectedPresentationFacade) define operações para conduzir as mensagens de inclusão até o objeto facade de decisão responsável por o seu processamento, de acordo com o padrão Apresentação Trata Mensagens Semânticas Wb.
Oferece também operações para instanciar e incluir objetos de apresentação para representar objetos de decisão.
As operações que instanciam objetos de apresentação são invocadas de duas maneiras.
A primeira é através das operações que conduzem as mensagens de inclusão até o objeto facade de inclusão, que executam imediatamente as operações de instanciação de objetos de apresentação correspondentes aos novos objetos de decisão, e que já fazem a ligação dos novos objetos de apresentação com os de decisão.
A outra maneira é através do sistema de notificação de inclusão de objetos de decisão promovido com o uso de Notificação de Modificações Semânticas, em que são definidas operações que recebem as notificações do objeto facade de decisão, através de objetos EventStub conectados às interfaces StateChangeNewObject expostas por o objeto facade de decisão.
Note que as operações que conduzem e tratam as mensagens de inclusão, como mostrado na implementação de dsCreateDecision1, desconectam os objetos EventStub antes de repassar as mensagens, para evitar que a inclusão de um objeto de decisão seja tratada duas vezes.
A solução considera que as classes de apresentação foram conectadas com as classes de decisão através de Ligação de Instâncias Wb, recebe o objeto de decisão ao qual cada objeto de apresentação deve ser ligado.
Estrutura Classe de Decisão Genérica Responsável por Instanciação e Inclusão de Objetos no Modelo de Decisão:
Subject StateChange Register (stub:
EventStub) Unregister (stub:
EventStub) DecisionFacade_ evnInstDecision1:
StateChangeNewObj_ evnInstDecision2:
StateChangeNewObj DSClass_ evnNewDecision1 evnNewDecision1Register (stub:
EventStubstub: EventStub) evnNewDecision2Register (stub:
EventStub) evnNewDecision2Unregister (stub:
EventStub)_ evnInstDecision1 $= new State ChangeNewObj\ Decision1\&gt;;
StateChangeNewObj_ newObj:
DSClass_ evnNewDecision2 SetNewObj (obj:
DSClass) instantiates instantiates Decision1 Decision2_ evnNewDecision1-&gt; SetNewObj (obj);
Classe de apresentação genérica e classe de apresentação adaptada para repassar mensagens de inclusão para um objeto de decisão responsável por a instanciação e inclusão de objetos no modelo de decisão, instanciando objetos de apresentação correspondentes e ligando- os:
ObserverClass Observer_ evnStubNewDecision1_ evnStubNewDecision2 EventStub_ Observer:
ObserverClass GenericPresentationFacade ConnectedPresentationFacade_ dsFacade:
DecisionFacade_ evnStubNewDecision1:
EventStub Client uses evnCreateForNewDecision1:
Presentation2_ dsFacade-\&gt; evnNewDecision1 Register;
Presentation1 uses/ instantiates Presentation2_ evnStubNewDecision1 $= new EventStub Presentation1 CreateForNewDecision1 Presentation1 pres $= new StateChangeNewObject scN $= (StateChangeNewObject) sc;
Participantes GenericPresentation Facade classe facade genérica de apresentação, que representa um framework de apresentação.
Define operação abstratas para a criação, conexão e desconexão de objetos EventStub nos objetos StateChangeNewObject, que devem ser sobrescritas por subclasses (ConnectedPresentationFacade) de acordo com o uso de Notificação de Modificações Semânticas.
ConnectedPresentation Facade classe facade de apresentação adaptada para representar uma classe facade de um framework de situação de decisão.
Define operações que delegam e dão tratamento imediato às mensagens de inclusão de objetos de decisão enviadas por a camada de diálogo, de acordo com o uso dos padrões Conduto de Mensagens Semânticas Wb e Apresentação Trata Mensagens Semânticas.
Define operações que promovem a instanciação de objetos de apresentação para cada tipo de objeto de decisão, de acordo com as associações conceituais feitas entre as classes de diferentes frameworks, como também ligam estes objetos.
Mantém os objetos EventStub criados e configurados para reconhecer inclusões de objetos de decisão, de acordo com Notificação de Modificações Semânticas.
Implementa as operações para criação e personalização, conexão e desconexão de objetos EventStub (CreateEventStubs, Connect EventStubs, DisconnectEventStubs), de acordo com Notificação de Modificações Semânticas.
Define operações que vão receber as notificações de inclusão de objetos de decisão, através de objetos EventStub, que devem dar instanciar e ligar objetos de apresentação correspondentes aos objetos de decisão criados, de acordo com Notificação de Modificações Semânticas.
Decision1 Classe de um framework de situação de decisão representadas por a classe ConnectedPresentation.
Definem operações para instanciação e inclusão de objetos de decisão no modelo de decisão, que notificam a criação de novos objetos através das interface StateChangeNewObject, criadas para a comunicação de instanciação de cada tipo de objeto de decisão, de acordo com Notificação de Modificações Semânticas.
Oferece operações para conexão e desconexão de objetos EventStub em cada objeto StateChangeNewObject (evnNewDecision1Register, Modificações Semânticas.
StateChangeNewObject Subclasse de StateChange, usada especialmente para a notificação de criação de novos objetos de decisão.
Deve ser parametrizada com a classe de decisão instanciada (DSClass).
Oferece operações para definição e recuperação da nova instância de decisão (SetNewObject, GetNewObject).
Client Representa conceitualmente o papel de uma classe cliente, da camada de diálogo, que envia uma mensagem de inclusão de elemento de decisão a um objeto de apresentação.
Solução do Exemplo A Figura 61 e a Figura 62 mostram como a solução deve ser construída, através de diagramas de classes UML.
A solução do exemplo trata apenas da conexão dos frameworks Graph e CapitalBudgeting.
Em primeiro lugar, é feita a associação conceitual entre a classe facade Graph com classe facade de decisão CapitalBudgeting, juntamente com a aplicação de Ligação de Instâncias Wb para permitir que objetos Graph sejam ligados a objetos CapitalBudgeting.
A classe facade genérica CapitalBudgeting (DecisionFacade) oferece operações para a criação de objetos Item e inclusão destes objetos no modelo de decisão, que são as duas versões de CreateAndAddItem.
Ela define uma interface StateChangeNewObject para a notificação de inclusão de objetos Item, que é_ evnNewItem.
A implementação da operação CreateAndAddItem mostra como a comunicação de inclusão de um Item é dada através da execução da operação Annouce de_ evnNewItem.
Isto é resultante do uso de Notificação de Modificações Semânticas.
Subject StateChange Register (stub:
EventStub) Unregister (stub:
EventStub) CapitalBudgeting_ Root:
Item DSClass CreateAndAddItem (fth:
Item): Item RemoveItem (i:
Item)_ evnNewItem $= new State ChangeNewObj\ Item\&gt;;_
evnNewItem StateChangeNewObj_ newObj:
DSClass SetNewObj (obj:
DSClass)_ evnNewItem-&gt; SetNewObj (obj);
Framework CapitalBudgeting A classe facade genérica de apresentação Graph (GenericPresentationFacade) simplesmente define as operações para criação e configuração, conexão e desconexão de EventStubs (CreateEventStubs, ConnectEventStubs, DisconnectEventStubs), de acordo com o uso de Notificação de Modificações Semânticas, e também operações para a criação e inclusão de objetos Node num grafo (AddNode, CreateAndAddNode).
A classe facade de apresentação adaptada CapitalBudgetingGraph (ConnectedPresentationFacade) conduz as mensagens de inclusão de Items originadas na camada de diálogo até o objeto Graph por a operação definida dsCreateAndAddItem.
Além de conduzir a mensagem, ela promove imediatamente a inclusão de um objeto ItemNode para representar o novo objeto Item, executando a operação CreateForItem.
A operação CreateForItem cria um novo objeto ItemNode para representar um objeto Item, ligando- os.
Como pré-requisito, considera- se que a classe ItemNode foi criada após o uso de Ligação de Instâncias Wb, após a associação das classes Node e Item, para permitir a ligação dos objetos destas classes.
ItemNode permite que seus objetos sejam ligados a objetos Item, e oferece uma operação de inicialização (construtor) que recebe um objeto Item ao qual deve um ItemNode deve ser ligado (ver Exemplo e Solução do Exemplo em Ligação de Instâncias Wb).
Isto é resultado do uso de Conduto de Mensagens Semânticas e Apresentação Trata Mensagens Semânticas.
A classe facade de apresentação adaptada CapitalBudgetingGraph implementa as operações para criação e configuração, conexão e desconexão de um objeto EventStub, que é_ evnStubNewItem na interface StateChangeNewObject_ evnNewItem de um objeto CapitalBudgeting, para receber as notificações de criação de objetos Item.
Cria também a operação evnCreateForNewItem para receber as notificações transportadas por_ evnStubNewItem, que simplesmente chama a operação CreateForItem que cria um objeto ItemNode e o liga ao novo objeto Item que foi notificado.
Adaptada do Framework Graph A Figura 63 mostra como objetos dos frameworks Graph, IndentTree e CapitalBudgeting se comunicam após o envio de uma mensagem de inclusão de um objeto Item para o objeto facade de apresentação IndentTree.
Apesar de não considerado o projeto do framework IndentTree nesta seção, para propósitos de ilustração do sistema de notificação considera- se aqui que as classes IndenTree e TreeNode foram adaptadas de maneira semelhante à utilizada para a adaptação das classes Graph e Node.
O cenário abaixo mostra um objeto de diálogo (Client) enviando a mensagem dsCreateAndAddItem para o objeto anIndentTree, que então delega o tratamento da mensagem para o objeto anCapitalBudegting.
O objeto anCapitalBudgeting cria e adiciona no modelo de decisão um novo objeto Item, e através do sistema de notificação de mensagens implementado através de objetos StateChangeNewObject e EventStub, comunica o objeto anGraph da nova instância de decisão, o qual toma as devidas providências para instanciar um objeto ItemNode e ligar- lo ao objeto Item.
O objeto anIndentTree não recebe a notificação porque na operação dsCreateAndAddItem ele desconecta o objeto EventStub da interface de notificação de inclusão de objetos de decisão, porque dentro de esta operação ele já faz a criação de um novo objeto ItemTreeNode para representar o novo Item.
Justificativa da Solução As justificativas da solução são praticamente derivadas das justificativas dos padrões Conduto de Mensagens Semânticas Wb, Apresentação Trata Mensagens Semânticas Wb e Notificação de Modificações Semânticas.
Especificamente da solução para o problema de inclusão de objetos de decisão, dois aspectos devem ser justificados.
O primeiro é o uso de classes facade para permitir que instâncias de frameworks de apresentação e de situação de decisão possam se comunicar.
Tanto num framework de apresentação como um de situação de decisão, é necessário que alguma classe tenha a responsabilidade de manipular os objetos dos frameworks, que são os elementos de um modelo de decisão ou os elementos visuais de uma estrutura de apresentação.
Em segundo lugar, a solução do padrão usa a solução variante Apresentação Trata Mensagens Semânticas Wb, ao invés de Apresentação Trata Mensagens BB, porque em muitas situações é importante que a camada de diálogo receba imediatamente o novo objeto de apresentação que ela solicitou para um objeto facade de apresentação, para por exemplo configurar suas propriedades gráficas.
Usando- se Apresentação Trata Mensagens BB, tudo é feito através da notificação de objetos incluídos para objetos facade de apresentação, e desta maneira a camada de diálogo não pode interagir imediatamente com o novo objeto.
Facade de Apresentação O objetivo desta dissertação foi demonstrar e analisar as contribuições que padrões podem trazer para o desenvolvimento de software, usando para isto a Arquitetura de Desenvolvimento de SADs baseado em Frameworks, apresentada no Capítulo 5, visando resolver alguns dos problemas encontrados originalmente no seu uso, identificados em e destacados na Seção 5.4 deste documento.
Para isto, foi proposta uma linguagem de padrões para guiar desenvolvedores usuários da Arquitetura no desenvolvimento e adaptação de frameworks, pensando apenas em aspectos de conexão dos diferentes tipos de frameworks sugeridos por a Arquitetura.
A linguagem produzida apresenta diversas propriedades, visando à resolução das limitações e problemas da Arquitetura.
Essas propriedades e suas contribuições foram destacadas no Capítulo 6.
Quanto a a resolução dos problemas das soluções de projeto dos frameworks sugeridas por a Arquitetura, os padrões da linguagem tentam fornecer melhores soluções para conexão dos frameworks, levando sempre em consideração as duas forças principais que atuam sobre estes problemas de conexão, que são reusabilidade e adaptabilidade.
Em outras palavras, frameworks devem ser genéricos e aplicáveis em diversas situações, e por outro lado, devem ser facilmente adaptáveis a contextos particulares.
Estas forças são normalmente contraditórias.
As atitudes tomadas que tentam dar melhores soluções para os problemas são:
Em relação a problemas de documentação encontrados no uso da arquitetura, a linguagem de padrões proposta, que endereça o problema mais genérico de conexão de frameworks, apresenta as seguintes propriedades e suas contribuições:
Separação de subproblemas independentes:
A linguagem divide o problema mais genérico de conexão de frameworks num grupo de subproblemas independentes, os quais estão interligados para resolver o problema geral endereçado por a linguagem, adotando uma abordagem do tipo &quot;dividir para conquistar «para facilitar o tratamento do problema mais genérico por parte de o desenvolvedor usuário da linguagem.
Abstração dos problemas de projeto relacionados com a conexão de frameworks:
Os problemas e soluções de projeto sugeridos em para o desenvolvimento de frameworks pensando em aspectos de conexão são, na maioria das vezes, descritos em termos concretos, demonstrados apenas nos estudos de caso desenvolvidos.
Os padrões da linguagem tentam abstrair estes problemas, capturando os seus elementos invariantes, para que possam ser utilizados igualmente para qualquer SAD, de diferentes domínios, que possa ser desenvolvido com o uso da Arquitetura.
Uso como guia passo a passo:
Os relacionamentos entre os padrões formam um grafo, onde os nós são os padrões e as arestas são os relacionamentos.
A linguagem permite que o problema mais genérico seja tratado passo a passo, começando no padrão inicial e mais genérico da linguagem, que conduz o usuário da linguagem a outros padrões, de acordo com os relacionamentos definidos.
O caminho que um usuário da linguagem (desenvolvedor) percorre ao navegar de um padrão para outro é uma das diversas combinações de soluções que podem ser criadas para resolver o problema mais genérico.
Para facilitar a navegação por os padrões da linguagem, são fornecidos grafos para padrões orientados a problema e a solução.
Uso como guia de referência:
Além de poder ser usada passo a passo, a linguagem pode ser usada como guia de referência.
O usuário pode procurar por um padrão que atenda um subproblema específico de conexão, sem ter que passar por todos os padrões da linguagem.
Esta busca é facilitada através do fornecimento de um índice dos padrões orientados a problema da linguagem.
Descrição das justificativas das soluções de projeto:
A solução de cada padrão descreve como resolve as forças que atuam sobre o problema, quais forças não são resolvidas e quais problemas são deixados em aberto ou mesmo gerados por as soluções escolhidas, que vão ser tratados por padrões subseqüentes da linguagem.
Como já foi destacado, é importante justificar as decisões de projeto descritas para que desenvolvedores as entendam e sintam- se à vontade para reutilizálas em seus próprios projetos.
Uso de um estudo de caso:
Para demonstrar situações concretas onde são encontrados os problemas e para o desenvolvimento de soluções para os problemas concretos, é utilizado um estudo de caso compartilhado por todos os padrões da linguagem, contemplando um pequeno aspecto da classe de problemas de Capital Budgeting.
O fornecimento de um estudo de caso é importante para o entendimento dos padrões, já que as pessoas têm uma certa dificuldade de lidar exclusivamente com abstrações.
Definição de diferentes tipos de padrões:
A linguagem divide padrões em orientados a problema, que encapsulam subproblemas invariantes do processo de conexão, e em orientados a solução, que representam soluções alternativas para os problemas representados por padrões orientados a problema.
A diferenciação de padrões orientados a problema e a solução é usada para auxiliar a utilização da linguagem, destacando os diferentes estes diferentes aspectos semânticos dos padrões da linguagem.
Em primeiro lugar, isto é importante quando existe mais de uma solução para um mesmo problema, que devem ser usadas em contextos ligeiramente distintos.
Com isto, são isoladas as partes invariantes de um padrão, que são o contexto geral, o problema e as forças que atuam sobre o problema, encapsulando- se as soluções distintas para o problema em padrões orientados a solução, os quais são especializações do padrão orientado a problema.
Em os padrões orientados a solução são descritos os aspectos de contexto ou contexto resultante que variam, juntamente com a solução proposta por cada um para o problema compartilhado.
Além de facilitar a utilização da linguagem, a existência de padrões orientados a problema e a solução facilita a evolução da linguagem, permitindo que novas soluções para um problema, representado por um padrão orientado a problema, possam ser introduzidas mais facilmente na linguagem.
Outra vantagem desta abordagem é que facilita a procura de padrões de acordo com o problema, através de índices de procura.
Tipagem de relacionamentos entre padrões:
A linguagem classifica os relacionamentos existentes entre os padrões em seis tipos, que podem ser leva a, é pré-requisito de, é completado por, usa, é especializado por e é conflitante com, e a estes tipos distintos de relacionamentos é dada uma notação especial nos grafos orientados a problema e a solução da linguagem.
Esta classificação têm o objetivo de facilitar para o usuário da linguagem a navegação entre os padrões, ajudando a destacar aspectos semânticos distintos existentes nestes relacionamentos, permitindo que o usuário que está manipulando os grafos da linguagem determinar quais padrões deve ou pode usar, de acordo com o contexto específico em que ele se encontra, percorrendo caminhos prováveis no uso passo a passo da linguagem.
Uso de formato estruturado de descrição:
Foi utilizado um formato mais estruturado para a descrição dos padrões, que é o resultado de uma mescla de vários formatos existentes na comunidade de padrões, esperando- se que ele auxilie a leitura e a procura de elementos específicos dos padrões.
Em este documento é apresentada uma porção da linguagem completa para desenvolvimento e conexão de frameworks de diferentes camadas, limitando- se às camadas de apresentação e situação de decisão da Arquitetura.
Espera- se com isto ilustrar as principais contribuições que o uso de padrões podem trazer para a resolução dos problemas da abordagem original da Arquitetura.
A linguagem de padrões apresentada não é um produto final, encontrando- se num estado embrionário, podendo ser considerada por alguns autores como um sistema de padrões ou como uma proto-linguagem composta de proto-padrões.
É importante salientar que a comunidade de software é bastante rígida na avaliação de linguagens de padrões publicadas, principalmente para não permitir que pessoas interpretem ou usem erradamente este conceito, classificando qualquer forma de documentação em padrões ou linguagens de padrões.
Para que padrões ou linguagens de padrões sejam reconhecidos, têm que submetidos à avaliação de grupos de especialistas em padrões nos chamados Patterns Writers Workshops, normalmente realizados dentro de conferências em padrões e linguagens de padrões, o que ainda não foi feito com a linguagem de padrões proposta.
Este trabalho apresenta algumas limitações e deixa alguns problemas em aberto, que poderão ser resolvidos em trabalhos futuros:
A linguagem deve passar por validações, sendo usada por outros desenvolvedores de SAD, encontrando possíveis limitações e inconsistências que deverão ser resolvidos, levando a consolidação de padrões existentes e incorporação de novos padrões à linguagem.
A identificação de problemas de conexão não foi exaustiva.
Muitos problemas ainda devem ser encontrados, podendo ser incorporados aos padrões já registrados na linguagem.
Um subproblema de conexão já identificado e que não recebeu tratamento na linguagem é o de validação de restrições semânticas.
Por exemplo, mensagens de alteração de estado de objetos de decisão, enviadas por a camada de diálogo através de objetos de apresentação, podem não ser aceitas por os objetos de decisão por motivos de restrição e validação do modelo de decisão, possivelmente gerando exceções ou mensagens de erro.
A camada de apresentação deve identificar quando mensagens não são aceitas por objetos de decisão ou quanto estes geram mensagens de erro ou exceções, para dar o tratamento adequado a estes eventos.
Em este trabalho foi considerada apenas uma porção da linguagem completa de conexão de frameworks, a qual tomou bastante tempo de elaboração e gerou um grande volume de material, como pode- se notar no tamanho do Capítulo 7.
Pretende-se em trabalhos futuros contemplar o problema complexo de conexão de frameworks considerando todas as camadas previstas por a Arquitetura, como também descrever toda a proposta da Arquitetura como uma linguagem de padrões, contendo padrões de processo, arquiteturais e também de projeto, estes últimos relacionados com a conexão de frameworks.
Como trabalho futuro, pretende-se desenvolver protótipos de SADs usando a Arquitetura e a linguagem de padrões desenvolvida, para demonstrar a sua viabilidade.
Provavelmente, um destes protótipos de SAD será desenvolvido a classe de problemas de Capital Budgeting, usada como estudo de caso da linguagem.
Melhores soluções podem ser encontradas para os problemas da linguagem, de acordo com experiências adquiridas durante sua utilização prática, visando principalmente dar maior ênfase à resolução da força adaptabilidade dos problemas.
Atualmente, pode- se dizer que as soluções de conexão não comprometem à reusabilidade dos frameworks, mas podem ser modificadas para facilitar ainda mais a adaptação dos frameworks, através de medidas como previsão de pontos de variabilidade, favorecer abordagem black-box para tornar o processo mais plug&amp; Como a linguagem encontra- se ainda num processo embrionário, devendo sofrer diversas alterações na sua estrutura e na descrição de seus padrões, de acordo com alguns especialistas da comunidade de padrões ela pode ser classificada como um sistema de padrões ou como uma proto-linguagem composta de proto-padrões, uma vez que não pode- se afirmar que ela é computacionalmente completa e que cobre todos os problemas do domínio que endereça, que neste trabalho é o problema complexo de conexão de frameworks.&amp;&amp;&amp;
A linguagem é neste momento mais voltada para o desenvolvedor abstractor do que ao elaborator, apesar de não serem feitas distinções sobre estes papéis dentro de a linguagem.
O desenvolvedor elaborator que possui frameworks desenvolvidos por abstractors, através do uso da linguagem, utiliza também a linguagem para conhecer o processo de adaptação de frameworks, como também as justificativas das decisões de projeto.
A questão a ser destacada aqui é que elaborators devem receber uma indicação dos abstractors sobre as soluções de projeto utilizadas, isto é, os padrões orientados a solução utilizados por os abstractors devem ser informados de alguma maneira para os elaborators, para que possam efetuar a adaptação dos frameworks corretamente.
