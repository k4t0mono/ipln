O avanço tecnológico atual do processo de construção de circuitos eletrônicos possibilita a integração de mais de um bilhão de componentes num único circuito integrado.
Um circuito integrado no estado da arte é um componente complexo constituído por numerosos módulos complexos conhecidos como núcleos de propriedade intelectual.
Circuitos integrados modernos contêm dezenas ou centenas de núcleos interconectados.
Cada vez mais a interconexão de núcleos se faz através de estruturas de comunicação complexas.
Uma forma de organizar estas arquiteturas é construir- las sob a forma de uma rede intrachip.
O uso de estruturas de comunicação total ou parcialmente regulares tende a aumentar a escalabilidade e o grau de paralelismo da comunicação em sistemas integrados complexos.
Uma das características mais importantes de uma rede intrachip é a sua topologia.
Este trabalho aborda a verificação e a prototipação da rede intrachip Hermes-TB.
Esta rede emprega topologia do tipo toro 2D bidirecional como forma de alcançar baixa latência e alta vazão a um custo de hardware reduzido.
A verificação do projeto da Hermes-TB foi obtida aqui através da execução da simulação com atrasos do projeto original, pois a proposta inicial da rede realizou a validação do projeto apenas através de simulação funcional.
Por outro lado a prototipação, aqui realizada sobre plataformas baseadas em FPGAs (do inglês, Field Programmable Gate Arrays) validou o projeto pela primeira vez em hardware.
A o final deste trabalho pôde- se então confirmar a viabilidade de uso da rede intrachip Hermes-TB em circuitos reais.
Palavras Chave: Redes intrachip, NoCs, topologia toro, toro 2 D, prototipação, FPGA.
O avanço atual da tecnologia de fabricação de circuitos integrados (CIs), popularmente conhecidos como chips, possibilita maior densidade de integração de componentes, viabilizando hoje a construção de um único Ci composto de mais de um bilhão de transistores.
Atualmente, o desenvolvimento destes CIs compreende a integração de múltiplos componentes, como processadores, blocos de memória e controladores de acesso a periféricos, num único chip, criando assim um sistema completo numa única pastilha.
Tais sistemas são conhecidos como SoCs, do amortização do custo de projeto e redução dos prazos, é importante que os componentes de um SoC sejam reutilizáveis.
Assim, o projeto de CIs deve se basear cada vez mais no reuso de componentes pré-projetados e melhorados a cada uso.
Esses componentes reutilizáveis são denominados núcleos IP (do inglês, Intellectual Property Cores, ou IP Cores ou IPs).
Um SoC contendo vários processadores CMPs (do inglês, Chip MultiProcessors), estes últimos definidos como CIs que contêm vários processadores idênticos.
Comercialmente, CMPs são hoje designados como dual core, quad- core, etc..
CMPs são resultados da tecnologia de integração em muito larga escala (do inglês, Very Large Scale Integration ou VLSI), que viabiliza agregar vários processadores programáveis num único Ci Internamente, tanto CMPs quanto MPSoCs fazem uso de arquiteturas de comunicação, podendo estas ser os tradicionais barramentos intrachip, ou estruturas mais complexas, denominadas redes consiste de um conjunto de condutores aos quais se conectam múltiplos núcleos e que possibilitam a transmissão de dados entre um par de núcleos de cada vez.&amp;&amp;&amp;
Barramentos têm como principal vantagem o baixo custo e a facilidade de expansão.
Como desvantagens, podem levar à eliminação ou redução do paralelismo potencial da comunicação entre dispositivos interligados, baixa escalabilidade, alto consumo de energia quando o número de núcleos cresce, e limitação da velocidade de comunicação proporcional ao aumento do número de núcleos.
O segundo tipo de arquitetura de comunicação (NoCs) consiste em geral de um conjunto de elementos roteadores interconectados por canais de comunicação ponto a ponto.
O conceito e suas variações são mais detalhados nos capítulos seguintes deste trabalho.
NoCs baseiam- se em conceitos oriundos das áreas de sistemas distribuídos, redes de computadores e processamento paralelo, adaptando estes conceitos aos requisitos de comunicação no interior de um SoC complexo.
O uso de NoCs como mecanismo de comunicação entre núcleos IP tem sido empregado por apresentar vantagens quando comparado a barramentos tradicionais, com características de melhora de parâmetros tais como:
Eficiência energética, confiabilidade, reusabilidade, comunicação não-bloqueante e escalabilidade de largura de banda.
O objetivo desse trabalho de pesquisa é a prototipação de uma NoC com topologia toro 2D proposta em trabalho anterior.
Outro trabalho relacionado desenvolvido no âmbito do Grupo de Pesquisa do Autor é o ambiente de teste NoCs denominado HardNoC (do inglês, Hardware Platform to Debug the Hermes NoC).
A HardNoC é utilizada neste trabalho sendo alterada para dar suporte à rede toro Hermes-TB.
Motivação Segundo estudos do ITRS (do inglês, International Technology Roadmap for Semiconductors), com o processo de integração de bilhões de transistores e centenas de IPs numa mesma pastilha de silício, é importante realizar pesquisas que possibilitem uma maior eficiência, baixo consumo de energia e velocidade na comunicação das informações dentro de chips.
Observa- se essa tendência, por exemplo, ao perceber iniciativas como a do fabricante TILERA desenvolvendo o Processador Tile64 com 64 núcleos processadores e a de pesquisadores da INTEL, construindo um chip contendo 80 núcleos processadores de ponto flutuante.
Ambos os projetos utilizam uma rede intrachip como arquitetura de comunicação entre núcleos processadores.
Ambos também demonstram preocupação com arquiteturas de comunicação com alto grau de paralelismo.
É evidente a necessidade de desenvolvimento de novas formas de transmitir as mensagem no interior de chips com maior eficiência, habilitando a vasta área de pesquisas em NoCs.
Em este cenário, este trabalho possibilita a evolução da pesquisa desenvolvida no Grupo de Apoio ao Projeto de Hardware (GAPH), onde se têm utilizado sobretudo a topologia malha 2D da NoC Hermes, proposta originalmente em.
A escolha por a topologia malha 2D está fundamentada na sua simplicidade de implementação em hardware.
Outra rede proposta por o GAPH foi a rede Mercury com topologia toro 2D.
Para a rede Hermes, existe o Ambiente Atlas, um software que permite gerar automaticamente redes Hermes e Mercury entre outras, a geração de tráfego e a visualização de estatísticas do tráfego.
O trabalho realizado por Scherer, por outro lado, propôs, projetou e implementou duas NoCs com topologia toro 2D (Hermes-TU e Hermes-TB), utilizando a infra-estrutura Hermes como base de desenvolvimento.
Além de expandir a estrutura de suporte ao projeto das duas NoCs, integrando as redes propostas ao ambiente Atlas, o mesmo trabalho apresentou uma avaliação comparativa destas contra a rede Hermes, nos aspectos de área, vazão e latência.
A rede Hermes-TB apresentou excelentes resultados de desempenho, superiores ao de redes Hermes com área equivalente.
De aí percebe- se a importância e a necessidade de dar continuidade, agregando valor aos projetos do GAPH.
Assim, este trabalho traz como contribuição a verificação e a prototipação da NoC Hermes-TB, através da expansão do ambiente HardNoC para dar suporte à Hermes-TB.
Objetivos Os objetivos estratégicos deste trabalho foram o domínio do processo de projeto e validação de redes intrachip em geral e de redes com topologia toro em particular, bem como do processo de prototipação de redes intrachip em FPGAs.
Como objetivos específicos foram estabelecidos os seguintes:
Estudo e análise do ambiente Testador HardNoC;
Adequações para integrar a rede Hermes-TB à HardNoC.
Simular funcionalmente e com atrasos o projeto da Hermes-TB, com a finalidade de obter resultados experimentais próximo de as características operacionais reais;
Validar a rede Hermes-TB, demonstrando sua viabilidade de implementação em hardware.
Contribuições A primeira contribuição foi a validação por simulação com atrasos do projeto da rede HermesTB.
A segunda e principal contribuição é disponibilizar um ambiente que permite prototipar instâncias da rede Hermes-TB em FPGAs.
Organização do Restante do Texto O restante do texto desta dissertação está organizado seis capítulos.
O Capítulo 2 introduz alguns conceitos básicos relacionados a redes intrachip em geral.
O Capítulo 3 mostra alguns trabalhos relacionados importantes para esta dissertação.
O Capítulo 4 aborda os experimentos necessários para demonstrar num ambiente de simulação, a funcionalidade da rede Hermes-TB.
O apresenta algumas conclusões do trabalho e sugere trabalhos futuros.
Este Capítulo apresenta os principais conceitos relacionados a redes intrachip.
Redes intrachip são arquiteturas de comunicação que normalmente apresentam alto grau de complexidade.
Para dominar a complexidade de projeto destas arquiteturas é necessário familiaridade com uma quantidade de conceitos fundamentais de redes de comunicação.
De entre estes conceitos, destacam- se as estratégias de chaveamento, os algoritmos de roteamento, os métodos de armazenamento temporário de mensagens, entre outros.
O objetivo deste Capítulo é introduzir um subconjunto destes conceitos, aqueles mais relevantes para o presente trabalho.
Roteamento: Classificações e Problemas Um primeiro conceito importante é o de algoritmo de roteamento, usado para definir o caminho que um pacote deve utilizar a partir de um nodo origem até um nodo destino.
Tais algoritmos podem ser classificados de acordo com diversos critérios.
A Figura 1 ilustra algumas das diferentes classificações de algoritmos de roteamento, baseado nos critérios que as definem.
O conjunto amplo, embora não-exaustivo, de critérios de classificação ilustrado na Figura 1 é descrito a seguir:
Quanto a o momento de realização do roteamento -- algoritmos podem ser classificados segundo este critério em estáticos, quando definidos em tempo de projeto da rede ou dinâmicos, quando definidos durante a operação do sistema.
Quanto a a quantidade de destinos das mensagens -- algoritmos podem ser classificados segundo este critério em unicast, quando existe apenas um destino ou multicast quando para pelo menos um pacote existam pelo menos dois destinos.
Um caso especial importante de algoritmo multicast são os algoritmos broadcast, onde um pacote gerado em algum ponto da rede é enviado para todos os demais pontos da rede.
Quanto a o local onde a decisão de roteamento é tomada -- algoritmos podem ser classificados segundo este critério em centralizado, quando um nodo define o caminho de todos os pacotes, ou origem quando o caminho ao longo de a rede é definido na origem do pacote, fora de a rede.
O último tipo são os algoritmos distribuídos, quando o caminho do pacote é definido a cada roteador por onde este passa no seu percurso ao destino.
Quanto a a forma de implementação -- algoritmos podem ser classificados segundo este critério em baseados em tabelas, quando o trajeto é definido a partir de consultas a tabelas que indicam o caminho ou parte deste, ou baseados em máquinas de estado, quando o roteamento é implementado usando um algoritmo.
Quanto a o processo de seleção do caminho -- algoritmos podem ser classificados segundo este critério em determinísticos quando, definidas origem e destino, o trajeto a ser realizado é sempre o mesmo.
Outro tipo são os algoritmos adaptativos, onde o caminho da origem ao destino é determinado em tempo de execução, determinado por as condições de tráfego, buscando o melhor caminho no instante do roteamento.
Quanto a a progressividade -- algoritmos podem ser classificados segundo este critério em progressivos, se o pacote sempre avança reservando canais ou regressivo, caso o mesmo possa liberar canais reservados previamente.
Quanto a a minimalidade -- algoritmos podem ser classificados segundo este critério em:
Mínimos, quando o nodo seguinte visitado por um pacote estiver sempre mais próximo de o destino que o nodo anterior;
Ou não mínimo, quando se permite o afastamento temporário de um pacote do seu destino.
Quanto a o número de caminhos -- algoritmos podem ser classificados segundo este critério em completos, quando todos os caminhos possíveis de serem usados por o pacote para ir de um nodo fonte a um nodo destino podem ser empregados por o algoritmo, ou parciais, quando a quantidade de caminhos entre um fonte e um destino é limitada por o algoritmo usado.
A seleção de um algoritmo de roteamento deve levar em consideração diferentes aspectos relacionados à estrutura de rede, do pacote, das interfaces de comunicação e do processo de transmissão de informação no interior da rede.
Um segundo conjunto de conceito em redes intrachip envolve a necessidade de evitar os fenômenos de deadlock, livelock e starvation.
Estes fenômenos podem ser definidos da seguinte maneira:
1) Deadlock é uma interdependência cíclica de comunicação que bloqueia indefinidamente alguns caminhos da infra-estrutura de comunicação.
2) Livelock é a situação em que a informação enviada nunca atinge o seu destino, circulando indefinidamente dentro de a rede.
3) Starvation é o adiamento por períodos arbitrariamente longos do direito de acesso a um dado recurso de comunicação por uma informação transitando na rede.
Métodos e Modos de Chaveamento e Algoritmos de Chaveamento A escolha de como se transfere pacotes entre origem e destino é o que determina o comportamento da lógica de chaveamento interna de cada roteador.
É possível discernir dois métodos de transferência, denominados chaveamento de circuito e chaveamento de pacotes, definidos a seguir.
Em o chaveamento de circuito (do inglês, circuit switching), o trajeto do nodo origem ao destino é inicialmente determinado e reservado, criando- se uma conexão (lógica e/ ou física) entre origem e destino.
Somente depois de estabelecida a conexão, inicia- se o envio da mensagem.
Em o chaveamento de pacotes (do inglês, packet switching), a mensagem é particionada ou agregada em pacotes, que são transmitidos sem uma determinação prévia do trajeto do nodo de origem ao destino.
Isto, porém implica a escolha de um de entre três modos de chaveamento que são:
Store- and-- forward:
Este modo se assume que cada pacote é armazenado inteiramente num roteador antes de seguir caminho para o próximo roteador;
virtual-cut-through: Em este modo, o roteador pode enviar um pacote adiante desde que o próximo roteador garanta a viabilidade de receber- lo completamente;
Wormhole: Em este modo, bastante usual em redes intrachip, pacotes são divididos em partes menores denominadas flits, que constituem a unidade fundamental de controle de fluxo na rede.
Cada flit pode ser enviado separadamente entre roteadores.
Tipicamente, o primeiro flit constitui- se de um cabeçalho que sucessivamente reserva canais por onde todos os demais flits do pacote seguirão.
Exemplos de Algoritmos de Roteamento Um algoritmo de roteamento simples e bem conhecido é denominado de roteamento XY.
Este é um algoritmo determinístico de operação mais simples em redes como malha 2D.
Ele é naturalmente livre de deadlock e livelock.
A vantagem deste algoritmo em redes com topologia malha é que ele garante a liberdade de deadlock a um baixo custo de implementação.
No entanto, ele restringe fortemente a forma de utilização dos recursos da rede.
Essa restrição provém do fato do pacote ter que percorrer totalmente as abscissas até chegar à coluna da ordenada em que se situa o nodo destino, seguindo então por caminhos verticais até o destino.
A Figura 2 ilustra o trajeto de um pacote de 4 flits que penetra uma rede 3x3 com topologia malha 2D por o roteador do canto inferior esquerdo e tem como destino o roteador superior central.
A Figura 3, por outro lado, apresenta e compara quatro algoritmos de roteamento, um determinístico, o XY explicado acima e três parcialmente adaptativos:
West--first, North-last e Negative-first.
Todos os algoritmos apresentados são mínimos, embora os adaptativos possuam versão não-mínima.
A adaptatividade mesmo parcial, pode reduzir o tempo total para a entrega de um pacote individual, pois em algumas situações ele pode mudar de direção, evitando condições de bloqueio.
As direções permitidas nestes algoritmos são as representadas por as linhas cheias, enquanto as linhas pontilhadas representam curvas não permitidas aos flits de um pacote.
Com base nessa explicação detalha- se a seguir os algoritmos adaptativos propostos originalmente por Glass e Ni em· Algoritmo West--First -- Em este algoritmo, ilustrado na Figura 3 (quadrante superior esquerdo), curvas para Oeste são proibidas.
De essa forma, o algoritmo West--First testa se Xd Xo, e em seguida roteia deterministicamente, de forma semelhante ao algoritmo XY.
Se Xd\&gt; Xo então este roteia de forma adaptativa nas direções Leste, Norte ou Sul.·
Algoritmo North-Last -- Em este algoritmo, ilustrado na Figura 3 (quadrante superior direito), não é permitido realizar curvas para Norte.
O algoritmo North-Last testa se Yd Yo, e em seguida roteia deterministicamente.
Se Yd Yo então este roteia de forma adaptativa nas direções Oeste, Leste, ou Sul.·
Algoritmo Negative--First -- Em este algoritmo, ilustrado na Figura 3 (quadrante inferior direito), não são permitidas curvas para direções negativas.
De essa forma, o algoritmo, fazendo uso da abreviatura XT para destino de X e Xs para origem de X, verifica se (XT Xs e YT Ys) ou (XT Xs and YT Ys), e então roteia deterministicamente como mostra a Figura no caminho 1 (endereço fonte (3,4) e endereço destino (0,7)) e no caminho 3 (endereço fonte (3,7) e endereço destino (6,5)).
Qualquer outra condição permite que o roteamento seja adaptativo.
Glass e Ni.
As curvas em linhas cheias representam uma curva permitida, e as linhas pontilhadas representam curvas proibidas.
Barras verticais no caminho entre roteadores representam bloqueios (devido, por exemplo, a outros pacotes usando o canal ou falhas na rede).
Controle de Fluxo Quando algum recurso está alocado para um pacote de forma a impedir a sua alocação a outro pacote, ocorre um bloqueio de recursos.
Em esta situação, é necessário que exista uma política determinando a melhor maneira de lidar com o pacote que não pode ser atendido.
De entre as políticas mais usadas destacam- se algumas:·
O descarte de pacotes que não têm acesso ao recurso necessário;·
O bloqueio e armazenamento de pacote;·
O desvio do caminho seguido por o pacote.
Essa determinação é a política do controle de fluxo, definindo quem aloca os canais e as filas no momento em que o pacote trafega na rede.
Ela também possibilita saber se o receptor está habilitado a receber dados ou não.
As estratégias de controle de fluxo utilizadas aqui pressupõem o bloqueio e armazenamento de pacotes.
Em este sentido duas estratégias são usadas para realizar o controle de fluxo:
Baseado em créditos e handshake:·
Controle de fluxo baseado em créditos -- não deixa que pacotes sejam descartados, pois uma transmissão entre roteadores só inicia após a verificação junto ao receptor que os dados serão recebidos.
Essa verificação é realizada da seguinte forma:
O receptor envia ao transmissor um sinal confirmando a existência de créditos que o último possui para envio dos dados.
Com esta informação, o transmissor envia dados somente quando existir crédito para o envio.
Ao longo de o processo de envio de dados do transmissor pode ou não ocorrer mudança no seu estado de créditos junto ao receptor, dependendo do espaço de armazenamento disponível no último.·
Controle de fluxo handshake -- o transmissor informa ao receptor a intenção de enviar um dado através de um sinal de solicitação.
O receptor recebendo o sinal de requisição verifica a existência de espaço para recebimento.
Existindo, o dado é lido e armazenado, e o receptor envia o sinal de reconhecimento de recepção (ack) ao transmissor.
Em a ausência desta possibilidade de recepção, o receptor pode enviar um sinal de não reconhecimento (nack), fazendo com que o roteador transmissor necessite retransmitir o dado até o recebimento de um ack.
Uma observação quanto a o uso do controle de fluxo handshake é a perda de desempenho, devido a o tempo que os dados ficam armazenados nas filas até receberem o sinal de ack, ou quando não existe espaço em fila já que se torna necessário reenviar o dado.
Arbitragem O fato de ocorrerem conflitos de requisições simultâneas requer a determinação de procedimentos para resolver, através do gerenciamento de acesso a recursos compartilhados, o uso dos componentes de rede por as mensagens que nesta trafegam.
Por exemplo, ao receber requisições de roteamento simultâneas, um elemento de arbitragem pode atribuir prioridade a portas de um roteador e com base nestas encaminha pacotes para uma unidade única de roteamento conforme esta escala de prioridades.
A a arbitragem está relacionado ao problema de starvation, que pode ser amenizado e até mesmo resolvido de acordo com o critério de arbitragem adotado.
Existem diversas políticas propostas, tais como prioridade estática, prioridade dinâmica, escalonamento por idade, FCFS (First Come First Served), LRS (Least Recently Served) e RR (Round-Robin).
As vantagens e inconvenientes de cada uma destas são amplamente discutidos na literatura.
Ver por exemplo para uma discussão mais detalhada.
Memorização Em as redes que utilizam chaveamento por pacotes do tipo wormhole, os roteadores devem armazenar os flits dos pacotes com destino às saídas que estejam indisponíveis, realizando o controle de fluxo para evitar a perda de dados.
Para oferecer essa característica é necessário usar um esquema de memorização temporária para armazenamento dos pacotes bloqueados no roteador.
Claramente não é possível disponibilizar uma capacidade de armazenamento infinita para garantir armazenamento na rede de todo e qualquer pacote em qualquer situação.
Assim um processo crítico é o de dimensionar os meios de armazenamento temporário dentro de os roteadores, de forma a reduzir tanto a perda de desempenho como o desperdício de área de silício.
Existem três opções básicas de memorização:·
Memorização na entrada -- a memorização temporária de dados na entrada pressupõe a existência de filas independentes em cada uma das portas de entrada do roteador.
As filas podem ser implementadas de várias formas, destacando- se as estratégias FIFO (First In First Out), SAFC (Statically Allocated, Fully Connected), SAMQ (Statically Allocated, MultiQueue) e DAMQ (Dynamically--Allocated, Multi-Queue).
Esta estratégia é usada, por exemplo, na NoC Hermes.·
Memorização na saída -- a memorização temporária de dados na saída implica a inserção de filas nas portas de saída do roteador.
O problema desta estratégia é que cada fila deve ser capaz de receber simultaneamente dados das N entradas, implicando que a fila de saída possua N portas de entrada ou que opere a uma velocidade N vezes maior do que as entradas.
O uso de armazenamento temporário de saída exige a implementação de um controle de fluxo entre a porta de entrada e de saída, aumentando assim a complexidade do roteador.·
Memorização centralizada compartilhada ­ a memorização centralizada compartilhada, denominado CBDA (Centrally Buffered, Dynamically Allocated), utiliza filas para armazenamento de pacotes de todas as portas de entrada do roteador.
O espaço de memória disponível a ser utilizado é dividido de forma dinâmica entre os pacotes de diferentes entradas.
Esta estratégia é usada, por exemplo, na NoC Mercury.
O armazenamento temporário centralizado compartilhado oferece uma melhor utilização de memória do que aquelas proporcionadas por as abordagens onde este espaço é prévia e estaticamente alocado a portas de entrada.
Segundo Zeferino, o CBDA deve oferecer no mínimo uma largura de banda igual à soma das larguras de banda de todas as portas, fazendo com que num roteador NxN, a fila possua 2N portas de acesso, de modo a permitir N acessos simultâneos de leitura e N acessos simultâneos de escrita.
Como desvantagem, pode- se citar um problema semelhante ao bloqueio HOL (do inglês, Head of Line).
Este tipo de bloqueio ocorre quando uma porta de saída está em uso por uma determinada porta de entrada e ao mesmo tempo outra porta de entrada está recebendo dados e também deseja utilizar essa mesma saída.
Em este caso, se o pacote que está alocando a porta de saída encontrar um bloqueio num roteador à frente no seu caminho, a segunda porta fica com seus dados bloqueados, talvez inutilmente.
Quando isso ocorre, as outras portas de comunicação são afetadas, pois uma fila eventualmente lotada acarreta a recusa ou o bloqueio adicional de dados, criando contenção.
Este problema pode ser evitado restringindo espaço alocado em cada fila para cada uma das portas de entrada.
A topologia de uma rede intrachip determina como são interligados os núcleos de um Ci.
Malha 2D e toro 2D são exemplos de topologias regulares largamente utilizadas em projetos de NoCs.
A topologia malha 2D é definida como aquela que distribui os nodos de forma simétrica num plano cartesiano.
Em esta topologia, cada nó da rede se liga a até quatro outros localizados nas direções dos pontos cardeais por os seus lados (Norte, Sul, Leste e Oeste).
Exceções são os nodos localizados na periferia da arquitetura.
Por exemplo, aqueles localizados nos lados superior, inferior, direito e esquerdo terão apenas três interligações com seus três vizinhos, e aqueles localizados nos cantos superiores (esquerdo e direito) e inferiores (esquerdo e direito) terão duas conexões com os seus dois vizinhos.
A topologia toro 2D pode ser obtida a partir de a malha 2 D, criando conexões entre os extremos da malha 2 D, de forma a criar anéis horizontais e verticais.
Os anéis numa topologia toro podem conduzir tráfego num ou nos dois sentidos, ao contrário de o que ocorre numa rede malha 2D regular, onde os enlaces sempre devem ser bidirecionais para permitir alcançabilidade plena entre nodos da rede.
Muitas das propostas de NoCs com topologia toro 2D pressupõe o uso de toros Este Capítulo restringe- se a revisar em detalhe as duas famílias de NoCs abordadas diretamente neste trabalho, a NoC Hermes, uma variação desta, a Hermes-VC e a NoC Hermes-TB.
Uma revisão do estado da arte em conceitos e propostas de NoCs pode ser encontrada em.
Em o caso específico de NoCs com topologia toro, o leitor pode usar o trabalho de Scherer como uma revisão do estado da arte neste tipo de NOCs.
A Rede Intrachip Hermes A rede Hermes é o projeto seminal de NoCs empreendido por o GAPH a partir de o trabalho inicial de Mello e Möller.
Sua primeira implementação foi sob a forma de uma rede com topologia malha 2 D, sem canais virtuais, com controle de fluxo do tipo handshake.
Com referência a o modelo de referência OSI, a Hermes original implementou apenas os níveis físico e de enlace.
Em o nível físico a rede realiza a transferência de bits através de um enlace formado por um conjunto de fios estruturados a partir de a definição do tipo de controle de fluxo a utilizar entre roteadores.
Em o nível de enlace ocorre a transmissão da mensagem, dividida conforme de acordo com os princípios ditados por a escolha do uso do modo de chaveamento wormhole em pacotes, e no interior deste em flits contendo a mensagem.
Em a rede Hermes, o tamanho do flit define a largura do barramento de dados entre roteadores.
Ou seja, os conceitos de flit e phit são equivalentes.
Entre roteadores, utiliza- se um controle de fluxo handshake tradicional e utilizam- se dois enlaces de comunicação unidirecionais para implementar um canal de comunicação bidirecional, conforme ilustrado na Figura 4 para uma instância da Hermes com flit de 8 bits.
A ferramenta Atlas permite ao usuário escolher o tamanho do flit (de entre um conjunto de valores possíveis) ao gerar instâncias desta NoC.
Os roteadores da NoC Hermes possuem entre três e cinco portas bidirecionais de comunicação uma lógica de arbitragem e uma lógica de controle que implementa o algoritmo de roteamento.
As cinco portas bidirecionais são denominadas Norte (N), Sul (S), Leste (E), Oeste (W) e Local (L), esta última usada para o roteador conectar- se ao núcleo a que está vinculado.
Note- se que assim a NoC possui uma memória de armazenamento temporária (buffer) de entrada associada, com uma estrutura de FIFO.
As portas N, S, E, e W conectam- se aos roteadores vizinhos localizados na direção designada por o nome da porta.
A lógica de arbitragem controla o acesso à lógica de roteamento por as portas de entrada.
A lógica de roteamento computa a porta de saída a partir de o algoritmo de roteamento, verifica a disponibilidade da porta de saída selecionada e realiza a conexão entre a porta de entrada e a de saída, caso isto seja possível.
Depois de terminada a transmissão da mensagem a lógica de controle desfaz a conexão entre portas de entrada e de saída.
Os pacotes da NoC Hermes têm a estrutura mostrada na Figura 5.
O primeiro e segundo flits do pacote formam o cabeçalho do pacote.
O restante deste, de tamanho variável contém os dados do pacote.
O primeiro flit dá o endereço do roteador destino, enquanto o segundo flit determina o tamanho do restante do pacote.
Cada roteador possui um endereço único na rede, definido por as suas coordenadas cartesianas posicionais na malha 2D que forma a rede.
Assim, o endereço de cada roteador é formado por um par (abscissa, ordenadas).
Uma relação importante existe entre o tamanho do flit e o tamanho máximo da rede.
Por exemplo, se o flit tiver tamanho de 8 bits significa que o tamanho máximo da rede será 16 x 16 roteadores, pois metade do primeiro flit especifica a abscissa do destino e a outra metade especifica a ordenada deste.
Em o nível de transporte ocorre o processo de envio do pacote do roteador origem ao roteador destino.
Em este nível se realiza o processo de divisão/ aglutinação de mensagem (ns) em pacotes (na origem) e a remontagem/ divisão dos pacotes em mensagens (no destino).
Maiores detalhes sobre a rede Hermes original podem ser encontrados nas referências e.
A porta Local na rede Hermes-VC tipicamente não possui canais virtuais.
Contudo a plataforma HardNoC que usa esta rede utiliza uma versão modificada, onde todos as portas possuem o mesmo número de canais virtuais.
Redes com Topologia Toro Uma rede com topologia toro é similar às redes com topologia malha, porém elas oferecem mais opções de caminhos, por a inclusão de enlaces interligando os roteadores nas extremidades da topologia.
Em redes toro 2 D, ligam- se os roteadores das extremidades superior aos roteadores da extremidade inferior correspondentes, e os roteadores das extremidades direita com os roteadores das extremidades esquerda correspondentes, usando canais denominados canais de retorno (do inglês wraparound).
Rede toro possuem como vantagem a redução à metade de diâmetro da rede.
Esse parâmetro determina o caminho mais curto entre nodos mais distantes numa rede.
O menor diâmetro de redes toro também propicia um aumento da largura de banda, bem como a potencial redução do tempo de armazenamento de pacotes nos buffers de entrada.
No entanto, canais de retorno necessitam fios tipicamente mais longos que os encontrados em redes com topologia malha.
Isto faz com que redes toro apresentem uma carga capacitiva tipicamente maior, gerando interferência eletromagnética potencialmente maior o que pode acarretar uma possível redução na freqüência de operação.
Redes com esta topologia foram propostas em diversos trabalhos anteriores, tais como, por exemplo, em, onde se realiza a prototipação de um SoC contendo uma rede que emprega algoritmo de roteamento baseado em chaveamento por pacotes usando um FPGA Virtex XCV800 da Xilinx.
Um problema importante nestas redes é que o algoritmo XY não é livre de deadlock em redes toro.
Assim, é necessário projetar outros algoritmos para uso nestas.
Como um exemplo de algoritmo de roteamento para rede toro, um trabalho seminal de Dally e Seitz propõe um algoritmo de roteamento livre de deadlock para roteamento de pacotes numa rede toro com chaveamento wormhole.
Este algoritmo foi implementado como parte de um Ci denominado &quot;The Torus Routing Chip», usado na implementação de máquinas paralelas com múltiplos processadores interconectados por uma rede toro 3D.
Além deste algoritmo, Dally e Towles propõem, no uso de uma topologia toro dobrado 2D usando canais virtuais com o mesmo algoritmo de roteamento para implementação de redes intrachip.
A topologia toro dobrado não difere estruturalmente de um toro convencional, ela apenas dita uma política de posicionamento relativo dos nodos da rede para uniformizar o comprimento das conexões entre roteadores, evitando as linhas mais longas na conexões wraparound, conforme ilustrado na Figura 7.
Segundo, a arquitetura toro necessita de pelo menos dois canais virtuais para ser livre de deadlock.
Em redes malha, não é necessário o uso de canais virtuais para tornar algoritmos determinísticos como XY livres de deadlock.
Para algoritmos totalmente adaptativos ou parcialmente adaptativos são necessários três canais virtuais em redes toro e pelo menos dois para redes malha.
Uma das métricas usadas para analisar uma rede é medir a latência, definida como o tempo que decorre entre o início da injeção de um cabeçalho de pacote na rede e a chegada do pacote completo no destino.
Em um sistema síncrono este tempo pode ser medido em ciclos de relógio.
Em duas topologias de rede foram comparadas, malha e toro.
Observou- se que o maior problema da topologia malha é seu diâmetro, que prejudica a latência máxima dos pacotes na rede.
A topologia toro habilita a redução da latência.
A comparação inclui gráficos de consumo de energia versus desempenho, consumo de energia versus latência e consumo de energia versus vazão.
Diferentes algoritmos de roteamento foram empregados nas comparações, mostrando conclusivamente a vantagem de se usar uma topologia toro em várias situações.
O roteamento nas redes toro é tipicamente mais complexo que em redes malha similares, pois a prevenção de deadlock é complicada por a existência dos canais de retorno.
Chi e Chen demonstram a implementação de um roteador para topologia malha ou toro.
Este roteador não possui filas de entrada e saída.
Os Autores sugerem uma técnica de roteamento inovadora que pode eliminar o problema de bloqueio de pacotes nas filas.
Esta técnica é denominada look-- ahead e consiste em definir o roteamento do pacote antes deste entrar no roteador seguinte.
Essa inovação propicia um melhor desempenho em relação a roteadores que utilizam filas do tipo FIFO.
O trabalho realizado por Pande et al.,
contextualiza o leitor a respeito de as diversas variáveis envolvidas na construção de uma NoC tendo como finalidade o uso destas em MPSoCs.
Os Autores salientam a necessidade de dar atenção a escolha da topologia a ser usada como forma de minimizar o fenômeno de atrasos em fios longos.
Demonstram que o atraso dos fios aumenta exponencialmente ou linearmente dependendo do uso de repetidores, que esse atraso pode exceder o limite de um ciclo de relógio.
Segundo os autores, aproximadamente 80% do atraso ocorre nos fios de interconexão, principalmente em fios longos.
Além disso, mostram gráficos e tabelas com valores de área, vazão, latência e consumo de energia comparando as NoCs seguintes:
CLICHÉ (Chip Level por Dally e Towles;
OCTAGON, proposta por Karim et al.
A contribuição maior do trabalho é o estabelecimento de métricas que habilitam uma análise quantitativa de diferentes topologias de NOCs.
A rede Intrachip Hermes-TB A rede Hermes-TB é uma NoC derivada da rede Hermes.
A diferença principal encontra- se na topologia utilizada.
A rede Hermes é uma rede com topologia malha 2D e a Hermes-TB emprega topologia Toro 2D.
A rede Hermes-TB possui, segundo os critérios da Figura 1 as seguintes características para seu algoritmo de roteamento:
Dinâmico, unicast, distribuído, baseado em máquinas de estado e adaptativo.
O seu algoritmo de roteamento é uma modificação do algoritmo West--First, adaptado a partir de a proposta original para redes malha de Glass e Ni.
Esta rede utiliza modo de chaveamento wormhole sem canais virtuais, controle de fluxo baseado em créditos e política de escalonamento round robin.
A estrutura do roteador Hermes-TB é similar ao roteador utilizado no projeto inicial da Hermes sem canal virtual, ilustrado na Figura 4.
Cada roteador possui exatamente cinco portas, usa filas de entrada, controle de fluxo baseado em créditos e não emprega canais virtuais.
O algoritmo de roteamento utilizado na rede Hermes-TB é uma adaptação do algoritmo westfirst de Glass e Ni.
Conforme a Figura 1 ele pode ser classificado como:
Dinâmico, quanto a o momento de realização do roteamento;
Unicast, quanto a a quantidade de destinos das mensagens;
Distribuído, quanto a o local onde a decisão de roteamento é tomada;
Baseado em máquinas de estado, quanto a a forma de implementação;
Adaptativo, quanto a o processo de seleção de caminhos;
Progressivo, quanto a a progressividade;
Não mínimo, quanto a a minimalidade;
Parcial, quanto a o número de caminhos empregado de entre todos disponíveis.
A adaptação consistiu em inserir modificações no comportamento do algoritmo quando o pacote chega a roteadores com valores máximos de coordenada (abscissas ou ordenadas).
Todo o texto desta Seção faz referência à Figura 8.
Os passos descritos representam a busca por a direção que se deve tomar após a análise do estado em que se encontra o pacote.
Para isto, observa- se a posição X/ Y do roteador corrente, tendo como pontos de referência:·
O valor de abscissa máximo, representado por Max, e o valor de ordenada máxima representado por Max (Y).·
O valor de abscissa do destino representado por D e o valor de ordenada do destino, representado por D (Y).·
O valor de abscissa do roteador corrente, representado por A e o valor de ordenada do roteador corrente, representado por A (Y).·
O valor médio de abscissa da rede representado por (Max (X)+ 1)/ 2 e o valor médio de ordenada, representado por (Max (Y)+ 1)/ 2.
West--first de Glass e Ni.
O algoritmo é dividido em quatro blocos principais:
O primeiro determina as distâncias em X e Y do pacote ao destino;
O segundo testa se o pacote chegou ao seu destino e age de acordo;
O terceiro serve, sobretudo se o pacote ingressou na rede no roteador corrente, ou seja, se o pacote acabou de ingressar na rede de comunicação;
O quarto é o caso geral, onde se testam várias situações do estado do pacote e age- se de acordo.
Antes de atribuir um pacote a uma porta de saída esta é testada para verificar se está livre (rotina free (ID_ porta).
Em o primeiro bloco, correspondendo à linha 1 da Figura 8, são atribuídos valores a Xos e Yos, que representam as distâncias ou deslocamentos (em inglês, offset) do pacote, do ponto em que este se encontra até o roteador destino.
Computa- se este valor por a diferença entre destino e origem.
Naturalmente, Xos é o valor de offset das abscissas enquanto Yos é o valor de offset das ordenadas.
O segundo bloco é formado por as linhas 2 e 3 da Figura 8.
Após a determinação de offset do pacote, busca- se saber se o destino foi alcançado.
Para tanto, é necessário apenas verificar se Xos $= Yos $= 0.
Se isto ocorrer, encaminha- se o pacote para a porta Local e o roteamento é concluído.
O terceiro bloco do algoritmo, nas linhas 4 a 17 da Figura 8, é executado se o pacote atingiu o roteador atual por a porta Local, ou seja, se o pacote acabou de entrar na rede.
Este bloco define a restrição básica para gerar do algoritmo livre de deadlock em redes toro, qual seja a de que os enlaces de wraparound somente podem ser utilizados como primeiro enlace de um caminho na rede.
O valor verdadeiro para a condição testada na linha 5 (In $= Local) indica que o pacote ingressou na rede no roteador corrente, pois a porta de entrada do mesmo (In) é a Local.
Em este caso, testam- se os quatro conjuntos de condições que podem levar a selecionar o uso de um enlace wraparound.
Dada a restrição básica citada, sabe- se que isto só pode acontecer a partir de um roteador nos limites externos da rede.
Os conjuntos de condições testadas e as ações correspondentes são:·
Linhas 6 e 7 ­ Se o pacote está na borda Leste da rede (A (X) $= Max (X)) e o destino do mesmo é nodo situado na borda Oeste (D (X) $= 0), ou pelo menos na metade esquerda da rede (D (X) toma- se o enlace wraparound por a porta Leste;·
Linhas 8 a 10 ­ Caso o conjunto de condições anteriores não se verifique, se o pacote está na borda.
Oeste da rede (A (X) $= 0) e o destino do mesmo é nodo situado na borda Leste.·
Linhas 11 a 13 ­ Caso os conjuntos de condições anteriores não se verifiquem, se o pacote está na borda Norte da rede (A (Y) $= Max (Y)) e o destino não está à esquerda do nodo atual (D (X)\&gt; $= A (X)) e este destino ou está na borda Sul (D (Y) $= 0), ou pelo menos na metade inferior da rede (D (Y) toma- se o enlace wraparound por a porta Norte;·
Linhas 14 a 16 ­ Caso os conjuntos de condições anteriores não se verifiquem, se o pacote está na borda Sul da rede (A (Y) $= 0) e o destino não está à esquerda do nodo atual (D (X)\&gt; $= A (X)) e este destino ou está na borda Norte (D (Y) $= Max (Y)), ou pelo menos na metade superior da rede (D (Y)\&gt; (Max (Y)+ 1)/ 2)), toma- se o enlace wraparound por a porta Sul2.
O quarto bloco do algoritmo consiste no caso geral.
Observe- se as linhas 18 e 19, que estabelecem a condição para rotear algum pacote durante a execução deste bloco.
Note- se que os conjuntos de condições testadas nas bordas Leste e Oeste não são totalmente simétricos.
Note- se que os quatro conjuntos de condições testadas não exaurem todas as possibilidades.
O roteamento neste bloco é feito para dois tipos de enlace:·
Os que ou não são o primeiro enlace no caminho do pacote ao longo de a rede, o que acontece quando o pacote não entra no roteador atual por a porta local (In\\&gt; Local);·
Os que são o primeiro enlace (In $= Local) mas não estão em nenhuma das bordas da rede (A (X)\&gt; 0 Ou A (X) E (A (Y)\&gt; 0 Ou A (Y) Se o teste acima der verdadeiro, isto garante que o pacote será roteado neste bloco.
Senão, o pacote deve ser reescalonado para roteamento, pois não há porta livre que ele possa usar no momento.
Caso a condição seja verdadeira e lembrando que se trata de um algoritmo do tipo West--first, as linhas 20 e 21 contêm o teste básico para rotear o pacote para Oeste, o que acontece sempre que o destino estiver à esquerda da posição atual do pacote.
Se isto não acontecer, alcança- se as linhas 22 a 36, que tentam rotear para alguma porta que não seja a Oeste.
A sequência de ações neste trecho garante certo grau de adaptatividade ao algoritmo e é a seguinte:·
Se o destino está no quadrante Sudeste em relação a a posição atual do pacote, tenta- se ir para Leste ou para Sul, nesta ordem, adaptativamente;·
Se o destino está no quadrante Nordeste em relação a a posição atual do pacote, tenta- se ir para Leste ou para Norte, nesta ordem, adaptativamente;·
Em as linhas 30 e 31, se o destino já está alinhado verticalmente com a posição atual do pacote e encontra- se à direita desta posição, tenta- se ir para Leste;·
Em as linhas 32 e 33, se o destino já está alinhado horizontalmente com a posição atual do pacote e encontra- se abaixo de esta posição, tenta- se ir para Sul;·
Em as linhas 34 e 35, se o destino já está alinhado horizontalmente com a posição atual do pacote e encontra- se acima de esta posição, tenta- se ir para Norte.
Caso nenhuma das tentativas de roteamento da lista acima consiga atribuir o pacote a uma porta livre, o pacote é reescalonado para novo roteamento (linha 36).
O algoritmo verifica o posicionamento do pacote.
Em seguida, deve selecionar uma das condições previstas.
Para exemplificar mostram- se quatro situações numa rede toro 5x5.
O primeiro exemplo implica computar o caminho tendo como origem a coordenada (4,2) e destino em.
Em este caso, a melhor opção é utilizar o canal de retorno, usando como critério a quantidade de passos necessária.
Usando o canal de retorno é necessário atravessar 2 segmentos (em inglês hops) da rede, enquanto na abordagem usando, por exemplo, uma malha 2 D, seriam 3 passos.
Analisando a execução passo a passo do algoritmo tem- se o seguinte.
Inicia- se verificando a posição inicial, depois se verifica a chegada ao destino.
Como se parte de uma porta local e estando sobre uma borda, a condição da linha 4 é atendida.
Por se estar na borda e o destino estar localizado antes do meio da matriz, a condição da linha 6 é atendida.
Assim, executa- se o passo que realiza a transposição, usando o canal de retorno por a porta Leste do extremo leste da matriz.
A o utilizar a porta Leste alcança- se a porta Oeste do outro extremo, alcançando assim o destino no passo seguinte.
O segundo exemplo consiste em computar o caminho tendo como origem a coordenada e como destino (2,4).
Em este caso, a melhor opção é utilizar o canal de retorno, usando como critério a quantidade de passos necessária.
Assim, usando o canal de retorno é necessário 1 passo enquanto na abordagem usando, por exemplo, uma malha 2 D, seriam 4 passos.
Analisando a execução passo a passo do algoritmo tem- se o seguinte.
Inicia- se verificando a posição inicial, depois se verifica a chegada ao destino.
Como se parte de uma porta local e se está na borda, a condição da linha 4 é atendida.
Por se estar na borda superior e o destino estar localizado na borda inferior, a condição da linha 11 é atendida.
Assim, executa- se o passo que realiza a transposição usando o canal de retorno por a porta Norte do extremo Norte da matriz.
A o utilizar a porta Norte alcança- se a porta Sul do outro extremo, chegando assim ao destino.
O terceiro exemplo consiste em computar o caminho tendo como origem a coordenada (2,2) e como destino, estando o caminho localizado entre (2,2) e (3,2) bloqueado.
Em este caso, a melhor opção é seguir de forma adaptativa na direção Sul.
Analisando a execução passo a passo do algoritmo tem- se o seguinte.
Inicia- se verificando a posição inicial, e depois a chegada ao destino.
Como se parte de uma porta local e se está no centro da matriz, a condição da linha 18 é atendida.
Por se estar no centro e o destino estar localizado na borda inferior, a linha 31 é atendida.
Assim, executa- se o passo que toma o caminho por a porta Sul e alcança a porta Norte do outro roteador, chegando ao destino no próximo passo.
O quarto exemplo consiste em executar o caminho tendo como origem a coordenada (2,2) e como destino a coordenada (4,2), estando o caminho localizado entre (2,2) e (2,3) bloqueado.
Em este caso, a melhor opção é seguir de forma adaptativa na direção Leste.
Analisando a execução passo a passo do algoritmo tem- se o seguinte.
Inicia- se verificando a posição inicial, depois verificando a chegada ao destino.
Como se parte de uma porta Local e se está no centro da matriz, a condição da linha 18 é atendida.
Por se estar no centro e o destino estar localizado na borda Leste, a linha 25 é atendida.
Assim, executa- se o passo que escolhe o caminho por a porta Leste e alcança a porta Oeste do outro roteador, chegando ao destino no próximo passo.
Hermes-VC, criando assim o ambiente HardNoC-TB.
Ambos ambientes foram exercitados por simulação.
Para garantir a operacionalidade da rede Hermes-TB realizou- se uma simulação com atrasos computados após a síntese do ambiente.
O ambiente de validação de NoCs HardNoC O diagrama de blocos do ambiente HardNoC é apresentado na Figura 10.
Este ambiente é composto de uma instância da rede Hermes-VC com topologia malha 2x3, onde roteadores possuem dois canais virtuais por porta.
Esta rede interconecta cinco IPs testadores de rede que podem ser programados através da NoC para gerar e receber tráfego e computar e informar algumas estatísticas sobre o tráfego recebido.
A interação com o ambiente é habilitada através do IP serial, usado para comunicação com um computador hospedeiro do tipo PC.
Através de um software especificamente desenvolvido, é possível programar os IPs testadores com padrões de tráfego, disparar o processo de geração de tráfegos programados para todos os Testadores e capturar de volta as estatísticas de tráfego resultantes do processo de execução.
Este ambiente de validação de NoCs em hardware foi especificamente desenvolvido para a rede Hermes-VC.
Ele pode ser facilmente adaptado para instâncias desta rede com número diferente de roteadores, mas não necessariamente é simples seu emprego com outras redes.
O protótipo inicial do ambiente, descrito em foi validado sobre uma plataforma de prototipação da empresa Digilent denominada XUP-V2PRO, contendo um FPGA Xilinx XC2 VP30 da família VirtexII-Pro.
Esta plataforma pode ser vista na Figura 45 do Capítulo 5.
A NoC do ambiente HardNoC pode ser gerada automaticamente a partir de o uso do ambiente Atlas.
Atlas é um ambiente desenvolvido no GAPH para habilitar a geração automatizada de descrições sintetizáveis de redes intrachip.
Além de esta capacidade, Atlas é útil para geração de tráfego, simulação de redes com injeção destes tráfegos e avaliação de desempenho das redes após uma simulação de tráfego.
Para geração do hardware e prototipação, empregaram- se as ferramentas comerciais ISE e Modelsim.
A primeira constitui um ambiente de síntese voltado para FPGAs da Xilinx.
A segunda é um ambiente de simulação disponibilizado para várias tecnologias, incluindo ASICs, FPGAs de vários fabricantes e diversas linguagens de descrição de hardware e validação, tais como VHDL, Verilog e SystemC.
Hermes-VC versus Hermes-TB e alterações no ambiente HardNoC A rede Hermes-TB possui algumas características que diferem da rede Hermes-VC como já descrito no Capítulo 3.
A rede Hermes-VC utiliza no ambiente HardNoC topologia malha 2D com dois canais virtuais, enquanto a Hermes-TB possui topologia toro e não possui canais virtuais.
Após uma análise das redes e suas interfaces externas, chegou- se a conclusão ser necessário, para adaptar o ambiente HardNoC para a Hermes-TB, trabalhar na geração e utilização dos sinais denominados lane_ tx e lane_ rx no IP Serial e nos IPs Testadores.
As interfaces em questão são ilustradas na Figura 11.
De a Figura 12 até a Figura 17 estão ilustradas as modificações conduzidas, que transformam o código VHDL do ambiente HardNoC no ambiente HardNoC-TB.
Em estas figuras, a coluna da esquerda contém o código da HardNoC enquanto a coluna direita contém o código HardNoC-TB.
Em a Figura 12 observa- se a mudança na biblioteca principal, alterando de HermesPackage para HermesTBPackage.
Essa alteração é necessária devido a o fato da biblioteca principal conter as informações de constantes, variáveis que são utilizadas nos diversos códigos que compõem o projeto.
As informações contidas nesse pacote compreendem constantes que permitem definir características dos roteadores como tamanho de flits, tipos específicos, subtipos e funções associadas.
Em a Figura 13 observa- se a mudança necessária para tratar a diferença entre a rede Hermes-VC que possui dois canais virtuais e a Hermes-TB que não possui canais virtuais.
A solução encontrada foi inutilizar a linha que possui os sinais Lane_ rx, Lane_ tx e mudar o tipo utilizado para os sinais credit_ o e credit_ i do tipo arrayNrot_ reglane para regNrot, que é definido no HermesTBPackage.
Para garantir um sinal de relógio que atinja todos os pontos do FPGA praticamente ao mesmo tempo, FPGAs dispões de módulos de controle de escorregamento de relógio.
No caso de os FPGAs da Xilinx, estes módulos são chamados gerenciadores digitais de relógio (em inglês, Digital Clock Manager ou DCM).
Em a Figura 14 o sinal de relógio descrito como ck e o sinal de reset foram colocados fora de o DCM, indicando a sua função fora de a especificação do mapa de portas.
Esta tarefa foi feita apenas para fins de validação funcional do sistema, sendo desfeita para a realização de simulação com atrasos.
A Figura 15 mostra as alterações iniciais do arquivo de descrição da NoC onde se adéqua a posição de ligação dos sinais de relógio que será utilizada na Hermes-TB.
Essa distribuição espacial pode ser vista nos desenho da topologia, bem como na planta baixa obtida após a síntese.
Esta alteração modifica a implementação original, pois aquela não estava de acordo com a documentação do projeto.
A implementação inverte, em relação a a documentação a orientação dos roteadores (no exemplo da Figura, mostra- se a inserção dos roteadores de coordenadas XY $= 20 e XY $= 21 e a remoção dos roteadores XY $= 02 e XY $= 12.
Em a Figura 16 nota- se as alterações que foram necessárias no nível de instanciação da NoC Hermes-TB para eliminar o uso de canais virtuais da plataforma HardNoC original, por a eliminação do sinais lane_ rxLocal e lane_ txLocal, mudança esta testada com sucesso na simulação.
A Figura 17 mostra a mudança mais significativa, qual seja a maneira escolhida de resolver o problema da rede original possuir dois canais virtuais e da rede Hermes-TB não fazer uso desses canais.
Mostram- se aqui apenas as alterações realizadas no IP Serial, existindo mudanças similares em todos os IPs e nos próprios roteadores.
Em um primeiro momento, observou- se a linha que continha o sinal denominado lane_ tx, depois no sinal credit_ i, que representa o sinal de crédito para o primeiro canal virtual.
Notou- se ser necessário realizar a ligação do mesmo de forma explícita com o sinal credit_ o do Roteador 00, enquanto que o sinal credit_ i (L2), desnecessário na Hermes Tb, foi aterrado.
Após as alterações esboçadas nesta Seção, obteve- se um versão da HardNoC-TB, pronta para simulação funcional.
Simulação da HardNoC-TB Com intuito de validar a rede Hermes-TB num ambiente funcional, além de as modificações realizadas na NoC, utilizam- se os IPs desenvolvido por o GAPH.
A idéia é inicialmente gerar simulações sem levar em conta atrasos nos fios, depois realizar simulações com atraso, buscando uma situação mais próxima da realidade, para só então partir- se para a prototipação da HardNoC-TB.
Os experimentos deste Capítulo na realidade validam o roteamento da rede Hermes-TB, testando canais de retorno, e enviando pacotes aos 5 IPs Testadores a partir de o IP Serial.
Quando se trabalha com simuladores como o Modelsim é possível utilizar scripts com o objetivo de agilizar o processo de simulação, visto que este requer diversos passos.
A Figura 18 mostra os principais blocos que compõem o script usado para realizar a simulação sem atraso:·
Definição da biblioteca de trabalho utilizada no projeto;·
Mapeamento de elementos necessários ao projeto, como a área local, bem como bibliotecas importantes no processo de simulação.
Em este exemplo existe a chamada de duas bibliotecas.
A primeira, de nome UNISIM é utilizada em simulação funcional (sem atraso) de componentes específicos de FPGAs da Xilinx.
No caso de a simulação de temporização (com atrasos) deve- se usar a SIMPRIM.
Esta contém a descrição Vital, contendo informações precisas de atraso dos componentes Xilinx (marcado com 2 na Figura);·
Comandos de compilação dos fontes VHDL, descrevendo os elementos que compõem o projeto e que serão utilizados no processo de simulação (marcado com 3 na Figura);·
Comando que realiza o disparo da simulação (marcado com 4 na Figura);·
Comando do realiza o disparo de outro script.
Em este caso, dispara- se a execução de um script que possui sobretudo o detalhamento dos sinais a serem visualizados.
O comando run indica o tempo da simulação.
A o executar este o Modelsim realiza a simulação e gera as formas de onda definidas no script W_ Routers_ IPs.
De o (marcado com 5 na Figura).
A forma usada para transmitir os dados através da rede no ambiente HardNoC é determinada em.
O funcionamento dos pacotes dentro de a rede é realizado da seguinte forma.
Existem algumas formas do pacote trafegar por o ambiente HardNoC, de acordo com a posição que ele se encontra.
Descreve- se a seguir os formatos de pacote usados nos diferentes pontos do ambiente.
Os pacotes gerados por o software denominado SerialSoftware e enviados de um PC hospedeiro para a plataforma HardNoC têm a estrutura ilustrada na Figura 19.
Existem três tipos de mensagens oriundas do hospedeiro para o IP Serial.
A primeira é o comando de leitura.
Em esta, o primeiro dado contém o código do comando;
O segundo dado indica o IP destino do pacote (de onde se quer ler dados), o terceiro especifica o número de palavras a ser lido do IP, e o quarto e quinto indicam o endereço inicial de leitura dos dados no IP.
O segundo tipo de mensagem é o comando de escrita representada no primeiro dado por o numero 1.
O segundo, o terceiro, o quarto e o quinto dados têm interpretação similar as do comando de leitura.
De o sexto ao nono dados está o dado a ser escrito (32 bits).
O último tipo de mensagem é um comando de inicialização do processo de geração de tráfego e armazenamento de estatísticas nos IPs testadores.
Este comando é de apenas um byte, sem nenhuma outra informação.
Com o auxílio destes três comandos cria- se o fluxo de dados do mundo exterior para a HardNoC.
Cada um dos pacotes chega ao IP Serial onde é decodificado, gerando pacotes no formato da rede ou outras ações implícitas no pacote proveniente do hospedeiro.
O IP serial executa a formatação dos dados de e para a NoC usando dois comandos, conforme descrito na Figura 20.
Os IPs testadores também podem ler e escrever dados em outros IPs da NoC e usam estes mesmos formatos.
O primeiro destes comandos é de leitura.
Em ele, o primeiro flit contém o endereço de destino, o segundo flit possui o tamanho da mensagem (sempre igual a 3), o terceiro flit especifica o endereço de origem (no caso, será o endereço do IP que envia a mensagem), o quarto flit contém o código 0, que indica tratar- se de comando de leitura e o quinto flit contém o endereço do dado a ser lido.
O segundo comando é o comando de escrita onde o primeiro flit contém o endereço de destino, o segundo o tamanho da mensagem, o terceiro especifica o endereço de origem (no caso, será o endereço do IP que envia a mensagem), o quarto contém o identificador de comando de escrita (1), o quinto possui o endereço de escrita e o sexto possui o dado a ser escrito.
Para cada um dos casos, o pacote é recebido e tratado conforme as máquinas de estado do IP que recebe o pacote, podendo este ser o IP Serial ou um dos IP Testadores.
Obviamente, os roteadores da rede manipulam este tipo de pacotes, que é compatível com o formato de pacote da Hermes-TB.
A Figura 21 ilustra o diagrama de forma em termos gerais, contendo todos os principais objetos necessários aos experimentos de validação da HardNoC-TB.
Em este diagrama existe uma divisão dos sinais em 4 grupos distintos:
Os sinais de clock e reset, os sinais do IP serial, os sinais de roteadores, e os sinais de IPs Testadores.
Em o primeiro grupo, existem os sinais de relógio e de reset como uma referência aos ciclos necessários para realizar uma operação.
Em o segundo grupo existem sinais do IP 00 que é o IP serial:
Rxd, txd, data in e data out..
Estes sinais são importantes nos experimentos porque a partir de eles comprova- se o funcionamento da comunicação com o hospedeiro, observação feita da seguinte maneira:
O sinal entra txd indicam o momento em que ocorre a recepção e transmissão, respectivamente.
O terceiro grupo é composto de linhas com a representação dos roteadores com seus respectivos sinais de entrada e saída.
Em os experimentos individuais esses sinais serão tratados em mais detalhes.
O quarto grupo é composto de sinais de entrada e saída dos IPs testadores.
Utilizam- se aqui figuras para ilustrar a operação dos experimentos, indicando os caminhos produzidos por a aplicação do algoritmo de roteamento.
A Figura 22 mostra o detalhamento da estrutura interna e o esboço das interfaces dos diferentes módulos que compõem a HardNoC-TB.
Os módulos são:·
O roteador e suas portas de entrada e saída (a);·
A interface de IP Testador com a porta Local de seu Roteador (b);
Testador; (c) Detalhe de conexão da porta local dos roteadores com os seus respectivos sinais de ligação ao IP Serial.
Para realizar a simulação foi usado o software Modelsim, e escrito um testbench para a NoC.
O arquivo utilizado nos experimentos denomina- se HardNoC_ TB.
Vhd. O componente denominado IP Serial é responsável por o recebimento dos comandos por o hospedeiro e por a decodificação dos mesmos e posterior envio destes a algum componente denominado IP Testador.
Assim, o testbench possui capacidade de ler arquivos contendo comandos, com o objetivo de simular a operação do hospedeiro de comunicando com o IP Serial.
Estes comandos são armazenados num arquivo de entrada denominado in_ tb.
Txt, declarado conforme ilustra o trecho VHDL do testbench da Figura 23 e com um conteúdo exemplificado na Figura 24.
O testbench é responsável por a produção e leitura de todos os estímulos necessários para a execução da simulação.
Local do Roteador 00.
Em esta Figura observa- se apenas o final de cada pacote, identificado por o valor de seu último flit.
O último dos pacotes apresenta um problema derivado da visualização com Modelsim, visto que no lugar do dado 0004 surge um valor 0000.
A o executar uma ampliação na forma de onda percebe- se que a simulação opera de forma correta, conforme esperado.
Este problema se repete em múltiplas figuras similares a seguir.
DataOut). O valor do último pacote não aparece correto, mas uma ampliação desta onda revela o comportamento esperado.
O hardware do IP Serial monta os pacotes no formato esperado por a Hermes-TB.
Segundo, cada pacote que circula na rede da HardNoC (e da mesma forma da HardNoC-TB) especifica uma de entre quatro possíveis operações:
Leitura, Escrita, Retorno de Leitura e Dado.
A estrutura dos pacotes para efetuar estas operações é detalhada na Figura 26.
Vale a pena salientar que os dois primeiros tipos de pacote são uma repetição da Figura 20.
A forma de onda da Figura 27 demonstra como se realiza o processo de envio do primeiro pacote (um comando de escrita), que tem no primeiro flit o valor 0021, que corresponde ao destino deste pacote;
Em o segundo flit, tem- se o tamanho que já é pré-definido conforme o padrão na Figura 26.
Em o terceiro flit aparece o endereço de origem.
Em esse caso ele se origina do IP Serial denominado IP valor 0000;
em o sexto flit aparece o dado que corresponde à carga útil do pacote.
Observe- se na Figura 28 o quinto flit, que identifica a posição deste pacote na mensagem.
Como ele é o penúltimo de oito, este campo vale 0006.
Em o sexto flit aparece o dado que representa a carga útil do pacote.
Para ilustrar a validação funcional e a operação do modelo VHDL da HardNoC-TB é necessário observar o algoritmo de roteamento da HardNoC-TB 3X2.
Em este experimento, os pacotes têm como origem o IP Serial e como destino o IP Testador 21.
Inicialmente, a seqüência de pacotes é enviada por o usuário a partir de o hospedeiro por a porta serial, nesse caso através do arquivo de extensão txt que simula a alimentação de dados.
Depois, os pacotes provenientes do hospedeiro são empacotados no formato da NoC Hermes-TB por o IP Serial e enviados à rede.
Em este meio são encaminhados aos roteadores e por os canais Norte, Sul, Leste e Oeste são repassados a outros roteadores até a chegada ao destino onde serão encaminhados à porta Local.
Para garantir facilidade de referência, as formas de onda utilizadas são todas semelhantes entre si, mudando os objetos, mas mantendo a estrutura geral de sinais apresentada na Figura 21, conforme o caminho a ser utilizado.
Em o Experimento 2, cujo fluxo é ilustrado na Figura 29, o pacote deve chegar ao IP Serial, denominado IP 00, por a sua porta In, conectada ao hospedeiro, sendo encaminhado em direção a a porta Out do mesmo IP, a partir de onde atinge o Roteador 00 por a porta Local.
Em o roteador será encaminhado para a porta Oeste, em direção a a porta Leste do Roteador 20, por o canal wraparound.
Chegando ao roteador 20, será encaminhado à porta Norte do mesmo, sendo recebido por a porta Sul do roteador 21, onde, por ser este o roteador conectado ao IP Testador destino a mensagem segue para a porta Local do mesmo.
A Figura 30 detalha a simulação deste processo.·
1 ­ O IP Serial Recebe a sequência de oito dados para transmitir a outro IP da NoC.
Os dados de cada pacote (carga útil) são, em hexadecimal:
1203, 1601, 2009, 0377, 0001, 0002, 0003, 0004.
Cada um dos dados gera um pacote para a rede, que penetram esta por o Roteador 00, via porta de entrada 4 (Local) deste.
Em este roteador, o algoritmo de roteamento é executado, a tabela de chaveamento é atualizada, realizando a ligação entre a porta Local do Roteador 00 com a porta de saída 1 (Oeste) do mesmo Roteador, conforme se pode acompanhar na forma de onda da Figura 30 com a ligação da porta de entrada 4 (Local) à porta de saída 1 (Oeste) no Roteador 00.·
2 ­ A porta de saída Oeste do Roteador 00 recebe os pacotes da porta de entrada Local do mesmo Roteador.
O Roteador 00 interage com a porta de entrada Leste do Roteador 20 conforme a Figura 30, onde se nota a ligação da porta de saída Oeste do Roteador 00 com a porta de entrada Leste do Roteador 20.·
3 ­ O Roteador 20 recebe o pacote oriundo da porta de saída Oeste do Roteador 00.
O algoritmo de roteamento é executado, a tabela de chaveamento é atualizada, realizando a ligação entre a porta de entrada 0 (Leste) e a porta de saída 2 (Norte) do mesmo Roteador.·
4 ­ A porta de saída Norte do Roteador 20 recebe o pacote oriundo da sua porta de entrada Leste.
O Roteador 20 interage com a porta de entrada Sul do Roteador 21 conforme a Figura 30, onde se nota a ligação da porta de saída 2 (Norte) do Roteador 20 com a porta de entrada 3 (Sul) do Roteador 21.·
5 ­ A porta de entrada 3 (Sul) do Roteador 21 recebe os pacotes oriundos da porta Norte do Roteador 20.
O algoritmo de roteamento é executado e a tabela de chaveamento é atualizada, realizando a ligação entre a porta de entrada 3 (Sul) do Roteador 21 e a porta de saída 4 (Local) do mesmo Roteador, como se pode visualizar na forma de onda da Figura 30.·
6 ­ A porta Local do Roteador 21 recebe o pacote oriundo da porta Sul do mesmo roteador.
Em esse instante, um a um os flits saem da rede e seguem para a memória do IP Testador 21.
O IP Testador fica aguardando o sinal de Start para após isto começar a operar, injetando o padrão de tráfego programado em si para o interior da NOC.
Em este experimento, um pacote deve chegar ao IP 00, por a porta In, seguindo em direção a porta out, do mesmo IP, sendo direcionado ao Roteador 00 por a porta Local.
Este roteador encaminhará o pacote para a porta Sul, em direção a a porta Norte do Roteador 01.
Chegando por o canal de retorno a este roteador o pacote será re-encaminhado à porta Leste do mesmo sendo recebido por a porta Oeste do Roteador 11.
Uma vez que este é o destino, o pacote segue por a porta local do mesmo.
Esta operação é detalhada em simulação no diagrama de formas de onda da Figura 32.
Observa- se que os passos realizados são numerados da mesma forma no desenho e na forma de onda.
O detalhamento dos passos é o seguinte:·
1 ­ Recebe- se a seqüência de oito pacotes contendo as seguintes cargas úteis (em hexadecimal):
1203, 1975, 0505, 1977, 0005, 0006, 0007, 0008.
O algoritmo de roteamento é executado, a tabela de chaveamento é atualizada, realizando a ligação entre a porta de entrada 4 (Local) do Roteador 00 com a porta de saída 3 (Sul) do mesmo roteador.·
2 ­ Em o Roteador 00, a porta de saída Sul recebe o pacote da porta de entrada Local.
A porta de saída Sul, por a topologia está conectada à porta de entrada 2 (Norte) do Roteador 01.·
3 ­ O Roteador 01 recebe o pacote oriundo da porta de saída Sul do Roteador 00.
O algoritmo de roteamento é executado, a tabela de chaveamento é atualizada, realizando- se a ligação entre a porta de entrada 2 (Norte) e a porta de saída 0 (Leste) no Roteador 01.·
4 ­ Em o Roteador 01 ainda, a porta Leste recebe o pacote oriundo da porta Norte do mesmo roteador.
A porta de saída Leste, por a topologia está conectada à porta de entrada 1 (Oeste) do Roteador 11.·
5 ­ Em o Roteador 11, a porta de entrada 1 (Oeste) recebe o pacote oriundo da porta de saída 0 (Leste) do Roteador 01.
O algoritmo de roteamento é executado, a tabela de chaveamento é atualizada realizando a ligação entre a porta de entrada 1 (Oeste) do Roteador 11 e a porta de saída 4 (Local) do mesmo roteador.·
6 ­ Em o Roteador 11 a porta de saída 4 (Local) recebe o pacote oriundo da porta de entrada 1 (Oeste) do mesmo roteador.
Em esse instante, gradativamente os pacotes atingem o IP Testador 11, são interpretados e os dados são armazenados na memória do IP 11, neste caso um IP Testador.
O IP Testador fica a partir de aí aguardando o sinal de Start para então simular o tráfego dentro de a NOC.
IP=00  ao IP 11, passando por o Roteador 00, depois por o Roteador 10, chegando ao Roteador 11.
Os sinais mostrados para os pontos 2-6 não mostram o valor esperado como ocorre em 1, mas isto é devido a falhas de detalhamento da visualização e não a erros de simulação.
Em este experimento validam- se três caminhos distintos da NoC Hermes-TB, percorridos de forma consecutiva.
Todos envolvem apenas dois roteadores entre origem e destino e todos partem do IP 00 (o IP Serial).
O esquema geral do experimento é detalhado na Figura 33 e as formas de onda para cada pacote são apresentadas na Figura 34, Figura 35 e na Figura 36.
O procedimento pode ser detalhado como segue:·
1 ­ O IP Serial recebe a seqüência de oito dados e cria um pacote para enviar cada um de eles através da NoC.
Para cada pacote que entra no Roteador 00, o algoritmo de roteamento é executado, a tabela de chaveamento é atualizada, realizando a ligação entre a porta de entrada 4 (Local) do Roteador 00 e a porta de saída 1 (Oeste) do mesmo roteador.·
2 ­ O Roteador 00 recebe na sua porta de saída 1 (Oeste) os pacotes da porta de entrada 4 (Local) do mesmo roteador.·
3 ­ O Roteador 20 recebe na sua porta de entrada 0 (Leste) os pacotes oriundos da porta de saída 1 (Oeste) do Roteador 00.
O algoritmo de roteamento é executado e a tabela de chaveamento é atualizada, realizando a ligação entre a porta de entrada 0 (Leste) com a porta de saída 4 (Local) do mesmo roteador.·
4 ­ O Roteador 20 recebe na porta de saída 4 (Local) os pacotes oriundos da porta de entrada 0 (Leste) do mesmo roteador.
Em esse instante, gradativamente os pacotes chegam e são armazenados na memória do IP 20, neste caso um IP Testador.
O IP Testador fica então aguardando o sinal de Start para iniciar o processo de geração de tráfego programado em ele para injeção na NoC.
IP=00  ao IP 20.
Os sinais mostrados para os pontos 2-4 não mostram o valor esperado como ocorre em 1, mas isto é devido a falhas de detalhamento da visualização e não a erros de simulação.·
5 ­ O IP Serial recebe a seqüência de oito dados e cria um pacote para enviar cada um de eles através da NoC.
Para cada pacote que entra no Roteador 00, o algoritmo de roteamento é executado, a tabela de chaveamento é atualizada, realizando a ligação entre a porta de entrada 4 (Local) do Roteador 00 e a porta de saída 3 (Sul) do mesmo roteador.·
6 ­ O Roteador 01 recebe na sua porta de saída 3 (Sul) os pacotes da porta Local do mesmo roteador.·
7 ­ O Roteador 01 recebe os pacotes oriundos da porta 3 (Sul) do Roteador 00, por a sua porta 2 (Norte).
O algoritmo de roteamento é executado e a tabela de chaveamento é atualizada, realizando a ligação entre a porta de entrada 2 (Norte) com a porta de saída 4 (Local) do mesmo roteador.·
8 ­ O Roteador 01 recebe na porta de saída 4 (Local) os pacotes oriundos da porta de entrada 2 (Norte) do mesmo roteador.
Em esse instante, gradativamente os pacotes chegam e são armazenados na memória do IP 01, neste caso um IP Testador.
O IP Testador fica então aguardando o sinal de Start para iniciar o processo de geração de tráfego programado em ele para injeção na NoC.
IP=00  ao IP 01.
Os sinais mostrados para os pontos 6-8 não mostram o valor esperado como ocorre em 5, mas isto é devido a falhas de detalhamento da visualização e não a erros de simulação.·
9 ­ O IP Serial recebe a seqüência de oito dados e cria um pacote para enviar cada um de eles através da NoC.
Para cada pacote que entra no Roteador 00, o algoritmo de roteamento é executado, a tabela de chaveamento é atualizada, realizando a ligação entre a porta de entrada 4 (Local) do Roteador 00 e a porta de saída 0 (Leste) do mesmo roteador.·
10 ­ O Roteador 10 recebe na sua porta de saída 0 (Leste) os pacotes da porta Local do mesmo roteador.·
11 ­ O Roteador 10 recebe os pacotes oriundos da porta 0 (Leste) do Roteador 00, por a sua porta 1 (Oeste).
O algoritmo de roteamento é executado e a tabela de chaveamento é atualizada, realizando a ligação entre a porta de entrada 1 (Oeste) com a porta de saída 4 (Local) do mesmo roteador.·
12 ­ O Roteador 10 recebe na porta de saída 4 (Local) os pacotes oriundos da porta de entrada 1 (Oeste) do mesmo roteador.
Em esse instante, gradativamente os pacotes chegam e são armazenados na memória do IP 10, neste caso um IP Testador.
O IP Testador fica então aguardando o sinal de Start para iniciar o processo de geração de tráfego programado em ele para injeção na NoC.
IP=00  ao IP 10.
Os sinais mostrados para os pontos 10-12 não mostram o valor esperado como ocorre em 9, mas isto é devido a falhas de detalhamento da visualização e não a erros de simulação.
Simulações como as descritas nos Experimentos 1 a 4, realizadas a partir de a especificação em nível de registradores (em inglês, Register Transfer Level, ou RTL) do sistema são capazes de verificar a funcionalidade sem considerar a temporização do eventos no sistema de forma precisa.
À medida que se avança por as etapas de síntese e implementação, simulações mais precisas do comportamento real do circuito podem ser obtidas, tendo em vista que estas etapas incorporam informações sobre a tecnologia usada, posição de módulos e roteamento, permitindo estimar os atrasos associados à lógica e conexões.
Fazendo uso do simulador Modelsim adequadamente parametrizado, pode- se observar a diferença do comportamento de simulações com e sem atraso num FPGA.
Em a Figura 37 mostra- se um comportamento síncrono controlado por um relógio.
O sinal de relógio do sistema (system_ clock) transiciona, habilitando que um dado passe para a saída do IP Serial, ao mesmo tempo em que entra na porta de entrada Local do Roteador 00.
Isso leva a reflexão que nesta simulação ideal o processo ocorre instantaneamente.
Para realizar um processo de simulação com atrasos, deve- se proceder a mudanças na forma como é feita a compilação de arquivos e na preparação para gerar formas de onda.
Ilustra- se este processo a seguir.
Supondo que a simulação funcional do sistema já alcançou sucesso, procede- se à síntese do sistema HardNoC-TB, usando por exemplo a ferramenta XST do ambiente ISE da Xilinx, seguido de uma síntese física.
Em este processo, parametriza- se a síntese para gerar um arquivo com os dados de temporização do sistema como um todo, associado ao componente FPGA específico.
Este arquivo recebe o nome de HardNoC_ timesim.
Sdf, e contém uma descrição VHDL no nível de portas lógicas do sistema completo, anotado com os atrasos de componentes e fios do FPGA escolhido.
Os atrasos são sempre anotados em triplas de valores, correspondendo, para cada fio e componente a valores de atraso mínimo, típico e máximo.
Em a simulação escolhe- se um destes tipos de atraso para usar.
A Figura 38 mostra um exemplo de script para realizar uma simulação da HardNoC-TB com atrasos utilizando o Modelsim.
Apenas três arquivos necessitam ser compilados:
O pacote básico com as definições internas da rede Hermes-TB;
O arquivo gerado no processo de síntese, contendo toda a estrutura da HardNoC-TB e os atrasos associados;
E o arquivo de testbench da HardNoC-TB, denominado HardNoC_ TB.
Vhd. A explicação dos passos de simulação são muito similares aos passos usados na simulação com atraso da Figura 18, alterando- se apenas o passo marcado com o indicador 4 em ambas as Figuras.
Os passos iniciais da Figura 38 são idênticos aos da Figura 18, sendo por isso omitidos na primeira.
O passo 4 do script de simulação com atrasos tem a seguinte funcionalidade:·
4 -- Comando que realiza a chamada para simulação, que conta com algumas opções específicas em relação a o comando de simulação da simulação com atrasos:
Primeiro, a opção ­t 1 ps estabelece o limite de resolução de tempo explicitamente em 1 ps;
A opção ­sdfmax estabelece que se deva usar valores máximos de atraso obtidos a partir de a leitura do arquivo HardNoC_ timesim.
Sdf. O arquivo com extensão SDF contém as informações dos componentes e fios com os referentes atrasos, neste projeto especifico.
SDF é uma sigla que representa um formato textual padrão de representação lógica de um circuitos com atrasos anotados.
A sigla significa Standard Delay Format.
Em o arquivo HardNoC_ timesim.
Sdf está a descrição de toda estrutura de hardware, contendo os IPs e Roteadores, bem como o comportamento de atraso de fios e componentes eletrônicos do FPGA.
Esse arquivo descreve um circuito de forma muito mais aproximada de um ambiente com as características físicas do circuito que se vai construir (no caso, configurando o FPGA).
Contudo, seu uso destina- se a simulação.
Referindo- se à forma de onda da Figura 39, nota- se que o sinal que respondia instantaneamente à transição do sinal de relógio do sistema na Figura 37 possui em verdade um atraso de 2,408 ns em relação a aquele.
Outro exemplo, relacionado a pacotes da NoC Hermes-TB aparece ilustrado na Figura 40.
Em o círculo 1 observa- se o tempo de 63000 ns em que o valor 0377 está na porta de saída Local do Roteador 21.
Em o círculo 2 observa- se a subida do sinal de relógio.
Foi marcada de forma precisa a posição onde se observa o valor 0377 através do círculo 3 localizando o sexto flit de um pacote contido na terceira posição da mensagem enviada do IP Serial ao IP Testador 21.
Roteador 21 por a Porta Local.
A simulação com atraso demonstra um atraso acumulativo de 46,224 ns na Figura 41 em relação a a Figura 40.
Como a frequência de relógio é de 25 MHz e o período, por consequência é de 40 ns, esta situação indica um potencial problema de temporização do sistema, onde atrasos combinacionais que ultrapassam o valor do período de relógio estão presentes.
O circuito provavelmente jamais funcionaria nesta freqüência devido a este problema, impossível de detectar em simulações sem atraso.
Uma solução para este problema é reduzir a frequência de operação para 20 MHz.
FPGAs foram introduzidos em meados dos anos 80, como uma nova tecnologia para implementação de lógica digital.
Estes dispositivos representam uma evolução natural a partir de os seus antecessores, os PLAs (do inglês, Programmable Logic Arrays), projetados para construir lógica de dois níveis.
FPGAs, que podem hoje comportar circuitos de até algumas dezenas de milhões de portas, permitem a implementação de grandes quantidades de lógica digital com estruturas combinacionais e sequenciais.
FPGAs abriram caminho para uma revolução no domínio das tecnologias de lógica programável, com aplicações nos mais variados campos da eletrônica digital, dando suporte à construção de sistemas completos (ou quase) em seu interior.
Uma característica importante de FPGAs é sua capacidade de serem configurados e reconfigurados no campo.
Desta forma, a funcionalidade do dispositivo não é definida durante sua fabricação e sim por o projetista da aplicação final, através do preenchimento de uma memória de controle.
O que o fabricante fornece é uma matriz de blocos lógicos básicos programáveis, capazes de armazenar bits de informação e realizar funções lógicas elementares, cercados por um conjunto de rotas e conexões reconfiguráveis que permitem a interligação destes blocos para implementação das funções desejadas.
Uma aplicação pode ser especificada de forma gráfica com esquemáticos e diagramas de estados e diagramas de blocos.
Contudo, para permitir a especificação de comportamentos complexos são utilizadas mais comumente descrições textuais em linguagens de descrição de hardware (do inglês, Hardware Description Languages ou HDLs).
Exemplos destas linguagens são VHDL e Verilog.
Atualmente, a utilização a linguagem SystemC vem ganhado adeptos no meio acadêmico e industrial, devido a a capacidade potencial de integrar numa mesma especificação descrições de componentes de software e de hardware de uma aplicação num modelo único executável, bem como a habilitação de descrições de nível de abstração mais alto, útil na modelagem de sistemas altamente complexos.
O processo de construção de uma aplicação em FPGA compreende quatro etapas importantes, e cada uma destas contém diversas etapas menores.
As quatro principais são:
Síntese lógica, síntese física, geração do arquivo de configuração e configuração do dispositivo.
Estas etapas são mais bem detalhadas a seguir.
A primeira etapa, denominada síntese lógica compreende gerar uma descrição de portas lógicas que corresponde em termos de funcionalidade ao comportamento implementado por os arquivos em linguagem de descrição de hardware, que são a entrada desta etapa.
Esta descrição de portas lógicas é denominada de netlist.
A netlist descreve a interconexão de componentes digitais primitivos (como portas lógicas, flip-flops e registradores) obtidos de uma biblioteca abstrata de portas e macro células.
Durante esta etapa são aplicados métodos de otimização de circuitos digitais para produzir uma implementação eficiente da aplicação.
Um exemplo de formato de netlist de circuitos é o formato A segunda etapa, denominada síntese física, gera uma rede de circuitos digitais específicos, que é dependente de tecnologia.
Em essa etapa ocorre o mapeamento tecnológico, que tem por função mapear os componentes da netlist em blocos básicos do FPGA.
A síntese física utiliza como menor unidade lógica configurável os chamados slices do FPGA.
O slice é um módulo configurável, formado por duas LUTs (do inglês, Look Up Tables) com uma saída e quatro entradas (no caso de os FPGAs da família VirtexII-Pro usados neste trabalho).
LUTs pode ser configuradas como tabelasverdade de até 4 variáveis Booleanas, ou como registradores de deslocamento ou memórias de porta simples ou dupla com capacidade de armazenar 16 bits.
Além de LUTs, os slices possuem recursos como dois flip-flops tipo D, vários multiplexadores e demultiplexadores configuráveis, e lógica de propagação rápida de vai-um para facilitar implementação de circuitos aritméticos básicos.
A LUT é o elemento básico em FPGAs da Xilinx, e tais elementos são modelados por a Xilinx na biblioteca Após o mapeamento tecnológico, a aplicação passa a ser descrita como uma netlist de blocos lógicos do FPGA com as especificações de suas configurações internas.
A ferramenta de posicionamento então determina a posição que cada bloco deve ocupar no FPGA, de forma a facilitar o processo de roteamento das conexões e minimizar o atraso associado.
Isto permite a obtenção de freqüências de sinal de relógio adequadas para a operação do circuito.
Após a execução do posicionador, a etapa de roteamento implementa todas as conexões entre blocos e pinos de entrada e saída utilizando os recursos de roteamento reconfiguráveis do FPGA.
A terceira etapa, geração do arquivo de configuração, é realizada após o roteamento.
É gerada uma saída com uma descrição de todas as configurações necessárias do FPGA, num formato binário específico do fabricante do componente.
Esta configuração constitui- se num bitstream para configuração do FPGA.
A quarta etapa denominada configuração do dispositivo é o processo em o qual o arquivo já compilado é enviado ao dispositivo FPGA para receber os sinais elétrico.
O processo de prototipação da rede Hermes-TB baseou- se em alguns trabalhos anteriores realizados no GAPH.
O modelo VHDL da HardNoC-TB é composto por múltiplos níveis hierárquicos de entidades.
Aqui a discussão se limita aos três primeiros níveis desta hierarquia de projeto.
A primeira representa o nível mais alto de abstração, e corresponde à interface externa do sistema HardNoC-TB, composta por sinais de entrada e saída.
Estes podem ser observados na Figura 42, compreendendo os sinais rxd, txd, system_ clock e system_ reset.
Em o segundo nível de hierarquia, mostrado na Figura 43, têm- se o diagrama de blocos principal do sistema.
Este diagrama mostra os blocos fundamentais do sistema interligados por conexões na forma de barramentos e sinais individuais de controle.
Estes são a NoC (vista como um bloco monolítico) o IP Serial (IP0000) e os IPs Testadores (os demais).
A entidade VHDL HardNoC-TB consiste numa descrição estruturada fundamentada no diagrama de blocos ilustrado na Figura 42.
O detalhamento da entidade consiste numa arquitetura VHDL descrita graficamente por o diagrama da Figura 43.
Esse diagrama apresenta apenas as instâncias das entidades IP Serial e 5 de IPs Testadores.
A Figura 44 ilustra os detalhes da arquitetura da NOC Hermes-TB, que contém todo os roteadores desta.
Estes esquemas anunciam ao leitor a complexidade do sistema em prototipação, seguindo desde a descrição em VHDL, até os detalhes de cada bloco componente de hardware desta.
Mesmo observada sem maiores detalhes, a Figura 44 revela a interligação entre os roteadores, da NoC.
Note- se que a Figura 44 detalha o módulo denominado NoC (Figura 43).
O sistema HardNoC-TB completo descrito por estes diagramas foi prototipado sobre a plataforma XUP-V2PRO da empresa Digilent, Inc, cuja fotografia aparece na Figura 45.
A interação com o computador hospedeiro se dá usando um cabo serial conectado à interface serial RS232 da placa (mostrada no canto inferior direito da Figura 45) e ao conector equivalente do lado do hospedeiro.
Análise dos Sinais da Hermes-TB no Protótipo Através do uso da plataforma XUP-V2PRO consegui- se prototipar o ambiente HardNoC-TB e explorar seu uso mediante emprego da ferramenta ChipScope.
Pôde- se verificar que a comunicação do IP Serial para programar Testadores e verificar seu conteúdo opera corretamente.
Entretanto, o disparo da execução dos processos de geração de tráfego e coleta de estatísticas na HardNoC-TB a partir de a geração do comando Start não operou corretamente.
Em o início deste trabalho o fato da plataforma original (HardNoC) em a qual se baseou a HardNoC-TB ter operado de maneira correta e completa foi o fator decisivo na sua escolha.
Contudo, o processo de repetição da prototipação da HardNoC revelou que esta apresenta o mesmo problema da HardNoC-TB, resultante provavelmente da perda de informações sobre o processo de prototipação do projeto.
A documentação de base original da HardNoC foi então revisada para identificar os erros nesta.
Vários problemas foram encontrados e corrigidos.
Contudo, atualmente o ambiente HardNoC ainda está em processo de depuração, e este processo atingiu o mesmo ponto em que se congelou a versão atual da HardNoCTB.
Assim, acredita- se que este problema seja independente da NoC utilizada.
Com a finalidade de se analisar os sinais internos no FPGA utilizou- se o software Chipscope Para o 9.2i da Xilinx.
Chipscope possibilita a monitoração do sistema prototipado, em tempo real, por a inserção de módulos de captura de dados do sistema em tempo real e módulos de transmissão dos mesmos através do cabo de programação da plataforma.
O processo de criação da interface Chipscope com finalidade de leitura em tempo real dos dados foi implementado na ferramenta ISE 10.
1, transferindo um arquivo binário, usando um cabo de programação USB.
A Figura 46 mostra os pontos da simulação que puderam ser observados operando corretamente usando o Chipscope.
Falhas Encontradas na HardNoc-TB Observou- se durante o processo de depuração da HardNoC-TB que a operação da rede toro bidirecional segue o comportamento esperado.
Contudo, ao realizar os testes utilizando IPs Serial e IPs Testadores ocorrem alguns problemas, como descritos a seguir:·
Primeiramente, verificou- se que sem o DCM não é possível alcançar um funcionamento correto da HardNoC-TB.
O DCM é um módulo complexo, que conforme o datasheet do FPGA Xilinx XC2 VP30 com speed grade 7 necessita de pelo menos 5 microssegundos depois do sinal de inicialização do sistema (reset) ser ativado, para que o DCM ative o seu sinal de saída LOCKED, indicando que o sistema está apto a operar.
Só depois disto os sinais do sistema podem ser observados.
Pode- se considerar como irrelevante qualquer sinal antes deste tempo.
Em as simulações, esse sinal não sofre esse atraso, o LOCKED é ativado imediatamente depois do reset.
Em os testes, o sinal LOCKED estava com valor desconhecido ou inválido.
Esse sinal é utilizado em todo sistema e na ausência do mesmo é impossível interpretar corretamente os resultados de simulação.
A solução para este problema foi a re-execução do processo de compilação das bibliotecas SIMPRIM e UNISIM.
Observou- se que estas duas bibliotecas não podem coexistir ao mesmo tempo, pois isto causa uma geração incorreta do arquivo SDF da simulação com atraso e depois um arquivo de configuração binário incorreto para a prototipação.
Personalizando o script de síntese, e reinstalando as bibliotecas a operação do sinal LOCKED do DCM foi corrigida.·
Resolvendo o problema dos transitórios, foi detectado ainda outro problema.
Esse ocorre ao se fazer a simulação com atraso.
O tempo de recebimento da informação não está sendo o suficiente para que a informação possa ser enviada por completo.
Com isto, ao longo de a operação ocorrem falhas de temporização.
O acúmulo destas falhas faz com que a HardNoC &quot;trave «a partir de certo ponto da operação.
Distribuição do espaço utilizado no FPGA A ferramenta ISE de desenvolvimento de projeto para FPGAs da Xilinx possibilita a restrições de posicionamento através do uso de macros.
A restrição de posicionamento é importante quando se busca a hierarquia dos sinais, e para reduzir o atraso do circuito.
Em a Figura 48 pode- se observar o arquivo UCF e a maneira de se delimitar a área a ser ocupada por cada elemento na Hermes-TB.
Observando as referencias da Figura 48 tem- se a relação de áreas indicadas conforme o eixo x e y do FPGA na Figura 49.
Esta Figura ilustra a estrutura do arquivo UCF.
A Figura 50 representa a alocação real conforme gerada por a ferramenta ISE, da disposição espacial da HardNoc-TB prototipada em FPGA, conforme orientações do arquivo UCF.
Ocupação de Área A Tabela 1 ilustra as diferenças de área entre os sistemas HardNoC e HardNoC-TB.
Em o processo de prototipação uma vantagem descoberta em relação a a rede Hermes-VC foi que a rede Hermes-TB ocupa menos área.
Como a única diferença entre ambos é a NoC utilizada, conclui- se que a Hermes-TB ocupa menos área que a Hermes-VC.
Mesmo oferecendo menor latência e maior vazão, a rede toro ocupa menos espaço mesmo que os roteadores sejam todos de 5 portas.
Um fator que explica essa redução é o fato dos canais virtuais não existirem na rede toro, reduzindo sobremaneira a área do roteador.
Esta dissertação apresentou o processo de prototipação da rede Hermes-TB através do desenvolvimento da plataforma HardNoC-TB, uma evolução da HardNoC original que utiliza a mesma estrutura com topologia malha 2D.
A implementação da HardNoC-TB, alvo deste trabalho, foi validada através de simulações com e sem atraso, e parcialmente num protótipo.
A HardNoC-TB possui vantagens em relação a HardNoC original, no que tange área ocupada obtendo um ganho de cerca de 8%.
O ideal é o desenvolvimento da HardNoc-TB totalmente funcional na prototipação, com fluxos oriundos do hospedeiro externo através do IP Serial e a NoC entregando aos IPs Testadores as informações, seguido do processo de geração de tráfego e troca de mensagens resultantes entre os IPs Testadores.
Até agora, o processo de programação dos IPs testadores com padrões de tráfego através da NoC foi plenamente validado.
A operação após gerar o sinal Start, é deixada como trabalho futuro.
De entre outros trabalhos futuros possíveis enumeram- se três como sugestão:·
Prototipar a HardNoC-TB usando um a dimensão maior, como por exemplo uma NoC 5X5 ou 6X6, visando realizar experimentos sob condições de uso mais típicas de NoCs, onde o número de núcleos conectados por a NoC é significativo.
Claro que para tanto é necessário trocar a plataforma de prototipação e o FPGA utilizado.·
Validar o projeto HardNoC-TB através do emprego de técnicas de verificação de projeto como análise de cobertura de código e asserções, visando aumentar a robustez do projeto.·
Adaptar o ambiente MPSoC-H, proposto originalmente em para operar com a rede Hermes-TB no lugar da rede Hermes e comparar a execução neste ambiente mais realista do ponto de vista de aplicações.
Este ambiente é similar ao ambiente HardNoC, mas substitui os IPs Testadores da HardNoC por processadores programáveis parcialmente compatíveis com a arquitetura MIPS-I, denominados MR4.
Instâncias prototipadas do ambiente MPSoC-H estão disponíveis no GAPH.
