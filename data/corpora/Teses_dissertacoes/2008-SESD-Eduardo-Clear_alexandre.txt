Devido a o avanço dos sistemas voltados à inteligência no transporte, novos protocolos e algoritmos estão sendo desenvolvidos para suprir a crescente demanda de tráfego de informações geradas por esses sistemas.
O desenvolvimento de novas técnicas de comunicação tem aumentado o uso de dispositivos GPS/ GSM em sistemas de monitoramento de veículos.
Este tipo de tecnologia pode transmitir informações sobre rastreamento de veículos para centros de controle através de comunicação sem fio sobre redes GPRS.
O objetivo deste trabalho é propor e avaliar um protocolo de transmissão de informações de rastreamento veicular sobre redes GPRS.
Para isto, pacotes de informações de rastreamento veicular são descritos neste trabalho, métricas referentes à transmissão destes pacotes são investigadas em diversos cenários de comunicação utilizando o simulador de redes Ns-2, tendo seus resultados analisados.
Palavras-chave: Sistemas de rastreamento veicular;
GSM GPRS; Network simulator.
O volume de veículos nas ruas vem crescendo aceleradamente ao longo de as últimas décadas, assim como os congestionamentos, número de mortes por acidentes de trânsito e o número de veículos furtados, um dado que preocupa diversas empresas e organizações como transportadoras, seguradoras, órgãos de fiscalização, policiamento e gerência de tráfego.
Sistemas para inteligência no transporte (SIT) visam aplicar tecnologia da informação, comunicação e rastreamento aliadas à Internet para melhorar a segurança, confiabilidade, conveniência e mobilidade nos sistemas voltados à área de transporte.
Sistemas SIT incluem uma gama variada de aplicações e serviços como sistemas inteligentes de controle de tráfego, tecnologias in-vehicle, localização e segurança no tráfego, sistemas de auxílio em viagens, entre outros.
Devido a o avanço deste tipo de sistemas, novos protocolos e algoritmos estão sendo desenvolvidos para suprir a crescente demanda de tráfego de informações geradas por esses sistemas, principalmente para extração de informações de transporte usando receptores de sistemas de posicionamento global (GPS) integrados com tecnologias de telefonia móvel celular (GSM/ GPRS) e o uso da Internet.
É no método ou modo de comunicação que se concentra uma grande área de pesquisa neste tipo de sistema.
O desenvolvimento de técnicas de comunicação móvel tem aumentado o uso de dispositivos GPS/ GSM em sistemas de monitoramento de veículos.
Este tipo de tecnologia pode transmitir informações GPS para centros de controle através de comunicação sem fio sobre redes GPRS.
GPRS é caracterizado como uma rede &quot;sempre conectada «(uma vez conectado, sempre online), com baixa taxa (medido por o tráfego de dados), e fácil conexão (conecta diretamente com a Internet) constituindo numa rede cuja velocidade pode chegar a Simulação é uma ferramenta importante para que de uma forma rápida e com pouco custo seja possível explorar o comportamento de novos protocolos de comunicação e transmissão de dados.
O objetivo geral deste trabalho é avaliar a transmissão de informações de rastreamento veicular sobre redes GPRS através de simulações.
Para isto, são definidos formatos de pacotes de dados contendo informações sobre posicionamento de veículos equipados com dispositivos GPS, seu comportamento sobre a rede GPRS é estudado utilizando como base os protocolos de transporte TCP e UDP, bastante difundidos na Internet.
Os protocolos, TCP, UDP e GPRS apresentam algoritmos e comportamentos complexos que, quando utilizados em conjunto, podem gerar resultados inesperados tornandose, muitas vezes, difícil analisar os seus resultados.
Assim, é necessário explorar diferentes cenários com intuito de detectar e estudar casos deste tipo.
Vários cenários distintos são avaliados neste trabalho, incluindo diferentes taxas de erros do meio físico de transmissão, tamanho de pacotes, quantidade de usuários e de timeslots utilizados por usuário no sentido uplink.
Além disso, um novo modelo de erros do meio físico é introduzido no pacote de comunicação GPRS, tornando os resultados das simulações em cima deste modelo mais condizentes com a realidade.
O restante desta dissertação encontra- se organizado da seguinte forma.
Em o capítulo 2 são descritos as principais características e os conceitos relacionados ao GPRS, tais como a rede GSM e os componentes adicionados a esta para formar a rede GPRS.
Por último, os protocolos e a interface aérea do GPRS são descritos e algumas considerações apresentadas.
Em o Capítulo 3 são apresentados os trabalhos relacionados com o estudo e interação dos protocolos TCP, UDP e GPRS no meio de comunicação sem fio, bem como outros trabalhos que estudam a troca de informações entre veículos (in vehicle) trafegadas sobre redes sem fio utilizando este tipo de tecnologia.
Em o Capítulo 4, os pacotes de rastreamento veicular utilizados como base para simulação da transferência de informações sobre redes GPRS são descritos, sendo detalhado seu formato e as informações contidas dentro de cada pacote.
Uma breve descrição sobre os protocolos de transporte TCP e UDP são apresentados, protocolos sobre o qual os pacotes de rastreamento serão transportados sobre a rede GPRS.
Simulator, descrevendo suas principais características e conceitos.
O módulo GPRS, implementado e instalado à parte, é descrito detalhadamente, sendo apresentado seus problemas e limitações, bem como as modificações realizadas para superar- los.
Em o Capítulo 6, os aspectos relacionados às simulações são apresentados, sendo descrita a topologia, os parâmetros utilizados nas simulações e as métricas coletadas.
Os resultados obtidos são apresentados e discutidos detalhadamente.
Por último, as conclusões, contribuições e trabalhos futuros são apresentados no Esse capítulo descreve as principais características e conceitos relacionados ao GPRS (General Packet Radio Service), tais como a rede GSM (Global System for Mobile comunication) e os componentes adicionados a esta para formar a rede GPRS.
Também são descritos os protocolos, a interface aérea, as operações de transferência dos pacotes de dados, e as vantagens e desvantagens do GPRS.
O GSM consiste num padrão desenvolvido por a ETSI (European Telecommunications Standards Institute) na tentativa de uniformizar os sistemas celulares europeus existentes, os quais divergiam bastante, impossibilitando a compatibilidade entre os mesmos.
O GSM provê transferência de voz e de dados através de comutação por circuito.
Para tanto, a rede GSM é composta por várias entidades, as quais estão agrupadas em três subsistemas:
MS (Mobile Station) ou estação móvel, BSS (Base Station System) e Ns (Network Subsystem).
Em a Figura 1 pode ser observada uma rede GSM, cujos elementos serão descritos resumidamente a seguir.
A MS consiste num equipamento móvel (ou terminal) e um smart card chamado SIM (Subscriber Identity Module).
O SIM provê ao usuário acesso a serviços específicos, de acordo com o perfil do usuário, independente do terminal utilizado.
Em outras palavras, para fazer chamadas e ter acesso aos serviços disponíveis, o usuário precisa apenas inserir seu cartão num terminal.
Para isso, o SIM armazena, entre outras informações, uma identidade chamada IMSI (International Mobile Subscriber Identity), que identifica o usuário no sistema, e uma chave secreta para autenticação (ou certificado).
Para identificar de forma única o terminal, há uma identidade denominada IMEI (International Mobile Equipment Identity).
O BSS é formado por dois tipos de componentes:
BSC (Base Station Controller) e BTS (Base Transceiver Station).
A BTS contém os transceptores que definem uma célula e controla os protocolos de links de rádio com a MS.
O BSC gerência os recursos de rádio para uma ou mais BTSs, sendo responsável por o estabelecimento de chamadas, saltos de freqüência (frequency hopping) e handovers.
O BSC interconecta a estação móvel (MS) e o MSC (Mobile Switching Center).
O principal componente do Ns é o MSC (Mobile Switching Center).
Este funciona como um switch, decidindo qual caminho o tráfego de informações deve seguir, e provê funções necessárias para a &quot;manipulação «de um usuário, como registro, autenticação e atualização de localização.
Para prover tais funções, o MSC trabalha em conjunto com outros componentes:
HLR, VLR, AuC e EIR.
O HLR (Home Location Register) armazena dados permanentes e temporários (voláteis) sobre o usuário.
Os dados permanentes consistem em informações sobre o perfil do usuário, que inclui desde dados pessoais até serviços aos quais o assinante tem direito, enquanto os dados temporários são informações sobre a localização do usuário.
O VLR (Visitor Location Register) contém dados necessários para o controle de chamadas e provisão de serviços ao usuário que se encontra na área geográfica controlada por ele.
Tais dados incluem parte dos dados permanentes contidos no HLR bem como dados locais, como uma identificação temporária.
O AuC (Authentication Center) guarda dados relacionados à segurança, como as chaves utilizadas na criptografia e na autenticação (certificados).
O EIR (Equipment Identity Register) armazena dados sobre o equipamento móvel.
Contém uma lista de todos os equipamentos válidos na rede, em a qual cada estação móvel é identificada por a sua IMEI.
Além de os elementos que compõem a rede GSM, a arquitetura da rede GPRS (Figura 2) apresenta novos componentes:
Os GPRS Support Nodes (GSNs).
Esses componentes são responsáveis por a entrega e roteamento de pacotes de dados entre as estações móveis e as redes de pacotes de dados (PDN ­ Packet Data Network) externas.
Há dois tipos de GSNs, Serving GPRS Support Nodes (SGSN) e Gateway GPRS Support Nodes (GGSN).
O primeiro é responsável por a entrega de pacotes de e para as estações móveis dentro de sua área de serviço.
Suas tarefas incluem roteamento e transferência de pacotes, gerenciamento de mobilidade, gerenciamento de link lógico, e funções de autenticação e cobrança.
O segundo, GGSN, funciona como uma interface entre a rede backbone GPRS e as redes de pacotes de dados externas.
O GGSN converte os pacotes GPRS vindos do SGSN no formato apropriado do protocolo de pacotes de dados (PDP ­ Packet Data Protocol) ­ por exemplo, IP ­ e manda os pacotes para a rede externa correspondente.
Analogamente, na direção inversa endereços PDP de pacotes de dados que chegam são convertidos para o endereço GSM do destinatário.
Os pacotes &quot;convertidos «são mandados para o SGSN responsável.
Assim, o GGSN armazena em seu registro de localização o endereço do SGSN corrente e o perfil do usuário.
Em geral, há relação muitos- para- muitos entre os SGSNs e os GGSNs:
Um GGSN é a interface para redes de pacotes de dados externas para vários SGSNs;
Um SGSN pode rotear seus pacotes por diferentes GGSNs para alcançar diferentes redes de pacotes de dados.
Conhecer a localização da estação móvel é bastante importante para a rede GPRS, para que esta possa encaminhar pacotes destinados à MS.
Assim, torna- se necessário gerenciar a mobilidade dos terminais, mantendo atualizada a localização destes.
Contudo, se a cada &quot;passo «a MS informar sua localização, haverá muita sinalização.
Para equilibrar essa relação (isto é, manter a localização da MS atualizada sem que haja excesso de sinalização), uma rede GSM é dividida em áreas de localização (La ­ Location Areas).
Estas são divididas em áreas de roteamento (Ra ­ Routing Areas), que, por sua vez, encontram- se divididas em células.
A freqüência e a precisão com que a MS informa sua localização depende do estado em que se encontra, os quais serão explicados a seguir (Seção 2.3.3).
Em o estado idle, a estação móvel é inacessível, isto é, não é possível realizar paging para essa unidade.
Em o estado ready, o terminal informa ao SGSN sempre que muda de célula;
Enquanto no estado standby a MS informa apenas sua Ra.
A o receber um pacote destinado à estação, a rede realiza um paging para saber a célula em que a MS se encontra.
Para ter acesso aos serviços GPRS, uma estação móvel deve antes se registrar num SGSN de uma rede GPRS.
Isso é feito através de um procedimento chamado GPRS attach.
Em esse procedimento, a rede checa se o usuário é autorizado, copia o perfil do usuário do HLR para o SGSN e determina uma identidade temporária (PTMSI ­ Packet Temporary Mobile Subscriber Identity) ao usuário.
O móvel informa se deseja ser registrado como um dispositivo GPRS, um dispositivo GSM ou ambos.
O procedimento de desconexão de uma rede GPRS é denominado GPRS detach e pode ser iniciado por o móvel ou por a rede (SGSN ou HLR).
Um procedimento de attach não habilita a estação a transmitir e receber dados.
Para isso, a MS precisa ativar uma sessão de comunicação através de um contexto PDP (Packet Data Protocol).
Em outras palavras, a estação móvel necessita de um ou mais endereços usados na rede de pacotes de dados externa com a qual ela deseja se comunicar, para que seja possível a troca de pacotes.
Um contexto PDP é formado por o tipo do PDP (por exemplo, IPv4), o endereço PDP associado à estação móvel, a qualidade de serviço (QoS) requerida e o endereço do GGSN que serve de ponto de acesso à rede de dados (PDN).
Para cada sessão é criado um contexto PDP, o qual é armazenado na MS, no SGSN e no GGSN Em um determinado momento, uma estação móvel pode estar num dos seguintes estados:
GPRS idle ­ nesse estado, a MS não está conectada a nenhuma rede GPRS;
Para transmitir e/ ou receber dados é preciso realizar um attach a uma rede GPRS, mudando para o estado ready.
GPRS ready o terminal passa para esse estado quando realiza um attach, registrando- se a uma rede GPRS.
Em esse estado, a MS pode estabelecer um contexto PDP, a fim de se comunicar com uma rede externa (PDN).
Quando um contexto é ativado, recursos são reservados para a sessão até que a transferência de dados pare por um determinado tempo, então os recursos são liberados, todos os contextos PDP são apagados e a MS entra no estado standby.
GPRS standby nesse estado, o móvel continua registrado a uma rede GPRS, mas não possui contexto PDP, logo não é possível a transferência de dados.
Quando a rede recebe um novo pacote destinado à MS, é realizado um paging para localizar a estação móvel e esta ativa um novo contexto PDP, voltando ao estado ready.
A Figura 3 ilustra resumidamente a mudança entre estados de uma MS.
Em redes híbridas GSM/ GPRS, os dispositivos móveis podem ser distribuídos em três classes:
Classe A (GSM/ GPRS):
O dispositivo móvel pode estar conectado a uma rede GPRS e a uma GSM ao mesmo tempo, podendo fazer e receber chamadas GPRS e GSM ao mesmo tempo.
Classe B (GSM/GPRS):
Essa classe é similar à classe A, mas nesse caso o móvel não suportará chamadas simultâneas, isto é, se estiver realizando uma chamada GPRS, não poderá fazer/ receber uma chamada GSM e vice-versa.
Classe C (GSM ou GPRS):
O dispositivo móvel nessa classe possui ambas funcionalidades ­ GSM e GPRS ­ mas só poderá se vincular a uma rede por vez.
A especificação do GPRS define protocolos para o plano de transmissão e para o plano de sinalização.
Os protocolos que constituem o plano de transmissão podem ser observados na Figura GPRS e redes IP.
Para uma rede IP externa, a rede GPRS parece uma sub-rede IP comum.
A comunicação SGSN-GGSN é realizada através da interface Gn, a qual possui os seguintes protocolos:
O GTP (GPRS Tunneling Protocol) é responsável por os pacotes de dados do usuário e as informações de sinalização relacionadas a estes entre os GSNs.
Em outras palavras, o GTP recebe datagramas IP e cria túneis (rotas válidas apenas na rede GPRS, invisíveis a redes externas) entre os GSNs.
Vale ressaltar que esse protocolo atua não apenas na interface Gn (entre SGSN e GGSN) mas também na interface Gp (entre GGSNs).
Os protocolos TCP (Transmission Control Protocol) e UDP (User Datagram Protocol) transportam os pacotes GTP dentro de o backbone da rede.
O TCP é utilizado quando se necessita de confiabilidade na transmissão, isto é, quando é importante que não haja perdas de dados.
Utiliza- se o UDP quando a perda de pacotes não consiste num grande problema.
Assim, o TCP é usado para dados do usuário que precisam de confiabilidade e o UDP, para sinalização e dados que não precisam de confiabilidade (como aplicações multimídia).
O IP (Internet Protocol) é empregado na camada de rede, para prover roteamento dos pacotes entre os GSNs.
A interface Gb promove a comunicação SGSN-BSS e SGSN-MS utilizando os protocolos abaixo:
O SNDCP (SubNetwork Dependent Convergence Protocol) é usado para transferir pacotes de dados entre o SGSN e a MS.
Esse protocolo converte pacotes da camada de rede (N-PDUs ­ Network layer Packet Data Unit) num formato adequado à arquitetura de rede GPRS.
O LLC (Logical Link Control) provê um link lógico bastante confiável entre a MS e o SGSN associado a ela.
Suas funcionalidades incluem controle de seqüência, entrega em ordem, detecção e correção de erros, e retransmissão (ARQ ­ Automatic Repeat reQuest).
Possui os modos de transmissão de quadros com e sem confirmação (acknowledged e unacknowledged, respectivamente).
O BSSGP (Base Station System GPRS Protocol) transporta entre o SGSN e o BSS informações relacionadas ao roteamento e a QoS.
Esse protocolo opera sobre Frame Relay.
O Network Service mapeia os serviços solicitados por o BSSGP para serviços Frame Relay apropriados.
A interface Um é responsável por a comunicação entre a MS e o BSS e é formada por os seguintes protocolos:
O RLC (Radio Link Control) tem como principal objetivo estabelecer um link confiável entre a MS e o BSS.
Entre suas funções encontram- se fragmentação e desfragmentação dos quadros LLC em blocos de dados RLC, e correção de erros através de um mecanismo de retransmissão seletiva desses blocos.
O MAC (Medium Access Control) controla o acesso aos canais de rádio, ou seja, determina como os pares freqüência/ timeslot são compartilhados por as MSs.
Baseado no slotted ALOHA, o MAC realiza resolução de contenção entre as tentativas de acesso ao canal, multiplexação de vários usuários num mesmo canal lógico (PDTCH), e escalonamento e priorização baseado no QoS negociado.
A camada física divide- se em duas subcamadas:
PLL (Physical Link Layer) e RFL (Physical RF Layer).
A PLL provê um canal físico entre a MS e o BSS.
Entre suas funções estão codificação dos dados e detecção e correção de erros de transmissão no meio físico.
A RFL realiza modulação/ demodulação das ondas físicas.
O plano de sinalização engloba protocolos para controle e suporte das funções do plano de transmissão, como os procedimentos de attach e detach.
Entre a MS e o SGSN (Figura 5), o protocolo GMM/ SM (GPRS Mobility Management and Session Management) provê suporte ao gerenciamento de mobilidade e de sessão na realização de funções como GPRS attach/ detach e ativação do contexto PDP.
A arquitetura de sinalização entre o SGSN e as bases de dados HLR, VLR e EIR, ilustrada na Figura 6, usa os mesmos protocolos do GSM e os incrementa com funcionalidades específicas do GPRS.
Entre o SGSN e o HLR, assim como entre o SGSN e o EIR, um MAP (Mobile Application Part) aperfeiçoado é empregado.
O MAP transporta informações de sinalização relacionadas a atualizações de localização, informações de roteamento, perfis de usuários e handovers.
A troca de mensagens MAP é realizada sobre (Transactions Capabilities Application Part) e o SCCP (Signaling Connection Control Part), os quais fazem parte da pilha de protocolos do Ss&amp; 7 (Signaling System no. 7) juntamente com o MTP3 (Message Transfer Part Level 3) e MTP2 (Message Transfer Part Level 2).
O BSSAP+ (Base Station System Application Part) abrange as funções descritas na especificação do GSM e é usado para transferir informações de sinalização entre o SGSN e o VLR.
Isso inclui sinalização de gerenciamento de mobilidade quando é necessária a coordenação entre funções GPRS e funções convencionais GSM (por exemplo, paging de uma estação móvel via GPRS para uma chamada GSM recebida).
Uma vez definidos os protocolos utilizados na transmissão de dados, será mostrado agora um cenário de um pacote sendo transmitido fim a fim numa rede GPRS.
GTP para diferenciar o N-PDU de uma mensagem GTP.
O dado segue adiante para a camada UDP/ TCP, a qual insere seu próprio cabeçalho ­ UDP ou TCP ­ baseado na classe QoS (letra B no diagrama).
Esse cabeçalho contém o endereço da porta de origem e de destino, informações sobre roteamento, e (no caso de o TCP) controle de fluxo.
Encaminhado para a camada IP, o N-PDU recebe o endereço da origem e do GSN de destino (no caso, SGSN).
Dependendo do tamanho do N-PDU e da unidade máxima de transmissão (MTU ­ Maximum Transmission Unit) da camada IP, é necessária a fragmentação do N-PDU.
Finalmente, o N-PDU, com todos os cabeçalhos adicionados, é transportado através da camada física da interface Gn para o SGSN.
Em o SGSN, os cabeçalhos são retirados e o N-PDU é conduzido para a camada SNDCP.
Esta irá comprimir (opcionalmente) e segmentar o pacote para atingir os 1520 octetos requeridos (MTU) para a transmissão através da camada de serviços de rede Frame Relay na interface Gb.
Primeiro o SNDCP classificará o N-PDU como Sn-DATA PDU orientado à conexão ou Sn-UNITDATA PDU não orientado à conexão.
Depois é adicionado um cabeçalho SNDCP contendo informações sobre compressão e segmentação, como visualizado na letra C da Figura 7.
Em a camada LLC, o Sn-DATA PDU ou o Sn-DATAUNIT PDU é encapsulado num quadro LLC, denominado bloco LLC, com seu próprio cabeçalho (letra D do diagrama).
Este contém informações de controle (usados no modo de transmissão com confirmação), frame O bloco LLC é enviado para a camada BSSGP, a qual provê informações de roteamento para a camada de serviços de rede.
O BSSGP também adiciona um cabeçalho, que contém informações essenciais às camadas RLC/ MAC da interface aérea -- relacionadas à transmissão de bloco, como prioridade, TLLI (Temporary Logical Link Id), etc..
O dado é enviado através da interface Gb entre o SGSG e o BSS.
Em o BSS, o BSSGP envia todas as informações para a RLC.
Esta segmenta os blocos LLC em blocos menores, denominados blocos RLC.
A letra E da Figura 7 ilustra esse processo.
Um grupo de blocos LLC, agora segmentados em blocos menores, é conhecido como um TBF (Temporary Block Flow).
Para cada TBF, recursos são alocados na interface aérea num ou mais PDTCHs.
Um TBF é temporário e mantido apenas enquanto durar a transferência de dados.
Cada TBF possui um TFI (Temporary Flow Identity) e a camada RLC adiciona um cabeçalho contendo o TFI, o número de seqüência do bloco RLC (BSN ­ Block Sequence Number), a direção (uplink/ downlink) e outras informações.
Para a segmentação dos blocos LLC em blocos de dados RLC, precisa ser definida a quantidade de dados úteis a serem transmitidos.
Tal quantidade varia de acordo com o cenário de codificação (Cs) escolhido.
Os possíveis valores são 22, 32, 38 e 52 octetos de dados, correspondendo a Cs-1, Cs-2, Cs-3 e Cs-4, respectivamente.
O Cs é determinado de acordo com a relação vazão/ confiabilidade desejada (vide Seção 2.7.4).
Após a segmentação dos dados e inserção do cabeçalho RLC, os blocos RLC são passados à próxima camada, MAC.
Esta adiciona seu próprio cabeçalho e encaminha os blocos RLC para a camada física (GSM RF), que os transmite através da interface aérea para a estação móvel.
Em a MS, os blocos são conduzidos através das camadas, em as quais os respectivos cabeçalhos são retirados e os segmentos remontados.
Finalmente, a mensagem de e-mail original é recebida na camada de aplicação por o usuário do móvel.
A interface aérea do GPRS utiliza a estrutura do GSM.
Em a camada física, o GSM usa uma combinação de TDMA com FDMA.
O espectro reservado para o GSM, que varia de acordo com o país, é dividido em duas bandas de freqüência de 25 MHz, separados por 45 MHz.
Em a Europa (Figura 7), são usadas as bandas 890 ­ 915 MHz para transmissão downlink (isto é, no sentido Bs-MS) e 935 ­ 960 MHz para transmissão uplink (ou seja, no sentido MSBS).
Cada banda é dividida em 124 portadoras de canais (de freqüências) com 200 kHz de largura.
Um determinado número dessas portadoras é reservado para uma BTS (isto é, para uma célula).
Cada portadora é dividida em quadros TDMA, os quais são compostos por oito timeslots, ou seja, oito canais.
Cada timeslot dura 576,9 ms, logo um quadro dura 4,615 ms..
A repetição de um timeslot particular define um canal físico.
Como pode ser observado na Figura 8, um quadro TDMA no sentido uplink é iniciado com um atraso de três timeslots do início de um quadro TDMA no sentido downlink.
Uma estação móvel GSM usa o mesmo timeslot nos dois sentidos:
Downlink e uplink.
GPRS apresenta um mecanismo de alocação de canais mais flexível:
mais de um timeslot (operação multislot) pode ser reservado para uma mesma MS.
Além disso, a alocação downlink e uplink pode ser assimétrica, pois é realizada separadamente.
Em um sistema GSM, um canal é alocado permanentemente durante todo o período de uma chamada, havendo ou não transmissão de dados.
Em GPRS, o canal é alocado apenas quando há transmissão de pacotes, beneficiando o usuário, que não precisa se preocupar com o tempo de conexão.
Em um sistema GPRS, a interface aérea é dividida em canais físicos para tráfego GPRS e canais físicos para GSM.
Channel). Ou seja, nesse caso os recursos GSM e GPRS são totalmente separados.
Sobre os canais físicos, são definidos canais lógicos para realizar várias funções, como sinalização, broadcast, paging e transporte de dados (payload).
Os canais lógicos GPRS podem ser classificados em dois grupos:
Canais de controle (Packet Control Channels) e canais de tráfego (Packet Traffic Channels).
Os canais de controle podem ainda ser divididos em canais de controle compartilhados, canais de controle dedicados e canais de controle de broadcast.
Uma breve descrição de cada canal é realizada a seguir.
PCCCH (Packet Common Control Channel) ­ consiste num conjunto de canais lógicos utilizados para sinalização comum entre o BSS e a MS.
É composto por quatro subcanais:
PRACH (Packet Random Access Channel) ­ usado por a MS para solicitar um ou mais canais para transmissão de dados (PDTCH) ou responder mensagens de paging.
PAGCH (Packet Access Grant Channel) ­ utilizado para responder mensagens de reserva de recursos (PDTCHs) para uma estação móvel antes da transferência de pacotes.
PPCH (Packet Paging Channel) ­ usado por o BSS para localizar uma MS (isto é, realizar um paging) antes da transmissão de pacotes downlink.
PNCH (Packet Notification Channel) ­ utilizado para informar um grupo de estações móveis sobre a chegada de mensagens PTM-M (Point-To-MultipointMulticast).
PBCCH (Packet Broadcast Control Channel) ­ utilizado por o BSS para transmitir informações sobre o sistema para todas as estações móveis GPRS na célula.
Os canais de controle dedicados são: (
Packet Associated Control Channel) ­ provê informações de sinalização sobre uma determinada MS (por exemplo, controle de potência).
Um PACCH é associado a um ou mais PDTCHs atribuídos a uma estação móvel.
PTCCH (Packet Timing advance Control Channel) ­ usado para sincronização.
PDTCH (Packet Data Traffic Channel) ­ transmite dados dos usuários.
É alocado para uma estação ou para um grupo de estações (para aplicações multicast).
Uma MS pode usar vários PDTCHs ao mesmo tempo para operação multislot.
Os canais lógicos definidos no item anterior não necessariamente requerem recursos físicos separados, sendo mapeados nos canais físicos através de uma técnica de multiframing.
Um multiframe é um conjunto de N quadros (frames) TDMA que juntos apresentam uma funcionalidade.
Um multiframe GPRS é composto por 52 quadros (frames) e pode ser visualizado na Figura 10.
Em cada quadro, um timeslot é considerado para formar essa estrutura, ou seja, após 52 quadros, juntando os timeslots de número 2, por exemplo, uma estrutura como essa terá sido gerada.
Os 52 quadros são divididos em 12 blocos, B0 a B11, que são constituídos por 4 quadros.
De os 4 quadros restantes, 2 são usados para canais de sincronização de tempo (PTCCH) e 2 são deixados ociosos.
Também são definidos multiframes com 51 quadros (frames), os quais são usados para carregar apenas os canais PCCCH e PBCCH.
Há três combinações possíveis para o mapeamento de canais lógicos num único canal físico (usando o multiframe com 52 quadros):
A primeira combinação permite que todos os canais lógicos sejam mapeados num canal físico.
Uma vez que existem apenas 12 blocos para canais lógicos num multiframe, essa opção reduzirá o número de canais disponíveis para cada categoria.
A segunda combinação permite que todos os canais exceto o PBCCH sejam mapeados num canal físico.
Isso aumenta a capacidade de PCCCH e PDTCH.
Mas essa opção só pode ser usada se os canais PBCCH e PCCH existirem em outro canal físico ou se os canais BCCH e CCCH do GSM puderem ser usados.
A terceira e última combinação é para tráfego e sinalização dedicada apenas, o que exclui PBCCH e PCCCH.
Essa combinação provê mais PDTCHs num canal físico e pode ser utilizada apenas se esses canais existirem em outros canais físicos ou se os canais BCCH e CCCH do GSM puderem ser usados.
O conceito mestre-escravo pode ser usado em algumas instâncias em as quais um canal físico é configurado como mestre e carrega todos os tipos de canais (isto é, utiliza a primeira opção descrita acima), e os outros canais físicos são configurados como escravos e usados apenas para transferência de dados (terceira opção).
Quando a demanda de transferência de dados é baixa, esses outros canais físicos podem ser usados para serviços de comutação por circuito.
A codificação de canais é usada para proteger pacotes de dados transmitidos contra erros.
Há quatro cenários de codificação no GPRS, os quais são utilizados de acordo com as condições do canal (ruído).
Quanto piores as condições do ambiente de transmissão, maior deve ser a proteção aos dados.
E quanto maior a proteção, menor a quantidade de dados úteis (isto é, dados do usuário).
A Figura 11 mostra o processo de codificação.
Primeiramente um codificador de blocos é utilizado para adicionar os bits de paridade (BCS ­ Block Check Sequence).
Depois os bits da USF (Uplink State Flag) são codificados.
Os tail bits, necessários para a terminação da codificação de convolução, são adicionados em seguida.
Um codificador &quot;convolucional «é usado na seqüência.
Finalmente, alguns bits de proteção são eliminados (se necessário) através de um mecanismo denominado puncturing, resultando numa codeword de 456 bits.
A Tabela 1 apresenta os valores envolvidos nos cenários de codificação.
Para iniciar uma transferência de pacotes, uma estação móvel GPRS deve primeiro se conectar a uma rede GPRS e realizar a ativação de um contexto PDP (vide Seção standby caso não esteja transmitindo dados e repetir o processo todo novamente.
Uma MS precisa solicitar recursos ao BSS antes de transferir os dados.
Esse processo começa com a requisição de um canal de dados através do PRACH.
A rede responde através do PDCH (ou AGCH).
A requisição pode ser feita numa ou duas fases.
Em a requisição numa fase, a rede responde à solicitação da MS reservando recursos num ou mais PDCHs para a transferência uplink de um determinado número de blocos de rádio.
Uma requisição em duas fases permite que a estação móvel forneça uma descrição completa dos recursos requisitados para a transferência uplink.
Se a rede não responde a uma requisição dentro de um certo período, a MS tenta novamente após um tempo de back-off.
O próximo passo na transferência de pacotes de dados é a alocação de blocos de rádio.
Esta pode ser dinâmica ou fixa.
Em a alocação dinâmica de blocos de rádio, a MS é informada sobre os blocos disponíveis bloco-a-bloco.
A rede manda uma mensagem para a estação móvel com a lista de PDCHs associados e o correspondente valor da USF (Uplink Status Flag).
A MS monitora as USFs nos PDCHs alocados e transmite os blocos de rádio nos canais que possuem o valor USF reservado para ela.
A USF atribui um ou quatro blocos a uma MS.
Assim, quando um móvel detecta sua USF num downlink, ele transmite um bloco ou uma seqüência de quatro blocos RLC/ MAC.
A MS inclui na transmissão do bloco uplink o número de blocos que faltam serem transmitidos.
A rede continuará reservando blocos para a estação até que esta indique que não há mais blocos a serem transmitidos.
Em a alocação fixa, a rede reserva todos os blocos requisitados por a MS.
A mensagem de reserva inclui os parâmetros freqüência, timeslots, um mapa de 128 bits e um start frame number.
A o receber essa informação, a estação móvel começará a transmitir o dado uplink nos blocos correspondentes, começando com o start frame number e usando a informação contida no mapa de bits.
Os blocos de dados RLC podem ser transferidos utilizando o modo com ou sem confirmação RLC.
Em o modo sem confirmação (unacknowledged), os blocos são transmitidos para a camada superior na ordem em que chegam.
Blocos perdidos são substituídos por bits 0, e a camada superior responsabiliza- se por a detecção/ correção de erros.
Em o modo com confirmação (acknowledged), os blocos são numerados, sendo entregues à camada LLC apenas quando todos os blocos RLC que compõem um bloco LLC são recebidos.
Isso é possível através da retransmissão seletiva de blocos (ARQ ­ Automatic Repeat Request).
O RLC é um protocolo de janela deslizante, isto é, permite que o transmissor envie um determinado número de blocos sem receber ACKs (ACKnowledgement).
E ao receber um ACK, a janela &quot;desliza «permitindo que mais blocos sejam enviados.
O tamanho da janela (Ws ­ Window Size) para o GPRS é 64, ou seja, um transmissor pode enviar até 64 blocos RLC sem receber nenhum ACK.
A confirmação da camada RLC é realizada através dos pacotes ACK/ NACK (acknowledged/ not acknowledged).
Estes contêm um mapa de bits com 128 elementos em que cada bit indica o estado de cada bloco transmitido (0 $= bloco não recebido corretamente;
1 $= bloco recebido corretamente).
Quando a janela fica completa, o transmissor pára de enviar blocos novos e começa a retransmitir os blocos não reconhecidos, avisando que a janela está cheia e que necessita de um pacote ACK/ NACK.
De acordo com a especificação, o receptor envia pacotes ACK/ NACK &quot;quando necessário».
Os casos explicitamente necessários são quando solicitado por o transmissor e ao receber o último bloco de uma seqüência.
A rede inicia a transferência de dados no sentido downlink enviando uma mensagem para a MS destino (que se encontra no estado ready), associando a ela um canal.
Se a MS estiver no estado standby, a rede realiza primeiramente um paging.
A rede transmite blocos RLC/ MAC pertencentes a um fluxo temporário de blocos (TBF ­ Temporary Block Flow) no canal downlink associado à estação móvel.
Geralmente mais de uma estação é multiplexada num PDCH num determinado momento.
Cada estação identifica seu TBF através do TFI (Temporary Flow Identity) contido no cabeçalho Após enviar o último bloco RLC, a rede inicia o processo de liberação de recursos.
A o receber da MS o pacote ACK/ NACK final, a rede inicializa um timer e, quando este expira, o TFI e todos os recursos alocados para a MS são liberados.
Em esse capítulo foi apresentada uma visão geral do GPRS, mostrando características e conceitos relacionados a essa tecnologia.
Primeiramente o GSM, que constitui a base do GPRS, foi apresentado de forma resumida.
Mostrou- se a rede GSM com seus subsistemas e, em seguida, os novos componentes, adicionados por a rede GPRS foram descritos.
O modo como o GPRS gerência a mobilidade de suas estações móveis foi exposto, descrevendo os procedimentos utilizados para isso.
Os protocolos que constituem os planos de transmissão e de sinalização do GPRS (por exemplo, GTP, RLC/ MAC, BSSAP+) foram apresentados, seguidos de um exemplo de um cenário ilustrando a transmissão fim a fim numa rede GPRS.
Também foi descrita a interface aérea, com seus canais lógicos e físicos, bem como o mapeamento entre eles.
Os cenários de codificação utilizados para transmitir os dados através da interface aérea foram detalhados, sendo explicado inclusive o processo de codificação.
A transferência de pacotes de dados, tanto no sentido downlink quanto no uplink, foi exposta.
Também foram apresentadas as formas de alocação de blocos de rádio, além de a transferência de blocos de dados RLC.
O estudo sobre a especificação da rede GPRS e seus protocolos é importante para que se possa criar um ambiente de simulação de acordo com a especificação, obtendo resultados muito próximos da realidade deste tipo de ambiente.
Baseado no estudo realizado nos Trabalhos Individuais I e II, foram identificadas as informações necessárias para o rastreamento e monitoramento de veículos através de dispositivos GPS e redes sem fio.
A identificação das informações necessárias e a definição do formato dos pacotes contendo informações sobre o rastreamento de veículos servem como base para definição do tamanho do pacote de dados que será trafegado nos diversos cenários gerados no simulador de redes Ns, buscando resultados cada vez mais condizentes com a realidade deste tipo de sistema.
Este capítulo inicia com uma visão alto nível do sistema de rastreamento veicular, sobre o qual os pacotes de comunicação irão trafegar, logo após, esses pacotes são detalhados.
Por último, são abordados os protocolos de transporte TCP e UDP sobre o qual os pacotes de informações de rastreamento veicular serão transportados.
Através das informações levantadas, foram definidos dois pacotes utilizados no envio (sentido veículo servidor central) de informações num sistema de rastreamento veicular, (1) pacote de informações básicas de telemetria e pacote de informações avançadas de telemetria.
O formato destes pacotes é detalhado ao longo deste capítulo.
Para facilitar o entendimento do fluxo de informações (pacotes de dados) trocados por o sistema, devemos analisar o framework sobre o qual o protocolo proposto irá funcionar.
O sistema de rastreamento veicular é composto de um componente de veículo móvel, um centro de monitoramento (servidor central) e uma rede de comunicação.
Os componentes do sistema já foram detalhados nos capítulos anteriores deste trabalho (vide Capítulo 2), esta seção tem como objetivo fornecer uma visão macro do funcionamento do sistema para facilitar a compreensão do fluxo de informações realizado por o sistema.
Esta seção descreve o formato dos pacotes de comunicação que serão utilizados para simular o comportamento da rede e do sistema no envio de informações de rastreamento veicular, serão detalhadas as informações contidas dentro de cada pacote de dados bem como as técnicas de compactação destes dados, utilizadas com intuito de diminuir o custo necessário para realizar o envio e recebimento destes dados.
Baseado nas necessidades de comunicação do sistema de rastreamento veicular foram identificados dois pacotes de transmissão de informações, Pacote de transmissão de informações básicas de telemetria, Pacote de transmissão de informações avançadas de telemetria.
Estes pacotes são detalhados nas próximas seções deste trabalho.
O pacote PT_ IBT contém as informações básicas de telemetria possíveis geradas por o veículo.
Este pacote é transmitido do veículo para o servidor central em determinados casos.
Este pacote possui 41 bytes de tamanho e as informações estão dispostas no pacote conforme Tabela 2: A posição 1 identifica o tipo de pacote enviado.
Tipo B identifica pacote de informações básicas.
As posições 2 a 21 identificam o código do sim card do chip GSM utilizado como referência única ao veículo monitorado.
As posições 22 a 29 informam a data e hora do evento de forma compactada, mais detalhes sobre o algoritmo de compactação da data pode ser visualizada no Apêndice A deste trabalho.
As posições 30 a 36 identificam a coordenada geográfica do veículo identificado em graus e minutos com o padrão Datum WGS-84.
A posição 30 representa o byte mais significativo da latitude, a posição 31 como o byte intermediário da latitude, a posição 32 como o byte menos significativo da latitude mais o quadrante, a posição 33 como o byte mais significativo da longitude, a posição 34 como o byte intermediário da longitude e a posição 36 como uma possível informação complementar de latitude e longitude.
A posição 37 identifica a direção em que o veículo esta se locomovendo, variando seu A posição 38 identifica o pico de velocidade atingida a partir de o último evento originado do GPS, variando seu valor de 0 km a 250 km/ h..
A posição 39 é referente a o nível de sinal GSM atual.
Seus valores possíveis estão descritos na Tabela 3.
O byte de posição 40 indica uma seqüência de 8 sinais digitais que representam alguns avisos possíveis sobre o veículo, onde o estado do bit $= 0 indica sensor acionado e estado do bit $= 1 indica condição normal, conforme a Tabela 4: A posição 41 refere- se a um byte de verificação cíclica de redundância, para controle de erro ou sujeira na transmissão do pacote, o algoritmo para cálculo e verificação de erro pode ser analisado no Apêndice B deste trabalho.
O pacote PT_ IAT contém todas informações de telemetria possíveis geradas por o veículo.
Este pacote é transmitido do veículo para o servidor central em determinados casos.
Este pacote possui 66 bytes de tamanho e as informações estão dispostas no pacote conforme Tabela 5: A posição 1 identifica o tipo de pacote enviado.
Tipo C identifica pacote de informações completas.
As posições 2 a 20 identificam o código do sim card do chip GSM utilizado como referência única ao veículo monitorado.
As posições 21 a 36 identificam o código do aparelho instalado no veículo.
As posições 37 a 44 informam a data e hora do evento de forma compactada, mais detalhes sobre o algoritmo de compactação da data pode ser visualizada no Apêndice A deste trabalho.
As posições 45 a 51 identificam a coordenada geográfica do veículo identificado em graus e minutos com o padrão Datum WGS-84.
A posição 35 representa o byte mais significativo da latitude, a posição 36 como o byte intermediário da latitude, a posição 37 como o byte menos significativo da latitude mais o quadrante, a posição 38 como o byte mais significativo da longitude, a posição 39 como o byte intermediário da longitude e a posição 41 como uma possível informação complementar de latitude e longitude.
A posição 52 identifica a direção em que o veículo esta se locomovendo, variando seu A posição 53 identifica o pico de velocidade atingida a partir de o último evento originado do GPS, variando seu valor de 0 km a 250 km/ h..
A posição 54 identifica o hodômetro que corresponde à distância percorrida por o veículo a partir de o último envio originado do GPS.
A posição 55 indica picos de giros do motor a partir de o último evento originado do A posição 56 é referente a o nível de sinal GSM atual.
Seus valores possíveis estão descritos na Tabela 6.
O byte de posição 57 indica uma seqüência de 8 sinais digitais que representam alguns avisos possíveis sobre o veículo, onde o estado do bit $= 0 indica sensor acionado e estado do bit $= 1 indica condição normal, conforme a Tabela 7: As posições 58 a 64 são reservadas no pacote de informações avançadas para uso em casos específicos de cargas especiais.
A posição 65 refere- se a um byte de verificação cíclica de redundância, para controle de erro ou sujeira na transmissão do pacote, o algoritmo para cálculo e verificação de erro pode ser analisado no Apêndice B deste trabalho.
Sistemas que trafegam dados sobre redes sem fio estão sujeitas a uma alta interferência de ruídos provenientes do meio físico.
Tratando- se de sistemas que trafegam dados sobre redes móveis e utilizam o meio físico de redes de celulares, por exemplo GSM, este tipo de interferência ocorre ainda em maior escala.
Além de a perda de pacotes provenientes do meio físico, existe a questão de que muitas vezes, o sinal GPS possa sofrer a mesma interferência do meio, pois se trata de um ambiente que utiliza um canal de conexão sem fio, só que neste caso, comunicação via satélite.
Sistemas para rastreamento de veículos, que trabalham com estes tipos de variáveis, devem estar preparados para armazenar as informações no momento de ausência de sinal GSM/ GPS.
Para simular este comportamento, supõe- se que os dispositivos GPS/ GSM simulados nos cenários deste trabalho possuem uma memória de massa, com capacidade de 10 Mbytes, que armazena os pacotes de informações, tanto os pacotes PT_ IBT quanto PT_ IAT, transferindo estes pacotes no momento de restabelecimento do sinal ou melhoria do canal de comunicação.
Devido a esta característica, será simulada a vazão máxima de envio de pacotes nos diversos cenários propostos por o trabalho, para os variados tamanhos de pacotes, condições de sinal e número de estações móveis.
O resultado destas simulações será detalhado no capítulo 6 deste trabalho.
Os protocolos TCP (protocolo de controle de transferência) e UDP (protocolo de dados do usuário) são protocolos de transporte, de baixo nível, que são utilizados em grande escala sobre redes GPRS é sobre estes protocolos que os pacotes de informações de rastreamento veicular serão transportados.
O TCP (Transmission Control Protocol) é um protocolo da camada de transporte, orientado à conexão, desenvolvido para oferecer funções de comunicação confiável e controle de congestionamento fim a fim.
Para prover confiabilidade, o TCP utiliza o mecanismo ARQ (Automatic Repeat Request), que retransmite todos os segmentos que não são explicitamente confirmados.
Para evitar o congestionamento da rede e a sobrecarga dos sistemas finais, o TCP realiza controle de tráfego (controle de fluxo e de congestionamento) através de um mecanismo de janela deslizante.
Esse mecanismo permite que o transmissor envie um determinado número de segmentos sem receber ACKs (ACKnowledgements -- confirmações), e, ao receber um ACK, a janela &quot;desliza «permitindo que mais segmentos sejam enviados.
O tamanho da janela, indicado por a variável CWND (Congestion Window), varia dinamicamente, baseado nos ACKs recebidos.
Os algoritmos Fast Retransmit e Fast Recovery permitem que o TCP detecte e corrija a perda de segmentos antes que o RTO (Retransmission Timeout) expire.
RTO consiste num timer que é inicializado sempre que um segmento é enviado.
Se um ACK não for recebido após esse tempo, considera- se que o segmento foi perdido.
Assim, o segmento é retransmitido e o TCP volta ao Slow Start.
O Fast Retransmit assume que um segmento foi perdido após receber três ACKs duplicados.
Em esse caso, o TCP retransmite o segmento perdido e retorna ao Slow Start.
O Fast Recovery pode ser utilizado após a retransmissão do segmento no Fast Retransmit, evitando que o TCP volte ao Slow Start.
O Fast Recovery reduz a janela à metade, incrementando- a, em seguida, de forma linear.
Embora seu funcionamento básico esteja padronizado, o TCP apresenta algumas variações e melhoramentos visando cada vez mais um melhor aproveitamento da rede.
Os algoritmos que implementam e a forma como estes são implementados diferenciam as versões do TCP.
Há, por exemplo, versões que não apresentam o Fast Recovery (TCP Tahoe) e outras que o implementam de forma diferente (TCP New-Reno).
Como não é objetivo deste trabalho o aprofundamento sobre as variações do protocolo TCP e sim a interação deste protocolo com o GPRS, foi assumido a versão TCP Reno para as simulações envolvendo este protocolo.
O TCP Reno implementa os quatro algoritmos básicos do controle de congestionamento sem modificações, ou seja, da forma descrita em.
Em outras palavras, inicializa a CWND com um segmento, incrementando a janela de forma exponencial (Slow Start) até atingir o SSTHRESH, quando o crescimento passa a ser linear (Congestion (Fast Retransmit) e reduz a janela à metade (Fast Recovery).
No caso de ocorrer um timeout, volta ao Slow Start.
Entidades TCP trocam dados na forma de segmentos, que consiste num cabeçalho de 20 bytes (fixo) mais uma parte opcional, seguida de zero ou mais bytes de dados.
O formato do cabeçalho TCP pode ser visualizado na Figura 13.
O UDP é um protocolo de nível de transporte orientado à transmissão de mensagens sem o estabelecimento de uma conexão entre máquina fonte e destino, fornecendo uma comunicação menos confiável que o TCP.
Ele envia as mensagens (sem conexão) e não oferece nenhuma garantia de entrega ou seqüência.
O formato do cabeçalho do UDP é mostrado na Figura 14.
O campo length dá o tamanho do cabeçalho mais o campo de dados.
O campo de checksum também é para o cabeçalho mais dados.
Pode- se notar por a Figura 14 que o tamanho do cabeçalho UDP é de 8 bytes.
Em os últimos anos têm sido realizados estudos avaliando o comportamento de redes GPRS.
No entanto, cada um de eles em geral avalia apenas poucos aspectos possíveis num cenário que suporta protocolos de transporte, principalmente TCP, sobre GPRS.
Web sobre GPRS considerando todas as camadas de protocolos envolvidas.
Tais resultados foram obtidos através de um simulador GPRS apresentado no mesmo trabalho.
O simulador desenvolvido por os autores é baseado no paradigma de simulações orientadas a eventos, e foi implementado utilizando a ferramenta Cadence Bones (Block Oriented Network Simulator), que suporta um sistema de modelagem hierárquico orientado por blocos.
Os autores realizam uma análise fim a fim, avaliando a vazão geral do sistema (no sentido downlink) para 30 usuários móveis.
O simulador utiliza o TCP Tahoe, com segmentos de 1460 bytes.
Para o GPRS, foi utilizada a configuração 4+ 1 para oito canais de dados GPRS (PDCH), variando o cenário de codificação (Cs-1 a Cs-4) e o C/ I.
O trabalho conclui que o GPRS é bastante apropriado para tráfego TCP/ IP.
Internet536 bytes).
Todas as medidas de vazão são analisadas no nível de aplicação, ou seja, todo o overhead ocasionado por os cabeçalhos dos protocolos, recuperação de erros e controle de fluxo (ex..
TCP slow) estão incluídos.
A vazão é definida por o tamanho do pacote de um objeto Www dividido por o seu tempo de transmissão.
Esta forma de cálculo é utilizada com objetivo de comparar os resultados para transmissão de objetos de diferentes tamanhos.
Foi demonstrado também por os autores, como um operador pode aumentar o desempenho de um sistema GPRS aumentando o número de canais de dados.
Os resultados confirmam as conclusões anteriores de que o GPRS é bastante apropriado para tráfego de informações de aplicações Internet.
Utilizando o simulador desenvolvido em, Meyer apresenta em (TCP Performance over GPRS) uma avaliação da harmonia entre o mecanismo ARQ (Automatic Repeat Request) do TCP e do GPRS (RLC).
Apenas um usuário transferindo arquivos longos foi estudado.
São utilizados 4 PDCHs e 4 timeslots no sentido downlink, variando o Cs e o C/ I.
O autor conclui que o ARQ da camada RLC é suficientemente rápido para retransmitir segmentos perdidos antes que ocorra um timeout no TCP.
Assim, usando o Cs apropriado para as condições do ambiente, não há perdas de segmentos TCP.
Aspectos relacionados à vazão geral do sistema e à taxa de pacotes de dados são simulador.
Tal trabalho possui dois objetivos.
O primeiro é avaliar a capacidade do sistema GPRS em termos de vazão sob diferentes condições de carga, variando o número de usuários e o número de timeslots (no sentido downlink) por usuário (1, 2 e 4), o C/ I (de 1 a 30 dB) e o cenário de codificação (Cs-1 a Cs-4).
O segundo é analisar a perspectiva do usuário ao utilizar GPRS como meio de acesso a web, observando a taxa de pacotes de dados recebida por o usuário.
Para as simulações apresentadas neste trabalho os autores utilizaram um modelo de tráfego na web.
Este modelo é divido em duas partes, o modelo do cliente e o modelo do servidor.
Enquanto o modelo do cliente determina o seu comportamento o modelo do servidor é responsável por a geração de tráfego.
O modelo de comportamento do usuário é composto de ações ativas (requisição de uma pagina) e ociosidade (ex..
Lendo informações de uma página), determinando o comportamento do usuário.
O Modelo do servidor leva em consideração o número de objetos (textos, ícones, figuras) de uma página web, e o tamanho de cada objeto.
Os autores concluem que, comparado à comutação por circuito (GSM), o GPRS é significativamente superior.
Em, o desempenho do SACK e Timestamps num sistema GPRS é estudado através da simulação da transferência de um arquivo de 512 Kbytes.
Para isto o TCP-Reno é utilizado.
Para simular um ambiente GPRS o autor utiliza o simulador baseado em eventos Cadence Bones.
Este modela a internet no simulador como um objeto com um delay e perda de pacotes cujos valores são definidos de forma randômica.
O Gateway GPRS Support Node (GGSN) é representado com um roteador, o Serving GPRS Support Node (SGSN) é modelado como um objeto com delay fixo, que representa o tempo de processamento desta camada.
A comunicação GGSN-SGSN e SGSN-BSS (Base Station Server) são modelados com atrasos fixos, que levam em consideração a capacidade dos links (2 Mbps e 64 Kbps respectivamente).
A estação móvel é modelada como um host TCP/ IP com as mesmas características de um host fixo.
Os parâmetros utilizados são:
4 canais de dados, Cs-4, C/ I de 24 dB e 15 usuários, sendo o segmento TCP de 431 bytes.
O trabalho conclui que a utilização do TCP-Reno com SACK resulta em melhor desempenho e que, apesar de melhorar o desempenho do TCP-Reno, o uso de TCP-Reno com Timestamps atrapalha a performance do Em um protocolo de transferência de informações para computação veicular (VITP) é apresentado.
O VITP é um protocolo que visa oferecer serviços através da comunicação entre veículos conectados através de redes sem fio, como condições das estradas, condições de tráfego, alertas de tráfego (acidentes de trânsito ou veículos danificados bloqueando tráfego), serviços de páginas amarelas (localização e lista de preços de postos de gasolina, localização e visualização de cardápios de restaurantes) utilizando muitas vezes informações de navegadores GPS no auxílio ao sistema de navegação de bordo.&amp;&amp;&amp;
O protocolo proposto por os autores possui uma especificação semântica e sintática de mensagens entre veículos, caracterizando um componente de software como proposta para realização de determinados serviços.
Um observador (VTIP PEER) armazena informações através de sensores localizados no veículo.
O observador estabelece uma dinâmica de grupo ad-hoc que coleta, comunica, e mesclam informações do sensor a bordo de diferentes veículos com objetivo de resolver uma solicitação encaminhada.
VITP é inspirado por o protocolo de transferência de hipertexto world wide web.
Logo após, os autores apresentam um cenário motivador, introduzindo o modelo de serviços do protocolo.
Em seguida, as especificações do protocolo são apresentadas.
Por último, uma simulação, através do simulador de redes Ns-2 é apresentada, utilizando- se um gerador de tráfego veicular para investigar a performance do protocolo num cenário realístico.
Os resultados das simulações executadas por o autor concluem que o protocolo VITP é viável para utilização em redes VANET devido a forma como este foi definido.
Em este capítulo foi fornecida uma visão geral do sistema que serve como base para geração dos cenários que serão simulados nos próximos capítulos deste trabalho.
Além de uma visão geral do sistema, foram descritos o pacote de transmissão de informações básicas de telemetria e o pacote de transmissão de informações avançadas de telemetria, tendo sido detalhado as informações contidas em cada pacote.
Esses pacotes serão trafegados sobre os diversos cenários gerados no simulador de redes Ns-2.
O funcionamento do sistema na ausência de sinal GSM/ GPS também foi descrito.
Foram abordados os protocolos de transporte TCP e UDP, sobre o qual os pacotes de transmissão de informações de rastreamento veicular serão transportados por a rede GPRS.
Por último, foram descritos alguns trabalhos relacionados, seus objetivos e suas limitações, servindo como material de base para a pesquisa realizada nesta dissertação.
Em o Capítulo 5, o ambiente de simulação utilizado para validação do modelo descrito será apresentado.
Este capítulo descreve as principais características e conceitos relacionados ao ambiente de simulação utilizado neste trabalho, o NetWork Simulator.
O módulo GPRS, implementado e instalado à parte, é descrito detalhadamente, sendo apresentados seus problemas e limitações, bem como as modificações realizadas para superar- los.
O Ns é um simulador que tem sido utilizado com grande freqüência em pesquisas em redes de computadores.
Atualmente o seu desenvolvimento é suportado por o DARPA (Defense Advanced Research Projects Agency, EUA) através do projeto SAMAN e por a NSF (National Science Foundation, EUA) através do projeto CONSER, em colaboração com outros pesquisadores como o centro ICIR.
O simulador já recebeu apoio do Lawrence Berkeley National Laboratory, do Xerox PARC (Palo Alto Research Center), da Universidade da Califórnia em Berkeley, Sun Microsystems e também agrega diversos módulos contribuídos por pesquisadores independentes.
É um software de código livre e fornecido gratuitamente.
Uma lista de discussão é mantida por os desenvolvedores, onde os pesquisadores de diversas partes do mundo podem trocar idéias e experiências, e também propor correções para o código do simulador, que depois de avaliadas podem ser incorporadas.
Estes pesquisadores, oriundos de países como Estados Unidos, Índia, Inglaterra, Itália e também Brasil, contribuem para o valor desta ferramenta.
O Ns é um simulador de eventos discretos, focado para o desenvolvimento de pesquisas em redes de computadores.
Ele prevê suporte a TCP e variantes do protocolo, multicast, redes sem fio (wireless), roteamento e satélite.
Tem facilidades de tracing, que é a coleta e registro de dados de cada evento da simulação para análise posterior.
Possui um visualizador gráfico para animações da simulação (nam ­ network animator), timers e escalonadores, modelos para controle de erros e algumas ferramentas matemáticas como gerador de números aleatórios e integrais para cálculos estatísticos.
Inclui também uma ferramenta de geração de gráficos, o xgraph, e vários tipos de geradores de tráfego.
O Ns foi desenvolvido na linguagem orientada a objetos C+, de forma modular.
O uso desta linguagem nos módulos confere velocidade e mais praticidade na implementação de protocolos e modificação de classes.
A interface com o usuário, configuração, estabelecimento de parâmetros e manipulação de objetos e classes é feita em modo texto, através da linguagem interpretada Otcl, que também é orientada a objetos.
A interface entre o usuário e o Ns dá- se através da linguagem script Otcl.
Segundo os desenvolvedores, a divisão em duas linguagens (Otcl e C+) objetiva dar ao simulador tanto velocidade e poder, quanto flexibilidade e facilidade de mudança de parâmetros.
O núcleo do simulador é escrito em C+, conferindo velocidade, mas esta linguagem torna- se lenta para manipulação constante ou mudança de parâmetros.
Otcl, por ser interpretada, é bem mais lenta, porém pode ser facilmente alterada.
Além de o mais, os objetos compilados são disponibilizados para o interpretador Otcl por linkagem, o que virtualmente cria um objeto Otcl para cada objeto C+, e que podem ser manipulados através das facilidades da Otcl.
A Figura 15 mostra a construção geral do Ns.
Um usuário comum atua no perímetro &quot;tcl», escrevendo scripts em Otcl e executando simulações.
Os escalonadores de eventos e os componentes de rede são implementados em C+ e disponibilizados ao interpretador Otcl através de uma replicação feita por a camada tclcl, que recria os objetos C+ em objetos Otcl, e que podem finalmente ser manipulados por esta última (processo denominado linkage).
Todo o conjunto constitui- se no Ns, que é um interpretador de Otcl com bibliotecas de simulação para redes de computadores.
De forma a realizar uma simulação no Ns é necessário, primeiramente, escrever um script em Otcl.
Este script contém as seguintes partes básicas:
O processo de simulação pode ser assim resumido:
Confecção do script (arquivo texto comum);
Após concluída a simulação:
Imprimir estatísticas calculadas no script;
Um ponto importante a observar é que o Ns não fornece estatísticas de simulação de modo automático;
Estas devem ser obtidas através de procedimentos matemáticos no script ou por a manipulação de objetos especiais chamados monitores.
Pode- se, ainda, usar ferramentas para análise dos arquivos de tracing gerados durante a simulação, que são os verdadeiros resultados da simulação, estes arquivos com formatação específica registram cada evento gerado por os escalonadores.
As ferramentas para análise dos arquivos de tracing devem então ser capazes de ler os dados gravados nestes arquivos e efetuar os cálculos desejados.
Uma destas ferramentas, muito utilizada, é o awk, uma linguagem projetada para buscar padrões dentro de um arquivo e efetuar ações programadas.
O animador nam pode também ser usado para analisar visualmente a simulação e obter algumas estatísticas, mas ele não é apropriado para análises mais profundas.
Se nada for feito, o simulador apenas rodará o script, gerará os arquivos de saída (tracing) e encerrará, sem nada mostrar ao usuário.
Em primeiro momento, esta característica um tanto não-amigável e não imediatista do Ns pode frustrar o usuário iniciante.
Entretanto, essa é a realidade de bom número dos simuladores existentes na categoria do Ns, que não foram feitos com ótica didática.
O modelo wireless consiste essencialmente no MobileNode (mobilenode_ H), com características adicionais que permite simulações de redes ad-hoc multi-hop, LANs wireless etc..
Um nó móvel é derivado do nó básico o Node (node_ H) com funcionalidades adicionadas de um nó wireless e mobilidade como a habilidade de mover- se dentro de uma dada topologia, habilidade de receber e transmitir sinais a partir de um canal wireless etc..
Uma diferença principal entre eles, é que um host móvel não está conectado por meio de links a outros hosts ou host móvel.
Em a criação de um objeto MobileNode é especificado a criação de um agente de roteamento, cria a pilha de rede consistindo de uma camada de enlace (link layer), camada mac e uma interface de rede com uma antena, interconectando estes componentes e conectando a pilha ao canal de comunicação, ilustrado na Figura 17.
Em o Ns, os protocolos principais, os elementos de topologia, as ações de processamento de pacotes, entre outros, são escritos em arquivos separados na linguagem C+.
Estes arquivos são agrupados através da linguagem Otcl na construção de um simulador.
Um nó sem fio é criado de maneira diferente de um nó fixo.
Este possui uma estrutura em camadas e uma pilha de rede, como mostra a Figura 16.
Este tem a capacidade de se mover numa determinada topologia de rede, além de enviar e receber dados de um canal sem fio.
As características de mobilidade de um nó incluem sua movimentação (baseado em duas posições dimensionais), alteração periódica de sua posição e gerenciamento de limites.
A pilha de rede de um nó wireless é descrita a seguir:
Link Layer (LL) é responsável por simular o protocolo da camada de conexão dos dados.
Esta fixa o endereço MAC do destino no cabeçalho Mac do pacote.
Atualmente, esta camada simplesmente envia e recebe os pacote Mac.
Esta possui também um módulo ARP que transforma um endereço IP para um endereço de maquina (Mac address).
Address Resolution Protocol (ARP).
Se o ARP possui o endereço de maquina do destino é gravado no cabeçalho Mac do pacote, senão este realiza um pedido de resolução de endereço e armazena o pacote temporariamente.
Para cada destino não encontrado, existe um espaço em memória onde apenas um pacote é armazenado.
Se algum outro pacote com o mesmo destino for recebido à memória é sobrescrita.
Interface Queue (IFQ).
Esta camada implementa uma fila de prioridades, que fornece prioridade para pacotes de roteamento do protocolo na fila e pode de forma seletiva remover pacotes de um certo destino.
Medium Access Control (MAC) Layer.
Atualmente implementado no Ns existem os padrões 802.11 e 802.3, CSMA e multihop (IEEE).
Network Interface (NETIF) é usada por o nó móvel para obter acesso a um canal de dados.
A interface wireless compartilhada é implementada como Phy/ WirelessPhy.
Esta interface é sujeita a colisões e recebe pacotes através do modelo de propagação via rádio.
O cabeçalho do pacote possui informações relacionadas à interface de transmissão, como a corrente (força) utilizada na transmissão, amplitude da onda, etc..
Esta informação é utilizada por o modelo de propagação para determinar se um pacote possui força suficiente para ser recebido.
O modelo aproxima- se da interface da radio DSSS (Lucent WaveLan DirectSequence Spread Spectrum).
Radio Propagation Model.
Este usa 1/ r2 para distâncias pequenas e uma aproximação do modelo two-ray-- ground para distâncias longas.
Um nó móvel é criado de acordo com o protocolo de roteamento ad-hoc que este irá usar.
Este é configurado para ter as tabelas e estruturas de dados apropriadas.
O simulador Ns suporta DSR, DSDV, AODV e Tora.
Estes, por padrão, podem se comunicar com todos outros nó móveis que tenham alcance.
Se um nó móvel deseja comunicar- se com outro nó de uma rede fixa, este pode realizar a comunicação conectando- se a uma estação base.
Uma estação base é implementada como um nó móvel no Ns mas com protocolos de roteamento de redes fixas e mobilidade desativada.
Isto é feito no nível de programação Otcl em ns /tcl/lib/ns-bsnode.
Tcl. Roteamento hierárquico deve ser utilizado com partes fixas e sem fio dispostas em domínios diferentes.
Dois ou mais nós móveis ainda podem se comunicar, porém será necessário o uso de uma estação base para se comunicarem com um nó fixo.
Este processo funciona perfeito com o padrão Mac 802.11 mas não para o GPRS.
Para um cenário de comunicação GPRS, é necessário que cada estação móvel (MS) converse apenas com sua estação base (Bs), e não com qualquer outra MS.
Isto implica que não poderá ser utilizado um configuração ad-hoc padrão para nós móveis fornecida por o Ns.
Ao invés de isso, o agente de roteamento não ad-hoc (NOAH) construído por Joerg Widmer foi utilizado.
Este cria um nó móvel simples (sem tabelas de roteamento, sinalização, normalmente criado por os nodos dsr/ dsdv) que pode se comunicar apenas com sua estação base (Bs).
O NOAH envia e recebe todos os pacotes através de sua Bs.
De forma inerente ele necessita o uso do roteamento hierárquico do Ns.
De este modo, um nó NOAH pode ser Em o próximo capítulo será descrito o Modulo GPRS, extensão utilizada no Ns, para tornar possível a simulação do protocolo sobre a rede GPRS.
O módulo do GPRS foi desenvolvido por Richa Jain no Indian Institute of Technology -- Bombay.
Sua implementação focaliza a interação MS-BS e abrange as camadas referentes à interface aérea da especificação.
Um nó móvel no Ns apresenta a pilha de protocolos de rede ilustrada na Figura 18.
Os componentes dessa pilha são brevemente descritos a seguir. --
Link Layer (LL):
Responsável por a simulação dos protocolos de link de dados, esse componente altera o endereço MAC do destino no cabeçalho MAC do pacote.
Atualmente, ele simplesmente passa pacotes de/ para a MAC.
Em um nó móvel, apresenta um módulo ARP conectado a ele que resolve as conversões de endereços IP em endereços MAC. --
Address Resolution Protocol (ARP):
Este componente recebe consultas da camada LL.
Se o endereço MAC já constar na sua tabela (ARP table), ele escreve o endereço no cabeçalho MAC do pacote.
Caso contrário, ele envia um ARP Request e armazena temporariamente o pacote.
Para cada destino desconhecido, há espaço para armazenar apenas um pacote.
Assim, ao chegar um novo pacote para o mesmo destino, o pacote anterior é sobrescrito.
A o receber a resposta com o endereço MAC do destino, o pacote é inserido na fila (IFQ). --
Interface Queue (IFQ):
Implementa uma fila de prioridades, a qual dá prioridade a pacotes de protocolos de roteamento, inserindo- os no início da fila.
Também permite o uso de filtros sobre os pacotes na fila e remove aqueles que possuem um destino específico. --
Medium Access Control Layer (MAC):
Atualmente implementa IEEE 802.
11 e 802.3, CSMA (Carrier Sense Multiple Access) e multihop. --
Network Interface (NetIF):
É utilizado por o nó móvel para acessar o canal.
Essa interface é sujeita a colisões e recebe pacotes através do modelo de propagação de rádio. --
Radio Propagation Model:
Implementa o modelo 1/ r2 para distâncias pequenas e 1/ r4 (modelo two-ray-- ground) para distâncias longas. --
Wireless Channel: Simula a transmissão real do pacote na camada física.
Implementa um meio compartilhado com suporte a mecanismos de contenção.
Se mais de uma transmissão ocorre ao mesmo tempo, é sinalizada uma colisão, que pode ser tratada por a camada MAC.
O módulo GPRS incrementa a camada LL, adiciona a camada RLC (Radio Link Control) à pilha e cria uma nova versão para a MAC, específica para o GPRS.
A pilha modificada pode ser visualizada na Figura 19.
As modificações, assim como o novo componente, são descritas a seguir.
A camada LL do ns foi modificada por o módulo GPRS, sendo incluídos fragmentação de pacotes e modo com confirmação.
Em o modo com fragmentação, os pacotes recebidos do agente transmissor são segmentados antes de serem passados para a RLC e são reagrupados no outro lado, antes de serem entregues ao agente receptor.
O modo com confirmação implementa um mecanismo de retransmissão stop-and-wait.
Assim, se um pacote (LLC PDU) é perdido ou recebido com erro, o receptor &quot;pára e espera «que esse pacote seja reenviado, mandando um ACK para sinalizar qual o pacote esperado.
Qualquer outro pacote recebido é ignorado.
Este componente implementa a camada de link de rádio e, assim como a LL, inclui fragmentação de pacotes e modo com confirmação.
Em o modo com fragmentação, os LLC PDUs são segmentados em RLC PDUs, sendo transmitido um RLC PDU por quadro.
O modo com confirmação implementa um mecanismo ARQ (Automatic Repeat Request).
Se um fragmento é perdido, um ACK duplicado do último fragmento recebido corretamente é enviado e os fragmentos seguintes são armazenados.
A o chegar o fragmento que estava faltando, este é colocado na ordem (isto é, na frente de os fragmentos que o sucedem).
Os fragmentos são passados adiante apenas quando todos os fragmentos que compõem um LLC PDU chegarem.
Em o modo sem confirmação, se faltar um fragmento do LLC PDU, nenhum fragmento é passado adiante.
Em esse caso, a LL se encarrega de retransmitir o LLC PDU (se estiver em modo com confirmação) ou deixa sob a responsabilidade da camada superior (por exemplo, A MacGprs implementa a divisão da interface aérea em canais, a alocação desses canais, a transmissão de pacotes (fragmentos RLC) e de mensagens de sinalização nos sentidos downlink e uplink, e um modelo de erros randômico.
Para formar os canais, a interface aérea é dividida em freqüências FDMA e cada freqüência dividida em quadros TDMA, compostos por oito timeslots.
Um canal consiste num par freqüência/ timeslot.
O número de freqüências pode ser estabelecido por o usuário e determina a quantidade de canais uplink e downlink a serem criados.
O slot 0 de cada freqüência (nos dois sentidos) é reservado para sinalização e broadcasts.
O usuário também pode decidir quantos slots por freqüência (PDCHs) são reservados para serviços GPRS.
O restante fica disponível para serviços GSM.
Cada quadro TDMA é composto por oito timeslots, em os quais cada slot tem duração de 577 microssegundos.
O início e o fim de cada slot é marcado por um timer, havendo um timer distinto para cada sentido (uplink e downlink).
Como determinado por a especificação (vide Seção 2.7), um quadro TDMA no sentido uplink é iniciado com um atraso de três timeslots do início de um quadro TDMA no sentido downlink.
Os quadros TDMA, em ambas as direções, deveriam ser sincronizados na MS e na Bs.
Mas um atraso finito de propagação entre a MS e a Bs causa um desencontro entre eles, impedindo a sincronização.
Assim, o relógio da MS deve ser adiantado o tempo desse atraso para que a sincronização ocorra.
Contudo, para simplificar o código nessa implementação, esse atraso foi considerado nulo.
Baseada no mecanismo ALOHA, a MAC é responsável por a alocação de canais, em a qual cada MS pode alocar apenas um canal (ou seja, não foi implementado multislot).
A alocação nos sentidos uplink e downlink é simétrica, sendo realizada através da troca de mensagens.
A o receber da sua fila (IFQ) um pacote para transmitir, a MS solicita um canal enviando uma Resource Request.
Quando recebe essa mensagem, a Bs aloca um canal (se houver algum disponível) e retorna uma Resource Reply, informando à MS qual o canal alocado.
Tanto a Bs quanto a MS armazenam essa informação para uso posterior.
A Bs pode alocar um canal para uma MS sem que esta tenha solicitado.
Isso ocorre quando a Bs recebe da sua fila um pacote destinado a uma MS que não tem canal alocado.
Em esse caso, a Bs aloca o canal e envia uma Resource Reply para a MS.
Após um determinado período de ociosidade (isto é, sem transmissão em qualquer direção), a MS solicita a liberação do canal através da mensagem Resource Release.
A MAC também implementa um modelo de erros para validar o modo com confirmação da camada RLC.
O modelo marca randomicamente um pacote (isto é, um fragmento RLC) como errado, resultando no seu descarte ao chegar ao destino.
A utilização do módulo GPRS apresenta algumas dificuldades iniciais.
A primeira dificuldade consiste na sua instalação.
O pacote de instalação do módulo não possui nenhum arquivo que explique como instalar- lo.
Além disso, faltam no pacote arquivos de um outro módulo, denominado NOAH (Non Ad-hoc Routing Agent), que é utilizado por o módulo GPRS.
Assim, faz- se necessário primeiro instalar o módulo NOAH, que apresenta um manual de instalação passo a passo.
A segunda dificuldade encontrada se deve à ausência de transparência de ambos os módulos.
A instalação de eles modifica de forma inconseqüente arquivos que são utilizados por outras classes do Ns.
Um módulo bem estruturado deveria ser transparente para o resto do código.
Contudo, isto não acontece.
Após a instalação dos módulos GPRS e NOAH, à parte wireless do Ns não funciona mais.
Assim, foi necessário o isolamento dos módulos.
Em outras palavras, todos os arquivos modificados por esses módulos que são compartilhados por outros tiveram que ser alterados de forma que o ns voltasse a funcionar exatamente como antes da instalação desses módulos.
Outra dificuldade é a falta de documentação detalhada.
O módulo contém um resumido manual em formato Html que o descreve de forma complexa.
Várias leituras ao manual são necessárias para que se possa entender o funcionamento do módulo.
Há também a dissertação de mestrado de Richa Jain.
O módulo GPRS é resultado de seu trabalho de mestrado.
Porém a dissertação não acrescenta muita informação ao conteúdo do manual.
De este modo, o entendimento do código, pouco comentado, torna- se custoso.
O módulo GPRS propriamente dito apresenta vários problemas e limitações.
Entre suas limitações, podem ser citadas: --
Implementação restrita à interface aérea:
Apenas a interação entre o nó móvel (MS) e a estação rádio- base (BSS) é tratada.
Os outros elementos da rede GPRS, como SGSN, GGSN e HLR, não estão implementados.
Assim, mecanismos de handovers e QoS não podem ser estudados. --
Restringe a rede a uma única célula:
Por apresentar variáveis estáticas, apenas uma Bs pode ser criada. --
Não permite a criação de mais de uma rede GPRS:
Uma vez que as variáveis da Bs são estáticas, se outra rede (e conseqüentemente outra Bs) for criada, essas variáveis serão compartilhadas por as duas, havendo sobreposição de informações. --
O modo com confirmação limita o número de MSs:
Tanto na camada RLC como na LLC, o módulo com confirmação restringe o número de estações móveis a 1. --
Não implementa multislot:
Cada MS pode alocar apenas um canal. --
Desenvolvido para uma versão antiga do ns:
A versão 2.1b7a.
Algumas dessas limitações foram superadas no trabalho atual e serão discutidas na próxima seção.
Além de as limitações, descritas no próprio manual do módulo, foram encontrados vários problemas no código, os quais envolvem erros lógicos de implementação e falta de concordância com a especificação do GPRS.
Tais problemas produziam resultados errados e, portanto, tiveram que ser resolvidos para que o módulo pudesse ser utilizado.
A seguir são listados os problemas resolvidos no presente trabalho cuja solução será descrita na próxima seção: --
vazão de chegada maior que a de saída; --
a combinação de certos parâmetros tornava a vazão nula; --
mecanismo de alocação de canais com falhas; --
vazamento de memória; --
modelo de erros só aplicado no sentido downlink; --
MS e Bs não eram separadas; --
fila única da Bs compartilhada por todas as MSs; --
a transmissão dos blocos RLC não estava de acordo com a especificação; --
o modo com confirmação da camada RLC não estava de acordo com a especificação; --
buffers ilimitados (pequeno vazamento de memória); --
timers desnecessários utilizados (problema de desempenho).
A seguir, serão descritos detalhadamente cada um dos problemas citados acima e as soluções encontradas.
Esta seção descreverá as modificações realizadas no módulo GPRS a fim de tornar- lo mais confiável e mais próximo de a especificação.
Para uma melhor compreensão, cada problema citado na seção anterior será detalhado, seguido da solução aplicada para reparar- lo.
Utilizando os mesmos parâmetros contidos no script exemplo que acompanha o módulo, foram realizados testes para verificar a vazão alcançada por o módulo GPRS.
Anexando uma fonte CBR a uma estação móvel, detectou- se que o destino recebia uma quantidade de bytes maior que a quantidade enviada.
O problema consistia na inclusão indevida de um cabeçalho IP realizada por o módulo NOAH.
Retirando essa linha de código, a quantidade de bytes enviada tornou- se igual à quantidade recebida.
Para entender melhor o funcionamento do módulo, os parâmetros das camadas RLC e LL foram variados.
Descobriu- se que determinadas combinações de parâmetros tornavam a vazão nula.
Isso ocorria devido a falhas no código que se tornavam visíveis apenas em algumas situações.
Um exemplo é a alocação de canais que, em alguns casos, libera o canal errado mas, dependendo da combinação de parâmetros utilizada, consegue transmitir sem que esse erro seja percebido observando- se apenas a vazão.
Esse e outros exemplos serão detalhados adiante.
A alocação de canais demonstrou instabilidade devido a alguns casos não tratados.
O ponto principal, motivo que acarreta nos outros problemas, consiste na &quot;liberação por partes».
Tanto a MS quanto a Bs possuem variáveis que armazenam o canal alocado.
A o solicitar a liberação do canal (enviando uma mensagem Resource Release), a MS já considera seu canal liberado, reinicializando sua variável.
Mas a Bs só liberará o canal quando receber a Resource Release.
Assim, o período compreendido entre o envio da mensagem (por a MS) e o seu recebimento (por a Bs) apresentam inconsistência, uma vez que, durante esse intervalo de tempo, a MS considera não ter mais canal reservado para ela, enquanto a Bs ainda considera o canal alocado.
Essa brecha permite o surgimento de alguns problemas.
O primeiro problema ocorre quando o modelo de erros é usado.
Se a mensagem Resource Release fosse marcada como errada e, conseqüentemente, descartada, a Bs não liberava o canal.
Isso causava dois comportamentos indesejados.
Em um caso, a Bs recebia pacotes para a MS e enviava no canal que ainda considerava alocado para a mesma.
Contudo, como a MS já havia liberado seu canal, ela não recebia o pacote (pois são recebidos apenas mensagens de sinalização e broadcast ou pacotes que se destinam a ela e que foram transmitidos no canal reservado).
Em outro caso, a MS recebia um pacote para transmitir e, como não possuía mais canal alocado, solicitava um novo canal.
A o receber tal solicitação (Resource Request), a Bs reservava um novo canal para a MS, ficando, então, dois canais reservados, mas apenas um sendo utilizado.
Quando a taxa de erros era muito grande, isso ocorria com bastante freqüência, ficando vários canais ociosos alocados para uma mesma MS.
Por simplicidade, a solução adotada foi o não descarte de mensagens de sinalização, ou seja, mensagens de sinalização (que incluem o Resource Release) nunca são marcadas por o modelo de erros.
O segundo problema identificado foi à liberação de canais errados.
A o receber um Resource Release, a Bs liberava o primeiro canal alocado para a MS, pois este deveria ser o único.
Contudo, como já foi descrito acima, havia situações em que durante um curto espaço de tempo a MS possuía dois (ou mais) canais reservados, apesar de estar ciente de apenas um de eles.
O algoritmo de alocação de canal é o mais simples possível:
Aloca- se o primeiro canal disponível.
Inicialmente, canais eram alocados na seqüência.
Porém, após um determinado tempo de simulação, ocorria à liberação de canais.
Logo, surgiam &quot;buracos «na seqüência, ou seja, existiam canais livres intercalados com canais reservados.
Assim, aconteciam situações em que, havendo um canal reservado para uma MS (por ainda não ter recebido sua mensagem de liberação), a Bs reservava um novo canal para a MS, onde o novo canal encontrava- se antes do antigo na ordem de precedência (por exemplo, o novo canal era o par freqüência 1/s lot 5 e o antigo, o par freqüência 3/s lot 2).
Então a Resource Release chegava à Bs e esta liberava o primeiro canal alocado para a MS, que, neste caso, era o canal novo, isto é, o canal que estava sendo utilizado.
Apesar de o conceito empregado estar errado (uma vez que a origem transmitia num canal e o destino recebia em outro), em algumas combinações de parâmetros essa situação funcionava, ou melhor, havia transferência normal de pacotes.
Um exemplo seria quando a MS estivesse transmitindo para a Bs com as duas camadas de link (RLC e LL) no modo sem confirmação.
Mas se a transmissão fosse no sentido contrário ou uma das duas camadas estivesse em modo com confirmação, a vazão tornava- se nula.
Como, mesmo no caso em que funcionava, a lógica estava errada, a solução encontrada para esse problema foi incluir na mensagem de Resource Release os dados do canal a ser liberado (isto é, freqüência/ slot), evitando, assim, a liberação do canal errado.
Outro problema não tratado era a falta de canais disponíveis.
Dependendo do número de freqüências utilizadas e da quantidade de MSs, ocorria de não haver canais livres para serem alocados.
Quando a Bs não encontrava nenhum canal disponível, ela simplesmente não alocava nenhum canal, o que estava correto.
Contudo, uma mensagem Resource Reply, com valores aleatórios nos campos &quot;freq «e &quot;slot», era enviada.
Além de ocorrerem casos em que uma MS estava usando o canal reservado para outra, havia também casos em que os valores aleatórios estavam fora de o intervalo válido, o que gerava acesso indevido de memória e conseqüente &quot;falha de segmentação».
A solução adotada consiste em enviar uma Resource Reply apenas quando um canal for alocado.
O módulo GPRS apresentou um grande vazamento de memória, o qual se encontrava na camada MAC e foi herdado da MacTDMA, em a qual a MacGPRS se baseia.
A interface aérea do Ns, implementada por a camada Channel, é compartilhada por todas as redes sem fio.
A o receber um pacote, essa camada manda uma cópia deste para cada nó móvel.
Cabe ao nó identificar se o pacote é destinado a ele e, em caso negativo, descartálo.
Assim como a MacTdma, a MacGprs não descartava os pacotes que não lhe pertenciam.
Esses pacotes eram simplesmente ignorados.
De essa forma, quanto mais nós móveis houvessem numa simulação e quanto maior fosse o tráfego gerado, maior era a quantidade de memória desperdiçada, pois para cada pacote enviado, eram geradas n cópias (onde n representa o número de MSs) e n-1 destas eram ignoradas, acumulando memória.
Esse vazamento foi solucionado liberando essas cópias.
Além desse vazamento principal, haviam outros vazamentos menos significativos.
Em vários pontos do código, nas três camadas, pacotes que não eram mais utilizados eram simplesmente ignorados, acumulando memória por não serem liberados.
Como exemplo, podem ser citados os pacotes de sinalização da MAC e os ACKs das camadas LL e RLC, os quais são criados no transmissor e não eram liberados no receptor.
Cada caso desses foi identificado e o problema solucionado, ou seja, todos os pacotes não mais utilizados agora são liberados.
O modelo de erros estava sendo aplicado apenas no sentido downlink.
A solução seria simplesmente aplicar o modelo também no sentido uplink.
Porém, uma vez que o modelo de erros era muito simples, optou- se por mudar- lo, tornando- o mais próximo de o real.
O modelo de erros atualmente implementado consiste na utilização de uma tabela com valores de block error rate (BLER) pré-calculados, fornecida por a Ericsson e adotada em, e.
O cenário assumido para a geração da tabela foi um canal urbano (Typical Urban Channel -- Tu) com usuários s imentando a 50 km/ h..
A Tabela 8 mostra os valores de BLER utilizados.
Esses valores estão em função de a taxa de carrier- to interface (C/ I) e do cenário de codificação.
A taxa C/ I indica as condições do ambiente, isto é, indica se a estação móvel está sob alta, média ou baixa interferência.
Como pode ser observado na tabela, quanto menor o valor de C/ I, maior a taxa de erros, ou seja, maior a interferência.
O modelo funciona da seguinte forma.
Cada nó possui um Cs e um C/ I, os quais são determinados no início da simulação.
A o receber um pacote, o nó sorteia um valor aleatório entre 0 e 1, utilizando uma distribuição Normal.
Esse valor é comparado então ao valor da tabela BLER que é obtido utilizando o Cs e o C/ I do nó.
Se o valor sorteado for menor ou igual ao BLER coletado, o pacote é marcado como errado e, posteriormente, descartado.
Um problema que gerou vários outros consiste na ausência de separação entre a Bs e a MS.
As duas deveriam apresentar estruturas diferentes, pois a Bs possui vários atributos que não se aplicam à MS, ou seja, deveriam ser classes diferentes.
Contudo, as duas contêm os mesmos atributos e a diferenciação entre elas é feita utilizando variáveis estáticas, sendo estas utilizadas apenas por a Bs.
Além de ferir o conceito de orientação a objetos, essa abordagem trouxe outros problemas, como a limitação do número de BSs por rede e de redes GPRS por cenário:
Apenas uma rede com uma única Bs pode ser utilizada num cenário.
Isso ocorre porque, dado que as variáveis são estáticas, é criada apenas uma variável por classe.
Logo, se fossem criadas duas redes GPRS, as BSs compartilhariam os atributos estáticos, havendo sobreposição de dados nesses atributos.
Este problema foi resolvido eliminando as variáveis estáticas e separando parcialmente as estruturas da Bs e da MS.
O código atual permite a criação de mais de uma rede GPRS.
E, apesar de não haver mais limitações no código com relação a o número de BSs por rede (isto é, poderiam ser utilizados mais de um objeto Bs sem maiores dificuldades), apenas uma Bs continua sendo utilizada por não haver ainda a implementação do BSC (Base Station Controller), responsável por gerenciar mais de uma Bs, tratando, por exemplo, do mecanismo de handovers.
Como visto no tópico anterior, o módulo do GPRS não fazia distinção clara entre a Bs e a MS.
Assim, o comportamento das duas em muitos casos era semelhante.
Um desses casos era o tratamento dos pacotes a serem transmitidos.
Entre as camadas RLC e MAC, há uma fila de prioridades que mantém os pacotes vindos da RLC.
A MAC recebe da fila e processa apenas um pacote por vez, recebendo o próximo pacote após enviar o pacote atual.
Em um nó normal, isto é, uma MS, este comportamento é adequado.
Contudo, numa Bs não.
Porque isso significa que a Bs só processará e transmitirá um pacote por vez, quando, na prática, pode transmitir em várias freqüências ao mesmo tempo.
Assim, decidiu- se criar filas separadas por canais (par freqüência/ slot), permitindo que a Bs possa transmitir em todas as freqüências simultaneamente.
Em a implementação original do módulo, um fragmento RLC era transmitido num único quadro.
De acordo com a especificação, um bloco RLC deve ser transmitido em quatro quadros consecutivos.
Então, considerando que um fragmento corresponde a um bloco RLC, um fragmento deveria ser transmitido em quatro quadros.
Por default, um fragmento possui 50 bytes.
O número de bytes de dados úteis de um bloco RLC depende do cenário de codificação (Cs) utilizado (vide Seção 2.7.4).
O Cs-4 permite a transmissão de 51 bytes de dados por bloco.
Assim, pode- se considerar que, na implementação original, a taxa de dados máxima atingida deveria ser próxima da taxa do CS4:
21,4 kbps.
Contudo, uma vez que um bloco era transmitido num único quadro, a taxa alcançada era aproximadamente 4 vezes maior que a taxa do Cs-4.
Esse erro foi corrigido e a implementação atual encontra- se em conformidade com a especificação, ou seja, a transmissão de um bloco RLC dura quatro quadros.
Em o módulo GPRS original, o modo com confirmação da camada RLC funcionava da seguinte forma.
Um pacote (fragmento) era enviado e guardado num buffer, para uma possível retransmissão.
Cada pacote era numerado para tornar possível a preservação da ordem dos pacotes no destino.
A o receber um pacote, o destino enviava um ACK do último pacote recebido corretamente, exceto se o pacote já tivesse sido recebido (isto é, se seu número fosse menor que o número do pacote esperado).
Se algum fragmento fosse perdido ou recebido com erros, os fragmentos seguintes eram armazenados num buffer até que o segmento que estava faltando fosse recebido.
O transmissor podia enviar até 64 segmentos sem receber nenhum ACK.
Após este valor, ele parava de transmitir e esperava receber um ACK.
Passado um determinado tempo sem receber nenhum ACK, o transmissor reenviava o último pacote transmitido.
Após três reenvios, o transmissor desistia de enviar pacotes e permanecia esperando por um ACK.
O mesmo acontecia no receptor quando este não recebia nenhum pacote durante um certo tempo.
O último ACK era retransmitido três vezes e, depois disso, o receptor ficava parado esperando um pacote.
Pode- se perceber que ocorriam casos em que os dois lados paravam, tornando a vazão nula.
Inicialmente, trabalhou- se sobre este modo da forma como estava implementado, consertando os casos em que a vazão era reduzida a zero.
Contudo, depois foi observado que algumas partes dessa implementação não estavam de acordo com a especificação.
A especificação determina que um ACK consiste num mapa de bits com 128 elementos, onde cada bit indica o estado de cada bloco transmitido na janela.
Além disso, um ACK deve ser enviado quando solicitado por o transmissor (por exemplo, quando a janela está completa) e ao receber o último bloco de uma seqüência.
Quando a janela fica completa, o transmissor deve parar de enviar blocos novos e começar a retransmitir os blocos não reconhecidos, avisando que a janela está cheia e que necessita de um ACK.
Comparando com a implementação original do módulo, não é difícil notar que este não seguia a especificação:
Um ACK continha apenas o número do último pacote recebido corretamente;
Era enviado um ACK cada vez que um pacote novo era recebido e, ao completar a janela, apenas o último pacote transmitido era reenviado, e apenas três vezes.
Assim, o modo com confirmação da camada RLC foi remodelado, e, atualmente, encontra- se de acordo com a especificação.
A RLC armazena os pacotes (fragmentos) a serem enviados num buffer.
Depois percorre esse buffer, passando para a IFQ os pacotes enquanto houver espaço na janela.
Se a janela estiver completa, os pacotes seguintes permanecem no buffer, até que haja espaço na janela para transmitir- los.
Em a implementação original do módulo, o buffer não possuía limite de tamanho.
Assim, quando a taxa de transmissão da origem era muito superior à alcançada por o GPRS (ou seja, RLC recebia muito mais pacotes do que podia transmitir), o buffer continuava crescendo de forma ilimitada.
Isso gerava um consumo exagerado de memória durante a simulação.
Além disso, considerando que uma estação móvel possui, na realidade, uma pequena quantidade de memória, não faz sentido armazenar milhares de pacotes.
Decidiu- se então limitar o buffer para armazenar dois LLC PDUs, eliminando o uso desnecessário de memória.
A camada LL também armazena os pacotes a serem transmitidos.
Apesar de não ter sido observado armazenamento excessivo de pacotes, como no caso de a RLC, optou- se por prevenir tal situação, limitando também seu buffer para armazenar apenas dois pacotes recebidos da camada superior.
O início e o fim de cada slot é marcado por um slotTimer.
Os slots no sentido downlink são delimitados por o downslotTimer e no sentido uplink é usado o upslotTimer.
Cada nó precisa estar ciente do slotTimer no sentido em o qual transmite, uma vez que a transmissão é realizada durante o slot que possui o canal apropriado para a transmissão.
Contudo, a recepção não está vinculada ao slotTimer no sentido oposto.
Em outras palavras, o receptor não verifica o slot atual para saber se deve ou não receber o pacote.
Logo, não é necessário que um nó tenha conhecimento do slotTimer no sentido em o qual recebe.
Em a implementação original do módulo, cada nó possuía os dois slotTimers.
Visto que um nó não utiliza os dois, na implementação atual o slotTimer desnecessário foi eliminado, havendo ganho no desempenho.
Assim, cada nó possui apenas o slotTimer no sentido em o qual transmite.
Isto é, a Bs apresenta apenas o downslotTimer enquanto a MS possui apenas o upslotTimer.
Além de as modificações realizadas no módulo original, algumas características foram adicionadas ao módulo GPRS visando tornar- lo mais próximo de a especificação.
As principais adições realizadas serão descritas a seguir.
O módulo do GPRS não apresentava nenhum cenário de codificação na camada RLC.
O manual do módulo diz que foi utilizada uma carga útil de dados de 50 bytes por fragmento RLC, simulando o tamanho médio de dados enviados por a RLC.
Como visto anteriormente (Seção 4.3.7), essa implementação estava errada, pois gerava uma taxa de transmissão irreal, aproximadamente quatro vezes maior que a taxa obtida com o Cs-4.
Buscando tornar o módulo mais próximo de o real, foram implementados os quatro cenários de codificação.
Cada fragmento representa um bloco RLC, transmitido em quatro quadros consecutivos, e a quantidade de dados (bytes) enviados por bloco é determinada por o Cs escolhido.
Os valores podem ser observados na Tabela 1, na Seção 2.7.4.
O GPRS permite que um usuário use mais de um timeslot em paralelo nos sentidos downlink e uplink.
Quanto mais slots o usuário puder usar ao mesmo tempo, maior será sua taxa de transmissão.
Teoricamente podem ser utilizados os oito timeslots em paralelo, contudo na prática são usados no máximo cinco, sendo as configurações indicadas 1+ 1, 2+ 1, 4+ 1, 1+ 2, 1+ 4.
O módulo do GPRS original implementa apenas a configuração 1+ 1, isto é, um timeslot por usuário nos dois sentidos.
Essa configuração limita a taxa máxima a aproximadamente 21,4 kbps utilizando Cs-4.
Visto que, na prática, pode- se utilizar mais de um timeslot no sentido downlink/ uplink, decidiu- se implementar o conceito de multislot, ou seja, agora é possível escolher o número de slots por usuários.
Esse capítulo descreveu o ambiente de simulação utilizado e modificado nesse trabalho.
Inicialmente, foi realizada uma breve descrição do Network Simulator (Ns), abrangendo sua origem e suas características.
Entre estas, encontra- se o fato do Ns ser código aberto, o que permite sua modificação e possibilita que outros pesquisadores contribuam com melhoramentos no código existente e desenvolvimento de novos módulos.
O módulo GPRS, que representa uma dessas contribuições, foi apresentado, contendo uma descrição detalhada de sua estrutura.
Em seguida, foram expostas suas limitações e seus principais problemas.
Finalmente, as modificações realizadas no módulo GPRS a fim de superar as limitações e problemas apresentados por ele foram descritas.
O próximo capítulo apresentará os cenários utilizados e os resultados obtidos com o uso desse módulo modificado.
Esse capítulo apresenta os aspectos relacionados às simulações que foram realizadas com o objetivo de estudar o envio de informações de rastreamento veicular sobre os protocolos TCP e UDP numa rede GPRS.
São descritas as topologias, os parâmetros utilizados e as métricas coletadas nas simulações.
Os resultados obtidos são apresentados e discutidos detalhadamente.
O ambiente de simulação utilizado foi o Ns-2, descrito no Capítulo 5.
A Figura 21 ilustra a topologia utilizada nas simulações:
Ela é formada por uma rede GPRS, dois roteadores intermediários e um sistema final (host).
A rede GPRS é constituída por um roteador GPRS, que une as funções do GGSN e do SGSN, uma estação rádio- base (Bs) e n estações móveis (MSs).
Os enlaces fixos apresentam capacidade de 1 Mbps e atraso de 10ms. O número de sistemas finais é igual a um, ou seja, existe um servidor central que coleta os dados de todos os MSs.
A transmissão de dados ocorre no sentido MS -- host (isto é, no sentido uplink), simulando um veículo enviando suas informações de rastreamento.
A topologia escolhida é simples visando facilitar a interpretação dos resultados.
Em outras palavras, optou- se por uma topologia que permitisse estudar os aspectos desejados com relação a o comportamento da transferência de pacotes de informação de rastreamento sobre os protocolos de transporte TCP e UDP sobre a rede GPRS sem, contudo, encobrir ou influenciar esse comportamento.
Os parâmetros utilizados na simulação são apresentados na Tabela 9.
Foi analisado a versão Reno do TCP.
Também foi avaliado o protocolo UDP, para fins de comparação, por permitir a utilização de aplicações que geram taxas de transmissão constantes (CBR ­ Constant Bit Rate) e não ser baseado em confirmações.
Foram utilizados três tamanhos diferentes de pacotes TCP e UDP.
Todos os experimentos foram realizados com 1, 5 e 50 fontes de dados móveis (simulando veículos).
A taxa de erros da interface aérea (C/ I médio) variou de 2 a 30 dB, com intervalo de 2 dB entre elas.
Os experimentos incluíram os quatro cenários de codificação, que foram configurados estaticamente.
Foi utilizado um timeslot no sentido da Bs para a MS (downlink) e um, dois e quatro timeslots no sentido uplink.
Para todas as simulações foi utilizado um número de freqüências suficiente para todas as estações transmitirem e, em cada freqüência, cinco canais de dados (PDCH ­ Packet Data Channels) foram permitidos.
As simulações tiveram duração de 100 segundos, que é um tempo suficiente para que os efeitos esperados pudessem ser observados.
Para cada experimento, foram realizadas 100 replicações, variando os valores escolhidos.
Esse número de replicações foi escolhido por representar um compromisso aceitável entre o custo computacional e a confiança estatística nos resultados.
Durante a execução dos experimentos, foram coletadas várias métricas, tanto relacionadas ao tamanho dos pacotes de informações de rastreamento veicular quanto a os protocolos de transporte (TCP e UDP) e quanto a o GPRS.
As principais métricas TCP/ UDP coletadas são vazão, tamanho da janela de congestionamento, número de segmentos transmitidos e número de segmentos retransmitidos.
No que se refere ao GPRS, foram coletados dados da camada RLC, como número de blocos transmitidos e descartados, C/ I e Essa seção apresenta os resultados mais significativos dos vários experimentos de simulação realizados utilizando o cenário ilustrado na Figura 20, variando os parâmetros exibidos na Tabela 9.
Protocolo TCP Os primeiros experimentos estudam comportamento da transmissão de informações de rastreamento veicular sobre redes GPRS utilizando o protocolo de transporte TCP.
Para efeitos de simulação, considerou- se que um veículo envia um pacote de informação de rastreamento, seja ele no formato básico (PT_ IBT) ou avançado (PT_ IAT) a cada 1 segundo.
Este tipo de transferência sobre a rede GPRS não apresenta nenhum tipo de gargalo no cenário criado, devido a o fato do tamanho dos pacotes transferidos serem muito inferiores à vazão da rede GPRS para o cenário proposto.
Optou- se por testar, principalmente, o cenário de ausência de sinal GPS/ GPRS, onde um veículo teve suas informações de rastreamento gravadas de forma local, na memória de massa do aparelho.
Considerando este caso, o veículo deve enviar todos os pacotes de rastreamento armazenados localmente no momento de restabelecimento de sinal, aumentando consideravelmente o volume de dados a serem trafegados por a rede GPRS.
A Figura 22 mostra a vazão alcançada por uma estação móvel submetida a diferentes condições de ambiente.
Foi utilizada a configuração 1+ 1 (um timeslot no sentido downlink e um no sentido uplink) e pacotes de 1500 bytes.
Em estes experimentos, foram gerados tráfegos de retaguarda (background) entre sistemas finais conectados entre os roteadores intermediários para observar o impacto resultante no tráfego GPRS.
Em a Figura 22 são apresentados os resultados com e sem esse tráfego.
Comparando os gráficos, pode- se observar que a presença do tráfego de retaguarda não influência de forma significativa os resultados, uma vez que estes estão bastante parecidos.
Assim, como não houve impacto significativo no tráfego GPRS, os próximos resultados não apresentarão mais tráfego de retaguarda.
Observando o gráfico da Figura 22 a, pode- se notar que há um Cs adequado para cada C/ I. Abaixo de 9 dB, o Cs-1 obtém a maior vazão.
Entre 9 e 14 dB, o Cs-2 é capaz de transmitir maior quantidade de dados.
O Cs-3 apresenta melhor desempenho para C/ Is de 15 a 24 dB, enquanto o Cs-4 possui maior vazão a partir de 25 dB.
Com esses resultados pode- se concluir que o uso dos CSs extremos só é justificado em condições ambientais extremas:
O Cs-1 para ambientes com muito ruído e o Cs-4 para ambientes com pouco ruído (acima de 25 dB).
Assim, os CSs mais apropriados são o Cs-2 e o Cs-3, que abrangem a faixa de 9 a 24 dB.
Esta conclusão está de acordo com a experiência das operadoras, que geralmente utilizam o Cs-2.
Esse resultado comprova que o Cs-4 não é um cenário indicado por exigir condições ótimas de ambiente para que não haja perda de blocos.
Quatro Cs Com intuito de verificar se o tipo do pacote de informação de rastreamento veicular influência na interação entre o TCP e o GPRS, esse tamanho foi variado, assumindo três valores diferentes:
61 por ser o valor do pacote de informações básicas de telemetria acrescido do cabeçalho TCP, 85 bytes por ser o tamanho do pacote de informações avançadas de telemetria acrescido do cabeçalho TCP e 1500 bytes, por ser um tamanho comum, observado com freqüência em transferências de arquivos grandes na Internet.
Os resultados obtidos para cada cenário de codificação são ilustrados na Figura 24.
Os valores apresentados nos quatro gráficos foram gerados utilizando 1 estação móvel, com configuração 1+ 1.
Para o Cs-1 (Figura 24 a), o tamanho do pacote influência a vazão:
Cs-1 é reduzida.
Assim, para transmitir um pacote de 1500 bytes (somando ainda cabeçalhos das camadas superiores), são necessários 74 blocos RLC.
Mas a janela de transmissão da camada RLC só permite que sejam enviados 64 blocos sem que seja recebida uma confirmação (ACK).
De acordo com a especificação, o receptor envia um ACK apenas quando recebe o último pacote da seqüência, ou quando o transmissor requisita uma confirmação.
Como o último bloco dessa seqüência não será transmitido dentro de a janela, o receptor só enviará um ACK quando for solicitado.
O transmissor solicitará um ACK quando a janela ficar completa, retransmitindo os blocos cujo recebimento ainda não foi confirmado.
O tempo gasto desde a retransmissão do primeiro bloco não confirmado (com solicitação de confirmação) até a recepção do ACK e a liberação da janela para novas transmissões causa a diminuição da taxa de transmissão observada no gráfico da Figura 24a.
Com os demais CSs (Figuras 24b a 24 d) isso não é tão perceptível, porque, para os tamanhos de pacotes utilizados nos experimentos, o número de blocos gerados por pacote pode ser enviado numa única janela de transmissão.
De essa forma, a janela causa limitação apenas quando a taxa de erros é alta, provocando a perda de muitos blocos e, conseqüentemente, impedindo o &quot;deslizamento «da janela.
Apesar de, segundo os resultados obtidos, o tamanho de 1500 bytes não ser o mais apropriado para o uso do TCP sobre o GPRS, este é o valor comum, utilizado na transferência de arquivos por a Internet.
Para o resto das simulações optou- se por fixar o tamanho do pacote TCP em 85 bytes, visto ser o tamanho do pacote de transmissão de informações avançadas de telemetria (PT_ IAT) além de ser um valor intermediário nas simulações executadas.
Observando a vazão do sistema para pacotes de rastreamento veicular (Figura 24) sobre as diversas codificações do cenário GPRS avaliado, podemos prever o tempo de restabelecimento do histórico de rastreamento no momento de restabelecimento do sinal GSM, após um período de armazenamento local das informações.
Para esta avaliação, tomou- se como parâmetro um veículo que tenha permanecido o tempo de 6 horas num ambiente sem a presença de sinal GSM, tendo como configuração de rastreamento o envio de pacotes de informações avançadas de telemetria com intervalo de 1 segundo no envio de cada pacote.
Em este cenário, após as 6 horas de armazenamento local, o veículo tem armazenado na memória de massa do equipamento um montante de pacotes ocupando um espaço de aproximadamente 1793 Kbytes.
A Figura 25 apresenta o tempo necessário para que o veículo realize o envio dos pacotes armazenados localmente para o servidor central, levando em consideração as diferentes codificações do cenário.
Pode- se notar que o Cs-1 consegue recuperar o histórico de rastreamento de modo mais eficiente para C/ Is entre 2 e 7, perdendo eficácia na medida que as condições do ambiente (ruído) melhoram.
O tempo de envio máximo para o Cs-1 fica em torno de 5 minutos para C/ I acima de 12 Db.
O Cs-2 possui um desempenho muito inferior que o Cs-2 para C/ Is abaixo de 4.
Porém consegue completar o envio das informações em menor tempo no intervalo de C/ Is de 8 a 14, tendo a possibilidade de enviar o histórico completo em aproximadamente 4 minutos para condições de C/ I acima de 14 Db.
O Cs-3 tem desempenho superior aos outros para o intervalo de C/ I entre 16 e 20 Db, tendo um péssimo desempenho para C/ Is abaixo 6.
Este consegue realizar o envio completo do histórico de informações em aproximadamente 2 minutos para C/ Is acima de 20.
Por último, o Cs-4 não consegue completar o envio do histórico de pacotes de rastreamento para C/ Is abaixo de 10, tendo desempenho superior para o intervalos de C/ I acima de 20, conseguindo realizar o envio completo do histórico em menos de 1 minuto, para o cenários com C/ I acima de 24.
A Figura 26 ilustra a vazão de dados da rede GPRS utilizando o protocolo TCP para os quatro CSs, variando o número de estações móveis (veículos) utilizados nas simulações.
Os valores utilizados foram 1, 5 e 50 MS (veículos).
Como pode ser visto nos gráficos, a quantidade de MSs praticamente não influenciou os resultados.
Em outras palavras, o tráfego gerado por uma estação móvel não prejudicou as outras estações.
Por este motivo, os demais resultados apresentados neste trabalho considerarão apenas uma estação móvel.
A Figura 27 ilustra as vazões atingidas variando o número de timeslots utilizados por 1 usuário no sentido uplink.
Além de a configuração singleslot utilizada para os demais resultados, foram utilizadas as configurações multislot 1+ 2 e 1+ 4.
Comparando as Figuras 27a e 27 b, observa- se que a vazão praticamente dobra, o que é absolutamente coerente visto que o número de slots utilizados é o dobro.
Como o comportamento do sistema não muda de forma significativa ao aumentar o número de timeslots, os resultados seguintes levam em consideração apenas à configuração singleslot.
A camada RLC do GPRS pode operar nos modos com ou sem confirmação (Seção portanto, decidiu- se verificar o desempenho do sistema sobre o GPRS utilizando o modo sem confirmação.
A Figura 28 ilustra a vazão obtida por uma MS submetida a diferentes condições de ambiente, utilizando a configuração 1+ 1 e pacotes de 85 bytes.
Analisando o gráfico, pode- se perceber que em ambientes que apresentam muito ruído a vazão é nula para todos os CSs.
Esse resultado é bastante coerente uma vez que não ocorrem retransmissões de blocos perdidos e os erros têm que ser corrigidos utilizando a codificação oferecida por o cenário.
Como esperado, o Cs-1 é o cenário que apresenta melhor desempenho por oferecer maior proteção aos dados.
O Cs-4, que não proporciona proteção aos dados, apresenta um desempenho muito ruim.
Os gráficos ilustrados na Figura 29 comparam o desempenho do sistema utilizando os dois modos da camada RLC.
A Figura 29a mostra a vazão atingida por os cenários extremos:
Cs-1 e Cs-4.
O Cs-1, que já consegue transmitir alguns dados a partir de 10 dB, consegue obter uma vazão ainda maior que o modo com confirmação quando todos os erros podem ser recuperados (isto é, em condições muito boas de ambiente).
Isso ocorre devido a a limitação imposta por a janela de transmissão utilizada no modo com confirmação (como explicado anteriormente).
Enquanto o Cs-4, por não oferecer proteção aos dados, apenas consegue transmitir dados em condições muito boas (depois de 22 dB), alcançando taxas bem abaixo de o valor máximo teórico mesmo em ambientes com pouco ruído.
Ilustrados na Figura 29 b, o Cs-2 e o Cs-3 transmitem alguns dados em ambientes com boas condições e atingem a mesma vazão obtida pelo modo com confirmação.
De essa forma, os resultados demonstram que o modo sem confirmação deve ser utilizado apenas em ambientes com condições muito boas e que o Cs-4 deve ser evitado, visto que não apresenta proteção aos dados.
Para fins de comparação, os mesmos experimentos foram também realizados para tráfego UDP.
Inicialmente, foram realizadas simulações variando- se o número de estações móveis (veículos) para a transferência de informações de rastreamento veicular utilizando o protocolo de transporte UDP sobre um canal de comunicação com C/ I igual a 30 Db (baixo ruído).
Logo após, foram realizadas simulações variando o tamanho do pacote UDP e o nível de sinal/ ruído.
Por último, é realizada uma comparação da vazão de dados utilizando o protocolo de transporte TCP e UDP para os cenários propostos.
A Figura 30 mostra um gráfico obtido a partir de a vazão alcançada em relação a a variação do número de veículos trafegando pacotes UDP com tamanho de 800 bytes utilizando um canal de comunicação com C/ I igual a 30 Db (baixo ruído).
Como visto nas seções anteriores deste trabalho, os dados sobre a rede GPRS são enviados através de múltiplos slots de tempo (comutação de pacotes), que são alocados conforme a demanda dos pacotes enviados ou recebidos.
Com o aumento da demanda por slots de tempo na rede GPRS, observou- se uma pequena diminuição na vazão de dados utilizando o protocolo UDP.
A Figura 31 mostra um gráfico obtido através dos resultados da vazão do sistema em relação a o tamanho do pacote de dados utilizando o protocolo de transporte UDP, trafegado sobre o sistema, os resultados tiveram como objetivo variar o comportamento do sistema frente a este tipo de variação.
Como pode ser observado na Figura 31, houve um aumento gradativo na vazão até o pacote alcançar o tamanho de 1000 bytes, que é o tamanho do MTU (Maximum Transmission Unit) da rede, com isso os pacotes maiores que esse valor tiveram um decremento da vazão.
Isso se dá por o fato de que os pacotes maiores de 1000 bytes são fragmentados na camada de enlace.
Na medida em que o tamanho dos pacotes com mais de 1000 bytes vai aumentando, a vazão volta novamente a crescer.
Para esta simulação, foram escolhidos três valores de C/ I, que correspondem respectivamente a alto nível de ruído na rede, ruído médio e boas condições do sinal.
Como pode ser observado nas figuras 32 e 33, com C/ I igual a dois a vazão alcançada foi muito baixa em relação a a taxa transmitida, o que compromete a recepção dos dados por o receptor.
Com C/ I igual a trinta obteve- se uma melhor vazão dos dados em relação a a taxa transmitida e com C/ I igual a quatorze, uma vazão intermediária.
Utilizando uma aplicação geradora de tráfego CBR com uma taxa de transmissão de 24 kbps, é possível observar a vazão máxima atingida por o GPRS para cada Cs sob os diferentes valores de C/ I. A Figura 33 apresenta os dados obtidos para o Cs-1 e o Cs-4 utilizando como protocolo de transporte TCP e UDP.
Em a Figura 33a o tamanho de pacote TCP é 85 bytes e o tamanho do pacote UDP de 800 bytes.
Pode- se perceber que, neste caso, o TCP apresenta um desempenho próximo de o UDP.
Contudo, na Figura 33b, quando a perda de pacotes torna- se desprezível para o Cs-1, a vazão alcançada por o TCP(~ 4 kbps) é praticamente a metade da vazão do UDP.
Isso se deve ao modo com confirmação da RLC e à quantidade de blocos RLC gerados nesse cenário de codificação (como explicado nos resultados relacionados à variação do tamanho do pacote de informações de rastreamento veicular ­ Seção 6.2.1).
Novamente os resultados mostram que o tamanho do pacote de informação de rastreamento veicular influência o desempenho do sistema sobre o GPRS.
Ressalta- se que, através do UDP, pôde- se validar o módulo GPRS utilizado nos experimentos, pois as taxas de transmissão alcançadas foram bastante próximas das taxas apresentadas na Tabela 2.1.
Observando- se a Figura 33 a, o Cs-1 alcançou 8,38 kbps para um valor máximo teórico de 9,05 kbps, enquanto o Cs-4 atingiu 19,7 kbps, para um máximo de 21,4 kbps.
Em um ambiente ideal (isto é, sem o modelo de erros), o Cs-4 obtém uma taxa mais próxima da esperada.
Em este capítulo foram apresentados os aspectos relacionados às simulações.
Inicialmente foram expostas as configurações da simulação.
A topologia e os parâmetros utilizados foram descritos de forma detalhada.
Em seguida os resultados mais significativos dos diversos experimentos de simulação realizados foram apresentados e discutidos.
Resultados relacionados à transmissão de informações de rastreamento veicular sobre redes GPRS utilizando os protocolos de transporte TCP e UDP foram expostos, através de os quais pode- se concluir que tráfegos de retaguarda (background) não influenciam de forma significativa no tráfego GPRS.
Através das simulações foi possível obter faixas de valores de C/ Is apropriados para o uso de cada cenário de codificação (Cs), sendo observado que os cenários mais adequados são o Cs-2 e o Cs-3 por abrangerem uma faixa maior de C/ Is em o qual apresentam melhor desempenho.
Variando o tamanho do pacote trafegado, foi possível notar que no cenário Cs-1, o tamanho do pacote influência na vazão, sendo o tamanho do pacote inversamente proporcional à vazão obtida.
O número de estações móveis (veículos) também foi variado, mostrando que o tráfego gerado por uma estação móvel não influência as outras estações, ou seja, os resultados obtidos foram praticamente os mesmos independentes do número de MSs.
Experimentos utilizando o modo sem confirmação da camada RLC demonstram que esse modo deve ser utilizado apenas em ambientes com condições muito boas de sinal e que o esquema de codificação Cs-4 deve ser evitado neste modo, visto que não apresenta proteção aos dados.
Por último, foi realizada uma comparação entre o desempenho do sistema utilizando os protocolos de transporte TCP e UDP.
Os resultados mostram, novamente, que o tamanho do pacote influência no desemprenho do sistema quando utilizando sobre o protocolo TCP no GPRS.
Para o tamanho de 85 bytes, o TCP apresentou uma vazão próxima da alcançada por o UDP, enquanto que com pacotes de 1500 bytes, a vazão atingida utilizando o Cs-1 é menor que a metade da obtida por o UDP.
O capítulo seguinte apresentará as conclusões e os trabalhos futuros relacionados a essa pesquisa.
Este trabalho teve como objetivo avaliar a transmissão de informações de rastreamento veicular sobre redes GPRS através de simulações.
Vários cenários foram avaliados, incluindo diferentes taxas de erros (C/ I) no meio físico de transmissão, tamanho de pacotes e quantidades de usuários e de timeslots utilizados por usuário no sentido uplink.
A primeira contribuição deste trabalho consiste no estudo abrangente realizado sobre a transferência de informações de rastreamento veicular sobre redes GPRS.
Foram estudados os seguintes aspectos:
Impacto do tráfego de retaguarda no tráfego de dados sobre GPRS:
Foram inseridos tráfegos de retaguarda (background) entre a rede GPRS e o transmissor de dados (no caso TCP), sendo constatado que não interferem no tráfego GPRS.
O Cs apropriado para cada taxa de erros (C/ I):
Variando a taxa de erros do ambiente (C/ I), foi avaliado o desempenho do sistema para cada cenário de codificação da camada RLC, e através desta análise, pôde- se determinar o intervalo em que cada Cs produz maior taxa de transmissão.
Verificou- se também que o Cs-2 e o Cs-3 são mais indicados por abrangerem uma faixa maior (9 a 25 dB);
A influência do tamanho do pacote de informação de rastreamento veicular sobre GPRS:
Variando o tamanho do pacote (quando utilizando sobre o protocolo TCP), pode- se verificar que este influência na vazão alcançada (principalmente quando Cs-1 é utilizado), sendo inversamente proporcional ao tamanho do pacote.
Isso ocorre devido a a limitação imposta por o tamanho da janela de transmissão da camada RLC;
Quantidade de usuários no sistema GPRS:
O número de estações móveis (veículos) no sistema GPRS foi variado a fim de detectar o impacto causado ao incrementar o numero de usuários no sistema.
Os resultados obtidos foram praticamente os mesmos, independente do número de MS, mostrando que o tráfego gerado por uma estação móvel não prejudica as outras estações;
A influência do número de timeslots por usuário no sentido uplink:
Foram analisadas duas configurações multislot.
O comportamento do sistema permaneceu praticamente o mesmo para as duas configurações, diferenciando apenas na vazão alcançada que dobrou à medida que os números de timeslots duplicava;
O comportamento do TCP sobre o modo sem confirmação da camada RLC:
O modo sem confirmação da camada RLC foi utilizado, e pode- se concluir que este deve ser utilizado apenas em ambientes com condições muito boas e que, por não apresentar proteção aos dados, o Cs-4 deve ser evitado nesse modo;
O desempenho do TCP comparado ao UDP:
Foram realizados experimentos com o protocolo UDP a fim de comparar seus resultados com os obtidos utilizando o TCP.
Observou- se que para segmentos de 85 bytes, os pacotes transmitidos utilizando o protocolo TCP apresentaram uma vazão próxima da alcançada por o UDP, enquanto que com segmentos de 1500 bytes, a vazão atingida utilizando o Cs-1 é menor que a metade obtida por o UDP.
Outra importante contribuição foi o aprimoramento do módulo GPRS para o Ns-2.
Após as alterações realizadas, este módulo apresenta- se mais estável e está mais de acordo com a especificação do GPRS.
Entre as principais modificações está a melhoria do modelo de erros, que atualmente utiliza uma tabela BLER bastante adotada no meio acadêmico.
Quanto a trabalhos futuros, uma interessante linha de pesquisa baseia- se na extensão do módulo GPRS para que este trabalhe com múltiplas células, incluindo gerenciamento de mobilidade, handovers e QoS.
Outra possibilidade é a adaptação dos cenários do Ns para simulação de redes veiculares (VANET), permitindo a troca de informações direta entre veículos, simulando assim, um nova gama de sistemas de auxílio em viagens e de gerenciamento de congestionamentos.
