Este trabalho disserta sobre modelos utilizados para representar e armazenar o fluxo de operações para edição de imagens.
As ferramentas de edição de imagens, geralmente, utilizam uma pilha para armazenar este fluxo, e neste trabalho são apresentados alguns problemas encontrados neste modelo, como por exemplo:
Quando o usuário desfaz algumas operações e aplica uma nova, as operações desfeitas são perdidas.
Outro problema detectado é que o histórico é mantido por sessão, ou seja, ao salvar uma imagem e abrir uma edição de ela em outro momento o histórico estará vazio, perdendo- se as transformações que já foram executadas e não é mais possível retroceder.
Este trabalho apresenta uma forma não-linear para armazenar e visualizar estes fluxos, baseando- se numa árvore.
Com uma árvore é possível ter vários caminhos que são diversas edições numa única forma de visualizar.
Salvando esta árvore pode- se manter o histórico para uma futura edição.
Outras vantagens e detalhes do modelo proposto são descritos ao longo de o trabalho.
Por fim é introduzido o protótipo desenvolvido para avaliar o modelo, em seguida são apresentados resultados de avaliações com usuários utilizando o protótipo.
Palavras Chave: Visualização, desfazer e refazer, programação visual.
A edição de imagens consiste em aplicar operações que alteram uma imagem original com o intuito de aprimorar- la para uma situação desejada.
Estas transformações são executadas de forma sequencial, gerando um fluxo linear.
As principais ferramentas de edição de imagens possuem uma opção para visualizar este fluxo durante o seu processo de edição.
Normalmente estas representações são chamadas de &quot;Históricos», pois possibilitam a visualização das operações executadas durante a edição.
Estes históricos permitem retroceder a um ponto da edição, para desfazer e refazer operações.
Esta funcionalidade permite ao usuário explorar a ferramenta e aprender com seus erros sem a necessidade de perder resultados já obtidos, no entanto, estes históricos possuem algumas limitações que são discutidas neste capítulo.
Em seguida uma breve introdução da proposta deste trabalho para aprimorar este histórico.
Por fim, há uma seção indicando a organização do restante do texto.
Os programas citados armazenam as transformações aplicadas num histórico de transformações (uma pilha), e cada nova transformação é inserida no topo desta pilha.
Este histórico também é conhecido como histórico de desfazer (undo history), visto que apresenta as transformações executadas sobre a imagem auxiliando o usuário a visualizar- las e permitindo desfazer- las.
Um inconveniente desta técnica é que quando o usuário necessitar desfazer uma transformação executada a uma distância n do topo da pilha, este deverá desempilhar n transformações para poder desfazer a que deseja.
E quando aplicar uma nova transformação, as transformações que foram desempilhadas serão perdidas, logo o usuário deverá aplicar- las novamente de forma manual.
Outro inconveniente é que geralmente os programas mantêm o histórico apenas durante uma sessão de trabalho e quando esta é encerrada o histórico é descartado, ou seja, o resultado final das transformações pode ser salvo, todavia as entradas da pilha serão perdidas porque não existe persistência dos passos executados durante uma edição.
Para salvar as imagens intermediárias o usuário deve salvar o resultado de cada transformação, gerando trabalho extra e aumentando significativamente o número de arquivos que devem ser salvos.
Em um dos programas descritos anteriormente seria possível salvar apenas a Figura 1.3g num arquivo, pois as demais seriam perdidas quando o usuário encerrarsse a sessão.
Para armazenar os resultados gerados nas Figuras 1.3 d, 1.3e e 1.3f o usuário deveria salvar 3 arquivos diferentes.
Outro motivo para salvar o histórico é que assim seria possível replicar as transformações executadas durante uma edição sobre outra entrada, habilitando assim a automatização de uma edição num conjunto de imagens, por exemplo, converter todas as imagens de uma pasta para tons de cinza.
Proposta O objetivo do presente trabalho é investigar técnicas para aprimorar estes históricos, visando solucionar os problemas citados anteriormente.
Em este trabalho será proposto um modelo de representação não-linear que faz uso de árvores para representar o histórico.
Com uma árvore é viável criar vários ramos a partir de um único nodo, gerando assim fluxos não-lineares.
A possibilidade de gerar estes fluxos permite a implementação de funcionalidades como a cópia de um ramo de uma árvore para ser inserido abaixo de outro nodo, repetindo uma sequência de transformações.
Isto auxilia em ocasiões em as quais o usuário necessita replicar as mesmas transformações sobre outro nodo da árvore.
O modelo é dividido numa interface gráfica para o usuário interagir com a ferramenta, uma visualização da árvore e uma engine que processa as transformações executadas por o usuário.
Para a avaliação deste modelo foram implementadas duas versões de protótipo, uma com o histórico linear e outra com a implementação da árvore.
Estes protótipos foram testados com usuários e os resultados são descritos no Capítulo 5.
Organização do texto Em o Capítulo 2 serão abordados trabalhos utilizados como base para o desenvolvimento de um modelo com o intuito de solucionar os problemas descritos.
Em seguida, no Capítulo 3, é feita a descrição deste modelo, contemplando as suas funcionalidades.
Após, no Capítulo 4, é detalhada a implementação do protótipo desenvolvido para a avaliação do modelo proposto.
Em o Capítulo 5 são descritos os testes executados para a avaliação do protótipo e a avaliação dos usuários sobre o novo modelo.
Por fim, são apresentadas as conclusões e trabalhos futuros no Capítulo 6.
Primeiramente são descritos trabalhos que estudam mecanismos para desfazer e refazer ações ou comandos como os trabalhos de Vitter e Berlage, utilizados para auxiliar o usuário a explorar as ferramentas sem a preocupação de não conseguir retornar a um determinado resultado.
Em seguida é mostrado como funcionam as duas principais ferramentas de edição de imagens:
GIMP e Adobe Photoshop, descrevendo as técnicas utilizadas para visualizar e interagir com o fluxo de edição de imagens.
Após são apresentados trabalhos da área de programação visual, que visam buscar formas de programar utilizando elementos gráficos, com o intuito de facilitar o trabalho do usuário.
Histórico de desfazer O histórico de desfazer não é uma funcionalidade utilizada apenas em editores de imagens, programas como editores gráficos, navegadores Web, programas para desenho industrial (CAD), ferramentas para visualização de informação, editores de texto e outros também utilizam estes mecanismos.
Os primeiros trabalhos encontrados na literatura sobre mecanismos para desfazer e refazer são da década de 80.
A seguir serão apresentados avanços nestas técnicas e serão discutidos problemas e soluções para os mesmos.
Um dos primeiros trabalhos sobre o histórico de desfazer é o artigo de Vitter que apresenta um framework para desfazer e refazer comandos executados no ambiente de programação Cope.
Em o artigo são introduzidos os problemas detectados no modelo que utiliza um fluxo linear para armazenar o histórico.
Por exemplo, quando o usuário retrocede até um determinado comando e insere comandos novos, os comandos executados posteriormente são perdidos e sobrepostos por os novos.
Para solucionar este problema foi proposta uma árvore para armazenar os comandos, permitindo ao usuário retroceder e gerar outros caminhos ao invés de sobrescrever o caminho atual.
O artigo identificou que pode existir uma ambiguidade quando o usuário quiser refazer um comando e existirem dois caminhos.
Por exemplo, na Figura 2.1 o usuário executou os comandos A1 até An então voltou até A1, executou B1 e B2 e retrocedeu duas vezes, logo o usuário estará no comando A1.
Se solicitar para refazer um comando, será um comando ambíguo pois pode refazer tanto B1 ou A2, para solucionar este problema o programa irá perguntar se quer voltar para B1 ou A2.
Além de os comandos de desfazer e refazer é introduzido o comando de pular (skip) que não executa um comando marcado por o usuário.
Isso auxilia na experimentação sem a necessidade de perder um ou mais comandos.
O modelo também propõe o uso de um histórico global, que proporciona desfazer operações realizadas sobre mais de um elemento.
Em este caso, o sistema busca o histórico de todos os objetos envolvidos nesta edição e retrocede em cada um de eles, como por exemplo:
Caso retrocedida a operação que pinta os objetos de vermelho no histórico global, o sistema irá procurar em todos os históricos dos objetos envolvidos e irá desfazer a operação, no caso nos históricos de A e B. O trabalho de Kaasten disserta sobre navegadores Web, discutindo funcionalidades como voltar/ avançar, o histórico de páginas e os bookmarks.
Os autores afirmam que existem problemas no modelo atual:
Por exemplo a funcionalidade de voltar/ avançar é baseada numa pilha, ou seja, é um fluxo linear que pode confundir o usuário, por exemplo, o usuário está na página A e clica num link B, em seguida aciona a funcionalidade de voltar e clica no link C, então o usuário clica no botão voltar buscando a página do link B, porém este já foi removido da pilha quando clicou no link C confundindo o usuário.
Outro problema detectado é que esta operação é mantida durante a sessão, ou seja, quando a janela ou aba for fechada as entradas da função voltar e avançar são descartadas.
Sobre o histórico dos navegadores foi identificado que a representação visual não é muito eficiente, pois normalmente os históricos apresentam o link ou o título da página, o que não facilita para o usuário identificar a página que quer ver.
Em seu trabalho os autores propuseram um modelo que guarda uma imagem da página e apresenta em tamanho reduzido juntamente com o título da página.
Berlage introduz a ideia de desfazer de forma seletiva, ou seja, o sistema apresenta uma lista de comandos que podem ser desfeitos e o usuário seleciona o desejado.
Isto foi apresentado numa época em que os históricos eram lineares e baseados em pilha e quando o usuário quisesse retroceder até um determinado estado, deveria desempilhar até o desejado.
Desta forma o usuário apenas escolhe qual comando deseja retroceder.
Um exemplo da janela criada para selecionar o comando para ser desfeito é apresentado na Figura 2.2.
Em o artigo de Meng é introduzida uma forma de visualizar o histórico para desfazer e refazer de forma seletiva num editor gráfico.
Em a época do artigo as funcionalidades de desfazer e refazer eram textuais, ou seja, o histórico mostrava as entradas com o nome da operação que a gerou.
Os autores propuseram que para cada edição fosse armazenada uma foto da edição, e em seu histórico eram apresentadas as funções e as fotos.
O estudo descreveu formas de ver estas entradas do histórico de forma a preservar a ordem cronológica destas entradas, alterando o tamanho da entrada:
Quanto menor significa que é mais antiga e quanto maior, mais recente.
Um exemplo da visualização proposta por o trabalho é mostrado na Figura 2.3 Meng afirma que mostrar uma foto do resultado nas entradas do histórico facilita para usuário identificar o estado ao qual retroceder.
Cada uma destas entradas deve ser selecionável de forma direta, ao invés de retroceder uma a uma até a entrada desejada.
Cada workflow é um conjunto de passos realizados para criar uma visualização.
O VisTrails pode interligar workflows para gerar resultados mais refinados.
Em este caso os workflows são representados em forma de árvore que permite forma intuitiva retroceder a uma visualização, comparar os resultados de diferentes workflows e facilita na compreenção dos passos já realizados.
Estes trabalhos serviram de base para o desenvolvimento da abordagem proposta, fornecendo ideias para a representação não-linear do fluxo de edição de imagens.
Como por exemplo a forma de retroceder de forma direta apresentada por Meng e a possibilidade de manter os estados que já foram desfeitos como no trabalho de Vitter.
Programas atuais Em esta seção serão abordados os programas mais populares de edição de imagens, descrevendo seus mecanismos para visualizar o fluxo de edição de imagens e as técnicas utilizadas para desfazer e refazer.
O primeiro programa de edição de imagens a ser apresentado é o GIMP seguido do Adobe Photoshop.
O programa GIMP (Gnu Image Manipulation Program) é um dos principais editores de imagens utilizadas por as comunidades de software livre.
Este programa possui uma interface dividida em janela principal com um menu no topo juntamente com a imagem a ser editada e janelas configuráveis.
A janela mais utilizada é a que contém as principais ferramentas usadas para a edição de imagens, no entanto existem outras, como por exemplo a janela que visualiza as camadas de uma imagem, a janela de cores e a janela do Histórico de Desfazer.
Esse Histórico de Desfazer apresenta entradas constituídas de uma imagem pequena do resultado e o nome da transformação que o gerou.
Estas entradas são empilhadas formando um fluxo linear, ou seja, a cada nova transformação é adicionada uma nova entrada na pilha.
A Figura 2.4 mostra o Histórico de Desfazer do GIMP, onde foram aplicadas transformações de troca de fundo utilizando a ferramenta Preenchimento.
Em a figura, os resultados das transformações podem ser vistos no histórico pois as transformações resultaram em diferenças significativas entre as imagens.
Para visualizar o resultado de uma transformação existem duas opções:
A primeira é desfazer até a entrada desejada utilizando a funcionalidade de desfazer por o menu ou por o atalho CTRL+ Z;
E a segunda é clicar com o mouse sobre a entrada desejada na pilha.
Contudo não é possível visualizar o resultado de duas transformações ao mesmo tempo, ou seja, se uma imagem é apresentada na janela principal, quando o usuário retroceder ou clicar numa entrada do histórico o resultado desta será apresentado na janela principal.
E quando o usuário aplicar uma nova transformação sobre este estado, todas as aplicadas posteriormente serão sobrescritas por a nova e serão perdidas.
Durante a sessão, quando a imagem é fechada as entradas nesta pilha são descartadas, ou seja, se a imagem for reaberta o histórico estará vazio.
Um dos inconvenientes desta técnica é a perda do histórico pois se o usuário quiser continuar uma edição em outro momento e tentar retroceder alguma transformação ele será impossibilitado, obrigando- o a aplicar novamente as transformações executadas anteriormente.
Acredita- se que o programa não armazena este histórico pois necessitaria salvar a imagem original e todas as transformações aplicadas sobre a imagem, por consequência, os arquivos seriam cada vez maiores, dependendo do número de transformações executadas.
E seria necessária uma operação explícita &quot;Limpar Histórico «para diminuir o tamanho dos arquivos.
Adobe Photoshop O Adobe Photoshop é um dos programas mais populares para a edição de imagens e é um produto comercial oferecido por a empresa Adobe.
Possui uma janela principal, com o menu principal no topo, uma janela móvel contendo as ferramentas e outras janelas que podem ser configuradas.
Entre elas existe a janela History, que mostra o histórico de transformações aplicadas sobre a imagem sendo editada.
Este histórico é linear e usa uma pilha de transformações como o GIMP e cada entrada desta pilha é representada por o ícone da ferramenta e ao lado o nome desta.
Em a Figura 2.6 pode se observar um exemplo, em o qual a imagem sofre retoques com as ferramentas Brush Tool (Pincel) e Pencil (Caneta).
O uso do ícone da operação gera mais problemas que o uso de imagens resultantes em tamanho reduzido, pois não se pode ter noção do resultado obtido por a transformação.
Para visualizar o resultado de uma transformação, o usuário deve clicar na transformação desejada apresentada neste histórico e o resultado da transformação é mostrado na janela principal da ferramenta.
Porém este histórico tem um tamanho máximo de entradas que irá depender de quanta memória o usuário disponibilizar para o programa, e por default tem- se 20 entradas no histórico.
Isto pode causar problemas caso um usuário queira desfazer mais transformações que o programa permita.
Uma vantagem deste programa é a funcionalidade Snapshot que consiste em &quot;tirar uma foto «do estado atual, ou seja, seleciona- se um resultado e armazena- se este resultado.
O usuário pode fazer transformações posteriores ou retroceder, mas o resultado desta transformação estará salvo durante a sessão.
Por exemplo na Figura 2.7 são apresentadas transformações de troca de fundo e para armazenar temporariamente estes resultados é utilizada a função Snapshot.
Os resultados são representados por um ícone com o resultado e ao lado o nome da Snapshot, no exemplo são Snapshot 1, Snapshot 2, Snapshot 3 e Snapshot 4.
Outra funcionalidade adicional do Photoshop é a possibilidade de clonagem, criando um novo documento a partir de uma entrada do histórico, ou seja, é criado um novo documento abrindo uma nova janela ou aba com a imagem resultante do estado selecionado e o histórico mostra a operação de duplicação e a edição original que foi clonada continua aberta.
Um exemplo desta funcionalidade pode ser visto na Figura 2.8 onde a primeira janela mostra a imagem original, em seguida o resultado de algumas transformações e quando iniciar uma nova edição a partir deste resultado é aberta uma nova aba como mostra a Figura 2.8c e pode- se visualizar o histórico com a operação de duplicação.
O histórico do Photoshop também armazena as entradas apenas durante uma sessão, ou seja, todas as entradas são descartadas quando a sessão é encerrada;
O mecanismo é muito semelhante ao visto na Seção 2.2.1 e, como no histórico, as entradas criadas por a função Snapshot também são descartadas.
Porém o Adobe Photoshop contém uma alternativa para o fluxo linear de transformações, que por default é desligada, mas que possibilita ao usuário usar uma pilha de transformações sem uma ordem linear.
Ou seja, quando o usuário retroceder até um ponto e executar uma nova transformação e aquelas que foram executadas posteriormente não serão perdidas, porém a nova entrada do histórico será empilhada ao final da última transformação da pilha.
Este mecanismo auxilia na persistência do histórico, porém é uma pilha sem uma ordem correta.
Programação Visual Uma das ideias para melhorar a visualização das transformações executadas sobre uma imagem surge com a programação visual:
De acordo com diversos autores[ 13, 18, 22, 23, 24, 27] programação visual é o uso de expressões visuais como imagens ou ícones no processo de programação, com o objetivo de facilitar a visualização do programa, tornando o ensino mais intuitivo para usuários não familiarizados com a lógica de programação e permitindo que usuários mais experientes se preocupem mais com a lógica do programa do que na implementação do código.
Normalmente estes programas utilizam ícones e ligam estes ícones formando um fluxo de operações.
Ícones são posicionados manualmente por o usuário e formam um programa que pode ser não-linear, pois existem operações que recebem mais de um parâmetro de entrada e operações que geram mais de uma saída como por exemplo as ferramentas Cantata, JLS e SCIL-VP, que serão descritas a seguir.
Cantata Um exemplo de programação visual é o ambiente Cantata desenvolvido sobre o sistema Khoros, que é um conjunto de funções utilizadas para processamento de imagens, manipulação de dados, processamento de matrizes e visualização de dados.
Cantata é uma interface gráfica que serve como camada superior para facilitar o uso das funções do Khoros.
O ambiente também utiliza ícones para representar as funções do programa e linhas para ligar estas funções, como se pode observar na Figura 2.10.
De acordo com Young et al o ambiente visual aumenta a produtividade pois permite ao usuário desenvolver soluções de maneira mais natural.
Esta interface é utilizada para auxiliar no desenvolvimento de programas que usam sequências de operações para o processamento de imagens.
Buscou- se saber mais sobre este ambiente, no entanto, o link referenciado no artigo de Young et al estava indisponível.
A ferramenta JLS foi descrita no artigo A Pedagogically Targeted Logic Design and Simulation Tool e consiste numa ferramenta voltada para o ensino de circuitos lógicos.
Os livros que ensinam circuitos lógicos utiliza- se de diagramas lógicos para ilustrar estes circuitos, então uma ferramenta de simulação deve ter uma interface gráfica para que os estudantes possam experimentar o que viram nos livros.
Para os autores deste artigo especificações textuais de circuitos são muito complexas e pouco intuitivas para estudantes que nunca viram circuitos lógicos.
Eles citam a conhecida frase &quot;Uma imagem vale mais que mil palavras!».
Em a Figura 2.11 se pode observar a interface da JLS, onde existe um menu principal no topo, uma caixa contendo os componentes do circuito, uma área de trabalho ao centro e abaixo um simulador de sinal.
Como pode- se observar, o circuito é desenvolvido na área central da ferramenta, onde o usuário seleciona um componente e insere- o na área de trabalho, depois o usuário deve ligar este componente a outros e simular os resultados obtidos.
Operações como And e OR possuem dois parâmetros de entrada e um de saída, enquanto não linear:
Por exemplo a partir de o resultado de um And pode se gerar um fluxo que seja à entrada Em o artigo de Koelma et al é apresentado um ambiente de programação visual chamado SCIL-VP.
A partir de um arquivo de configuração é construída em tempo de execução uma palheta que contém ícones que representam funções.
Este arquivo de configuração contém as informações sobre o nome da função, subgrupo de funções à qual pertencem, parâmetros de entrada e saída, o ícone que representa esta função, os parâmetros fixos da função, especificação dos valores permitidos para os parâmetros e uma breve descrição dos parâmetros.
O exemplo apresentado no trabalho consiste de funções para a manipulação de imagens e possui funções para abrir, salvar e aplicar transformações sobre uma imagem.
O ambiente possui uma área de trabalho com um menu no topo, e uma palheta contendo as principais funções do sistema, como apresentado na Figura 2.12.
Esta área de trabalho é onde os ícones que representam funcionalidades devem ser adicionados, e possui barras de rolagem tanto na vertical quanto na horizontal para que programas grandes possam ser visualizados.
As funções são representadas por ícones especificados no arquivo de configuração, e caso um ícone não seja especificado o programa irá criar um novo com o nome da função.
Estes ícones recebem parâmetros como entrada e podem retornar saídas.
Para os parâmetros de entrada foram criados pinos à esquerda do ícone, para representar a saída das funções foram criados pinos à direita.
Caso a função tenha parâmetros fixos como por exemplo um limiar, existirá um quadrado acima de o ícone.
A Figura 2.13 mostra o ícone que representa a função erosion3 x3, que possui dois parâmetros de entrada, uma saída e possui parâmetros fixos pois existe um quadrado acima de o ícone.
Os ícones devem ser interligados por o usuário, conectando os pinos de saída de um ícone com os pinos de entrada de outro.
Estes pinos são tipados, ou seja, o dado de entrada ou saída possui um tipo como, por exemplo inteiro, imagem, bit.
A ligação entre os pinos é utilizada para manter a consistência destes dados, ou seja, um pino de entrada que receba como entrada um número não pode ser ligado com um pino de saída que contenha uma imagem por exemplo.
O presente trabalho apresenta um modelo para tornar o fluxo linear de imagens em nãolinear.
É proposto o uso de uma estrutura de dados para armazenar este fluxo não-linear de entradas do histórico, e na próxima seção são comentadas as estruturas estudadas e a escolhida.
Em seguida é abordada a representação gráfica da estrutura, introduzindo elementos da interface gráfica do sistema, juntamente com funcionalidades adicionais que o modelo proporciona descrevendo suas vantagens.
Em a Seção 3.3 é discutida uma ferramenta para aplicar as transformações solicitadas por o usuário.
Por fim, é abordado o uso de um mecanismo para manter a persistência de dados.
Foi desenvolvido um protótipo semelhante aos programas atuais, onde é apresentada a imagem a ser editada numa janela com uma barra de ferramentas.
O usuário seleciona a ferramenta e aplica a transformação sobre a imagem, como está acostumado.
No entanto, o histórico baseado em pilha foi descartado e substituído por uma árvore para permitir fluxos não-lineares.
A cada nova transformação é inserido um novo nodo na árvore e cada nodo é uma entrada do histórico.
Com o uso de uma árvore é possível ter fluxos não-lineares, pois um nodo pode gerar mais de um nodo filho, possibilitando assim a geração de múltiplos resultados a partir de uma imagem.
Estrutura de dados A maioria dos programas de edição de imagens utiliza uma pilha de transformações já que o fluxo mais comum é o linear, no entanto, um fluxo não-linear é difícil de ser implementado usando pilhas.
Por exemplo, caso uma transformação resulte em duas imagens, o programa deve criar uma pilha para cada imagem resultante, obrigando- o a administrar estas pilhas.
Além disso o armazenamento numa pilha causa um problema ao retroceder para alterar uma transformação executada anteriormente.
O usuário deve desfazer até a transformação desejada, alterar- la e consequentemente perder as transformações seguintes que foram desfeitas.
Uma alternativa para eliminar este problema é o uso de uma lista ao invés de uma pilha.
Considerando que cada nodo armazene o resultado de uma transformação, pode- se remover qualquer nodo desta lista sem perder o resto da lista, o que não era possível com o uso de uma pilha.
No entanto, esta estrutura continua tendo um fluxo linear de transformações, pois a partir de um nodo não podem ser gerados dois nodos, como no caso de uma imagem resultar em duas novas.
A Figura 3.1 apresenta dois tipos de fluxos que não podem ser reproduzidos utilizando listas, a Figura 3.1a apresenta um fluxo onde o nodo b se divide em dois novos nodos c e, como a operação de recorte sobre duas regiões de imagem, o que não é permitido numa implementação de lista que só pode ter um único fluxo.
O inverso ocorre na Figura 3.1b onde dois fluxos são unidos, o que também não é permitido.
Outra alternativa para armazenar as transformações é utilizar uma árvore, onde um nodo é uma entrada do histórico e armazena a transformação e a imagem resultante em tamanho reduzido.
Por a definição de árvore um nodo pai pode ter um ou mais filhos e com esta modelagem uma entrada poderia gerar uma ou mais entradas resultantes, gerando um fluxo não-linear.
No entanto, um nodo filho não pode ter mais que um único nodo pai, o que pode não ocorrer no contexto de edição de imagens:
Por exemplo, pode ser usada uma imagem e uma máscara para gerar outra imagem, logo seria necessário um nodo filho com dois nodos pais, uma para a imagem e um para a máscara.
Um exemplo que não pode ser atingido utilizando a estrutura de árvore é apresentado na Figura 3.2, onde o nodo d possui dois pais, os nodos b e, o que não é permitido por a definição de árvore.
A utilização de um grafo foi cogitada para armazenar este fluxo, porém o grafo teria que ter características específicas que tornariam o trabalho mais complexo:
O primeiro problema detectado seria que o grafo deveria ser dirigido para que o usuário não confunda quem é a entrada e a saída de uma transformação, como mostra a Figura 3.3 a, onde o usuário pode confundir qual imagem é o nodo pai e qual é o filho.
Outro problema é que este grafo tem que ser acíclico, pois uma imagem não pode ser a entrada e a saída da mesma função, por exemplo, na Figura 3.3b onde o resultado da transformação serve de entrada para a própria transformação.
Optou- se por utilizar uma árvore pois o trabalho visa identificar se a representação de fluxos não-lineares auxilia na edição de imagens.
Com o uso de uma árvore é possível visualizar e interagir com fluxos não-lineares, mesmo sem ser permitido gerar o fluxo representado na Figura 3.1 b, porém acredita- se que seja suficiente para identificar melhorias no modelo atual.
Representação Gráfica O modelo proposto deve ser similar ao utilizado por as ferramentas de edição de imagens atuais, que possuem uma janela principal contendo um menu com as funções básicas como abrir imagem, salvar imagem, sair, etc., uma área de trabalho onde a imagem é disposta e uma barra de ferramentas.
Em outra janela deve ser apresentado o histórico da edição, contendo as entradas que representam as transformações executadas.
O histórico é a representação gráfica da estrutura apresentada na seção anterior, posicionada na janela secundária do sistema.
Baseando- se na programação visual é possível definir elementos gráficos para representar estas entradas.
O nodo de uma árvore é um retângulo contendo uma imagem resultante em tamanho reduzido e o nome da transformação que a gerou.
Estes retângulos podem ser ligados indicando as transformações em sequência.
Em a Figura 3.4 pode- se observar um exemplo de entrada no histórico, onde é ampliada a transformação de um filtro para inversão horizontal (flop) numa imagem colorida.
A raiz da árvore deve ser a imagem original e todas as entradas devem ter um caminho da raiz até a entrada, pois este caminho indica as transformações executadas desde a imagem original até a resultante.
Este caminho é o fluxo linear de uma edição e o conjunto de caminhos forma a árvore gerando um fluxo não-linear.
Quando uma nova transformação é executada o sistema deve inserir a nova entrada como filha desta e esta filha deve se tornar a corrente.
Em a representação a entrada corrente deve ser sinalizada de forma que seja possível distinguir- la das outras, indicando em qual imagem será aplicada a próxima transformação.
De acordo com Meng é aconselhável que o usuário possa retroceder de forma arbitrária e direta, ou seja, o usuário visualiza todas as entradas do histórico e seleciona para qual retroceder.
Com o intuito de permitir esta funcionalidade as entradas devem ser selecionáveis através de um duplo clique do mouse sobre a entrada desejada.
Quando uma nova transformação for executada, um novo ramo da árvore deve ser criado, ao invés de sobrescrever as posteriores, mantendo assim todas as entradas no histórico.
Analisando a árvore durante o processo de desenvolvimento do protótipo observou- se que seria interessante possibilitar ao usuário copiar ou mover sub-árvores, ou seja, copiar ou mover um ramo inteiro da árvore de uma entrada para outra.
A o faze isto, todas as transformações a partir de uma entrada até as folhas são executadas no resultado de outra entrada.
Por exemplo, na Figura c, d e utilizando a imagem resultante da entrada f ao invés de a entrada b, gerando as entradas g, h e i, marcadas com uma linha pontilhadas.
O mesmo ocorre ao mover um galho, porém as transformações são removidas da entrada origem e inseridas abaixo de a entrada destino.
Em a representação desta árvore deve existir um método para ampliar as entradas, pois zoom out..
Artigos como afirmam que o uso de Drag and Drop é essencial para a programação visual, pois facilita a manipulação dos ícones.
Seguindo esta linha de raciocínio, foi decidido que as entradas devem ser móveis, ou seja, cada entrada pode ser movida para que seja possível deixar duas entradas distantes mais próximas para facilitar a comparação entre os resultados.
A janela secundária possui um tamanho grande e com barra de rolagem, pois o trabalho de Burnett afirma que um dos principais problemas da programação visual é a área de trabalho, pois programas grandes necessitam de uma área de trabalho grande.
Além disso, quando é utilizada uma pilha para representar o histórico todas as entradas possuem a mesma largura, fixando assim a largura do histórico, o que pode não acontecer com uma árvore, pois um nodo pode gerar um ou mais nodos filhos, logo a largura do histórico irá depender do número de nodos filhos inseridos na árvore.
Engine de Transformação O trabalho de Sim apresenta um ambiente de programação visual para criar fluxos para o processamento de imagem.
Em o modelo apresentado por Sim a interface gráfica é executada no computador do cliente, mas o processamento da imagem é executado em sistemas distribuídos de forma transparente para o usuário.
Com base neste trabalho, foi definido que o modelo não deve se preocupar em aplicar as transformações, e sim em como interagir e representar para o usuário, ou seja, deve ser definida uma engine externa para aplicar as transformações.
Em este caso a interface gráfica solicita à engine para aplicar as transformações, e quando necessário, a interface solicita parâmetros da transformação para o usuário.
Antes da interface gráfica enviar parâmetros para a engine é necessário que o protótipo valide estes valores, pois a engine é responsável apenas por aplicar a transformação.
Um exemplo é a situação de um recorte (crop) pois esta transformação necessita de uma região sobre a imagem para ser recortada e o usuário pode ter selecionado uma região fora de a imagem, gerando um erro na engine.
Em a Seção 4.2 é apresentada a engine escolhida para realizar as transformações.
Persistência dos Dados A persistência dos dados do histórico é uma das deficiências dos programas atuais pois em eles o histórico é descartado após o encerramento da sessão e se o usuário quiser este histórico de volta será impossibilitado.
Com a perda deste histórico tem- se a perda das imagens intermediárias, pois elas são armazenadas no histórico e se o usuário não as salvou estas serão perdidas.
Outro problema detectado é que o usuário fica impossibilitado de retroceder pois o histórico fica vazio.
Uma vantagem de manter este histórico é a possibilidade de visualizar as transformações que já foram executadas, para que o usuário possa identificar os passos dados para chegar a uma determinada imagem.
Por estas razões, acredita- se que deva existir um mecanismo para salvar as transformações e os parâmetros utilizados para replicar a edição.
O programa GIMP possibilita o uso de scripts contendo comandos para aplicar transformações sobre uma imagem.
No entanto, estes scripts devem ser escritos numa linguagem própria do programa.
Este mecanismo poderia ser utilizado para manter a persistência dos dados, no entanto o usuário necessita conhecer esta linguagem específica.
Baseando- se na abordagem do GIMP optou- se por armazenar o histórico num arquivo texto que deve ser interpretado por o protótipo para restaurar uma edição.
Uma das vantagens de armazenar o histórico num arquivo texto é o espaço em disco gasto, pois uma edição pode gerar várias imagens e mantendo apenas o histórico e a imagem original é possível criar novamente as imagens resultantes, logo não é necessário armazenar todos os resultados gerados e quando for solicitado é gerado novamente.
Em o fim é uma troca de espaço em disco por tempo de processamento.
Este capítulo faz uma descrição geral do protótipo desenvolvido para a avaliação do modelo proposto, além de uma descrição sobre sua arquitetura, abordando a ferramenta utilizada para aplicar as transformações e os métodos utilizados para manter a persistência do histórico.
Por fim, são apresentadas as operações que podem ser executadas neste protótipo, tanto na edição da imagem quanto na interação com o histórico.
Descrição Geral A principal tarefa do protótipo é servir como plataforma para avaliar como os usuários se sentem ao interagir com a representação do histórico utilizando uma árvore ao invés de uma pilha de transformações e se os usuários se sentem confortáveis visualizando o histórico organizado em forma de árvore.
Como objetivo secundário foi avaliada a utilidade de alguns mecanismos implementados, como copy e move.
O protótipo também serviu para avaliar a forma de automatizar a edição de um conjunto de imagens a partir de uma edição.
Em esta seção serão discutidos os principais elementos criados para a implementação do protótipo, incluindo o algoritmo utilizado para organizar visualmente os elementos da árvore.
A primeira parte do protótipo a ser implementada foi a estrutura de dados para armazenar a árvore criada durante o processo de edição de imagens.
Por a definição de árvore, todos os nodos, exceto o nodo raiz, têm de ter um único nodo pai e cada nodo pode ter nodos filhos.
Foram definidos alguns atributos que um nodo deve ter:·
Nodo pai:
É uma referência para o nodo pai, sendo que para a raiz este será nulo;·
Id: Um inteiro para facilitar na busca por um nodo;·
Transformação: O nome da transformação que será aplicada;·
Parâmetros da transformação:
Atributo não obrigatório, pois algumas transformações não necessitam de parâmetros;·
Nome da imagem resultante:
Armazena o nome da imagem criada;·
Nome da imagem de entrada:
É o nome da imagem resultante do nodo pai;·
Lista de filhos:
Uma lista contendo todos os filhos deste nodo;
Com estes nodos foi implementada uma árvore para armazenar os dados gerados durante uma edição.
A árvore possui um nodo raiz que é criado por a operação de abrir uma imagem (open) e os demais são transformações aplicadas sobre a imagem.
Um nodo transmite seu resultado como entrada para cada nodo filho e este gera uma nova imagem resultante.
Cada nodo é representado por um ícone como no trabalho de Koelma.
Em o trabalho de Meng os ícones tinham tamanhos variados que indicavam uma ordem cronológica das edições, no entanto todos os ícones deste trabalho tem tamanho igual, pois a ordem cronológica é mantida por o caminho da imagem original até um nodo folha.
Estes ícones mudam de acordo com o zoom aplicado sobre o histórico.
O ícone é dividido em duas partes, no topo a operação e abaixo o resultado em tamanho reduzido como mostra a Figura 4.1.
Por padrão o ícone possui um espaço de 80 pixels para a largura e 96 pixels para a altura, sendo que 80x16 pixels são para o texto indicando a operação e 80x80 pixels para o resultado em miniatura, como mostra a Figura 4.1.
Para que o resultado seja inserido na região é preciso redimensionar a imagem sem distorcer, mantendo a razão de aspecto, pois a região tem tamanho fixo de 80x80 e os resultados podem ter tamanhos variados e por consequência razões de aspecto diferentes.
Por isso é calculado o tamanho da imagem maximizando a altura ou a largura na região.
Para isto é necessário calcular a razão de aspecto da imagem e da região reservada, com as fórmulas:
A razão de aspecto é maior que um se a largura for maior que a altura e menor que um se a altura for maior que a da região.
Em seguida são comparadas as duas razões de aspecto, gerando as seguintes alternativas:·
razaoImagem\&gt; razaoRegiao:
Isto significa que a imagem é mais larga que a região, então maximiza- se a largura e a altura da imagem é recalculada da seguinte forma:
NovaAltura $= larguraRegiao/ razaoImagem;·
razaoImagem razaoRegiao:
Isto significa que a imagem é mais alta que a região, então maximiza- se a altura e a largura é recalculada com:
NovaLargura $= alturaRegião razaoImagem.
Utilizando estes cálculos é possível maximizar a imagem do ícone sem distorcer. Para dispor as entradas do histórico foi investigada a possibilidade de utilizar o pacote Graphviz que contém várias ferramentas que geram imagens de um grafo com os nodos organizados.
Este programa gera diversos formatos de imagens, como JPEG, PNG e SVG.
Este programa poderia ser utilizado para gerar a organização da árvore na janela secundária, no entanto, a saída é uma imagem estática, isto tornaria o histórico estático e não permitiria ao usuário retroceder para uma determinada entrada.
Outra desvantagem de utilizar um imagem para representar o histórico é que não é possível mover os nodos e esta é uma funcionalidade necessária para comparar dois nodos distantes.
Para tornar esta imagem dinâmica poderia ser criada uma imagem em formato SVG, usar as posições dos elementos e reproduzir- las, tornando o trabalho complexo e demorado pois o sistema tem que encontrar os elementos do SVG e remapear- los na janela secundária.
Por estes motivos descartou- se o uso do pacote Graphviz.
Para a organização da árvore foi desenvolvido um algoritmo que dispõe os ícones de forma que estes não se sobreponham e que seja possível identificar facilmente qual é o nodo pai de um nodo.
Considerando estas regras foi desenvolvida uma função que recebe como parâmetros um nodo (Px e Py) que indicam a posição onde o nodo é desenhado, estas coordenadas informam a posição horizontal (Px) e vertical (Py).
Esta função retorna um valor inteiro que indica a última posição na horizontal que foi inserido um nodo, para que não exista sobreposição.
A árvore é inicializada no canto superior esquerdo, dando uma margem de 10 pixels.
Para a primeira chamada é passado como parâmetro o nodo raiz e 10 pixels da margem para Px e Py.
Em seguida é aberta uma recursão para a mesma função para os filhos deste nodo modificando estas coordenadas.
Todos os filhos de um nodo devem estar abaixo deste nodo, para indicar a paternidade e manter uma hierarquia, então Py é incrementado para os nodos filhos da seguinte forma:
Px createTree (Px, Py+ h+ dy, filho);
Px Px+ w+ dx;
Para a interface gráfica foram usadas duas janelas para o usuário interagir com o sistema.
A primeira é a janela principal onde se encontram as ferramentas para editar, uma área onde será disposta a imagem editada e um menu principal, com opções como abrir imagem, salvar imagem, etc..
A janela secundária foi desenvolvida para mostrar e interagir com a árvore gerada durante a organizada a árvore, como mostra a Figura 4.4.
Para manter a persistência dos dados foi desenvolvido um formato XML para armazenar a árvore gerada.
O formato XML foi escolhido por permitir o uso de tags de forma recursiva.
Dentro de esta são apresentadas as funções de inversão horizontal (flop) e conversão para tons de cinza (grayscale).
A tag flop contém as operações de sépia (sepia tone) com parâmetros de 70% e O arquivo XML não armazena as posições dos nodos no histórico:
O programa lê o arquivo e monta a árvore.
Isto diminui o número de informações que devem ser armazenadas no arquivo e o algoritmo que posiciona as entradas é determinístico, logo as entradas serão inseridas nas mesmas posições.
A janela principal apresentada à esquerda da Figura 4.4 é responsável por permitir que o usuário edite a imagem e a cada nova transformação executada na janela principal é adicionada uma nova entrada na árvore disposta na janela secundária.
Os elementos são renderizados através da biblioteca Java 2D que permite desenhar linhas, retângulos, círculos, imagens, entre outros.
Para dispor as imagens para o usuário foi desenvolvida uma classe que estende a classe JPanel e sobrescreve o método paintComponent para renderizar as entradas do histórico dentro de o JPanel, organizando os nodos utilizando o algoritmo descrito anteriormente.
Foi desenvolvido um método em o qual o protótipo faz uma chamada de sistema passando a imagem corrente, a transformação com seus parâmetros e o nome da imagem resultante.
Após a conclusão desta chamada a interface gráfica atualiza a imagem corrente com o resultado da transformação e uma nova entrada no histórico é inserida na janela secundária.
Em seguida são apresentados os comandos utilizados durante a edição apresentada na Figura 4.8: Considerando que uma edição é formada por comandos executados por a engine, pode- se alterar a imagem de entrada para aplicar toda a edição sobre outra imagem, ou seja, alterando a primeira imagem a edição será aplicada sobre esta outra imagem.
Isto foi utilizado para facilitar a automatização de uma sequência. De acordo com Cook o usuário deve ser capaz de automatizar suas tarefas de forma simples e fácil, e o autor acredita que deve existir uma forma intuitiva que não necessite que o usuário saiba programar para automatizar suas tarefas.
Considerando o trabalho de Cook foi desenvolvida uma funcionalidade para aplicar todas as transformações de uma edição sobre um conjunto de imagens, por exemplo, converter todas as imagens de uma pasta para tons de cinza.
Esta funcionalidade abre uma edição e quando o usuário selecionar uma pasta, todas as imagens desta sofrerão as transformações executadas nesta edição.
Um exemplo desta automatização pode ser o redimensionamento de uma pasta contendo diversas imagens para um tamanho reduzido com apenas um clique.
Em este trabalho foi apresentada uma forma de armazenar esta edição num arquivo XML, porém este formato é específico e compreendido apenas por o protótipo.
Para promover versatilidade foi criado uma forma de armazenar e replicar a edição sem a necessidade do protótipo.
Optou- se por armazenar num script que possa ser interpretado por o shell.
O protótipo cria este script contendo os comandos executados durante uma edição possibilitando salvar e replicar a edição.
Para rodar este script basta executar- lo passando o caminho da imagem.
Por exemplo, o script da Figura 4.10 foi salvo com o nome &quot;edicao1 «e é chamado da seguinte forma:
Considerando que o script pode ser executado sobre qualquer imagem, pode se armazenar apenas as imagens originais e o script, economizando espaço em disco como o armazenamento em formato XML.
É possível aplicar esta edição sobre uma pasta utilizando o comando for do shell.
Por exemplo, é possível aplicar o script &quot;edicao1 «sobre todas as imagens da pasta Pictures da seguinte forma:
Seguindo o mesmo exemplo descrito anteriormente é possível economizar espaço em disco armazenando apenas o script e as imagens originais. Por exemplo na Figura 4.11 é aplicada uma edição sobre uma pasta contendo 100 imagens, são gastos aproximadamente 400 MB para armazenar as imagens originais e os resultados da edição.
Por outro lado, ao armazenar o script, que tem em média 1 KB e as imagens originais, o espaço gasto será de 100 MB, ganhando assim uma troca de espaço em disco por tempo de processamento pois quando o usuário quiser visualizar as imagens resultantes deverá aplicar a edição sobre a pasta.
Em a próxima seção serão abordados os comandos disponíveis no protótipo para editar a imagem e as funcionalidades adicionadas no histórico com o para facilitar a execução de tarefas do usuário.
Em este trabalho foi considerado que um projeto é uma edição em a qual o usuário define as transformações que são executadas sobre uma imagem e seus parâmetros.
Em o menu da janela principal estão as operações:·
Abrir imagem (Open Image):
Apresenta uma janela para escolher uma imagem para editar, como mostra a Figura 4.12;·
Salvar imagem (Save Image):
Mostra uma janela para identificar onde a imagem vai ser salva e o usuário informa o nome da nova imagem;·
Abrir projeto (Open Project):
Mostra a janela para escolher um projeto para ser aberto;·
Salvar projeto (Save Project):
Abre uma janela parecida com a de Salvar Imagem se o projeto não for salvo nenhuma vez, caso contrário somente salva;·
Salvar projeto como (Save Project As):
Abre uma janela semelhante a Salvar Imagem;·
Aplicar numa pasta (Apply in Folder):
Aplica a edição corrente sobre uma pasta selecionada com uma janela semelhante a Abrir Imagem;·
Criar script (Create Script):
Cria um script que executa esta edição sobre uma imagem, o protótipo abre uma janela solicitando o nome e o local para salvar.
Para escolher um arquivo ou pasta para abrir ou salvar é apresentada para o usuário a janela de escolher como mostra a Figura 4.12, onde são apresentadas as pastas para selecionar um arquivo ou pasta.
Em a janela principal estão as operações selecionadas para o usuário editar a imagem, posicionadas numa barra de ferramentas.
A primeira é a função que abre uma imagem para ser editada, o que também pode ser executado através do menu principal selecionando a opção de abrir uma imagem (open image).
A segunda e a terceira funções (flip e flop) são semelhantes:
Outra funcionalidade implementada no protótipo é a operação de recorte.
Para realizar um recorte é necessário que o usuário defina uma área da imagem com o mouse e clique sobre o botão de recorte (crop).
Em este caso o protótipo deve verificar se uma região foi selecionada, caso contrário o usuário deve ser informado de que deve selecionar uma região.
O protótipo verifica se a região está sobre a imagem, se estiver é executado o recorte, caso contrário é solicitado ao usuário que selecione uma região sobre a imagem.
A operação de rotação serve para rotacionar a imagem, onde o usuário informa o ângulo de rotação.
É permitido rotacionar tanto no sentido horário (ângulo positivo) quanto no anti-horário (ângulo negativo).
Por fim, tem- se a operação para redimensionar a imagem, onde o usuário informa a escala em porcentagem.
Estas operações foram selecionadas com o intuito de ter uma variedade distinta de operações.
Alguns métodos modificam a imagem, suas cores ou dimensões.
Outros possuem parâmetros, aumentando a diversidade de interação.
A funcionalidade Drag and Drop foi implementada na segunda janela, para que o usuário possa posicionar as entradas como desejar, com o intuito de comparar- las.
Esta funcionalidade pode janela.
O zoom permite ao usuário ampliar o resultado das transformações e comparar- las na janela do histórico, sem a necessidade de abrir uma nova janela.
Com a opção de Drag and Drop é possível comparar imagens que estejam distantes umas das outras, trazendo- as para perto.
Outras funcionalidades foram adicionadas para facilitar o reuso ou movimentação da subárvore do fluxo de edição.
A primeira é a operação de cópia, que consiste em copiar toda uma sub-árvore para outra entrada.
Para executar esta funcionalidade é necessário mover um nodo qualquer para cima de outro, ativando um menu com opções, em seguida escolhe- se a opção copy.
O nodo arrastado é considerado a origem e o nodo em o qual o usuário solta é o nodo destino.
Todas as transformações aplicadas a partir de o nodo origem são aplicadas sobre o nodo destino.
Ou seja, quando o usuário arrastar um nodo origem sobre um nodo destino, todas as transformações aplicadas sobre a origem, inclusive esta transformação, serão aplicadas sobre a imagem resultante do nodo destino.
Por exemplo, na Figura 4.14 o usuário aplicou uma transformação de flop em seguida uma conversão para tons de cinza, retornou para o resultado anterior e executou um filtro de sépia com densidade de 80% gerando o fluxo da Figura 4.14 a..
Porém o usuário percebe que gostaria de recortar a imagem antes de aplicar estas transformações, então aplica o recorte na região desejada, em seguida clica sobre a transformação flop, arrasta- a até o recorte e solta.
O protótipo então solicita ao usuário qual operação deve executar e o usuário seleciona o copy como mostra a Figura O protótipo é responsável por antes de executar uma operação de cópia avaliar se esta não provocará uma situação de loops infinitos, caso esta seja detectada, o protótipo não irá executar esta operação.
No caso de um fluxo linear utilizando uma pilha para armazenar e representar estas transformações seria impossível executar a operação de cópia realizada no exemplo da Figura 4.14, pois o usuário teria que retroceder desempilhando as operações até a imagem original e aplicar o recorte e todas as transformações que foram desfeitas seriam perdidas e deveriam ser executadas novamente.
Outra operação suportada por o histórico é a remoção de sub-árvores.
O usuário clica sobre o nodo raiz da sub-árvore e seleciona a opção de remover (delete), então o protótipo remove esta sub-árvore.
Com o objetivo de avaliar o modelo proposto foram realizados testes com usuários sobre o protótipo desenvolvido no Capítulo 4.
A aplicação dos testes apontou vantagens e desvantagens da representação com uma árvore em comparação com o modelo tradicional que utiliza uma pilha.
Em este capítulo será apresentada uma descrição da avaliação.
Protótipos avaliados Como visto no Capítulo 4 foi implementado um protótipo capaz de produzir fluxos não lineares, utilizando uma árvore para representar o fluxo gerado durante uma edição onde os nodos da árvore representam as entradas do histórico e permitem funcionalidades como visto na Seção identificando vantagens e desvantagens do mesmo.
Para facilitar a adaptação do usuário com o protótipo foi desenvolvida uma variação utilizando uma pilha de transformações, semelhante às ferramentas atuais com uma janela principal onde a imagem é editada e o histórico na segunda janela utiliza uma pilha.
As entradas são semelhantes às do histórico do programa GIMP, como é mostrado na Figura 5.1.
Em esta variação é possível retroceder para um estado com um duplo clique do mouse sobre a entrada desejada.
Este histórico é baseado em pilha, logo, quando o usuário retroceder as operações executadas posteriormente serão perdidas como nos programas atuais.
O protótipo baseado em pilha não suporta as operações de copiar (copy) e mover (move) sub-árvores, pois a pilha oferece apenas um fluxo linear.
Em o texto foi usada a nomenclatura de Protótipo A para a implementação que utiliza uma pilha de transformações e Protótipo B para o fluxo de edição de imagens com uma árvore.
Metodologia de avaliação Um dos problemas encontrados para a avaliação deste modelo foi a dificuldade em encontrar nos trabalhos relacionados algum tipo de avaliação com usuários.
Em a época destes trabalhos não era comum fazer testes com os usuários e as ferramentas eram avaliadas levando em consideração o julgamento dos autores.
O trabalho de Meng por exemplo identifica que a seleção de um estado para retroceder é mais eficiente quando o usuário visualiza os resultados de forma ampla e sugere dois modelos para aprimorar o método para retroceder, no entanto, o estudo indica como trabalhos futuros a avaliação destes modelos com usuários.
Em o artigo de Seals é apresentado um ambiente de programação visual voltada para professores iniciantes na programação.
O ambiente foi desenvolvido para criar simulações científicas para auxiliar na aprendizagem da matéria.
Para a avaliação deste ambiente foram realizados testes comparando o ambiente desenvolvido com outro semelhante já existente no mercado.
O estudo contou com o auxílio de 19 professores que realizaram os testes.
A primeira etapa consistia em preencher um questionário pré-teste para identificar o perfil do usuário.
Em seguida o usuário recebia instrução para realizar o &quot;think aloud «durante a sessão de teste, que consiste numa técnica para o usuário realizar a tarefa e dizer o que está pensando.
Os usuários tinham que criar 3 simulações nos dois programas.
Após a realização das tarefas os usuários respondiam um questionário pós-teste avaliando as reações perante os dois ambientes.
Por fim o usuário era entrevistado para garantir que o avaliador coletou todas as informações relevantes ao trabalho.
O critério principal foi o tempo gasto em média para os dois ambientes, foi destacado que o novo ambiente reduzia o tempo gasto e que 64% dos usuários ficaram mais satisfeitos com o ambiente proposto.
Para avaliação do modelo proposto foram realizados testes com usuários utilizando uma metodologia semelhante ao apresentado no artigo de Seals.
Porém a avaliação foi realizada utilizando os dois protótipos desenvolvidos, ao contrário de Seals que comparou com outro ambiente já existente.
Os testes foram realizados da seguinte forma:·
Termo de consentimento:
Introduz o teste, informa que os dados serão usados para fins de pesquisa e se o usuário aceitar ele assina o termo autorizando o uso das informações adquiridas;·
Pré-teste: Para identificar o perfil do usuário;·
Tutorial: Para apresentar como o protótipo funciona e suas principais funcionalidades;·
Tarefas: Para o usuário interagir e avaliar o protótipo;·
Pós-teste: Para o avaliador discutir com o usuário a experiência com o protótipo.
Estas etapas serão discutidas nas subseções a seguir.
Termo de consentimento Este termo é obrigatório para o uso das informações coletadas com os usuários.
O termo serve para informar o usuário sobre o teste de forma clara e objetiva, dissertando sobre os objetivos do teste, como será realizado e os fins do teste.
Em o Apêndice??
É apresentado o termo de consentimento utilizado neste trabalho.
O termo de consentimento deve ser assinado em caso de aceitação do usuário e deve ser assinado por o avaliador, possibilitando assim o uso das informações coletadas durante o teste de forma legal.
Pré-teste O questionário pré-teste tem 6 questões, de as quais 3 exploravam a experiência do usuário:·
Com quais ferramentas de edição de imagens você já trabalhou?
­ Adobe Photoshop ­ Picasa ­ Outros:·
Há quanto tempo utiliza este tipo de ferramenta?
­ menos de 6 meses ­ mais de 1 ano ­ mais de 2 anos· Com que frequência utiliza este tipo de ferramenta?
Estas questões serviram para avaliar o nível de experiência dos usuários utilizando ferramentas de edição de imagens.
Em seguida foram apresentadas questões específicas sobre as funcionalidades discutidas neste trabalho.
A primeira verifica se o usuário já utilizou algum mecanismo para automatizar a edição de um conjunto de imagens:·
Você já automatizou a edição de um conjunto de imagens (por exemplo:
Aplicar a remoção de olhos vermelhos ou a conversão para preto e branco para todas as imagens de uma pasta?)
Em caso afirmativo, foi fácil?
Em seguida foi questionado se o usuário já teve que gerar duas imagens a partir de uma:·
Você já precisou gerar duas imagens a partir de uma única imagem?
Se sim, encontrou alguma dificuldade?
Qual ou quais?
Por fim foi questionado se o usuário já teve que comparar ou visualizar resultados intermediários:·
Você já precisou comparar resultados intermediários de uma edição (ex.:
Comparar fundos diferentes para uma imagem)?
Se sim, encontrou alguma dificuldade?
Qual ou quais?
Estas questões auxiliaram para identificar o perfil do usuário e a experiência em tarefas menos triviais como a automatização de uma edição sobre um conjunto de imagens, Os resultados deste questionário serão discutidos na Seção 5.4.
Tutorial O tutorial foi realizado após o pré-teste.
Primeiro era apresentado o Protótipo A que representa o fluxo linear utilizando uma pilha de transformações.
Em o tutorial é apresentado como são aplicadas as transformações sobre uma imagem.
Foi explicado como o Protótipo A representa o histórico, que é possível retroceder clicando sobre a entrada desejada e quando uma nova transformação for aplicada após retroceder as posteriores serão perdidas.
Por fim foi mostrado como se salva uma edição, como salva uma imagem e como se aplicam as transformações a um conjunto de imagens.
Em seguida foi apresentado o Protótipo B mostrando como funciona a edição, como retroceder, como funciona a função de zoom, a cópia de um ramo da árvore e como mover um ramo.
Por fim eram recapituladas as funções básicas de salvar.
O tutorial serviu para dar uma noção de como os protótipos funcionam, com o objetivo de não deixar o usuário desconfortável sem ter ideia de como iniciar as tarefas.
Outro motivo por o qual foi realizado um tutorial antes das tarefas é que o objetivo dos testes não era identificar problemas com a interface, e sim, apresentar e avaliar o modelo de visualização do fluxo de edição de imagens utilizando uma árvore.
Tarefas O objetivo das tarefas é identificar se o modelo apresentado é um avanço sobre o modelo atual utilizado para representar o fluxo de edição.
Todas as tarefas devem ser possíveis de executar nos dois modelos.
O modelo proposto possui funcionalidades adicionais como por exemplo a função de copiar e de mover, que podem ser utilizadas durante a execução das tarefas, mas deve ser possível executar a tarefa sem a necessidade destas.
Para avaliar o modelo proposto foram definidas 3 tarefas que foram executadas no Protótipo A e em seguida utilizando o Protótipo B. A primeira tarefa tem o objetivo de adaptar o usuário com o protótipo, com a forma como se abre uma imagem para editar, como se aplicam transformações, como inserir parâmetros nas funções e como se salva uma imagem.
A descrição da tarefa é apresenta a seguir:
Tarefa 1: Para experimentar a ferramenta, primeiro converta a imagem «ferrari.
Png», localizada na área de trabalho, para tons de cinza (Grayscale), depois aplique uma rotação (rotate) de 15 graus na imagem e salve- a na área de trabalho com o nome de «nova_ ferrari.
Png». A segunda tarefa foi criada para testar o fluxo não-linear:
O usuário deve produzir duas imagens a partir de uma como é descrito a seguir:
Tarefa 2: Para usar as transformações, abra a imagem «dois_ carros.
Png «e recorte (crop) apenas o carro da direita.
Em seguida aplique no recorte uma inversão na vertical (flip).
Após execute a transformação de sépia tone (sepia tone) de 70% e salve o resultado com a nomenclatura «direita_ 70.
Png». Retroceda para o resultado da inversão horizontal e execute novamente a transformação de sépia tone agora com 80% e salve com a nomenclatura «direita_ 80.
Png». Após aplicar estas transformações no carro da direita, replique- as no segundo carrinho salvando as duas imagens como «esquerda_ 70.
Png &quot;e «esquerda_ 80.
Png». Em esta tarefa o modelo linear é capaz de gerar os resultados solicitados, com um trabalho a mais por não ter a opção de copiar um ramo da árvore.
Utilizando o Protótipo B é possível identificar os fluxos não lineares gerados durante a edição.
Em o Protótipo A o usuário gera a imagem «direita_ 70.
Png &quot;e deve retroceder um estado para gerar «direita_ 80.
Png &quot;e quando a gera o usuário verifica que a imagem anterior é perdida no histórico, o mesmo acontece quando retrocede até a imagem original para gerar as imagens «esquerda_ 70.
Png &quot;e «esquerda_ 80.
Png». A tarefa 3 foi criada para apresentar a funcionalidade de aplicar uma edição sobre um conjunto de imagens.
A tarefa foi descrita da seguinte forma:
Tarefa 3: Aprofundando as transformações, redimensione a imagem «ferrari.
Png «em 70% do seu tamanho original e converta- a para preto e branco.
Feito isso, aplique estas configurações sobre a pasta &quot;todas «da área de trabalho.
Estas foram as 3 tarefas realizadas para avaliar o modelo proposto.
Em a próxima seção serão abordadas as sessões de teste.
Pós-teste Após a aplicação das tarefas foram realizadas perguntas para a avaliação do modelo proposto.
As primeiras perguntas eram destinadas a identificar dificuldades na realização das tarefas e se o usuário havia realizado todas as tarefas ou se teve alguma dificuldade.
Em seguida eram feitas perguntas específicas sobre o modelo proposto, como:·
O que você achou da função de copiar e mover?·
Você acha possível comparar resultados com os ícones criados para cada entrada do histórico, considerando o uso de zoom?·
Você acha útil a funcionalidade de aplicar uma edição sobre um conjunto de imagens?
Em seguida era questionado qual o modelo o usuário gostou mais e pedia- se uma justificativa.
Por fim, o usuário era questionado se havia alguma sugestão para a melhoria do modelo.
Sessões de teste As sessões de teste foram realizadas com 9 estudantes da Faculdade de Informática da Pontifícia Universidade Católica do Rio Grande do Sul, incluindo alunos da graduação e da pósgraduação.
Os testes foram realizados individualmente, apenas o usuário e o avaliador numa sala utilizando um notebook e um mouse.
Os testes levaram em média entre 20 e 30 minutos.
O avaliador entregava o termo de consentimento para o usuário e explicava que o trabalho seria realizado para avaliar o protótipo criado, sem fins lucrativos e mantendo a privacidade dos dados coletados.
Se o usuário concordasse era solicitado que assinasse o termo.
Em seguida era realizado o pré-teste de forma a identificar o perfil do usuário.
Optou- se por realizar as 3 tarefas sobre o Protótipo A em seguida as 3 sobre o Protótipo B. O avaliador entregava uma tarefa de cada vez e esperava o usuário indicar a conclusão ou a desistência da tarefa.
O avaliador interagia quando solicitado por o usuário para tirar alguma dúvida.
Após a conclusão das tarefas com os dois protótipos era realizado o pós-teste para identificar a reação dos usuários ao modelo proposto.
Em a próxima seção são discutidos os resultados dos testes.
Resultados obtidos Esperava- se ter dois grupos de usuários, o primeiro com usuários experientes e o segundo com mais inexperientes.
Porém os resultados indicaram que todos os usuários se autodenominaram experientes, por este motivo foi limitado em apenas um grupo.
Uma das características identificadas nos usuários é que 6 usuários não utilizaram a ferramenta de cópia para a tarefa 2, que consistia em aplicar as mesmas transformações em outra região da imagem.
Um dos 6 usuários afirmou que a edição era curta (apenas 3 transformações) então não achou necessário o uso da funcionalidade.
No entanto se fosse algo mais complexo com mais transformações o usuário acredita que iria utilizar esta operação.
Aqueles que utilizaram afirmaram que é útil e melhora o modelo atual.
Um dos usuários disse:
&quot;Fiz apenas uma vez e depois copiei e ele fez tudo para mim «Em relação a a visualização, todos os usuários preferiram a representação em árvore.
De entre os 9, 4 afirmaram que fica mais fácil de ver utilizando uma árvore.
Outros afirmaram que o uso de uma árvore é bom por permitir caminhos alternativos, ou seja, sem a perda de uma edição como ocorria no modelo tradicional.
Um dos usuários afirmou que o modelo permite ramificações e que isto dá liberdade ao usuário de tentar sem a preocupação de não conseguir retroceder.
Quando questionados sobre o uso do zoom e se era possível comparar resultados, todos afirmaram que sim, dependendo do nível de detalhes e do nível máximo de zoom.
Um dos usuários indicou que todas as transformações seriam possíveis de serem comparadas exceto a operação de redimensionar (resize) pois as entradas possuem um tamanho fixo.
Apenas 2 usuários já haviam utilizado a funcionalidade de aplicar uma edição sobre um conjunto de imagens.
Os demais, após conhecerem a acreditavam que seria muito útil.
Um dos usuários disse que seria útil para aplicar uma edição para a remoção de olhos vermelhos num conjunto de imagens.
Análise dos resultados Analisando os resultados foi identificado que todos os usuários que avaliaram o protótipo aceitaram a nova forma de visualizar o fluxo de edição de imagens, principalmente com o incremento de funcionalidades como copiar e mover, o que era esperado pois o novo modelo aumenta o atual sem perder características do modelo já existente.
Outro fator identificado é que o uso de uma árvore permite aos usuários explorarem mais sem a preocupação de perder algum resultado, já que todas as alterações são mantidas na árvore.
Em relação a a automatização de uma edição, muitos não conheciam esta funcionalidade, mas após conhecerem identificaram vários usos para a mesma.
O presente trabalho sugere o uso de uma árvore para representar o fluxo de edição de imagens, tornando o fluxo em não-linear.
Foram apresentadas as deficiências do modelo linear, apresentando exemplos e em seguida foi introduzido o modelo proposto utilizando uma árvore, descrevendo as vantagens do uso da mesma.
Por fim foram abordadas as avaliações realizadas sobre o modelo, descrevendo os testes com os usuários.
Em este capítulo serão discutidas as contribuições deste trabalho, além de possíveis trabalhos futuros.
Modelo baseado em árvore Como visto no Capítulo 1 o modelo baseado em pilha tem algumas inconveniências para o usuário, como por exemplo a perda de transformações aplicadas quando o usuário retrocede e aplica uma nova transformação.
Isto motivou o estudo de uma alternativa para representar e armazenar este histórico.
Para solucionar alguns dos problemas encontrados, foi proposta a estrutura de árvore.
Com uma árvore é possível criar ramificações, que permitem ao usuário desfazer e refazer quaisquer transformações aplicadas anteriormente, sem a perda de transformações.
O uso de uma árvore possibilitou a implementação das operações de copiar e mover.
Como visto na avaliação do modelo elas auxiliam no reuso de transformações, diminuindo o trabalho do usuário.
Outro vantagem do modelo proposto é a persistência do histórico, pois normalmente quando se edita uma imagem todas as transformações aplicadas durante a edição são mantidas no histórico, no entanto quando este é fechado e reaberto as entradas do histórico são perdidas.
Em este modelo o histórico é salvo num arquivo XML e guarda a árvore com todos os seus nodos, o que facilita quando o usuário quiser retroceder uma edição posteriormente.
Isto auxilia o usuário a ver as transformações que já foram realizadas para chegar a um resultado e possibilita desfazer e refazer.
O uso de zoom sobre a área onde é apresentada a árvore auxilia na comparação de resultados, no entanto, podem haver transformações que possam ser imperceptíveis, como a operação de redimensionar (resize).
O modelo apresentado possibilita a edição de um conjunto de imagens, como por exemplo, a conversão de todas as imagens de uma pasta para tons de cinza, diminuindo assim o trabalho do usuário.
Isto também pode ser realizado utilizando um modelo linear, no entanto, só é possível gerar um resultado final.
Em o modelo baseado em árvore pode- se gerar vários resultados, por exemplo a execução da edição apresentada na Figura 6.1 onde existem 3 resultados finais.
Com estas vantagens é possível identificar que o uso de uma árvore auxilia na visualização e na edição de uma imagem.
A proposta incrementa o modelo atual, com o uso de uma árvore foi possível implementar funcionalidades que facilitam a edição para os usuários.
Trabalhos Futuros Em esta seção são discutidas funcionalidades e técnicas que podem ser implementadas para aprimorar o protótipo desenvolvido, além descrever problemas identificados e propor possíveis soluções.
O protótipo foi desenvolvido para identificar a eficácia do uso de uma árvore ao invés de uma pilha para representar o histórico de desfazer.
Após a avaliação pode- se identificar que os usuários foram favoráveis ao uso de uma árvore.
Como trabalhos futuros pode- se estudar o uso de um grafo ao invés de uma árvore, para realizar operações como a geração de uma imagem através da união de outras duas como mostra a Figura 3.2.
Um dos problemas do uso de uma árvore ou um grafo é seu tamanho, pois se a edição for extensa, o número de nodos pode ser significativamente grande.
Em este caso pode- se implementar técnicas para reduzir o número de nodos visíveis, como por exemplo a técnica Fisheye, que dá um zoom sobre o nodo corrente e os demais ficam menores.
Em relação a a funcionalidade de executar uma edição sobre uma pasta contendo imagens, foi identificado que seria possível criar uma interface para selecionar os resultados que devem ser gerados, pois atualmente a ferramenta gera todos os passos executados durante a edição.
No entanto o usuário pode optar por gerar apenas o resultado final, ou então apenas alguns resultados intermediários.
Uma alternativa seria uma interface que mostrasse todos os passos da edição e o usuário selecionasse as que desejam.
