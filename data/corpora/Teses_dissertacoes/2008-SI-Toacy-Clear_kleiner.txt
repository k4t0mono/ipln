Com o sucesso da MDA (Model Driven Architecture) e da UML (Unified Modeling Language), modelos estão substituindo código como o principal artefato de desenvolvimento de software.
Em MDA, a transformação e a composição de modelos são duas atividades essenciais.
Enquanto a transformação de modelos tem sido amplamente pesquisada e documentada, a composição de modelos precisa de mais investigação.
Com a MDA, surgiram três desafios: (
i) criar linguagens de modelagem específicas de domínios (DSML);
Compor DSML;
Compor modelos representados em DSML.
A UML permite a construção de DSML através de UML profiles, porém não oferece um mecanismo adequado para tais profiles.
Em este contexto, o presente trabalho apresenta uma proposta de mecanismo de composição de UML profiles fundamentado em regras de composição, regras de transformação de modelos, estratégias de composição, estratégia de comparação e regras de comparação.
Um modelo formal deste mecanismo foi construído utilizando a linguagem de modelagem formal Alloy e foi realizada uma análise automática do modelo usando Alloy Analyzer.
Além disso, uma ferramenta de software foi construída com o objetivo de validar o mecanismo e automatizar a abordagem.
Palavras-Chave: Os avanços alcançados no desenvolvimento de sistemas de software têm estimulado a construção de sistema de software com elevado nível de complexidade e tamanho cada vez maiores.
Estes sistemas têm destacado o inadequado nível de abstração fornecido por as modernas linguagens de programação de alto nível, como, por exemplo, Java, C&amp;, Python.
Assim, foi gerado uma demanda por linguagens, métodos e tecnologias que aumentam o nível de abstração em o qual os sistemas são idealizados, construídos e evoluídos.
Uma tendência em Engenharia de Software consiste em tratar, através do uso de linguagens de modelagem, programas no nível dos seus conceitos, com o objetivo de simplificar o projeto, a evolução e a manutenção destes.
Além disso, deseja- se aumentar a capacidade de adaptação frente a as rápidas mudanças das tecnologias e atender às exigências do time- to-- market.
Esta tendência propõe o aumento do nível de abstração em o qual os software são projetados e desenvolvidos, mudando o foco do código para os modelos.
De acordo com, estas mudanças são comparadas com o salto da linguagem assembly à terceira geração de linguagem de programação.
A MDA é um exemplo desta tendência, a qual trata- se de uma abordagem MDD da OMG.
Em o contexto da MDA, ao contrário de se construir software através da integração de componentes de software existentes, ou seja, colocando- os para interoperarem, o objetivo é construir novas aplicações ricas em funcionalidades a partir de a transformação e composição d modelos dos componentes de software existentes.
Em a MDA, a transformação e composição de modelos são duas atividades essenciais e têm se tornado cada vez mais importante.
A transformação de modelos tem sido pesquisada, documentada e tem alcançado avanços importantes, por outro lado, a composição de modelos necessita de maiores investigações e esforços para solucionar significantes problemas.
De acordo com, a composição de modelos trata- se de uma nova área de pesquisa e se encontra na sua &quot;infância».
Sendo assim, com a mudança do foco do código para os modelos, as linguagens de modelagem ganharam destaques e estão cada vez mais se adaptando e apresentando novos recursos, com o objetivo de aumentar suas capacidades de representação.
Várias linguagem de modelagem foram desenvolvidas, destacando- se a UML da OMG.
A UML é um linguagem de modelagem de propósito geral que apresenta a capacidade de modelar um grande e diversificado conjunto de domínios de aplicações.
Foi adotada como linguagem de modelagem padrão, sendo usada tanto comercialmente quanto na academia.
Porém, nem todas as suas capacidades de modelagem são necessariamente úteis em todos os domínios de aplicação, o que levou a linguagem a ser estruturada de forma modular, tornando possível o uso apenas de partes da linguagem as quais são de interesse para um domínio específico.
O sucesso da UML e da MDD têm direcionado e estimulado a proliferação do uso dos modelos.
Diante de isto, deseja- se desenvolver aplicações grandes e complexas (as quais geralmente são formadas por um conjunto de aplicações menores que representam os diversos domínios da aplicação) a partir de a composição dos modelos que representam os diferentes domínios da aplicação.
Ou seja, compor modelos específicos de domínio a fim de construir aplicações cada vez maiores.
Segundo, o desafio enfrentado é duplo:
Criar domínios conceituais capazes de modelar um conjunto grande de aplicações pertencentes a um domínio;
E compor modelos conceituais a fim de modelar uma aplicação específica.
Alinhado com estes dois desafios, surgem duas observações.
Primeira, por o fato da UML ser um linguagem de caráter geral e ter um escopo de aplicação muito grande, em determinada situações não é capaz de modelar aplicações definidas em domínios específicos.
Tal fato caracteriza a situação onde a sintaxe ou a semântica especificada na UML não é capaz de expressar conceitos de um sistema ou domínio em particular, ou quando deseja- se tornar os elementos já existentes mais restritos, ou seja, diminuir o seu escopo.
Sendo assim, surge a necessidade de criar um extensão da linguagem, ou seja, criar uma linguagem de modelagem específica de domínio (DSML).
Segunda, com a MDA surgiram três desafios:
Criar DSMLs;
Compor DSML's;
Compor modelos representados em DSMLs.
UML possam ser estendidos, permitindo, desse forma, que a UML seja adaptada a fim de aumentar ou especializar sua expressividade.
Esta extensão permite a UML atender as desse modo, um tópico de pesquisa em aberto.
Motivação Em esta Seção é especificada a motivação para a construção de uma nova abordagem para o Alguns esforços na área de composição de modelos têm sido realizados considerando a natureza inicial desta área de pesquisa, porém nenhum destes esforços são direcionados para a composição de DSMLs geradas a partir de o mecanismo de extensão conservativa de como realizar sua composição.
Exemplo de Divisão e Conquista Uma forma simples de entender e resolver problemas complexos é dividir- los em partes menores (princípio de divisão e conquista) (Pólya 2004).
Como a Engenharia de Software não é diferente neste aspecto, é seguido este princípio no exemplo de motivação.
Sendo assim, construir e modelar aplicações de grande porte pode implicar em fazer uso de diferentes plataformas de desenvolvimento e domínios de aplicação simultaneamente.
Além disso, modelar uma aplicação seguindo o princípio da separação de interesses, implica em evitar a construção de modelos grandes e monolíticos, os quais são difíceis de serem manipulados e entendidos.
Com isto em mente, uma boa forma de modelar uma aplicação, é dividir- la em domínios da aplicação para trabalhar com a heterogeneidade dos modelos e os conceitos específicos dos domínios.
Observando a Figura 1.1 (a) é possível notar uma especificação abstrata de uma aplicação Web, WebApp, a qual pode ser definida através da integração conjunto de entidades relacionadas aos seus domínios.
Para cada domínio, existe um Dx para representar uma visão abstrata do mesmo.
Os conceitos identificados em W ebAppx são representados e definidos seus relacionamentos em Dx, em o qual podem ser representados em termos de um metamodelo.
Este metamodelo inclui a definição dos conceitos do domínio, os relacionamento entre eles, e as restrições que governam tantas as estruturas estáticas, quanto as comportamentais destas entidades.
De modo similar, a Figura 1.1 (b) mostra uma aplicação que é implementada através de três camadas:
Interface, business, e database.
Para cada camada existe um metamodelo que representa os conceitos específicos do domínio e o relacionamento entre eles.
O stereotype Edge possui a tagged values name?;
Os stereotypes EndNode e Leaf representam conceitos de domínios iguais sendo aplicado com a mesma finalidade.
&quot;Tree Topology «&quot;Node «name $= «main.
Server &quot;value $= 10 «Node location &quot;$= «central «&quot;EndNode position «$= &quot;final «or?
&quot;MyApplication Node ApplicationSever Edge «&quot;Leaf, EndNode «Client or?
Problemática A semântica do mecanismo de composição da UML não é bem definida, sendo difícil de populares ferramentas de modelagem (como IBM Rational Software Modeler) não implementam o mecanismo de composição da UML.
De acordo com Rumbaugh, «Jacobson and Booch:
&quot;o uso do mecanismo de composição da UML pode gerar confusões e deve ser evitado se possível».
Sendo assim, é listado algumas problemáticas específicas que são abordadas nesta dissertação e que são descritas a seguir.
Problemática 01.
Não existe uma especificação clara de como deve ser realizada a composição de modelos, quais atividades devem ser realizadas e os passos a serem seguidos.
Problemática 02 (P2).
A semântica do mecanismo de composição da UML não é bem definida.
Em, isto tem sido definido como complexo, difícil e complicado de ser usado.
Tal argumentação é fundamentada por a ausência de uma especificação que defina o papel de cada modelo no processo de composição.
Problemática 03 (P3).
O mecanismo de composição da UML não é capaz de realizar a por exemplo, como dois stereotypes devem ser compostos.
Problemática 04 (P4).
Ferramentas de modelagem não implementam o mecanismo de composição de modelos definido na UML, por exemplo, IBM Rational Software Modeler.
Um vez que surja a necessidade de realizar a composição de elementos.
Questão de Pesquisa de composição) apresenta inconsistência, ambigüidade e define regras de composição gerais as quais são aplicadas aos metatypes do metamodelo que são mais freqüentemente utilizados, por exemplo:
Classes, Associations, Properties e entre outros.
Não existe um definição em de como deve ser realizada a sentido, surge a questão de pesquisa deste trabalho:
&quot;Como realizar a composição de Objetivos O estudo realizado neste trabalho tem como objetivo geral desenvolver um mecanismo de específicos têm- se:
Contribuições problemas, constituindo, desta forma, a base da contribuição.
Além de isto, este trabalho representa um primeiro esforço na realização de composição de DSML no contexto da UML e na elaboração de um guia de composição de modelos.
Assim, um resumo das contribuições geradas por a pesquisa descrita nesta dissertação é apresentado a seguir:
Estudo Comparativo dos Mecanismos de Composição:
A linha de pesquisa de composição de modelos necessita de estudos comparativos das abordagens existentes devido a o fato de se encontrar no seu estado inicial.
Logo, a descrição e comparação das abordagens de composição de modelos existentes caracteriza- se como uma contribuição.
Sendo assim, foi elaborado um resumo comparativo das semelhanças e diferenças de outras abordagem existentes com a da abordagem proposta.
Além de isto, este trabalho representa uma bom referencial na área de pesquisa de composição de modelos.
Operadores de Composição: Quatro operadores de composição são apresentados:
Match Operator;
Merge Operator; Composition Strategy Operator;
E Model Transformation Operator.
Estes operadores fazem uso de match rules, merge rules, e model transformation rules para desempenhar seus respectivos papeis dentro de o mecanismo de composição.
Estes operadores fazem parte do artigo publicado em.
Extensão do Metamodelo da UML: Com a construção de um metamodelo de composição de modelos que estende o metamodelo da UML é possível especificar o um metamodelo que define a sintaxe e semântica do relacionamento de composi-ção;
Regras de boa formação que especificam as restrições no relacionamento de composição;
Descrição da semântica de composição.
Modelo Formal do Mecanismo de Composição: O mecanismo de composição foi modelado em Alloy, uma linguagem formal baseada em teoria dos conjuntos e lógica de predicado, apresentando um aspecto formal do proposta, algo não apresentado na UML.
Este modelo formal permite realizar verificações, análises automáticas do mecanismo, e checar a corretude da proposta.
Uma vez definido o modelo formal, foram realizadas análises de algumas propriedades algébricas utilizando o Alloy Analyzer.
Além de isto, com o modelo formal, futuras evoluções da proposta ou do metamodelo da UML podem ser analisadas com o objetivo de verificar o impacto das mudanças na abordagem.
Com isso, é possível checar se a abordagem é válida, ou inválida perante as modificações.
Uma outra importante contribuição é a construção do mecanismo de composição baseado em regras de composição, regras de transformação de modelos, regras de comparação, estratégia de comparação e estratégias de composição.
Com isso, é possível desenvolver outros trabalhos adaptando estas regras e estratégias para outros contextos.
Etapas da Pesquisa O trabalho apresentado neste documento foi realizado por meio de várias etapas, as quais estão representadas por a Figura 1.3 e são descritas a seguir:
Etapa 1: Em essa etapa realizou- se um estudo sobre os mecanismos de composição existentes, onde coletou- se informações sobre as formas e técnicas utilizadas na realização de composição.
Ainda nessa etapa, realizou- se um levantamento das estratégias usadas para solucionar os conflitos que surgem durante a composição e um estudo aprofundado da UML.
Etapa 2: Em essa etapa realizou- se uma análise dos resultados obtidos da Etapa 1 para identificar os procedimentos e as fases que são freqüentes no mecanismos de composição.
Com base nestas observações, foi desenvolvido o mecanismo de composição da UML para representar o mecanismo de composição.
Etapa 3: Em essa etapa realizou- se um especificação formal do mecanismo de composição proposto na Etapa 2 na linguagem Alloy.
Etapa 4: Baseado no mecanismo desenvolvido na Etapa 2 e na especificação da Etapa 3 foi desenvolvido a ferramenta de composição de modelos MoCoTo (Model Composition Tool).
Etapa 5: Após o desenvolvimento da ferramenta na Etapa 4, foi realizado a composição dissertação.
Etapa 1 Etapa 2 Identificação dos procedimentos e das atividades nos mecanismos de composição.
Estrutura do Trabalho A dissertação é organizada nos seguintes capítulos:
Anexo A:
São apresentados diagramas do metamodelo da UML que são utilizados ao longo de a dissertação.
Anexo B: É apresentado uma descrição das regras de composição utilizadas na abordagem.
Anexo C: É apresentada a modelagem do mecanismo de composição em Alloy, juntamente com a análise modelagem.
Anexo D: É apresentado um histórico dos trabalhos desenvolvido durante o transcorrer da pesquisa.
Fundamentação Teórica Antes de apresentar a definição do mecanismo de composição, é necessário descrever alguns conceitos relacionados a proposta desta dissertação.
Em este capítulo é apresentada da UML.
Esta descrição serve como base para justificar as peculiaridades apresentadas descrito de forma resumida a fim de caracterizar a necessidade de uma abordagem para Unified Modeling Language A UML é uma linguagem visual que é aplicada para a especificação, construção e documentação de artefatos de software.
Trata- se de uma linguagem de modelagem de propósito geral que pode ser usada com o paradigma orientado a objetos ou a componentes.
Além disso, a linguagem caracteriza- se por a aplicabilidade em diferentes domínio de aplicações e plataformas de implementação (por exemplo J2EE, J2ME, CORBA).
Além disso, a UML tem se tornado um linguagem de modelagem padrão, sendo usada tanto na indústria quando na academia.
Arquitetura da UML A especificação da UML é baseada na abordagem de metamodelagem, o que implica em ter um metamodelo responsável por a sua definição.
Este metamodelo foi implementado seguindo os seguintes princípios:·
Modularidade: Visa uma forte coesão e um baixo acoplamento na definição da linguagem.
Isto é caracterizado por a definição de pacotes, que representam áreas conceituais, e a organização dos recursos da linguagem em metaclasses.·
Camada: A arquitetura do metamodelo é definida em quatro camada com o objetivo de separar os interesses nas quartos camadas de abstração.
Além disso, é aplicado na definição dos pacotes para separar em camadas os principais elementos daqueles que o utilizam.·
Partições: É aplicado para organizar áreas conceituais dentro de as camadas.
Isto fornece flexibilidade exigida por os padrões atuais de metamodelagem.
Em o metamodelo da UML, isto é representado por a forte coesão dentro de os pacotes e baixo acoplamento.·
Extensibilidade: É aplicado para tornar a linguagem extensível.
A UML é estendida por duas formas:
Criando um dialeto da linguagem através do uso de da UML.·
Reuso: A definição do metamodelo de forma granular facilita o reuso da definição da linguagem.
XMI (XML Metadata Interchange) para UML, MOF (Meta Object Facility) e outros metamodelos que são baseados na InfrastructureLibrary;
E Constructs, contém metaclasses concretas que são usadas para modelar linguagem orientada a objetos, sendo usado por o MOF e UML.
Core é usado para definir os construtores usado na especificação de metamodelo, sendo usado para definir, por exemplo, a UML e o MOF.
A definição do metamodelo da UML é estruturada em quatro camadas hierarquicamente organizadas.
A camada de meta-metamodelagem (M3) tem o objetivo de especificar a linguagem utilizada para definir a UML, nesta camada encontra- se o MOF.
A UML encontra- se especificada na camada de metamodelo (M2) que tem como objetivo definir linguagens para definir modelos.
A camada de modelo contém instâncias dos metamodelos definidos em M2, representando os modelos do usuário.
Esta estrutura co-existir na mesma camada com os elementos que o definem, ou seja, eles são definidos por os elementos presentes na camada M2 e também fazem parte desta, quebrando a ordem natural do processo de instanciação.
Por o fato da UML ser uma linguagem de caráter geral e ter um escopo de aplicação muito grande, em determinada situações não é capaz de modelar aplicações definidas em domínio específico (por exemplo, área financeira, aplicações de tempo real, aplicações multimídia, entre outros).
Isto caracteriza a situação onde a sintaxe ou a semântica especificada na UML não é capaz de expressar conceitos de um sistema em particular, ou quando deseja- se tornar os elementos já existentes mais restritos, ou seja, diminuir o seu escopo.
Sendo assim, surge a necessidade de criar um extensão da linguagem.
A OMG define duas formas de definição de linguagem específicas de domínios.
A primeira é baseada na definição de uma nova linguagem, representando uma linguagem alternativa a UML.
Para isto, é utilizado os mecanismos fornecidos por a OMG para definição de linguagens visuais orientada a objetos.
Esta abordagem representa a mesma forma utilizada para a definição da UML.
Sendo assim, a sintaxe e a semântica dos elementos na nova linguagem são definidas para atender as características específicas do domínio.
Novas linguagens são construídas usando o MOF, o qual consiste de uma linguagem projetada para a definição de linguagem de modelagem orientada a objetos.
CWM representa um exemplo de linguagem criada com o MOF, onde a semântica dos elementos da linguagem não são equivalentes aos definidos na UML.
A segunda alternativa consiste na especialização da UML.
Para isto, alguns elementos definidos da UML são especializados através da definição de restrições sobre os mesmos.
Porém, com esta abordagem, o metamodelo da UML é respeitado, deixando a semântica original dos elementos da UML inalteradas (por exemplo, as propriedades de classes, operações e entre outros elementos permanecem inalteradas).
Novas notações podem ser definidas a fim de uma melhor representação dos conceitos.
Com o objetivo de disponibilizar extensão conservativa, a UML fornece um conjunto de mecanismo de extensão (como stereotype, constraints e tagged values) para especializar seus elementos.
Com isto, é possível gerar versões customizada da UML para atender às exigências de domínios específicos.
Um vez definidas estas adaptações, estas A construção de uma linguagem baseada na adaptação da UML produzirá elementos e notações que atendem as exigências e as necessidades apresentadas por os conceitos específicos de um domínio.
Entretanto, como não é respeitado a semântica definida na UML, a extensão não permite o uso de ferramentas comerciais de modelagem para gerar os diagramas, gerar código, fazer engenharia reversa, e etc (Fernández&amp; suportados por as ferramentas comerciais de modelagem, porém podem não ser capazes de especificar determinadas necessidades e exigências.
Definir qual tipo de extensão utilizar não é uma tarefa fácil, a qual dependerá das necessidades e da experiência com a suas limitações.
Uma nova semântica é definida, porém não deve ser contraditória a definida no metamodelo de referência.·
Deve apresentar notações gráficas para representar os stereotypes.·
Ser capaz de especializar a semântica de determinados elementos do metamodelo da UML.
Por exemplo, para representar um relacionamento de herança definido em única.·
Deve apenas utilizar os três mecanismos de extensão da UML, sendo eles:
Stereotypes, tagged values, e constraints.
Juntamente com os modelos que os mesmos devem ser aplicados, por meio de o uso ser definido como um modelo UML permutável.·
A definição de tagged values deve ser formalizada.
Em particular, tagged values são tipificadas com o objetivo de especificar exatamente quais valores são e quais as naturezas de eles.
O tipo de um tagged value deve ser algum tido de dados definido na UML, ou alguma classe ou stereotype, podendo ser um tipo de dado incorporado ou definido por o usuário.
Além disso, tagged values multivaloradas.
A UML trata- se de uma linguagem de modelagem de propósito geral que cobre um grande espectro de domínios de aplicação.
Porém, quando aplicada para modelar domínios específicos apresenta algumas limitações diante de a necessidade de representar conceitos específicos destes domínios.
Sendo assim, uma especialização ou extensão dos conceitos definidos na UML permite adaptar- la a fim de tornar- la capaz de representar peculiaridades num domínio específico.
A extensão do metamodelo com o objetivo de aumentar o poder de representação com o objetivo de satisfazer as necessidade e as exigências de um subdomínio.
Para isto, a UML fornece mecanismos de refinamento, são eles: (
i) tagged values; (
ii) stereotypes;
Stereotype Stereotype define como uma existente metaclasse pode ser estendida com o objetivo de modificar modificando de alguma forma a sua semântica.
Adiciona ou substitui terminologias ou notações já existentes com o objetivo de gerar adaptações.
Em a sua definição no metamodelo, um stereotype trata- se de uma construtor que estende a metaclasse Class.
A definição dos stereotypes no metamodelo da UML segue o mesmo padrão da definição dos outros construtores.
Porém, a criação de um stereotype tem um peculiaridade, pois a sua instância não caracteriza a criação de um &quot;modelo de usuário «(ver Figura 2.2), mas sim um novo construtor inserido na definição do metamodelo.
Em outras palavras, vistos como uma &quot;camada virtual «na camada M2.
A fim de ter uma melhor representação é possível associar imagens aos stereotypes.
A Figura 2.3 ilustra o uso de stereotypes.
Tagged Value Em a UML 1.
3, tagged values poderiam estender o metamodelo sem a necessidade de ter stereotype associado.
Em a UML 2.
0, uma tagged value pode ser utilizada apenas associada a um stereotype e sua estrutura é basicamente formada por &quot;nome «e &quot;tipo».
Sendo assim, para fazer uso de tagged value é necessário primeiro definir um stereotype e depois inserir a tagged value no stereotype.
Constraints Uma constraints trata- se de uma restrição semântica representada como uma expressão textual.
Cada expressão tem uma linguagem de interpretação implícita, a qual pode ser uma notação de matemática formal, por exemplo a notação de teoria dos conjuntos;
Linguagem de restrição baseada em computação, por exemplo OCL;
O objetivo do uso das constraints consiste na especificação de restrições que não são possíveis de serem representadas usando a sintaxe abstrata da UML.
As restrições são representadas através de string's entre chaves, podem ser fixadas numa lista de elementos, entre dependências, ou dentro de um nota.
Além disso, estas constraints tem o papel fundamental na definição de regras de boa formação, as quais devem ser respeitadas para a construção de um modelo válido.
A Figura 2.4 ilustra de forma simples o uso de constraints.
Adicionar semântica que não são especificadas;
Adicionar restrições limitando o uso do metamodelo e de seus construtores;
Inserir informações que podem ser usadas quando o modelo é transformado em outro modelo ou em código.·
Especializar a UML para determinadas tecnologias:
Linguagem de programação, middleware, ou banco de dados são naturais candidatos a definir um específico estensões, tais como:
&quot;métodos virtuais», &quot;identificadores», restrição &quot;not null», etc.· Especializar a UML para modelagem de processo de desenvolvimento de software:
A UML é utilizada de forma diferentes nas fases do desenvolvimento do de uso.
Mecanismo de Composição da UML A UML apresenta um mecanismo de composição, package merge, que define como dois pacotes são compostos.
O package merge é aplicado no metamodelo da UML a fim de tornar possível a implementação dos compliance levels definidos na mesma.
Este mecanismo define terminologias e uma semântica para o relacionamento de composição entre dois pacotes.
O uso do package merge é indicado quando elementos definidos em pacotes diferentes tem nomes iguais e se deseja que estes representem um mesmo conceito.
É aplicado para fornecer diferentes definições de um dado conceito para diferentes propósitos, iniciando com uma definição base.
Dado um conceito base, este é estendido em incrementos, com cada incremento definido num merged package diferente.
Através da seleção do incremento que deve ser composto é possível obter uma definição de um conceito para um determinada finalidade.
Por a natureza da atividade desenvolvida por o package merge, este pode ser visto como uma operação que tem dois pacotes de entradas e gera um pacote de saída que representa a combinação do conteúdo dos pacotes envolvidos na composição.
Além disso, os pacotes de entrada e o de saída possuem semântica equivalente.
O package merge trata- se de um DirectedRelationship entre dois pacotes representado por a palavra-chave &quot;merge».
O pacote de origem do relacionamento é definido como receiving package;
E o destino como merged package.
O resultado da composição é representado por o resulting package.
Em a Figura 2.5 é mostrado um exemplo simples do uso do package merge.
O package merge é definido basicamente com match rules, constraints e transformations.
As match rules são utilizadas para especificar quando um elemento do pacote receiving e um do merged representam conceitos equivalentes, devendo ser compostos para representar um elemento único no resulting package.
A comparação dos elementos dos pacotes é baseada no &quot;nome «dos mesmos.
As constraints especificam as pré-condições que devem ser satisfeitas para tornar a composição possível.
Em determinada situação é possível ter dois elementos que são considerados equivalentes, porém não podem ser compostos devido a a violação de algum restrição.
Sendo assim, a composição destes elementos pode produzir algum elemento inválido.
Em geral, a composição é considerada inválida se os elementos possuem alguma incompatibilidade.
Por exemplo, a composição de duas operações é considerada inválida se apresentam algum inconformidade, o fato das duas operações terem nomes iguais, porém com tipo de retorno diferente invalida a composição.
Outro possível exemplo seria dois elementos considerados equivalentes, porém com restrições contraditórias também invalidam a composição.
As transformations definem como a composição é realizada de fato.
Estas definem a pós-condição da composição, ou seja, qual o resultado esperado da composição, se todas as restrições são satisfeitas.
Como regra padrão para realizar a composição é definido que se um elemento do merged package não possui um elemento equivalente no receiving package, este elemento deve ser copiado para o resulting package.
O package merge não apresenta transformations para todos os metatipos presentes no metamodelo, apresentando apenas para os mais comuns (como Class, Association, Properties, e entre outros).
Se dois elementos são iguais, o elemento resultante da composição é também igual a eles.
Por outro lado, se os elementos são diferentes a transformation define como estes elementos são inseridos no resulting package.
Análise Comparativa das Abordagens de Composição de Modelos Este seção tem como principal objetivo apresentar os principais trabalhos relacionados à composição de modelos utilizados no contexto desta pesquisa.
Analisando a literatura atual, é possível observar que a composição de modelos tem sido objeto de pesquisa na comunidade de Engenharia de Software em diferentes contextos.
Porém, foi constatado que por ser uma área de pesquisa nova, conseqüentemente, tendo trabalhos recentes e em Sendo assim, o seu desenvolvimento tem se baseado em trabalhos em diversas áreas de pesquisa, como:
Integração de banco de dados;
Modelagem orientada aspecto;
Composição de código fonte;
Transformação de modelos.
Como o principal interesse desta pesquisa está relacionado à identificação das serão analisados, a seguir, os trabalhos que contribuíram para esta pesquisa.
A análise comparativa das abordagens de composição de modelos é baseada nos critérios listados abaixo:
Possui formas diferentes de realizar a composição?
Feitas? Abordagem Etapas da composição:
A abordagem apresentada em contempla as etapas de comparação e composição dos modelos.
Poucas considerações são feitas sobre quais atividades são necessárias para realizar a comparação e a composição, não ficando explícito como os modelos de entrada são manipulados para compor suas estruturas.
Forma de verificar equivalência:
A proposta apresenta um processo de composição baseado em assinatura, onde uma assinatura consiste de um conjunto de propriedades sintáticas do modelo.
Para esta abordagem, dois modelos são equivalentes, se, e somente se, tiverem as propriedades definidas nas assinaturas iguais.
Porém, considerado apenas a assinatura como elemento de comparação torna o processo de comparação deficiente.
Por exemplo, modelos que possuem nomes diferentes podem representar conceitos iguais.
Forma de realizar a composição:
Nenhuma consideração é feita a respeito como as propriedades dos modelos devem ser modificadas para expressar a composição.
É apresentado um algoritmo que realiza a composição de dois modelos.
Porém nada é exposto sobre como os valores das propriedades dos modelos que apresentam valores diferentes são tratadas.
Por exemplo, como duas classes com nomes iguais, porém com visibilidades diferentes são compostas.
Logo, como compor dois métodos sendo um de visibilidade public e o outro de visibilidade private?
Questão deste tipo não pode ser respondida.
Tratamento de problemas:
Nenhuma consideração é feita explicitamente no trabalho.
Porém, é feito referência à diretivas de composição como as responsáveis por o tratamento de conflitos.
Representação da proposta:
A abordagem apresenta um metamodelo de composição que descreve como realizar a composição baseada em assinatura.
Para isto apresenta propriedades estáticas e comportamentais para dar suporte a composição de modelos orientados a aspectos.
Porém, o metamodelo foi idealizado com o objetivo de ser usado no desenvolvimento da ferramenta de composição, não para expressar a abordagem proposta.
Além disso, não apresenta uma instância do metamodelo expressando o uso do mesmo.
Escopo da abordagem:
A proposta destina- se a composição de modelagem orientada a aspectos.
Ou seja, composição dos aspectos que representam os cross-cut concerns e os primary model.
Validação da abordagem:
Para validar a proposta é utilizado a linguagem Kermeta para desenvolver uma ferramenta que implementa a técnica de composição baseada em assinatura.
Relação com a abordagem proposta:
Apesar de esta abordagem se basear na comparação por assinatura, existe uma grande distância entre a mesma e a apresentada nesta dissertação.
A forma de comparação não apresenta flexibilidade na maneira de comparar e apresenta dificuldades na realização de verificação de novos tipos de modelos, por exemplo, um modelo do tipo enumeration.
A extensão do metamodelo da UML não apresenta uma definição semântica e nem regras de boa formação, limitando- se a uma descrição em linguagem natural, ao contrário de a apresentada neste trabalho de dissertação.
Além disso, não apresenta uma especificação formal da abordagem.
Abordagem Etapas da composição:
A abordagem apresentada em dá suporte a comparação, composição e tratamento de conflitos.
Porém, não apresenta uma descrição de como estas &quot;atividades «se relacionam e não descreve um fluxo entre as atividades.
Forma de verificar equivalência:
A proposta apresenta um processo de composição baseado em nomes, o que representa uma desvantagem da proposta.
Pois comparação de modelos baseada apenas em &quot;nome», não é refinada o bastante para identificar a similaridade dos conceitos representados por os modelos.
Por exemplo, dois atributos com nomes iguais e tipos diferentes serão compostos por a abordagem, o que representa um problema.
Forma de realizar a composição:
Esta abordagem apresenta duas formas de realizar composição, sendo representado por:
Override e merge strategy.
Apesar de esta abordagem ser uma das mais completas na especificação de diferentes formas de realizar composição, a mesma apresenta limitadas regras de composição para as estratégias em linguagem natural.
Nada é exposto como os valores das propriedades dos modelos que apresentam valores diferentes são tratadas.
Por exemplo, como duas classes com nomes iguais, porém com propriedades (isAbstract $= true e isAbstract $= false) diferentes são compostas.
Tratamento de problemas:
Apresenta tratamento de apenas quatro tipos de confli- te os:
Precedence, especifica a precedência entre os elementos correspondentes;
Explicit, conflito tratado em nível do modelo composto cujo objetivo é especificar uma referência explícita a outro modelo;
Default, especifica valores padrão para determinada propriedades dos modelos;
TransformationFunction, especifica uma função para definir a especificação da reconciliação entre modelos correspondentes.
Representação da proposta:
É apresentado uma extensão da UML e a sua construção foi construída seguindo o padrão apresentado na UML, definindo:
Sintaxe abstrata;
Regras de boa formação;
Semântica. A extensão apresenta conceitos que também são encontrados nesta extensão do metamodelo da UML apresentada nesta dissertação, como:
CompositionRelationchip; ComposableElement;
E CompositeElement.
Porém, apresentam semânticas diferentes.
Escopo da abordagem:
Composição de subjects.
Validação da abordagem:
Nenhuma consideração é feita sobre a validação utilizando algum formalismo ou através da construção de ferramenta.
Relação com a abordagem proposta:
Apesar de a abordagem ser bem estrutura e tratar pontos importantes na composição de modelos, a mesma apresenta desvantagens em relação as questões tratadas nesta dissertação.
O processo de comparação apresentado nesta dissertação tem maior poder de identificação de equivalência entre os modelos, justificado por as diferentes pontos considerados na momento da comparação, como:
Tipografia, estrutura do modelo e a semelhança entre conceitos do domínio.
Esta abordagem, além disso, não apresenta nem nenhuma verificação formal, nem ferramenta que faça uma validação conceitual da abordagem.
Abordagem Etapas da composição:
A abordagem apresentada em tem como objetivo retirar ambiguidade e inconsistência no package merge.
Além disso, visa dar suporte a comparação e composição.
Porém, não apresenta uma descrição da interação entre as duas etapas presentes.
Forma de verificar equivalência:
A abordagem usa apenas o &quot;nome «dos modelos para definir a correspondência entre eles, caracterizando uma desvantagem da abordagem, sendo equivalente a neste sentido.
Para realizar a comparação são utilizados regras de correspondências, que se comparam com as default match rules descritas nesta dissertação.
Apesar de a presença das regras de correspondência, fica distante da flexibilidade e o poder de definição de similaridade apresentado nesta dissertação.
Forma de realizar a composição:
Esta abordagem se caracteriza por apresentar regras de composição considerando as propriedades sintáticas definidas no metamodelo da UML, caracterizando um ponto forte da abordagem.
Porém, estratégias de composição não são apresentadas, sendo assim, apenas uma forma de composição é possível de ser realizada, sendo esta forma comparável à realizada por a merge strategy apresentada neste trabalho de dissertação.
Tratamento de problemas:
Nenhuma consideração é feita sobre os problemas que surgem com a composição.
Representação da proposta:
Não é apresentado nenhuma extensão do metamodelo da UML, porém é representado por um DirectedRelationship representado por com merge.
Escopo da abordagem:
Composição de diagrama de classes UML e pacotes.
Validação da abordagem:
A validação da proposta é realizada através de uma verificação formal.
Para isto, é utilizado a linguagem Alloy.
Além disso, foi desenvolvido uma ferramenta utilizando como base o EMF e integrada ao Rational Software Architecture.
Relação com a abordagem proposta:
Apresenta desvantagens em relação a questão de definição de equivalência, devido a a forma de realizar a comparação baseado apenas no nome.
Assim como o trabalho apresentado nesta dissertação, é apresentada uma modelagem Alloy e uma ferramenta visando a validação conceitual da proposta.
As regras de composição desta abordagem foram tomadas como base para a elaboração das Abordagem Etapas da composição:
A abordagem apresentada em considera a comparação, composição e o tratamento de conflitos como atividades essenciais na composição de modelos orientado a aspecto.
É enfatizado como deve ser realizada a comparação, composição e o tratamento de conflitos.
Além disso, é apresentado um fluxograma das atividades necessárias para solucionar problemas relacionados a composição através de diretivas de composição.
Forma de verificar equivalência:
Para obter uma visão integrada dos modelos orientados a aspecto, é considerado nomes dos modelos como base para determinar a equivalência entre os mesmo.
Além disso, é utilizado o conceito de &quot;assinatura «(conjunto de propriedades sintáticas que devem ser consideradas para realizar a comparação) a fim de melhorar o processo de definição de equivalência.
Pois é possível verificar a estrutura do modelos usando assinaturas.
Dois modelos são considerados equivalentes se, e somente se, tiverem assinaturas iguais, porém para modelos com nomes diferentes e que representam um mesmo conceito, a abordagem não é capaz de identificar- los como equivalentes.
Sendo assim, a não consideração do valor semântico dos modelos configura uma limitação da abordagem.
Forma de realizar a composição:
Esta abordagem utiliza diretivas de composição para realizar a composição, sendo esta representada como um empacotamento de modelos primários (representam os core concerns) e aspectuais (representam os crosscut concerns).
Para realizar a composição, modelos com assinaturas equivalentes representam visões consistentes de um mesmo conceito, logo, devem ser compostos.
Estas diretivas são especificadas usando um formato pré-definido.
Tratamento de problemas:
O tratamento de problemas que podem surgir durante a composição é considerado por a abordagem com um atividade fundamental.
Para isto, são definidas diretivas de composição (post-merge directives) com o objetivo de realizar modificações no modelo visando solucionar os conflitos e os problemas encontrados no modelo composto.
Representação da proposta:
Um metamodelo de composição é definido, o qual apresenta propriedades estáticas e comportamentais associadas a composição de modelos.
Para isto, é utilizado a Kermeta, uma linguagem de metamodelagem que extende o MOF com linguagem de ações, sendo compatível com o EMF.
Dentro os conceitos apresentados, têm- se:
Mergeable, representa os modelos que podem ser compostos;
Signature, instância deste elemento define representações de assinaturas.
Escopo da abordagem:
Composição de modelos orientado a aspectos.
Validação da abordagem:
Para validar a proposta é utilizado a linguagem Kermeta para implementar a parte principal do metamodelo.
Porém, não apresentando, por exemplo, a implementação das diretivas de composição.
Relação com a abordagem proposta:
Assim como o trabalho apresentado nesta dissertação, utiliza assinatura na comparação entre os modelos.
Porém, apenas a utilização das assinaturas para definir a equivalência entre os modelos configura uma desvantagem.
Os objetivos delegados às diretivas de composição, se assemelham com aos das regras de composição e transformação de modelos utilizadas por o merge operator e model transformation operator, respectivamente.
O metamodelo se diferência do metamodelo da UML e do metamodelo apresentado no Capitulo 6 por não definir a composição como um relacionamento entre dois modelos (conforme o conceito de relationship Abordagem Etapas da composição:
A abordagem apresentada em especifica a necessidade da realização de comparação e composição efetivamente.
Para isto, são definidos um conjunto de operações que realizam estas atividades.
Forma de verificar equivalência:
Para definir a correspondência entre os modelos, é especificado a necessidade de um operador de match.
Porém, não especifica como a comparação e a definição da equivalência deve ser determinada.
Forma de realizar a composição:
Não é especificado como a composição deve ser realizada.
É definido a necessidade de um operador de composição para tornar a composição de modelos possível, o qual gera um modelo composto a partir de dois modelos de entradas e um definição de relacionamento entre eles.
Tratamento de problemas:
Nenhuma consideração é feita em relação a problemas e a conflitos que surgem durante a composição.
Representação da proposta:
A proposta é apresentada através de uma descrição de um conjunto de operadores de composição.
Nenhum consideração é feita em relação a sua representação no contexto da UML.
Escopo da abordagem:
A proposta visa ser aplicável a todos os domínios de aplicação de composição modelos.
Validação da abordagem:
Nenhuma validação é realizada, apenas exemplos mostrando aplicabilidade da abordagem são descritos.
Relação com a abordagem proposta:
Consiste de um framework unificado para o entendimento dos problemas da composição de modelos e visa fornecer um vocabulário para a discussão das idéias centrais em composição.
Os operadores de match e merge descritos na abordagem tem objetivos iguais aos dos match e merge operator descritos no Capitulo 4.
As propriedades algébricas definidas em são usadas na validação formal do trabalho proposto nesta dissertação, tais como:
Idempotênica; Comutatividade;
Associatividade; Inversa;
Monotonicidade; E totalidade.
Abordagem Etapas da composição:
A abordagem apresentada em tem foco na comparação e composição.
Forma de verificar equivalência:
É especificado um operador de match para encontrar correspondência entre os modelos.
Para determinar a equivalência, o match operator faz uso de heurísticas para encontrar a similaridade tipográfica, estrutural e semântica entre os modelos.
O objetivo da comparação é gerar uma tabela de similaridade que especifica o grau de correspondências entre os elementos de duas statecharts.
Forma de realizar a composição:
Para realizar a composição é definido um operador de composição.
Este operador tem dois modelos de entrada e uma descrição do relacionamento de correspondência entre os mesmos.
O objetivo do operador é construir um modelo composto que contenha os comportamentos compartilhados por os modelos de entradas, como um comportamento normal, e os não compartilhados como variabilidades.
A composição preserva a semântica dos modelos de entrada, o que representa um ponto muito positivo desta abordagem.
Tratamento de problemas:
Nenhuma consideração é feita em relação a os problemas e aos conflitos que surgem durante a composição.
Representação da proposta:
Nenhuma consideração é feita em relação a representação da proposta como uma extensão da UML.
Escopo da abordagem:
Composição de statecharts.
Validação da abordagem:
Para avaliar os operadores propostos foi desenvolvido a ferramenta Tremer, a qual compõe statecharts dado um correspondência entre elas.
Além disso, é analisado a complexidade da realização de um comparação considerando aspectos estáticos, onde n1 e n2 representam o número de estados nos modelos de entradas) e os comportamentais (O (c×m1 ×m2), onde c é o número máximo de interações para o algoritmo de comparação de comportamento, e m1 e m2 representam o número de transição nos modelos de entrada) Relação com a abordagem proposta:
A relação com a abordagem proposta nesta dissertação consiste na forma de comparar dois modelos através de similaridade tipográfica.
Não é considerado aspectos comportamentais como em, nem conservação da semântica dos modelos de entrada não é garantida no modelo de saída.
Como semelhança têm- se:
As atividades de comparação e composição são desempenhadas por operadores;
Usa- se similaridade tipográfica e lingüística;
Representação da correspondência entre os modelos de entrada através de uma tabela de similaridade.
Abordagem Etapas da composição:
A abordagem apresentada em define apenas a comparação e a composição como etapas importante para a representação da composição de modelos.
Forma de verificar equivalência:
Nenhuma consideração é realizada quanto a forma de se realizar a comparação, apenas que a comparação e a definição de correspondência é necessária.
A correspondência é representada através do stereotype ConceptOverlap.
A correspondência entre features de classes pertencentes a domínios diferentes é representado com o stereotype FeatureCorrespondence.
Forma de realizar a composição:
A composição é representada como uma associa-ção entre conceitos de diferentes domínios, tendo com alguns de eles partes equivalentes.
A composição de visões estáticas de diferentes domínios visa formar uma linguagem de meta-modelagem que seja capaz de modelar um domínio ou a composição destes domínios.
Tratamento de problemas:
Nenhuma consideração é feita em relação a os problemas e aos conflitos que surgem durante a composição.
Representação da proposta:
Define um extensão do metamodelo da UML capaz de representar sua modelagem e a sua composição.
Ou seja, uma linguagem de meta-modelagem específica de domínio.
Escopo da abordagem:
Composição de modelos em software federation.
Validação da abordagem:
Nenhuma forma de validação é apresentada.
Relação com a abordagem proposta:
A relação com a abordagem proposta nesta dissertação consiste na apresentação de uma extensão do metamodelo da UML para representar composição de modelos, porém estas extensões possuem pouca semelhança.
A partir de a Figura 3.1 observa- se que:·
Etapas: Nenhuma das abordagens estudadas fornecem um guia de composição de modelos.
Todas as abordagens tem a comparação e composição como atividades fundamentais.·
Comparação: Nenhuma abordagem apresenta estratégias de comparação.
As abordagens não combinam diferentes maneiras de realizar comparação a fim de melhor definir a correspondência entre os modelos de entrada.·
Composição: Alguns abordagens não deixam claro como a composição é realizada efetivamente.
Apenas uma abordagem estudada apresenta a definição de estratégias de composição e nenhuma abordagem apresenta simultaneamente estratégias de composição, regras de composição e operador de composição.
Nejati et al.
2007 Estublier &amp; Ioneta 2005 Legenda:·
Transformação de Modelos:
Apenas duas abordagens apresentam a preocupação em tratar problemas que surgem durante a composição, porém apenas uma de elas faz uso de algo semelhante as regras de transformação de modelos definidas nesta dissertação.·
Validação: Apenas uma abordagem faz uso de linguagem formal para validação da abordagem, sendo a maioria validada através de ferramentas.
Porém, alguns não apresentam nenhum forma de validação, sendo a maioria tendo seus resultados questionáveis.·
Representação: Verifica- se uma parcial preocupação em adaptar a UML a fim de tornar- la capaz de representar composição de modelos.
Apenas uma abordagem faz uso de sintaxe abstrata, regras de boa formação e definição de uma semântica para definir a extensão.
Definição do Mecanismo de O problema central resolvido neste dissertação consiste em fornecer um mecanismo de é apresentado o mecanismo de composição de modelos com o objetivo de solucionar tais problemas.
Esta abordagem é baseada em quatro operadores:
Match Operator, responsável por definir a equivalência entre os modelos de entradas do mecanismo de composição;
Merge Operator, responsável por realizar a composição dos modelos;
Composition Strategy Operator, responsável por definir a estratégia de composição a qual a composição deve seguir;
Model Transformation Operator, responsável por solucionar problemas e conflitos que surgem durante a composição dos modelos de entrada.·
Especificando os Modelos de Entrada:
Em esta seção são especificados os modelos de entrada do mecanismo de composição.·
Problemas Encontrados na Definição do Mecanismo de Composição da UML:
Em esta seção são apresentados alguns problemas encontrados no mecanismo de composição da UML juntamente com a solução.·
Definição dos Operadores de Composição: Esta seção se detém na definição dos operadores de composição.
Cada operador é responsável por um conjunto de atividades, sendo o conjunto destas atividades a representação do mecanismo de composição na sua essência.
Em o contexto de orientação a objetos, tendo duas classes, Classe A e Classe B, quando é estabelecido um relacionamento de herança da Classe B em relação a a Classe A, isto implica que os atributos e métodos da Classe A devem ser inseridos (herdados) na Classe B. Observa-se que quando é estabelecido o relacionamento de herança, a Classe A assume o papel de superclasse e a Classe B o papel de subclasse.
De esse modo, qualquer referência realizada à Classe B (agora como subclasse), na verdade, implica em fazer referência a todos os atributos e métodos definidos tanto na Classe A (agora como superclasse) quanto na Classe B (observando que alguns atributos e métodos da Classe A podem ser sobrescritos).
Especificando os Modelos de Entrada Especificar os modelos de entrada implica em definir o domínio do mecanismo de composição, o qual é definido a partir de a especificação do tipo de modelos que o mesmo é capaz de compor, ou seja, os operandos da composição.
Os elementos que não fazem parte deste domínio, poderão ser compostos possivelmente com a extensão desta abordagem.
De esse da UML Em a perspectiva do mecanismo de composição, os elementos a serem compostos podem ser agrupados e distribuídos na forma de uma árvore.
Esta representação é baseada na associação no relacionamento de tipo &quot;composição «entre eles e na observação do metamodelo da UML, onde determinados modelos possuem propriedades e podem conter outros elementos através de alguma forma de associação.
Com a finalidade de mostrar os elementos que são candidatos a serem compostos por o mecanismo proposto, os mesmos são representados na Figura 4.4 através de uma estrutura de árvore.
Sendo assim, existem dois tipos de elementos, os elementos que são &quot;nodo», que representam os elementos que são formados por outros elementos, e os que são &quot;folhas», que não são compostos por nenhum outro elemento.
Os nodos serão chamados composite, e as folhas de primitive, termos definidos em.
Um exemplo de composite é Stereotype, Class, Association, Enumeration e Interface.
Como exemplo de primitive tem- se:
Property, Parameter, Constraints e Tagged Values.
Para definir quais elementos serão composites e quais elementos serão primitives, foi levado mencionado anteriormente de &quot;composição», como segue:·
composite: São elementos não granulares, ou seja, aqueles elementos que contêm outros elementos, sendo isto especificado no metamodelo da UML através de associação de composição.
Diante de o relacionamento de composição, os composites não são vistos como unidades elementares, sendo sua composição representada por a composição de suas partes.
Por exemplo, dado um stereotype, o qual é um elemento composite, a sua composição é realizada por a composição de suas operações, tagged values e todas suas propriedades sintáticas.·
primitive: São elementos vistos de forma granular diante de o relacionamento de composição.
Em o metamodelo da UML são caracterizados por fazer referências a outros elementos, porém não através de associação de composição.
Isto pode ser ilustrado com as Property que faz referência a Type (esta referência à Type ela herda de StructureFeature) e não possui nenhum associação de composição com outros elementos.
Observando que Association também possui uma referência à Type, porém possui uma associação de composição com Property o que a caracteriza como uma Composite.
A partir de a Figura 4.4 é possível observar que:
E Enumeration.·
Association: É um composite que possui Property.·
Stereotype: É um composite que possui Tagged Values e Operation.·
Class: É um composite que possui Property e Operation.·
Enumeration: É um composite que possui EnumerationLiteral.·
Operation: É um composite que possui Parameter.·
Property: É um primitive, o que implica em não ter outro tipo de elemento.·
Tagged Values: É um primitive, o que implica em não ter outro tipo de elemento.·
Parameter: É um primitive, o que implica em não ter outro tipo de elemento.
Problemas Encontrados na Definição do Mecanismo de Composição da UML O objetivo desta seção é apresentar os problemas encontrados na definição do mecanismo de composição da UML e mostrar as soluções para estes problemas.
Este mecanismo é formado por match rules, constraints e transformations, como descrito na Seção 2.3, porém apresenta ambigüidade, suas regras não são completas e apresenta inconsistência de acordo com a semântica de composição definida no mecanismo.
A seguir é apresentada uma descrição.
Definição não é completa· A fim de que as regras do mecanismo de composição sejam completas, as mesmas devem apresentar, para cada metaclasse definida na especificação da UML uma match rule;
Para cada elemento da metaclasse (como por exemplo atributos, operações ou associações) deve existir uma transformation associada (Zito 2006).
Sendo assim, foram elaboradas regras de comparação e regras de composição quatro operadores de composição especificado na Seção 4.4 e um guia de composição de modelos especificado na Seção 4.5.
Apresenta ambigüidade· O package merge, assim como a UML, é especificado através de linguagem natural, o que implica no surgimento de dúvidas, incerteza e diferentes interpretações da sua definição, configurando, desta forma, sua ambigüidade.
Para solucionar esta através de alguma linguagem ou notação formal.
Em este contexto, a solução apresentada nesta dissertação foi modelada num linguagem formal as regras propostas com o objetivo de verificar sua corretude e evitar ambigüidade.
Apresenta inconsistência· A inconsistência do package merge se configura através das suas definições que são incompatíveis com a sua semântica atual definida, por exemplo, algumas transformation contradizem o que é especificado na semântica do package merge.
Sendo assim, foram propostas regras de composição de acordo com a semântica apresentada nesta dissertação e a especificação formal permitiu retirar as inconsistência.
Para definir quais match rules e transformations não foram definidas e quais de elas são ambíguas, foi tomado como base: (
i) o padrão existentes nas regras já definidas; (
ii) observação do metamodelo da UML;
E (iii) o trabalho em (Zito 2006).
Estas são descritas como segue:
Metaclasse Package As regras ambíguas e as regras não definidas para a metaclasse Package presente no Regras Ambíguas (Ra):
Não apresenta regras ambíguas.
Regras Não Definidas (RnD):·
RnD 1.1: Não é definido nenhuma transformação para o valor default.·
RnD 1.2: Não é definido nenhuma transformação para as operações.·
RnD 1.3: Não é especificado nenhuma transformação para o elementImport ou packageImport herdados de Namespace.·
RnD 2.4: Não é especificado nenhuma transformação para realizar a composição de comentários.
Metaclasse Class Regras Ambíguas (Ra):
Não apresenta regras ambíguas.
Regras Não Definidas (RnD):·
RnD 2.1: Não é definido nenhuma transformação para o atributo superClass.·
RnD 2.2: Não é definido nenhuma transformação para as operações.·
RnD 2.3: Não é especificado nenhuma transformação para o elementImport ou packageImport herdados de Namespace.·
RnD 2.4: Não é especificado nenhuma transformação para realizar a composição de comentários.
Metaclasse Association As regras ambíguas e as regras não definidas para a metaclasse Association presente no Regras Ambíguas (Ra):
As Match Rules são ambíguas.
Regras Não Definidas (RnD):·
RnD 3.1: Não é definido nenhuma transformação para as associações especializadas.·
RnD 3.2: Não é especificado nenhuma transformação para o elementImport ou packageImport herdados de Namespace.
Metaclasse Parameter As regras ambíguas e as regras não definidas para a metaclasse Parameter presente no Regras Ambíguas (Ra):
As Match Rules são ambíguas.
Regras Não Definidas (RnD):·
RnD 4.1: Não é definido nenhuma transformação para o default valor.·
RnD 4.2: Não é especificado nenhuma transformação para o atributo direction.·
RnD 4.3: Não é definido nenhuma transformação para type herdado de TypedElement.
Metaclasse Operation As regras ambíguas e as regras não definidas para a metaclasse Operation presente no Regras Ambíguas (Ra):
As Match Rules são ambíguas.
Regras Não Definidas (RnD):·
RnD 5.1: Não é definido nenhuma transformação para as exceptions.·
RnD 5.2: Não é especificado nenhuma transformação para o atributo direction.·
RnD 5.3: Não é definido nenhuma transformação para type herdado de TypedElement.
Metaclasse Property As regras ambíguas e as regras não definidas para a metaclasse Property presente no Regras Ambíguas (Ra):
As Match Rules são ambíguas.
Regras Não Definidas (RnD):·
RnD 6.1: Não é definido nenhuma transformação para o valor default.·
RnD 6.2: Não é especificado nenhuma transformação para o atributo isDerivedUnion.·
RnD 6.3: Não é definido nenhuma transformação para type herdado de TypedElement.
Sendo assim, é apresentado uma solução a qual visa solucionar estes problemas em complemento as citadas anteriormente.
Esta é organizada em três formas, como segue:
Composição Iterativa:
Todos os elementos que são contidos por um outro elemento serão compostos de forma iterativa, ou seja, todo composite deve ter seus elementos primitive compostos iterativamente.
Como mostrado anteriormente, um elemento é contido por outro, quando existe um relacionamento de associção do tipo &quot;composição «entre eles.
Por exemplo, a metaclasse Class possui dois relacionamentos de composição sendo um com a metaclasse Operation e o outro com a metaclasse Property no Anexo A na página 143).
Para realizar a composição de forma iterativa deve seguir os seguintes passos:
Composição Dirigida por Estratégia:
Elementos que constituem os merged elements e os receiving elements fazem referência a outros elementos, porém não os contém.
Por exemplo, a metaclasse Operation faz apenas referência à metaclasse Type, porém não a contendo.
Estas referências que os merged elements e os receiving elements fazem deve ser compostas seguindo um estratégia de composição e aplicação de regras de transformação quando surgirem conflitos.
A Figura 4.7 ilustra é possível obter três resultados seguindo as três estratégias de composição.
Esta estratégias são descritas com o objetivo de ilustrar.
Estes resultados são ilustrados na Figura 4.7-B. De esse modo, observa- se que:·
Override Strategy: O output model produzido seguindo esta estratégia tem· Merge Strategy:
O output model produzido seguindo esta estratégia tem· Union Strategy:
O output model produzido seguindo esta estratégia tem nome, pois existem dois stereotype com nomes iguais num mesma namespace.
Estas estratégias de composição são descritas com maiores detalhes no Capítulo 6.
Composição de Propriedades:
Para realizar a composição de propriedades de determinas metaclasses é necessário realizar um tratamento adequado das características das propriedades.
Estas propriedades são definidas no metamodelo da UML como atributos das metaclasses, como por exemplo, o atributo isAbstract da metaclasse Class pode assumir os valores true, para definir que a instância de Class é uma classe abstrata, e false, para definir que a instância de Class é uma classe concreta.
De essa forma, como compor uma classe abstrata com uma concreta?
Isto é possível?
Respostas para estas perguntas são definidas nas regras de composição especificas para a propriedade.
Outro exemplo é o atributo visibility da metaclasse Element, a mesma pode assumir os valores public, private, protect e package, então surge novamente outra questão:
Como compor dois atributos sendo um public e outro private?
Respostas para estas perguntas são apresentadas na definição da regra de composição desta propriedade.
Sendo a forma de atuação da regras depende do tipo de estratégia de composição.
Definição dos Operadores de Composição Em esta seção são definidos os operadores relacionados ao mecanismo de composição, são eles:
Match operator;
Merge operator;
Composition strategy operator;
E model transformation operator.
Estes operadores são os responsáveis por as atividades pertencentes ao mecanismo de composição, fazendo uso de regras de composição (merge rules), regras de comparação (match rules) e regras de transformação de modelo (model transformation rules).
Este operadores são descritos a seguir.
Match operator O Match Operator trata- se de uma heurística e seu objetivo é definir a grau de equivalência entre os elementos dos modelos de entrada.
Para definir o grau de equivalência entre os similaridade tipográfica entre nomes do modelos de entrada.
Dicionário de Sinônimo Com o dicionário de sinônimo é possível o especialista de domínio fazer uso da sua expertise no domínio e aplicar- la no processo da definição do grau de equivalência entre o modelos de entrada.
Assim, é possível definir a equivalência entre conceitos (representados através de assinaturas dos modelos) do domínio que é difícil de ser identificado por a comparação tipográfica e por a análise da estrutura sintática dos modelos.
A Tabela 4.1 mostra um exemplo simples de dicionário de sinônimos, a qual possui duas colunas:
Name, para representar o conceito que possui sinônimos associados a ele;
E Synonym, para especificar, de fato, os sinônimos.
Durante a composição de modelos baseada na assinatura, nomes semelhantes, os quais representam o mesmo conceito num domínio, pode ser considerados não equivalentes.
Por exemplo, dado dois stereotype Estudante e Estudantes, os mesmos representam string's diferentes, logo devem ser considerados elementos &quot;totalmente «não equivalentes, o que é errado.
Diante deste problema, é utilizado similaridade topográfica para definir um grau de similaridade baseado na assinatura.
A similaridade tipográfica é determinada como T (r, m) para todos os a similaridade tipográfica é usado o algoritmo N-gram, o qual define um valor entre para todo par de (r, m).
Os pares são definidos a partir de o elementos, logo serão formados (R×M) $= (5×7) $= 49 comparações, assim tendo 49 graus de similaridade.
Assinatura dos Modelos A fim de levar em consideração a estrutura dos modelos de entradas para determinar sua equivalência são determinadas as &quot;assinaturas dos modelos».
Para cada tipo de modelo de entrada existe uma definição de uma assinatura para o mesmo.
A assinatura é definida em termos de as propriedades sintáticas dos modelos definidas no metamodelo da UML, onde as propriedades sintáticas definem a estrutura do modelo.
A assinatura é uma coleção de valores para um dado subconjunto de propriedades sintáticas definidas no metamodelo da UML.
Por exemplo, isAbstract é uma propriedade sintática definida dentro de a metaclasse Class especificada no metamodelo da UML.
Se a instância de Class é abstrata, então isAbstract $= true, caso contrário a instância é uma classe concreta, isAbstract $= false.
O conjunto de propriedades sintáticas utilizadas para definir a assinatura de et al.
2004). Uma signature type que consiste de todas as propriedades sintáticas associadas de modelo é então chamada de complete signature type, para as signature type que são apenas baseadas em algumas propriedades sintáticas dos modelos são nomeadas como partial signature type, já para as signature type que são apenas baseadas no nome dos modelos é nomeada como default signature type.
Por exemplo, uma possível partial signature type para uma operação seria um subconjunto consistindo das seguintes propriedades definidas na metaclasse Operation, tais como:
Name, o seu valor consiste do nome da operação;
E ownedParameter, o seu valor é uma coleção de parâmetros associados com as operações.
Sendo assim, quando é realizado a comparação de duas operações, considerando esta partial signature type é considerado apenas o nome da operação e parâmetros definidos para a mesma.
Observando As assinaturas são estruturas em &quot;níveis hierárquicos de comparação».
Por exemplo, na Figura 4.11, uma possível definição dos níveis de comparação de uma partial signature type para os stereotypes, a qual leve em consideração apenas as propriedades sintáticas name e property, seria:
Tree. Node (name) (nível 2), com Tree.
Node. Name (property) (nível 1).
Para determinar o grau de similaridade baseada na signature type (M) entre um receiving element (r) e um merged element (m) M (r, m) foi criado uma equação com objetivo de mensurar/ dar um valor ao grau de similaridade.
Esta equação consiste numa média pondera de médias aritméticas, representada na Equação 4.1.·
pi representa os pesos, sendo pi $= i, onde i 1 e i N+· k expressa o número de elementos em cada nível, onde k 1 e k N+.
Por exemplo, Tree.
Node tem duas propriedades, como estas propriedades representam um nível, logo k $= 2.
O grau de similaridade entre um receiving element e um merged element é representado por S. Para definir S é necessário combinar D, T, e M definidos anteriormente.
O valor de S é obtido através da Equação 4.2.
Se D $= 1, então T também assume valor 1 (um), e vice-versa.
Match Rules A fim de auxiliar o processo de definição de equivalência entre os receiving elements e merged elements foram definidas algumas match rules.
O match operator é o responsável por o uso destas regras e, de acordo com o resultado da execução, o mesmo define o valor de i, j, o qual foi especificado anteriormente.
Para todos os possíveis tipos de elementos ao mesmo.
As match rules são definidas considerando as definições apresentadas no MOF e no metamodelo da UML.
Existem três tipos de match rules:·
Default match rules:
São um conjunto de regras que se relacionam para verificar a equivalência dos modelos consideram apenas os nomes dos elementos que os formam.
Por exemplo, default match rule para um stereotype levaria em consideração o nome do stereotype, o nome das suas propriedades, o nome das suas operações, e etc..
Quanto mais refinada for necessária a comparação entre os modelos mais nomes das propriedades devem ser considerados.·
Partial match rules:
São um conjunto de regras que se relacionam para verificar a equivalência dos modelos consideram um subconjunto das propriedades sintáticas dos elementos que os formam.
Por exemplo, partial match rule para um stereotype levaria em consideração o nome do stereotype, a propriedade isAbstract do stereotype, a propriedade isDerived, e etc..
Quanto mais refinada for necessária a comparação entre os modelos mais propriedades devem ser consideradas.·
Complete match rules:
São um conjunto de regras que se relacionam para verificar a equivalência dos modelos consideram todas as propriedades sintáticas dos elementos que os formam.
Por exemplo, complete match rule para um stereotype levaria em consideração todas as propriedades sintáticas definida no metamodelo da UML.
Uma vez que uma complete match rule deve considerar todas propriedades sintáticas do elemento, logo quando esta regra retorna 1 (um) como resultado da comparação entre dois modelos, isto indica que os mesmos são iguais.
O mecanismo de composição proposto apresenta três tipos de estratégias de comparação entre os modelos de entrada:
Default match strategy, faz uso das default match rules;
Partial match strategy, faz uso das partial match rules;
E complete match strategy, faz uso das complete match rules.
A diferença entre cada uma de elas é tipo de match rules as quais as mesmas fazem uso.
Se é desejado uma comparação mais refinada, deve ser utilizado a complete match strategy, para uma comparação com um baixo grau de refinamento deve ser utilizado a default match strategy.
MR1. Stereotype match rule:
MatchStereotype (Stereotype rcv, Stereotype mrgd) rcv.
Name $= mrgd.
Name And MatchAttribute (rcv, mrgd) And MatchOperation (rcv, mrgd) MR2.
Association match rule:
MatchAssociation (Association rcv, Association mrgd) (rcv.
Name $= mrgd.
Name) And (rcv.
MemberEnds $= mrgd.
MemberEnds) MR3.
Attribute match rule:
MatchAttribute (Stereotype rcv, Stereotype mrgd) (rcv.
OwnedAttribute. Name $= mrgd.
OwnedAttribute. Name) And (rcv.
OwnedAttribute. TypedElement $= mrgd.
MR4. Operation match rule:
MatchOperation (Stereotype rcv, Stereotype mrgd) (rcv.
And (rcv.
OwnedOperation. OwnedParameter.
Length $= mrgd.
OwnedOperation. OwnedParameter.
Length) And (x (rcv.
OwnedOperation. OwnedParameter $= mrgd.
OwnedOperation. OwnedParameter) MR5.
Enumeration match rule:
MatchEnumeration (Enumeration rcv, Enumeration mrgd) rcv.
Name $= mrgd.
Name And MatchEnumerationLiteral (Enumeration rcv, Enumeration mrgd) MR6.
Enumeration Literal match rule:
MatchEnumerationLiteral (Enumeration rcv, Enumeration mrgd) x (rcv.
OwnedLiteral. Name $= mrgd.
OwnedOperation. Name) Composition Strategy Operator O objetivo deste operador é especificar como a composição deve ser realizada.
Em outras palavras, este operador determinar quais regras de composição deve ser utilizada por o Merge Operator, definido na SubSecção 4.4.3.
Para isto, este operador faz uso das estratégias de composições definidas.
Foram definidas três estratégias de composição:
Override; Union;
E merge.
Estas estratégias são brevemente descritas a seguir:
Override Strategy. Esta estratégia especifica que as partes que são equivalentes (overlapping parts) do receiving element devem sobrescrever as overlapping parts do merged element.
Sendo assim, as overlapping parts do receiving element são inseridas novos elementos inseridos, esta estratégia deve ser usada, configurando, desse modo, um cenário de aplicação desta estratégia.
Union Strategy. Esta estratégia especifica que todo receiving element e merged element devem ser inseridos no composed model.
A composição realizada seguindo esta estratégia se caracteriza por ser uma composição conservativa.
Quando é necessário esta regra deve ser usada configurando, desse modo, um cenário de aplicação desta estratégia.
Merge Strategy. Esta estratégia especifica que as overlapping parts do receiving element e merged element são combinadas a fim de obter uma visão integrada das mesmas, enquanto que as non-overlapping parts são apenas inseridas no composed model.
Isto seguindo esta estratégia, representando, desse modo, um cenário de aplicação.
Merge Operator O merge operator trata- se de uma heurística e seu objetivo é realizar a composição de modelos.
Para realizar a composição é necessário saber o grau de equivalência entre os modelos de entradas e uma estratégia de composição a ser seguida.
Para realizar a composição, de fato, o merge operator faz uso de regras de composição (merge rules) as quais são especificadas no Anexo B na página 147.
Dado dois modelos de entrada, o merge operator faz uso de merge rules para obter um modelo que representa uma visão integrada dos mesmos.
Este operador assume que os modelos de entrada representam visões diferentes e consistentes de um mesmo conceito.
O merge operator necessita de três entradas:
Match model, os modelos que são equivalentes;
Match description, uma descrição da equivalência definindo quais elementos devem ser compostos;
Composition strategy, especifica qual estratégia de composição deve ser seguida para realizar a composição.
Uma ilustração do merge operator é mostrado na Figura 4.9.
Para compor dois modelos de entrada, o merge operator deve identificar as partes que são compartilhadas entre eles, partes estas chamadas de overlapping parts.
As partes que não são iguais são chamadas de non-overlapping parts.
Para produzir uma visão integrada dos modelos de entrada é necessário compor as overlapping parts, sendo a forma desta composição definida por a estratégia de composição especificada, e as non-overlapping parts, as quais são apenas inseridas no composed model.
De acordo com, a composição de modelos pode ser vista como um operação, a qual dado dois modelos MA e MB, tem como saída um produto MAB.
Isto pode ser representado por MA+ MB -- MAB.
Em nosso contexto, a composição da composição.
Esta equação é representada para o merge operator como:
Merge (MM, MD, CS) $= Cm, sendo estes elementos descritos abaixo.
Match Models (Mm):
Mm representa o conjunto de receiving element e merged element que são equivalentes.
Por exemplo, a Figure 4.11 (a) possui basicamente quatro equivalências entre Tree e Topology: (
i) Tree.
Node e Topology.
Node; (ii) Tree.
Leaf e Topology.
EndNode; (iii) Tree.
Edge e Topology.
Edge; (iv) Tree.
StateKind e Topology.
StateKind. Match Description (Md):
Md denota o relacionamento de equivalência entre os elementos de Mm..
Por exemplo, o Match Description do Mm anteriormente descrito seria: (Tree.
NodeTopology. Node); (
Tree. LeafTopology.
EndNode); Composition Strategy (Cs):
Cs especifica como os modelos devem se integrados.
De o objetivo inicial da composição, representando, desse modo, uma forma flexível de realizar composição.
Composed Model (Cm):
Cm representa o resultado da composição.
Merge rules são usadas por o merge operator para especificar a composição entre receiving element e merged element que são equivalentes.
Estas regras definem efetivamente como a composição deve ser realizada.
Sendo assim, para cada elemento de entrada do mecanismo de composição deve existir um merge rule definida capaz de especificar como este elemento deve ser composto com o seu equivalente.
As merge rules são formadas basicamente por um nome, dois elementos de entrada, e uma saída que representa o resultado da composição.
As merge rules são definidas no Anexo B. Sendo assim, com o objetivo de especificar a composição, foi criado Merge Specification Rule que é especificada seguindo o modelo de especificação, a seguir:
Name: Define o nome da regra.
Description: Usado para descrever como a regra deve ser aplicada.
Syntax: Especifica a sintaxe da regra.
Pre-Condition: Especifica as condições que devem ser satisfeitas para que uma regra seja executada.
Estas condições podem ser expressadas através de linguagem formais (por exemplo Z, VDM, Alloy), OCL ou através linguagem natural.
Post-Condition: Define as condições que deves ser satisfeitas após uma regra ter sido executada.
Estas condições podem ser expressadas através de linguagem formais (por exemplo Z, VDM, Alloy), OCL ou através linguagem natural.
Uma vez definido o modelo é possível descreve a regra de especificação de composição seguindo este modelo, como segue:
Merge Specification Rule (MSR) Name:
Regra de especificação de composição Description:
O objetivo desta regra é especificar a composição de dois modelos de acordo com uma estratégia de composição.
Cada estratégia de composição produzirá, possivelmente, modelos compostos diferentes.
Esta regra tem seis operandos:
Dois modelos de entrada;
Duas namespace dos modelos de entrada;
A especificação da estratégia de composição;
Estratégia de comparação.
Context: Usada na composição de dois modelos Syntax:
Pre-condition: A CompositionStrategy deve descrever uma estratégia de composição válida.
Para ser &quot;válida «a mesma deve ser definida dentro de o mecanismo de composição.
Post-condition: A regra de produzir um modelo de saída válido.
Uma vez que MSR tenha sido especificada, um conjunto de merge rules são utilizadas para realizar a composição.
Por exemplo, para compor dois stereotypes Tree.
Node e Topology.
Node de acordo com a estratégia de composição MergeStrategy e a DefaultMatchStrategy, tem- se a seguinte sintaxe de MSR:
Model Transformation Operator O model transformation operator trata- se de uma heurística e seu objetivo é identificar e solucionar problemas que surgem durante a composição, e assegurar que &quot;desejadas características «estejam presentes no output model.
Alguns dos problemas que este operador trata são: (
i) referência a elementos que não existem;
conflito de nome, ou seja, elementos com nomes iguais numa mesma namespace;
número elevado de elemento, por exemplo, grande quantidade de atributos;
Elemento em determinada namespace, porém fazendo referência a outra namespace.
Este operador tem três entradas:
Composed model;
Desired features;
E well-- formedness rules.
Como saída é produzido o output model, o resultado da composição.
A Figura 4.9 mostra uma representação deste operador.
Sendo assim, para produzir o output model o operador faz uso de model transformation rules.
Estas rules dão capacidade ao operador de manipular o modelo de entrada, composed model, para produzir o modelo de saída, output model, que representa efetivamente o resultado da composição.
Em este sentido, dado um composed model o operador verifica se existe algum problema e se os recursos desejados são encontrados.
Para isto ele faz uso de well-- formedness rules e desired features.
Quando uma well-- formedness rule ou um desired feature não é respeitada, isto representa uma bad-formedness conflict.
Para todo o problema identificado as regras de transformação devem ser aplicadas com o objetivo de solucionar- los.
Model Transformation Rules (MTR) As model transformation rules criadas têm as seguintes capacidades:·
Criar e deletar modelos.·
Adicionar e remover modelos de um namespace.·
Renomear elementos de modelos.·
Alterar/ Atualizar referências entre os modelos.
Para definir estas regras é utilizado o modelo apresentado anteriormente para definir a merge specification rule, como segue:
MTR1. Criar novo modelo Name:
Create Description: Este regra de transformação é utilizada para criar um novo modelo.
A função desta regra se assemelha com uma factory, tendo a capacidade de criar os modelos de reflexão definido no MOF (CMOF:
Reflection) (OMG 2002).
Para fazer uso desta regra é necessário: (
i) fornecer o tipo do elemento que será criado;
E (ii) os argumentos exigidos (quando necessário), os quais são definidos no metamodelo da UML.
Um exemplo de propriedade que deve ser especificada no momento da criação do elemento consiste em isAbstract definida na metaclasse Class, a qual assume valor true ou false.
Context: Criar novo modelo Pre-condition:
Checar se todos argumentos são válidos e se existem argumentos para as propriedade obrigatórias para criar o modelo.
Post-condition: A regra deve criar um modelo corretamente.
Além disso, é possível fazer referências a well-- formedness rules e desired features com o objetivo de verificar se o elemento criado não possui um bad-formedness conflict.
MTR2. Deletar um modelo Name:
Delete Description: Esta regra é aplicada quando determinado modelo deve ser deletado.
Ela possui dois operandos:
O modelo que deve ser deletado;
Namespace de origem.
Context: Deletar um modelo Syntax:
Pre-condition: Tanto a Namespace e o elemento a ser deletado devem ser elementos válidos e devem existir.
Todos os operandos devem estar corretamente especificados.
Post-condition: A regra deve deletar um modelo corretamente.
Além disso, é possível fazer referência a well-- formedness rules e desired features a fim de verificar se bad-formedness conflict são criados após a deleção do modelo.
Por exemplo, na Figura 4.11, se a enumeration TreeTopology.
StateKind é deletada, então surge um &quot;conflito de referência», pois o stereotype faz uma referência para a mesma, representado por TreeTopology.
Root. State.
Em a Figura 4.11, deletar o stereotype TreeTopology.
Node levaria ao surgimento de um &quot;conflito de referência», pois os stereotypes TreeTopology.
Leaf, TreeTopology.
Root e TreeTopology.
MainNode fazem referência a ele.
MTR3. Inserir um modelo numa Namespace Name:
Insert Description: Todo modelo deve ter uma namespace.
Portanto, o objetivo da regra é inserir um modelo a uma Namespace.
Para isto são necessários dois operandos: (
i) o modelo (por exemplo um stereotype) que será inserido;
E a (ii) Namespace especificando onde o modelo deve ser inserido.
Context: Inserir um modelo num Namespace.
Syntax: Pre-condition:
Checar se a Namespace existe e verificar o nome do operador.
Todos os operandos devem estar corretamente especificado.
Post-condition: O modelo de ser inserido corretamente na Namespace.
MTR4. Renomear um modelo numa Namespace Name:
Rename Description: O objetivo da regra é renomear o modelo, a fim de evitar conflito de nome.
Por exemplo, duas tagged values de diferentes stereotypes têm nomes iguais e devem ser values deve ser renomeada.
Esta regra tem três operandos:
O modelo (por exemplo stereotype, Operation, etc.) que deve ser renomeado;
especificação da namespace;
E (iii) o novo nome que será atribuído ao modelo.
Context: Renomear um modelo numa Namespace Syntax:
Pre-condition: O modelo deve estar definido numa Namespace.
Post-condition: A regra deve inserir o modelo corretamente.
MTR5. Criar uma associação entre dois modelos Name:
CreateAssociation Context: Criar uma associação entre dois modelos.
O primeiro operando cria uma associação com o segundo operando, sendo os mesmos de tipos iguais.
Por exemplo, não é possível cria uma herança entre uma stereotype e uma enumeration.
Para especificar a regra foi utilizado o princípio de reflexão definido no MOF (CMOF:
Reflection) (OMG 2002).
Sendo assim, é criado a associação utilizando uma Factory entre os dois modelos.
Syntax: Pre-condition:
Os argumentos devem estar corretamente especificados.
Post-condition: A associação entre os modelos devem ser corretamente criada.
MTR6. Alterar referência entre modelos Name:
ReplaceReferences Context: Alterar referência entre os modelos.
Description: Um modelo pode fazer referência a um outro modelo que não existe, logo originando um conflito de referência (reference conflict).
Sendo assim, é aplicado esta regra.
Esta regra faz uso da replaceReferences directive definida em para resolver o conflito.
Syntax: ReplaceReferences originalName:
Name Pre--condition: Os argumentos devem ser especificados.
Post-condition: A referência entre os modelos deve ser alterada corretamente.
Guia para Composição de Modelos Em a comunidade de Engenharia de Software, não existe um consenso sobre as atividades e as particularidades inerentes a composição de modelos, muito menos uma descrição ou esboço das características de um soluções em composição de devido a a complexidade do tema.
Como conseqüência, todos trabalhos inicializados que abordem o tema precisa de um grande investimento de tempo e esforço.
Sendo assim, com o objetivo de modificar esta realidade, foi analisado um conjunto de trabalhos visando fazer um levantamento dos requisitos básicos, das atividades e das necessidades pertinentes à composição de modelos.
Feito isto, foi elaborado um guia de composição de modelos que tem como principal objetivo auxiliar o desenvolvimento da trabalham isoladamente, então uma visão integrada das atividades desenvolvidas por os mesmos é necessária.
De esse modo, o guia de composição elaborado especifica o fluxo de atividades dos operadores a fim de obter uma completa interação e alinhamento entre as atividades desenvolvidas por eles.
Além disso, o guia visa representar boas práticas e tornar tão compreensível quanto possível o papel dos operadores na composição.
Este guia é mostrado na Figura 4.10, o qual estende por introduzir a especificação do fluxo de atividades dos operadores, refinar a forma de comparação entre os modelos, por fornecer uma nova forma de especificar a composição e transformação.
A fim de ter uma visão clara do mecanismo de composição de modelos, a abordagem de composição possui quatro fases:
Entrada. Então, este operador analisa os modelos de entrada com o objetivo de entrada são separados e agrupados de acordo com seus tipos.
Por exemplo, Stereotype e Association são identificados e agrupados de acordos com seus tipos.
Comparison Phase. Baseado na análise dos modelos de entrada, a assinatura de todos Esta fase é finalizada assim que a descrição de equivalência, os modelos equivalentes e os não equivalentes são definidos.
Merge Phase. O objetivo desta fase é produzir o composed model.
Para isto, o composition strategy operator define a estratégia de composição que será usada por o merge operator.
Uma vez que a descrição de equivalência, os modelos equivalentes e não equivalentes são definidos, o merge operator realiza a composição dos modelos equivalentes.
Esta fase é finalizada assim que o composed model é criado.
Post-Composition Phase.
O objetivo desta fase compreende nos objetivos do model transformation operator definido anteriormente.
Baseado em desired features e wellformedness features, este operador verifica se o modelo possui alguma má formação.
Sendo esta má formação representada como conflitos.
Quando conflitos são encontrados, o operador utiliza model transformation rules a fim de solucionar estes conflitos.
O próximo passo é executar a transformação.
O modelo de saída desta fase é produzido assim que nenhum conflito é identificado.
The output model representa o resultado da composição.
De esse modo, a fim de especificar e compor Tree e Topology) são utilizados a regra de especificação de composição e o guia definido anteriormente é utilizado, como segue:
LocalEdge e Tree.
Edge são de tipos iguais e são aplicados a Association, então são &quot;agrupados».
Tree. Statekind, Topology.
Node, Topology.
EndNode, Topology.
StateKind. Sendo assim, a descrição de equivalência definida é: (Tree.
NodeTopology. Node), (Tree.
LeafTopology. EndNode) and (Tree.
StateKindTopology. StateKind).·
Passo 01: Toda referência para Topology.
StateKind deve ser alterada para TreeTopology.
StateKind, sendo assim tem- se:·
Passo 02: O stereotype TreeTopology.
Leaf deve estender TreeTopology.
Root, assim, tem- se:
LocalEdge Estratégias de Composição Em este capítulo são descritas as estratégias de composição especificadas nesta dissertação.
O objetivo destas estratégias é dar flexibilidade à composição através da apresentação de diferentes maneiras de realizar a composição de modelos.
Ao longo de o capítulo são apresentadas três seções:·
Override Strategy: Em esta seção é apresentada a descrição da estratégia override, do seu cenário de aplicação e de sua semântica.·
Union Strategy: Em esta seção é apresentada a descrição da estratégia union, do seu cenário de aplicação e de sua semântica.·
Merge Strategy: Em esta seção é apresentada a descrição da estratégia merge, do seu cenário de aplicação e de sua semântica.
Override Strategy O relacionamento de composição baseado na override strategy especifica que os elementos Em esta seção será detalhada a semântica de composição baseado na Override Strategy, para isto tem- se as seguintes Subseções contendo:·
possíveis cenários de aplicações do relacionamento de composição baseado na override strategy;·
a descrição da semântica de composição de override strategy.
Cenários de Aplicação software, os domínios das aplicações estão constantemente evoluindo, sendo esta evolução caracterizada, ou por o incremento de novos requisitos, ou por a alteração dos já existentes.
Com isso, o metamodelo é alterado a fim de refletir as alterações do domínio.
De a mesma através da composição baseada na Override Strategy.
Outro cenário de aplicação para Override Strategy é no contexto de GSD (Global Software Development).
Onde equipes distribuídas trabalham na especificação de Definir a estratégia de composição a qual relacionamento de composição deve seguir, implica em especificar a forma como os modelos devem ser compostos.
Compor seguindo a override strategy consiste em definir que as overlapping parts do receiving Quando o relacionamento de composição tem override strategy como estratégia de composição, esta composição passa a ter a mesma semântica do relacionamento de herança.
Um exemplo de composição seguindo esta estratégia de composição é mostrado é equivalente ao da subclasse (receiving elements) sobrescritos.
Ou seja, todo o receiving element que tiver algum merged element equivalente, sobrescreverá o merged element, Semântica de Override Strategy Em esta Subseção é discutida a semântica que o relacionamento de composição assume quando é definido override strategy como a estretégia de composição.
A maneira de identificar os elementos equivalentes, as overlapping parts, é especificada no Capítulo 4.
A composição seguindo a semântica de composição override strategy deve respeitar as seguintes regras, como segue:
Regra 01: Para todo receiving element que possua um merged element equivalente implica que receiving element deve sobrescrever- lo.
A aplicação desta regra é ilustrada na Figura 5.1, onde é considerado a default match strategy como a base para a realização da definição da equivalência.
De esse modo, observa- se três casos, como segue:
Regra 03: Para todo receiving element que não possua um merged element equivalente, realizar algumas transformações.
A aplicação desta regra é ilustrada na Figura 5.1, onde stereotype Tree.
MainNode possui uma referência à enumeration StateKind.
As enumeration Topology.
StateKind e Tree.
StateKind são equivalentes, o que implica em Tree.
StateKind sobrescrever Topology.
StateKind. De esse modo, surge um conference conflict, haja vista TreeTopology.
MainNode faz referência à enumeration Topology.
StateKind que não existe.
Este conflito é solucionado com a mudança de referência da enumeration Topology.
StateKind para TreeTopology.
StateKind. Union Strategy nome, haja vista terão resulting elements com assinaturas iguais num mesma namespace, sendo necessário, com isso, realizar alguns transformações.
Para conservar os conceitos é necessário realizar algumas transformações nos elementos na parte (E) da figura Tree.
Node, Tree.
StateKind, Topology.
StateKind e A semântica de composição baseada na union strategy é descrita nesta seção.
Para isto, tem- se as seguintes Subseções contendo:·
possíveis cenários de aplicações do relacionamento de composição baseado na union strategy;
Name Value capacidade de representar todos os conceitos de ambos os frameworks.
Sendo assim, é os conceitos de ambos os frameworks.
Semântica de Union Strategy Em esta Subseção é discutida a semântica que o relacionamento de composição assume O relacionamento de composição baseado na union strategy especifica que os as overlapping parts, é a mesma especificada no Capítulo 4.
A composição seguindo a semântica de composição union strategy deve respeitar as seguintes regras, como segue:
Regra 01: Para todo receiving element que possua um merged element equivalente, isto aplicar algumas transformações, tais como:
Atualizar namespace e renomear os elementos equivalentes.
A aplicação desta regra é ilustrada na Figura 5.2, onde é considerado a default match strategy como a base para definir as overlapping parts.
De esse modo, observa- se três overlapping parts, o surgimento de alguns conflitos e a realizações de algumas transformações, como segue:
TreeTopology. Root fazendo referência à Topology.
StateKind e Tree.
StateKind, respectivamente, sendo necessário atualizar estas referências.
Como resultado tem- se TreeTopology.
Tree. Edge e TreeTopology.
Topology. Edge.
Regra 03: Para todo receiving element que não possua um merged element equivalente, o mesmo deve ser inserido no resulting element sem alterações.
Em a Figura 5.2, é apresentado o uso desta regra, onde os stereotype Tree.
Leaf, Tree.
Root e Tree.
Search aplicar as model transformation rules, anteriormente definidas.
Um exemplo de aplicação destas regras é ilustrada na Figura 5.2, onde stereotype Tree.
MainNode possui uma referência à enumeration StateKind.
As enumeration Topology.
StateKind e Tree.
StateKind são equivalentes, o que implica que Tree.
StateKind é composto com Topology.
StateKind. De esse modo, surge um reference conflict, haja vista TreeTopology.
MainNode faz referência à enumeration Topology.
StateKind que não existe mais.
Este conflito é solucionado com a mudança de referência da enumeration Topology.
StateKind para TreeTopology.
StateKind através da aplicação da regra de transformação MTR6 definida na Seção 4.4.4 na página 70.
Merge Strategy O relacionamento de composição baseado na merge strategy especifica que os elementos Em esta Seção será detalhada a semântica de composição baseado na merge strategy, para isto tem- se as seguintes Subseções contendo:·
possíveis cenários de aplicações do relacionamento de composição baseada na merge strategy;·
a descrição da semântica de composição de merge strategy.
Cenário de Aplicação Merge strategy é aplicada ao relacionamento de composição quando é nececessário obter de software, a etapa de modelagem dos domínios da aplicação pode ser dividida entre os grupos de desenvolvimento a fim de que o esforço seja dividido.
De esse modo, tem- se equipes diferentes trabalhando na especificação de domínios onde é necessário representar seus conceitos específicos, os quais a UML não dê suporte.
Assim, são criadas linguagens para isto.
Porém, num determinado momento é necessário ter uma visão integrada dos pode ser realizada através da merge strategy.
Em a Figura 5.3 é mostrado um exemplo de composição seguindo esta estratégia.
Para o desenvolvimento de uma aplicação Web, por exemplo, divide- se a aplicação em três partes:
Visão, dados e negócio (ver Figura 1.1.
Onde cada parte representa um domínio da aplicação, os quais apresentam conceitos específicos.
A fim de modelar esses relacionamento de composição usando merge strategy.
Definir o relacionamento de composição seguindo a merge strategy consiste em Semântica de Merge Strategy Em esta Subseção é discutido a semântica que o relacionamento de composição assume equivalentes combinados.
A maneira de identificar os elementos equivalentes, as overlapping parts, é a mesma forma utilizada nas outras estratégia.
A composição seguindo a semântica de composição merged strategy deve respeitar as seguintes regras, como segue:
Regra 01: Para todo receiving element que possua um merged element equivalente isto implica que os mesmos deverão ser combinados.
A aplicação desta regra é ilustrada na Figura 5.3, onde é considerado a default match strategy como a base para a realização da definição da equivalência.
De esse modo, observa- se três casos, como segue:
TreeTopology. Node como resultado.
Comum as duas enumeration, e os EnumerationLiteral available e busy pertencente a ambas enumeration, além disso, o EnumerationLiteral off originado de Tree.
StateKind. TreeTopology.
Edge como resultado.
Regra 02: Para todo merged element que não possua um receiving element equivalente, o Regra 03: Para todo receiving element que não possua um merged element equivalente, o mesmo deve ser inserido no resulting element sem alterações.
Em a Figura 5.3, é apre- sentado o uso desta regra, onde os stereotype Tree.
Leaf, Tree.
Root e Tree.
Search uma referência à enumeration StateKind.
As enumeration Topology.
StateKind e Tree.
StateKind são equivalentes, o que implica que Tree.
StateKind é composto com Topology.
StateKind. De esse modo, surge um reference conflict, haja vista TreeTopology.
MainNode faz referência à enumeration Topology.
StateKind que não existe.
Este conflito é solucionado com a mudança de referência da enumeration Topology.
StateKind para TreeTopology.
StateKind através da aplicação da regra de transformação MTR6 definida na Seção 4.4.4 na página 70.
Semelhança Entre as Estratégias Estabelecer um relacionamento de composição consiste, basicamente, em:
Especificar de composição a ser seguida;
Definir a estratégia de comparação a ser seguida;
Definição da estratégia de comparação, a qual define a base para definir a equivalência entre eles, foi observado durante o desenvolvimento deste trabalho que o estabelecimento de um relacionamento de composição pode originar modelos de saída iguais, independente da estratégia de composição adotada.
Diante deste fato, esta seção tem como objetivo realizar uma análise dos casos em que os modelos de saída são iguais.
Para isto é mostrado o relacionamento entre os modelos de entrada, as estratégias de composição e as overlapping parts.
Sendo assim, a comparação entre dois modelos de entrada pode originar um relacionamento entre o conteúdo os quais são:
Total, partial, subset e empty, sendo estes descritos as seguir:
Name Value iguais.
A fim de definir os termos anteriormente especificados seguindo a definição da teoria dos conjuntos, tem- se:
Total Overlapping Parts:
Representa a coleção dos elementos de R e M que são iguais.
Isto implica que:
R M $= R e R M $= M. Subset Overlapping Parts:
Representa que M é um subconjunto de R. Isto implica que:
M R que equivale a R M $= R e R M $= M. Empty Overlapping Parts:
Representa que M e R são disjuntos.
ARM $= Isto implica que:
Caso 02: O modelo de saída é igual a A B quando adota- se override strategy ou merge strategy como estratégia de composição, tendo partial overlapping parts;
E quando tem- se merge strategy como estratégia de composição e tem- se empty overlapping parts.
Caso 03: O modelo de saída é igual a A (B -- (A B)):
Quando adota- se union strategy como estratégia de composição, tendo total overlapping parts, partial overlapping parts, subset overlapping parts e empty overlapping parts;
E quando tem- se override strategy como estratégia de composição e tem- se empty overlapping parts.
Extensão do Metamodelo da UML Com o objetivo de tornar a UML capaz de expressar o mecanismo de composição proposto, foi criado uma extensão do seu metamodelo.
Sendo assim, a UML é adaptada ao domínio de composição de modelos e a abordagem proposta passa a ter uma forma este trabalho apresenta uma abordagem que é baseada na composição de modelos de entrada produzindo modelos de saída, como citado anteriormente.
A composição é realizada levando em consideração:
Estratégias de comparação, estratégias de composição, os modelos de entrada que apresentam equivalentes, regras de transformação, regras de composição e regras de equivalência, como mencionado nos capítulos anteriores.
De esse modo, criar uma representação deste mecanismo no contexto da UML implica em tornar possível representar este conteúdo.
O mecanismo de composição especificado e desenvolvido é representado através de um relacionamento de composição, identificado como composition relationship.
Porém, este relacionamento apresenta característica (por exemplo as merge rules, composition strategy, e entre outras) que não podem ser representadas com a UML.
Sendo assim, é proposto uma extensão do metamodelo da UML para tornar- la capaz de representar este relacionamento.
Este capítulo apresenta uma proposta de extensão do metamodelo da UML para representar o relacionamento de composição.
O Capítulo possui com as seguintes seções:·
Metamodelo da UML:
Esta seção apresenta considerações sobre o metamodelo de a· Definição do Relacionamento de Composição:
Esta seção se detém na definição de uma extensão do metamodelo da UML.
Este metamodelo é responsável por especificar o relacionamento de composição.·
Regras de Boa Formação: Em esta seção são apresentadas regras de boa formação, a fim de representar informações semânticas adicionais e garantir correta construção do relacionamento definido na extensão do metamodelo da UML.
Metamodelo da UML A OMG definiu a especificação da UML seguindo a abordagem da metamodelagem.
O metamodelo da UML especifica a sintaxe e a semântica da linguagem, sendo projetado seguindo os princípios de:
Modularidade; Layering;
Partitioning; Extensibilidade;
Reuso. O metamodelo da UML é descrito usando:·
sintaxe abstrata:
Representada por os diagramas UML mostrando as metaclasses que definem os construtores da linguagem (como por exemplo:
Association, Operation, Property, Parameter, entre outros) e seus relacionamentos.
Uma descrição informal em linguagem natural que descreve cada um destes construtores e seus relacionamentos.·
regras de boa formação:
Trata- se de um conjunto de regras de boa formação que são descritas usando OCL e linguagem natural.·
semântica: Para cada construtor da linguagem é associado um significado, para isto é usado linguagem natural.
O uso da linguagem natural para especificar os elementos que compõem a linguagem, como a semântica, as regras de boa formação e sintaxe abstrata citados anteriormente, favorece o surgimento de ambigüidade.
Conseqüentemente, implica em dificuldades em estender o metamodelo da linguagem.
O trabalho não se deterá em apresentar uma especificação formal da extensão da UML, e sim uma descrição do relacionamento de composição seguindo as recomendações de extensão do metamodelo apresentada da especificação da linguagem.
Porém, evitando ambigüidade e inconsistência.
Definição do Relacionamento de Composição Para especificar os tipos de elementos que podem participar do relacionamento de composição foi levado em consideração o modo como a UML define os participantes do relacionamento de herança, do relacionamento de composição (PackageMerge), e o padrão de projeto composite.
Em a especificação da UML, são definidos dois construtores abstratos:
Classifier, todo os elementos que podem participar de um relacionamento de herança é filho do mesmo;
PackageElement, todos os elementos que podem participar de um relacionamento de composição de pacote deve herdar- lo.
Com isso, são inseridos dois conceitos no metamodelo da UML:
ComposableElement: Trata- se dos modelos de entradas do relacionamento de composição, ou seja, os elementos que podem ser compostos.
ComposableElement é uma classe abstrata e um NamedElement.
CompositeElement: É um ComposableElement que é composto por outros ComposableElement ou ComposableElement.
Cada elemento que faz parte de um CompositeElement é tratado separadamente durante a composição.
CompositeElement é uma classe abstrata que funciona como um contêiner.
A introdução destes dois conceitos no metamodelo da UML é representado através da sintaxe abstrata ilustrada na Figura 6.1, a qual define os tipos de modelos que podem participar do relacionamento de composição através da estrutura do padrão de projeto composite.
Isto implica em algumas conseqüências, tais como:
&quot;composto «os novos elementos poderiam fazer parte.
Isto é solucionado através das restrições na especificação da UML, a qual define o que cada um tipo de modelo pode ter, e em qual modelo o mesmo pode fazer parte.
A distribuição dos elementos &quot;primitivos «nos compostos se configura de acordo com apresentado na Figura 4.4 e de acordo com a definição do metamodelo da UML.·
o relacionamento de composição é representado por CompositionRelationship.
Ao passo que CompositionRelationship faz reuso de DirectedRelationship, o mesmo disponibiliza uma especialização de DirectedRelationship no contexto de composição de modelos;·
apenas é especificado entre elementos que são passíveis de serem compostos.
Este elementos são definidos na Seção 4.2, &quot;Especificando os Modelos de Entrada em a «página 51;·
o relacionamento de composição faz uso de regras as quais precisam ser representadas, sendo idealizadas dentro de a extensão baseada na estrutura de Constraint definida na UML.·
o relacionamento de composição é caracterizado por o suporte a diferentes formas de composição, isto é verificado através da definição da enumeration CompositionStrategyKind.·
o relacionamento de composição faz uso de regras para determinar a equivalência entre os modelos (Match Rules), para realizar transformações dos modelos (Model Transformation Rules) e para executar a composição dos modelos (Merge Rules), como já descrito.
Rule foi definida para representar estas regras.·
os operadores do mecanismo de composição são representado por:
Match, CompositionStrategy, Merge, e Transformation.
O metamodelo definido na Figura 6.2 define a sintaxe abstrata do relacionamento de composição.
Sendo assim, com o objetivo de deixar claro o papel de cada elemento, é realizado uma descrição, como segue:
CompositionRelationship: Especifica um relacionamento semântico entre dois CompositeElement.
Este construtor relaciona um receiving a um merged, representando um relacionamento navegável do receiving ao merged.
CompositionRelationship possui um conjunto de tuplas cujo valores especificam a instância do relacionamento.
A instância do CompositionRelationship é chamada de merge.
Generalização:· CompositionRelationship estende DirectedRelationship definido no metamodelo da UML.
Atributos:· resulting:
CompositeElement, especifica o resultado da composição entre dos modelos de entrada.
Trata- se de um subconjunto de Namespace:
OwnedMember definido no metamodelo da UML.
Associações:· merged:
Trata- se de um CompositeElement que será compostos com receiving.
A cardinalidade &quot;1 «representa que todo o relacionamento de composição deve Representa um subconjunto de DirectedRelationship:
Target do metamodelo de a· receiving:
Trata- se do CompositeElement que terá seu conteúdo estendido por o merged.
A cardinalidade &quot;1 «representa que todo o relacionamento de· strategy:
Especifica a estratégia que deve ser aplicada à composição.
A cardinalidade &quot;1 «representa que todo o relacionamento de composição deve ter uma estratégia de composição associado a ele;·
match: Especifica qual estratégia de comparação que deve ser seguida durante o relacionamento de composição.
A cardinalidade &quot;1 «representa que todo relacionamento de composição deve ter uma Match Strategy associada.·
merge: Especifica qual estratégia de composição deve ser seguida durante o relacionamento de composição.
A cardinalidade &quot;1 «representa que todo relacionamento de composição deve ter uma Merge Strategy associada.
Constraint: Context CompositionRelationship· A visibilidade do CompositionRelationship é público ou privado.
Operações Adicionais: Que é especificada para o relacionamento de composição.
Isto é expressado em OCL como segue:
Then self. Match.
Threshold Semântica: Um relacionamento de composição estabelece um relacionamento de composição entre receiving e merged, onde o principal objetivo é representar a integração do conteúdo dos mesmo, produzindo um CompositeElement que representa o resultado da composição.
A instância de CompositionRelationship é chamada de merge.
A navegabilidade do relacionamento de composição significa que o merge deve ser estabelecido num determinado sentido.
O estabelecimento da origem e destino do relacionamento define o papel dos CompositeElements na instância do relacionamento de composição.
A origem representa o receiving e o destino o merged (receiving merged) Notação:
Um relacionamento de composição é representado por um senta de linha sólida, partindo do receiving ao merged.
ComposableElement: Trata- se de uma metaclasse abstrata a qual representa os elementos que podem ser composto.
Estes elementos são operandos na definição das regras de match, merge, e model transformation.
CompositeElement: Trata- se de uma metaclasse abstrata a qual representa os elementos CompositionStrategy:
É responsável por a associação de uma estratégia de composição a um relacionamento de composição.
Faz o papel do Composition Strategy Operator.
Atributos:· kind:
CompositionStrategyKind, representa a estratégia de composição de fato.
Os possíveis valores de kind são definidos na enumeration CompositionStrategyKind.
Transformation: É responsável por a representação da resolução de problemas através de model transformation rules.
Com esta metaclasse, a UML passa a ser capaz de expressar Model Transformation Operator.
Como uma composição pode surgir de composição pode ter model transformation rules associado, ou não.
Associações:· ownedTransformationRule:
Rule, consiste de uma coleção de Rule (model transformation rules).
A cardinalidade&quot;* «especifica que é possível ter uma coleção de regras, ou nenhuma.
Atributos:· isRequired:
Boolean, quando o seu valor é igual true indica que as especificações das model transformation rules devem ser aplicadas ao relacionamento de composição.
Os possíveis valores de kind são os definidos na enumeration CompositionStrategyKind.
Match: É responsável por a representação da match strategy aplicada ao relacionamento de composição.
Trata- se de um NamedElement.
Associações:· ownedMatchRule:
Rule, consiste de uma coleção de Rule (match rules).
A qual define as match rules.
Atributos:· kind:
MatchKind, representa as possíveis match strategies que podem ser associadas ao relacionamento de composição.
Os possíveis valores de kind são os definidos na enumeration MatchKind.
Merge: É responsável por a representação da composição no relacionamento de composição.
Trata- se de um NamedElement.
Esta entidade dá UML a capacidade de representar o merge operator.
Associações:· ownedMergeRule:
Rule, consiste de uma coleção de Rule (merge rules).
A qual define as merge rules).
Rule: Este construtor é usado para representar as regras usadas no relacionamento de composição.
Sendo assim, as regras de comparação, composição e transformação de modelos podem ter sua sintaxe representadas fazendo uso desta.
Generalização:· Rule é uma extensão de Operation definida no metamodelo da UML.
Associações:· ruleExpression:
RuleExpression, consiste de uma coleção de RuleExpression.
A cardinalidade&quot;* «especifica que Rule pode ter, ou não, uma referência a RuleExpression.
É utilizada para a construção da sintaxe das regras.·
ruleValues: RuleValues, consiste de uma coleção de RuleValues.
A cardinalidade&quot;* «especifica que Rule pode ter, ou não, uma referência a RuleValues.
Um regra para ser válida a mesma deve satisfazer os valores especificados em ruleValues.·
ownedElement: ComposableElement, representa os operandos das regras.·
raisedConflict: Conflict, a execução das regras podem gerar exceções durante a sua aplicação (por exemplo, caso uma Post-Condition não seja satisfeita gerará uma exceção) estas exceções são representadas como uma coleção de Conflict.·
precondition: Constraints, especifica um conjunto de restrições que a regra deve satisfazer para ser executada.
Redefinida de Operation: Precondition· postcondition:
Constraints, especifica um conjunto de restrições que devem encontradas após aplicação da regra.
Por exemplo, não deve existir conflitos de nomes, ou seja, modelos com nomes iguais dentro de uma mesma Namespace.
Redefinida de Operation: Postcondition Semântica:
Rule adiciona ao metamodelo da UML a capacidade de representar as regras definidas no mecanismo de composição.
Pode ser expressada em linguagem natural ou em algum linguagem específica (por exemplo em Alloy, OCL, Java e etc).
Para que uma regra seja executa corretamente a mesma deve satisfazer as postcondition definidas.
Ao passo que, precondition deve ter sido satisfeitas.
Conflict: Especifica os problemas que surgem durante a execução de uma Rule.
Generalização:· Conflict é um Type, o qual é definido no metamodelo da UML.
RuleExpression: Representa uma árvore estruturada de símbolos que denota um determinado valor.
Generalização:· RuleExpression é um Expression, a qual é definido no metamodelo da UML.
Semântica: RuleExpression especifica um node numa árvore de expressão.
Dado um node, este será um operando ou um operador.
Se for uma operando será considerado um símbolo terminal.
Caso contrário será um operador que atuará sobre alguns operandos.
É utilizada para construir as regras utilizadas no relacionamentos de composição, as match rules, merge rules, e as model transformation rules.
Notação: Uma RuleExpression com operandos é representada com um símbolo e seus parâmetros representando os operandos da mesma.
Por exemplo, a expressão da match rule para enumeration, MatchEnumeration (Enumeration rcv, Enumeration mrgd).
RuleValues: É a especificação e representação de um conjunto de instâncias.
Generalização:· RuleValues é uma ValueSpecification, que é definido no metamodelo da UML.
Semântica: RuleValues é necessário que os valores atribuídos sejam valores válidos ao contexto da composição, ao qual o mesmo é aplicado.
Representam os valores que são manipulados por as regras.
MatchKind: Este construtor é uma Enumeration que define literais para determinar a estratégia de comparação a ser seguida durante a composição.
Descrição: MatchKind possui os seguintes literais:·
default, usado para representa a default match strategy.·
partial, usado para representa a partial match strategy.·
complete, usado para representa a complete match strategy.
Semântica: MatchKind é usado para especificar os tipos de match strategy suportadas no relacionamento de composição.
Sendo assim, os possíveis valores para match strategy passado como parâmetro para o relacionamento de composição são definidos neste construtor.
O significado de cada literal (default, partial, complete) é definido nas estratégias de comparação especificadas no Capitulo 4.
CompositionStrategyKind: Este construtor é uma Enumeration que define literais para determinar a estratégia de composição a ser seguida durante a composição.
Descrição: CompositionStrategyKind possui os seguintes literais:·
union, usado para representa a union composition strategy.·
override, usado para representa a override composition strategy.·
merge, usado para representa a merge composition strategy.
Semântica: CompositionStrategyKind é usado para especificar os tipos de composition strategy suportadas no relacionamento de composição.
Sendo assim, os possíveis valores para composition strategy passado como parâmetro para o relacionamento de composição são definidos neste construtor.
O significado de cada literal (union, override, merge) é definido nas estratégias de composição especificadas no Capitulo 4.
Regras de Boa Formação A fim de assegurar que a definição do relacionamento de composição definido seja garantida e representar informações semânticas adicionais são apresentadas algumas regras de boa formação.
O modelo seguido para especificar estas regras é o apresentado na especificação da UML, como segue:
Regra 01:
O relacionamento de composição deve ser definido entre CompositeElement context CompositionRelationship Regra 02:
Todo relacionamento de composição deve ter uma estratégia de composição.
Regra 03:
Todo relacionamento de composição deve ter ao menos duas regras associado.
Context Merge context Match Regra 04:
Uma regra pode ter Conflicts gerados da sua execuação.
Regra 05:
O resultado da composição é um ComposositeElement.
Context CompositionElement self.
Resulting. OclIsKindOf (CompositeElement) Uma vez definido a extensão, é apresentado um exemplo de uso da extensão do Para isto é necessário definir a estratégia de comparação e a estratégia de composição que comparação e é representada por DM; (
iv) merge strategy, como a estratégia de composição e é representada por MS.
Modelo Formal do Mecanismo de O mecanismo de composição da UML é definido usando linguagem natural, o que proporciona o surgimento de inconsistência e ambiguidade.
A fim de evitar isto, o mecanismo é modelado utilizando a linguagem formal Alloy.
Com isso, o modelo formal criado é analisado de forma automática utilizado o Alloy Analyzer, a fim de validar o modelo.
Como implementar as estratégias de comparação e de composição?
As respostas destas perguntas levam a ter as seguintes contribuições:
Diante deste contexto, este capítulo é organizado com as seguintes seções:·
Alloy e Alloy Analyzer:
É apresentado uma descrição da linguagem Alloy e do Alloy Analyzer, os seus conceitos e suas características.·
Análise do Modelo Formal:
É realizado uma análise do modelo formal usando o Alloy Analyzer.·
Propriedades Algébricas: Uma verificação de algumas propriedades algébricas do mecanismo de composição com o Alloy Analyzer.
Alloy e Alloy Analyzer numa linguagem formal e depois realizar uma análise neste modelo formal.
Sendo assim, é utilizado a Alloy e o Alloy Analyzer.
A Alloy trata- se de uma linguagem formal baseada em teoria de conjuntos, lógica de primeira e é fortemente influenciada por a notação orientada a objeto.
Modelos representados em Alloy são entradas para a sua ferramenta de suporte o Alloy Analyzer, o qual basicamente trata- se de um resolvedor de restrições.
A Alloy e o Alloy Analyzer tem sido usado com sucesso para modelar: (
i) modelos orientados a objeto; (
ii) composição de modelos;
formalização de modelos orientados a objeto (Massoni et al.
2004, Bourdeau &amp; Cheng 1995); (
iv) modelagem de sistemas críticos, incluindo sistema de controle de tráfico aéreo e em máquinas de terapias com proton.
Além de isto, como a linguagem é influenciada por a notações da modelagem orientada a objeto, isto torna mais fácil a classificação de objetos e suas propriedades.
Por estas razões, foi escolhido usar Alloy e acredita- se que a linguagem e sua ferramenta de suporte sejam bastante úteis e ofereçam similar benefícios na realização de análise automática do Um modelo representado em Alloy consiste basicamente de signatures, facts, predicates e functions, os quais são descritos como segue:·
signatures: São semelhantes as classes representadas nas linguagens orientada a objeto.
As signatures possuem fields (os atributos nas classes) e podem ser estendidas por outras signatures (similar ao mecanismo de herança em OO).
Além disso, é possível gerar instância de signatures, sendo estas instâncias o objeto da análise.·
facts: Representa restrições semânticas que são aplicadas às signatures.
Os facts são definidos usando lógica de predicado.
Sendo assim, usam conectivos lógicos (por exemplo,&amp; (and),| (or), (implica), entre outros), quantificadores (como, all (para todo), some (existe)) e operadores (como,+ (operador união), $= (operador igualdade) e^ (operador que representa transitividade);·
functions: Comparando com o paradigma orientado a objeto, as functions seriam os métodos das classes ou as operation definidas no metamodelo da UML;
A estrutura dos predicates é igual à apresentada nos facts e nas functions.·
modules: Assim como a UML, Alloy foi idealizada com o princípio da modularidade em mente.
Desta forma, a linguagem é organizada em módulos (os pacotes em UML).
Cada modelo pode ter signatures, functions, predicates e facts.
De a mesma forma que os pacotes em UML podem ter acesso, por exemplo, ao conteúdo de outros pacotes através do relacionamento de &quot;import», os modules em Alloy também podem ter acesso ao conteúdo de outros modules.
A fim de fazer uso destes conceitos, ambientar o leitor aos conceitos da linguagem a herança em orientação a objeto;
Para um modelo em Alloy ser considerado válido, o mesmo não deve violar nenhuma restrição a qual é definida através dos facts.
Um modelo é considerado inconsistente se não existe uma instância que satisfaça a todas as restrições definidas através dos facts.
Sendo assim, para ter uma instância, por exemplo, de um Stereotype válida, é necessário que sejam satisfeitas todas as restrições relacionadas a ele.
Outro exemplo seria, uma instância de Tree deve respeitar as restrições de RootFact para se considerada válida, se não existir nenhuma instância que satisfaça as restrições será considerado um modelo inconsistente.
Análise com Alloy O Alloy Analyzer pode realizar dois tipos de análise sobre o modelos de entradas:
Checar as instâncias do modelo;
Verificar asserções.
Com isto em mente, para realizar a análise da proposta do mecanismo de composição a verificação de asserções será levada em conta, assim como checar instâncias do modelo.
Onde verificar asserções consiste em analisar se o que é definido no modelo apresentam valores verdadeiros ou falsos.
O objetivo de utilizar asserções consiste em definir uma &quot;afirmação «e verificar se esta é válida para toda instância do modelo.
Quando o Alloy Analyzer verifica as asserções, o mesmo retorna true se a asserção é válida.
Caso contrário, retorna um contra-exemplo a fim de mostrar que a asserção é false.
A fim de verificar as asserções, o Alloy Analyzer analisa todas as possíveis instâncias do modelo, quando é encontrado um contra-exemplo a análise é finalizada e o contra-exemplo é mostrado.
Caso o número de instância seja muito grande, ou tendendo ao infinito, a análise torna- se impraticável.
Um alternativa para resolver este problema é a definição do escopo, em o qual a análise deve ser realizada.
Em a definição de um escopo, é definido o número máximo de instâncias possíveis para as signatures.
O Alloy Analyzer tem a capacidade de considerar apenas as instâncias do modelo onde o número que define o valor máximo possível de instância das signatures é encontrado.
Por exemplo, quando é definido o valor máximo de instâncias das signatures é 5, isto implica que o Alloy Analyzer analisará apenas os modelos que têm no máximo 5 instâncias de signature.
A verificação de asserção da Alloy não é como uma prova de teorema, em a qual uma vez que se tenha uma entrada e a partir de esta entrada origine um resultado&quot;` falso», implica na quebra do teorema.
Em Alloy, se uma asserção falha, então ela é, necessariamente, falsa.
Porém, se ela não falha, ela pode vir a ser falsa num escopo maior.
Segundo, uma boa forma de iniciar uma análise de um modelo com um número elevado de signatures é começar com um escopo pequeno.
Pois &quot;se um asserção é inválida, ela também é inválida num pequeno escopo».
Este configura a hipótese do menor escopo apresentada em.
Modelagem do Mecanismo de Composição de Pro-A fim de realizar a modelagem do mecanismo de composição em Alloy foram criados dois módulos:·
metaclasses e meta-atributos são considerados como signature e fields, respectivamente;·
as associações entre as metaclasses são consideradas como fields;
De acordo com, Alloy apresenta um baixa performance quando é necessário realizar análise de modelos com muitas signatures e fields, com 25 signatures ou mais, sendo a análise limitada com um escopo de 5 ­10 signatures.
Diante de isto, número maior que 35 metaclasses, as quais são representadas através das signatures, tornase impossível.
Assim, é necessário reduzir, o quanto possível, o número de metaclasses que Por outro lado, se for desconsiderado um número elevado de metaclasses isto levará a uma análise que não condiz com a realidade.
Se for considerado, por exemplo, um determinado número de metaclasses, porém não for considerado as metaclasses que estas estabelece uma &quot;meta-associação «(sendo representada como meta-atributos, como anteriormente mencionado) torna a análise não consistente.
O objetivo de desconsiderar algumas metaclasses é tornar possível a realização da análise automática.·
metaclasses semelhantes:
As metaclasses DataType, PrimitiveType e Enumeration são semelhantes a metaclasse Class, haja vista todas possuem nomes, atributos, operações e superclasses.
De essa forma, será considerada apenas a Class e é assumido que os resultados são aplicados a todas as outras.·
metaclasses não necessárias:
Para realizar a análise e diante de as restrições para execução desta, determinadas metaclasses precisam ser desconsideradas.
Tais são utilizadas durante o mecanismo de composição.
Com isso, estas metaclasses são· herança múltipla:
O metamodelo da UML possibilita o uso de herança múltipla.
Porém, Alloy não permite a implementação de herança múltipla, ou seja, não permite uma signature realizar herança múltipla.
Logo, a fim de evitar problemas na modelagem, a herança múltipla não será implementada.
A metaclasses Property e Parameter ambas herdam de MultiplicityElement e TypedElement uma saída para implementar esta herança múltipla em Alloy é agrupar o conteúdo de MultiplicityElement e de TypedElement numa única metaclasse, TypedMultiplicityElement, com o objetivo de que esta os representem.·
herança: Os princípios que foram levados em consideração para projetar o metamodelo da UML (como modularidade, flexibilidade, reuso, layering e entre outros), conduziram à formação de um hierarquia, no relacionamento de herança, com um alto grau de profundidade.
Por exemplo, a metaclasse Class encontra- se abaixo de o nível 5 dentro de a hierarquia do relacionamento de herança.
De esse modo, para solucionar este problema será considerada a filha com os meta-atributos (fields) herdados, sendo mantido apenas as superclasses abstratas TypedElement, Element, PackageElement e Element que são usadas para tornar possível o polimorfismo.·
atributos e associações derivadas:
A UML possui várias associações e atributos derivados como, por exemplo, os atributos isOrdered, isUnique, lower e upper todos da metaclasse Operation, a qual define as operações no metamodelo da UML.
Estes atributos e associações não serão inseridos nos modelos representados em Alloy.
Apenas o atributo derivado isDerived e a associação derivada extension da metaclasse Extesion definida no metamodelo definido no seu interior, é necessário fazer o uso da recursão.
Porém, para modelar isto em Alloy não é possível, haja vista a mesma não oferece o mecanismo de recursão.
Logo, não será levado em consideração a composição de modelos de forma recursiva.
Com isso, é apresentado, na Figura 7.2, uma extensão do metamodelo do UML e Enumeration em Alloy.
A modelagem completa encontra- se no Anexo C. Modelagem de Stereotype em Alloy O Código 7.2 representa a modelagem da metaclasse Stereotype em Alloy.
Isto é representado através da signature Stereotype, como segue:·
Stereotype estende Class.
Logo, tudo que é definido em Class é herdado por o Stereotype.·
Um Stereotype tem um relacionamento com Image.
Isto é representado através de uma field (linha 2)· Todo Stereotype pode apenas generalizar ou especializar outro Stereotype.
Esta restrição definida em é especificada em a (linha 4).·
Um Stereotype pode ter mais de uma Image.
Estas imagens são iguais se, e somente se, os mesmo tiverem as propriedades content, location e format iguais (linha 5 ­7)· Todo Stereotype não deve ter conflito de nome.
Código 7.2: Modelagem de Stereotype em Alloy i c o n:
S e t Image a l a:
Stereotype| this.
SuperClass in Stereotype a l i1, i 2:
I c o n| $ \&gt; i 1 $= i 2 one p:
P r o f i l e| t h i s i n p.
O wnedSt er eo t ype s a l a:
Element, b:
S t e r e o t y p e| (b.
@ name $= a.
@ name) $ \&gt; b $= a Modelagem de Enumeration em Alloy Para representar uma Enumeration em Alloy, é necessário criar uma signature que estenda CompositeElement.
O Código 7.3 representa esta modelagem e a descrição da mesma é apresentada a seguir:·
Enumeration extende CompositeElement.
Logo, tudo que é definido em CompositeElement é herdado por o Enumeration.·
Todo EnumerationLiteral com mesmo nome, são considerados iguais (linha 4).
Código 7.3: Modelagem da Enumeration em Alloy a l a, b:
O w n e d L i t e r a l s| a.
@ name $= b.
@ name $ \&gt; a $= b one p:
P r o f i l e| t h i s i n p.
OwnedMembers Modelagem do Mecanismo de Composição em Alloy O mecanismo de composição faz uso das especificações definidas no metamodelo dos uso da modelagem deste em Alloy.
Sendo assim, o módulo CompositionRelationship possível modelar as atividades realizadas por o model transformation operator.
Sendo assim, tem- se o objetivo de:
Verificar os modelos de entradas;
Verificar a correspondência entre os modelos;
Verificar se a composição é possível.
O relacionamento de composição foi modelado como um predicate com 5 parâmetros, representado por CompositionRelationship e ilustrado no Código 7.4.
É apresentado uma descrição a seguir:·
O predicate retorna true se, e somente se, o parâmetro resulting for o resultado da composição do conteúdo dos parâmetros receiving e merged.·
Tem 3 CompositeElement, uma match strategy, representado por matchStrategy, e uma composition strategy, representado por compositionStrategy.·
O merge operator recebe os parâmetros de entrada, representado por o predicate mergeOperator, e retorna true se, e somente se, for possível compor o conteúdo do receiving e merged, produzindo resulting, de acordo com a match strategy e a composition strategy especificada.
Fica a cargo de o predicate merge operator a verificação da composição (linha 5 ­6).
Análise do Modelo Formal Alloy suporta dois tipos de análises automática:
Simulation, usada para demonstrar a consistência de um dado predicado;
E checking, é utilizada para validar afirmações através da tentativa de encontrar um contra-exemplo, ou seja, dado uma afirmação o Alloy Analyzer busca um contra-exemplo que invalide a afirmação, como mencionado anteriormente.
Para realizar a análise é necessário definir o escopo da análise, este escopo delimita o tamanho da instância do modelo que está sendo explorada para validar as afirmações.
Quando é encontrado um contra-exemplo a afirmação é necessariamente inválida, por outro lado, quando nenhum contra-exemplo é encontra pode- se afirma que a afirmação é válida dentro de o escopo definido.
Sendo assim, se o relacionamento de composição é visto como uma operação tendo algumas entradas e produzindo uma saída, torna- se interessante e pertinente realizar um verificação se este relacionamento é válido para algumas propriedades algébricas.
Esta análise visa conhecer as propriedades do relacionamento e verificar algumas propriedades que relacionamento de composição necessariamente precisa ter.
Além disso, é possível verificar a semântica do relacionamento.
Em, é apresentado um conjunto de propriedades algébricas as quais os operadores de composição deve satisfazer algumas de elas.
Sendo assim, foi escolhido quatro propriedades com o objetivo de avaliar os operadores que representam o relacionamento de composição, tais como:
Idempotency, commutativity, associativity e uniqueness.
Para verificar estas propriedades são criadas assertivas que verificam se estas propriedades são válidas.
A seguir é apresentado um descrição destas propriedades:
Idempotency: Esta propriedade verifica se a composição de um modelo com ele mesmo, produzirá o mesmo como saída, dado uma estratégia de comparação e de composição.
Se S é um conjunto com uma operação binária f definida neste conjunto, então f é idempotency se, para todo s definido em S, f (s, s) $= s.
Por exemplo, as operações de união e intersecção de conjuntos podem ser consideradas ambas idempotency.
De uma maneira similar, a operação de composição pode ser vista como uma operação binária que tem dois modelos de entradas a fim de produzir um modelo de saída, isto pode ser expressado como merge (ma, me a) $= ma.
Em nossa abordagem esta propriedade é expressada em lógica de predicado como:
Match: MatchStrategy, strategy:
CompositionStategy merge (receiving, merged, resulting, match, strategy) $= merge (receiving, merged, resulting, match, strategy) Uniqueness:
Esta propriedade verifica se dado dois modelos de entrada, um estratégia de comparação e um estratégia de composição é produzido um único e possível modelo de saída.
Esta propriedade é extremamente importante, pois caso o mecanismo de composição não a atenda, isto significa que existe ambiguidade e a ausência de algum regra de composição.
Aplicando esta propriedade é possível verificar se há algum problema no modelo formal.
Se algum problema é encontrado, isto é refletido com um contra-exemplo.
Em nossa abordagem esta propriedade é expressada em lógica de predicado como:
Match: MatchStrategy, strategy:
CompositionStategy merge (receiving, merged, resultingA, match, strategy) merge (receiving, merged, resultingA, match, strategy) match (resultingA, resultingB, match) Commutativity:
Este propriedade é largamente utilizada na matemática com o objetivo de representar a habilidade de mudança da ordem dos operandos sem alterar o resultado.
O mecanismo de composição respeita esta propriedade se, e somente se, a composição de um modelo A e um modelo B seja igual a composição de B com A. Para uma função binária f:
D×D K é comutativa se, e somente se, f (x, y) $= f (y, x) para todo x, y D. Esta propriedade é expressada em lógica de predicado como:
Match: MatchStrategy, strategy:
CompositionStategy merge (receiving, merged, resulting, match, strategy) $= merge (merged, receiving, resulting, match, strategy) Associativity:
Como no relacionamento de composição não é especificado a ordem da composição, esta propriedade é importante para verificar se ordem interfere na composição.
Um operação binária f num conjunto D é associativa se, e somente se, ela satisfaz a regra de associatividade:
F (f (x, y), z) $= f (x, f (y, z) para todo x, y, z D. Esta propriedade é expressada em lógica de predicado como:
Receiving, merged, mergedA, resulting, match:
MatchStrategy, strategy:
CompositionStategy merge (merge (receiving, merged, resultingA, match, strategy), mergedA, resulting, match, strategy) $= merge (receiving, merge (merged, mergedA, resultingB, match, strategy), resulting, match, strategy) O relacionamento de composição é representado através de um predicate sendo ilustrado no Código 7.5 e descrito como segue:·
tem cinco parâmetros de entrada:
Três CompositeElement (receiving, merged e resulting), uma estratégia de comparação (matchStrategy) e uma estratégia de composição (compositionStrategy) (linhas 1 ­4).·
uma vez definido os parâmetros de entrada do relacionamento de composição, estes parâmetro são passados para o predicate mergeOperator, o qual tem a função de verificar se a composição é possível de ser realizada, ou seja, verifica o papel do operador de composição da abordagem proposta (linhas 5 ­6).
Código 7.5: Predicate que representa o relacionamento de composição 1 pred c o m p o s i t i o n R e l a t i o n s h i p (r e c e i v i n g:
O próximo passo é representar as propriedades algébricas em Alloy, para uma dada estratégia de comparação e uma dada estratégia de composição, aplicada ao operador de composição citado anteriormente.
Sendo assim, o Código 7.6 representa a formalização da propriedade Idempotency através de uma assertiva em Alloy para a estratégia de comparação default e a estratégia de composição override.
Sendo assim, tem- se:·
Definição do nome da assertiva. (
linhas 2 ­3).·
A composição da com ele mesmo, deve produzir o mesmo como saída (onde c representa o resultado da composição e necessariamente c $= a) (linhas 4 ­6).
Código 7.6: Assertiva que verifica a propriedade idempotency em Alloy a l a, c:
P r o f i l e| a l match:
D e f a u l t M a t c h S t r a t e g y| a l strategy:
OverrideStrategy| mergeOperator $ \&gt; mergeOperator O Código 7.7 representa a formalização da propriedade Uniqueness através de uma assertiva em Alloy para a estratégia de comparação default e a estratégia de composição override.
Um descrição é realizada a seguir:·
Definição do nome da assertiva. (
linhas 2 ­4).·
A composição de receiving e merged deve resultar em resultingA e resultingB, os quais devem se iguais seguindo a default match rule.
Código 7.7: Assertiva que verifica a propriedade uniqueness em Alloy a l r e c e i v i n g, merged, r e s u l t i n g A, r e s u l t i n g B:
P r o f i l e| a l match:
D e f a u l t M a t c h S t r a t eg y| a l strategy:
OverrideStrategy| mergeOperator[ r e c e i v i n g, merged, r e s u l t i n g A, match, s t r a t e g y]&amp; mergeOperator[ r e c e i v i n g, merged, r e s u l t i n g B, match, s t r a t e g y] $ \&gt; matchOperator Sendo assim, o Código 7.8 representa a formalização da propriedade Commutativity através de uma assertiva em Alloy para a estratégia de comparação complete e a estratégia de composição override.
Um descrição é realizada a seguir:·
Definição do nome da assertiva. (
linhas 2 ­4).·
A composição de receiving e merged deve resultar em resultingA e resultingB, os quais devem se iguais seguindo a default match rule (linhas 4 ­6).
Código 7.8: Assertiva representada em Alloy que verifica a propriedade commutativity a l match:
CompleteMatchStrategy| a l strategy:
OverrideStrategy| mergeOperator $ \&gt; mergeOperator O Código 7.9 representa a formalização da propriedade Associativity através de uma assertiva em Alloy para a estratégia de comparação complete e a estratégia de composição merge.
Um descrição é realizada a seguir:·
Definição do nome da assertiva. (
linhas 2 ­5).
