O projeto de SoCs atuais compreende dezenas de núcleos IP (Intellectual Property) compreendendo módulos de hardware dedicado e processadores.
Núcleos IP obtêm alto desempenho com a utilização de hardware dedicado.
Flexibilidade é a característica chave de processadores, visto que é fácil modificar o comportamento dos programas em tempo de execução.
A maioria dos SoCs atuais não possui capacidade de modificar o comportamento do hardware ou a sua estrutura depois da fabricação do sistema.
Além de a inflexibilidade observada no hardware, a integração de dezenas ou centenas de núcleos num mesmo SoC traz problemas relacionados a escalabilidade e desempenho.
Para solucionar estes problemas, redes intra-chip (Networks on Chip NoCs) estão se tornando cada vez mais difundidas.
Este trabalho propõe estender a flexibilidade natural do software para módulos de hardware, utilizando NoCs como principal recurso interno de comunicação.
Isto é possível a partir de a reconfiguração de módulos de hardware em tempo de execução.
O presente trabalho possui duas contribuições principais:
Primeiro, um fluxo de projeto específico para SoCs com módulos reconfiguráveis;
Segundo, a proposta de um conjunto de características necessárias para habilitar a reconfiguração de módulos de hardware de uma NoC.
Palavras Chave: SoCs, NoCs, CoCs, MPSoCs, FPGAs, SDRs, reconfiguração parcial, reconfiguração dinâmica.
A crescente demanda por equipamentos eletrônicos cada vez menores, mais duradouros, mais rápidos e com mais funcionalidades no mesmo dispositivo, motivam a pesquisa por novos métodos de implementação.
A busca por desempenho em microprocessadores seguiu duas estratégias simultâneas ao longo de o tempo:
Aumento da freqüência de relógio e paralelismo no nível de instrução (ILP ­ Instruction Level Parallelism).
O aumento da freqüência está alcançando um limite, devido principalmente a problemas de dissipação de potência e complexidade de projeto.
O ILP seguiu o caminho pipeline superescalar com múltiplas linhas execução (multi-thread) e também está chegando a um limite nos sistemas mono-processados.
Companhias como Intel, AMD, Sony, IBM e Toshiba mostraram no ano de 2005 a tendência para futuros microprocessadores:
No entanto, não somente o fator distância influência na comunicação entre os elementos de processamento de um SoC, mas também o meio de comunicação em si.
Um dos meios de comunicação mais utilizados, devido a a simplicidade de implementação e ao baixo consumo de área, são os barramentos.
Barramentos, segundo, possuem diversas limitações:
O número de módulos de hardware que podem ser conectados ao barramento é tipicamente na ordem da dezena;
Apenas uma troca de dados pode ser realizada por vez, pois o meio físico é compartilhado por todos os módulos de hardware, reduzindo o desempenho global do sistema;
Necessidade de mecanismos inteligentes de arbitragem do meio físico, para evitar desperdício de largura de banda;
O uso de linhas globais num circuito integrado com tecnologia submicrônica impõe sérias restrições ao desempenho do sistema, devido a as altas capacitâncias e resistências parasitas inerentes aos fios longos.
Estas limitações podem ser parcialmente contornadas através do uso de, por exemplo, hierarquias de barramentos, onde o problema continua existindo, sendo apenas reduzido.
Uma maneira de minimizar os problemas oriundos da arquitetura de barramentos é através da utilização de redes de comunicação internas ao circuito integrado, no que se módulos de hardware conectados a roteadores, que por sua vez são conectados entre si através de canais de comunicação.
Este meio de comunicação possibilita que diferentes módulos da NoC se comuniquem simultaneamente, sendo este um meio de comunicação promissor para futuros Uma característica que pode ser agregada a uma NoC, quando a mesma for implementada em dispositivos parcial e dinamicamente reconfiguráveis (e.
g algumas famílias de FPGAs), é a possibilidade de substituir módulos conectados à NoC enquanto outros continuam operando.
Esta substituição de módulos em tempo de execução pode trazer novos benefícios aos SoCs, como por exemplo reduzir o consumo de potência e o tamanho do sistema, aumentar o tempo de vida do produto, implementar SoCs tolerantes a falhas e possuir um hardware virtualmente maior que o fisicamente existente, já que os módulos são configurados no sistema conforme a demanda.
Seguindo as tendências apresentadas inicialmente, presume- se que futuros SoCs possuirão dezenas de módulos de hardware interconectados por uma NoC, sendo cada módulo reconfigurado com um hardware (e.
g um processador ou um hardware dedicado) que melhor atenda as aplicações que estão sendo executadas no momento por o SoC.
Este trabalho versa exatamente sobre a junção destas tendências (NoC e reconfiguração), objetivando auxiliar o projeto destes SoCs.
Sistemas Embarcados atuais (e.
g celulares, computadores de mão, máquinas fotográficas digitais, tocadores de música) utilizam basicamente dois tipos de tecnologia:
Circuitos integrados de propósito específico (ASICs) e processadores (GPPs, DSPs e ASIPs).
A Figura 1 ilustra diferentes General Purpose Processors Domain Specific Processors Application Specific I/S Processors Field Programmable Devices Application Specific ICs tecnologias disponíveis para a implementação de sistemas embarcados num gráfico, quantificando consumo de potência, flexibilidade e desempenho destas.
Conforme mostra o gráfico, processadores são utilizados quando flexibilidade é um requisito importante do projeto, e ASICs são empregados quando desempenho e/ ou baixo consumo de potência é almejado.
No entanto, quando ambas as características são desejadas, processadores e ASICs têm sido utilizados num mesmo sistema embarcado.
As conseqüências deste fato são:
Um grande consumo de área para a implementação do circuito integrado e de o (s) processador (es); (
ii) elevado consumo de potência devido a o alto consumo de área e à implementação de interfaces entre as diferentes tecnologias empregadas.
Segundo o gráfico da Figura 1, a tecnologia de dispositivos reconfiguráveis é uma alternativa intermediária entre processadores e ASICs para sistemas embarcados que necessitam simultaneamente de flexibilidade e desempenho.
Por que esta tecnologia ainda não é largamente empregada para a implementação de sistemas embarcados com as características citadas?
Dispositivos reconfiguráveis, surgidos na década de 80, são relativamente novos em relação a tecnologias já maduras como ASICs e processadores, lançados nas décadas de 60 e 70, respectivamente.
Desta forma, estas tecnologias se encontram mais otimizadas para a implementação de sistemas embarcados atuais.
Outro ponto a ser considerado é que os recursos configuráveis de dispositivos reconfiguráveis também consomem área e potência do sistema embarcado como um todo.
Dispositivos reconfiguráveis são utilizados tanto na prototipação de sistemas digitais, quanto em produtos finais.
A vantagem da utilização destes em produtos finais é a capacidade de poder modificar o hardware, permitindo:
Atualizar não somente o software, como também o hardware;
Aumentar o tempo de vida do produto, instalando novas funcionalidades de hardware;
Aumentar o desempenho do produto, migrando tarefas para serem executadas em hardware;
Reduzir o tamanho do dispositivo, configurando apenas o hardware necessário para uso imediato;
Reduzir o consumo de potência, como conseqüência da redução da área;
Implementar sistemas tolerantes a falhas, reconfigurando o hardware para corrigir defeitos do sistema;
Reduzir o tempo de chegada ao mercado, pois a fase de fabricação do circuito integrado não esta incluída no ciclo de fabricação do produto, já que o dispositivo reconfigurável é comprado pronto, necessitando apenas a configuração do dispositivo com a lógica específica do produto.
Algumas desvantagens de dispositivos reconfiguráveis são:
Custo elevado quando comparado a ASICs produzidos em grande quantidade;
Maior consumo de área e potência quando comparando uma única configuração utilizada no dispositivo reconfigurável com um circuito integrado equivalente implementado em ASIC.
Dispositivos reconfiguráveis permitem que um mesmo produto seja tanto específico quanto genérico.
Considere um produto genérico como sendo um computador de mão e um produto específico como sendo uma máquina fotográfica digital.
Existem computadores de mão que tiram fotografias, mas a sua qualidade não se compara a uma máquina fotográfica digital, pois o computador de mão faz todo o processamento em software.
Com a utilização de dispositivos reconfiguráveis, o computador de mão (sistema genérico) pode ser configurado para possuir o hardware necessário de uma máquina fotográfica digital (sistema específico), assim obtendo melhor desempenho que a alternativa somente software.
Exemplos de dispositivos reconfiguráveis utilizados na indústria são EPROMs, PLAs, Pals, PLDs e FPGAs.
Entre estes, se destaca o FPGA, por a sua alta densidade de elementos lógicos e rápida reconfigurabilidade.
Estes componentes são baseados num arranjo bidimensional de células básicas de lógica configurável repetidas, possuindo um paralelismo nativo.
Além deste arranjo básico, outras estruturas mais complexas como blocos de memória ou mesmo processadores são integrados ao componente, aumentando consideravelmente seu poder de computação.
Esta Seção apresenta definições e conceitos que permitem associar a linguagem do presente documento com a literatura da área de sistemas reconfiguráveis e redes intra-chip.
Dispositivo reconfigurável:
Circuito integrado que habilita definir a interconexão de seus componentes internos, bem como a função destes componentes através do processo que se denomina configuração.
Podem- se citar os dispositivos Virtex e Apex como exemplos de dispositivos reconfiguráveis.
Arquitetura reconfigurável:
Arquitetura que conecta um ou mais dispositivos reconfiguráveis a outros componentes de hardware, permitindo a interação com o mundo externo.
Pode- se citar a XSV-800 como exemplo de arquitetura reconfigurável com um dispositivo reconfigurável, e o PRISM como exemplo de arquitetura reconfigurável com diversos dispositivos reconfiguráveis.
Sistema reconfigurável:
Projeto e implementação de hardware que tira proveito das características reconfiguráveis de arquiteturas reconfiguráveis.
Podem- se citar os trabalhos e como exemplos de sistemas reconfiguráveis.
Bitstream: Conjunto de bits que define a função dos recursos reconfiguráveis de um sistema reconfigurável, conferindo uma funcionalidade específica ao mesmo.
Configuração: Processo de escrever um bitstream na memória do sistema reconfigurável, de forma a definir a funcionalidade do mesmo.
Reconfiguração: Processo de sobrescrever um bitstream na memória do sistema reconfigurável, de forma a redefinir a funcionalidade do mesmo.
Reconfiguração total:
É a reconfiguração onde a memória do sistema reconfigurável é inteiramente sobrescrita.
Reconfiguração parcial:
É a configuração que permite que somente uma porção da memória do sistema reconfigurável seja sobrescrita.
Reconfiguração estática:
É uma reconfiguração que afeta a operação do sistema inteiro, implicando uma parada geral durante o processo de reconfiguração.
Também chamada de reconfiguração disruptiva.
Reconfiguração dinâmica:
As porções do sistema que não estão sendo reconfiguradas permanecem completamente funcionais durante o ciclo de reconfiguração.
Também chamada de run-time reconfiguration (RTR), on-the-fly reconfiguration, in-circuit reconfiguration ou reconfiguração não-disruptiva.
Todas essas expressões podem ser traduzidas também como reconfiguração em tempo de execução.
Projeto reconfigurável:
É um conjunto de descrições abstratas que pode, através de um processo automático ou semi-automático, gerar um bitstream.
Este bitstream ou projeto reconfigurável é uma das possíveis configurações que compõe um sistema reconfigurável ao longo de o tempo.
Bloco lógico:
É a célula básica de dispositivos reconfiguráveis para a implementação de funções lógicas.
FPGA: É um tipo de dispositivo reconfigurável que consiste de uma matriz de blocos lógicos, chaves de interconexão, fios e pinos de E/ S configuráveis.
Os blocos lógicos são conectados entre si ou a pinos de E/ S através de um ou mais fios e chaves de interconexão.
Chave de interconexão:
Recurso de hardware que permite conectar dois fios distintos.
Pode- se citar como exemplos de chaves de interconexão tristates e switch boxes.
Recursos internos do FPGA:
Blocos lógicos, fios, chaves de interconexão e pinos de E/ S. Grão:
Estrutura básica num sistema reconfigurável, replicada para gerar o todo ou a parte fundamental do sistema.
Granularidade: Característica de um sistema reconfigurável, dependente da dimensão do grão deste.
Sistema reconfigurável de grão pequeno:
Aquele onde o grão é relativamente simples.
Por exemplo, no caso de FPGAs da família Virtex-II da Xilinx, o grão é um CLB.
Sistema reconfigurável de grão grande:
Os sistemas reconfiguráveis de grão grande possuem como grão unidades lógicas e aritméticas (ULAs) e/ ou pequenos microprocessadores e memórias.
No caso de o Chess, o grão é uma ULA.
Núcleo: É um sistema digital complexo pré-projetado, pré-verificado e prototipado em hardware pelo menos uma vez.
Os núcleos são utilizados como componentes de aplicações, sendo a reusabilidade destes em diferentes aplicações uma característica importante para o projeto de sistemas digitais.
Os núcleos são chamados também usando as terminologias em inglês, core ou IP core.
Invólucro: O invólucro é uma camada de lógica inserida sobre o núcleo, permitindo adequar a interface e o protocolo de comunicação original do núcleo ao meio de comunicação.
Também chamado de wrapper.
Módulo: É o núcleo pronto para ser conectado a um meio de comunicação, ou seja, o núcleo com o seu wrapper.
Roteador: É o núcleo de hardware básico de uma rede intra-chip, responsável por fazer o repasse de pacotes.
CPU bound: Característica de um sistema onde o tempo de computação é principalmente determinado por o tempo despendido com processamento.
I/ O bound:
Característica de um sistema onde o tempo de computação é principalmente determinado por o tempo despendido com operações de entrada e saída (E/ S).
Top: Arquivo de mais alta hierarquia num projeto de hardware.
O objetivo estratégico do presente trabalho é dominar a tecnologia de sistemas digitais reconfiguráveis, utilizando redes intra-chip como meio de comunicação entre módulos de propriedade intelectual reconfiguráveis.
Os objetivos específicos deste trabalho são:
Propor um fluxo de projeto que simplifique o processo de implementação de SDRs (Sistemas Dinamicamente Reconfiguráveis); (
ii) implementar uma plataforma multiprocessada dinamicamente reconfigurável construída sobre uma rede de interconexão de baixo consumo de área.
A rede de interconexão empregada no presente trabalho está limitada a uma rede intra-chip direta, com topologia malha, chaveamento por pacotes e repasse de pacotes por o método wormhole.
O motivo destas restrições de projeto ocorrem devido a a disponibilidade do código fonte da NoC Hermes, que possui tais características, e desta NoC poder ser implementada em FPGAs junto a outros módulos de hardware conectados a ela no mesmo dispositivo.
Este trabalho está organizado como segue.
O Capítulo 2 apresenta a evolução de sistemas e dispositivos reconfiguráveis, contemplando também processadores reconfiguráveis e sistemas reconfiguráveis.
Em este Capítulo é dada ênfase a dispositivos parcial e dinamicamente reconfiguráveis, os quais possuirão esta característica explorada no restante do documento.
Tal estudo faz- se necessário uma vez que os fabricantes de dispositivos reconfiguráveis nem sempre fornecem um conjunto completo de ferramentas de CAD que possibilite a reconfiguração parcial e dinâmica de seus dispositivos.
Artemis2, é a segunda contribuição deste trabalho.
Projeto proposto no Capítulo 4 e a rede Artemis introduzida no Capítulo 5.
A finalidade destes estudos de caso é apresentar as principais dificuldades para a implementação de sistemas parcial e dinamicamente reconfiguráveis, e como estas podem ser resolvidas.
Por fim, as conclusões e os trabalhos futuros são apresentados no Capítulo 7.
Segundo a mitologia grega, Hermes é o mensageiro dos Deuses.
Segundo a mitologia grega, Artemis possui o poder de transformar pessoas em animais.
Há duas décadas lógica reconfigurável é empregada em arquiteturas reconfiguráveis, ocupando diferentes posições dentro de estas.
A Figura 2 apresenta diferentes posições em a qual a lógica reconfigurável pode ser empregada em arquiteturas reconfiguráveis:
Como unidade funcional (RFU Reconfigurable Functional Unit) de um processador (A), como coprocessador (B), anexada ao barramento de um processador (C) e de forma autônoma (D).
Os primeiros três tipos de arquiteturas (A, B e C) apresentadas na Figura 2 são chamadas de processadores reconfiguráveis e possuem a lógica reconfigurável conectada a um processador mestre, sendo essas chamadas de acopladas.
As arquiteturas podem ser fortemente acopladas (RFUs (A)) ou fracamente acopladas (coprocessadores (B) e anexados (C)), devido a a distância da lógica reconfigurável ao processador mestre.
Em (A), a lógica reconfigurável é posicionada dentro de o processador, sendo normalmente inserida no estágio de execução do mesmo.
Esta lógica reconfigurável permite estender o conjunto de instruções do processador e é acessada com baixa latência devido a a proximidade entre a lógica reconfigurável e o processador.
Em (B), a lógica reconfigurável possui uma conexão dedicada com o processador, sendo esta tratada como um coprocessador.
Em este caso a lógica reconfigurável pode, opcionalmente, acessar diretamente a memória do processador e/ ou recursos de E/ S. Em (C), a lógica reconfigurável não possui uma conexão dedicada com o processador, sendo esta comunicação compartilhada com outros recursos do processador.
Com base nos diferentes tipos de arquiteturas apresentadas, a Figura 3 apresenta a evolução de dispositivos, processadores e sistemas reconfiguráveis ao longo de o tempo.
AT6000 XC6200 Virtex CLi6000 KressArray CLAy Matrix Spartan Spartan 2 MorphoSys OneChip Palma Anexado Walder Gecko Huebner Sistemas Reconfiguráveis Dyer Coprocessador Indústria Chimaera Universidade Processadores Reconfiguráveis Origem do trabalho:
Spartan 3 Nano Processor Tipo de processador reconfigurável:
Virtex 4 PRIS PipeRench Legenda:
O primeiro FPGA a ser construído foi o XC2064 em 1985 por a fabricante Xilinx.
Após, outros fabricantes surgiram no mercado de FPGAs:
Actel, Advanced Micro Devices (AMD), Semiconductor, Plessey, Plus, QuickLogic, entre outros.
Por volta de 1990, trabalhos acadêmicos apresentaram arquiteturas com múltiplos FPGAs comerciais (multi-chip), como por exemplo DeCPerle, CHS2 x4, MORRPH, Splash-2 e outros apresentados em.
Por volta de 1995, trabalhos acadêmicos mostraram diversas formas de conectar FPGAs a processadores, sendo alguns exemplos destes os processadores reconfiguráveis apresentados na Figura 3.
Por volta de a mesma época o meio acadêmico desenvolve seus próprios dispositivos reconfiguráveis, sendo estes também apresentados na Figura 3.
Estes, de forma geral, são dispositivos reconfiguráveis de grão grande, e não se popularizaram devido a a generalidade do grão restringir o conjunto de aplicações que obtêm um desempenho adequado no dispositivo.
Por volta de o ano 2000 os FPGAs comerciais já possuíam um milhão de portas lógicas equivalentes disponíveis ao projetista, permitindo a construção de aplicações com processadores e hardware dedicado num único FPGA.
Os FPGAs do ano de 2005 já possuem dez milhões de portas lógicas equivalentes disponíveis ao projetista e processadores embarcados.
Uma característica disponível em alguns FPGAs é a reconfiguração parcial e dinâmica.
As vantagens destes sobre outros que não possuem esta característica é a possibilidade de modificar parte do hardware do sistema enquanto o restante permanece executando.
O primeiro FPGA com esta característica foi o dispositivo CAL1024 da Algotronix, lançado no ano de 1988.
Após este, surgiram outros dispositivos que hoje não são mais comercializados:
ERA60100, CLi6000, CLAy-10 e CLAy-31, AT6000 e XC6200.
Os FPGAs parcial e dinamicamente reconfiguráveis disponíveis atualmente no mercado são os dispositivos da Atmel e da Xilinx.
A Atmel comercializa a família de dispositivos AT40k, enquanto a Xilinx vende as famílias Virtex, Virtex-II Para o e Virtex 4.
No entanto, poucos sistemas reconfiguráveis tiraram proveito da reconfiguração parcial e dinâmica dos FPGAs até o momento.
Um dos principais motivos é a inexistência ou a falta de documentação dos fabricantes de FPGAs em como utilizar esta característica.
Alguns exemplos de sistemas parcial e dinamicamente reconfiguráveis são apresentados na Figura 3, possuindo estes uma baixa latência de comunicação por terem sido implementados num único chip.
O Gecko é o único sistema reconfigurável que utiliza NoCs para conectar módulos reconfiguráveis, enquanto os outros sistemas utilizam barramento.
As Seções 2.1, 2.2 e 2.3 apresentam, respectivamente, processadores reconfiguráveis, dispositivos reconfiguráveis e sistemas reconfiguráveis, conforme delimitado na Figura 3.
Aplicações com computações intensivas passam em média 90% do tempo em apenas 10% do código.
Este fato motiva otimizar o processador para executar os trechos de código responsáveis por este maior consumo de tempo de processamento diretamente em hardware.
Devese observar que nem sempre o hardware dedicado é a solução para ganho de desempenho, pois em determinados casos o gargalo é o conjunto de operações de E/ S ou acessos à memória externa.
Processadores com um conjunto de instruções específicas para a aplicação (ApplicationSpecific Instruction-Set Processor ASIP) provêm flexibilidade e desempenho a um custo de área adicional para cada nova função implementada em hardware.
Um exemplo de ASIP é o Xtensa da Tensilica.
Processadores com um conjunto de instruções reconfiguráveis (Reconfigurable Instruction-Set Processor RISP) não apresentam um custo adicional de hardware para cada nova instrução, mas sim um custo pré-definido de área onde lógica reconfigurável pode ser programada em tempo de execução.
Segundo, a posição da lógica reconfigurável em relação a o processador tem um impacto direto no desempenho dos RISPs e nos tipos de aplicações que são beneficiadas por a lógica reconfigurável.
Obter um ganho de desempenho executando um pedaço de código em hardware reconfigurável depende de dois aspectos:
Tempo de comunicação e tempo de execução.
O tempo para executar uma operação é a soma do tempo necessário para enviar e receber dados de a/ para lógica reconfigurável, e o tempo de processamento.
Se este tempo total é menor que o tempo levado por o processador executar a operação sozinho, então um ganho de desempenho é obtido.
Se a lógica reconfigurável ainda não foi configurada para executar uma operação específica, então ainda é necessário adicionar o tempo de configuração.
Uma vantagem desta técnica é que a lógica reconfigurável funciona em paralelo com o processador, liberando o mesmo para outras tarefas ou para a gerência de recursos, enquanto a lógica reconfigurável trata da computação.
Outra vantagem é que como a lógica reconfigurável está conectada no mesmo meio de comunicação de outros periféricos do processador, logo a lógica reconfigurável pode fazer uso direto, por exemplo, da memória e periféricos de E/ S sem interromper o processador.
Tal vantagem pode ser de extrema valia para aplicações I/ O bound.
O PRISM-I (Processor Reconfiguration through Instruction-Set Metamorphosis) teve sua primeira publicação por Peter Athanas et al.
De a Universidade do Estado da Virginia.
Ele foi desenvolvido como prova de conceito para mostrar a viabilidade de incorporar um conjunto de instruções configurável a um processador de propósito geral.
O PRISM-I consiste na interconexão de um nodo de processamento Armstrong com uma plataforma com hardware reconfigurável por meio de um barramento, conforme ilustrado na Figura 4.
O nodo de processamento Armstrong é baseado num processador M68010 da Motorola, com freqüência de operação de 10 MHz.
A plataforma com hardware reconfigurável possui 4 FPGAs 3090 da Xilinx, cada um com seis mil portas lógicas equivalentes e 144 pinos de entrada e saída.
A interconexão das duas plataformas foi feita por a interface de coprocessador de 16 bits do M68010.
Para avaliar o sistema, o processador faz chamadas de funções implementadas em hardware reconfigurável.
As operações testadas consumiram de 48 a 72 ciclos de relógio para completar a operação e entregar a resposta de volta ao processador.
Os testes executados, embora tenham sido iniciais e prejudicados por o baixo desempenho do meio de comunicação, mostraram que é possível obter ganhos com a implementação de instruções em hardware reconfigurável.
De entre as diversas operações executadas, a que obteve melhor desempenho foi a função de logaritmo na base 2, executando 54 vezes mais rápido que em software.
A segunda versão do PRISM teve como principais objetivos estender o número de instruções suportadas por o compilador e reduzir o tempo de comunicação entre o processador e o hardware reconfigurável.
Enquanto o PRISM-I leva em média 100 ns para devolver a resposta ao processador, o tempo gasto na nova versão é de 30 ns.
Outra modificação feita foi no tamanho da palavra de dados, que no PRISM-I era fixa em 32 bits, e que no PRISM-II é de 64 bits para entrada e 32 bits para saída.
O PRISM-I também possuía a limitação que uma instrução tinha que caber num único FPGA.
A arquitetura do PRISM-II permite que uma única operação seja dividida em até três FPGAs.
Para prover um melhor balanceamento entre hardware e software o processador M68010 foi substituído por o AMD Am29050, com freqüência de 33 MHz e desempenho aproximado de 28 MIPS.
Os FPGAs 3090 foram substituídos por os 4010 com aproximadamente 10 mil portas lógicas equivalentes e 160 pinos de entrada e saída.
Todas essas modificações resultaram num fator de aceleração de aproximadamente 86 vezes em relação a software para uma função de reversão de bits numa palavra de 32 bits.
Isso mostra que essa versão obteve um ganho significativo de desempenho em relação a o PRISM-I, pois quando a mesma função foi executada na primeira versão ela obteve um fator de aceleração de apenas 26 vezes em relação a software.
O PipeRench foi proposto por Seth Goldstein et al.
De a Universidade de Carnegie Mellon.
A arquitetura é composta por uma rede de elementos lógicos e de armazenamento interconectados, que atuam como um coprocessador.
Esta arquitetura é organizada de forma a implementar um pipeline de configurações, sendo particularmente interessante para aplicações baseadas em fluxos uniformes (como processamento de imagens ou sons), ou qualquer computação simples e regular sobre grandes conjuntos de pequenos elementos de dados.
A Figura 5 apresenta uma visão abstrata de dois estágios do PipeRench e uma visão detalhada de um estágio.
Cada PE contém uma ULA e um conjunto de registradores para comunicação entre estágios (registrador de passagem).
Cada ULA contém LUTs e controle extra para propagação de carry, detecção de zero, e outros bits de controle.
Lógica combinacional pode ser implementada usando um conjunto de n ULAs de B bits.
Funções combinacionais complexas podem ser obtidas com o cascateamento das linhas de propagação de carry, através da rede de interconexão.
A partir de as redes de interconexão os PEs podem acessar operandos dos estágios anteriores que estão armazenados nos registradores de saída, bem como saídas de outros PEs do mesmo estágio.
O barramento global é utilizado tanto por a aplicação para entrada e saída de dados quanto por os PEs para alcançar os seus destinos, porque os estágios do pipeline de uma dada aplicação podem estar fisicamente em qualquer um dos estágios da arquitetura.
Com este dispositivo foi obtido um ganho de desempenho médio de 189 vezes sobre um Ultrasparc II com freqüência de 300 MHz.
Quando a lógica reconfigurável é conectada como coprocessador, existe uma interface dedicada entre processador e coprocessador.
Em este caso a comunicação entre processador e coprocessador ocorre sem intervenções externas, pois não há a concorrência de outros periféricos neste canal de comunicação.
Em contraponto, não é qualquer processador que pode fazer uso deste tipo de acoplamento, porque este necessita de uma interface específica para conectar um coprocessador.
Em este tipo de acoplamento a lógica reconfigurável pode, opcionalmente, acessar diretamente a memória do processador e/ ou recursos de E/ S. Em o entanto, esta comunicação só pode ocorrer quando o processador não estiver acessando a memória ou recursos de E/ S, pois a comunicação com estes periféricos é, normalmente, compartilhada entre processador e lógica reconfigurável.
Este tipo de acoplamento apresenta um custo benefício intermediário aos tipos anexado e RFU, pois aplicações IO-bound concorrem com o processador para acessar a memória e aplicações CPU-bound possuem um tempo intermediário de comunicação entre processador e lógica reconfigurável em relação a os outros tipos de acoplamento.
O Garp teve sua primeira publicação por John Hauser da Universidade da Califórnia em Berkeley e foi projetado com o principal objetivo de acelerar laços de aplicações de propósito geral.
O projeto implementa um coprocessador conectado ao MIPS, que consiste numa malha bidimensional de CLBs interconectadas por recursos de roteamento programáveis (Figura 6).
A célula lógica básica da matriz reconfigurável é uma unidade de 2 bits com quatro entradas de 2 bits cada.
Quatro canais de 32 bits de dados e um canal de 32 bits de endereços comunicam o processador à matriz reconfigurável.
A matriz reconfigurável possui pelo menos 24 blocos lógicos numa coluna, de os quais 16 blocos a partir de a primeira posição são conectados ao barramento compartilhado processadormemória.
Em a tentativa de minimizar os acessos ao barramento compartilhado, o projeto emprega a utilização de uma memória cache que pode armazenar quatro configurações totais da matriz ou diversas configurações parciais.
Uma reconfiguração total buscada da cache pode entrar em funcionamento em até cinco ciclos de relógio.
Para avaliar o desempenho do Garp foi utilizado um algoritmo de filtro de imagem que calcula a média dos pixels.
A execução do Garp obteve um desempenho 43 vezes melhor que um Ultrasparc 170.
O Morphosys foi proposto por Hartej Singh et al.
De a Universidade da Califórnia em Irvine e consiste em sete componentes principais (Figura 7):
Um processador baseado no MIPS (Tiny_ RISC), uma malha 8x8 de células reconfiguráveis, uma memória de contextos, uma fila, uma cache de dados, um controlador de DMA e duas memórias principais (uma do processador e outra de contextos da malha reconfigurável).
Cada célula da malha reconfigurável pode ser individualmente reconfigurada e possui uma ULA de 16 bits com módulo de multiplicação acoplado, uma unidade de deslocamento, dois multiplexadores que selecionam as entradas da célula, um registrador de contextos e quatro registradores de propósito geral.
Enquanto o processador executa as tarefas seqüenciais e de controle de transferência de dados entre o hardware reconfigurável e a memória, o hardware reconfigurável explora o paralelismo disponível do algoritmo da aplicação.
O processador RISC possui duas classes de instruções específicas para controlar os componentes do MorphoSys.
Uma dessas classes é responsável por carregar contextos da memória principal para a memória de contextos e a outra é responsável por iniciar transferências de dados entre a memória principal e a fila, sendo essa classe denominada de instruções de DMA.
A fila é uma memória de dados interna para a malha reconfigurável, provendo 128 palavras de 16 bits de memória.
Um barramento de operandos de 128 bits conecta a fila com a matriz de células reconfiguráveis.
Todas as células reconfiguráveis de uma mesma linha compartilham 16 bits do barramento de operandos.
Uma característica importante da malha reconfigurável é a sua interconexão em três níveis, o qual pode ser vista na Figura 8.
O primeiro nível acessa o vizinho mais próximo de a mesma linha/ coluna.
O segundo nível provê conectividade completa com a linha/ coluna do mesmo quadrante.
O terceiro nível provê conectividade interquadrante, que consiste em barramentos que percorrem todas as linhas e colunas, cruzando as bordas dos quadrantes.
Um dos algoritmos utilizados para avaliar o desempenho do MorphoSys foi o de DCT, sendo executado em 37 ciclos de relógio.
Este tempo foi mais de seis vezes menor que a execução do algoritmo num computador com processador Pentium MMX com instruções otimizadas.
O Systolic Ring foi proposto por Gilles Sassatelli et al.
De a universidade de Montpellier e foi projetado com o principal objetivo de acelerar computações intensivas orientadas a dados (e.
g multimídia e processamento de sinais).
A Figura 9 apresenta um diagrama de blocos da arquitetura do Systolic Ring.
O Systolic Ring possui uma rede em anel como meio de interconexão de blocos lógicos, denominados D-Nodes.
Cada D-Node possui uma ULA de 16 bits, um banco de registradores 4x16 bits e uma unidade de controle.
A unidade de controle possui 9 registradores, um contador para até 8 estados e um multiplexador 8x1.
Esta unidade de controle gerência o D-Node quando o mesmo está operando em modo local.
O D-Node também pode executar em modo global (normal), o qual executa microinstruções originadas do controlador de configurações.
O controlador de configurações é formado por um processador RISC personalizado para funcionar como um controlador de configurações.
A tarefa de ele é gerenciar dinamicamente as configurações da rede e controlar a comunicação de dados com um processador hospedeiro.
O Systolic Ring opera como segue.
O processador hospedeiro inicia a execução de uma aplicação e envia o código objeto a ser executado por o processador do controlador de configurações.
A o ser recebido o código objeto, o controlador de configurações pode configurar o Systolic Ring ciclo a ciclo se assim for configurado e inicia a recepção de dados a serem computados do processador hospedeiro.
Um Systolic Ring com 8 D-Nodes possui um poder máximo de computação de 1600 MIPS a 200 MHz, enquanto um Pentium II 450 MHz possui um poder máximo de computação de 400 Quando a lógica reconfigurável é conectada a um processador como RFU, esta é posicionada dentro de o processador, sendo normalmente inserida no estágio de execução do mesmo.
Este posicionamento permite estender o conjunto de instruções do processador com um tempo de acesso inferior aos oferecidos por os outros tipos de acoplamento.
O Nano Processor foi proposto por Michael Wirthlin et al.
De a Universidade de Brigham Young.
O seu principal objetivo é poder ser implementado em FPGAs da época, por isso ele dispõe de uma arquitetura simples, ocupando pouca área.
Ele possui seis instruções nativas e permite um total de 32 instruções.
O processador é organizado hierarquicamente em três níveis, conforme apresentado na Figura 10.
O nível mais interno do processador é o núcleo do Nano Processor, que possui as seis instruções nativas e não foi desenvolvido para ser modificado.
Ele possui um registrador de instruções (Instruction Register Ir) de 5 bits, um registrador de página de endereços (Page Address Register Par) de 3 bits, um contador de programa (Program Counter PC) de 8 bits, um registrador de endereços (Address Register AR) de 8 bits e um acumulador de 8 bits com 1 bit de carry.
Em esta arquitetura apenas instruções aritméticas de adição e subtração foram implementadas.
O nível intermediário do processador é chamado de Conjunto de Instruções Personalizadas.
Em ela são implementadas as instruções específicas ao problema a ser tratado por o processador.
Essas instruções podem ser selecionadas de uma biblioteca previamente desenvolvida ou criadas a partir de editores de esquemáticos ou ferramentas de síntese.
O nível mais externo é o Software Executável.
Em ele é implementado a aplicação em código assembly onde são feitas as chamadas das instruções nativas e personalizadas.
O Nano Processor foi prototipado numa plataforma da National Technologies.
A plataforma inclui dois FPGAs 3090 da Xilinx, duas memórias SRAMs 32k x 8, uma memória DRAM de 1 Mb, um codec stereo de 16 bits e uma interface com o PC.
O melhor ganho de desempenho obtido com esta plataforma foi de 240 vezes em relação a um processador 486 executando a 33 MHz para a aplicação saturating mixer.
O DISC (Dynamic Instruction Set Computer) também foi proposto por Michael Wirthlin et al.
De a Universidade de Brigham Young, um ano após a publicação do Nano Processor.
Ele foi desenvolvido para suportar modificações no seu conjunto de instruções em tempo de execução.
Para isso ele deve ser implementado em dispositivos que suportem reconfigurações parciais e dinâmicas.
Em o DISC todas as instruções são implementadas como módulos de hardware e são substituídas quando não existe mais espaço disponível para a instrução seguinte.
Essa abordagem possui a vantagem de não só utilizar uma área em hardware virtualmente maior que a existente fisicamente, mas também de permitir implementar funções complexas com melhor desempenho quando comparado a software.
A arquitetura do DISC e alguns exemplos de instruções são apresentados na Figura 11.
Antes de iniciar o DISC, um programa é carregado na memória, o módulo de controle global é carregado em hardware e o espaço de instruções dinâmicas é liberado.
A seguir o DISC inicia a execução do programa.
Quando for feita a chamada de uma instrução que não se encontra configurada, o processador é bloqueado e uma requisição de configuração de instrução é enviada ao computador hospedeiro por os pinos de entrada e saída do sistema.
O computador hospedeiro verifica o tamanho do módulo requisitado, seleciona onde o mesmo será posicionado, remove um ou mais módulos se não existir espaço suficiente no dispositivo, e reposiciona o módulo para onde ele havia sido selecionado.
A seguir, o computador hospedeiro envia a nova configuração para o sistema, o processador sai do estado de bloqueio e a instrução é executada.
Para avaliar o desempenho da arquitetura foi desenvolvido um algoritmo de filtro de imagem tanto com instruções de propósito geral quanto com instruções específicas.
O ganho de desempenho obtido por a versão com instruções específicas foi de 23,5 vezes sobre a implementação com instruções de propósito geral.
O OneChip teve a sua primeira publicação por Ralph Wittig et al.
De a Universidade de Toronto.
Em esse projeto é defendida a idéia que o processador deve estar fortemente acoplado ao hardware reconfigurável, minimizando os bloqueios do processador com uma comunicação rápida e eficiente entre eles.
Os recursos reconfiguráveis foram integrados no estágio de execução do processador, sendo chamados de Unidades Funcionais Programáveis (Programmable Functional Unit PFU).
As PFUs são adicionadas em paralelo às Unidades Funcionais Básicas (Basic Functional Unit BFU) do processador.
As PFUs implementam funções específicas a uma aplicação, podendo ser circuitos seqüenciais ou combinacionais.
As PFUs também podem ser utilizadas como lógica de cola para que o processamento de uma determinada função venha do mundo externo.
As BFUs são responsáveis por as operações lógicas e aritméticas elementares de qualquer aplicação.
O OneChip foi prototipado num Transmogrifier-1, que possui quatro FPGAs 4010 da Xilinx, dois chips de interconexão Aptix AX1024 e quatro memórias SRAMs 32k x 9.
O processador DLX baseado no MIPS foi particionado em três FPGAs, deixando um FPGA para PFUs do usuário.
O OneChip obteve um fator de aceleração de quase 50 vezes na aplicação de uma DCT (Discrete Cosine Transform) em relação a a execução numa Workstation SGI Indy rodando a 150 MHz com processador MIPS R4400.
A versão posterior do OneChip, chamada de OneChip-98, foi publicada por Jeffrey Jacob e Paul Chow ambos da Universidade de Toronto.
Realizando uma análise detalhada sobre o OneChip eles detectaram que o gargalo não era mais a interface entre o processador e a lógica reconfigurável, mas sim a interface destes com a memória.
Por este motivo, o OneChip-98, apresentado na Figura 12, busca uma maior taxa de transferência de dados com a memória, permitindo o acesso concorrente a mesma por a lógica reconfigurável e por o processador.
Para aumentar a taxa de transferência com a memória principal, caches foram adicionadas ao sistema, implementando uma hierarquia de memória semelhante à empregada em computadores pessoais.
Conseqüentemente, um mesmo dado pode ser trazido tanto para a cache do processador quanto para a cache do FPGA, causando um possível problema de coerência de caches.
O tratamento deste problema é analisado no artigo.
O OneChip-98 foi prototipado num Transmogrifier-2 com dois PLDs Altera Flex10 K50.
A aplicação de um filtro FIR 64-tap obteve uma aceleração de 32 vezes sobre um Ultrasparc 2 rodando a 300 MHz.
Os autores apontam como aplicações alvo problemas que acessam muito a memória.
O Chimaera foi proposto por Scott Hauck et al.
De a Universidade de Washington.
Ele possui Unidades Funcionais Reconfiguráveis (Reconfigurable Functional Unit RFU) pequenas o suficiente para serem integradas no próprio processador, buscando minimizar o gargalo de comunicação entre processador e lógica reconfigurável.
Esta abordagem permite utilizar a lógica reconfigurável para acelerar as computações críticas das aplicações, enquanto aproveita a flexibilidade dos processadores para a criação de software.
A Figura 13 apresenta a arquitetura do Chimaera.
O principal componente do sistema é a matriz reconfigurável, que possui uma arquitetura própria baseada no Triptych, na família FLEX 8000 da Altera e no PRISC.
A matriz recebe entradas do banco de registradores chamado &quot;sombra», que possui cópia de um subconjunto de valores do banco de registradores do processador.
Cada modificação feita no banco de registradores do processador é propagada por o barramento, assim atualizando o &quot;sombra».
As instruções que forem carregadas na matriz podem utilizar uma ou mais linhas de RFUs.
Sempre que uma linha de RFUs for configurada, uma memória conectada à matriz armazena, numa posição específica para a linha da RFU, o identificador da instrução que foi carregado na linha.
Em o momento em que uma operação da matriz for executada, as linhas de saída da matriz que possuem o identificador da instrução são habilitadas a colocar o resultado no barramento.
Enquanto o processador executa instruções nativas, o módulo de pré-busca verifica a cada ciclo de relógio o Registrador de Instruções (Instruction Register Ir), de forma &quot;especulativa».
Isso permite iniciar a execução da operação na matriz antes mesmo da chamada ter sido feita por o processador, assim reduzindo ou eliminando o bloqueio do mesmo à espera do resultado. Quando
a chamada é de fato executada por o processador, a matriz escreve o resultado no barramento de resultados caso a operação já tenha sido computada, caso contrário ela bloqueio o processador até a computação ser efetuada.
Também pode ocorrer da operação não estar presente na matriz, assim causando um bloqueio no processador até que a operação seja buscada da cache de instruções ou da memória, parcialmente configurada na matriz e executada.
Em este caso o tempo de reconfiguração pode ser significativo, logo o programador deve evitar ficar recarregando a RFU constantemente.
O Chimaera possui nove registradores que podem servir como origem de uma operação a ser executada nas RFUs.
O programador deve saber quais destes registradores devem ser carregados antes de chamar a operação a ser executada na matriz, pois quando o processador chama uma operação implementada na RFU é passado como parâmetro somente o identificador da operação e o registrador de retorno.
As RFUs do Chimaera foram desenvolvidas para tratar com eficiência instruções típicas de um processador como And, OR, XOR, XNOR, operações aritméticas simples, condições de salto e combinações destas.
Essa arquitetura, embora simples, apresentou desempenhos até 160 vezes superiores do que a execução do processador sem lógica reconfigurável.
Esta Seção apresenta exemplos de como a lógica reconfigurável pode ser utilizada de forma autônoma, ou seja, sem levar em consideração um processador.
Em este sentido são apresentadas nas próximas Seções dispositivos reconfiguráveis, organizados conforme a Tabela 2.
A maior parte dos dispositivos reconfiguráveis acadêmicos encontrados na literatura são dispositivos de granularidade grande.
Um dos principais motivos desta tendência é uma maior simplicidade de mapeamento e roteamento para este tipo de dispositivo, reduzindo a complexidade da implementação de ferramentas de CAD e o tempo de execução destas ferramentas.
Além disso, como os blocos lógicos trabalham com palavras de dezenas de bits, o número de elementos de interconexão é reduzido, pois todos os fios de uma palavra são roteados através de um único elemento de chaveamento.
A conseqüência deste fato é um menor consumo de energia e área.
Outra vantagem é um menor tempo de reconfiguração em comparação com os dispositivos de grão pequeno, pois a complexidade é reduzida devido a um menor número de chaves de roteamento e elementos reconfiguráveis.
A desvantagem de dispositivos reconfiguráveis de grão grande é que as operações e o tamanho da palavra são limitadas por o grão, tratando operações e tamanhos de palavra múltiplos a sua arquitetura.
Em certos casos, este fato pode causar uma perda de eficiência em consumo de potência e desempenho.
As próximas Seções apresentam alguns exemplos de dispositivos reconfiguráveis acadêmicos de grão grande.
O KressArray-I, publicado por Rainer Kress et al.
De a Universidade de Kaiserslautern, pode ser considerado como a primeira arquitetura de grão grande reconfigurável, pois suas Unidades de Blocos de Dados (Datapath Unit DPU) manipulam dados de 32 bits.
O conjunto de DPUs do KressArray-I é chamado de Arquitetura de Blocos de Dados Reconfiguráveis (Reconfigurable Datapath Architecture RDPA), possuindo topologia em malha e DPUs com dois registradores de entrada e dois registradores de saída, conforme apresentado na Figura 15.
As operações são dirigidas a dados, ou seja, elas são avaliadas logo que todos os operandos estão disponíveis, utilizando para isso um protocolo semelhante a um handshake para a sincronização de dados entre DPUs.
O KressArray-I provê barramentos locais e globais.
O barramento local interconecta os vizinhos e é implementado como uma malha unidirecional para reduzir gastos em área.
O barramento global interconecta cada DPU da arquitetura, sendo utilizado para entrada e saída do KressArray-I e para propagação de resultados intermediários de DPUs distantes.
Outra alternativa de projeto empregada para reduzir área foi a multiplexação das interconexões globais, passando assim a tarefa de gerência para um escalonador externo.
O escalonamento do acesso a dados é feito por o ambiente de software, que calcula o tempo de execução de toda a aplicação e escalona os dados buscando atingir o melhor desempenho.
O KressArray-III é uma versão posterior do KressArray-I que passou a chamar as DPUs de RDPUs.
Em esta arquitetura as conexões passaram a ser bidirecionais, conectando- se as quatro RDPUs vizinhas.
Aqui &quot;bidirecional «significa que a direção é selecionada em tempo de configuração, ou seja, ela é fixa durante a execução.
Também foi inserido nesta arquitetura um hardware adicional responsável por paralelizar o acesso à memória, permitindo acesso em modo rajada.
Em o KressArray-III as RDPUs podem servir tanto para roteamento quanto para a aplicação de uma determinada função.
O conjunto de funções também foi estendido, agora podendo executar qualquer operação aritmética não ponto- flutuante da linguagem C. A arquitetura MATRIX (Multiple ALU Architecture wiTh Reconfigurable Interconnect eXperiment) foi proposta por Ethan Mirsky e André DeHon do MIT.
Ela possui topologia em malha que conecta Unidades Básicas Funcionais (Basic Functional Unit BFU) de 8 bits.
Cada BFU contém 256 palavras de 8 bits de memória, uma ULA de 8 bits com uma unidade de multiplicação agregada e uma unidade de controle implementada através de PLA.
A rede MATRIX é uma coleção hierárquica de barramentos de 8 bits que possui a opção de dinamicamente trocar as conexões.
A rede interconecta os vizinhos mais próximos, vizinhos a uma distância de quatro posições e também interconecta BFUs por linhas globais.
Essa estrutura hierárquica de interconexão atinge alta taxa de transferência de dados e, em contraponto, dificulta o mapeamento da aplicação.
O CHESS foi desenvolvido por Alan Marshall et al.
De a Hp Labs e possui topologia em malha.
A unidade de computação fundamental é uma ULA de quatro bits, que possui um conjunto de 16 instruções básicas.
Ao contrário de outras arquiteturas aritméticas reconfiguráveis, o CHESS possui uma arquitetura no formato de um tabuleiro de xadrez, conforme apresentado na Figura 18.
Cada ULA contém barramentos de quatro bits de largura de entrada e saída em cada um dos seus quatro lados.
Isto possibilita o envio e recebimento de dados de/ para qualquer uma das oito ULAs à sua volta.
Em tempo de execução qualquer uma das chaves pode ser utilizada como memória de 16 palavras de 4 bits.
Em este modo a chave permanece desconectada, no entanto, barramentos que passam sobre a chave ainda podem continuar operando.
Logo, se um grande número de chaves for utilizado como RAM a capacidade de roteamento fica reduzida.
Para evitar este problema, o CHESS suporta a inserção de BRAMs.
O CHESS provê a capacidade de encadeamento de ULAs, o que é útil para computações seriais de nibbles.
As instruções executadas por as ULAs podem ser estáticas ou dinâmicas.
Instruções estáticas são armazenadas como parte da configuração fixa da ULA.
Instruções dinâmicas são geradas por o encadeamento de ULAs.
Isso permite que instruções sejam modificadas ciclo-a-ciclo, suportando determinadas execuções como macros, implementando processadores específicos ou provendo um efeito de arquitetura reconfigurável de grão fino.
A arquitetura do CHESS foi otimizada para reduzir atrasos de comunicação, favorecendo interconexões locais entre os elementos de processamento e não possuindo barramentos globais.
Interconexões longas podem ser obtidas por a conexão de múltiplos segmentos de barramentos ou por a utilização do CHESS como um pipeline.
O DReAM (Dynamically Reconfigurable Architecture for Mobile Systems) foi desenvolvido na Universidade de Darmstadt por Jürgen Becker et al.
O DReAM possui uma topologia em malha de unidades de processamento reconfiguráveis (Reconfigurable Processing Unit RPU).
Ele foi fabricado por a Mietec/ Alcatel com tecnologia CMOS 0.
35 µm.
O DReAM é composto por a interconexão de 8 componentes, conforme apresentado na Figura 19.
Enquanto o barramento local liga RPUs vizinhas, a interconexão global é composta por barramentos segmentados por chaves.
A estrutura da RPU foi otimizada para requisitos de sistemas de comunicação móvel, sendo desenvolvida para executar manipulações de dados aritméticos.
A RPU possui duas RAMs de 16 por 8 bits dupla porta e duas unidades de execução de 8 bits dinamicamente reconfiguráveis, chamadas de Unidades Reconfiguráveis de Processamento Aritmético (Reconfigurable Arithmetic Processing Unit Rap).
As RAMs de dupla presentes nas RPUs são utilizadas tanto como LUTs nas operações de multiplicação quanto como memória de dados ou como fila para armazenar resultados intermediários.
Cada Rap integra dois deslocadores e uma ULA.
Esta Seção apresenta a arquitetura interna de FPGAs parcial e dinamicamente reconfiguráveis das últimas duas décadas.
O dispositivo CAL1024 da Algotronix foi o primeiro dispositivo parcial e dinamicamente reconfigurável a ser fabricado.
As especificações técnicas do dispositivo surgiram da tese de doutorado de Tom Kean.
O dispositivo possui uma matriz de 32 por 32 células configuráveis, com 5 mil portas lógicas equivalentes.
O dispositivo possui 128 pinos de E/ S, permitindo implementar plataformas com múltiplos FPGAs.
A estrutura básica de uma célula do CAL1024 é apresentada na Figura 20.
A célula possui conexões de entrada e saída de um bit com cada uma das quatro células vizinhas NEWS (North, East, West, South) e duas entradas globais (G1 e G2).
Os sinais globais foram implementados com o propósito de serem utilizados como sinais de relógio do circuito, no entanto estes podem ser utilizados por a lógica do usuário.
A célula pode implementar qualquer uma das 20 funções apresentadas na Tabela 3.
Observar que ao invés de utilizar LUTs, a função da célula básica é definida por um conjunto de multiplexadores.
A memória de configuração do CAL1024 possui 18k bits, sendo 18 bits para cada célula.
Cada célula está organizada na memória de configuração em 2 linhas de 9 colunas, conforme ilustrado na Tabela 4.
Novos valores podem ser escritos individualmente na memória de configuração, automaticamente reconfigurando parcialmente o dispositivo.
O dispositivo ERA60100 da Plessey[ PLE90] possui uma matriz de 50 por 50 células, sendo a célula deste dispositivo a mais simples de todos os FPGAs.
A Figura 21 apresenta o diagrama de blocos da célula, podendo esta ser configurada como uma porta lógica NAND, como um inversor ou como um flip-flop.
O ERA60100 possui quatro tipos de roteamento:
Local, curta distância, longa distância e periferia.
O roteamento local conecta as células vizinhas mais próximas.
Os roteamentos de curta e longa distância são barramentos verticais e horizontais que se estendem, respectivamente, por 10 células e por o chip inteiro.
O roteamento de periferia é um barramento de 10 bits que se estende junto com os pinos de E/ S localizados na periferia do chip.
O Era pode ser configurado a partir de 3 diferentes fontes:
Por um ROM, por outro FPGA ou por um dispositivo autônomo como, por exemplo, um processador.
O dispositivo pode ser parcialmente reconfigurado por linha, permitindo que uma parte do dispositivo seja modificado enquanto o restante permanece funcionando.
O tempo de reconfiguração é proporcional ao número de linhas a ser configurado.
Uma configuração total pode ser efetuada em aproximadamente 350 µs.
Em 1993 a Algotronix foi comprada por a Xilinx, tendo sido a tecnologia da Algotronix utilizada como base para a construção da família de dispositivos XC6200.
Apenas os dispositivos XC6216 e XC6264 foram construídos desta família, possuindo, respectivamente, uma matriz de 64 por 64 e 128 por 128 células.
A Figura 22 apresenta o diagrama de blocos de uma célula desta família de dispositivos e sua respectiva unidade funcional.
Observar a semelhança entre as Figura 20 e Figura 22.
A célula recebe três entradas de vizinhos NEWS a uma célula de distância (N, E, W, S) e a quatro células de distância (N4, E4, W4, S4).
Além de estas entradas, a célula recebe as entradas globais CLR e CLK utilizadas por o flip-flop D da unidade funcional.
A célula possui como saída conexão direta com os quatro vizinhos NEWS e uma saída (MAGIC) para a conexão com células localizadas a uma distância maior ou igual a quatro células.
O tempo mínimo de leitura e escrita na memória de configuração da família de dispositivos XC6200 é, respectivamente, 30 ns e 40 ns.
Cada célula está organizada na memória de configuração em três bytes, conforme ilustrado na Tabela 5.
A família de dispositivos Virtex da Xilinx foi a sucessora da família XC6200, tendo esta sido descontinuada quando a primeira foi lançada em 1998.
A família Virtex evoluiu para a família Virtex-II em 2000 e para Virtex-II Para o em 2002.
Devido a as famílias Virtex-II e Virtex-II Para o terem herdado todas as características da Virtex, apenas estas serão contempladas no decorrer de esta Seção.
Para informações específicas do dispositivo Virtex o leitor é remetido a e a.
A Figura 23 apresenta os principais recursos dos dispositivos Virtex-II.
A Virtex-II é composta basicamente por blocos lógicos configuráveis (CLBs ­ Configurable Logic Blocks), blocos de entrada e saída (IOBs ­ Input/ Output Blocks), blocos de memória (BRAMs Block Select RAMs), gerenciadores digitais de relógio (DCMs ­ Digital Clock Manager), multiplicadores e recursos de roteamento que interconectam todos estes componentes.
As CLBs provêem elementos funcionais para a implementação de lógica combinacional e/ ou seqüencial.
Cada CLB possui quatro slices e dois tristates.
A Figura 24 apresenta a metade superior de uma CLB e compreende geradores de função de quatro entradas (Look-Up Tables LUTs), flipflops para armazenamento de um bit e recursos como propagação rápida de carry.
Cada BRAM possui 18 Kb de memória dupla porta, programável em diversas larguras de dados e endereços.
A Virtex-II Para o possui todos os recursos dos dispositivos Virtex-II e mais dois processadores Power PC.
A Tabela 6 apresenta a quantidade desses e outros recursos existentes em cada dispositivo das famílias Virtex-II e Virtex-II Para o.
A arquitetura de (re) configuração dos dispositivos Virtex é organizada como uma matriz bidimensional de bits.
No entanto, o dispositivo só pode ser configurado unidimensionalmente em colunas, onde cada coluna é composta por frames.
O frame é a menor unidade que pode ser lida ou escrita do FPGA.
Quanto menor o número de linhas de CLBs do FPGA, menor é o tamanho do frame e conseqüentemente mais rápido é o tempo de reconfiguração de um frame.
A Tabela 7 apresenta o número de bits de um frame dos dispositivos apresentados na Tabela 6, assim como o tempo de reconfiguração de um bitstream total para diversos modos de configuração.
Tabela 7 ­ Informações para a reconfiguração de dispositivos Virtex-II e Virtex-II Para o.
Virtex-II Para o Virtex-II Dispositivo Número de frames Tamanho do frame em bits Bits de Configuração Total de bits (incluindo cabeçalho) Tempo de download SelectMap em ms Tempo de download Serial em ms Tempo de download (33 MHz) em ms Os dispositivos da família Virtex-II possuem uma porta interna de acesso de configuração denominada ICAP (Internal Configuration Access Port).
Este componente, apresentado na Figura 25, está localizado na parte inferior direita do FPGA e permite que o dispositivo se auto reconfigure.
O ICAP pode funcionar a uma velocidade máxima de 66 MHz.
A interface de comunicação do ICAP, apresentada na Tabela 8, é semelhante à interface SelectMAP, não possuindo os pinos utilizados exclusivamente para reconfiguração total (DONE, INIT e PROGRAM) e os pinos de modo de configuração (M0, M1 e M2).
Barramento de entrada de dados por onde é feita uma configuração.
O pino I[ 0] é o bit mais significativo.
Barramento de saída de dados por onde é feito readback e por onde saem informações de estado durante uma configuração.
O pino O é o bit mais significativo do byte.
Indica quando o FPGA pode aceitar outro byte.
Quando BUSY está em nível lógico baixo, o FPGA lê o barramento de dados na próxima borda de subida de CCLK quando ambos, CE e WRITE estiverem em nível lógico baixo.
Se BUSY estiver em nível lógico alto, o byte atual é ignorado e precisa ser mantido no barramento até a próxima borda de descida de CCLK, quando BUSY estiver em nível lógico baixo.
Habilita o ICAP.
Este pino é ativo em nível lógico baixo, embora esta polaridade possa ser invertida através da ferramenta FPGA Editor.
Indica se está sendo feita uma configuração ou um readback do FPGA.
É ativado em nível lógico baixo, podendo ser invertido via FPGA Editor, assim como o sinal CE.
Quando em nível lógico baixo, WRITE indica que um byte está sendo escrito através do barramento I.
Quando em nível lógico alto, WRITE indica que um byte está sendo lido através do barramento O.
Outra característica das famílias de dispositivos Virtex da Xilinx é que eles são glitchless, permitindo que áreas que sobrescreverem os mesmos dados de configuração aos existentes não apresentem nenhum tipo de transitório.
No entanto, caso sejam enviados dados de configuração diferentes dos previamente existentes no FPGA, glitches podem ser observados em sinais que ligam a área que está sendo reconfigurada ao restante da lógica que está fixa no dispositivo.
Esta Seção apresenta sistemas parcial e dinamicamente reconfiguráveis.
Estes sistemas estão organizados a partir de o meio de comunicação empregado, mostrando a evolução destes meios em SoCs.
Para esta Seção foram selecionados apenas sistemas que reconfiguram um módulo inteiro, sendo descartado aqueles que fazem a reconfiguração de &quot;parâmetros», onde apenas alguns valores em memória são modificados para que um módulo opere com novos valores de entrada.
Um ponto em comum entre os trabalhos apresentados é que todos utilizam as famílias Virtex e Virtex-II da Xilinx.
O motivo principal desta escolha em comum é que a Xilinx é a única empresa atualmente no mercado a comercializar dispositivos parcial e dinamicamente reconfiguráveis com alta densidade de porta lógicas, assim possibilitando a construção deste tipo de sistema.
As próximas Seções apresentam exemplos de sistemas reconfiguráveis, organizados conforme a Tabela 9.
Quando apenas um módulo de hardware deve ser conectado a outro, a conexão direta, também chamada de ponto a ponto, é normalmente empregada.
Este tipo de interconexão permite extrair o máximo de desempenho da comunicação, pois é construído especificamente para atender os requisitos dos dois módulos que estão se comunicando.
O sistema de Dyer et al.
Foi validado numa plataforma XSV800 que possui um dispositivo FPGA Virtex 800.
A Figura 26 apresenta o diagrama de blocos do sistema de Dyer, que implementa no mesmo FPGA um processador LEON e um coprocessador reconfigurável.
Foram desenvolvidos dois decodificadores de áudio como coprocessadores para o LEON, um PCM e um Intel/ DVI compatível com o decodificador ADPCM.
O módulo ADPCM executa a 50 MHz e utiliza 430 slices;
O módulo PCM utiliza 35 slices.
Em este sistema um módulo Ethernet recebe pacotes UDP com áudio codificado, o processador LEON desempacota o áudio codificado e passa para o módulo reconfigurável decodificar- lo.
O resultado é automaticamente ouvido por a saída de som da plataforma de prototipação.
O sistema proposto por Dyer é dito ponto a ponto porque define uma interface única entre o coprocessador e os módulos a ele conectado (Leon e D/ A converter).
Dois conjuntos de macros de passagem (feed-through) são utilizados.
O primeiro conecta o Leon ao coprocessador e o segundo o coprocessador ao D/ A converter.
O sistema não é escalável, não permitindo agregar novos componentes ao sistema, como ocorre em barramentos ou NoCs.
Barramento, conforme apresentado no Capítulo 1, é um meio de comunicação simples e que ocupa pouca área, sendo adequado para a comunicação de poucos módulos de hardware devido a este ser compartilhado por todos a ele conectado.
Para sistemas reconfiguráveis unidimensionalmente, como os dispositivos Virtex, barramentos são normalmente fixados horizontalmente na parte inferior ou superior do dispositivo, de forma a comunicar os módulos reconfiguráveis posicionados verticalmente.
O sistema de Palma et al.
Foi implementado numa plataforma VW300 que possui um dispositivo FPGA Virtex 300.
A Figura 27 apresenta o diagrama de blocos do sistema de Palma, que implementa um barramento de dados de um bit, um árbitro do barramento, um módulo mestre e até três módulos escravos.
Em este sistema os módulos escravos (reconfiguráveis) executam operações aritméticas.
O módulo mestre é responsável por fazer as solicitações de computação aos módulos escravos.
Para que o módulo mestre possa fazer a transferência de dados por o barramento para os módulos escravos, o módulo mestre deve antes requisitar acesso ao árbitro para que o mesmo possa utilizar o meio de comunicação compartilhado.
Quando o acesso é liberado, o módulo mestre começa a enviar bit a bit os valores a serem calculados.
Uma vez que o módulo escravo tenha efetuado a operação, o módulo escravo utiliza a mesma política de comunicação com o arbitro do barramento para enviar a resposta da operação para o módulo mestre.
Em este sistema o módulo mestre envia para o display os resultados das operações efetuadas e as solicitações de reconfiguração.
Uma vez que um pedido de reconfiguração foi enviado para o display o sistema permanece parado até que o usuário faça a reconfiguração parcial manualmente do módulo escravo requisitado e aperte no botão de start da plataforma de prototipação.
Em este sistema o microcontrolador é responsável por gerenciar os módulos reconfiguráveis durante a execução do sistema.
Quando o microcontrolador necessita de um módulo reconfigurável que não se encontra configurado, este envia uma requisição à unidade de descompactação, que por sua vez inicia a busca do bitstream específico na memória flash e envia para o módulo ICAP.
Não foram divulgados quais foram os módulos reconfiguráveis utilizados para este sistema, apenas que as aplicações alvo são multimídia e automotivas.
Não foram divulgados quais foram os módulos reconfiguráveis utilizados para teste deste sistema.
O sistema R8NR, que também pode ser caracterizado como coprocessador reconfigurável, foi validado numa plataforma V2 MB1000 que possui um dispositivo Virtex-II 1000.
A Figura 30 apresenta o diagrama de blocos do sistema R82R com duas áreas reconfiguráveis.
O sistema é composto por três módulos:
Um computador hospedeiro, provendo uma interface para o sistema do usuário;
Uma memória de configurações, contendo todos os bitstreams parciais a serem utilizados durante a execução do sistema;
Um FPGA, contendo áreas fixas e reconfiguráveis do sistema R82R.
A área fixa do FPGA é um sistema computacional completo, incluindo o processador R8R, a sua memória local contendo instruções e dados, um barramento do sistema controlado por um árbitro e periféricos (interface serial e controlador de configurações).
A interface serial provê comunicação com o computador hospedeiro através de uma interface RS-232 padrão.
O controlador de configurações (CC) é um periférico desenvolvido para agir como um módulo escravo do processador R8R ou do computador hospedeiro.
Foram desenvolvidas três instruções aritméticas como coprocessadores para o processador R8R:
Divisão, multiplicação e raiz quadrada.
O principal objetivo deste sistema foi avaliar quando uma determinada implementação em hardware começa a ser vantajosa com relação a uma implementação em software, baseada no número de vezes que este hardware é empregado antes de ser reconfigurado.
Os módulos multiplicador, divisão e raiz quadrada começam a ser vantajosos em relação a a implementação em software a partir de 750, 260 e 200 execuções, respectivamente.
Para interconectar diversos módulos de hardware que demandam altas taxas de transferência de dados, barramentos podem não prover a qualidade de serviço desejada.
Em este contexto, NoCs parecem ser uma boa solução para a interconexão destes módulos de hardware.
A seguir é apresentado o sistema Gecko, sendo este o único exemplo de sistema encontrado na literatura até o presente momento a utilizar módulos dinamicamente reconfiguráveis conectados a uma NoC.
Embora a DyNoC também permita a reconfiguração dinâmica de módulos, nesta a reconfiguração é disruptiva, pois interrompe a execução de outros módulos e roteadores posicionados na mesma coluna.
Outro problema da DyNoC é que esta não trata os pacotes existentes nos roteadores antes de reconfigurar- los.
O sistema Gecko, apresentado na Figura 31, é composto por um computador de mão iPAQ 3760 com processador StrongArm e um FPGA Virtex-II 6000.
O sistema operacional OS4RS, executado sobre o iPAQ, controla as tarefas de hardware executadas no FPGA.
O FPGA implementa uma NoC 3x3 com topologia malha como meio de comunicação dos seguintes módulos de hardware:
Cinco processadores RISC de 16 bits, um bloco 2D IDCT, uma interface para uma CPU externa e dois processadores reconfiguráveis de grão fino.
A NoC do Gecko é composta de três redes, conforme ilustrado na Figura 32: Uma rede de dados, uma rede de controle e uma rede de reconfiguração.
Estas três redes distintas foram criadas porque cada rede possui propósitos e necessidades diferentes, permitindo assim tratar cada uma de forma eficiente.
Um exemplo de aplicação executado sobre o Gecko é ilustrado na Figura 33.
Em primeiro momento, um vídeo está sendo executado no PDA, utilizando todos os recursos de hardware disponíveis.
A seguir, iniciam- se os comerciais e o usuário minimiza a janela do filme para executar outro aplicativo em primeiro plano.
Quando isso ocorre, o número de recursos alocados ao vídeo é reduzido, pois não é necessário executar o vídeo em alta definição e taxa de amostragem.
A o executar, por exemplo, um jogo em primeiro plano, este pode utilizar os recursos de hardware previamente liberados.
Este Capítulo apresentou diferentes processadores, dispositivos e sistemas reconfiguráveis, enfatizando- se sua evolução ao longo de o tempo.
Observa- se nitidamente três gerações nesta evolução:
Sistemas com múltiplos FPGAs;
Dispositivos reconfiguráveis de grão grande;
Sistemas reconfiguráveis de grão grande prototipados sobre dispositivos reconfiguráveis de grão fino com elevado número de portas lógicas equivalentes.
O objetivo perseguido em sistemas reconfiguráveis desde 1985 é adicionar ao hardware a flexibilidade alcançada no software.
A primeira geração era penalizada por o baixo desempenho do meio de comunicação e baixa densidade dos dispositivos reconfiguráveis.
A segunda geração era penalizada por a pouca flexibilidade do grão, pois o mesmo é implementado na forma de ULAs ou processadores, os quais realizam um conjunto pequeno de operações.
A terceira geração provê flexibilidade, pois permite que qualquer função seja implementada nos módulos reconfiguráveis, com razoável desempenho no meio de comunicação.
O sistema Gecko é semelhante à arquitetura proposta na presente Dissertação, pois utiliza NoC como meio de comunicação, provendo ao usuário as características de escalabilidade e elevado desempenho no meio de comunicação.
O dispositivo de grão fino utilizado nos sistemas da terceira geração (Virtex) é adequado para arquiteturas que utilizam barramentos, dada a natureza unidimensional do processo de configuração.
Sistemas baseados em NoCs têm uma natureza bidimensional no posicionamento dos módulos, o que requereria dispositivos que permitissem a reconfiguração individual de blocos lógicos, como ocorria em CAL1024, ERA60100 (Seção 2.2.2.2) e XC6200 (Seção últimas duas décadas, convergindo nos últimos anos para FPGAs comerciais que possibilitam reconfigurar parcial e dinamicamente módulos de hardware do sistema.
De entre estes pode se observar que os dispositivos Xilinx são os que possuem maior densidade de portas lógicas equivalente e documentação relacionada à reconfiguração parcial e dinâmica Embora os dispositivos Xilinx possuam a característica de ser parcial e dinamicamente reconfiguráveis e existam sistemas com esta característica, ainda não há um fluxo de projeto específico e adequado para a implementação destes sistemas, conforme relatado na revista Xcell da própria fabricante.
Exemplos de fluxos de projeto utilizados para a implementação dos sistemas parcial e dinamicamente reconfiguráveis citados no Capítulo 2 são detalhados neste dos sistemas.
A Seção 3.1 apresenta uma breve introdução sobre o fluxo de projeto padrão para FPGAs Xilinx, o qual deve ser conhecido antes de inserir características de reconfiguração parcial e dinâmica sobre o mesmo.
A seguir, um fluxo de projeto genérico para a construção de SDRs é apresentado na Seção 3.2, apontando os principais passos a serem executados e problemas a serem resolvidos por fluxos reais.
A Seção 3.3 e 3.4 apresentam, respectivamente, os fluxos utilizados por os sistemas de Dyer e Palma.
A Seção 3.5 apresenta o fluxo de Projeto Modular, utilizado por os sistemas de Walder (Seção 2.3.2.3), R8NR (Seção 2.3.2.4), Gecko e outros.
O fluxo de Horta é apresentado na Seção 3.6.
Por fim, a Seção 3.7 apresenta o fluxo de projeto utilizado por o sistema de Huebner (Seção 2.3.2.2).
Esta Seção apresenta uma introdução ao fluxo utilizado na implementação de projetos de hardware para FPGAs Xilinx e respectivas alternativas de ferramentas para cada um dos passos.
Este fluxo inicia com um projeto em linguagem de descrição de hardware e é finalizado por a geração do bitstream.
É importante conhecer cada um desses passos e as respectivas ferramentas, pois algumas destas farão uso de parâmetros avançados e específicos quando aplicadas a SDRs.
O primeiro passo apresentado na Figura 34 é a simulação funcional do projeto descrito em linguagem de descrição de hardware (VHDL, Verilog ou System-C RTL).
Em esta etapa, é possível verificar o correto funcionamento lógico do projeto a partir de a aplicação de vetores de teste à entrada do mesmo.
O passo seguinte é a síntese lógica do hardware.
Algumas alternativas de ferramentas de síntese lógica são o XST da Xilinx, o Leonardo Spectrum da Mentor e o Synplify da Synplicity.
Estas ferramentas suportam uma série de otimizações selecionáveis por o usuário, como maior controle do nível de esforço para redução de área, velocidade ou potência.
Estas ferramentas A ferramenta de síntese lógica também pode gerar um arquivo HDL com atraso de portas (em formato SDF Standard Delay Format), que contém os atrasos das portas lógicas.
Isto permite fazer uma simulação mais precisa, possibilitando encontrar erros de temporização, não encontrados na simulação funcional.
Caixas pontilhadas representam passos opcionais do fluxo.
O arquivo EDIF, gerado por a ferramenta de síntese lógica, acompanhado do arquivo de restrições de recursos do usuário (UCF ­ User Constraints File), específico para o FPGA alvo, são as entradas para a fase de síntese física.
A síntese física é responsável por o mapeamento das portas roteamento destes recursos.
As ferramentas da Xilinx que executam estes passos são NGDBuild, MAP e Par.
Após o término da execução destas ferramentas, um bitstream total e uma série de relatórios são gerados.
Entre os principais relatórios gerados, os mais importantes são os de velocidade e o de área, que informam os atrasos dos caminhos críticos do projeto e a ocupação de área deste no FPGA.
O bitstream total do projeto é gerado por a ferramenta BitGen da Xilinx, podendo este ser configurado no FPGA a partir de a execução da ferramenta Impact.
A Seção 3.1 versou sobre a execução do fluxo de projeto padrão para projetos de hardware sem características reconfiguráveis.
As seções 3.2.1 a 3.2.6 apresentam um fluxo de projeto genérico para SDRs.
Em este contexto faz- se antes necessário definir os termos sistema e projeto.
Utilizará- se- sistema como sendo o equivalente a SDR e possuindo diversos projetos.
Cada projeto é um dos possíveis estados atuais de configuração do sistema.
O primeiro passo do fluxo de projeto é definir a estrutura geral do SDR, escolhendo a quantidade de áreas reconfiguráveis que farão parte deste e quais módulos estarão inicialmente configurados nestas áreas reconfiguráveis.
É aconselhável prototipar este projeto usando configuração total, de forma a garantir que as restrições temporais deste sejam atendidas e que o mesmo opere em hardware.
O motivo para esta prototipação inicial é garantir a operacionabilidade do ponto de partida do SDR, uma vez que serão posteriormente adicionados novos elementos, agregando complexidade ao todo.
O passo seguinte é a instanciação de componentes provedores de comunicação controlada entre os módulos reconfiguráveis e o restante do projeto.
Estes componentes, também conhecidos como macros na literatura, fixam a posição das entradas e saídas entre cada um dos módulos reconfiguráveis instanciados em diferentes projetos do sistema.
Para que as macros, instanciadas na Seção 3.2.2, fixem corretamente as entradas e saídas de cada um dos módulos de cada um dos projetos do sistema, tanto os módulos quanto as macros correspondentes em cada projeto devem ser posicionados nas mesmas coordenadas do FPGA.
Esta restrição de posicionamento, obrigatória para SDRs, pode ser feita com a ferramenta gráfica Floorplanner da Xilinx.
O Floorplanner permite selecionar a posição destino dos componentes do projeto dentro de o FPGA e definir o formato de alocação de lógica dos módulos no mesmo.
O Floorplanner gera como saída um arquivo de restrições do usuário (User Constraints File UCF).
Uma vez gerado o primeiro UCF de um projeto, este pode ser reutilizado para gerar novos projetos do mesmo SDR.
Infelizmente, ao restringir a lógica de um módulo a uma determinada posição do FPGA, não obrigatoriamente os fios que interconectam os componentes internos deste módulo estarão posicionados dentro de os limites definidos para a lógica.
Com freqüência, os fios internos de um módulo invadem a área de outro.
Caso um ou mais fios cruzem a área pré-definida, estes ficarão desconectados após a reconfiguração, podendo ocasionar o não funcionamento do projeto e até mesmo um dano físico no dispositivo.
A ferramenta FPGA Editor da Xilinx permite visualizar os fios do sistema e rotear manualmente ou automaticamente conexões que apresentem erros.
O quinto passo para o fluxo de projeto genérico de SDRs é a geração de bitstreams.
Um bitstream total é o resultado de uma síntese física para FPGA e serve para inicializar o sistema.
Bitstream totais são gerados a partir de a ferramenta BitGen da Xilinx.
Bitstreams parciais são utilizados para atualizar um módulo de hardware numa área específica do FPGA.
A geração de bitstreams parciais é um processo específico até mesmo para dispositivos de uma mesma família de um mesmo fabricante.
Com freqüência, apenas o próprio fabricante cria ferramentas para a geração de bitstreams parciais, pois para efetuar este passo é necessário conhecer em profundidade a organização do bitstream e sua relação com a arquitetura de reconfiguração do dispositivo.
Como os fabricantes não têm o interesse de divulgar detalhes sobre estas arquiteturas, apenas eles possuem informações suficientes para prover ferramentas capazes de configurar parcialmente os seus dispositivos.
Outro motivo que inibe os fabricantes de dispositivos reconfiguráveis de fornecer mais informações de suas arquiteturas é que seja feita engenharia reversa de algum projeto, podendo assim colocar em risco a propriedade intelectual de produtos dos clientes.
Duas situações necessitam que um fluxo de projeto para SDR seja repetido.
A primeira é para gerar outro módulo de hardware para uma mesma área reconfigurável.
A segunda é para posicionar um mesmo módulo de hardware em outras áreas reconfiguráveis.
É possível evitar a segunda situação se o mesmo bitstream puder ser posicionado em diferentes áreas reconfiguráveis.
Este procedimento é chamado de realocação e permite que um módulo originalmente sintetizado para uma área possa ser movido para outra, sem re-síntese.
Realocação pode ser útil em pelo menos quatro diferentes situações:
Quando existem muitas áreas reconfiguráveis em a qual pode- se posicionar um módulo;
Quando é difícil restringir um módulo a uma área específica;
Quando um módulo possui restrições temporais difíceis de serem alcançadas;
Quando dois módulos que se comunicam freqüentemente ou possuem uma grande quantidade de dados a ser transferida se encontram distantes.
Além disso, a realocação de módulos também reduz os requisitos de memória para armazenar bitstreams parciais, diminuindo o custo do sistema.
Segundo Dyer e Wirz, quatro fluxos para geração de SDRs podem ser utilizados levando em consideração a biblioteca de manipulação de bitstreams JBits:
Fluxo 1: Desenvolver todos os módulos com ferramentas de implementação padrão3 e extrair os bitstreams parciais manualmente a partir de os bitstream totais.
Fluxo 2: Desenvolver todos os módulos com JBits.
Fluxo 3: Desenvolver o bitstream total com ferramentas de implementação padrão e aplicar posteriores modificações ao roteamento com JBits.
Fluxo 4: Desenvolver todos os módulos com ferramentas de implementação padrão e utilizar JBits para conectar os módulos.
JBits é um conjunto de classes Java que fornece uma API para manipular o arquivo de configuração da família Virtex, tendo sido originalmente criado para suportar reconfiguração dinâmica.
Com este conjunto de classes é possível realizar modificações num circuito sem a necessidade de se refazer o posicionamento e roteamento com as ferramentas padrão.
O JBits pode ser utilizado como uma ferramenta autônoma ou como base para produzir outras ferramentas, incluindo aplicações de CAD tradicionais de posicionamento e roteamento.
Pode- se citar como exemplos de classes JBits a leitura e escrita de valores de componentes internos como LUTs, CLBs, BRAMs e IOBs, o cálculo de CRC de um bitstream e a geração de bitstreams parciais ou totais com as modificações efetuadas.
As próximas Seções apresentam os quatro fluxos propostos por Dyer e Wirz.
Sem utilizar JBits, a reconfiguração parcial consiste na manipulação manual de bitstreams.
Os bitstreams totais são gerados por ferramentas de síntese e implementação padrão.
De estes bitstreams, módulos são extraídos copiando apenas os frames destes num novo bitstream parcial.
Os frames correspondentes do FPGA são substituídos por os novos do bitstream parcial através de reconfiguração dinâmica.
Uma restrição inerente a este fluxo é que o roteamento entre o módulo reconfigurável e o restante do sistema não é feito automaticamente.
Isto requer que o módulo seja conectado ao restante do sistema através de macros, conforme apresentado na Seção 3.2.2, assegurando que cada módulo reconfigurável utilize os mesmos recursos de roteamento para as conexões.
Ferramentas do próprio fabricante, como MAP, Par e NGDBuild.
Se todos os módulos forem desenvolvidos com JBits, é possível facilmente utilizar a reconfiguração dinâmica neste projeto.
A qualquer momento o programa pode escrever modificações no projeto como um bitstream parcial e reconfigurar o dispositivo.
JBits possui um roteador automático, o qual pode refazer o roteamento com novos módulos inseridos no sistema.
Uma restrição deste fluxo é que ele é aplicável apenas a projetos de pequeno porte, pois a ferramenta de roteamento é limitada, não havendo outras ferramentas para implementar máquinas de estado ou outros modelos de construção.
Um projeto inicial é criado com ferramentas de síntese e implementação padrão, configurando inicialmente o FPGA.
A partir de isso todas as modificações subseqüentes são aplicadas com JBits.
As modificações não são capturadas de outro bitstream, mas criadas por o JBits.
Este fluxo é apropriado para projetos que necessitam de poucas modificações como alteração de parâmetros de um algoritmo ou mudança na conectividade de fios.
Uma dificuldade inerente a este fluxo é desenvolver o circuito inicial de forma que o JBits consiga encontrar os recursos específicos novamente.
Por este motivo o projeto inicial necessita de um floorplanning que contenha além de o posicionamento de cada módulo, o posicionamento das LUTs que são origem ou destino das conexões que serão alteradas.
Outra restrição é quanto a temporização de sinais.
A ferramenta de implementação utiliza um algoritmo baseado em atrasos para efetuar o roteamento.
Se estas conexões são removidas por o JBits a temporização não é mais garantida, a menos que o programa verifique explicitamente os atrasos das novas rotas.
Este fluxo é semelhante ao Fluxo 1, com a diferença que o JBits é utilizado para extrair os módulos de bitstreams totais e unificar com outros bitstream para construir um novo bitstream parcial.
Existem duas vantagens deste fluxo sobre o Fluxo 1: O JBits não fica restrito a extrair frames, podendo este ler CLBs com todos os seus recursos e escrever como um bitstream parcial para o dispositivo;
Um módulo pode ser conectado à interface através do roteador do JBits.
Este fluxo permite utilizar dois métodos diferentes para realizar a reconfiguração dinâmica.
O primeiro, apresentado na Figura 35, utiliza macros na interface do módulo reconfigurável com o restante do sistema.
O segundo, apresentado na Figura 36, utiliza o roteador do JBits para fazer a interconexão entre o módulo reconfigurável e o restante do sistema.
Uma restrição inerente a este segundo método é, assim como o Fluxo 3, que ao utilizar o roteador do JBits a temporização da interface entre o módulo reconfigurável e o restante do sistema não é garantida.
Em contraponto, o primeiro método possui a desvantagem de necessitar a edição manual da macro para implementação da interface.
De entre os quatro fluxos apresentados por Dyer e Wirz, os dois métodos do Fluxo 4 foram utilizados para implementar o sistema apresentado na Seção 2.3.1.1.
O método descrito na Figura 35 foi chamado de roteamento estático, enquanto o método descrito na Figura 36 foi chamado de roteamento automático.
As Seções 3.3.5.1 a 3.3.5.3 apresentam os passos utilizados por o Fluxo 4 ressaltando quando um passo é específico para um determinado método.
Este passo é equivalente ao descrito na Seção 3.2.3, utilizando- se a ferramenta Floorplanner da Xilinx para fazer restrições de área de módulos e componentes.
Para que seja possível fazer a restrição de posicionamento de módulos é necessário que seja mantida a hierarquia do projeto, sendo esta uma opção que deve ser habilitada na ferramenta de síntese.
O Leon, a interface e o coprocessador tiveram a sua área restringida conforme apresentado na Figura 26 da página 34.
Conforme já mencionado, a restrição de posicionamento não necessariamente restringe as linhas de roteamento.
Dyer e Wirz denominaram as linhas cruzando a área reconfigurável como &quot;linhas perturbantes».
As soluções de roteamento manual ou automático foram descartadas, devido a o tempo necessário ao usuário realizar um roteamento manual correto e às limitações da ferramenta JBits, respectivamente.
A solução adotada no fluxo é denominada &quot;roteamento guiado», conforme ilustra a Figura de uma macro de passagem, denominada &quot;CLB macro simples «e apresentada na Figura 38A.
A &quot;CLB macro simples «nada mais é que todas as LUTs de uma CLB configuradas com a função identidade.
Este componente pode ser restringido a uma posição específica a partir de restrições no arquivo UCF ou por o Floorplanner.
Para decidir onde posicionar a CLB macro simples ainda é necessário utilizar o FPGA Editor para capturar as coordenadas de onde este componente pode ser posicionado de forma a evitar que o roteamento invada um módulo.
A vantagem deste método é que isto só deve ser feito uma única vez e não a cada nova implementação como os métodos de roteamento manual e roteamento automático.
A Figura 26 da página 34 apresenta onde as CLBs macro simples foram posicionadas no sistema de Dyer.
A macro denominada &quot;CLB macro dupla», ilustrada na Figura 38 B, é utilizada para fixar a interface do módulo reconfigurável com o restante do sistema, conforme apresentado na Seção coprocessador reconfigurável e o Leon.
Elas são formadas por duas CLBs interconectadas, sendo cada uma programada também como passagem de dados.
A CLB macro dupla permite comunicar quatro bits e possui uma rota fixa entre duas CLBs.
Para gerar um bitstream parcial por o método de roteamento automático, o usuário pode escrever um programa em Java utilizando a API JBits, executando basicamente os seguintes passos:
Abrir o bitstream total contendo o módulo origem;
Abrir o bitstream total contendo o módulo destino;
Habilitar o cálculo de CRC do bitstream destino;
Informar que nenhum frame foi modificado do bitstream destino;
Encontrar e desconectar os fios que conectam o módulo reconfigurável ao módulo fixo no bitstream destino;
Armazenar os pontos de interface dos fios desroteados no módulo fixo;
Copiar o módulo origem;
Colar o módulo origem no bitstream destino;
Encontrar os pontos de interface do novo módulo reconfigurável no bitstream destino;
Criar fios para conectar os pontos de interface do módulo origem ao módulo destino; (
xi) rotear os fios criados, conectando os pontos de interface do módulo reconfigurável aos respectivos pontos de interface do módulo fixo; (
xii) calcular o CRC do bitstream destino; (
xiii) salvar o bitstream destino como um bitstream parcial.
A Tabela 10 apresenta algumas funções do JBits a serem utilizadas no processo de implementação de um programa em Java/ JBits que permite criar bitstreams parciais por o método de roteamento automático.
O fluxo de projeto adotado em[ PAL02b] foi implementado para permitir a reconfiguração parcial de módulos de hardware e busca minimizar a complexidade da interface de comunicação dos módulos do sistema.
Tenta- se reduzir a complexidade da interface de comunicação porque durante o desenvolvimento do trabalho as ferramentas disponíveis não possuíam as funcionalidades para reconfiguração parcial e operações com macros.
Por este motivo, era necessário utilizar a ferramenta FPGA Editor para verificar manualmente se os diferentes projetos utilizam a mesma trilha desde o módulo origem até o módulo destino.
Este processo dificulta a criação de SDRs, pois não há como salvar o roteamento efetuado para um projeto e reaplicar- lo após uma nova síntese.
A forma encontrada para criar SDRs com este fluxo foi utilizar tristates nas entradas e saídas dos módulos reconfiguráveis.
Isto se deve ao fato que as trilhas de roteamento com tristates apresentam um roteamento fixo entre as CLBs vizinhas em dispositivos Virtex.
As trilhas de roteamento com tristates dos dispositivos Virtex permitem construir um barramento fixo entre os diferentes projetos, assim descartando a necessidade de ter que verificar se o barramento inteiro foi roteado da mesma forma em todos os projetos.
No entanto, o problema de rotear fios manualmente persiste na conexão entre o barramento e o módulo reconfigurável, conforme ilustrado na Figura 27 (pág. 35).
Duas camadas de tristates entre o barramento e o módulo reconfigurável são necessárias.
Isto se deve ao fato que um tristate pertence a uma CLB, a qual possui LUTs, flip-flops e roteamento.
Caso apenas uma camada de tristate fosse utilizada, como na Figura 39, haveria sobreposição da área de um módulo sobre a lógica do barramento, assim interrompendo o funcionamento do sistema.
As seis subseções subseqüentes apresentam os passos que devem ser executados para a construção de um SDR segundo o fluxo proposto por Palma.
O módulo Receive é responsável por receber serialmente dados enviados por módulos Send.
Para isso ele sempre captura os primeiros 8 bits recebidos por o sinal dataIn.
Caso o endereço recebido seja igual ao endereço do seu módulo (address), os 32 bits restantes serão recebidos, caso contrário serão descartados.
Após o completo recebimento, o sinal disp é ativado informando ao módulo do usuário a chegada de dados por o sinal word_ out..
Em esta etapa é necessário instanciar o barramento serial de Palma no arquivo top do projeto e tantos módulos quantos forem as áreas reconfiguráveis.
Cada área reconfigurável no FPGA é denominada de slot.
Todos os slots devem ter conexões ao barramento.
Esta restrição ocorre por duas razões:
A ferramenta de síntese suprime os tristates não conectados ao barramento;
Não se deve deixar o sinal de request flutuante, pois transições espúrias podem comprometer a operação de todo o sistema.
A política adotada por Palma foi construir módulos dummy, sem função lógica, para serem conectados aos slots sem módulos reconfiguráveis.
Em esta etapa deve- se fazer a restrição dos módulos do sistema, conforme apresentado na Seção 3.2.3.
Uma vez feita as restrições de posicionamento através da interface gráfica da ferramenta Floorplanner para um projeto top, é possível copiar as linhas do arquivo UCF que fazem referência aos módulos e aplicar a todos os outros projetos top.
Isto é factível porque todos os módulos devem ocupar uma área específica do sistema para que uma posterior reconfiguração possa ocorrer.
Esta é a fase que consome mais tempo, e exige um maior esforço do projetista.
Neste passo deve- se garantir que a interconexão entre os módulos e o barramento seja idêntica em todos os projetos.
Lembrar que havendo, por exemplo, dois módulos reconfiguráveis, são gerados dois projetos totais, denominados projeto 1 e projeto 2, cada um com um dado módulo reconfigurável em todos os slots.
Por exemplo, o fio dataIn do projeto 1 que interliga o primeiro slot do barramento ao módulo deve possuir as mesma conexões efetuadas por o fio dataIn que interliga o primeiro slot do barramento ao módulo no projeto 2.
A Figura 41 apresenta à direita a interface entre o primeiro slot e o barramento.
A o centro da Figura 41 o caminho percorrido por o sinal dataIn é ressaltado, desde sua origem até o seu destino.
À esquerda da Figura 41 é feito um zoom sobre o destino do sinal dataIn, permitindo visualizar diversos outros caminhos que poderiam ter sido tomados por o sinal.
Caso exista diferença nas conexões da interface do projeto 1 em relação a o projeto 2 devese desconectar o fio em questão do projeto 2 e reproduzir exatamente as mesmas conexões feitas por o respectivo fio no projeto 1.
Uma vez garantido o idêntico roteamento das interfaces de todos os projetos é possível utilizar a ferramenta BitGen para gerar os bitstreams totais de todos os projetos pertencentes ao SDR.
Nenhum parâmetro é necessário à ferramenta BitGen para a geração do arquivo total, apenas o nome do projeto com extensão NCD.
Utilizando a ferramenta CoreUnifier é possível criar os bitstreams parciais dos módulos que transformarão o sistema com uma nova configuração.
O bitstream total que será utilizado para inicializar o SDR deverá ser o primeiro bitstream aberto no CoreUnifier, o qual é denominado bitstream base.
A seguir devem ser abertos os outros bitstreams que possuem algum módulo diferente do inicial, para que estes modifiquem a configuração do sistema.
A seleção do módulo de um bitstream secundário deve ser efetuada por a interface gráfica de forma a englobar toda a lógica do módulo, se estendendo até a camada de tristates do mesmo.
A ferramenta gerará um bitstream parcial que possui a parte inferior (barramento) originada do bitstream base e a parte superior (módulo) originada da seleção do bitstream secundário.
O módulo mestre é responsável por prover entrada e saída de dados do sistema.
As entradas do sistema são feitas a partir de a reconfiguração de componentes LUTRAM internas ao módulo mestre, configuradas a partir de a ferramenta BITProgrammer ou Circuit Customizer.
Estas ferramentas permitem fazer leitura e escrita de valores a partir de reconfiguração parcial.
Também é responsabilidade do módulo mestre enviar a resposta da operação dos módulos para o display do FPGA.
É função do árbitro do sistema evitar que haja escritas simultâneas no barramento, decidindo qual módulo pode colocar dados no meio compartilhado num determinado instante de tempo.
Em este sistema é utilizado um árbitro com prioridade rotativa, onde a cada ciclo de relógio um módulo do sistema possui prioridade caso exista mais de um pedido de acesso simultâneo.
Os tristates de interface entre os módulos reconfiguráveis e o barramento são os componentes isoladores no fluxo de projeto de Palma.
A interface dos módulos com o barramento é feito por os quatro sinais descritos em 3.4.1.1 e os sinais de controle clock e reset.
Os módulos escravo1 e escravo2 podem ser configurados como somadores e subtratores.
Estes módulos recebem dois operandos de 32 bits do módulo mestre e, depois de realizarem uma dada função, retornam o resultado novamente para o módulo mestre.
O Anexo I apresenta a descrição VHDL do projeto top da calculadora reconfigurável.
Após a síntese do top é possível utilizar o Floorplanner para restringir o posicionamento dos módulos e dos tristates que conectam cada módulo ao barramento.
Sugere- se utilizar para cada módulo o menor número de colunas para que a reconfiguração leve o menor tempo possível.
Outra restrição que deve ser feita é quanto a os tristates.
Cada módulo adicionado ao sistema demanda 12 tristates (6 do lado do barramento e 6 do lado do módulo).
A o posicionar estes tristates, também com a ferramenta Floorplanner, recomenda- se fixar os tristates que ligam o mesmo fio numa mesma coluna, de forma que o barramento seja conectado ao módulo por o menor caminho possível, gerando um menor atraso.
Os posicionamentos efetuados tanto dos módulos quanto de tristates Barramento Barramento Subtrator2 Subtrator2 Subtrator1 Mestre parcial União final Subtrator1 Barramento parcial Barramento Subtrator1 Mestre Somador2 Somador1 Mestre devem ser replicados para cada projeto pertencente ao sistema.
No caso de a calculadora reconfigurável existem dois projetos.
Um com dois módulos somadores e outro com dois módulos subtratores, conforme pode ser observado na Figura 42.
Dois bitstreams totais geram um novo total modificando apenas os módulos a serem substituídos.
Posterior geração dos bitstreams parciais destes módulos.
De posse dos bitstreams totais com dois somadores e com dois subtratores, manualmente roteados, verificou- se o correto funcionamento destes em FPGA.
Observado o correto funcionamento, utilizou- se a ferramenta CoreUnifier para a construção dos bitstreams parciais.
Para transformar um sistema inicialmente configurado com dois módulos somadores para módulos subtratores, deve- se abrir primeiramente como bitstream base o bitstream do projeto somador e posteriormente o projeto do subtrator.
Seleciona- se a área correspondente ao módulo subtrator1 e gera- se o bitstream parcial do mesmo.
A seguir utiliza- se o mesmo processo para gerar o módulo subtrator2.
O teste do sistema no FPGA é feito configurando inicialmente o bitstream total que contém os módulos somadores e a seguir configurando o FPGA com os bitstreams parciais gerados.
Sem interromper a execução do sistema os módulos subtratores entram em funcionamento.
O fluxo de Projeto Modular foi criado para que equipes distintas trabalhem de forma distribuída num mesmo projeto, onde cada equipe produz um ou mais módulos e um projetista &quot;centralizador «instancia os módulos de cada equipe num único sistema.
As vantagens desta abordagem são que o fluxo não necessita de roteamento manual e que cada equipe pode testar e validar os seus módulos sem que os módulos de outras equipes afetem os seus.
Desta forma cada equipe gera um bitstream parcial do seu módulo e ao final do fluxo completo do Projeto Modular têm- se os arquivos de inicialização do sistema (bitstream total).
Apesar de utilizado para sistemas reconfiguráveis, originalmente o fluxo de Projeto Modular não foi concebido para esta finalidade.
Antes de executar o fluxo de Projeto Modular em si, abordado na Seção 3.5.2, alguns passos devem ser efetuados para que os arquivos de entrada do fluxo sejam corretamente criados e posicionados numa árvore de diretórios.
Estes passos de preparação para execução do fluxo de Projeto Modular são apresentados na Seção 3.5.1.
As seis subseções subseqüentes apresentam os passos que devem ser efetuados antes da execução do fluxo de Projeto Modular.
Esta etapa pressupõe que o sistema, sem características reconfiguráveis, já foi prototipado pelo menos uma vez, conforme abordado na Seção 3.2.1, e que o sistema já está dividido em módulos.
Em esta etapa são adicionados os componentes isoladores, conforme abordado na Seção componentes são as LUTs e os DCMs.
DCMs são utilizados para evitar o escorregamento de relógio.
LUTs são utilizadas para a geração de constantes lógicas.
O motivo desta geração manual de constantes lógicas com LUTs é devido a estas poderem ter a sua posição restringida.
Quando não são feitas restrições de posicionamento, pode ocorrer de constantes serem buscadas de um componente que se encontra em outra área reconfigurável, assim causando uma desconexão do fio no momento da reconfiguração.
A Bus Macro, ilustrada na Figura 43, é o componente proposto por a Xilinx para interconectar módulos reconfiguráveis ao restante do sistema.
A Bus Macro é formada por oito tristates e disponibiliza quatro fios de um bit para a comunicação do sistema com o módulo reconfigurável ou vice-versa.
A Bus Macro possui quatro saídas (O) bidirecionais.
Cada sinal de saída pode estar ligado na entrada esquerda (Li) ou na entrada direita (Ri).
Desta forma apenas o toggle esquerdo (LT) ou o toggle direito (RT) de um sinal de saída podem estar ativados simultaneamente de forma a não causar um curto circuito.
É importante ressaltar que os tristates são ativos em nível lógico baixo e que para desativar uma determinada saída da Bus Macro basta colocar LT e RT em nível lógico alto.
A criação de arquivos de restrições do usuário, abordado na Seção 3.2.3, pode ser feita manualmente, com a ferramenta Floorplanner ou com a ferramenta PACE.
Estas ferramentas restringem a posição de módulos, macros e pinos de E/ S através das linhas:
Este passo deve ser executado para todos os módulos, macros e pinos de E/ S do projeto.
Caso um mesmo módulo seja utilizado em mais de uma área reconfigurável é necessário replicar o código fonte VHDL para cada área reconfigurável, gerando um VHDL para cada combinação.
Isto é necessário porque o Projeto Modular utiliza o nome do arquivo de mais alta hierarquia do módulo para construir um diretório específico para cada módulo de cada área reconfigurável.
Para facilitar a tarefa de síntese de cada um dos módulos do sistema é aconselhável escrever scripts que executam a ferramenta de síntese lógica para cada um dos arquivos VHDL de O Application Note 290 da Xilinx sugere uma determinada árvore de diretórios para a organização de um SDR implementado a partir de o fluxo de Projeto Modular.
Para que o fluxo seja executado com sucesso é recomendável criar os diretórios conforme o modelo sugerido e inserir os arquivos de entrada nesses diretórios.
O fluxo de Projeto Modular nada mais é que a aplicação de uma série de ferramentas da Xilinx segundo uma seqüência e parâmetros que permitem modularizar o sistema, validar individualmente cada um dos módulos e finalmente unir todos os módulos.
O fluxo de Projeto Modular pode ser dividido em três fases.
A fase de orçamento inicial determina qual é a estrutura do arquivo de nível hierárquico mais alto do projeto.
Em a fase de implementação do módulo ativo cada módulo é sintetizado e implementado separadamente.
Em a fase de montagem final são gerados os projetos com os módulos já implementados, utilizados para inicializar o sistema.
A Figura 44 apresenta as fases do Projeto Modular.
Projeto Prototipável A fase de orçamento inicial tem como principal objetivo montar a estrutura do projeto.
Em esta fase é feita a definição de quais pinos serão utilizados e onde estão posicionados os módulos e componentes inseridos no arquivo de mais alto nível do projeto.
A Figura 45 apresenta o fluxo de execução da fase de orçamento inicial.
Inicialmente, os fontes HDL do projeto são sintetizados, gerando- se os arquivos de descrição lógica do circuito (EDIF).
A seguir o NGDBuild posiciona os módulos do projeto como caixas preta, e fixa os componentes inseridos na Seção 3.5.1.2.
As entradas desta ferramenta são o Macro pré-roteada e o arquivo UCF de restrições do usuário.
Arquivos NGD e NGO são gerados, porém apenas este último será utilizado como entrada da próxima fase.
Em a fase de implementação do módulo ativo são feitos o mapeamento, posicionamento e roteamento de cada um dos módulos do sistema, tanto fixos quanto reconfiguráveis.
A entrada desta arquivos são utilizados por o NGDBuild para gerar o arquivo NGD que possui a descrição lógica do módulo em função de primitivas da Xilinx.
O arquivo NGD do módulo é mapeado por a ferramenta MAP para um arquivo NCD, não roteado, que possui a descrição do módulo em função de os recursos específicos do dispositivo.
A ferramenta Par posiciona e roteia os recursos do módulo, gerando um novo arquivo com extensão NCD.
O arquivo NCD é utilizado como entrada para a ferramenta BitGen, que gera o bitstream parcial do módulo, e para a ferramenta PIMCreate, que copia e renomeia arquivos de entrada de acordo com as necessidades do Projeto Modular.
A Figura 46 ilustra o fluxo executado nesta fase.
Em a fase de montagem final todos os módulos implementados fisicamente que fazem parte do arquivo de mais alta hierarquia do projeto são agregados ao mesmo.
O posicionamento, mapeamento e roteamento são feitos de maneira unificada, anexando todos os módulos num único projeto.
O bitstream total do projeto final é criado nesta fase, pronto para ser prototipado.
O fluxo da fase de montagem final é ilustrado na Figura 47.
A primeira ferramenta utilizada nesta fase é o NGDBuild.
Esta ferramenta utiliza como entrada o arquivo de restrições do usuário (UCF), o arquivo da Bus Macro (NMC), o arquivo de mais alta hierarquia do projeto (EDIF) e todo o conjunto de arquivos Pim gerados na fase anterior.
As ferramentas MAP e Par são utilizadas para mapear e posicionar os módulos no arquivo de mais alta hierarquia do projeto e fazer o roteamento entre os módulos já roteados.
Por fim a ferramenta BitGen é utilizada para gerar o bitstream total que permite inicializar o FPGA.
Arquivo O estudo de caso apresentado nesta Seção já foi abordado na dissertação de mestrado de Brião e aqui é apresentado por ser um sistema simples e que permite focar no fluxo de Projeto Modular em si.
O estudo de caso consiste numa calculadora que pode possuir dois módulos reconfiguráveis, um de adição e um de subtração.
O sistema também possui um módulo não reconfigurável responsável por efetuar E/ S. A Figura 48 apresenta um diagrama de blocos do sistema.
O módulo E/ S é responsável por fazer a interface entre a entrada e a saída do FPGA com os módulos que fazem o cálculo dos valores requisitados.
As entradas deste módulo são chaves que representam os operandos dos módulos que efetuam o cálculo e um botão que atualiza o display de saída.
O primeiro módulo reconfigurável executa a soma ou a subtração de dois operandos de dois bits.
O segundo módulo reconfigurável executa a soma ou a subtração de dois operandos de três bits e retorna o resultado para o módulo E/ S. As próximas Seções seguem o fluxo de Projeto Modular da mesma forma como ele foi abordado na Seção 3.5.1 e 3.5.2, partindo desde a preparação da execução do fluxo até a fase de montagem final do mesmo.
O sistema da calculadora reconfigurável possui dois projetos denominados top e top1.
O projeto top instancia dois módulos de adição e o projeto top1 instancia dois módulos de subtração.
O Anexo II apresenta o código VHDL do projeto top, sem características reconfiguráveis.
Para tornar o projeto top, apresentado no Anexo II, um projeto reconfigurável, é necessário modificar apenas o arquivo top.
Vhd, inserindo os componentes apresentados na Seção 3.2.2.
O Anexo III apresenta o arquivo top.
Vhd com os componentes que permitem a reconfiguração do sistema já inseridos.
As áreas reconfiguráveis e os componentes inseridos na etapa anterior devem ter seus posicionamentos restringidos para que os componentes isoladores ocupem sempre as mesmas posições e para que os módulos não invadam as áreas de outros módulos.
Estas restrições de posicionamento são feitas no arquivo UCF, que pode ser editado manualmente ou por a ferramenta Floorplanner.
A Figura 49 apresenta o arquivo UCF para o estudo de caso da calculadora reconfigurável.
A Figura 50 apresenta a representação gráfica do dispositivo com as restrições de posicionamento inseridas no arquivo UCF apresentado na Figura 49.
Uma vez feito o projeto top, fica fácil replicar os passos para o projeto top1.
O arquivo de mais alta hierarquia do projeto top1 é o mesmo que o projeto top, com a única diferença de instanciar não os módulos adder, mas sim os módulos sub.
O arquivo de restrições do usuário é exatamente o mesmo para os projeto top e top1.
Em esta etapa deve- se colocar todos os arquivos que serão utilizados na execução do fluxo do Projeto Modular nos diretórios recomendados por a Xilinx.
Para este estudo de caso os diretórios e os arquivos devem estar organizados conforme apresentado na Figura 52.
Antes da fase de orçamento inicial alguns parâmetros devem ser executados para que as ferramentas da Xilinx se configurem para o Projeto Modular.
Estes parâmetros são apresentados nas linhas de 1 a 3 do script de execução do Projeto Modular (Figura 53), que deve ser gerado por o projetista.
As linhas de 5 a 7 e de 9 a 11 da Figura 53 apresentam, respectivamente, a execução da fase de orçamento inicial dos dois projetos de mais alta hierarquia do SDR, denominados top e top1.
Em a fase de orçamento inicial apenas a ferramenta NGDBuild é executada para gerar a estrutura do projeto.
Em esta fase os módulos reconfiguráveis do sistema são implementados, sendo gerado um bitstream parcial para cada módulo.
A Figura 54 apresenta os quatros trechos do script que representam a execução da fase de implementação do módulo ativo para cada um dos módulos do sistema.
Cada uma das ferramentas executadas são explicadas na Seção 3.5.2.2.
O fluxo de SDR proposto por Horta possui como entrada módulos de hardware descritos a partir de bitstreams totais ou parciais, podendo estes terem sido implementados para qualquer dispositivo da família Virtex I da Xilinx.
As vantagens deste fluxo são:
Flexibilidade para realocar módulos de hardware em qualquer FPGA da família Virtex I;
Redução de tempo de projeto, pois o módulo não é re-sintetizado;
Propriedade intelectual do módulo garantida;
Características de temporização do módulo fixo.
Um ponto negativo desta abordagem é não poder modificar a interface nativa de comunicação do módulo, necessitando a inserção de lógica adicional (wrapper) para tornar o módulo compatível com uma interface de comunicação específica.
Um requisito apontado por Horta para que o fluxo funcione corretamente é que a interface de comunicação entre o módulo reconfigurável e a lógica estática esteja bem definida.
Essas interfaces foram chamadas de Gasket em e redefinidas para Bus Macros em.
Para a geração de bitstreams parciais segundo este fluxo, pode- se utilizar a ferramenta PARBIT Slice:
O usuário informa quais colunas de CLBs de um bitstream total de entrada deve ser construído um bitstream parcial.
A localização do bitstream parcial é a mesma que a posição de origem no bitstream total.
Block: O usuário informa qual área de um bitstream original deve ser copiada para qual posição de um bitstream alvo.
Este modo de operação permite que a área selecionada do bitstream original seja de um dispositivo diferente que o bitstream alvo.
Bip (Bitstream Intellectual Property):
O usuário informa o bitstream total que possui o módulo a ser extraído e o arquivo top VHDL que instancia o módulo.
Devem ser inseridos no top, na forma de comentário, o número de linhas e colunas de CLBs ocupados por o módulo e a coordenada superior esquerda do módulo.
O PARBIT funciona por linha de comando e não utiliza o JBits para acessar o bitstream, fazendo manipulação direta do arquivo de configuração.
Huebner, em, aponta que a ferramenta de roteamento algumas vezes não respeita as restrições feitas por o projetista e cruza o limite entre as áreas reconfiguráveis na implementação de Bus Macros com tristates.
A Figura 56 ilustra este problema.
O principal motivo para a ocorrência de erros é o fato da linha de roteamento do sinal de saída ser fisicamente a mesma em ambos os lados da macro.
O retângulo preto é um componente do módulo esquerdo.
A ferramenta de roteamento conectou o sinal indicado utilizando um fio conectado ao lado direito, por o fato do sinal ser equivalente em ambos os lados.
Devido a os problemas supracitados das Bus Macros, Huebner desenvolveu um barramento seguindo a idéia de comunicação em SDRs proposta por Palma (Seção 3.4), onde os elementos que comunicam as diversas áreas reconfiguráveis ficam na parte inferior do FPGA.
A vantagem desta abordagem é a possibilidade de isolar a computação na parte superior do FPGA da comunicação, fixada na parte inferior.
Desta forma é possível reconfigurar a computação de um módulo sem interromper a comunicação dos outros que estão em execução no sistema.
Isto é factível somente porque a reconfiguração das famílias de dispositivos Virtex da Xilinx são glitchless.
A princípio, Huebner tentou instanciar múltiplas macros iguais lado a lado de forma a implementar um barramento.
Devido a a arquitetura da Virtex-II apresentar mistura de colunas de CLBs com BRAMs e blocos multiplicadores, problemas de roteamento foram detectados.
Por este motivo as macros que seriam instanciadas foram todas roteadas manualmente, construindo assim dois barramentos unidirecionais para a comunicação de módulos reconfiguráveis.
A Figura 57 ilustra o diagrama de esquemático dos barramentos de leitura e escrita, enquanto a Figura 58 apresenta a planta baixa de um destes barramentos.
O motivo de Huebner ter desenvolvido um barramento unidirecional é que um barramento para a escrita possui uma arquitetura diferente de um barramento de leitura.
Quando um módulo deseja ler dados de um barramento ele deve receber os dados se os mesmos forem destinados a ele.
No caso de escrita um árbitro deve selecionar qual o módulo pode escrever no barramento para que não ocorra conflito de acesso ao mesmo.
A Figura 59 apresenta como as CLBs dos barramentos de leitura e escrita estão configuradas.
As CLBs do barramento de leitura estão configuradas como somente passagem de dados, enquanto as CLBs do barramento de escrita estão configuradas como multiplexadores.
Cada barramento tem largura de 8 bits e o atraso, segundo Huebner, é de 5,5 ns entre o módulo mais à esquerda do FPGA e o árbitro que está posicionado mais à direita.
O problema desta arquitetura de barramentos é o procedimento de arbitragem, Daisy--chain, onde a prioridade de acesso ao barramento é fixa.
Huebner, assim como Dyer, utiliza o JBits para gerar bitstreams parciais, mas a partir de um fluxo ainda diferente dos propostos por Dyer.
Em o fluxo de Huebner todos os módulos são desenvolvidos com ferramentas de implementação padrão e os bitstreams parciais são extraídos com o JBits.
Isto é possível marcando os frames de um bitstream total como modificados e gerando um bitstream parcial deste.
A Figura 60 apresenta o trecho de código em linguagem Java utilizando a API JBits 3 responsável por gerar bitstreams parciais para dispositivos Virtex-II.
A Tabela 11 apresenta um resumo dos fluxos estudados neste Capítulo, apontando as principais características de cada um.
A segunda coluna da tabela refere- se à utilização ou não de macros.
Observa- se que, exceto os fluxos propostos por Dyer, sempre há a utilização de macros para fixar os pinos de interface dos módulos reconfiguráveis.
Uma alternativa à utilização de macros é empregar o roteador do JBits, porém este é extremamente limitado em suas funcionalidades.
A terceira coluna refere- se ao método de síntese dos módulos reconfiguráveis.
O conjunto de classes JBits não permite gerar módulos reconfiguráveis complexos, devido a o reduzido número de recursos oferecidos por ela.
O fluxo de Projeto Modular utiliza parâmetros de síntese avançados, que com freqüência dificultam a síntese do projeto em comparação à síntese simples.
A síntese simples aplica os parâmetros padrão, não fazendo outras restrições ao projeto que possam dificultar o processo de síntese.
A quarta e a quinta coluna apresentam a ferramenta que gera o bitstream parcial e o método de geração deste bitstream.
De entre os fluxos apresentados, apenas as alternativas propostas por a Xilinx, BitGen e JBits, constroem os bitstreams parciais de forma nativa.
Os demais fluxos utilizam ferramentas próprias, gerando bitstreams parciais através da extração de frames de bitstream totais.
A última coluna apresenta com quais dispositivos um determinado fluxo é compatível.
Em estes fluxos apresentados pode- se perceber que a maioria é compatível apenas com os FPGAs da família Virtex-I, devido a arquitetura desta ser disponibilizada publicamente.
Apenas o fluxo de Projeto Modular e o fluxo de Huebner são compatíveis com FPGAs mais recentes.
Segundo a análise realizada e excluindo o fluxo de Projeto Modular que possui as desvantagens apresentadas, o fluxo de Huebner é o que mais se adeqüa a um fluxo simples, rápido e compatível com dispositivos atuais, no entanto, este ainda possui uma limitação:
Não extrai apenas o módulo reconfigurável do projeto, mas sim frames inteiros onde o módulo está inserido.
O próximo Capítulo apresenta o fluxo de projeto para SDRs proposto por esta dissertação de mestrado, introduzindo um fluxo que supra algumas das restrições presentes nos atuais.
Este Capítulo apresenta a primeira contribuição deste trabalho:
Um fluxo de projeto para SDRs.
Este fluxo tem por objetivo simplificar os procedimentos de síntese para o usuário, utilizando ferramentas padrão.
Os elementos isoladores não são baseados em tristates, reduzindo a propensão a erros observada em fluxos como o Projeto Modular.
Além de a simplicidade e de macros próprias, este fluxo contempla realocação de módulos em duas dimensões.
Projeto inicial não reconfig.
O primeiro passo do fluxo de projeto é definir a estrutura geral do SDR, escolhendo a quantidade de áreas reconfiguráveis que farão parte deste e quais módulos estarão inicialmente configurados nestas áreas reconfiguráveis.
A escolha da quantidade de áreas reconfiguráveis é feita segundo o tamanho dos módulos reconfiguráveis a serem utilizados no sistema, o tamanho do FPGA e a necessidade de utilizar módulos reconfiguráveis em paralelo.
É aconselhável prototipar este projeto usando configuração total, de forma a garantir que as restrições temporais deste sejam atendidas e que o mesmo funcione corretamente.
O motivo para esta prototipação inicial é garantir a operacionabilidade do ponto de partida do SDR, uma vez que serão posteriormente adicionados novos elementos, agregando complexidade ao todo.
A Figura 62 apresenta o diagrama de blocos do projeto inicial, com duas áreas reconfiguráveis e uma área fixa.
O passo seguinte do fluxo corresponde à inserção de macros entre os módulos reconfiguráveis e o restante do projeto, conforme ilustrado na Figura 63.
Estes componentes, conforme explicado na Seção 3.2.2, fixam a posição das entradas e saídas entre cada um dos módulos reconfiguráveis instanciados em diferentes projetos do sistema.
Este fluxo de projeto permite utilizar qualquer uma das macros apresentadas nos fluxos do utilizam tristates e protegem a parte fixa do sistema de receber dados espúrios durante a reconfiguração.
As Seção 4.2.2 e 4.2.3 apresentam, respectivamente, como construir as macros propostas na Seção 4.2.1 e como instanciar- las na linguagem VHDL.
Além de fixar a comunicação dos módulos reconfiguráveis nos diferentes projetos do SDR, uma das macros propostas neste trabalho possui a função de isolar o restante do sistema enquanto um módulo está sendo substituído.
Este isolamento é necessário porque a reconfiguração instantaneamente modifica o módulo, podendo assim ocorrer chaveamentos transitórios em sua saída e por conseqüência interferir no funcionamento do restante do sistema que continua operando.
Este comportamento foi de fato identificado através da utilização de analisador lógico no momento da reconfiguração parcial e dinâmica do sistema.
A Figura 64 apresenta as duas macros propostas neste trabalho para SDRs que possuem a área fixa à esquerda e a área reconfigurável à direita.
A macro LR, apresentada na Figura 64 A, possui apenas a função de fixar a comunicação da área fixa para a área reconfigurável nos diferentes projetos do SDR.
A macro RLC, apresentada na Figura 64 B, possui a função de fixar a comunicação da área reconfigurável para a área fixa, e adicionalmente, permitir à área fixa evitar que haja o envio de dados para si durante a reconfiguração.
Caso a área reconfigurável esteja à esquerda, é possível implementar macros invertidas (RL e LRC) em relação a as apresentadas.
Por o conhecimento do Autor existem três métodos para projetar uma macro destinada a FPGAs Xilinx:
Através da utilização da ferramenta FPGA Editor;
Escrita em linguagem XDL;
Escrita em linguagem HDL.
O primeiro método de implementação é demorado e trabalhoso, mas é exatamente o hardware a ser configurado no FPGA.
O método utiliza a linguagem de descrição da Xilinx (XDL) para descrever de forma textual a macro.
Este método necessita de um conhecimento avançado da arquitetura do dispositivo para de fato obter sucesso no projeto de uma macro, não sendo normalmente indicado para construir macros, mas sim realizar um grande número de pequenas modificações em macros ou projetos, já que é baseado em texto e pode ser rapidamente modificado.
O Anexo V apresenta o projeto de uma porta lógica &quot;E «através da linguagem XDL.
O método utiliza o fluxo de projeto padrão para FPGAs Xilinx descrito na Seção 3.1.
Este método de implementação é rápido e menos suscetível a erros que os outros métodos, mas o hardware gerado pode ser bem diferente do esperado, devido a o processo de posicionamento e roteamento ser não determinístico.
Por este motivo, este método é indicado apenas para macros grandes, realizando- se as eventuais correções de posicionamento e/ ou roteamento através dos métodos ou Devido a a simplicidade das macros propostas e a necessidade de construir- las apenas uma única vez, o método foi utilizado.
Os passos para a construção da macro segundo o método são apresentados no Anexo IV, enquanto a Figura 65 ilustra a macro RLC criada por o FPGA Editor.
A macro LR é semelhante à apresentada na Figura 65, com a diferença de não possuir o sinal ctrl e as saídas (o) estarem posicionadas no lugar das entradas (i) e vice-versa.
Módulo Fixo Módulo Reconfigurável Slices L o7 o6 ctrl7 ctrl6 o5 o4 ctrl5 ctrl4 Legenda:
Slices R sig7 sig6 sig2 sig5 sig4 sig3 sig0 i7 i6 i5 i4 i3 i2 sig1 i1 i0 Programação das LUTs:
A Figura 66 apresenta como a macro RLC, ilustrada na Figura 65, é instanciada na linguagem VHDL.
Esta macro possui 8 bits de entrada de dados, 8 bits de saída (o) e 8 bits que controlam a passagem de dados (ctrl).
Os sinais data_ in, data_ out e control representam, respectivamente, os sinais do módulo reconfigurável com destino à parte fixa do sistema, os sinais oriundos do módulo reconfigurável que já passaram por a macro e os sinais do módulo fixo que controlam a passagem de dados da macro.
É aconselhável que antes de executar uma reconfiguração, o sinal de controle da macro seja desabilitado, para que chaveamentos temporários de data_ in não sejam percebidos em data_ out, permitindo que a parte fixa do SDR continue operando durante o processo de reconfiguração.
Caso seja necessário uma interface entre o módulo fixo e reconfigurável com mais de 8 bits, mais macros devem ser instanciadas, conforme necessário.
A instanciação da macro LR funciona de forma análoga à macro RLC, considerando apenas que a mesma usa sinais com direção de propagação da informação invertida e não possui o sinal de controle (ctrl).
O terceiro passo no fluxo de implementação de SDRs é restringir o posicionamento dos módulos reconfiguráveis e das macros.
Esta restrição pode ser feita por a ferramenta gráfica Floorplanner da Xilinx, que permite estabelecer restrições para definir uma região sobre a superfície de silício do FPGA que deve ser ocupada por os componentes do sistema.
O Floorplanner gera como saída um arquivo de restrições do usuário (User Constraints File UCF) que é utilizado durante as fases de posicionamento e roteamento do projeto.
A Figura 67 apresenta um exemplo de como os módulos reconfiguráveis e as macros podem ser posicionados para que o projeto possa ser posteriormente dinamicamente reconfigurado.
O importante deste posicionamento é que os módulos reconfiguráveis ocupem subconjuntos de colunas de recursos (CLBs) distintos do FPGA, e que as macros estejam verticalmente alinhadas nas interfaces dos módulos reconfiguráveis.
O motivo destas restrições de posicionamento serem implementadas verticalmente é que os dispositivos Xilinx são reconfigurados em colunas.
Uma vez executado os passos de posicionamento e roteamento, é necessário verificar se o roteamento efetuado automaticamente atende os requisitos de um SDR.
Como já mencionado, ao restringir a lógica de um módulo a uma determinada área do FPGA, não obrigatoriamente os fios que interconectam os componentes internos deste módulo permanecerão dentro de os limites definidos por as restrições de posicionamento.
Com freqüência, os fios internos de um módulo invadem a área de outro, conforme ilustrado na Figura 68A.
Caso um ou mais fios cruzem a área pré-definida, estes poderão ficar desconectados após a reconfiguração, podendo ocasionar o não funcionamento do projeto e até mesmo um dano físico no dispositivo.
Por este motivo, deve- se verificar as interfaces dos módulos reconfiguráveis, buscando obter um roteamento como o da Figura 68B.
As interfaces dos módulos reconfiguráveis podem ser verificadas por a ferramenta XDLAnalyzer, proposta nesta dissertação, ou por a ferramenta FPGA Editor.
Ambas alternativas de verificação de roteamento serão tratadas nas Seções 4.4.1 e 4.4.2.
Através da ferramenta FPGA Editor é possível visualizar e manipular a forma como os recursos estão fisicamente alocados no FPGA.
A o se abrir o projeto já roteado nesta ferramenta, deve- se localizar as macros no mesmo.
As macros propostas na Seção 4.2.1 utilizam CLBs de duas colunas adjacentes, sendo uma pertencente a um módulo fixo/ reconfigurável e outra pertencente a um módulo reconfigurável.
A fronteira entre duas colunas de CLBs são demarcadas no FPGA Editor por linhas longas4 (em inglês, long lines) verticais.
Uma vez encontrada uma macro deve- se verificar se algum fio cruza a fronteira ao longo de toda a coluna sem passar por alguma macro.
O sinal de relógio é o único fio que pode cruzar livremente o FPGA sem passar por macros, pois este utiliza uma árvore específica de roteamento.
A Figura 69 apresenta uma macro LR com um sinal de relógio passando livremente por a macro (Clock_ INT) e dois casos típicos de problemas: (
i) um fio de dados que cruza a fronteira e depois retorna para entrar na macro (data_ in) e (ii) um fio de constante posicionado no módulo Linha longa refere- se a um recurso de roteamento que interconecta CLBs distantes.
Existem casos onde não se consegue evitar que um determinado fio não cruze a fronteira.
Quando esse fio é originado de um módulo fixo e invade um módulo reconfigurável, esse fato não representa maiores problemas, contanto que o SDR não utilize realocação e que o projetista verifique para cada projeto diferente se o fio invasor utilizou exatamente as mesmas trilhas do FPGA.
A realocação não pode ser utilizada em SDRs que possuem fios do módulo fixo invadindo a área reconfigurável, porque os módulos construídos em outras áreas reconfiguráveis não possuirão a configuração do fio invasor, e se a reconfiguração fosse executada, o módulo fixo pararia de funcionar, ou mesmo causar danos ao FPGA.
A ferramenta XDLAnalyzer, proposta por o Autor, possui a função de analisar todos os sinais de um projeto, verificando se algum de eles atravessa a fronteira do módulo de origem sem passar por macros.
A partir de isso, pode- se utilizar a ferramenta FPGA Editor para visualizar/ corrigir os sinais com erros de roteamento ou tentar um novo posicionamento sem sequer abrir o FPGA Editor.
O XDLAnalyzer utiliza como entrada o arquivo UCF do projeto, o qual possui as informações das fronteiras dos módulos, e a descrição XDL do projeto, que descreve em formato texto o caminho percorrido para cada sinal, conforme exemplificado nas linhas 82 a 106 da Figura 107 do Anexo V. O arquivo XDL é gerado por a ferramenta XDL da Xilinx após a execução da mesma com a linha de comando XDL ­ncd2xdl arquivo.
Ncd, onde arquivo.
Ncd é o nome do projeto gerado por a ferramenta de síntese física ou modificado por a ferramenta FPGA Editor.
O primeiro passo da ferramenta é converter as coordenadas utilizadas por o UCF para as coordenadas utilizadas por o XDL.
A seguir o XDLAnalyzer percorre o arquivo XDL até encontrar o primeiro sinal (net).
Para cada sinal encontrado, deve- se determinar as coordenadas do primeiro ponto de interconexão (pip) de sua descrição (LIOIR17 $= coluna de E/ S esquerda, linha 17).
A partir de essas coordenadas é possível determinar no arquivo UCF a qual módulo o sinal pertence e verificar se algum dos pips seguintes possuem as coordenadas fora de o módulo origem.
Se isso ocorrer, este sinal é reportado ao usuário.
O procedimento é repetido até o final do arquivo XDL.
A ferramenta BitGen da Xilinx é utilizada para gerar o bitstream total que inicializa o sistema.
O BitGen pode ser executado tanto através do ambiente de desenvolvimento ISE quanto via linha de comando.
Via linha de comando, um bitstream total pode ser gerado por o comando bitgen arquivo.
Ncd, onde arquivo.
Ncd é o nome do arquivo gerado por a ferramenta de síntese física ou modificado por a ferramenta FPGA Editor da Xilinx.
O arquivo.
Bit gerado por o BitGen pode ser utilizado por a ferramenta Impact para configurar o FPGA.
A construção de projetos com novos módulos reconfiguráveis é feita com o reuso do projeto inicial e substituindo- se o fonte HDL específico do módulo reconfigurável.
O arquivo UCF gerado na Seção 4.3 é reutilizado neste passo para fixar o novo módulo reconfigurável exatamente na mesma posição do módulo por o qual está sendo substituído (Figura Em este passo, o projeto deve ser verificado conforme apresentado na Seção 4.4.
Esta verificação pode ser feita com o FPGA Editor ou com o XDLAnalyzer.
Esta Seção apresenta duas ferramentas para extrair módulos reconfiguráveis a partir de bitstreams totais, gerando bitstreams parciais conforme ilustra a Figura 70.
Ambas as ferramentas utilizam o método de extração de frames e são compatíveis com os dispositivos VirtexII e Virtex-II Para o.
Bitstreams parciais podem ser extraídos de projetos totais descritos no formato NCD com a ferramenta BitGen da Xilinx.
Três tipos de colunas podem ser incluídos no bitstream parcial através dos seguintes parâmetros na linha de comando do BitGen:
g PartialMask0:
Colunas de CLB;
g PartialMask1:
Colunas de BRAM;
g PartialMask2:
Colunas de interconexão de BRAM;
A documentação disponível da ferramenta BitGen informa apenas que para selecionar as colunas específicas de um determinado tipo de coluna utiliza- se uma máscara com valores em hexadecimal, mas não informa como gerar esta máscara.
Através de um termo de cooperação de pesquisa assinado com regras de sigilo (Non Disclosure Agreement NDA) entre o GAPH e a Xilinx obteve- se dados para gerar essas máscaras.
Por este motivo, foi criada a ferramenta BITMask, que transforma as coordenadas dos módulos do projeto (disponíveis no arquivo UCF ou no FPGA Editor) na máscara a ser utilizada por o BitGen.
O BITMask é executado por a linha de comando:
BITMask inicio fim.
Três máscaras são geradas por o BITMask, uma para cada PartialMask.
Portanto, o usuário decide se os valores informados dos parâmetros inicio e fim correspondem ao número da coluna de slices ou ao número da coluna de BRAMs.
Em o primeiro caso, inicio e fim correspondem as slices inicial e final do módulo, no segundo caso, inicio e fim correspondem à primeira coluna e à última de BRAMs.
Se o módulo ocupar apenas uma coluna de recursos, basta informar os mesmos valores para inicio e fim.
Para criar a máscara para o parâmetro PartialMask0, BITMask divide inicio e fim por dois para transformar colunas de slices em colunas de CLBs, e soma três a cada variável para desconsiderar as primeiras três colunas do FPGA, que são a coluna de relógio e as colunas de IOBs.
A seguir deve- se gerar um valor binário que possua os bits entre inicio e fim habilitados, onde o bit mais a direita é o bit menos significativo.
A Figura 71 apresenta um exemplo de como gerar a máscara para o parâmetro PartialMask0 de um módulo implementado entre as slices 2 e 9.
Para criar a máscara para os parâmetros PartialMask1 apenas gerar um valor binário que possua os bits entre inicio PartialMask2, fim o BITMask deve habilitados, onde o bit mais a direita é o bit menos significativo.
O CoreUnifier é uma ferramenta gráfica desenvolvida por o Autor em linguagem Java, e possui o objetivo de gerar bitstreams parciais a partir de a seleção de áreas de bitstreams totais.
Ela foi implementada a partir de as equações de endereçamento do dispositivo Virtex-I disponibilizadas no Application Note 151.
O CoreUnifier-II Para o, assim como disto, permite realocação de bitstreams e Virtex-II Para o.
Ele foi construído documentação disponível no JBits 3.
Tais o CoreUnifier, também gera bitstreams parciais.
Além é destinado a manipular bitstreams dos dispositivos com base no conhecimento obtido do CoreUnifier e da fontes de informações foram importantes para o seu desenvolvimento porque a organização do bitstream em relação a sua arquitetura não foi aberta ao público, como feito para o dispositivo Virtex-I. A ferramenta CoreUnifier-II Para o possui dois modos de operação:
Extração: Gera um bitstream parcial das colunas selecionadas a partir de um bitstream total.
Este modo de operação é automaticamente utilizado quando um único bitstream total é aberto na interface gráfica.
Em este modo de operação, também é possível realocar as colunas selecionadas antes de salvar o bitstream parcial, o que é feito arrastando o conjunto de colunas para a nova posição.
Unificação: Gera um bitstream parcial a partir de a unificação de dois bitstreams totais.
Esse modo de operação é automaticamente selecionado quando dois bitstreams totais são abertos na interface gráfica.
O primeiro bitstream total aberto é denominado mestre, sendo este o projeto inicializa o SDR.
O segundo bitstream total aberto possui o módulo reconfigurável a ser inserido sobre o mestre.
A diferença deste modo de operação para o primeiro é que neste, o módulo reconfigurável não precisa ocupar toda a coluna, podendo ser mantida lógica do projeto inicial na mesma coluna.
Este modo de operação permite a realocação de um módulo nas duas dimensões:
Linha e coluna.
As próximas Seções descrevem a relação entre arquitetura, memória de configuração e bitstreams dos dispositivos Virtex-II e Virtex-II Para o que foram compiladas para a implementação da ferramenta CoreUnifier-II Para o.
Estas informações complementam o estudo efetuado na dissertação de Daniel Mesquita, podendo servir como base para novas ferramentas que manipulam bitstreams.
Cabe ressaltar que não foram utilizadas informações disponíveis do NDA para a implementação da ferramenta CoreUnifier-II Para o, tendo sido estas deduzidas a partir de e Conforme mencionado anteriormente, aa memóriaa de configuração das famílias Virtex-II e Virtex-II Para o podem ser vistas como uma matriz de bits.
Esses bits são agrupados em frames verticais com um bit de largura, que se estendem do topo à base da matriz.
Existem três tipos de colunas:
CLB, BRAM e interconexão de BRAM.
Recursos de E/ S (IOBs) e de relógio fazem parte das colunas de CLBs e podem conter um número diferente de frames, conforme ilustrado na Figura Cada CLB é cortada verticalmente por 22 frames e horizontalmente por 80 bits.
A Figura 73 apresenta uma abstração da composição de um frame de uma coluna de CLBs do dispositivo Virtex-II 1000.
Os 96 primeiros bits de um frame correspondem aos IOBs do topo da coluna, e os 96 últimos, aos IOBs da base da coluna.
Entre esses grupos, há conjuntos de 80 bits correspondentes às CLBs de uma coluna do dispositivo.
Para o dispositivo Virtex-II 1000, há 32 desses conjuntos, conforme apresentado na Tabela 6, da página 31.
A ferramenta BitGen pode gerar bitstreams em dois formatos.
O primeiro é em formato binário, normalmente utilizado para configurar FPGAs (possui a extensão».
Bit&quot;). O segundo é em formato texto, utilizado para manipular o bitstream (possui a extensão».
Rbt&quot;). Um FPGA pode ser configurado por a ferramenta Impact a partir de ambos os formatos de arquivo.
A Figura 74 apresenta a estrutura de um bitstream total do dispositivo Virtex-II 1000 gerado por o BitGen, composto por 127797 palavras de 32 bits.
De estas, apenas as palavras de dados possuem a função de configurar o FPGA.
As outras ou são desnecessárias ou são utilizadas por o processo de configuração.
Em este bitstream existem 10522 palavras desnecessárias, pois repetem dados que já foram enviados nas palavras de dados.
O Autor utilizou a ferramenta CoreUnifier para extrair estas 10522 palavras do bitstream e a configuração do FPGA foi executada corretamente.
Para informações completas sobre as palavras utilizadas por o processo de configuração, remete- se o leitor a.
A Figura 75 apresenta um bitstream parcial gerado por o CoreUnifier-II Para o.
A linha 5 indica que o bitstream foi gerado para um dispositivo Virtex-II 1000 e a linha 7 informa que a partir de esta linha existem 597664 bits a serem enviados para o dispositivo.
As linhas 8 e 9 são utilizadas para sincronizar o hardware de recepção de dados com a velocidade em a qual o bitstream está sendo enviado.
As linhas 10 e 11 inicializam o cálculo de CRC para posterior verificação de dados de configuração enviados para o dispositivo.
As linhas 12 e 13 são escritas para garantir que o bitstream enviado é destinado ao dispositivo correto.
As linhas 14 e 15 informam que está sendo feito o download de uma configuração para o dispositivo, e não readback.
As linhas 16 e 17 informam que os dados enviados configuram o FPGA a partir de a coluna de CLB 20 (MJA 23-3) frame 0.
As linhas 18 e 19 informam que a partir deste ponto serão enviadas 18656 palavras de 32 bits, ou seja, 8 colunas de CLBs.
Os dados de configuração da coluna de CLB 20 a coluna 27 são enviados entre as linhas 20 e 18675.
A linha 18676 apresenta o cálculo de CRC automático efetuado após o envio de dados.
As linhas 18677 a 18680 executam uma nova verificação total antes de terminar o bitstream.
As linhas 18681 a 18682 retiram, por segurança, a sincronização efetuada no início do bitstream, impossibilitando o envio de dados até uma nova sincronização.
As linhas 18683 a 18684 atualizam a sincronização feita nas duas linhas anteriores.
Xilinx ASCII Bitstream Created by Bitstream G. 30 Design name:
Architecture: Virtex2 Part:
Date: Thu Nov 03 19:45:17 2005 Bits:
Para que seja factível a reconfiguração parcial de módulos a partir de bitstreams totais, fazse necessária a localização de CLBs dentro de o arquivo de configuração.
Segundo a Figura 74, para chegar até o primeiro frame de CLBs do arquivo de configuração deve- se deslocar 31 frames de dados a partir de o comando FDRI.
Logo, a localização da palavra de 32 bits inicial de qualquer coluna de CLBs pode ser realizada através da Equação 1.
Equação 1 onde:
FL: É o número de palavras de um frame.
Esse valor é obtido dividindo o tamanho do frame em bits do dispositivo utilizado por 32.
CLB_ Col:
É o número da coluna de CLB desejada, sendo a coluna mais à esquerda do dispositivo a coluna zero.
Como já mencionado, uma coluna de CLBs é formada verticalmente por 22 frames.
A Equação 2 permite acessar individualmente cada frame de uma coluna de CLBs.
Equação 2 onde:
MNA: É o índice do frame desejado dentro de uma coluna de CLBs.
Este valor varia de 0 a 21.
Conforme apresentado na Figura 73, cada CLB dentro de um frame possui 80 bits (2,5 palavras de 32 bits).
A Equação 3 permite localizar o índice da palavra que contém os bits de programação de uma CLB específica dentro de um frame.
Cabe ressaltar que se o resultado não for inteiro, os bits da linha da CLB requisitada iniciam a partir de a metade da palavra de 32 bits resultante.
Equação 3 onde:
CLB_ Row:
É o número da linha de CLB desejada, sendo a linha de CLB superior a linha zero.
Considere a realocação da CLB de coordenadas 0,0 para as coordenadas 1,1 num dispositivo Virtex-II 1000, conforme apresentado na Figura 76.
O primeiro passo é determinar o índice da palavra do bitstream onde inicia a configuração da CLB de origem.
Isto é feito aplicando as três Equações apresentadas na Seção anterior.
Substituindo- se as coordenadas 0 e 0 em CLB_ Col e CLB_ Row, 106 em FL e 0 em MNA obtêm- se que os primeiros 80 bits de programação da CLB 0, 0 iniciam na palavra 3289.
O segundo passo é determinar o índice da palavra da CLB de destino dentro de o bitstream.
Isto é feito aplicando as mesma três equações com as coordenas 1 e 1 para CLB_ Col e CLB_ Row, o que resulta no índice 5623,5.
Em este caso deve- se copiar 80 bits a partir de o inicio da palavra 3289 para a segunda metade da palavra 5623 e as duas palavras seguintes.
Para realocar a CLB inteira basta reaplicar os dois passos para os outros 21 frames variando o valor de MNA.
Existe ainda um passo opcional para a implementação de SDRs que é a realocação dos módulos reconfiguráveis do sistema.
Embora a ferramenta CoreUnifier-II Para o permita de forma gráfica facilmente realocar módulos de posição, conforme descrito na Seção anterior, fazer um projeto com esta característica requer um esforço de projeto ainda maior que fazer um projeto apenas reconfigurável.
Quatro dificuldades adicionais sobre o fluxo de SDRs são citadas:
Perda de um grau de liberdade no roteamento, não sendo mais possível que nenhum fio cruze a fronteira entre os módulos, pois o módulo realocado não possuirá o complemento do fio de outro módulo conforme o módulo original possuía;
As interfaces dos dois módulos implementados em posições distintas do FPGA devem possuir interface idêntica, caso contrário a comunicação do módulo realocado com o restante do sistema será prejudicada;
Possibilidade de um módulo realocado não atender mais as características de temporização;
Um módulo não pode ser realocado para qualquer posição do FPGA, devido a os FPGAs Virtex-II e Virtex-II Para o possuírem uma arquitetura irregular (processadores PowerPC, BRAMs e blocos multiplicadores).
Este Capítulo apresentou um fluxo de projeto que busca simplificar a implementação de SDRs em relação a outros fluxos apresentados no Capítulo 3.
A principal simplificação deste fluxo em relação a propostas anteriores ocorre durante a síntese do projeto, a qual, por ser baseada em parâmetros padrão, reporta menos erros durante a execução do fluxo.
Uma fonte de problemas de fluxos para SDRs, como é o caso do Projeto Modular, é a utilização de macros baseadas em tristates.
Este problema foi tratado no fluxo atual com a utilização de macros baseadas em LUTs, conforme as macros utilizadas por Dyer e Huebner.
A ferramenta CoreUnifier-II Para o permite gerar bitstreams parciais por o método de extração de frames e realocar módulos do sistema.
O fluxo apresentado ainda está distante de um fluxo ideal para SDRs.
O principal problema enfrentado é a dificuldade em restringir o roteamento, já que os módulos são compostos por blocos lógicos e roteamento, e os blocos lógicos podem ter as suas posições restritas.
Este controle do roteamento é necessário para que os módulos possam ser posicionados em posição escolhida do FPGA e posteriormente reconfigurados, enquanto o restante do sistema continua operando.
Uma tarefa passível de ser automatizada nos fluxos de SDR é a instanciação de macros no top do projeto.
Como todas as conexões dos módulos reconfiguráveis (com exceção do sinal de relógio) devem ser feitas por macros, basta saber a direção da conexão e inserir a macro correspondente no meio.
Este Capítulo apresenta a segunda contribuição deste trabalho:
Uma proposta de NoC que permita a reconfiguração parcial e dinâmica de módulos conectados a ela.
Esta NoC, denominada Artemis, foi construída a partir de a NoC Hermes, visando minimizar a necessidade de conectar um número elevado de módulos que não são usados simultaneamente, conseqüentemente reduzindo a área reservada para os roteadores da NoC, adicionar flexibilidade permitindo que novos módulos sejam carregados sem interromper o sistema como um todo e aumentar o desempenho do sistema utilizando módulos de hardware específicos para resolver uma computação solicitada.
O trabalho de Marescaux, apresentado na Seção 2.3.3.1, possui três redes distintas:
Uma para tráfego de dados, uma para controle e uma exclusiva para reconfiguração.
Por um lado, três redes distintas garantem uma melhor qualidade de comunicação e menor latência.
Por outro lado, a sobreposição de redes de comunicação aumenta o número de fios entre os módulos do sistema, conseqüentemente aumentando a complexidade para a conexão de módulos reconfiguráveis e a área para o controle de cada uma destas redes em cada uma das interfaces dos módulos.
A proposta deste trabalho é utilizar a própria rede intra-chip de comunicação de dados para controlar também a reconfiguração.
Para a implementação desta, a rede Hermes é utilizada como base, sendo sucintamente apresentada na Seção 5.1.
Em a seqüência, duas políticas de acesso a módulos reconfiguráveis são analisadas, na Seção 5.2.
As modificações necessárias na rede Hermes para a conexão de módulos reconfiguráveis são apresentadas na Seção 5.3.
Essa rede intra-chip modificada para permitir a substituição de módulos de hardware em tempo de execução foi denominada Artemis.
A topologia de uma NoC é definida por a estrutura de conexão dos seus roteadores.
Em a topologia malha, utilizada neste trabalho, roteadores distintos possuem um número de portas diferentes, dependendo de sua posição na rede, como mostrado na Figura 77C.
Por exemplo, o roteador central de uma NoC Hermes 3x3 possui cinco portas, conforme apresentado na Figura 77B.
As cinco portas bidirecionais do roteador são:
East, West, North, South e Local.
Cada porta possui uma fila de entrada para o armazenamento temporário de flits5.
A porta Local estabelece a comunicação entre o roteador e seu módulo local.
As demais portas ligam o roteador aos roteadores vizinhos.
O modo de chaveamento adotado por o roteador da NoC Hermes é wormhole, onde cada pacote que trafega por a rede é passado flit a flit por os canais físicos.
O formato dos pacotes que trafegam por a rede é apresentado na Figura 77A.
A lógica de controle implementa a lógica de arbitragem e o algoritmo de roteamento.
Flit: Menor quantidade de informação transmitida entre roteadores de uma NoC.
2º flit:
Quantidade de flits de dados do pacote flitN flit2 flit1 Roteador ou Módulo Dados Porta de Entrada 1º flit:
Um roteador pode ser requisitado a estabelecer até 5 conexões simultâneas (uma conexão por porta de entrada do roteador).
A lógica de arbitragem é utilizada para escolher qual das portas de entrada será roteada primeiro.
Para isto, é utilizado um algoritmo de arbitragem dinâmica rotativa (round-robin), onde a prioridade de uma determinada porta é dada em função de a última porta a ter a requisição de arbitragem atendida.
Este algoritmo evita que uma mesma porta de entrada tenha sempre a maior prioridade para requisitar uma porta de saída, não permitindo acesso das outras portas de entrada às portas de saída.
O algoritmo de roteamento utilizado por o roteador é o XY determinístico, em o qual os pacotes trafegam por a rede sempre numa mesma ordem:
Trafegam por a rede no eixo X até chegar na coluna do roteador destino;
Trafegam por a rede no eixo Y até chegar na linha do roteador destino;
Estando no roteador destino, o pacote é encaminhado para a porta local para alcançar o módulo destino.
Quando um flit é bloqueado num determinado roteador, o desempenho da rede é afetado, pois os flits do mesmo pacote podem ser bloqueados em roteadores intermediários da rede, dependendo dos tamanhos do pacote e das filas.
O tamanho das filas utilizadas para armazenar flits bloqueados é parametrizável em tempo de projeto.
Mais detalhes sobre a NoC Hermes podem ser obtidos em.
A posição de um dado módulo reconfigurável na NoC pode variar ao longo de a execução do sistema.
Isto ocorre porque estes saem do sistema para dar espaço a outros e até mesmo para melhorar o desempenho do sistema como um todo (e.
g reposicionar módulos origem e/ ou destino de forma que fiquem mais próximos quando estes se comunicam com freqüência ou quando transferem grande quantidade de informação).
Para isso, é necessária uma entidade que gerencie a qual roteador um módulo reconfigurável vai ser conectado e que módulo reconfigurável pode ser retirado para a entrada de outro.
A esta entidade dá- se o nome de Controlador de Configurações Dois CCs foram propostos como trabalhos acadêmicos, tendo sido estes analisados por Carvalho.
Carvalho implementou um CC completamente em hardware chamado RSCM no escopo do mesmo grupo do Autor.
Encontra- se em andamento a implementação de um CC em software, para que seja feita a análise dos para os e contras em relação a o trabalho de Carvalho.
Não pertence ao escopo deste trabalho conectar um CC ao SDR proposto, ficando esta atividade como uma sugestão de trabalho futuro.
No entanto, este trabalho se preocupa em prover um suporte de hardware e de comunicação entre os módulos reconfiguráveis e o CC.
Logo, para efetuar um acesso a um módulo reconfigurável da rede deve- se acessar antes o CC para se determinar onde o módulo será configurado.
A Figura 78 apresenta duas políticas de acesso ao CC para posterior acesso ao módulo reconfigurável.
CC é acessado toda vez que MR for acessado.
Os passos sugeridos na Figura 78A são descritos a seguir:
O passo 3 se repete para cada acesso posterior de MF a MR.
A seguir são descritos os passos sugeridos na Figura 78 B:
A política descrita na Figura 78B é a mais simples de ser implementada, pois quando deseja- se acessar um MR, o pacote é enviado para o CC e este gerência qual é o endereço que corresponde ao MR.
No entanto, esta política possui uma latência maior, pois o CC é sempre acessado antes de acessar um MR.
A necessidade de sempre acessar o CC antes de acessar um MR pode criar também um gargalo no sistema quando existirem muitos MRs.
A política descrita na Figura 78A é a que mais se aproxima à política de comunicação já implementada na NoC, pois uma vez que o endereço de destino do pacote é fornecido por o CC, os acessos a MRs são semelhantes aos acessos a MFs.
Esta política permite efetuar a comunicação com MRs com uma baixa latência de comunicação, já que não é necessário acessar o CC sempre antes de acessar o MR.
Em contraponto, cada módulo conectado ao meio de comunicação deve possuir uma tabela local que relacione o endereço dos MRs utilizados por o módulo.
Esta é uma tabela limitada, contendo apenas um subconjunto de registros da tabela total do CC.
O número de registros existentes na tabela de CC é igual ao número de MRs do sistema, enquanto a tabela existente em cada módulo é parametrizável.
A vantagem desta implementação é que um módulo pode acessar mais de um MR sem consultar o CC.
A desvantagem é que criar tabelas nos módulos que podem acessar MRs pode trazer, além de um aumento significativo em área, a necessidade de controle da validade do endereço de MR.
O objetivo da NoC Artemis é permitir o controle da reconfiguração de módulos conectados a ela por a mesma rede intra-chip em a qual dados são transmitidos.
Entende- se por controle da reconfiguração o processo de permitir que um módulo seja corretamente configurado sem prejudicar o funcionamento do restante do sistema que continua operando.
Verificou- se durante a execução do presente trabalho, que a reconfiguração de um novo módulo resulta em glitches para a entidade ao qual o módulo está conectado.
Em o caso específico da NoC, este problema é percebido no sinal rx do roteador, o qual erroneamente oscila algumas vezes devido a o processo de reconfiguração, levando o roteador a possíveis estados inválidos.
Para contornar este problema e permitir a reconfiguração de módulos conectados à NoC, quatro modificações no roteador da Hermes foram feitas:
Suporte a pacotes de controle;
Acréscimo de sinais nas interfaces de E/ S;
Inserção de lógica nas filas para receber/ repassar pacotes de controle;
Descarte de pacotes de dados enviados para módulos reconfiguráveis durante a reconfiguração do módulo.
Estas modificações são apresentadas na Seção 5.3.1.
O mecanismo de isolamento do módulo reconfigurável conectado à porta local do roteador é apresentado na Seção 5.3.2.
A Seção 5.3.3 apresenta a validação por simulação funcional da NoC Artemis.
A prototipação da Artemis é realizada numa série de estudos de caso no Capítulo 6.
O roteador da NoC Hermes é formado basicamente por a lógica de controle, por as filas e por as portas de E/ S, como pode ser observado na Figura 77B na página 87.
As modificações necessárias no roteador da Hermes são apresentadas a seguir e envolvem apenas as portas de E/ S e as filas do roteador, não sendo necessárias alterações na lógica de controle.
Para informações específicas sobre a lógica de controle o leitor é remetido a.
Para que a rede Artemis possa garantir o correto funcionamento da NoC em SDRs, pacotes de controle foram criados em complemento aos pacotes de dados suportados por a rede Hermes.
Pacotes de controle são utilizados na Artemis para que os roteadores possam controlar a comunicação com o módulo reconfigurável conectado em sua porta local.
Estes pacotes são identificados por sinais extras nas portas de entrada dos roteadores, detalhados na Seção seguinte.
Dois serviços habilitados por a chegada de pacotes de controle foram adicionados aos roteadores de módulos reconfiguráveis da Artemis:
Os serviços de estabelecimento e interrupção de comunicação entre o roteador e o módulo reconfigurável.
A Figura 79 apresenta estes pacotes.
Pacotes de controle possuem apenas dois flits.
O primeiro é o destino do pacote e o segundo é a operação que o roteador deve executar.
Com esta estrutura de pacotes de controle a NoC pode diretamente suportar até 2 (tamanho do flit em bits) serviços disponibilizados por os roteadores.
No caso de os dois pacotes que controlam a reconfiguração apresentados na Figura 79, estes devem ser gerados por um módulo que executa o papel de um controlador de configurações (CC).
Este CC pode ser interno ao sistema e estar implementado em hardware, em software ou ser implementado externamente e fazer interface com o sistema através de um módulo conectado à NoC.
Uma vez que um pacote de interrupção da comunicação é recebido por o roteador de um módulo reconfigurável, o sinal de reconf deste roteador, que é conectado a (s) macro (s) através dos sinais ctrl, é ativado.
Quando isto ocorre a (s) macro (s) inibe (m) a passagem de dados.
Depois da recepção de um pacote de restabelecimento da comunicação, o sinal reconf é desativado e a (s) macro (s) volta (m) a repassar dados para o módulo reconfigurável.
Para diferenciar pacotes de controle de pacotes de dados foram adicionados nas portas dos roteadores os sinais ctrl_ in e ctrl_ out, conforme ilustrado na Figura 80.
Desta forma, a cada flit ctrl_ in rx ack_ rx data_ in ctrl_ out tx ack_ tx data_ out Roteador ctrl_ out tx ack_ tx data_ out ctrl_ in rx ack_ rx data_ in West East Roteador enviado por um roteador através dos sinais data_ out e tx, adiciona- se o sinal ctrl_ out, o qual informa se o flit é de controle ou de dados.
O roteador destino do flit recebe flits de forma análoga por os sinais data_ in, rx e ctrl_ in.
Para que pacotes de controle cheguem ao roteador destino é necessário inserir lógica em cada uma das portas dos roteadores da NoC para repassar ou capturar os pacotes de controle.
As primeiras tarefas do roteador destino são verificar o destino (primeiro flit) de um pacote recebido, e se este é de controle.
Caso o destino de um pacote de controle seja igual ao endereço do roteador atual, então este pacote será capturado por o roteador atual.
A chegada do segundo flit do pacote informa se será estabelecida ou interrompida a comunicação do roteador com o módulo reconfigurável.
Caso o destino do pacote seja um endereço diferente do roteador atual, então este flit deve entrar na fila pré-existente (fila de dados) e uma nova fila criada no roteador da Artemis (fila de controle) deve armazenar no mesmo índice da fila de dados a informação de que aquele dado é de controle.
A fila de controle possui o mesmo tamanho da fila de dados, largura um bit e sempre opera com o mesmo índice da fila de dados.
O segundo flit deste pacote, contendo a operação a ser efetuada por o roteador destino, é igualmente inserido na fila de dados, inserindo também o valor recebido de ctrl_ in na fila de controle.
Uma vez que um pacote de controle se encontra na fila do roteador, o processo de repasse é feito de forma semelhante aos pacotes de dados, apenas levando em consideração que deve ser realizado o envio de ctrl_ out com o valor armazenado na fila de controle, para cada flit enviado.
Quando um pacote de dados destinado à porta local do roteador for recebido durante o processo de reconfiguração, o pacote em questão fica aguardando na fila do roteador do módulo reconfigurável e, dependendo do tamanho do pacote, em outros roteadores intermediários da NoC.
Se isto ocorrer, o pacote de controle enviado por o CC não chegará até o roteador do módulo que foi configurado, jamais estabelecendo a conexão com o mesmo.
Devido a este motivo e à dúvida de não saber se o pacote foi destinado ao módulo que estava previamente configurado ou ao módulo que está sendo configurado, decidiu- se descartar pacotes de dados recebidos por o roteador de um módulo reconfigurável durante o processo de configuração de um módulo.
Fica a cargo de a política de acesso evitar que pacotes de dados não sejam descartados por o roteador do módulo que está sendo reconfigurado, ou tratar deste caso usando e.
g uma estratégia de reenvio.
Um pacote deve ser descartado apenas quando três eventos simultâneos forem verificados:
O módulo local encontra- se em processo de reconfiguração;
O pacote recebido é destinado ao módulo conectado à porta local do roteador (data_ in $= address, onde address é o endereço XY do roteador atual na NoC e data_ in é o primeiro flit do pacote que indica o destino do mesmo);
o pacote é de dados.
Uma vez detectado que o pacote deve ser descartado na chegada do primeiro flit, espera- se a chegada do segundo flit, o qual possui a informação de quantos flits ainda serão recebidos.
Esta informação é utilizada para inicializar um contador que é decrementado a cada flit recebido, onde cada flit é dito &quot;descartado «por não ser inserido na fila de entrada de forma a ser repassado para o módulo local.
A interface entre o roteador e o módulo reconfigurável é apresentada na Figura 81.
Foram necessárias duas macros LR para conectar os 11 bits da interface do roteador com o módulo reconfigurável e duas macros RLC para conectar os outros 10 bits de interface no sentido inverso de comunicação.
Em a interface entre o roteador e um módulo reconfigurável percebe- se que os sinais reconf e reset foram adicionados e os sinais ctrl_ in e ctrl_ out foram suprimidos, quando comparado à interface roteador-roteador apresentada na Figura 80.
Os sinais ctrl_ in e ctrl_ out foram suprimidos da interface entre o roteador e o módulo reconfigurável porque módulos reconfiguráveis não enviam nem recebem pacotes de controle, sendo estes pacotes consumidos por o roteador.
O reset é um sinal global que deve ser conectado apenas aos módulos, sendo utilizado para colocar as máquinas de estados dos módulos no estado inicial.
O sinal reconf é utilizado, assim como reset, para inicializar as máquinas de estados, com a exceção que o sinal de reconf inicializa apenas o módulo local do roteador a ele conectado.
O sinal de reconf negado da Figura 81 é conectado ao sinal controle da macro RLC, conforme apresentado na Figura 64B, permitindo a passagem de dados do módulo reconfigurável para o roteador apenas quando o módulo não estiver sendo reconfigurado.
A rede Artemis foi primeiramente validada através de simulação funcional.
A Figura 82 apresenta, por meio de formas de onda, a validação do processo de interrupção da comunicação com um módulo reconfigurável, e o posterior restabelecimento desta comunicação após a reconfiguração.
Os passos apresentados a seguir possuem correspondência com a numeração indicada na Figura 82, e pressupõem o uso do sistema descrito na Figura 78.
Roteador desativa sinal de reconf, informando à macro que volte a repassar os sinais de saída do módulo reconfigurável para o roteador.
Poucas modificações foram necessárias na rede Hermes para habilitar a reconfiguração parcial e dinâmica de módulos conectados a ela.
De entre as modificações, a primeira refere- se à implementação de dois tipos de pacotes de controle, os quais não são repassados ao módulo conectado à porta local, e sim processados diretamente por o roteador.
Em o contexto deste trabalho, os pacotes de controle foram utilizados para isolar o módulo antes da reconfiguração e reativar a comunicação após a reconfiguração.
Em trabalhos futuros, estes pacotes poderão ser utilizados para configurar o roteador, ou recolher estatísticas de desempenho, por exemplo.
A segunda modificação a ressaltar é habilitar o descarte de pacotes durante a reconfiguração de um módulo, pois pacotes de dados direcionados a este último seriam bloqueados por o roteador, podendo colocar a rede em situação de bloqueio permanente.
Este Capítulo apresenta uma série de estudos de caso para validar o fluxo de projeto de SDRs proposto no Capítulo 4 e a NoC Artemis, proposta no Capítulo 5.
A Seção 6.1 primeiramente apresenta o ambiente de hardware e software utilizado para validar os estudos de caso apresentados nas Seções seguintes.
A Seção 6.1 ainda provê uma introdução sobre os módulos de hardware utilizados nos estudos de casos.
O estudo de caso da calculadora reconfigurável é apresentado na Seção 6.2, com o objetivo de seguir passo a passo o fluxo de projeto proposto.
A Seção 6.3 possui a finalidade de mostrar que o fluxo proposto é robusto, no sentido de permitir a construção de interfaces entre um barramento e um módulo reconfigurável com mais de 100 sinais.
A Seção 6.4 apresenta a conexão dos módulos reconfiguráveis de multiplicação, divisão e raiz quadrada à NoC Artemis.
Um sistema multiprocessado que permite intercambiar módulos processadores de 32 bits por processadores de 16 bits é apresentado na Seção 6.5.
As Seções 6.6 e 6.7 apresentam sistemas realocáveis vertical e horizontalmente, respectivamente.
Em esta Seção apresenta- se o ambiente de hardware e software utilizado para desenvolver e validar o presente trabalho.
Primeiro, descreve- se as plataformas de desenvolvimento utilizadas e os módulos de hardware que em elas foram prototipados.
Em seguida, descreve- se quais softwares comerciais foram empregados e os aplicativos implementados para habilitar o desenvolvimento dos estudos de caso.
Os testes iniciais do fluxo de projeto proposto, módulos reconfiguráveis conectados à NoC Artemis e de realocação, foram todos executados numa plataforma V2 MB1000 da Memec Insight.
Esta plataforma possui um FPGA Virtex-II 1000 e suporte a módulos de extensão padrão da Memec denominados P160.
Utilizou- se o módulo de prototipação para estender as interfaces de E/ S da plataforma principal para a conexão em analisadores lógicos da Agilent e Hp.
As reconfigurações foram efetuadas através do cabo Parallel Cable IV da Xilinx.
À medida que os estudos de caso foram se tornando mais complexos, migrou- se para uma plataforma maior, a Xilinx University Program Virtex-II Para o Development System.
Esta possui um dispositivo Virtex-II Para o XC2 VP30 e foi reconfigurada através de um cabo USB.
As próximas Seções apresentam os módulos de hardware utilizados nos sistemas implementados.
É importante ressaltar que todos os módulos foram desenvolvidos no escopo do O módulo serial é responsável por prover comunicação entre o sistema do usuário num computador hospedeiro e os módulos do sistema interconectados através da NoC.
Esta comunicação é realizada através do protocolo padrão RS-232C.
A Figura 83 apresenta a interface externa do módulo serial.
Os sinais apresentados na parte superior da Figura 83 conectam o módulo ao computador hospedeiro, enquanto os sinais da parte inferior conectam o módulo com a NoC.
A função de cada sinal é:
Além de os sinais de interface padrão do protocolo da NoC descritos na Figura 77D, pode- se perceber o sinal ctrl_ out..
Este habilita que o módulo serial envie pacotes de controle para os módulos conectados à Artemis, permitindo controlar externamente o estabelecimento ou a interrupção da comunicação com módulos reconfiguráveis.
A primeira tarefa do módulo serial é ajustar a transmissão/ recepção da taxa de transferência de dados do computador hospedeiro com a taxa de transmissão/ recepção do módulo serial.
Isto é feito enviando um byte 55h do computador hospedeiro para o módulo serial.
Este procedimento precisa ser efetuado cada vez que o sistema for inicializado.
Após a inicialização, o módulo espera por dados do computador hospedeiro ou da NoC, transmitindo o dado recebido para o lado oposto.
O módulo serial ocupa em média 284 slices de um dispositivo Virtex-II (Para o).
O processador R8 é um processador 16 bits load-store com arquitetura Von Neumann (memória de instrução e dados unificada), com CPI (Ciclos Por Instrucao) entre 2 e 4.
O conjunto completo de instruções do processador é apresentado na Tabela 12.
O bloco de dados contém 16 registradores de propósito geral, registrador de instruções (Ir), contador de programa (PC), ponteiro para pilha (SP), e 4 flags de estado (negativo, zero, vai- um e transbordo).
A interface externa do módulo R8, assim como os seus principais blocos internos, são apresentados na Figura 84.
O módulo R8 inclui o processador R8 e uma memória cache de 4K palavras de 16 bits.
Em o módulo R8 existe ainda uma lógica de controle que comanda a execução do processador R8, colocando o mesmo em estado de espera toda a vez que o processador executa uma instrução de load-store.
Operações de load-store podem acessar:
A cache local ao processador, a cache de outro processador ou uma memória remota;
Dispositivos de E/ S;
Outros processadores, por motivos de sincronização.
Estes três modos de acesso são detalhados a seguir.
Para determinar qual elemento de armazenamento do sistema (cache local, cache remota, memória) o processador R8 está acessando através de instruções load-store, faixas de endereçamento foram definidas para cada tipo de elemento de armazenamento.
A Figura 85 apresenta um exemplo das faixas de endereçamento de um sistema que contém dois processadores e uma memória.
As operações de E/ S são mapeadas no endereço de memória FFFFh.
Portanto, quando uma instrução de store é executada neste endereço, uma operação de printf é realizada por o módulo de E/ S do sistema (módulo Serial no presente trabalho), e quando uma operação de load é executada no mesmo endereço uma operação de scanf é realizada.
Em sistemas multiprocessados um mecanismo de sincronização é necessário para implementar aplicações distribuídas.
Esta sincronização foi realizada no presente trabalho através de comandos wait e notify, ambos mapeados em memória.
O comando wait é responsável por bloquear a execução do processador até que um comando de notify seja recebido.
O comando wait é identificado através de uma instrução de store no endereço FFFEh com o número do processador que vai reiniciar a execução do processador com um comando de notify.
O comando de notify é identificado através de uma instrução de store no endereço FFFDh com o número do processador que vai ser reiniciado.
O módulo R8 ocupa em média 502 slices de um dispositivo Virtex-II (Para o).
O processador MR2 implementa um subconjunto das instruções da arquitetura MIPS.
O processador MR2 é um processador 32 bits load-store com arquitetura Harvard.
Ele possui um banco de registradores de uso geral de 32 posições, denominados de 0 a 31.
O registrador 0 não é realmente um registrador, mas sim a constante 0, disponível para uso em instruções que necessitem usar este valor.
O conjunto completo de instruções do processador é apresentado na Tabela 13.
A interface externa do módulo MR2, assim como os seus principais blocos internos, são apresentados na Figura 86.
O módulo MR2 inclui o processador MR2 e uma memória cache de 2K palavras de 32 bits, sendo 1K palavras reservada para instruções e 1K palavras para dados.
O porte do processador MR2 para a NoC e a criação de drivers para comunicação com outros módulos da NoC também são contribuições do presente trabalho.
Em o processador R8 drivers não são necessários, pois uma vez que uma operação mapeada em memória é executada, um hardware específico se responsabiliza por montar um pacote e enviar a outro módulo da NoC.
Se por um lado, esta abordagem permite rapidamente liberar o processador em chamadas não bloqueantes, por outro lado ela se torna extremamente custosa em hardware à medida que novas operações com novos módulos são adicionadas a NoC.
Por este motivo decidiu- se implementar a comunicação com outros módulos da NoC por software.
Em este caso, os drivers possuem toda a lógica de envio e recebimento de pacotes para a comunicação com outros módulos da NoC.
O Anexo VI apresenta o código completo dos drivers criados.
Com as modificações efetuadas no módulo MR2, as únicas operações executadas por hardware são:
Enviar flit, receber flit e escrever flit na cache.
A escrita na cache foi a única operação que não foi possível implementar em software, pois quando o sistema é inicializado ele não possui o software para preencher a sua cache de instruções com a aplicação a ser executada.
Espera- se no futuro utilizar a reconfiguração parcial para inicializar a cache de instruções da MR2, tornando opcional o hardware hoje existente para este fim.
O módulo MR2 ocupa em média 1021 slices de um dispositivo Virtex-II (Para o).
A NoC Artemis foi modificada a partir de a NoC Hermes utilizada na MultiNoC.
A MultiNoC é uma plataforma biprocessada otimizada para baixo consumo de área, tendo sido esta prototipada num dispositivo Spartan-II com 200 mil portas lógicas equivalentes junto a dois processadores R8, um módulo serial e um módulo de memória.
Esta NoC é uma rede malha 2×2, com flits de 8 bits e filas de armazenamento temporário para 4 flits.
A NoC Artemis com a configuração apresentada ocupa em média 1360 slices de um dispositivo Virtex-II (Para o).
O módulo de multiplicação recebe como entrada dois operandos de 32 bits, provendo uma resposta de 64 bits.
A Figura 87 apresenta os quatro formatos de pacotes utilizados para interagir com o módulo de multiplicação.
Os pacotes A e B são utilizados para enviar os dois operandos de 32 bits e os pacotes C e D são utilizados para recuperar os 64 bits do resultado (um pacote é para recuperar os 32 bits mais significativos da resposta, outro é para recuperar os bits menos significativos).
O módulo de multiplicação ocupa em média 260 slices de um dispositivo Virtex-II (Para o).
O módulo de divisão divide um operando de 32 bits por outro de 32 bits, resultando em 32 bits de resposta e 32 bits de resto da divisão inteira.
A Figura 88 apresenta os quatro formatos de pacotes utilizados para interagir com o módulo de divisão.
O pacote A é utilizado para enviar o dividendo da operação, o pacote B é utilizado para enviar o divisor, o pacote C é utilizado para recuperar o quociente e o pacote D para recuperar o resto da divisão inteira.
O módulo de divisão ocupa em média 254 slices de um dispositivo Virtex-II (Para o).
O módulo de raiz quadrada calcula a raiz quadrada de um operando de 64 bits, provendo uma resposta de 32 bits.
A Figura 89 apresenta os três formatos de pacotes utilizados para interagir com o módulo de raiz quadrada.
Os pacotes A e B são utilizados para enviar, respectivamente, a parte alta e parte baixa do operando a extrair a raiz quadrada, enquanto o pacote C é utilizado para recuperar o resultado da operação.
Além de os softwares para o fluxo de projeto apresentados no Capítulo 4 (CoreUnifier-II Para o, XDLAnalyzer, FPGA Editor e BitGen), outros softwares adicionais são utilizados com a finalidade de obter o SDR funcionando na plataforma de prototipação.
As Seções 6.1.2.1 e 6.1.2.2 apresentam, respectivamente, os simuladores dos processadores R8 e MR2.
A Seção 6.1.2.3 apresenta a ferramenta Packer, responsável por preparar os códigos objetos dos processadores para serem enviados para um simulador HDL ou para um computador hospedeiro através da interface serial.
A Seção 6.1.2.4 apresenta o software utilizado para comunicar o computador hospedeiro com o SDR executado na plataforma de prototipação.
O código em linguagem de montagem para o processador R8 deve ser escrito conforme o seu conjunto de instruções apresentado na Tabela 12.
A seguir o R8 Simulator, apresentado na Figura 90, permite simular o código desenvolvido e automaticamente gerar o código objeto da aplicação.
Infelizmente, o R8 Simulator não permite simular uma aplicação multiprocessada, sendo desconsideradas as instruções que se comunicam com outros processadores.
O código assembly para o processador MR2 deve ser escrito conforme o seu conjunto de instruções apresentado na Tabela 13.
A seguir o Spim, apresentado na Figura 91, permite simular o código desenvolvido e automaticamente gerar o código objeto da aplicação.
Infelizmente, o Spim, assim como o R8 Simulator, não permite simular uma aplicação multiprocessada, sendo desconsideradas as instruções que se comunicam com outros processadores.
Após ter sido gerado o código objeto por o simulador Spim na Seção anterior, o código objeto precisa ser transformado em pacotes para que estes sejam enviados através da NoC até as caches dos processadores do SDR.
A Figura 92 apresenta a interface gráfica da ferramenta Packer, responsável por quebrar códigos objetos em pacotes.
Um campo que deve ser obrigatoriamente preenchido, além de os arquivos de origem e destino dos pacotes, é qual o endereço XY na NoC do processador MR2 que está sendo carregado.
Por a interface gráfica da ferramenta também é possível selecionar se o arquivo de saída vai ser utilizado por um simulador HDL ou se o arquivo será enviado para o SDR a partir de uma interface de E/ S do computador hospedeiro.
Os campos restantes são opcionais.
Até o presente momento não existe suporte da ferramenta Packer para os códigos objetos do processador R8, devendo o processo de geração de pacotes ser efetuado manualmente.
O SerialApp provê acesso à plataforma de prototipação através da interface serial RS-232C de um computador.
A partir de ele é possível configurar as caches de dados e instruções dos processadores, disparar a execução dos processadores e efetuar operações de E/ S dos módulos do sistema.
A Figura 93 apresenta a interface gráfica do SerialApp.
A Figura 95 apresenta as restrições de posicionamento feitas com a ferramenta Pace sobre os recursos instanciados no top.
Note- se à esquerda da Figura 95 que a lógica do projeto foi posicionada à direita do dispositivo, de forma a evitar que o roteamento dos pinos de E/ S não invadam os módulos reconfiguráveis.
A Figura 96 apresenta o roteamento do projeto restringido na Figura 95.
Note que fios do módulo fixo invadiram o módulo reconfigurável.
Tentou- se diversas vezes voltar para o passo anterior e modificar o posicionamento para melhorar o roteamento, sendo o roteamento apresentado o melhor que foi obtido.
Para este estudo de caso esta invasão de área é permitida desde que os fios ocupem as mesmas trilhas na área reconfigurável 1 do projeto top que instancia módulos sub.
De posse dos dois projetos top, um com dois módulos adder instanciados outro com dois módulos sub instanciados, pode- se gerar os bitstreams parciais.
Utilizando a ferramenta CoreUnifier-II Para o basta abrir cada um dos tops, selecionar as áreas dos módulos reconfiguráveis e gerar o bitstream parcial.
Para utilizar o BitGen, deve- se antes descobrir as máscaras das áreas reconfiguráveis com a ferramenta BitMask.
Para este exemplo deve- se executar- la duas vezes, uma para cada área.
Uma vez com as coordenadas da primeira área reconfigurável e uma segunda vez com as coordenadas da segunda área reconfigurável (bitmask 44 46).
As respectivas máscaras 1C00000 e 6000000 retornadas por o BitMask devem ser passadas para o BitGen da seguinte forma:
Um detalhe importante é que as primeiras duas execuções do BitGen devem ocorrer dentro de a pasta onde se encontra o top que possui os módulos adder instanciados, e as duas últimas execuções na pasta onde se encontra o top que instancia os módulos sub.
Para verificar o correto funcionamento do SDR, prototipou- se o projeto inicial com os dois módulos somadores e, a partir de os switch buttons da plataforma, requisitou- se a operação 3+ 2 para o primeiro somador e o resultado da primeira operação somado ao valor 1 para o segundo somador.
O resultado 6 (3+ 2)+ 1) foi apresentado no display da plataforma.
A seguir, se configurado o primero subtrator, o resultado se altera instantaneamente para 2((3-2) + 1), se configurado o segundo, o resultado se altera para 4 (3+ 2) 1) e se configurado ambos os subtratores, o resultado se altera para 0((3-2) -1).
O fluxo de projeto para SDRs, apresentado no Capítulo 4, foi estendido por Rafael Soares em seu trabalho de mestrado executado em paralelo ao do Autor, permitindo a reconfiguração de módulos do usuário conectados ao barramento CoreConnect.
A este barramento podem ser conectados processadores (e.
g Microblaze, PowerPC), módulos do usuário e outros módulos disponibilizados no ambiente de desenvolvimento EDK da Xilinx.
Em foi apresentado um SDR auto-reconfigurável, em o qual um processador Microblaze posicionado na parte fixa do sistema dispara a reconfiguração ora de um contador progressivo ora de um contador regressivo.
A Figura 97 apresenta a planta baixa do sistema contador progressivo/ regressivo para um dispositivo Virtex-II Para o 30.
Devido a a grande quantidade de sinais que interligam o barramento CoreConnect ao módulo do usuário, um total de 11 macros RL e LRC foram utilizadas.
O ambiente EDK também provê o controlador hwicap, que fornece acesso ao dispositivo ICAP, descrito na Seção 2.2.2.4, para aplicações executadas sobre o processador Microblaze ou PowerPC.
Desta forma, aplicações executadas sobre estes processadores podem alterar a memória de configuração do dispositivo, assim modificando o hardware existente.
A diferença do fluxo utilizado em para o fluxo apresentado no Capítulo 4 é na etapa inicial, em a qual todo o projeto é implementado no EDK e num segundo momento as macros são inseridas não no top do projeto, mas sim dentro de o módulo reconfigurável.
O restante do fluxo segue de forma semelhante à apresentada no Capítulo 4.
Este estudo de caso apresenta a NoC Artemis conectada a dois módulos reconfiguráveis.
Três diferentes módulos reconfiguráveis podem ser substituídos em tempo execução neste sistema:
Dois detalhes importantes para aumentar a probabilidade do SDR funcionar corretamente são escolher os maiores módulos reconfiguráveis para iniciar o SDR e tentar restringir ao máximo a área dos módulos reconfiguráveis.
Estes dois cuidados evitam que a árvore de relógio, que não é reconfigurada junto com o módulo, possua uma configuração diferente em cada um dos projetos do sistema, conforme evidenciado na Figura 99.
Verificou- se na prática que a reconfiguração parcial do módulo raiz quadrada não funciona utilizando os projetos dos módulos multiplicação ou divisão como iniciais, somente quando o mesmo é o inicial.
Isto ocorre porque o módulo de raiz quadrada utilizou dois ramos da árvore principal de relógio, enquanto os outros dois módulos utilizaram somente um.
Logo, apenas o projeto com dois módulos de raiz quadrada possui a configuração do segundo ramo da árvore de relógio que possibilita o correto funcionamento para estes módulos reconfiguráveis e não apresenta problemas para os módulos de divisão e multiplicação onde este segundo ramo não é utilizado.
Para verificar o correto funcionamento do SDR, prototipou- se o projeto inicial com os dois módulos de raiz quadrada e a partir de o computador hospedeiro enviou- se um pacote através do módulo serial para interromper a comunicação da NoC com o módulo a ser reconfigurado.
A seguir efetuou- se a configuração do bitstream parcial com o módulo de divisão ou raiz quadrada e restabeceu- se a comunicação da NoC com o módulo reconfigurável.
Após isso todos os módulos foram verificados, garantindo que o SDR continua funcionando conforme o esperado após a reconfiguração parcial e dinâmica.
Sob o ponto de vista de sistemas parcial e dinamicamente reconfiguráveis não há diferença entre reconfigurar processadores e reconfigurar módulos.
A Figura 100 apresenta um SDR semelhante ao apresentado na Seção anterior, com a diferença de possuir um processador MR2 ou R8 conectado ao roteador inferior esquerdo da NoC Artemis.
O processador MR2 pode ser substituído em tempo execução por o processador R8 e vice-versa ou por os módulos reconfiguráveis previamente apresentados de multiplicação, divisão e raiz quadrada.
Aplicações em MPSoCs possuem requisitos diferenciados.
Por exemplo, para operações que não exigem alto desempenho, uma CPU simples de 16 bits pode ser suficiente.
Para aplicações mais complexas, como tratamento digital de sinais, processadores mais complexos são necessários.
Este experimento mostra que é possível configurar os processadores conforme a aplicação a ser executada e que é possível também utilizar processadores especializados para determinadas tarefas, sem necessariamente ter- los configurados o tempo todo.
BRAMs/ multiplicadores, enquanto o módulo reconfigurável inferior é conectado por macros implementadas sobre colunas de CLBs.
A Figura 101 apresenta o roteamento do projeto inicial de módulos estaticamente realocáveis conectados à NoC Artemis.
Como este estudo de caso foi implementado num dispositivo Virtex-II XC2 V1000, apenas 3 módulos foram conectados à NoC para simplificar o roteamento:
Um módulo serial posicionado na parte fixa do sistema e dois módulos reconfiguráveis denominados &quot;double «e &quot;not».
O módulo &quot;double «soma um parâmetro de 16 bits recebido com ele mesmo e o módulo &quot;not «inverte todos os bits de um parâmetro de 16 bits.
Estes módulos ocupam 75 slices e 77 slices, respectivamente.
A reconfiguração destes módulos é dita estática porque uma parte do sistema (o segundo módulo reconfigurável posicionado na mesma coluna) possui a sua execução interrompida durante a reconfiguração.
Dois bitstreams parciais foram gerados a partir de a ferramenta CoreUnifier-II Para o.
Um realocando o módulo &quot;not «sobre a área do módulo &quot;double», e o outro realocando o módulo &quot;double «sobre a área do módulo &quot;not».
Estes bitstreams parciais permitem que a NoC possua dois módulos &quot;not «ou dois módulos &quot;double «conectados a ela a partir de um único projeto inicial através de realocação.
A macro utilizada por o sistema, também apresentada na Figura 101, possui duas diferenças em relação a as macros apresentadas na Seção 4.2.1.
Estas ocupam 4 colunas de CLBs e utilizam apenas 4 fios e 4 slices.
A utilização de um número maior de colunas pode ser o último recurso, quando não se está preocupado com área do FPGA, para evitar que linhas longas cruzem os limites das áreas, conforme apresentado à direita da Figura 101.
Também foi detectado em alguns projetos que, dependendo da posição origem dos sinais conectados à macro, podem não existir recursos de roteamento adequados num única linha de CLBs do FPGA.
A utilização de um roteamento inadequado na interface de módulos pode ser percebida quando linhas longas são utilizadas para interconectar pontos de origem e destino próximos ou quando diversas linhas curtas são utilizadas para interconectar pontos de origem e destino distantes.
Em estes casos, uma alternativa é utilizar um número maior de macros em diferentes linhas de CLBs do FPGA, com um número menor de fios por macro, conforme a macro apresentada à direita da Figura 101.
Apesar de simples o conceito de realocação, este estudo de caso evidenciou a dificuldade prática da implementação desta técnica em dispositivos Xilinx.
A opção de realizar inicialmente a realocação vertical teve por objetivo verificar a factibilidade de realocação.
Comprovou- se neste estudo de caso que realocação é possível nestes dispositivos.
A Seção anterior apresentou a realocação vertical parcial e estática de módulos de hardware.
O objetivo desta Seção é validar a realocação horizontal parcial e dinâmica, assim validando a etapa opcional do fluxo de SDRs proposto no Capítulo 4 e a ferramenta CoreUnifer-II Para o.
No entanto, ainda não foi possível rotear módulos, conforme apresentados nos estudos de casos anteriores, apenas rotear CLBs para serem horizontalmente realocáveis.
Esta dificuldade na realocação horizontal ocorre devido a a irregularidade dos FPGAs Xilinx com relação a as colunas de multiplicadores e BRAMs.
Estas colunas tornam- se &quot;âncoras «para módulos reconfiguráveis, que só podem ser realocados horizontalmente de 6 em 6 colunas de CLBs, no caso de os dispositivos VirtexII Para o, assim dificultando as opções de posicionamento e, por conseqüência, roteamento.
Quando o CoreUnifier-II Para o reconfigurar uma CLB, será exibido no display um índice de CLB, com um novo conteúdo, atribuído por realocação.
O estudo de caso apresentado nesta Seção possui 8 CLBs realocáveis, onde cada CLB possui uma constante diferente armazenada.
O projeto inicial possui na CLB 0, a constante 8;
em a CLB 1, a constante 9;
e assim por diante. A o pressionar- se um push-button da plataforma de prototipação, exibe- se em display de 7 segmentos o número de uma CLB e a sua respectiva constante armazenada.
A o pressionar- se novamente o mesmo push-button, exibe- se o número da próxima CLB e a sua respectiva constante armazenada.
Desta forma quando uma CLB é realocada através do CoreUnifier-II Para o a constante da CLB de origem é mostrada na CLB de destino da realocação.
O roteamento deste projeto é apresentado na Figura 102.
Este sistema é dito dinamicamente reconfigurável porque a modificação de uma parte do sistema não afeta outras.
A computação reconfigurável é indubitavelmente uma área promissora para sistemas que necessitam de flexibilidade e desempenho.
Potência é uma terceira característica importante, porém não contemplada no escopo do presente trabalho.
Intuitivamente, pode- se argumentar que havendo menos componentes no SoC, haverá um menor consumo de potência.
Entretanto, Becker et al.
Mostraram que durante o processo de reconfiguração o consumo de potência é elevado.
A demanda por estes requisitos (flexibilidade, desempenho e potência) tem sido verificada principalmente em dispositivos portáteis.
Estes devem ser compatíveis com diversos protocolos de redes sem fio, fotografar, filmar, jogar, habilitar a comunicação por voz, navegar na Internet, escutar música armazenada local ou remotamente, enviar e receber mensagens de texto, funcionar como localizador geográfico, reproduzir vídeos e ainda executar algoritmos avançados de criptografia (AES, Des, BlowFish) para não permitir que a comunicação ou os dados armazenados no dispositivo possam ser interceptados por um agente externo mal intencionado.&amp;&amp;&amp;
No entanto, a computação reconfigurável ainda não é amplamente utilizada em produtos comerciais.
Um dos motivos que inibe o seu uso é a dificuldade de conseguir tirar proveito adequado desta tecnologia para alcançar o desempenho esperado.
Foi visando suprir esta demanda que o presente trabalho buscou contribuir.
As próximas Seções apresentam um resumo do trabalho desenvolvido, uma análise das contribuições e indicações de trabalhos futuros.
O estudo do estado da arte apontou as diferentes formas de se fazer uso da computação reconfigurável e diferentes dispositivos em os quais sistemas reconfiguráveis podem ser implementados.
Entre estes, os dispositivos Xilinx chamam a atenção devido a a disponibilidade de documentação e trabalhos relacionados no assunto, tanto no meio acadêmico quanto na indústria, de ferramentas que permitem interagir nas fases intermediárias da descrição de hardware à prototipação em FPGA.
O mesmo fabricante se destaca dos demais neste assunto quanto a a diversidade de plataformas e à alta densidade em termos de portas lógicas dos dispositivos oferecidos.
A partir de isso, o restante do documento explorou especificamente as características dos FPGAs Xilinx, estudando os fluxos para a implementação de sistemas parcial e dinamicamente reconfiguráveis.
Em relação a estes fluxos, constatou- se uma série de dificuldades e limitações no emprego dos mesmos, motivando o desenvolvimento de um novo fluxo que contornasse alguns dos problemas apontados.
A proposta de um novo fluxo de projeto para a implementação de SDRs evitou o uso de macros baseadas em tristates, utilizou ferramentas baseadas no fluxo de projeto padrão e apresentou dois métodos para a geração de bitstreams parciais compatíveis com os dispositivos Virtex-II e Virtex-II Para o.
A este fluxo, adicionou- se a possibilidade de gerar bitstreams parciais a partir de a realocação de módulos de um SDR através da ferramenta CoreUnifier-II Para o.
No entanto, o fluxo proposto sofre dos mesmos problemas enfrentados por os fluxos existentes em relação a o roteamento.
Para auxiliar neste quesito, diversos artifícios de projeto e implementação foram sugeridos ao longo de o documento.
De forma a atender as demandas de comunicação de futuros SDRs, uma NoC foi modificada para permitir que módulos reconfiguráveis fossem dinamicamente conectados a ela.
Esta NoC, denominada Artemis, habilita o isolamento dos módulos reconfiguráveis para que a reconfiguração do FPGA não interfira com o restante do sistema que continua operando.
Outra característica da Artemis é um mecanismo de segurança em hardware que descarta pacotes de dados quando estes são enviados (erroneamente) para um módulo que se encontra em processo de reconfiguração, evitando assim situações de erro que possam conduzir a bloqueios permanentes da rede.
O fluxo de projeto proposto e a NoC Artemis foram empregados na prática em estudos de caso apresentados no Capítulo 6.
O fluxo, uma vez dominado e seguido conforme apresentado, não reportou erro durante a sua execução.
A reconfiguração parcial e dinâmica de módulos foi atingida na prática.
A realocação dinâmica de módulos conectados à NoC Artemis não foi alcançada até o fechamento do presente trabalho, apenas a realocação estática de módulos e a realocação dinâmica de poucas CLBs.
Segundo a visão do Autor, este trabalho contribui em 7 diferentes aspectos:
Fluxo de projeto para SDRs:
Propôs- se uma nova forma de implementar a reconfiguração parcial e dinâmica de dispositivos Xilinx baseada nas ferramentas padrões.
A vantagem deste fluxo é ser menos suscetível a erros (em relação a fluxos que utilizam Bus Macros), ser mais simples de ser executado (em relação a o fluxo de Projeto Modular e ao fluxo de Palma executado por o Autor em e) e ser compatível, a princípio, com todos os FPGAs atuais que suportam reconfiguração parcial e dinamica da Xilinx.
NoC Artemis: Uma NoC que habilita a reconfiguração parcial e dinâmica de módulos conectados a ela.
A NoC Artemis provê mecanismos (e.
g pacotes de controle, isolamento do módulo reconfigurável, descarte de pacotes) que possibilitam a reconfiguração de uma parte do FPGA sem interferência no restante do sistema.
Macros: Este trabalho propôs a utilização de macros baseadas em LUTs, eliminando a possibilidade de fios se conectarem no lado errado da macro, conforme verificado nas Bus Macros.
As macros propostas podem ser modificadas para facilitar o roteamento do SDR.
Geração de bitstreams parciais:
Duas alternativas para a geração de bitstreams parciais através do método de extração de frames foram apresentadas.
Uma alternativa é através da ferramenta BitGen com o auxílio da ferramenta BitMask.
A segunda alternativa é através da ferramenta CoreUnifier-II Para o.
Realocação: Também foi adicionada à ferramenta CoreUnifier-II Para o a possibilidade de realocar módulos de hardware de SDRs.
A realocação, embora difícil de ser empregada na prática, pode reduzir o gasto em memória de sistemas auto-reconfiguráveis para armazenamento de bitstreams com configurações do sistema.
Ferramenta de verificação de roteamento:
A ferramenta XDLAnalyzer foi proposta para analisar todos os sinais de um projeto, verificando se algum de eles atravessa a fronteira do módulo de origem sem passar por macros.
Interconexão do processador MR2 à NoC:
Foi no contexto do presente trabalho que ocorreu o porte do processador MR2 para a NoC.
Para isto foi criado um wrapper para o processador MR2 que conecta a NoC e as caches de instruções e dados ao processador.
Este porte buscou reduzir ao máximo o consumo em área, resultando na criação de drivers para a comunicação com outros módulos da NoC.
Entre as atividades previstas para o futuro imediato e de médio prazo, cita- se:
Atividades relacionadas à arquitetura reconfigurável:
Utilizar o ICAP para fazer a auto-reconfiguração do SDR;
Sinalizar o término do processamento de módulos reconfiguráveis para o processador MR2 através de interrupções.
Atividades relacionadas a ferramentas para SDR:
Implementar de forma efetiva realocação em hardware;
Atualizar a ferramenta CoreUnifier-II Para o para tornar- la compatível com a Virtex 4;
Utilizar uma metodologia semelhante ao fluxo de Projeto Modular onde cada módulo do sistema é uma macro, metodologia esta que pode ser denominada macro-based design;
Automatizar o processo de inserção de macros em SDRs;
Permitir que o XDLAnalyzer refaça roteamentos que não atendem o fluxo de SDRs de forma automática;
Salvar e recuperar o contexto de módulos reconfiguráveis, permitindo a reconfiguração de um módulo que compartilhe a mesma coluna de outro módulo reconfigurável.
Atividades relacionadas a redes intra-chip:
Inserir a capacidade de gerar a NoC Artemis na ferramenta Maia;
Desenvolver um adaptador para NoCs, de forma que outras NoCs possam acoplar módulos dinamicamente reconfiguráveis;
Permitir a reconfiguração do meio de comunicação;
Conectar os processadores PowerPC, Microblaze e Picoblaze à NoC Artemis.
