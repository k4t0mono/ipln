Os avanços relacionados à tecnologia de fabricação de circuitos integrados impulsionam a complexidade e o número de funcionalidades dos produtos eletrônicos.
A literatura aponta que até 2015 tarefas do nível comportamental de projeto de sistemas eletrônicos ocuparão cerca de 50% do esforço de projeto, o que reforça a necessidade do desenvolvimento de ferramentas de automação e geração automática de circuitos.
Além disso, o projeto de circuitos atuais faz uso do paradigma de projeto síncrono, que associado ao crescimento da complexidade dos mesmos impõe restrições importantes com relação a o consumo de energia e à dissipação de potência.
Este trabalho se apresenta como uma solução alternativa para alguns destes problemas, por a proposta de um ambiente de geração e avaliação de redes intrachip.
Tais redes permitem, além de conectar módulos de processamento que operem em diferentes frequências, podem ajudar a garantir o atendimento de restrições temporais impostas por os requisitos de tráfego destes módulos.
Durante a geração da rede, o ambiente permite, em tempo de projeto, variar as características da mesma, tais como as frequências de operação dos roteadores, de forma individualizada.
Além de a geração da rede, o ambiente ainda habilita avaliar restrições temporais de diferentes modelos de tráfegos, dando suporte à parametrização do tráfego na rede.
Esta característica de permitir avaliar a rede através de um modelo de tráfego oferece alternativas para reduzir o esforço do projeto dos sistemas eletrônicos ainda nas fases de especificação de requisitos do sistema.
Isto ocorre por que o ambiente facilita a visualização do comportamento de um modelo de rede denotando se o mesmo atende ou não a requisitos esperados para um cenário de tráfego.
Palavras chave:
Geração de Redes, Geração de Tráfego, Redes Intrachip Não Síncronas, Avaliação de Tráfego.
Durante as últimas décadas, a evolução da tecnologia de fabricação de circuitos integrados sempre esteve diretamente relacionada às mudanças que ocorrem no processo de projeto de produtos eletrônicos.
Parte desta mudança tem relação com o crescimento do número de transistores dos circuitos integrados, componentes fundamentais na concepção dos produtos eletrônicos.
Em, após um estudo do crescimento anual dos circuitos, Moore identificou que a cada 18 a 24 meses dobra- se a quantidade de transistores que se podia construir sobre a mesma área de silício, resultando numa redução de custos e aumento do desempenho dos circuitos integrados segundo uma curva exponencial.
Este fato continuou a observar- se em décadas posteriores, dando origem à chamada Lei de Moore.
O estado da arte em semicondutores faz uso da Lei de Moore como uma das medidas e incentivos ao crescimento da complexidade dos circuitos.
O desafio para atender aos pressupostos da lei incentiva a indústria e a academia para investir somas consideráveis em pesquisa e desenvolvimento para manter o crescimento dentro de as expectativas da Lei de Moore.
Uma organização, o ITRS, do inglês &quot;International Technology Roadmap for Semiconductors», tem como objetivo analisar e prever o crescimento do mercado de semicondutores.
Como resultado destes esforços, em, Arden Demonstram existirem subsídios tecnológicos para o projeto de circuitos integrados capazes hoje de superar os pressupostos da Lei de Moore.
Em são apresentados os desafios a serem vencidos para que as próximas escalas de fabricação capazes de superar o estado da arte atual estejam operacionais.
Os documentos detalham que até 2016 a escala de fabricação estará homologada para desenvolver circuitos com dimensões de 450 mm de diâmetro.
O reflexo do esforço e da disponibilidade tecnológica oferecida é visualizado em produtos que fazem uso das tecnologias de fabricação mais recentes.
Até onde se têm conhecimento, o menor processo de fabricação utilizado nos dias atuais, é descrito em que faz uso da tecnologia de fabricação de escala de 22 nm fazendo uso de substratos de 300 mm.
Em é apresentado um circuito integrado para operações de computação de High Performance Computing ou HPC, que contêm 7.1 bilhões de transistores, capaz de atingir desempenho sustentável de 1 Teraflop, que representa um trilhão de operações de ponto flutuante em precisão dupla.
Previsões indicam que este circuito será disponibilizado no terceiro trimestre do ano de 2012 com tecnologia de fabricação 28 nm.
Em é apresentado um circuito integrado com função de coprocessador, que apresenta desempenho sustentável de Teraflop.
Este circuito já é fabricado utilizando tecnologia de fabricação 28 nm, e aplicado em supercomputadores de propósito especifico.
Ainda durante as últimas décadas, a evolução nos projetos de circuitos integrados evoluiu do desenho manual de transistores ao uso de linguagens de descrição de hardware e ferramentas de síntese, que a partir de a descrição abstrata efetuam a geração automática do projeto em nível físico do circuito.
Um dos maiores desafios do projeto de sistemas eletrônicos está no atendimento de restrições e pré-requisitos do sistema.
Uma das alternativas para superar estes desafios está no desenvolvimento de ferramentas de automação e geração automática de circuitos.
Estas devem ser tais que possam utilizar como entrada as restrições e pré-requisitos do circuito a ser gerado.
Em aponta- se que até 2015, o nível comportamental do projeto de sistemas eletrônicos ocupará cerca de 50% do esforço de projeto, o que reforça a necessidade de desenvolvimento de ferramentas de automação e geração automática de circuitos.
Em as últimas duas décadas, o desenvolvimento de sistemas eletrônicos compostos múltiplos elementos de processamento implicava sistemas compostos por diversos circuitos integrados distintos.
Com a disponibilidade tecnológica atual, é possível desenvolver sistemas eletrônicos completos num único circuito integrado.
Para esse tipo de circuito, se dá o nome de sistema eletrônico estão encapsulados num mesmo circuito integrado.
Tal tipo de sistema reúne uma série de vantagens, algumas de elas diretamente relacionadas à redução dos custos de encapsulamento e de manufatura do produto.
Esta tendência de projeto tende a reduzir os esforços em tempo de projeto.
Por consequência, o sistema se torna mais competitivo.
Outra técnica para aumentar a competitividade, e capaz de fazer uso da disponibilidade tecnológica para aumentar o número de funcionalidades dos sistemas eletrônicos, é o reuso de componentes que compõem um sistema eletrônico.
Com o reuso maciço de componentes, o projeto de um SoC passa a consistir a montagem do sistema a partir de uma maioria de módulos pré-validados e pré-caracterizados.
Contudo, a interconexão em si de grande número de módulos não é tarefa trivial, sobretudo quando de a interconexão depende a viabilidade do sistema como um todo.
Uma arquitetura de interconexão deve ser capaz de permitir que componentes comuniquem- se entre si de forma eficiente.
Diversos modelos de arquiteturas de interconexão foram propostas e difundidas.
Em geral, uma arquitetura de interconexão deve garantir:
Eficiência energética e confiabilidade escalabilidade e largura de banda reusabilidade.
Um modelo de arquitetura de interconexão capaz de atender a estes requisitos, e que contém atualmente grande apelo comercial e gera muitos esforços em pesquisa Assume- se por convenção neste trabalho, que o termo rede intrachip será referenciado unicamente por o termo rede.
Em este modelo de rede, as decisões de arbitragem e roteamento da informação são tratadas de maneira distribuída, variando conforme as políticas de roteamento adotadas.
Este modelo de arquitetura deriva suas propriedades da adaptação de conceitos provenientes de redes de computadores e/ ou de sistemas distribuídos, existindo assim, semelhanças quer seja na disposição de protocolos, seja no encaminhamento de informação e até na sincronização da informação.
Por outro lado, o projeto dos circuitos integrados atuais faz uso majoritário do paradigma de projeto síncrono, em que um único sinal sincronizador é usado para coordenar todos os eventos que acontecem no circuito.
Este paradigma foi adotado por favorecer a simplicidade e exigir pouca lógica para sincronizar eventos.
Devido a a crescente redução na escala dos componentes eletrônicos, o número de componentes a serem sincronizados, e por consequência o número de fios necessários para interconectar estes componentes ao sinal sincronizador, aumentam na mesma proporção.
Em, os autores apontam que 45% do total da potência consumida por um processador de alto desempenho da época, era devida ao processo de distribuição do sinal de sincronização (relógio) do circuito.
A solução para as restrições impostas por o modelo síncrono, que estão ligadas diretamente ao consumo de energia e à dissipação de potência, são temas de pesquisa e de interesse crescente do mercado.
De entre algumas das soluções apresentadas na literatura, destacam- se os circuitos que independem de sincronizadores, e circuitos que fazem uso de múltiplos sinais de sincronização.
O modelo que independe de sincronizadores, referenciado por modelo assíncrono, faz uso de protocolos de comunicação e sincronização locais no lugar da lógica baseada num sinal de sincronização global.
As principais vantagens dessa abordagem estão na eliminação dos problemas causados por o sinal de sincronização, apresentando maior robustez se comparada a circuitos que fazem uso do sinal de sincronização.
Esta técnica é pouco adotada em SoCs hoje em dia, por a carência de ferramentas de projeto e de recursos humanos aptos para dar suporte à tecnologia.
Outra solução para libertar- se do modelo síncrono é aquela que faz uso de múltiplos sinais de sincronização.
Em esta abordagem, conhecida em inglês por o termo Globally Asynchronous Locally Synchronous ou GALS, o circuito é particionado, e as partes resultantes costumam ser referenciadas na literatura como ilhas, onde cada ilha possui um sinal de sincronização, podendo estes sinais ser diferentes uns dos outros.
Cada sinal de sincronização possui uma árvore de distribuição de relógio própria.
Para garantir a sincronização entre as ilhas, usam- se interfaces de sincronização, capazes de garantir a comunicação entre ilhas.
De acordo com o ITRS, o uso da técnica GALS no projeto de circuitos com foco em baixo consumo de energia, é considerada como a segunda melhor técnica para redução no consumo de energia dinâmica de sistemas complexos, no mesmo nível de qualidade de técnicas de DVFS, do inglês Dynamic Voltage Frequency Scaling, em que a voltagem e a frequência do circuito são ajustadas dinamicamente, conforme a demanda de operação do circuito.
A carência de recursos de especificação, verificação e síntese para sistemas não síncronos dá sentido a um esforço em pesquisa para fazer evoluir as técnicas de especificação, verificação e síntese de SoCs GALS em geral, e de arquiteturas de comunicação para tais SoCs em particular.
O interesse em redes de interconexão que utilizam a abordagem GALS como tema de pesquisa possibilita explorar alternativas no projeto de circuitos em que as restrições ocasionadas por a distribuição e consumo de potência do sinal de relógio possam ser evitados.
Além disso, a abordagem GALS favorece o reuso de componentes.
Em esta, componentes pré-projetados e prévalidados sobre diferentes domínios de frequência podem garantir que requisitos de projeto como o tempo máximo para que um produto chegue ao mercado, sejam atendidos.
Tal realidade reforça a motivação para existir um conjunto de técnicas capazes de permitir a geração e avaliação de tráfego em NoCs que operem sobre diferentes domínios de frequência num nível mais alto de abstração que aquele descrito na bibliografia atual.
O ambiente Atlas, proposto e mantido por o grupo de pesquisa do Autor dá suporte hoje ao processo de projeto de redes síncronas apenas.
Assim, existe uma infraestrutura de software extensa de a qual se pode partir para desenvolver e validar técnicas de especificação, verificação e síntese de NoCs não-síncronas.
Ainda, uma rede com suporte a SoCs GALS já foi proposta e validada por o grupo de pesquisa do Autor, e denomina- se Hermes-G.
Ou seja, à infraestrutura de software disponível (Atlas) se junta um suporte de hardware já previamente projetado e validado (Hermes-G).
Como objetivo geral neste trabalho, pretendeu- se desenvolver uma infraestrutura capaz de viabilizar a geração e avaliação da rede GALS Hermes-G. Para que o objetivo geral fosse atingido, um conjunto de objetivos específicos foi desenvolvido.
Estes consistem na inserção de suporte na ferramenta Atlas para:
A geração automatizada de instâncias quaisquer de redes GALS Hermes-G. A geração de tráfego sintético para redes GALS Hermes-G. A partir de grafos de aplicação do tipo CDCG, possibilitar gerar tráfego para redes Permitir a avaliação de tráfegos sintéticos em redes GALS Hermes-G. Possibilitar a avaliação de tráfegos gerados a partir de grafos CDCG em redes Hermes-G. O restante do documento é detalhado em 8 Capítulos, descrevendo os seguintes assuntos:
Hermes-G, uma das contribuições do trabalho.
Aplicações para redes do tipo Hermes-G, outra das contribuições do trabalho.
Este Capítulo realiza um estudo num conjunto de trabalhos relacionados, contendo alguns dos temas de pesquisa explorados por este trabalho.
De entre os temas pesquisados, esta o projeto de redes intrachip RTL capazes de operar sobre diferentes frequências de operação, e que de alguma forma, sejam passíveis de sofrer parametrização, e que estejam vinculadas a um ambiente de geração automatizada.
Outro tema de pesquisa, busca esclarecer como trabalhos relacionados caracterizam tráfego de rede.
O último tema pesquisado relaciona quais são as métricas de avaliação de tráfego, como são calculadas e como o desempenho de rede é mensurado por os trabalhos.
Por fim, é feita uma compilação e uma comparação dos temas pesquisados, com a proposta deste trabalho.
A seguir, será feita a revisão dos trabalhos, partindo da seguinte estratégia para cada um dos trabalhos.
Primeiramente é feito um resumo do trabalho, logo a seguir é dada ênfase a cada um dos temas de pesquisa detalhados anteriormente, e por fim, é feita a conclusão apresentando resultados do trabalho.
Fen Propõem criar diretrizes para que projetistas de redes intrachip escolham configurações de redes capazes de atender aos requisitos de desempenho das aplicações que usam a rede intrachip como meio de comunicação.
Os autores utilizam o ambiente OPNET para geração e simulação de redes intrachip.
Durante a geração, o autor descreve a possibilidade de gerar redes com topologias &quot;2D Mesh», Fat Tree &quot;e «Butterfly Fat Tree».
A Figura 1 ilustra a disposição dos roteadores e dos elementos de processamento em cada um das topologias possíveis de serem geradas.
Para cada topologia, o gerador permite utilizar duas politicas de chaveamento de pacotes, a &quot;Wormhole «e a &quot;Virtual Cut Through».
Cada uma das portas dos roteadores faz uso de uma fila, com capacidade máxima de até dois pacotes, sendo que cada pacote possui tamanho igual a 256 bits.
O processo de geração do tráfego proposto leva em consideração a distribuição espacial que define a relação entre a origem e o destino dos pacotes e a distribuição temporal que define o intervalo entre a geração dos pacotes do tráfego.
Os autores fazem uso de duas distribuições espaciais, a primeira, define os destinos de maneira aleatória, e a segunda, define os destinos do tráfego seguindo um critério de afinidade, em que os endereços vizinhos mais próximos do endereço gerador têm maior probabilidade de serem os destinos do tráfego.
A distribuição temporal não é detalhada, porem, o autor durante a avaliação do trabalho utiliza cenários variados com taxas de injeção definidas, o que caracteriza tráfego com distribuição temporal uniforme.
O processo de avaliação de tráfego utiliza como métrica de desempenho a vazão da rede, caracterizada por a média de bits recebidos por os elementos de processamento acoplados na rede, e a latência de pacote, caracterizada por o intervalo de tempo entre a entrada e a saída de um pacote da rede, tempo este medido em ciclos de relógio da rede.
Por fim, após a realização de um conjunto de experimentos, variando as características de rede propostas por o trabalho, os autores concluem que a arquitetura de rede com topologia &quot;Fat Tree «utilizando chaveamento de pacotes &quot;Wormhole», foi aquela capaz de atingir a maior vazão de rede e a menor latência de pacote.
Os autores destacam ainda que durante a avaliação dos experimentos propostos, as características impostas ao tráfego foram decisivas na obtenção dos resultados.
Kreutz, propõem o desenvolvimento de uma técnica capaz de encontrar a arquitetura de rede intrachip ótima para uma aplicação, onde para isso deva ser levando em consideração o compromisso de latência e consumo mínimo de energia.
Os autores descrevem que a proposta do trabalho faz uso de redes com topologias diretas e indiretas.
Em as topologias diretas, o trabalho dá suporte a &quot;2D Mesh «e &quot;Torus», usando roteamento determinístico XY.
Em a topologia indireta, o trabalho dá suporte a &quot;Fat Tree «usando roteamento adaptativo.
Em ambas as topologias são utilizadas as técnicas de chaveamento de pacotes &quot;Wormhole «e controle de fluxo baseado em créditos.
Os autores não descrevem existir suporte tanto a parametrização quanto de uma ferramenta de geração automatizada de redes.
O processo de geração do tráfego é feito através de modelos.
O trabalho faz uso de dois modelos, um definido como ACP, do inglês &quot;Application Communication Pattern», que define os custos de comunicação e dependências entre as tarefas, e outro, definido como CRG, do inglês &quot;Communication Resource Graph», que define a arquitetura de comunicação onde à tarefa deve ser mapeada.
A Figura 2 ilustra um exemplo da proposta, contendo um modelo ACP que define uma aplicação e um modelo CRG que define a arquitetura de comunicação, juntamente com a aplicação mapeada.
Em o trabalho, os autores propõem a utilização de um algoritmo de mapeamento e minimização de caminhos entre as tarefas, denominado &quot;Tabu Search».
Este algoritmo assume todas as combinações possíveis de mapeamento, buscando o melhor mapeamento possível, em compromisso com a menor latência possível e menor consumo de energia.
CRG, define a arquitetura de comunicação onde à tarefa vai ser mapeada.
O processo de avaliação de tráfego utiliza como métrica de desempenho a latência média gasta por todos os pacotes, medida em ciclos de relógio, e o consumo de energia gasto por uma aplicação para ser executada, medida em micro joules.
Por fim, após a realização de um conjunto de experimentos, variando as características de redes propostas, e usando um conjunto definido de aplicações descritas por a proposta do trabalho, os autores concluem que a rede &quot;Fat Tree «foi a que apresentou a menor latência de entre as redes propostas e as aplicações utilizadas, mas que a topologia &quot;2D Mesh «foi a que apresentou o melhor compromisso entre latência e consumo de energia.
Panades, apresentam uma rede intrachip chamada DSPIN, com suporte a serviços de entrega de pacotes na rede, capazes de sustentar num fluxo de pacotes um conjunto de restrições como latência máxima e vazão mínima.
A rede proposta por o autor é projetada como uma arquitetura de rede intrachip voltada para multiprocessadores com memória compartilhada.
DSPIN é caracterizada por uma topologia &quot;2D Mesh», chaveamento de pacotes &quot;Wormhole «e algoritmo de roteamento determinístico XY.
As principais características da rede DSPIN são O uso de canais virtuais nas portas de entrada dos roteadores, onde cada canal é responsável por transportar uma classe de serviço.
A rede proposta dá suporte a dois tipos de pacote, um considerado como de melhor esforço, do inglês &quot;Best Effort «e outro com garantia de serviço, do inglês &quot;Guaranteed Service».
Suporte a técnica GALS, entre roteadores e IPs.
Entre roteadores é possível existir defasagem entre as bordas dos relógios dos roteadores, mas todos os relógios devem trabalhar na mesma frequência.
Entre os roteadores e IPs a relação é inversa, sendo que é possível os relógios operarem em diferentes frequências, mas devendo estar sincronizados na mesma fase.
A rede DSPIN considera um módulo de processamento como um cluster, que podendo ser formados por diversos sub módulos, interconectados por sua rede local.
Cada cluster é conectado a um único roteador, que possui dois canais físicos, um para enviar e outro para receber dados da rede.
A Figura 3 ilustra uma arquitetura de cluster composta por três IPs do inglês &quot;Intellectual Property», uma rede local e um adaptador de rede.
Durante o processo de avaliação do trabalho, o autor cita algumas variações nas características da rede DSPIN, mas não detalha em nenhum momento se a rede é passível de parametrização, ou da existência um ambiente para geração automática da rede.
O processo de geração de tráfego é pouco detalhado, os autores citam durante o processo experimental fazer uso de distribuição espacial aleatória e de distribuição temporal uniforme, variando o comprimento dos pacotes num intervalo de um a dezesseis flits, sendo o &quot;flit», de tamanho fixo em 34 bits.
Não é mencionada a maneira como o comprimento dos pacotes é variado.
O processo de avaliação de tráfego utiliza como métrica de desempenho a latência medida em ciclos de relógio.
Como processos experimentais são propostos cenários de tráfego com variação nas taxas de injeção.
Os autores concluem que durante a utilização do serviço &quot;Guaranteed Service», mesmo tráfegos injetados na taxa máxima da rede, não há variação na latência dos pacotes.
Em contrapartida, durante a utilização do serviço &quot;Best Effort», tráfegos injetados em 25% da capacidade da rede, apresentam variações bruscas no aumento da latência.
Em Ost, os autores apresentam o ambiente Maia, que possibilita geração e avaliação de redes intrachip.
O trabalho apresenta o ambiente e demostra algumas das funcionalidades existentes.
O ambiente Maia, possibilita a geração de redes intrachip, modeladas através de &quot;templates «parametrizáveis da rede Hermes.
Esta rede dá suporte a diferentes topologias de redes, comprimentos nas filas de entrada dos roteadores, algoritmos de roteamento determinísticos e adaptativos e diferentes técnicas de controle de fluxo.
Durante o processo de geração da rede, o projetista pode optar por a geração de interfaces externas a rede, existindo duas possibilidades, a interface nativa da rede ou uma interface OCP, do inglês &quot;open core protocol».
A Figura 4 ilustra a interface gráfica de usuário de geração de redes do ambiente Maia, e descreve suas funcionalidades.
O processo de geração de tráfego do ambiente Maia, é feito a partir de um módulo do ambiente chamado &quot;Traffic Generation», responsável por implementar a interface gráfica que permite parametrizar o tráfego, e por gerar os arquivos que compõem o tráfego a ser transmitido na rede.
O gerador permite variar os parâmetros que definem o tráfego, sendo eles, a taxa de injeção do tráfego, o número de pacotes, o tamanho dos pacotes e os destinos do tráfego, que podem ser fixados num endereço da rede, ou definidos de maneira aleatória.
A avaliação do tráfego é feita a partir de um módulo do ambiente Maia chamado &quot;Traffic Analysis», que usa arquivos que coletam informações dos pacotes durante a simulação da rede.
O processo de avaliação é feito após o termino da simulação.
De entre as métricas de desempenho utilizadas para avaliar o tráfego estão o número de pacotes recebidos, o tempo médio de entrega dos pacotes, o tempo total de entrega dos pacotes e o tempo total de simulação da rede, todos eles calculados em ciclos de relógio da rede.
Durante o processo experimental os autores propõem variar as características de algumas redes disponibilizadas por o ambiente, obtendo algumas conclusões como que tráfego que contem pacotes menores obtém melhor desempenho em redes com algoritmos de roteamento adaptativos e tráfegos com pacotes maiores obtêm maior desempenho em algoritmos de roteamento determinísticos.
Em Pontes, propõem o desenvolvimento de dois roteadores GALS, baseados no roteador Hermes, ambos com objetivo de redução no consumo de energia da rede.
As redes propostas por este trabalho são:
Hermes-g. Hermes-glp.
Ambos os roteadores são baseados no roteador Hermes, descrito originalmente por.
Ambas as redes são compostas por as seguintes características, roteamento determinístico XY, controle de fluxo baseado em créditos, chaveamento de pacotes &quot;Wormhole «e largura dos canais dos roteadores igual a 16 bits.
O principal componente que diferência as redes propostas da rede Hermes são as filas utilizadas nos roteadores.
Em a rede Hermes, é feito uso de uma fila síncrona como componente de entrada nos roteadores, onde leituras e escritas entre os roteadores são feitas na mesma fase e na mesma frequência.
As redes Hermes-G e Hermes-GLP utilizam uma fila bi síncrona, que permite que escritas e leituras na fila sejam feitas tanto na mesma, como em diferentes frequências, podendo ou não estar na mesma fase.
A Figura 5 ilustra a arquitetura da fila, composta por uma memória, que armazena os dados e por uma lógica de codificação de ponteiros de leitura e de escrita, que garante que mesmo que ambos os ponteiros utilizados para ler e escrever na fila operem em diferentes domínios de relógio, ambos sempre estejam sincronizados.
Além de a fila bi síncrona, o roteador Hermes-GLP possui um componente que ajusta a frequência do roteador, do inglês &quot;Clock Gating «com base em valores de prioridade definidos e implementados através de um campo de prioridade nos pacotes do tráfego.
O processo de geração de tráfego é pouco detalhado, uma vez que os autores o citam unicamente durante o processo experimental do trabalho.
Em resumo, a distribuição espacial do tráfego não é explorada, os autores apenas utilizam tráfego com origens e destinos estáticos.
A distribuição temporal é uniforme, usando a taxa máxima de injeção dos IPs.
Como avaliação do tráfego, é feito uso da latência média de pacote como métrica de desempenho.
Durante o processo experimental, é comparado o tempo adicional ocasionado por o mecanismo que varia a frequência dos roteadores com base nas prioridades dos pacotes, e quais são as taxas de ativação dos roteadores numa rede Hermes-GLP.
Os resultados demostram que não houve acréscimo significante na latência dos pacotes por o uso do mecanismo que altera a frequência do roteador com base na prioridade nas redes Hermes-GLP.
Além disso, os resultados apresentam existir diferenças significativas na a taxa de ativação entre um roteador e outro, o que demostra a principal vantagem da rede Hermes-GLP na redução de energia comparada a rede Hermes-G. Em Bononi Os autores comparam diferentes arquiteturas de redes intrachip utilizando tráfego sintético e tráfego real, demostrando o impacto do tráfego e da arquitetura simulação da rede.
Este ambiente permite gerar diferentes topologias.
O trabalho faz uso de quatro topologias, ilustradas por a Figura 6 e descritas a seguir:
&quot;2D Mesh «&quot;Ring Spidergon Crossbar».
Em todas as topologias são utilizados algoritmos de roteamento determinísticos mínimos, livres de situações de impasse, do inglês &quot;deadlock».
O simulador utilizado usa precisão em nível de flit, onde todos os roteadores se comunicam de maneira síncrona.
Crossbar. O processo de geração de tráfego é feito através da ferramenta Scotch que a partir de grafos de aplicações, permite modelar tráfego sintético e tráfego real.
A ferramenta Scotch realiza o particionamento e o mapeamento da aplicação através de dois grafos, um que descreve a aplicação e outro que descreve a topologia e as demais características da rede, e leva em consideração a melhor combinação possível que explore o melhor desempenho da rede.
O processo de avaliação do tráfego utiliza como métrica de desempenho o tempo de processamento de uma aplicação real em ciclos de relógio, e a vazão média da rede.
Durante o processo experimental, os autores avaliam todas as topologias de rede propostas sobre diferentes cenários de aplicações sintéticas, onde o modelo de particionamento e mapeamento das tarefas é variado.
Além disso, os autores fazem uso de um cenário de aplicação real MPEG, do inglês &quot;Moving Picture Experts Group «utilizando diferentes topologias de rede propostas.
Como resultados os autores concluem que a topologia de rede &quot;Crossbar «foi a que atingiu melhor desempenho de entre as demais topologias comparadas.
Além disso, os autores destacam a importância do particionamento e do mapeamento, sendo eles os critérios mais importantes para obter o melhor desempenho da rede.
Em Tedesco, os autores apresentam métodos para geração e avaliação de tráfego em redes intrachip, onde é proposta uma abordagem alternativa de avaliação de desempenho, que leva em consideração os canais que interligam os roteadores, possibilitando avaliar em quais pontos da rede os requisitos do tráfego não estão sendo atendidos.
Os autores utilizam a rede intrachip Hermes em seu trabalho, esta rede, possui topologia &quot;2D Mesh», suporte a canais virtuais, roteamento determinístico XY e adaptativos West--First, chaveamento de pacotes &quot;Wormhole», controle de fluxo baseado em créditos e &quot;Handshake «e suporte a parametrização do comprimento dos canais que interligam os roteadores.
O tráfego proposto por o autor faz uso da distribuição espacial complemento para definir os iniciadores e destinatários do tráfego.
O intervalo em que os pacotes são colocados na rede é dado de maneira uniforme.
Além de a taxa de injeção, o autor permite parametrizar o número de pacotes em flits de cada tráfego injetado por um IP.
O processo de avaliação do tráfego é descrito ao longo de o trabalho como a principal contribuição.
O modelo proposto permite que o tráfego seja avaliado tanto nos pontos de injeção e coleta de dados da rede, caracterizado como &quot;Abordagem Externa «quanto nos canais que interconectam os roteadores, caracterizado como &quot;Abordagem Interna».
Em a abordagem externa, os resultados são obtidos nas interfaces externas da rede, já na abordagem interna, é possível obter detalhes entre os canais que interligam os roteadores, e entender em quais pontos, a rede apresenta maior e menor índice de atividade ou ociosidade.
Como métricas de avaliação de desempenho, os autores fazem uso de vazão e de latência, tanto para a abordagem externa, quanto para a abordagem interna.
O processo experimental é feito através de cenários de redes Hermes, fazendo uso de algoritmos de roteamento determinísticos e adaptativos, e uso de canais virtuais, que multiplexam um canal físico, o que permite em alguns casos, um melhor aproveitamento da rede.
Através da técnica de avaliação interna, o autor demostra a possibilidade de detectar em quais pontos a rede estava causando a saturação no tempo de transmissão dos pacotes.
Além disso, os autores demostram as vantagens no uso de canais virtuais, capaz de em alguns cenários aumentarem as taxas de tráfego aceito.
Ainda em Tedesco, os autores desenvolvem um novo trabalho propondo evolução no processo de geração de tráfego, com objetivo de comparar o desempenho de uma rede quando diferentes modelos de tráfegos são utilizados.
As questões relacionadas à geração de redes permanecem as mesmas descritas em.
O processo de geração de tráfego proposto por os autores destaca a importância de dirigir a modelagem do tráfego conforme as características de uma aplicação.
O trabalho de caracterização do tráfego proposto leva em consideração os requisitos de entrega das aplicações.
Os autores propõem um modelo de tráfego capaz de variar os seguintes parâmetros de um tráfego:
Tamanho dos pacotes Intervalo de geração de um pacote Intervalo de ociosidade entre pacotes.
Os autores fazem uso da distribuição de probabilidade normal e Pareto on-off para variar os intervalos de geração e ociosidade dos tráfegos.
O ambiente de avaliação de tráfego faz uso das mesmas métricas descritas em, sendo que durante o processo experimental, são proposto dois cenários compostos por redes Hermes de tamanho 8x8 com 16 bits de largura dos canais entre os roteadores e 8 flits de profundidade nas filas de entrada dos roteadores, que operam a 50 MHz.
Em ambos os cenários, a distribuição espacial é ilustrada por a Figura 7 (c), sendo um tráfego de voz, gerado por os roteadores 0 e 7 para o roteador 63, e um tráfego de vídeo, gerado do roteador 24 para o roteador 52, e do roteador 39 para o roteador 60.
A diferença entre ambos os cenários esta na forma como os pacotes são injetados na rede.
O primeiro cenário representado por o tráfego de voz realiza a injeção de pacotes conforme ilustra a Figura 7 (a), seguindo as características de tráfego CBR, do inglês &quot;Constant Bit «Rate», onde a taxa de injeção é continua ao longo de o tempo.
O segundo cenário representado por o tráfego de vídeo realiza a injeção de pacotes conforme ilustra a Figura 7 (b), seguindo as características de tráfego VBR, do inglês &quot;Variable Bit «Rate &quot;onde a taxa de injeção varia entre períodos «on- off».
A mesma quantidade de pacotes foi utilizada em ambos os tráfegos, injetados sob as mesmas taxas de injeção.
Como resultados, os autores concluem que o segundo cenário que utiliza o modelo VBR apresentou melhores resultados em relação a a variação da latência média de todos os pacotes.
Liu, propõem uma abordagem de caracterização de tráfego em NoCs a partir de aplicações reais.
Os objetivos do trabalho demostram à complexidade envolvida no processo de caracterização do tráfego e nos ganhos da proposta comparadas a distribuições de tráfego sintéticas, amplamente utilizadas por trabalhos relacionados.
Os autores utilizam o ambiente MCSL, que dá suporte a simulação de redes com precisão de ciclo, e dá suporte as topologias &quot;2D Mesh», &quot;Torus «e &quot;Fat Tree».
O processo de geração de tráfego, descrito por o autor como uma metodologia de caracterização de tráfego foi proposto a partir de um conjunto de oito aplicações reais, descritas originalmente para MPSoCs, do inglês características que um tráfego deve assumir.
De entre elas estão o modelo da aplicação e o modelo da arquitetura, ambos descritos através de grafos.
O modelo da aplicação descreve o tráfego, no que tangem os custos de comunicação e de computação de uma aplicação.
Já o modelo da arquitetura descreve as características desejadas da rede, incluindo os parâmetros dos recursos e a capacidade dos elementos de processamento.
O processo de avaliação de tráfego utiliza como métrica de desempenho a vazão total da rede e os atrasos de todos os pacotes medidos entre o envio e recebimento dos pacotes do tráfego.
O processo experimental varia as topologias suportadas por o trabalho sob diferentes tamanhos de redes, onde tráfego sintético uniforme é comparado com modelos de aplicações descritas através da abordagem proposta.
Em geral, os autores concluem avaliando vazão da rede e latência dos pacotes, que o modelo proposto comparado a tráfego sintético uniforme, por ter a capacidade de concentrar tráfego tanto espacialmente quanto temporalmente trouxe maior precisão aos resultados.
Hong, propõem avaliar o desempenho de uma rede de topologia &quot;Torus «com suporte a roteamento &quot;Backtracking», fazendo uso de tráfego sintético orientado a aplicações.
A rede utilizada possui como características, topologia &quot;2D Torus», 32 bits de largura de dados entre os roteadores e algoritmo de roteamento &quot;Backtracking».
O roteamento segue a ideia do menor caminho entre a origem e o destino do tráfego, possuindo protocolo de chaveamento de pacotes de três fases, sendo elas:
Chaveamento do circuito Transmissão do pacote Liberação do circuito.
O chaveamento é feito através de um pacote que contem o destino do tráfego, que pode ou não assumir um caminho alternativo ao menor caminho caso encontre bloqueios durante o chaveamento do circuito.
A transmissão dos pacote ocorre flit a flit, já a liberação do circuito é feita através de um pacote que libera o caminho.
O processo de geração de tráfego dá suporte a tráfego sintético dirigido a aplicações.
Pacotes são gerados conforme três parâmetros, sendo eles a distribuição espacial, a distribuição do intervalo de geração entre os pacotes e o tamanho dos pacotes.
A distribuição espacial, que descreve a relação entre a origem e o destino dos pacotes, é variada de três maneiras, sendo elas:
Uniforme &quot;Locality Transpose».
Em a uniforme, a quantidade total de pacotes é distribuída de maneira proporcional entre todos os destinos disponíveis para receber tráfego na rede.
Em a distribuição &quot;Locality», os pacotes são distribuídos de maneira uniforme, porém, com uma relação de afinidade entre os vizinhos próximos a origem do tráfego.
Em a distribuição &quot;Transpose», o destino do tráfego é a sua matriz transposta do endereço origem do tráfego.
A distribuição temporal é feita através de uma distribuição de probabilidade Poisson onde a taxa de injeção dos pacotes é fixa e o tempo de idle de cada pacote é variado.
A distribuição de tamanho de pacote é parametrizável, podendo ser feita de três formas, sendo elas de tamanho de pacote curto, médio e longo.
O processo de avaliação de tráfego utiliza como métrica de desempenho o atraso médio de pacotes medido em ciclos de relógio e a vazão média da rede.
O processo experimental é feito numa rede &quot;2D Torus «com dimensões 4x4.
Em o modelo de tráfego proposto, cada IP envia 10.000 pacotes, variados em três tamanhos de pacotes, sendo o curto de 128 bytes, o médio de 512 bytes e o longo de 2048 bytes.
Como resultados, os autores concluem que o fator de localidade do tráfego trouxe ganhos no atraso e na vazão dos pacotes, o que indica um possível ganho de desempenho quando uma estratégia de mapeamento é utilizada.
Além disso, o autor detectou que a distribuição espacial uniforme foi aquela que atingiu os menores resultados envolvendo saturação do tráfego, quando comparadas a distribuições espaciais &quot;Locality «e &quot;Transpose».
Bru, apresentam um ambiente que permite avaliar redes intrachip projetadas em nível RTL como em Tl, do inglês &quot;Register Transfer Level «e &quot;Transaction Level «sobre diferentes configurações, utilizando ferramentas com suporte a interface gráfica.
O ambiente proposto, referenciado por BrownPepper, implementado com uso de interface gráfica, e de domínio publico, permite a geração parametrizável da rede SoCIN, acrônimo de (SoC Interconection Network) que possui topologia &quot;2D Mesh», e composta por o roteador ParIS, acrônimo de (Parameterizable Interconnect Network), formado por 5 portas, onde 4 de elas são responsáveis por a comunicação entre os roteadores e uma de elas responsável por a comunicação do roteador com um módulo IP.
Cada porta do roteador possui dois canais, um responsável por receber e outro por o envio dos dados.
A rede SoCIN permite a transmissão de pacotes de tamanhos ilimitados.
O processo de geração de tráfego é implementado num dos módulos do ambiente BrownPepper através de um ambiente parametrizável de configuração de tráfego utilizando interface gráfica.
O modelo de tráfego proposto segue o mesmo definido em, com acréscimo de um novo campo aos parâmetros do tráfego, que o classifica conforme seu QoS, do um tempo máximo de atraso, por exemplo, foi atendido.
O processo de avaliação de tráfego utiliza como métrica de desempenho a latência média da rede, medida em ciclos de relógio, e o percentual de pacotes que tiveram seu tempo de transmissão ideal atendidos.
O ambiente de avaliação é disponibilizado através de uma interface gráfica.
Durante o processo experimental o autor avalia dois cenários de tráfego, que demostram as funcionalidades do ambiente de maneira geral, demostrando que modificando certos parâmetros da rede, é possível atender restrições impostas por os tráfegos gerados.
Schemmer, apresentam uma proposta para estender o gerador de tráfego do ambiente Atlas, utilizando a distribuição de probabilidade exponencial decrescente para variar a distribuição temporal de um tráfego de pacotes, que define o intervalo entre a transmissão dos pacotes de um tráfego.
Os autores fazem uso da rede Hermes e da ferramenta de geração de redes presente no ambiente Atlas, que permite gerar variações da rede Hermes, no que diz as suas dimensões, profundidade das filas nas portas dos roteadores, largura dos canais e número de canais virtuais.
Além disso, o ambiente possibilita a seleção de sete algoritmos de roteamento, sendo 6 de eles adaptativos e um determinístico, todos, livres de situação de impasse, do inglês &quot;Deadlock Free».
O processo de geração de tráfego permite variar os parâmetros do tráfego, no que diz respeito ao número de pacotes, tamanho dos pacotes, destinos do tráfego e intervalos entre a geração dos pacotes.
Os destinatários dos pacotes do tráfego podem ser parametrizados de três maneiras:
Endereço destino único:
Todos os pacotes de um tráfego são enviados para um único destino;
Complemento: Todos os pacotes de um tráfego são enviados para endereço binário negado;
Aleatório: Os destinos são escolhidos de maneira aleatória por o gerador de tráfego.
O intervalo de injeção entre os pacotes segue uma distribuição exponencial decrescente, calculado entre um intervalo de taxas de injeção, passível de parametrização.
A Figura 8 descreve através de um exemplo uma das interfaces do ambiente de geração, que permite a visualização gráfica da distribuição dos pacotes para um intervalo informado.
Em o exemplo ilustrado por a figura, é proposto um tráfego de 1000 pacotes variados num intervalo de 100 Mbps a 200 Mbps variados em incrementos de 10 Mbps, com valor de média que define a intensidade do decaimento da distribuição definido em 151 Mbps.
Mbps com incremento de 10 Mbps e média de 151 Mbps.
O processo de avaliação do tráfego utiliza a mesma abordagem descrita por.
Como métricas de avaliação de desempenho, é feito uso de vazão e de latência.
Durante o processo experimental os autores comparam a distribuição temporal de tráfego exponencial decrescente proposta com uma distribuição normal já existente no ambiente.
Dois fluxos de 500 pacotes são propostos, um do roteador 00 para o roteador 22, e um do rotador 20 para o roteador 22, ambos concorrentes por o mesmo caminho da rede.
O primeiro tráfego é gerado de maneira uniforme, o segundo tráfego é gerado num cenário através de uma distribuição normal, e em outro cenário através de uma distribuição exponencial.
O objetivo do experimento é avaliar a capacidade de saturação da distribuição exponencial comparada a distribuição normal, sendo que ambas enviam a mesma quantidade de informação, em intervalos de tempo correlatos para os mesmos destinos.
Como resultados, os autores detectam existir 20% de aumento na latência média do tráfego uniforme utilizando tráfego exponencial, quando comparado a um mesmo cenário, que utiliza de tráfego normal.
A vazão por outro lado diminuiu 9% no tráfego uniforme utilizando tráfego exponencial, quando comparado a tráfego normal.
Por fim, o tráfego exponencial apresenta melhores resultados com relação a capacidade de saturar a vazão e a latência dos pacotes, comparado a tráfego normal.
Gratz, apresentam o projeto, implementação e a avaliação da rede intrachip Trips OCN, proposta como uma rede intrachip para interconexão de processadores.
Os autores propõem o desenvolvimento da rede Trips OCN, que contem como características, tamanho 4x10, topologia &quot;2D Mesh», chaveamento de pacotes &quot;Wormhole», 4 canais virtuais em cada uma das portas dos roteadores, formados por 5 portas, sendo 4 de elas para comunicação entre roteadores e uma de elas para comunicação da rede componentes.
O processo de geração de tráfego propõe o uso de tráfego sintético e o uso de aplicações reais.
O tráfego sintético é modelado utilizando distribuições &quot;Bit complement «e &quot;Random «que variam os destinos dos pacotes, já o tempo de injeção dos pacotes é dado por uma distribuição uniforme.
Os autores utilizam o SPEC CPU2000 para extrair as aplicações reais, sendo utilizadas 20 aplicações no total.
O processo de avaliação do tráfego utiliza como métrica de avaliação de desempenho a latência média dos pacotes, medida em ciclos de relógio e a vazão aceita dos tráfegos.
Durante o processo experimental, os autores comparam os resultados obtidos entre tráfego sintético e as aplicações reais, concluindo que o tráfego sintético além de não reproduzir o mesmo universo da aplicação, no que diz ao momento e a quantidade de informação injetada, não reproduz resultados de saturação próximos da aplicação, que em relação a os cenários avaliados, são justamente os causadores de aumento na latência média dos pacotes, e redução na vazão total da rede.
Esta seção resume alguns dos assuntos em comum propostos por este trabalho, coexistentes com os trabalhos pesquisados.
A seguir, são feitas comparações, justificando através destas a proposta deste trabalho.
A Tabela 1 apresenta cinco aspectos coletados dos trabalhos pesquisados seguindo o tema de projeto e geração parametrizável de redes intrachip.
Os itens coletados partem dos seguintes questionamentos:
Trabalho descreve uma ferramenta de geração automática de rede intrachip?
Processo de geração de redes é passível de parametrização?
Quais topologias são suportadas por a rede?
Quais algoritmos de roteamento são suportados por a rede?
Rede utilizada é síncrona ou não síncrona?
Qual nível de abstração de projeto a rede é descrita?
A partir de a coleta dos dados, constata- se que nos item ferramentas de geração de redes e suporte a geração parametrizável, entende- se a existência de cinco ferramentas, onde somente numa de elas os autores não descrevem existir suporte a parametrização durante a geração da rede.
Dente as topologias utilizadas, com exceção de um, todos os outros fazem uso da topologia &quot;Mesh», além disso, quase todos dão suporte a topologia &quot;Torus».
Com relação a o tipo de roteamento suportado, a maior parte faz uso de roteamento determinístico.
Com relação a o nível de abstração do projeto da rede, na grande maioria dos trabalhos é feito uso do nível RTL, do inglês &quot;Register Transistor Level», utilizando linguagem VHDL, do inglês &quot;VHSIC hardware description «para descrever a rede.
O último item que pesquisa se as redes utilizadas são síncronas ou não síncronas, demostra que a grande maioria dos trabalhos pesquisados faz uso de redes síncronas, com exceção de dois de eles.
Em o contexto deste trabalho é apresentada uma ferramenta de geração parametrizável de redes com suporte a definição de múltiplos domínios de frequência para os roteadores, descritos em nível de projeto RTL utilizando linguagem VHDL.
Conforme o levantamento feito, nenhum dos trabalhos pesquisados apresenta esta proposta.
A rede utilizada por este trabalho faz uso da topologia &quot;Mesh «seguindo a tendência utilizada por a maioria dos trabalhos pesquisados.
Por fim, a maior parte dos trabalhos faz uso de algoritmos de roteamento determinísticos, este trabalho, além de o uso de algoritmos de um roteamento determinístico, dá suporte também a seis algoritmos de roteamento adaptativos, suportados somente por alguns dos trabalhos pesquisados.
A Tabela 2 apresenta sete aspectos coletados dos trabalhos pesquisados seguindo os temas de caracterização de tráfego de rede e métricas de avaliação de tráfego utilizadas.
Os itens coletados partem dos seguintes questionamentos:
Trabalho descreve ferramenta de geração de tráfego?
Processo de geração de tráfego é passível de parametrização?
Trabalho utiliza grafo de aplicação para descrever tráfego?
Se grafo for utilizado, trabalho descreve alguma técnica de particionamento ou de mapeamento?
Qual é a distribuição espacial do tráfego utilizada por o trabalho?
Qual é a distribuição temporal do tráfego utilizada por o trabalho?
Quais são as métricas de avaliação de desempenho utilizadas?
A partir de a coleta dos dados, constata- se que no item ferramenta de geração de tráfego com suporte a parametrização, somente alguns trabalhos detalham existir uma ferramenta apta a possibilitar geração de tráfego parametrizável.
Em alguns trabalhos, foi detectado o uso de grafos de aplicações para descrever tráfego, sendo que somente num de eles os autores descrevem a existência de uma técnica de particionamento e mapeamento utilizada para sintetizar o grafo que descreve o tráfego a arquitetura da rede.
Com relação a distribuição temporal, grande parte dos trabalhos utiliza tráfego aleatório e complemento, existindo em alguns de eles, uma proposta evolutiva ao modelo aleatório, em que propriedades estatísticas são utilizadas na definição dos destinos do tráfego.
Já o item distribuição temporal, a grande maioria os autores utilizam distribuição uniforme, existindo alguns casos em que proposto o uso de modelos estatísticos como uma proposta evolutiva para aumentar a precisão do tráfego.
Por fim, o item avaliação de desempenho, resume as métricas utilizadas para avaliar o tráfego na rede, sendo que em grande maioria, os trabalhos utilizam a vazão da rede e a latência média dos pacotes, avaliadas sobre diferentes óticas durante a injeção, transmissão e recebimento dos pacotes.
Em o contexto deste trabalho, é apresentada uma ferramenta de geração de tráfego parametrizável, que possibilita variar o tráfego, com relação a quantidade e ao tamanho dos pacotes, e varia a questão espacial que define os destinos dos pacotes e a questão temporal que define o momento de injeção dos pacotes, utilizando distribuições estatísticas.
Além disso, este trabalho dá suporte a geração de tráfego através de grafos de aplicações, que além de permitirem caracterizar a questão espacial e temporal dos pacotes, permitem modelar as dependências existentes entre os tráfegos, que de certa forma caracterizam um maior grau de aproximação ao comportamento de uma aplicação.
Conforme o levantamento feito, nenhum dos trabalhos pesquisados descreve um ambiente de geração de tráfego parametrizável, capaz de modelar as características do tráfego conforme é proposto.
Por fim, este trabalho apresenta uma ferramenta de avaliação de tráfego, com suporte a interface gráfica, que faz uso das métricas de vazão e latência conforme os demais trabalhos pesquisados.
Esta ferramenta leva em consideração o cálculo da latência e da vazão ideal e calculas, levando em consideração quando uma rede intrachip não síncrona é utilizada, uma vez que este trabalho originalmente dá suporte a geração de redes não síncronas.
As particularidades referentes a estes detalhes, e a proposta integral descrita até então serão detalhadas em profundidade nos próximos capítulos.
Este Capítulo descreve o processo de parametrização e projeto da ferramenta de geração de redes GALS, baseadas na arquitetura original da rede Hermes-G. Ele descreve quais foram às dificuldades e as decisões tomadas durante o desenvolvimento do gerador.
Este gerador foi completamente integrado ao fluxo de projeto de geração do ambiente Atlas.
Em a visão do autor, este capítulo é considerado com uma das contribuições apresentadas por este trabalho.
Esta Seção descreve de através de uma abordagem cronológica quais foram as primeiras atividades desenvolvidas, para obter e entender a ferramenta Atlas e a rede Hermes-G, para então dar inicio a parametrização da rede e desenvolvimento da ferramenta de geração.
A seguir, serão detalhadas as principais características do processo de geração de redes no ambiente Atlas, que influenciaram no projeto do gerador de redes não síncronas.
Logo após é detalhado como a rede Hermes-G foi obtida, e algumas das principais características e funcionalidades adicionadas durante o desenvolvimento deste trabalho a rede.
O ambiente Atlas foi proposto por o grupo de pesquisa GAPH, ou grupo de apoio ao projeto de hardware, inicialmente com objetivo de integrar as ferramentas de geração e avaliação de tráfego e de energia para redes do tipo Hermes.
Hoje, este ambiente dá suporte à geração e avaliação de tráfego para outros seis tipos de redes, originalmente concebidas como uma evolução da rede Hermes, ou levando em consideração algumas das características utilizadas por esta rede.
Atualmente o ambiente Atlas é mantido sobre controle de versionamento num ambiente de desenvolvimento SVN, do inglês &quot;Apache Subversion».
Todas as contribuições propostas por este trabalho estão mantidas num dos inúmeros diretórios ramo, do inglês &quot;Branch», derivados a partir de o diretório tronco, do inglês &quot;Trunk «do ambiente Atlas.
Para este trabalho foi criado um ramo derivado do tronco, chamado &quot;GALS», um acrônimo que remete a uma das palavras chaves deste trabalho.
Todas as contribuições desenvolvidas por este trabalho gerador de redes não síncronas apresentado por este capitulo.
Após obter uma versão estável do ambiente Atlas, o autor deste trabalho propôs um estudo, com objetivo de entender como o processo de geração era feito.
A saber, o código fonte que compõe o ambiente Atlas não possui documentação, tanto no que tange o código fonte, quanto a suas funcionalidades, o que encarece o processo de aprendizagem para o desenvolvimento de novas funcionalidades.
Sendo assim, a atividade de estudar o ambiente antes de projetar uma nova funcionalidade acaba se tornando algo necessário.
O ambiente Atlas dá suporte a geração de sete tipos de redes, sendo elas:\&gt;
Como resultados do estudo do ambiente de geração, o autor deste trabalho concluiu que:
Cada uma das redes suportadas por o processo de geração de redes do ambiente Atlas possui seu próprio ambiente de geração, incluindo desde a interface gráfica do gerador até os arquivos que geram a rede intrachip.
Todas as redes seguem um padrão, no que diz respeito aos nomes dos diretórios que armazenam o código fonte dos geradores e aos diretórios que armazenam os modelos das redes, utilizados durante o processo de geração de rede.
Todas as redes propostas seguem um fluxo de projeto ilustrado por a Figura 9 durante a definição de um projeto e geração da rede, composto por quatro etapas:
Criação de um projeto de rede;
Definição das características da rede;
Geração da rede.
Dar suporte a edição de um projeto de rede gerada.
Toda rede é vista no ambiente como um modelo universal, durante o processo de geração da rede, os modelos são lidos, manipulados e gerados conforme as características selecionadas por o usuário.
Partindo destes conhecimentos, o novo ambiente de geração proposto, irá seguir o mesmo modelo de diretórios e nomenclaturas utilizadas para armazenar os arquivos que compõem o ambiente de geração e os modelos da rede.
Além disso, o ambiente de geração de redes HERMESG também irá dar suporte a edição de um projeto de rede.
Criação de um projeto.
Definição das características desejadas para uma rede.
Geração da rede.
Edição de um projeto de rede gerado.
De acordo com, a rede Hermes-G é uma extensão da rede Hermes, proposta originalmente por.
Ambas as redes, são formadas por as seguintes características, topologia de interconexão malha bidimensional, controle de fluxo utilizando créditos, algoritmo de roteamento determinístico XY e chaveamento de pacotes utilizando a técnica &quot;Wormhole».
A principal diferença entre uma rede Hermes de uma rede Hermes-G, esta nas filas de entrada dos roteadores.
Em a rede Hermes, é feito uso de uma fila síncrona, onde a frequência de escrita e a frequência de leitura são feitas sempre, na mesma frequência e na mesma fase.
Em a rede Hermes-G, é feito uso de uma fila bi síncrona, que possibilita que leituras e escritas, sejam realizadas, tanto na mesma fase e na mesma frequência, como em fases e frequências diferentes.
Em uma rede Hermes-G, o principal elemento que compõe a rede é o roteador.
Uma rede é composta por diversos roteadores.
Cada roteador é composto por três componentes fundamentais.
O primeiro de eles, chamado de controlador do roteamento, do inglês &quot;Switch Control», é o responsável por realizar a arbitragem das portas de entrada do roteador, e por o cálculo do endereço destino de um pacote.
O segundo componente, também presente em todas as chaves, chamado de barra cruzada, do inglês &quot;Crossbar», é o responsável por interconectar todas as portas de entrada com todas as portas de saída do roteador.
O terceiro e último componente, presente em todas as chaves, chamado de fila de entrada, do inglês &quot;Buffer», é responsável por dar suporte duas funcionalidades em redes Hermes-G. A primeira de elas é garantir que independente a fase, ou a frequência em que o roteador estiver operando, em relação a o roteador ou elemento de processamento ao qual a porta do roteador estiver conectada, a fila presente nesta porta irá garantir que a comunicação ocorra da mesma forma.
A segunda funcionalidade é realizar o armazenamento dos flits dos pacotes de maneira temporária, quando houver contenção na rede, causado por a ocupação do caminho por um fluxo de pacotes concorrente durante o chaveamento da conexão.
Este trabalho obteve acesso a um projeto de rede Hermes-G, com características definidas, tamanho 3x3, largura de canais igual a 16 bits e profundidade das filas de entrada dos roteadores igual a 4 flits de 16 bits cada.
Para este projeto foi feito um estudo dirigido, com objetivo de identificar quais eram as estruturas que formavam a rede.
Durante este estudo os arquivos da rede foram documentados.
Além disso, um conjunto de experimentos variando algumas das características da rede foram executados, para validar o funcionamento da rede.
Para este projeto foi criado no mesmo servidor de SVN descrito na seção anterior um diretório para armazenar estes arquivos.
A rede Hermes-G parametrizada e inserida no ambiente Atlas parte então deste projeto de rede que se encontra disponível publicamente em Antes de descrever com maior grau de detalhamento os componentes que caracterizam uma rede Hermes-G, serão apresentadas algumas atualizações feitas na rede durante o desenvolvimento deste trabalho, umas no sentido de corrigir falhas existentes, outras adicionando novas características a rede.
Ao todo, três novas funcionalidades foram adicionadas, e duas correções foram feitas, com objetivo de aumentar a robustez das filas utilizadas nos roteadores.
Todas estas modificações feitas na rede são suportadas por o ambiente de geração de redes A implementação original da rede Hermes-G dá suporte a roteamento determinístico XY, em que todo fluxo de pacote segue sempre o mesmo caminho definido por a politica de roteamento.
Durante o trabalho de doutorado de Edson Moreno, o autor implementou seis novos algoritmos de roteamento adaptativos para a rede Hermes, descritos em sendo eles:
West First; West First Minimal;
West First Non Minimal;
North Last; North Last Minimal;
North Last Non Minimal.
Devido a as características de semelhança existentes entre a rede Hermes e a rede Hermes-G, os algoritmos de roteamento implementados para a rede Hermes são totalmente compatíveis com a rede Hermes-G. Este trabalho adapta os roteamentos adaptativos utilizados em redes Hermes para a rede Hermes-G. Para garantir o funcionamento destes algoritmos adaptativos, o autor deste trabalho desenvolveu uma ferramenta de testes, capaz de gerar, simular e verificar um conjunto arbitrário de redes Hermes e Hermes-G, de maneira automática.
Esta ferramenta faz uso dos geradores de rede e de tráfego do ambiente Atlas e será detalhada posteriormente, uma vez que foi desenvolvida para verificar o funcionamento do gerador de redes Hermes-G de maneira automática.
Um conjunto composto por diversos casos de teste foi proposto para validar os algoritmos de roteamento adaptativos tanto em redes Hermes como em redes Hermes-G utilizando a ferramenta de testes.
Durante os experimentos, foram detectados alguns erros em alguns cenários com relação a o roteamento e a transmissão dos tráfegos.
Algumas mudanças nos algoritmos adaptativos foram propostas e desenvolvidas por o aluno de mestrado William Schneider.
Os mesmos cenários de teste foram novamente executados sob as mudanças propostas, onde que a ferramenta de testes reportou êxito na transmissão dos cenários de tráfegos propostos após fazer uso das mudanças propostas.
Um conjunto composto por diversos casos de teste foram propostos para validar a proposta de minimização do &quot;Crossbar», tanto em redes Hermes como em redes Hermes-G, fazendo uso da ferramenta de testes.
Para todos os casos propostos, a ferramenta de testes reportou êxito na transmissão dos tráfegos utilizando diferentes algoritmos de roteamento com duas versões de &quot;Crossbar «minimizados.
&quot;West First», proíbe- se curvas para oeste se o pacote vier de norte, sul ou leste. (
c) &quot;North Last», proíbe qualquer curva após o sentido norte ter sido tomado.
Durante o desenvolvimento do trabalho de mestrado do aluno Guilherme Heck foi detectado durante simulações existirem deficiências funcionais no módulo de comparação de ponteiros da fila bi síncrona, componente este utilizado nas portas de entrada dos roteadores na rede HERMESG.
A Figura 11 ilustra através de um diagrama de blocos os componentes que formam a fila.
De entre eles estão os módulos responsáveis por implementar os comparadores de ponteiros de fila cheia e fila vazia, utilizados respectivamente como controle de fluxo para escrita na fila, através do sinal de fila cheia e para consumo da fila, através do sinal de fila vazia.
Além de eles, a fila é composta por um módulo de memória, que armazena os dados na fila, e por uma lógica de comparadores, que sincroniza a leitura e a escrita, ambas podendo ou não ser feitas em diferentes domínios de frequência e de fase.
Através desta funcionalidade é possível configurar os roteadores para operar em diferentes domínios de relógio.
Para resolver as condições de exceção encontradas na sincronização de ponteiros é descrito na proposta de um módulo comparador utilizando três ponteiros, sendo eles um de leitura, um de escrita e um de escrita anterior, que armazena temporariamente o endereço de escrita anterior da fila.
Além disso, o aluno de mestrado Guilherme Heck, detecta também que a codificação Gray utilizada originalmente no comparador de ponteiros por a fila bi síncrona, faz uso de endereços em binários, convertido através da operação &quot;ou exclusivo «(XOR).
Esta conversão possibilita a geração de &quot;Glitches», efeitos não desejados que pode levar a fila a um estado inválido.
Como solução para este problema, ele propõe o desenvolvimento de um novo comparador de ponteiros, utilizando a codificação Johnson, que faz uso de um registrador de deslocamento e de uma porta inversora para realizar o processo de incremento dos ponteiros de leitura e de escrita, e sem a possibilidade de gerar &quot;Glitches «durante o incremento.
Em, o autor desenvolve um estudo do crescimento da área das filas bi síncronas utilizando a codificação de ponteiros Johnson proposta comparado a codificação Gray, originalmente existente na fila bi síncrona.
Durante os experimentos ele varia a profundidade das filas em 4, 8, 16,32, 64 e 128 endereços possíveis.
Os resultados são obtidos através do processo de síntese para FPGAs, do inglês &quot;Field--Programmable Gate Array «extraído em número de LUTs, do inglês &quot;Look-Up Table «de quatro entradas.
Os resultados obtidos apontam que para casos em que 4,8 e 16 endereços da fila, o número de LUTs gastas por ambas as codificações, são matematicamente as mesmas.
Para profundidades de endereços de filas de 32,64 e 128 endereços, a codificação Gray, apresentou menor consumo em área que a codificação Johnson.
Por existir ganhos em cada uma das abordagens, o autor deste trabalho adotou a possibilidade de parametrizar a codificação de ponteiros durante a geração de redes Hermes-G, permitindo o uso de arquiteturas de rede com codificação Johnson e codificação Gray.
O projeto da rede Hermes-G, por permitir que os roteadores operem em frequências diferentes, cria condições em que os elementos que transmitem e recebem o tráfego da rede, necessitem de um componente capaz de sincronizar a transmissão.
Com relação a o componente externo transmissor, conectado a uma porta local de um roteador, independente este operar numa frequência maior ou menor do que o roteador, a sincronização entre ambos os componentes é garantida por a fila bi síncrona presente na porta local do roteador.
Já num cenário em que um componente externo receptor estiver conectado a porta local, tanto operando numa frequência de leitura maior ou menor que a frequência do roteador, se faz necessário existir um componente sincronizador entre a saída da porta local do roteador, e o componente de recebimento do tráfego.
Em a visão de um projeto, este sincronizador é visto como um componente necessário para garantir a recepção do tráfego, porem, na visão da rede ele não faz parte dos módulos que compõem a rede.
A proposta original descrita por propõem a utilização de um componente chamado &quot;Async_ Fifo», desenvolvido a partir de a arquitetura da fila bi síncrona, possuindo diferenças no protocolo de leitura da fila.
Esta arquitetura compartilha das mesmas deficiências relacionadas à sincronização dos ponteiros detectadas e corrigidas por, sendo assim, o autor deste trabalho, no objetivo de corrigir as deficiências existentes, propôs o desenvolvimento de uma nova arquitetura &quot;Async_ Fifo», baseada na arquitetura da fila bi síncrona, que da suporte as correções propostas por, desenvolvida unicamente utilizando a codificação de ponteiros Johnson.
A Figura 12 ilustra as conexões de entrada e de saída da fila bi síncrona em Figura 12 (b), e do componente &quot;Async_ Fifo «em Figura 12 (a).
Em ambos os casos o protocolo de entrada das filas é o mesmo, por o motivo de estarem sempre conectadas as portas dos roteadores.
Em a Figura 12 é possível visualizar que existem diferenças no protocolo de saída das filas, uma vez que na fila bi síncrona, parte de suas saídas são conectadas ao módulo que realiza o roteamento, e parte de elas ao &quot;Crossbar».
Já na &quot;Async_ Fifo», a saída da fila possui apenas conexões de transmissão, por o motivo de não haver necessidade de realizar o roteamento para transmitir os dados.
A Figura 13 descreve a máquina de estados de leitura da fila bi síncrona, composta ao todo por cinco estados, sendo o estado &quot;S_ INIT «responsável por inicializar a fila, os estados &quot;S_ HEADER «e &quot;S_ SHEADER «por realizar o roteamento, e &quot;S_ TX «e &quot;S_ END «por a transmissão do pacote.
A nova arquitetura &quot;Async_ Fifo «conta com apenas dois destes cinco estados, sendo eles o &quot;S_ INIT «que realiza a transmissão do dado quando existir e &quot;S_ END «que aguarda e detecta até que exista um dado na fila para ser transmitido.
De entre um dos diversos tópicos propostos originalmente por este trabalho, um de eles propõe utilizar filas síncronas e filas bi síncronas de maneira simultânea numa rede, uma vez que ambas as filas compartilham do mesmo protocolo de comunicação, e teoricamente, são compatíveis.
A ideia por trás do uso de ambas as filas esta relacionado ao aumento no tempo de transmissão e na área da fila bi síncrona comparada a fila síncrona.
A seleção no uso das filas é feito durante a geração da rede a partir de a frequência de operação de cada roteador.
Em contextos onde as frequências são diferentes é utilizada a fila bi síncrona, em contextos onde a frequência é igual, é utilizada a fila síncrona.
Durante o processo experimental, em que cenários foram gerados de maneira manual, o autor detectou situações de impasse, onde tráfegos de pacotes não eram completamente transmitidos.
Em uma inspeção detalhada nas simulações utilizado o formato de visualização de forma de onda, detectou- se que a arquitetura interna da fila síncrona não era capaz de tratar algumas condições existentes quando diferentes cenários de redes são propostos.
Em a visão do autor deste trabalho, as alterações necessárias a serem feitas modificariam algumas das propriedades existentes da fila síncrona utilizada por o roteador Hermes.
Sendo assim, foi proposto evoluir a arquitetura síncrona do roteador Hermes, criando uma variação desta arquitetura.
Para classificar a nova variação de arquitetura proposta, o autor assumiu a nomenclatura &quot;Hermes-GS», uma vez que a arquitetura é desenvolvida especificamente para trabalhar em redes Hermes-G, possuindo a característica de permitir leituras e escritas unicamente de maneira sincronizada, por isto o sufixo Gs acrônimo de &quot;Gals Synchronous».
De entre as modificações desenvolvidas, a nova proposta evolui uma deficiência encontrada no processo de leitura da fila, que assume depois de feito roteamento do pacote, a cada ciclo de relógio do roteador, que um dado deve ser transmitido.
Esta condição só é funcional em dois casos, um num modelo ideal, onde não há atrasos na transmissão dos flits dos pacotes, e outro, quando o chaveamento de pacotes garante que uma vez realizado o chaveamento do primeiro flit, os demais flits estarão disponíveis para consumo da fila no próximo ciclo da frequência de leitura do roteador.
O modelo de rede proposto assume que diferentes frequências sejam definidas estaticamente durante o projeto da rede, o que na pratica implica em diferentes atrasos de transmissão para os fluxos de pacotes.
Para isso, a maquina de estados que da suporte ao processo de leitura da fila foi rescrita, levando em consideração a condição que o sinal da fila que informa que existe uma transmissão de um flit só seja habilitado quando os ponteiros da fila indiquem que o dado esteja presente na fila.
O projeto de um cenário de uma rede Hermes-G pode ser decomposto em três grandes partes:
Os arquivos VHDL que compõem a rede.
Os arquivos SystemC que compõem os geradores e receptores do tráfego.
Um arquivo VHDL e um TCL do inglês &quot;Tool Command Language», responsáveis por conectar a rede com os geradores e receptores e automatizar a compilação e simulação do projeto da rede.
Em a visão do ambiente Atlas, o processo de geração de redes engloba gerar de maneira simultânea as três partes.
Em a visão deste trabalho, por coexistirem outros fatores que diferenciam o que é rede do que é a estrutura de geração e avaliação de tráfego, preferiu- se optar por desenvolver o gerador de redes com habilidade de unicamente gerar a rede.
A rede Hermes-G será detalhada de maneira evolutiva, neste primeiro momento serão descritos quais são os componentes que caracterizam a rede, e como eles foram parametrizados e adaptados para permitir sua geração.
Em os capítulos seguintes, os demais componentes que formam o ambiente de geração de tráfego da rede serão detalhados.
A rede Hermes-G é composta ao todo por seis arquivos.
Por convenção, o autor renomeou os arquivos que compõem a rede, prefixando todos os arquivos com o rótulo &quot;HermesG», seguindo a tendência utilizada por outros tipos de redes suportadas por o ambiente Atlas.
A seguir, serão detalhados os arquivos que descrevem a rede, e quais foram às decisões de projeto assumidas para permitir a parametrização dos arquivos.
HermesG_ Buffer:
Arquivo utilizado como modelo que descreve quatro arquiteturas de filas.
A parametrização com relação a o tipo da fila e a profundidade são suportados por outros arquivos.
Durante a geração da rede, apenas é feita uma cópia deste arquivo.
HermesG_ SwitchControl:
Arquivo utilizado como modelo que descreve seis arquiteturas de &quot;SwitchControl».
A parametrização com relação a o tipo de roteamento utilizado é suportado por outro arquivo.
Durante a geração da rede, apenas é feita uma cópia deste arquivo.
HermesG_ Crossbar:
Arquivo utilizado como modelo que descreve seis arquiteturas de &quot;Crossbar».
A parametrização com relação a o tipo de &quot;Crossbar «utilizado é desenvolvido em outro arquivo.
Durante a geração da rede, apenas é feita uma cópia deste arquivo.
Router: Arquivo utilizado como modelo para geração dos roteadores da rede.
Este arquivo possui uma série de marcadores, que indicam os locais onde devem ser declarados quais arquiteturas de &quot;SwitchControl», &quot;Crossbar «e &quot;Buffer «a rede deverá dar suporte.
Durante a geração da rede, uma cópia deste arquivo é feita, substituindo os marcadores existentes por as arquiteturas dos componentes &quot;SwitchControl», &quot;Crossbar «e &quot;Buffer «selecionados através da interface do ambiente.
NOC: Arquivo utilizado como modelo para geração da rede, que interliga todos os roteadores.
Este arquivo possui uma série de marcadores, que indicam os locais onde devem ser declarados e interconectados os roteadores, como também as portas de entrada e saída do componente.
Durante a geração da rede, uma cópia deste arquivo é feita, substituindo os marcadores existentes por os roteadores da rede e por sua interconexão.
HermesG_ Package:
Arquivo utilizado como biblioteca de constantes, que armazena os valores do comprimento dos canais e profundidade dos buffers.
Durante a geração da rede, uma cópia deste arquivo é feita, substituindo os marcadores existentes por os valores referentes ao comprimento dos canais e a profundidade dos buffers selecionados através da interface do ambiente.
De maneira resumida, o projeto da interface gráfica do ambiente de geração de redes Hermes-G deverá dar suporte à seleção de oito características da rede, sendo elas:
Dimensões da rede, em linhas e colunas.
Profundidade das filas de entrada dos roteadores.
Comprimento dos canais que interligam os roteadores.
Algoritmo de roteamento utilizado por os roteadores.
Frequência de operação dos roteadores.
Frequência de operação dos geradores e receptores do tráfego.
Codificação de ponteiros das filas bi síncronas.
A seguir é detalhado o projeto da interface gráfica do gerador de redes, apresentando uma solução capaz de dar suporte à seleção de valores para todas as características da rede Hermes-G conforme resumidas por a seção 3.2.
Dimensões: Opção do gerador que permite parametrizar as dimensões da rede, suportando redes com tamanho mínimo de dois roteadores em X e dois roteadores em Y, e tamanho máximo de dezesseis roteadores em X e dezesseis roteadores em Y. Comprimento do flit:
Opção do gerador que permite parametrizar o comprimento dos canais que interligam os roteadores, em 8, 16, 32 ou 64 bits.
Profundidade do buffer:
Opção do gerador que permite parametrizar a profundidade das filas utilizadas por os roteadores, em 4, 8, 16 e 32 flits.
Algoritmo de roteamento:
Opção do gerador que permite parametrizar o algoritmo de roteamento utilizado por os roteadores.
Os algoritmos de roteamento suportados são:
West First; West First Minimal;
West First Non Minimal;
North Last; North Last Minimal;
North Last Non Minimal.
Codificação de ponteiros:
Opção do gerador que permite parametrizar a codificação de ponteiros utilizada por as filas bi síncronas.
De entre as opções disponíveis estão a codificação Johnson e a codificação Gray.
O item número cinco da Figura 14 foi desenvolvido para dar suporte a criação, edição e remoção de frequências.
Estas frequências depois de cadastradas são utilizadas por o item número 7 da Figura 14 para definir a frequência de operação dos roteadores e seu respectivo módulo de transmissão e recepção de pacotes.
Este componente é responsável por a gerência de frequências e possui ao todo quatro funcionalidades, conforme ilustrado por a Figura 15.
A funcionalidade permite a visualização dos valores de frequências cadastradas.
A funcionalidade permite que novas frequências sejam cadastradas.
A funcionalidade permite remover frequências cadastradas, e a funcionalidade permite a edição de frequências cadastradas.
Toda frequência é definida por três campos, sendo eles o nome, o valor e o múltiplo do valor da frequência.
A seguir serão descritas as funcionalidades de adição, remoção e edição de frequências.
A adição de novas frequências permite que novas frequências sejam criadas para serem utilizadas por os roteadores e seus módulos de transmissão e recepção de pacotes.
A interface gráfica que dá suporte a funcionalidade é descrita por a Figura 16.
A adição de uma nova frequência consiste em definir um nome, um valor e um múltiplo do valor da frequência.
A funcionalidade de adição de frequências leva em consideração um conjunto de restrições descritas a seguir:
Nomes de frequências devem obrigatoriamente iniciar por uma letra do alfabeto, e seus caracteres remanescentes formados por letras, números ou um caractere ponto.
Além disso, palavras reservadas da linguagem VHDL não podem ser usadas como nomes.
Estas restrições seguem as restrições impostas para nomes de variáveis da linguagem VHDL, uma vez que o nome das frequências é utilizado durante a geração do projeto da rede.
Valores para as frequências validos devem estar entre um intervalo de 0.1 MHz e 5000 MHz (GHz).
A remoção de frequências cadastradas foi desenvolvida para flexibilizar o processo de manipulação de frequências.
A Figura 17 apresenta a interface de remoção de frequências, que possui um único campo, onde é possível selecionada e remover uma frequência cadastrada.
A funcionalidade remoção leva em consideração um conjunto de restrições na remoção de frequências.
Para todo projeto de rede é gerado por padrão durante sua inicialização uma frequência chamada de &quot;def Clock 50.0 MHz», que é cadastrada para todos os roteadores e seus respectivos transmissores e receptores.
Por regra, este valor não pode ser removido, mas pode ser editado, mesmo que existam outras frequências cadastradas.
Uma vez removida uma frequência, todos os roteadores e módulos de transmissão e recepção de pacotes que fazem uso desta frequência removida, recebem automaticamente a frequência padrão da rede, que conforme definido por a regra anterior, sempre estará presente pois não pode ser removido.
A edição de frequências cadastradas foi desenvolvida para flexibilizar o processo de manipulação de frequências.
A Figura 19 apresenta a interface da funcionalidade de edição, compostas por os seguintes campos:
Selecionar uma das frequências cadastradas;
Informar um novo nome para a frequência;
Informar um novo valor e um múltiplo do valor da frequência.
As regras com relação a nomes e valores de frequências válidas seguem as restrições definidas na seção 3.3.1.1.
Quando uma frequência é editada, todos os roteadores e módulos de transmissão e recepção que fazem uso desta frequência recebem os novos valores informados para a frequência durante a edição.
O item número sete da Figura 14 aponta através de um quadrado de cor preta para a funcionalidade que permite selecionar uma das frequências cadastrada para cada um dos roteadores e seus respectivos módulos de transmissão e recepção de pacotes uma frequência de operação.
O item número sete da Figura 14 faz uso de exemplo do roteador 11, que uma vez selecionado por o clique do ponteiro do mouse sobre o componente, irá disparar a Figura 19, que permite selecionar uma das frequências cadastradas para o roteador, para o módulo transmissor e para o módulo receptor.
A geração da rede Hermes-G será detalhada em duas partes.
A primeira descreve as questões relacionadas aos diretórios e ao arquivo de projeto da rede, responsáveis respectivamente por armazenar o projeto da rede e por permitir a edição da rede gerada.
O segundo passo descreve como é feito a geração dos arquivos da rede, detalhando algumas particularidades na escolha das arquiteturas dos componentes.
O diretório onde a rede deve ser criada é dado conforme o caminho e o nome do projeto da rede definidos durante a criação do projeto da rede.
Em este diretório a pasta &quot;NOC «irá armazenar os arquivos referentes à rede.
Um arquivo com extensão».
Noc «irá armazenar as características da rede gerada inclusive as frequências armazenadas por o componente da seção 3.3.1, e as frequências cadastradas para os roteadores e seus respectivos módulos de transmissão e recepção de pacotes, como também e a codificação de ponteiros definida para a rede.
A função deste arquivo é permitir a edição de um projeto de rede previamente gerado.
Uma vez gerado o diretório da rede e o arquivo de projeto, os arquivos que compõem a rede são gerados, conforme descritos a seguir.
O processo de geração da rede é feito através da cópia dos arquivos utilizados como modelos parametrizáveis dos componentes da rede, detalhados por a seção 3.2.
Os componentes &quot;HermesG «Buffer», &quot;HermesG_ Crossbar «e &quot;HermesG_ SwitchControl», que descrevem respectivamente as arquiteturas das filas, as arquiteturas de &quot;Crossbar «e as arquiteturas de roteamento, utilizadas para a geração dos roteadores são unicamente copiadas do diretório do ambiente Atlas que armazena os modelos para o diretório destino do projeto da rede.
A seguir são detalhados como os roteadores são gerados.
O componente &quot;HermesG_ Package «é copiado do diretório do ambiente Atlas que armazena o modelo para o diretório destino do projeto.
Durante a cópia do arquivo é feita uma busca e substituição dos marcadores&quot;tam_ flit  &quot;e&quot;tam_ buffer», por os valores referentes ao comprimento dos canais e por a profundidade das filas informada por a interface gráfica durante a definição dos parâmetros da rede.
O componente &quot;HermesG_ Package «é utilizado como um arquivo que armazena constantes responsáveis por os valores dos componentes utilizados.
O componente &quot;Router «é o responsável por conter a estrutura de um roteador.
Este projeto assume que cada roteador numa rede de tamanho N roteadores será implementado por um arquivo VHDL.
Sendo assim, um projeto de tamanho N roteadores terá na pasta da rede N cópias do componente &quot;Router».
Esta estratégia foi adotada por conveniência e facilidade de geração dos roteadores.
Durante a cópia do arquivo &quot;Router «feita N vezes, segundo o tamanho N roteadores da rede é feita uma busca e substituição de cinco marcadores, explicados um a um na sequência.
O primeiro marcadorrouter_ name indica o local onde o nome do roteador deve ser escrito.
A estratégia adotada assume que para cada roteador deva existir um nome único, para isso adotou- se a seguinte nomenclatura como nomes dos rotadores.
Todo nome contem como prefixo a palavra (Router) que indica que o arquivo implementa um roteador, seguido do endereço do roteador em hexadecimal, tendo como sufixo o tipo de fila utilizado em cada uma das portas do roteador.
O sufixo parte da seguinte proposta.
Todo roteador possui cinco portas, sendo elas a porta leste, oeste, norte, sul e local.
Em as redes Hermes-G uma porta pode possuir uma fila síncrona (HERMESGS), uma fila bi síncrona (HERMESG), ou estar desconectada.
Adotou- se o caractere para porta desconectada, o caractere (A) para fila bi síncrona e o caractere (S) para fila síncrona.
O sufixo deverá descrever o tipo de fila, ou se a porta estiver desconectada para cada uma das portas do roteador, seguindo a sequência na ordem leste, oeste, norte, sul, local.
Por fim, um exemplo de nome gerado para um roteador seria &quot;Router00 S0A0S», onde seu prefixo indica que é um roteador, e que possui três portas conectadas, sendo duas de elas com filas síncronas, sendo elas a porta leste e local, e possuindo a porta norte conectada a uma fila bi síncrona.
O segundo marcadorAlgorithm_ type indica o local onde a arquitetura do roteamento escolhido deverá ser declarada, e ao mesmo tempo interconectada com os demais componentes do roteador.
O terceiro marcadorCrossbar_ type indica o local onde a arquitetura do &quot;Crossbar «deverá ser escrita, e ao mesmo tempo interconectada com os demais componentes da fila.
A arquitetura do &quot;Crossbar «escolhida por a ferramenta de geração de redes é sempre aquela compatível com a arquitetura de roteamento escolhida, uma vez que como explicado por a seção algoritmo de roteamento.
O quarto marcadorPin_ ground indica o local onde as portas não utilizadas por o roteador devem ser desligas.
Em uma topologia malha, nove combinações de roteadores com relação a o número de portas dos roteadores podem existir.
A Figura 20 ilustra as combinações, sendo possível existirem roteadores com 3, 4 e 5 portas.
O gerador de redes detecta a partir de o endereço do roteador durante a geração quais portas devem ser desligadas.
O quinto e último marcadorport_ type indica o local onde as arquiteturas que implementam as filas dos roteadores devem ser declaradas e ao mesmo tempo interconectadas com os demais componentes do roteador.
O componente &quot;HermesG_ Buffer «dá suporte a quatro arquiteturas de filas, selecionadas por o gerador a partir de as seguintes condições:
Quando somente uma frequência é definida para todos os roteadores e módulos de geração e recepção de pacotes, todos os roteadores irão fazer uso da arquitetura da fila do tipo Hermes.
Esta rede além de gastar menos tempo para rotear e transmitir um pacote ocupa menos área que a fila bi síncrona.
Como detalhado por a seção 3.1.2, a rede Hermes-G só se difere da rede Hermes por o uso das fila bi síncrona.
Dando suporte ao uso de filas do tipo Hermes quando uma única frequência é utilizada este trabalho permite estender as ferramentas de geração de avaliação de tráfego propostas também para redes Hermes.
Quando mais de uma frequência é utilizada, tanto por roteadores quanto por módulos de transmissão ou recepção de valores, o ambiente de geração irá fazer uso das filas síncronas (HERMESGS) e bi síncronas (HERMESG), utilizando a respectiva codificação de ponteiros com base no que foi definido durante a escolha dos valores da rede.
A escolha de qual fila será utilizada em cada porta é feita por a comparação da frequência do roteador com a frequência do roteador ou módulo transmissor/ receptor conectado na porta.
Se as frequências forem iguais é utilizado uma fila síncrona, se as frequências forem diferentes é utilizada uma fila bi síncrona capaz de garantir a comunicação, independente se transmissor conectado na fila for mais lento ou mais rápido que a frequência de operação da fila.
Uma vez gerados os roteadores, o componente &quot;NOC «que interconecta todos os roteadores formando a topologia malha da rede é copiado do diretório do ambiente Atlas que armazena o modelo para o diretório destino do projeto.
Durante a cópia do arquivo é feita uma busca e substituição de três marcadores presentes no arquivo.
O primeiro marcadorclock_ noc indica o local onde as conexões de entrada e saída do componente NOC deve ser declaradas.
Estas conexões permitem a componentes externos transmitir e receber dados da rede.
O segundo e o terceiro marcadormap_ router eport_ router são substituídos por as instancias dos roteadores, detalhados por a seção 3.4.2.2 e por a interligação das portas de entrada com as portas de saída dos roteadores, formando a topologia malha da rede.
A Figura 21 ilustra em (a) um roteador formado por cinco portas gerado através do processo descrito na seção 3.4.2.2 e em (b) uma rede composta por nove roteadores através do processo descrito por a seção 3.4.2.3.
Este capítulo descreve o processo relacionado ao tema de geração de tráfego sintético e tráfego utilizando modelos de aplicações CDCM para redes do tipo Hermes-G. De entre os tópicos explorados por este capitulo estão à caracterização dos tipos de tráfegos propostos, a descrição da implementação dos geradores de tráfego, e por fim o projeto e geração parametrizável dos componentes responsáveis por a transmissão, recebimento e automação do processo de simulação da rede.
Em a visão do autor, este capítulo é considerado com uma das contribuições apresentadas por este trabalho.
Esta seção explora quais são as características que compõem um tráfego sintético.
Em o escopo deste trabalho, duas modelagens de tráfego são propostas, sendo a descrita a seguir uma de elas.
Por esta razão, o autor preferiu adotar a nomenclatura do modelo de tráfego que será apresentado a seguir como tráfego sintético, uma vez que diferente de um modelo de aplicação, não leva em consideração aspectos presentes em aplicações, como por exemplo, a dependência na transmissão de um conjunto de pacotes, ou a variação no comprimento da informação a ser transmitida.
O modelo de tráfego sintético proposto permite que cada módulo transmissor conectado a um roteador, transmita uma quantidade de ilimitada de pacotes, podendo variar o tamanho dos pacotes em número de flits.
Cada módulo transmissor pode transmitir diferentes quantidades de pacotes possuindo diferentes tamanhos em flits.
A relação entre os destinos dos pacotes e os intervalos entre a geração de cada um dos pacotes é dada por a distribuição espacial, e por a distribuição temporal, descritas a seguir.
A distribuição espacial define a relação entre as origens e os destinos do tráfego.
As distribuições espaciais suportadas por o modelo de geração de tráfego sintético utilizado são propostas por, e descritas por a Figura 22.
Ao todo três distribuições são suportadas, descritas a seguir:
Aleatória: Em a distribuição aleatória, cada pacote de um tráfego terá um endereço destino escolhido de maneira aleatória por o gerador de tráfego.
Destino único:
Em a distribuição destino único todos os pacotes de um tráfego terão um único endereço destino.
Complemento: Em a distribuição complemento, todos os pacotes de um tráfego terão como destino o valor complemento do endereço em representação binária do roteador origem.
Destino único:
Roteador endereço zero envia todos os pacotes para um único endereço. (
c) Complemento:
Roteadores endereços zero e oito enviam tráfego para seus endereços complemento.
A distribuição temporal define a variação das taxas de injeção de um tráfego, sendo na visão do tráfego de pacotes, o intervalo de tempo entre a geração de cada um dos pacotes.
Este trabalho faz uso do modelo de variação de taxas de injeção descrito por a Figura 23, onde todos os pacotes do tráfego têm tamanho fixo, e a variação do intervalo de geração entre os pacotes, conforme descrito por a figura por o tempo de ociosidade, é quem define a taxa de injeção de cada pacote.
A equação que calcula o tempo de ociosidade de cada pacote é detalhada por a Figura 24.
O cálculo é feito a partir de o tamanho do pacote a ser transmitido multiplicado por a divisão da taxa máxima do transmissor dividido por a taxa de injeção do pacote.
A taxa de injeção de um pacote na visão deste trabalho pode ser fixa para todos os pacotes, ou pode ser variada conforme uma distribuição de probabilidade.
Onde: Ociosidade:
Período de ociosidade de um pacote.
TamanhoPacote: Tamanho do pacote (em número de flits).
NumCiclosFlit: Número de ciclos gastos para transmissão de um flit TaxaMaxIp:
Capacidade máxima de transmissão do gerador de pacotes.
TaxaInjPacote: Taxa de transmissão de um pacote.
Este trabalho da suporte a três distribuições de probabilidade, sendo elas a distribuição uniforme, a distribuição normal e a distribuição exponencial.
Com exceção da distribuição uniforme onde todos os pacotes são transmitidos a uma mesma taxa de injeção, as demais distribuições serão detalhadas a seguir.
Por conveniência, será detalhado como o cálculo da distribuição normal é realizado através de um estudo de caso.
Assume- se um cenário com de 10 pacotes com taxa de injeção mínima de 100 Mbits, taxa de injeção máxima de 200 Mbits, com taxa média de injeção de 150 Mbits, desvio padrão de 10 Mbits e incremento de 10 Mbits.
A partir de o intervalo mínimo de 100 Mbits e máximo de 200 Mbits e por o valor de incremento de 10 Mbits calculam- se 10 taxas de injeção no intervalo.
Durante o cálculo da distribuição normal, poderão ocorrer casos, como o da Figura 26 que durante o cálculo do número de taxas de injeção, ocorrerão sobras de pacotes.
Estes pacotes não calculados deverão por as regras definidas por a distribuição normal ser acrescida a taxa de injeção referente a a média da curva.
A implementação original da distribuição normal descrita em apresentou deficiências no cálculo da distribuição normal sob algumas variações nos intervalos das taxas de injeção.
Em, sendo este o mesmo autor deste trabalho, apresenta um conjunto de correções desenvolvidas para no cálculo da distribuição normal, que corrige as deficiências existentes.
Em a Figura 26 é possível visualizar que o cálculo no exemplo utilizado resultou em sobra de pacotes, acrescentados numa taxa de injeção próxima ao valor da média de 500 Mbits.
A distribuição exponencial decrescente é calculada para um número de pacotes a partir de quatro valores, sendo eles:
Taxa de injeção mínima;
Taxa de injeção máxima;
Taxa de injeção média;
Incremento; A equação que calcula a função de probabilidade de cada uma das taxas de injeção de um intervalo é ilustrada por a Figura 27.
A equação é formada por os valores da média da curva (µ), por a taxa de injeção (rate) e por o número de Euler (e).
Por conveniência, será detalhado como no exemplo anterior o cálculo da distribuição exponencial através de um estudo de caso.
Assume- se um cenário com de 10 pacotes com taxa de injeção mínima de 100 Mbits, taxa de injeção máxima de 200 Mbits, com taxa média de injeção de 150 Mbits e incremento de 10 Mbits.
A partir de o intervalo mínimo de 100 Mbits e máximo de 200 Mbits e por o valor de incremento de 10 Mbits calculam- se 10 taxas de injeção no intervalo.
Os mesmos tratamentos com relação a o cálculo do número de taxas e o arredondamento de pacotes detalhado para a distribuição normal se aplicam a distribuição exponencial.
Seguindo o que diz a regra, o excesso de pacotes calculado é colocado na taxa de injeção mínima da curva, que representa o ponto onde o maior número de pacotes é gerado.
A Figura 28 apresenta um exemplo de uma distribuição exponencial decrescente de 1000 pacotes distribuídos numa taxa mínima de 1 Mbits e uma taxa máxima de 1000 Mbits com média de 100 Mbits e incremento de 15 Mbits.
O ambiente de geração de tráfego sintético para redes Hermes-G diferentemente da abordagem utilizada por a seção 3.1, propõem evoluir o ambiente de geração de tráfego proposto por.
Modificações foram introduzidas neste ambiente de geração, tanto nos aspectos relacionados à parametrização de um tráfego, como na geração dos arquivos do tráfego.
Além disso, o ambiente de geração de tráfego para redes Hermes-G também é responsável por a geração dos arquivos do projeto referentes à transmissão, recepção e simulação da rede, gerados juntamente com os arquivos do tráfego.
Antes de detalhar quais são as características com relação a a interface gráfica do gerador e o processo de geração de tráfego, serão detalhadas algumas questões fundamentais a respeito processo de geração de tráfego.
O gerador de trafego permite a geração de diversos cenários de tráfego para um mesmo projeto de rede existente.
Para cada novo projeto de tráfego, um nome deve ser informado.
Este nome é utilizado para geração de um diretório e um arquivo cenário durante a geração do tráfego, sendo o diretório responsável por armazenar os arquivos do tráfego e o arquivo cenário por armazenar os parâmetros definidos para um tráfego, e permitir que este mesmo cenário possa ser editado.
Este arquivo cenário também é utilizado durante a simulação e avaliação da rede.
Em o escopo deste trabalho, o gerador de tráfego com as modificações feitas para dar suporte a redes HERMESG irá utilizar a mesma hierarquia de diretórios onde o tráfego será gerado, e o mesmo arquivo cenário capaz de possibilitar a criação e a edição de mais de um cenário de tráfego para um mesmo projeto de rede.
O item da Figura 29 permite ao clicar sobre um dos quadrados pretos que representam os transmissores de cada endereço selecionar o tipo de tráfego para cada um dos endereços geradores de tráfego.
A Figura 30 descreve a interface que possibilita a seleção dos parâmetros do tráfego para cada um dos geradores.
Em o gerador de tráfego Hermes-G, a frequência de operação de cada um dos módulos transmissores é conhecida, uma vez que durante a geração da rede, este valor deve ser informado.
Sendo assim, na Figura 30 o campo &quot;Frequency «apresenta a frequência do módulo gerador de maneira ocultada, que não permite ser modificada.
Em a Figura 30 o campo &quot;Target «define a distribuição espacial dos pacotes do tráfego, podendo como já descrita na seção 4.1.1 ser aleatório, destino único ou complemento.
Os campos e da Figura 30 permitem que o número de pacotes e o tamanho do pacote de um gerador sejam variados.
O campo da Figura 30 permite configurar as características temporais dos pacotes, através das distribuições normal, uniforme e exponencial descritas na seção 4.1.2.
O campo da Figura 30 permite visualizar graficamente uma distribuição temporal.
Durante a adaptação da interface do gerador que possibilita parametrizar o tráfego, a não existência de um tratamento de exceções nos campos de entrada levou o autor a estudar e propor condições mínimas de entrada de valores baseado em alguns critérios, descritos a seguir:
Para qualquer uma das três distribuições temporais, a taxa máxima de injeção deve ser sempre a frequência do gerador multiplicado por o comprimento do flit.
Por exemplo, numa rede com comprimento de flit igual a 8 bits e um gerador operando a 50 MHz, a taxa de injeção máxima é de 400 Mbits.
Em redes Hermes-G o tamanho mínimo de pacote suportado para geração de tráfego é de 13 flits.
O tamanho máximo do pacote em número de flits é limitado por a equação 2 (Comprimento do flit).
Por exemplo, numa rede com comprimento de flit igual a 8 bits, o tamanho máximo em flits de um pacote é de 256 flits.
O número máximo de pacotes de um tráfego é limitado por a equação 2 (Comprimento do flit* 2).
Por exemplo, numa rede com comprimento de flit igual a 8 bits, o número máximo de pacotes é de 65535 pacotes.
A partir de os valores informados através da interface gráfica é feita a geração do tráfego.
Em o modelo proposto por o tráfego de cada transmissor é representado em arquivos de texto, utilizados como entrada por estes módulos conectados nos roteadores.
Em cada uma das linhas destes arquivos texto estão presentes informações que compõem cada um dos pacotes.
A Figura 31 descreve o formato do pacote escrito por o gerador de tráfego num arquivo texto que representa o tráfego de um módulo transmissor.
A seguir cada um dos campos da Figura 31 que compõem um pacote serão detalhados:
Tempo de injeção em decimal. (
f) Número de sequência do pacote. (
g) Dados remanescentes do pacote.
O &quot;TimeStamp «define o momento ideal de injeção de um pacote em ciclos da frequência de operação do módulo transmissor.
A partir de uma distribuição temporal, cada um dos pacotes assume uma taxa de injeção.
De maneira incremental, o tempo de injeção de cada pacote é calculado a partir de a equação da Figura 24.
A seguir será detalhado através de um exemplo, o cálculo do tempo de injeção de três pacotes de 13 flits cada com taxa de injeção uniforme de 100 Mbits calculado para uma rede com comprimento de flit de 8 bits e um módulo transmissor de 100 MHz.
Aplicando a equação da Figura 24 para cada um dos três pacotes obtêm- se os seguintes valores descritos por a Tabela 3: Com base nos valores da Tabela 3 observa- se que o intervalo entre os pacotes é o mesmo de 104 ciclos, por o motivo de possuírem a mesma taxa de injeção de 100 Mbits.
Além disso, o cálculo do &quot;TimeStamp «de cada pacote é dado de maneira incremental uma vez que cada pacote demanda um tempo para ser transmitido.
Além de o &quot;TimeStamp «conforme ilustrado por a Figura 31 outros seis campos compõem o pacote do tráfego.
A seguir serão descritos cada um de eles:
Destino: O campo destino informa para qual roteador o pacote deve ser transmitido.
Este campo é utilizado por os roteadores da rede para calcular a rota que o caminho deve assumir.
Tamanho do &quot;Payload&quot;:
Por definição um pacote na rede Hermes-G é formado por dois campos, sendo eles o &quot;Header «que representa o cabeçalho do pacote e contem o destino e o tamanho do &quot;Payload», sendo o cabeçalho o responsável por realizar a conexão entre origem e destino.
Já o campo &quot;Payload «é responsável por representar a informação contida no pacote.
Por esta razão é que o campo tamanho do &quot;Payload «da Figura 32 possui este nome.
A função do campo Tamanho do &quot;Payload «é enviar ao transmissor o tamanho do pacote, utilizado durante a leitura para montagem do pacote final a ser transmitido na rede.
Origem: O campo origem informa de qual roteador o pacote esta sendo transmitido.
&quot;TimeStamp «em decimal:
Este campo descreve o tempo de transmissão do pacote em notação decimal, utilizado por o módulo transmissor durante a transmissão do pacote.
Número de sequência:
O número de sequência é utilizado para garantir que durante a avaliação do tráfego seja possível identificar os pacotes a partir de um número identificador.
O número de sequência é um identificador único, sendo assim, durante a geração de vários tráfegos para vários módulos geradores, é mantida uma sequência durante a geração para que cada pacote contenha um número único de pacote em relação a os demais.
Payload: O Payload contém o que na pratica representariam os dados de uma aplicação numa em uma transmissão.
Este campo é preenchido com valores aleatórios gerados por convenção a partir de o número dez em decimal.
Além de os arquivos referentes ao tráfego sintético, o ambiente de geração de tráfego adaptado para redes Hermes-G realiza a geração e a interconexão dos arquivos referentes ao ambiente que transmite e recebe pacotes na rede, referenciado a partir deste instante unicamente como Testbench.
O diretório onde estes arquivos devem ser criados é dado conforme o caminho e o nome do projeto da rede definidos durante a criação do projeto da rede.
Em este diretório a subpasta &quot;SC&quot;_ NOC «irá armazenar os arquivos referentes ao Testbench da rede, que ao todo são compostos por quatro arquivos sendo eles:
SC_ Input_ Module:
Responsável por a transmissão dos pacotes;
SC_ Output_ Module:
Responsável por a recepção dos pacotes;
HermesG_ Fifo_ Output:
Responsável por sincronizar a recepção dos pacotes quando o receptor opera numa frequência diferente do roteador;
TopNoC: Responsável por conectar os transmissores e os receptores a uma entidade de rede.
As próximas seções descrevem o processo de geração destes arquivos que formam o Testbench.
O componente responsável por a leitura e por a transmissão do tráfego é implementado por a entidade &quot;SC_ Input&quot;_ Module».
A versão original do componente, disponibilizada a este trabalho conforme descreve a seção 3.1.2 foi modificada, tanto com relação das portas de entrada e saída do componente quanto a sua arquitetura, uma vez que um novo formato de pacote de tráfego contendo novos campos foi proposto.
A Figura 33 ilustra quais são as portas de entrada e saída da entidade &quot;SC_ Input&quot;_ Module».
As portas de saída do componente são responsáveis por:
Data Out:
Enviar os dados do componente SC_ Input_ Module para o roteador.
O comprimento desta porta é gerado de maneira parametrizável, através do comprimento do flit gerado para rede.
Tx: Indicar a porta local do roteador que o transmissor deseja realizar uma comunicação com a rede.
Clock Out: Informar a porta local do roteador a frequência de operação do transmissor.
Finish: Indicar ao componente que finaliza a simulação da rede, descrito em detalhes na seção 4.2.4.3 que o transmissor enviou todos os pacotes do tráfego.
As portas de entrada do componente são responsáveis por:
Clock In:
Receber a frequência de operação do transmissor.
Reset: Recebe o sinal de reset do circuito.
Credit: Informar se a porta local do roteador ao qual o transmissor esta conectado tem capacidade de receber um pacote.
RotID: Informar o número do roteador, utilizado para leitura dos arquivos do tráfego para o respectivo transmissor.
A arquitetura da entidade &quot;SC_ Input&quot;_ Module «foi basicamente rescrita para comportar as condições de fim de transmissão e para dar a leitura e a transmissão dos novos campos do pacote.
Ao todo o componente opera em três fases, descritas resumidamente a seguir:
­ Realiza a leitura de um pacote do arquivo de tráfego.
Se existir um pacote vai para o item, caso contrário informa que transmitiu todos os pacotes do tráfego.
Quando todos os pacotes forem transmitidos volta novamente para o item.
O pacote transmitido é formado por sete campos ilustrados por a Figura 34, que contêm os valores referentes ao destino (a), utilizado por os roteadores para encaminhar o pacote, o tamanho do pacote (b) utilizado por as filas dos roteadores para garantir o chaveamento da conexão a partir de o tamanho do pacote e por a origem (c) e por o número de sequência (e) utilizados por a ferramenta de avaliação de tráfego descritas na Seção 5.3 para identificar os tráfegos.
Os valores referentes ao &quot;TimeStamp «(d) e ao Tempo de transmissão (f) são utilizados para os cálculos da vazão e da latência dos pacotes descritos por as seções 5.1.1 e 5.1.2.
O item Payload (g) é utilizado para completar o tamanho do pacote do tráfego parametrizado durante a geração.
O componente responsável por o recebimento dos pacotes da rede e por a escrita dos arquivos texto de saída do tráfego é descrito por a entidade &quot;SC_ Output_ Module».
A versão original do componente, disponibilizada a este trabalho conforme descreve a seção 3.1.2 foi modificada, tanto com relação das portas de entrada e saída do componente quanto a sua arquitetura, uma vez que um novo formato de pacote gerado por o transmissor contendo novos campos foi proposto.
As portas de entrada do componente responsáveis por:
RotID: Informar o número do roteador, utilizado para escrita dos arquivos de saída do tráfego recebidos por o receptor.
Clock: Receber a frequência de operação do receptor.
Reset: Recebe o sinal de reset do circuito Data In:
Receber os dados da porta local dos roteadores para o componente SC_ Output_ Module.
O comprimento desta porta é gerado de maneira parametrizável, através do comprimento do flit gerado para rede.
Tx: Indicar ao componente SC_ Output_ Module que a porta local do roteador deseja realizar uma comunicação.
As portas de saída do componente responsáveis por:
Credit: Indicar a porta local do roteador que o componente SC_ Output_ Module têm capacidade de receber ou não um pacote.
Idle: Indicar ao componente que finaliza a simulação da rede, descrito em detalhes na seção 4.2.4.3 que o componente receptor esta ocioso com relação a a recepção de pacotes.
A arquitetura da entidade &quot;SC_ Output_ Module «foi basicamente rescrita para comportar os novos campos do pacote.
Em resumo, ela aguarda a chegada dos pacotes, possuindo uma maquina de estados interna capaz de detectar quais campos esta recebendo, escrevendo estes valores no arquivo de saída do tráfego ao qual estiver conectado.
O pacote escrito no arquivo de saída referente a o tráfego é utilizado posteriormente para avaliação de tráfego.
O formato do pacote é ilustrado por a Figura 36 sendo composto por nove campos sendo eles o destino (a), a origem (c) e o número de sequência (e) utilizados por a ferramenta de avaliação descritas na Seção 5.3 para identificar os tráfegos.
Os campos TimeStampDecimal (d), Tempo Transmitido (f), TempoChegadaPF (h) e TempoChegadaUF (i) são utilizados para os cálculos da vazão e da latência dos pacotes descritos por as seções 5.1.1 e 5.1.2.
O componente TopNoC é responsável por declarar e conectar os transmissores e receptores a uma instancia de uma rede.
A seguir são descritas algumas das estruturas que o componente TopNoC é responsável por gerar e conectar:
&quot;HermesG_ Fifo_ Output «para o diretório de projeto, subpasta &quot;NOC».
Esta entidade é detalhada na seção 3.1.2.4, que descreve o componente &quot;Async_ Fifo».
O nome &quot;HermesG_ Fifo_ Output «foi escolhido por critério de padronização de nomenclatura com os demais arquivos da rede.
Além de estas condições, todo componente TopNoC é dotado de uma estrutura que finaliza a simulação de maneira automática uma vez que não exista tráfego na rede.
Esta estrutura foi desenvolvida, pois redes que possibilitam operar com várias frequências criam possibilidade de existirem cenários que levam muito tempo para serem simulados, e ao mesmo tempo difíceis de estimar um valor otimista para um tempo de simulação.
Esta estrutura faz uso de três valores, sendo eles os sinais de &quot;Finish «de todos os transmissores, que indica quando o transmissor terminar de transmitir seus tráfegos, o sinal de &quot;Idle «de todos os receptores, que indica se o receptor esta recebendo tráfego ou se está ocioso, e a condição de fila vazia de todas as filas de todos os roteadores da rede, inclusive as filas utilizadas entre os roteadores e os receptores.
Uma vez todos os transmissores tendo transmitidos seus pacotes, e os receptores estarem e um estado de ociosidade, e todas as filas da rede estiverem vazias, a estrutura enviará um evento externo ao simulador que irá retornar a chamada ao arquivo que automatiza a simulação descrito por a Seção a seguir que irá finalizar automaticamente a simulação.
O arquivo «Simulate.
De o é gerado para um projeto de rede contendo os comandos de compilação e simulação da rede, de maneira que este arquivo uma vez disparado automatiza a simulação da rede.
Este arquivo contém uma condição que após disparar o comando de simulação da rede, aguarda que um evento externo do simulador informe o fim da simulação, para então finalizar sua execução.
A simulação de um tráfego sintético é feita a partir de a leitura dos arquivos do tráfego e da transmissão dos pacotes na rede.
Por fim, os receptores coletam os pacotes e escrevem os arquivos de saída, contendo os dados dos pacotes e os tempos gastos durante a transmissão.
Como já descrito em seções anteriores, o autor deste trabalho desenvolveu uma ferramenta de testes em caráter experimental, com objetivo de verificar se as características funcionais da rede e do ambiente de Testbench da rede estavam operacionais conforme os critérios assumidos durante o desenvolvimento.
A ferramenta de testes permite através da interface de linha de comando ilustrada por a Figura 37 que diferentes abordagens sejam utilizadas para definir cenários de teste, estes formados por arquivos de rede e de tráfego.
Para esta ferramenta o autor propôs uma distribuição de tráfego alternativa às demais existentes no gerador de tráfego do ambiente Atlas, onde todos os elementos transmissores da rede geram tráfegos para todos os endereços da rede, com exceção de ele mesmo.
A distribuição temporal utilizada é uniforme, que assume a taxa máxima de transmissão do transmissor.
O modelo de tráfego varia o número e o tamanho dos pacotes de diversas maneiras, seja a partir de parâmetros informados por o usuário durante a geração dos cenários ou de maneira aleatória.
Em a visão do autor, esta abordagem maximiza que todas as combinações possíveis de caminhos sejam utilizados por os pacotes.
Utilizando uma opção do ambiente, que permite gerar todas as combinações de redes num intervalo de parâmetros, o autor obteve ao todo 50.400 cenários possíveis de teste para redes do tipo Hermes-G variando as opções de dimensões da rede, profundidade das filas, comprimento dos canais, arquiteturas de roteamento e codificação de ponteiro das filas.
Como já descrito, a ferramenta além de possibilitar que a simulação seja feita de maneira automática, e finalizada quando os tráfegos de um cenário forem transmitidos, o autor adicionou na ferramenta diretivas que detectam a capacidade da arquitetura de processamento do computador hospedeiro e exploram a capacidade &quot;Multithreading «quando existirem.
Durante as simulações o autor detectou ganhos significativos na redução do tempo das simulações com o uso desta técnica.
Além de a simulação a ferramenta também verifica o tráfego gerado e compara se os pacotes do tráfego foram corretamente recebidos nos destinos.
Para os 50.400 cenários de testes simulados, em todos os casos houve sucesso na transmissão na e recepção dos pacotes.
Além de a proposta de um modelo de tráfego sintético, este trabalho também propôs fazer uso de modelos de aplicações para descrever tráfego para uma rede Hermes-G. Este trabalho faz uso do modelo de aplicações CDCM, do inglês &quot;Communication Dependence and Computation Model «proposto por que representa uma aplicação por a sua computação e sua comunicação.
De acordo com, o modelo permite definir com precisão o tempo de computação, uma vez que para cada mensagem da aplicação é possível definir o tempo de computação, o tamanho da mensagem e suas dependências.
O modelo CDCM proposto é representado através de um grafo CDCG, do inglês &quot;Communication Dependence and Computation Graph», sendo este utilizado para descrever as aplicações.
Em o escopo do trabalho definido por, é proposto um ambiente denominado CAFES acrônimo do inglês para &quot;Communication Analysis for Embedded Systems «que permite a geração e o mapeamento de modelos CDCM.
O processo de criação e geração de um modelo de aplicação no escopo deste trabalho é feito em três partes ilustradas por a Figura 38.
O ambiente CAFES ilustrado por a Figura 38 item (a) é utilizado nas etapas de criação e mapeamento de um modelo de aplicação.
Esta etapa irá gerar um arquivo intermediário que servirá de entrada para a ferramenta de geração de tráfego do ambiente Atlas ilustrado por a Figura 38 item (b) que a partir de as definições contidas neste arquivo irá gerar o Testbench contendo os arquivos de tráfego e o ambiente de transmissão e recepção adaptado para as características do modelo de aplicação CDCM informado.
O ambiente CAFES permite descrever modelos de aplicação CDCM a partir de grafos CDCG.
Um grafo CDCG, conforme ilustrado por a Figura 39 é composto por um conjunto de tarefas, descritas através de vértices.
Toda aplicação deve possuir obrigatoriamente um inicio, descrito no grafo por o vértice &quot;START «e um fim, descrito no grafo por o vértice &quot;END».
Cada tarefa possui os seguintes campos:
Tempo de processamento:
Define um tempo de processamento da tarefa expressa em nano segundo.
Identificador origem e destino:
Define quem são a origem e o destino relacionados à tarefa.
Durante o mapeamento os identificadores são traduzidos em endereços da rede.
Mensagem de transmissão:
Define uma mensagem que deve ser transmitida após o processamento acontecer, expressa em flits.
Dependências de entrada:
Definem os eventos que devem acontecer para que a tarefa seja executada.
Dependências de saída:
Definem quais outras tarefas devem ser disparadas após a execução da tarefa.
O grafo CDCG permite definir de maneira precisa as características relacionadas ao tempo de processamento e quantidade de transmissão.
Ele também permite particionar a aplicação em tarefas, e definir quais são os eventos que devem acontecer antes que cada tarefa deva ser executada, e quais eventos devem ser disparados após sua execução.
Uma vez descrita à aplicação, o ambiente permite realizar o mapeamento das tarefas para um modelo de rede de tamanho definido.
O mapeamento é feito levando em consideração um conjunto de requisitos com objetivo de minimizar o consumo de energia e a redução no tempo de execução da aplicação na rede.
Ao todo o ambiente permite três estratégias de mapeamento, sendo que no escopo do trabalho, o mapeamento só é utilizado para conhecer em quais endereços as tarefas que compõem uma aplicação devem ser mapeadas, sendo assim não será detalhado.
Em a seção 7.2 o autor comenta numa possível adaptação do processo de mapeamento, uma vez que o mapeamento como é feito atualmente leva em consideração uma rede contendo uma única frequência de operação.
A Figura 40 descreve a ferramenta de mapeamento do ambiente CAFES para o grafo ilustrado por a Figura 39, onde cada endereço da rede irá comportar uma tarefa.
Uma vez realizado o mapeamento o ambiente CAFES foi adaptado para gerar um arquivo contendo os valores referentes à aplicação e ao mapeamento, utilizadas por a ferramenta de geração de tráfego do ambiente Atlas, conforme ilustrado por a Figura 38 (b) para geração dos arquivos de tráfego e do Testbench.
A seguir serão detalhados quais são as características salvas da aplicação neste arquivo.
O arquivo que contem as características de um de modelo de aplicação é gerado num diretório informado por o usuário durante o processo do mapeamento, contendo o nome do projeto e a extensão».
Model». O arquivo contêm ao todo quatro campos que representam os dados da aplicação, e são utilizados por a ferramenta de geração de trafego do ambiente Atlas para gerar os arquivos do tráfego e o Testbench para o modelo de aplicação CDCM.
A Figura 41 descreve um exemplo de um arquivo, sendo que os quatro campos que representam os dados da aplicação serão detalhados a seguir:
Noc Size: Informa o tamanho da rede utilizada por a aplicação.
A ferramenta de geração utiliza este valor para verificar se a rede gerada por o usuário irá comportar o número de tarefas da aplicação.
A partir destes campos a ferramenta de geração de tráfego realiza a geração dos arquivos que compõem as mensagens a serem transmitidas e o Testbench formado por os arquivos transmissores e receptores do tráfego.
A interface gráfica do gerado de tráfego foi adaptada para dar suporte à leitura do arquivo que descreve o modelo de uma aplicação, conforme ilustrado por a Figura 42.
Após o modelo ser carregado é feita uma verificação que detecta se a extensão do arquivo é valida, e então efetua a leitura dos campos do arquivo.
Durante a leitura do arquivo o ambiente verifica se as dimensões da rede utilizada por a aplicação são iguais ao projeto da rede gerada, como outros valores da aplicação relacionada às capacidades da rede, como por exemplo o tamanho das mensagens ou o tempo de processamento, que variam conforme o comprimento do flit utilizado por a rede.
Durante a leitura o ambiente informa se o arquivo que descreve a aplicação esta de acordo com as restrições impostas por um projeto de rede.
Uma vez estão de acordo é apresentado a mensagem de sucesso conforme ilustrado por a Figura 42, sendo que o botão &quot;Generate «é liberado para que os arquivos do tráfego e o Testbench composto por os transmissores, receptores e por o arquivo que interconecta a rede aos transmissores e os receptores sejam então gerados.
Durante a geração destes arquivos o ambiente gera também um arquivo cenário de tráfego que contêm informações a respeito de o tráfego, utilizado para carregar o cenário gerado durante a avaliação do tráfego da rede.
A partir de os valores das tarefas descritas no arquivo da aplicação é feita a geração do tráfego.
Após um conjunto de propostas alternativas, o autor preferiu adotar a mesma abordagem utilizada no tráfego sintético descrito por a seção 4.2.3 onde o tráfego de cada transmissor é representado em arquivos de texto utilizados como entrada por estes módulos conectados nos roteadores.
Cada tarefa possui uma mensagem contendo um conjunto de informação a ser transmitida.
O autor deste trabalho definiu que cada mensagem seria transmitida como um único pacote, sendo assim, as mensagens de cada tarefa mapeada para um endereço da rede é vista como um pacote descrito num arquivo de texto que caracteriza o tráfego.
Origem: O campo origem informa de qual endereço o pacote esta sendo transmitido.
Ele é obtido a partir de o identificador origem da tarefa, que este associado a um endereço da rede.
Destino: O campo destino informa para qual roteador o pacote deve ser encaminhado.
Ele é obtido a partir de o identificador destino da tarefa, que este associado a um endereço da rede.
Tempo de processamento:
O tempo de processamento é definido em ciclos de relógio da frequência de cada transmissor, calculado a partir de o tempo de transmissão de cada tarefa.
Tamanho do pacote:
Define o tamanho do pacote em flits, calculado a partir de o tamanho da mensagem definido para cada tarefa.
Número de sequência:
O número de sequência é utilizado para garantir que durante a avaliação do tráfego seja possível identificar os pacotes a partir de um número identificador.
Este número é gerado através de identificador único, sendo assim, durante a geração dos pacotes referente as tarefas o ambiente de geração garante que cada pacote irá possuir um número de sequência único diferente em relação a os demais.
Roteador destino do pacote. (
c) Tempo de processamento do pacote em ciclos. (
d) Tamanho do pacote. (
e) Número de sequência do pacote.
A partir de os valores informados por o arquivo que descreve a aplicação são gerados os respectivos transmissores, receptores e um componente que interliga a rede gerada durante a geração da rede aos transmissores e os receptores.
Por existirem mudanças com relação a maneira como a transmissão é feita, um novo componente transmissor foi desenvolvido.
O componente CDCG_ TopNoC que interliga a rede aos transmissores e receptores sofreu uma revisão em suas estruturas, uma vez que agora este arquivo coordena a transmissão das tarefas levando em consideração suas dependências existentes.
A fim de garantir que a ferramenta de avaliação de tráfego e as técnicas relacionadas a avaliação de tráfego propostas fossem suportadas para este modelo de tráfego, o formato do pacote transmitido na rede, a arquitetura do receptor de tráfego e o formato dos pacotes de saída do tráfego permanecem os mesmos.
Permitindo que o ambiente de avaliação de tráfego descrito por o capitulo 5 de suporte a avaliação de tráfego de modelos de aplicações CDCM para redes Hermes-G. O componente responsável por a leitura e por a transmissão do tráfego de modelos de aplicações CDCM é suportado por a entidade &quot;SC_ CDCG_ Input&quot;_ Module».
Com relação a variação nas portas de entrada e saída comparado a entidade &quot;SC_ Input&quot;_ Module &quot;utilizada para transmissão de tráfego sintético descrita por a seção 4.2.4.1, o componente «SC_ CDCG_ Input&quot;_ Module &quot;possui uma porta de entrada «Send &quot;e uma porta de saída «Receive «conforme ilustradas por a Figura 44, utilizadas para comunicação entre o transmissor e a entidade CDCG_ TopNoC.
A porta de entrada &quot;Send «indica ao componente transmissor que um pacote deve ser lido e transmitido, já a porta &quot;Receive «é utilizada por o transmissor para confirmar quando o pacote foi transmitido à rede.
A arquitetura da entidade &quot;SC_ CDCG_ Input&quot;_ Module «foi projetada para assumir o seguinte comportamento:
O componente CDCG_ TopNoC é responsável por declarar e conectar os transmissores e receptores a uma instancia de uma rede.
A seguir são descritas algumas das estruturas que o componente CDCG_ TopNoC é responsável por gerar e conectar:
&quot;HermesG_ Fifo_ Output «para o diretório de projeto, subpasta &quot;NOC».
Esta entidade é detalhada na seção 3.1.2.4, que descreve o componente &quot;Async_ Fifo».
O nome &quot;HermesG_ Fifo_ Output «foi escolhido por critério de padronização de nomenclatura com os demais arquivos da rede.
Além de estas condições, todo componente CDCG_ TopNoC possui uma estrutura responsável por controlar a transmissão das tarefas, de maneira que as dependências existentes entre as tarefas sejam levadas em consideração.
O componente CDCG_ TopNoC através dos sinais de &quot;Send «e &quot;Receive «coordena a transmissão das tarefas, possuindo uma memória que armazena quais são as dependências de cada tráfego, e qual deve ser o fluxo de eventos a ser executado para que todas as tarefas executem sendo que suas dependências sejam levadas em consideração.
Todo componente CDCG_ TopNoC é dotado de uma estrutura que finaliza a simulação de maneira automática uma vez que não exista tráfego na rede.
Esta estrutura foi desenvolvida, pois redes que possibilitam operar com várias frequências criam possibilidade de existirem cenários que levam muito tempo para serem simulados, e ao mesmo tempo difíceis de estimar um valor otimista para um tempo de simulação.
Esta estrutura faz uso de três valores, sendo eles os sinais de &quot;Finish «de todos os transmissores, que indica quando o transmissor terminar de transmitir seus tráfegos, o sinal de &quot;Idle «de todos os receptores, que indica se o receptor esta recebendo tráfego ou se está ocioso, e a condição de fila vazia de todas as filas de todos os roteadores da rede, inclusive as filas utilizadas entre os roteadores e os receptores.
Uma vez todos os transmissores tendo transmitidos seus pacotes, e os receptores estarem e um estado de ociosidade, e todas as filas da rede estiverem vazias, a estrutura enviará um evento externo ao simulador que irá retornar a chamada ao arquivo que automatiza a simulação descrita por a Seção a seguir que irá finalizar automaticamente a simulação.
O arquivo «Simulate.
De o é gerado para um projeto de rede contendo os comandos de compilação e simulação da rede, de maneira que este arquivo uma vez disparado automatiza a simulação da rede.
Este arquivo contém uma condição que após disparar o comando de simulação da rede, aguarda que um evento externo do simulador informe o fim da simulação, para então finalizar sua execução.
A simulação de um tráfego de modelos de aplicação CDCM é feita a partir de a leitura dos arquivos do tráfego e da transmissão dos pacotes na rede.
Por fim, os receptores coletam os pacotes e escrevem os arquivos de saída, contendo os dados dos pacotes e os tempos gastos durante a transmissão.
Este Capítulo apresenta questões relacionadas à avaliação de tráfego do trabalho.
Em ele são descritas as métricas e suas variações utilizadas para avaliar o tráfego, e como elas são calculadas.
Além disso, o autor descreve o ambiente de avaliação de tráfego proposto originalmente por e estendido por este trabalho para dar suporte à avaliação de tráfego para redes não síncronas.
Em a visão do autor, este capítulo é considerado com uma das contribuições apresentadas por este trabalho.
Este trabalho faz uso de duas métricas para avaliar o tráfego.
A primeira de elas a latência responsável por calcular o tempo gasto por um pacote ser transmitido.
A segunda de elas a vazão que calcula a quantidade de informação transmitida numa unidade de tempo.
A seguir serão detalhados como estes valores são expressos, obtidos e calculados.
A latência é utilizada por este trabalho para calcular o tempo gasto por um pacote para ser transmitido.
Em o escopo deste trabalho o tempo é expresso em segundos, porém, a transmissão ocorre em frações de um segundo, sendo assim a latência utiliza de um submúltiplo do segundo o nano segundo &quot;ns», que representa a 1x10- 9 segundo.
A latência do pacote no escopo da rede é vista como a diferença do intervalo entre o momento em que o primeiro flit do pacote tenta entrar na rede até o último flit do pacote sair da rede.
Com base nas explicações feitas nas seções 4.2.4.1 e 4.2.4.2, o transmissor e o receptor durante a transmissão de cada pacote anotam os momentos em que o pacote tentou entrar e saiu da rede.
Estes valores podem ser obtidos nos arquivos de saída do tráfego que são escritos por os receptores.
A Figura 36 descreve o formato de um pacote presente nos arquivos de saída do tráfego, sendo que o item (f) da Figura 36 representa o tempo em ciclos de relógio da frequência do transmissor que o primeiro flit do pacote tentou entrar na rede e o item da Figura 36 representa o tempo em ciclos de relógio da frequência do receptor que o último flit do pacote saiu da rede.
O cálculo da latência de um pacote é feito durante o processo de avaliação de tráfego.
Primeiramente os valores que descrevem os intervalos em que cada pacote requisitou a rede, e o intervalo que cada pacote saiu da rede são convertidos de ciclos de relógio para tempo absoluto.
Repare que as frequências do transmissor e do receptor podem ser diferentes, por esta razão que o cálculo da latência é feito durante a avaliação de tráfego, pois o ambiente conhece quais são as frequências de ambos os componentes.
Feito isso, a equação descrita por a Figura 45 é utilizada, onde o tempo de chegada do último flit do pacote no receptor em tempo absoluto é subtraído do tempo que o pacote tentou ser transmitido na rede por o transmissor em tempo absoluto.
O valor resultante desta equação é o tempo gasto por o pacote para ser transmitido, ou seja, a latência do pacote.
A vazão é utilizada por este trabalho para medir a quantidade de informação transmitida entre um dos caminhos possíveis da rede num intervalo de tempo.
Em o escopo deste trabalho a vazão é expressa em bits por segundo (bps), porém, a capacidade da rede possibilita que centenas de milhares de bits sejam transferidos por segundo.
Sendo assim, este trabalho faz uso do múltiplo Mbps, ou Megabit por segundo, que representa um milhão de bits transferidos por segundo.
Em o escopo da rede a vazão é vista como a quantidade de bits transmitidos divididos por o tempo gasto para transmissão do pacote.
A quantidade de bits transmitida refere- se ao tamanho do pacote, obtido através de um dos campos do pacote no arquivo de saída do tráfego, já o tempo de transmissão referente a latência do pacote é obtida através dos cálculos descritos por a seção O calculo da vazão de um pacote é feito durante o processo de avaliação de tráfego.
A equação ilustrada por a Figura 46 realiza o cálculo da vazão, por a divisão do tamanho do pacote em bits por a latência do pacote em tempo absoluto.
A vazão calculada é então multiplicada por 1000 para ser expressa em Mbps.
Além de os valores de vazão e latência medidos durante a transmissão de um pacote, o ambiente de avaliação de tráfego proposto por propõem a utilização de medidas estatísticas no calculo das métricas propostas durante a avaliação do tráfego.
A seguir serão detalhadas quais são as medidas estatísticas utilizadas e como seu cálculo é feito.
O ambiente de avaliação de tráfego faz uso de duas medidas estatísticas no cálculo da latência de um conjunto de pacotes, sendo elas a latência média e o desvio padrão da latência.
Além disso, o ambiente também calcula a latência ideal de transmissão de um pacote na rede, a partir de valores conhecidos sobre as características da rede e do caminho utilizado durante o roteamento.
A latência ideal de um pacote informa o tempo mínimo de transmissão de um pacote da origem ao destino, calculado a partir de as características da rede.
Em o escopo do ambiente de avaliação de tráfego, a latência ideal é utilizada para comparar a latência medida de um pacote com o tempo ideal de transmissão.
O cálculo da latência ideal leva em consideração uma série de aspectos envolvendo as características da rede, sendo elas o número de roteadores existentes entre a origem e o destino, a frequência de operação de cada um dos roteadores e o algoritmo de roteamento utilizado.
Por existir a necessidade durante a avaliação de conhecer os roteadores do caminho, o calculo da latência ideal só poderá ser feito para roteamentos determinísticos, uma vez que é impossível conhecer o caminho assumido utilizando roteamentos adaptativos.
Por ordem o tempo de transmissão de um pacote é composto por o tempo gasto por o primeiro flit do pacote para realizar o roteamento, que deve ser somado ao tempo de transmissão dos demais flits do pacote.
Primeiramente será detalhado como é calculado o tempo de roteamento, sendo este o processo que envolve maior complexidade para ser calculado.
O primeiro passo executado no calculo é verificar quais são os roteadores entre a origem e o destino do pacote, logo em seguida verificar quais são as filas síncronas (HERMESGS) e quais são as filas bi síncronas (HERMESG) utilizadas entre os roteadores.
Ao todo podem existir duas combinações de roteadores, sendo que cada uma de elas consome um tempo diferente para realizar a escrita, a sincronização do dado e a requisição de roteamento.
A primeira combinação de roteador faz uso da fila síncrona (HERMESGS) e obrigatoriamente conforme definido nas regras de geração da rede vai estar conectado a outra fila síncrona (HERMESGS), consumindo ao todo cinco ciclos de relógio da frequência do roteador para escrever, sincronizar e realizar o roteamento do primeiro flit do pacote.
Este valor em ciclos é convertido para tempo absoluto utilizando o valor da frequência do roteador.
A segunda combinação de roteador faz uso da fila bi síncrona (HERMESG), pode conforme as regras de geração estar conectada a uma fila síncrona (HERMESGS) ou uma fila bi síncrona (HERMESG), consumindo um tempo não determinístico entre a escrita do primeiro flit na fila do roteador e a sincronização da fila.
Por regra a fila consome meio ciclo de relógio da frequência da escrita, para escrever o primeiro flit do pacote, e gasta um tempo não determinístico, que no pior caso pode levar até um ciclo de relógio da frequência de leitura do roteador para sincronização da fila.
Sendo assim, este trabalho assume que o calculo da latência ideal leva em consideração o pior caso com relação a o efeito não determinístico causado por a sincronização da fila, podendo existir assim, cenários em que o tempo medido para transmissão de um pacote seja menor que a latência ideal calculada.
Em o total, o tempo gasto para escrever, sincronizar e rotear o primeiro pacote, nessa combinação de roteador considerando o pior caso é de meio ciclo de relógio da frequência da escrita e sete ciclos de relógio da frequência de leitura do roteador, sendo quatro ciclos utilizados para o roteamento, e três para a sincronização dos ponteiros da fila.
Este valor em ciclos é convertido para tempo absoluto utilizando os valores das frequências de leitura e de escrita do roteador.
Uma vez conhecidos os roteadores e seus respectivos tempos gastos para transmitir o primeiro pacote, é feito um somatório dos tempos gastos por cada um dos roteadores existentes onde é obtido o tempo ideal de transmissão do primeiro flit.
Para os demais flits que compõem um pacote é feita uma busca por o componente com a menor frequência entre a origem e o destino, sendo que são levados em consideração tanto os roteadores quanto o transmissor e o receptor do caminho.
A menor frequência encontrada é convertida em tempo absoluto e multiplicada por os demais flits que compõem um pacote, uma vez que depois de realizada a conexão entre a origem e o destino, cada flit irá gastar um ciclo da frequência mais lenta entre a origem e o destino para ser transmitida.
O tempo obtido para os demais flits do pacote é somado ao tempo do primeiro flit do pacote, obtendo assim a latência ideal do pacote.
A latência média de um conjunto de pacotes é uma medida estatística que representa o tempo médio gasto por um conjunto de pacotes para ser transmitido.
O cálculo da média ilustrado por a Figura 47 é feito a partir de a divisão do somatório de todos os valores de cada uma das latências dos pacotes medidas durante a transmissão de um determinado fluxo de pacotes origem-destino do tráfego por o número total de pacotes.
O desvio padrão da latência de um conjunto de pacotes é uma medida estatística que representa a dispersão das latências dos pacotes em relação a a média.
Quanto menor for este valor, menor será a variação nos tempos de transmissão dos pacotes, indicando que a transmissão ocorreu de maneira uniforme para o conjunto de pacotes calculado.
O cálculo do desvio padrão de um conjunto de pacotes é ilustrado por a Figura 48.
Ele é feito a partir de a raiz quadrada da divisão do somatório das latências dos pacotes subtraídos da média dos pacotes elevados ao quadrado por o número total de pacotes.
O ambiente de avaliação de tráfego faz uso de duas medidas estatísticas no cálculo da vazão de um conjunto de pacotes, sendo elas a vazão média e o desvio padrão da vazão.
Além disso, o ambiente também calcula a vazão ideal de transmissão de um pacote na rede, a partir de valores conhecidos sobre as características de uma rede e do caminho utilizado durante o roteamento.
A vazão ideal informa a quantidade de informação possível de ser transmitida entre um caminho da rede num intervalo de tempo, calculado a partir de as características da rede.
Em o escopo deste trabalho, a vazão ideal é utiliza para avaliar a vazão medida de um conjunto de pacotes com a vazão ideal do caminho, que representa a quantidade máxima de informação possível de ser transmitida.
A vazão média de um conjunto de pacotes é uma medida estatística que representa a quantidade média de informação transmitida por um conjunto de pacotes.
O cálculo da vazão média é feito por a Figura 50 a partir de a divisão do somatório de todos os valores das vazões calculadas de um conjunto de pacotes por o número total de pacotes.
O calculo da vazão de cada pacote é feito conforme detalhado na seção 5.1.2 a partir de a latência medida de cada pacote.
O desvio padrão da vazão de um conjunto de pacotes é uma medida estatística que representa a dispersão das vazões dos pacotes em relação a média.
Quanto menor for este valor, menor será a variação da quantidade de informação transmitida por os pacotes, indicando que a transmissão ocorreu de maneira uniforme para o conjunto de pacotes calculado.
O cálculo do desvio padrão de um conjunto de pacotes é ilustrado por a Figura 51.
Ele é feito a partir de a raiz quadrada da divisão do somatório das vazões dos pacotes subtraídos da média dos pacotes elevados ao quadrado por o número total de pacotes.
A partir de as métricas e das medidas estatísticas descritas por as seções 5.1 e 5.2 o ambiente de avaliação de tráfego originalmente proposto por foi adaptado para comportar os cálculos e dar suporte à avaliação de tráfego para redes Hermes-G. O ambiente de avaliação de tráfego faz uso do arquivo cenário do tráfego, definido na seção 4.2.1 como arquivo de entrada para avaliar o tráfego, e permite que para o mesmo projeto de rede que contenha vários cenários já simulados seja possível avaliar cada um de maneira independente a partir de o cenário de tráfego.
Ao todo quatro ferramentas que permitem avaliar o tráfego, foram modificadas sendo elas Distribuição de vazões;
Distribuição de latências;
Analisador de latências;
Relatório global.
Estas ferramentas foram adaptadas para dar suporte ao cálculo do tráfego para redes Hermes-G, e serão detalhadas a seguir.
A ferramenta distribuição de vazões através de um ambiente gráfico ilustrado por a Figura 52 disponibiliza a visualização dos valores relacionados à vazão medida de um determinado conjunto de pacotes entre um transmissor e um receptor.
De entre os valores relacionados estão à vazão de cada um dos pacotes, calculado a partir de o método descrito por a seção 5.1.2, a média das vazões dos pacotes calculadas a partir de o método descrito por a seção 5.2.2.2 e o desvio padrão da vazão calculado a partir de o método descrito por a seção 5.2.2.3.
A Figura 52 descreve um tráfego uniforme injetado a 400 Mbps de dois pacotes do endereço 00 ao endereço 11.
A partir de os campos disponibilizados por a ferramenta de distribuição de vazões é possível avaliar que para o tráfego exemplo utilizado, um pacote teve vazão de aproximadamente 200 Mbps e o outro pacote vazão de 250 Mbps.
Além disso, a média dos valores foi de 227.0 Mbps e o desvio padrão de 23.9 Mbps.
A ferramenta distribuição de latências através de um ambiente gráfico ilustrado por a Figura 53 disponibiliza a visualização dos valores relacionados à latência de um determinado conjunto de pacotes entre um transmissor e um receptor.
De entre os valores relacionados estão à latência de cada um dos pacotes, calculado a partir de o método descrito por a seção 5.1.1, a média das latências calculadas a partir de o método descrito por a seção 5.2.1.2 e o desvio padrão da vazão calculado a partir de o método descrito por a seção 5.2.1.3.
A Figura 53 descreve um tráfego uniforme injetado a 400 Mbps de dois pacotes do endereço 00 ao endereço 11.
A partir de os campos disponibilizados por a ferramenta de distribuição de latência é possível que para o tráfego exemplo utilizado, um pacote teve latência de aproximadamente 1020 ns e o outro pacote latência de 1260 ns.
Além disso, a média dos valores foi de 1140 ns e o desvio padrão de 120 ns.
A ferramenta analisador de latências através de um ambiente gráfico ilustrado por a Figura 54 permite a visualização de um conjunto de pacotes de todos os tráfegos que levaram mais ou menos tempo para serem transmitidos.
Para todo valor de latência é informado também o número de sequência e o endereço de origem e de destino do pacote.
A latência dos pacotes é calculada a partir de o método descrito por a seção 5.1.1, os valores referentes ao número de sequência, origem e destino são capturados diretamente dos pacotes nos arquivos do tráfego.
A ferramenta de relatório global através de um ambiente gráfico ilustrado por a Figura 55 permite que todos os tráfegos transmitidos entre um endereço origem e destino sejam avaliados sobre duas óticas.
A primeira de ela apresenta os valores de vazão ideal e latência ideal de cada tráfego, calculado conforme os métodos descritos por as seções 5.2.1.1 e 5.2.2.1.
A segunda apresenta os valores medidos de um tráfego, sendo eles a média da vazão e da latência, o desvio padrão da vazão e da latência e os valores de vazão e latência mínima e máxima.
Além disso, o ambiente disponibiliza para cada tráfego dois botões que permitem disparar as ferramentas de distribuição de vazão e distribuição de latências detalhadas nas seções 5.3.2 e 5.3.1.
Este capítulo apresenta um conjunto de experimentos desenvolvidos com objetivo de validar os conceitos propostos por este trabalho e avaliar de maneira resumida alguns cenários de rede e de tráfego apresentados nos capítulos anteriores referentes à proposta deste trabalho.
De entre os estudos de caso desenvolvidos, o autor pretende demonstrar como é possível aumentar o desempenho de um cenário de tráfego proposto variando as características da rede como o tipo de roteamento utilizado e a frequência de operação.
Além disso, são feitas comparações em área usando diferentes variações da rede.
Este estudo de caso propõe estudar o impacto resultante no desempenho de tráfegos concorrentes em dois modelos de rede, uma operando totalmente de maneira síncrona e outra operando de maneira não síncrona possuindo ao todo duas ilhas de frequência síncronas.
O cenário sugerido de maneira geral faz uso de uma rede com dimensões de três linhas por três colunas formadas no total por nove roteadores onde quatro de eles conectam processadores, dois de eles conectam elementos de memória, e três de eles elementos de entrada e saída.
Este estudo de caso foi proposto seguindo algumas tendências no projeto de SOC atuais, contendo quatro processadores operando numa ilha de frequências mais altas, diferente dos componentes de memória e entrada e saída que operam em outra ilha de frequências.
Em ambos os modelos de rede foram utilizados dimensões 3x3, comprimento de canais igual a 16 bits, profundidade das filas igual a 16 flits, algoritmo de roteamento &quot;Negative First Non Minimal «e codificação de ponteiros das filas Johnson.
Em este cenário optou- se por trabalhar unicamente com filas bi síncronas, uma vez que utilizando um cenário totalmente síncrono com filas síncronas do tipo Hermes, o tempo de sincronização e transmissão da fila influenciaria nos resultados.
Os processadores serão mapeados nos endereços, os elementos de memória nos endereços e os elementos de entrada e saída nos roteadores.
O primeiro modelo de rede faz uso de um único domínio de frequência em todos os roteadores, transmissores e receptores.
O segundo modelo faz uso de dois domínios de frequência, conforme ilustrado por a Figura 56, o primeiro de eles no quadrado pontilhado onde os processadores estão mapeados, faz uso de uma frequência de 500 MHz para os roteadores, transmissores e receptores.
Já no quadrado preto onde estão mapeados os elementos de memória e de entrada e saída é utilizada uma frequência de 50 MHz para os roteadores, transmissores e receptores.
O cenário de tráfego sugerido segue a definição do estudo de caso, onde três transmissões são utilizadas.
A primeira transmissão propõe que um processador mapeado no endereço 01 envie a outro processador mapeado no endereço 02 50 pacotes de 16 flits cada, ou seja, 12800 bits transmitidos a uma taxa de injeção uniforme de 600 Mbits, o que representa 7.5% da capacidade de transmissão do processador.
Esta transmissão poderia ser representada na prática como uma migração de uma tarefa sendo que o processo de migração é executado de maneira concorrente no processador, uma vez que pouco mais de 7% da capacidade de transmissão do processador é utilizada.
A segunda transmissão do cenário de tráfego propõe que um dos elementos de memória mapeado no endereço 02 envie a um dos processadores mapeado no endereço 02 100 pacotes de 16 flits cada, ou seja, 256000 bits transmitidos a uma taxa de injeção exponencial decrescente variada num intervalo de 200 Mbps a 800 Mbps com taxa média de 400 Mbps, o que representa respectivamente um intervalo de 25% a 100% e com média de 50% da taxa máxima de transmissão da memória.
Esta transmissão poderia ser representada na prática como um elemento de memória de maneira concorrente a outros processadores transmitido valores de seus respectivos endereços da memória, para o processador mapeado no endereço 12, onde que por existir concorrência no acesso à memória por outros processadores, a distribuição temporal do tráfego é dada conforme a distribuição exponencial decrescente onde grande parte do total de pacotes é transmitida a uma taxa de injeção mais baixa, e poucos pacotes transmitidos a uma taxa de injeção mais alta.&amp;&amp;&amp;
A terceira transmissão do cenário de tráfego propõe que um dos elementos de memória mapeado no endereço 20 envie a um dos elementos de entrada e saída I/ O do inglês &quot;Input/ Output «mapeado no endereço 22 100 pacotes de 16 flits cada, ou seja, 256000 bits transmitidos a uma taxa de injeção normal variada num intervalo de 200 Mbps a 600 Mbps com taxa média de 400 Mbps, o que representa um intervalo de 25% a 75% e com média de 50% da taxa máxima de transmissão do elemento de memória.
Esta transmissão poderia ser representada na prática como uma conexão com uma memória não volátil do tipo EEPROM, do inglês &quot;Electrically Erasable Programmable Read-Only Memory», responsável por armazenar de maneira permanente uma informação já computada por os processadores do circuito que esta presente numa das memórias do circuito.
A distribuição normal é utilizada, pois descreve um comportamento em que grande parte dos pacotes é transmitida próxima à média, já que num cenário real de uma memória EEPROM externa, existiriam atrasos durante a sincronização e o inicio da recepção, onde que grande parte dos pacotes seria transmitido próximo a o valor da média.
Os resultados obtidos após realizar a simulação dos modelos de rede síncrona e não síncrona são ilustrados por a Tabela 4.
Com relação a vazão e a latência média de transmissão do primeiro cenário referente a migração de uma tarefa entre ambos processadores, representados na Tabela 4 por o item «(P -- P) 01-02», foi detectado que o cenário não síncrono gastou 76% menos tempo para migrar a tarefa e conseguiu atingir uma vazão 73% maior que o cenário síncrono para migrar a tarefa.
Este comportamento era previsível, uma vez que no cenário não síncrono os roteadores 01 e 02 responsáveis por a transmissão do tráfego estavam operando em 500 MHz, diferente do cenário síncrono onde os roteadores estavam operando em 50 MHz.
Em o segundo cenário referente a comunicação de um elemento de memória com um processador, ilustrado através da Tabela 4 por o item «(M-P) 00-12», foi detectado com relação a latência que o cenário não síncrono gastou 33% menos tempo para transmitir os dados e com relação a vazão que o cenário não síncrono conseguiu atingir uma vazão 32% maior que o cenário síncrono para transmitir os valores da memória para o processador.
Este comportamento era previsível, uma vez o tráfego «(P-P) 01-02», iria causar contenção obrigando o roteamento adaptativo a utilizar os roteadores para realizar a comunicação.
Em o cenário síncrono todos os roteadores possuem a mesma frequência, no cenário não síncrono os roteadores que conectam os processadores possuem frequências 10 vezes maiores que a frequência utilizada no cenário síncrono, o que justifica a existência de 33% redução na latência comparando ambos os cenários.
Em o terceiro cenário referente a comunicação de um elemento de memória com um elemento de entrada e saída, ilustrado através da Tabela 4 por o item «(M -- I/ O) 20-22», foi detectado que com relação a latência o cenário síncrono gastou 9.5% menos tempo e com relação a vazão que o cenário síncrono conseguiu atingir uma vazão 6% maior que o cenário não síncrono para transmitir os dados da memória para o controlador de entrada e saída.
O autor esperava obter resultados próximos para estes cenários de tráfego, uma vez que os roteadores que caracterizam o caminho entre a memória e o controlador de entrada e saída operam na mesma frequência.
A Figura 57 ilustra através de um gráfico os valores da latência média de cada um dos cenários de tráfego propostos.
Por fim, foi calculada a média da latência a partir de as médias de cada um dos tráfegos propostos para ambos os modelos de rede.
A latência média da rede não síncrona foi 42% menor que a rede síncrona.
A Figura 58 através de um gráfico os valores da vazão média de cada um dos cenários de tráfego propostos.
Por fim, foi calculada a média da vazão a partir de as médias de cada um dos tráfegos propostos para ambos os modelos de rede.
A vazão média da rede não síncrona foi 45% maior que a rede síncrona.
A partir de os resultados, conclui- se que o modelo não síncrono foi aquele que na média dos tráfegos conseguiu atingir 42% menor latência e 45% maior vazão.
O que mais chama a atenção é que redes que utilizam algoritmos de roteamento adaptativos, além de permitir que tráfegos concorrentes não fiquem limitados a um único caminho possível entre um endereço origem e destino, possam explorar em redes não síncronas a capacidade de transmissão de outros roteadores que operam em frequências mais elevadas.
O cenário de tráfego ilustrado na Tabela 4 por o item «(M -- P) 00-12 «demostra ganhos de 33% de redução na latência e 32% aumento na vazão, comparado a uma rede síncrona, por encontrar uma contenção na rede e fazer uso de um caminho alternativo formado por roteadores operado em frequências mais elevadas.
Este estudo de caso propõe estudar o impacto no tempo de transmissão e no custo de área variando a codificação dos ponteiros das filas bi síncronas e no uso da fila síncrona descrita por a seção 3.1.2.5, utilizada para geração de redes não síncronas.
Ao todo quatro modelos de rede são propostos, sendo que em todos eles são utilizadas as mesmas características, sendo elas dimensão de duas linhas por duas colunas, comprimento de canais igual a 16 bits, profundidade das filas igual 16 flits e algoritmo de roteamento XY.
A frequência de operação de todos os rotadores, transmissores e receptores é de 50 MHz, com exceção do roteador endereço 11 que possui frequência de operação de 100 MHz.
O primeiro e o segundo modelo irão possuir codificação Gray e codificação Johnson respectivamente em todas as filas bi síncronas dos roteadores.
O terceiro e o quarto modelo irão possuir codificação Gray com uso da fila bi síncrona e codificação Johnson com uso da fila bi síncrona.
A Figura 59 descreve em quais locais da rede nestes dois últimos modelos é feito uso da fila bi síncrona e da fila síncrona.
O cenário de tráfego sugerido para os quatro modelos de rede visa explorar o tempo gasto quando os dois tipos de filas são utilizados numa transmissão.
O primeiro cenário de tráfego propõe que o transmissor conectado no roteador 00 envie ao roteador 11 a quantidade de 10 pacotes de 16 flits cada, totalizando um tráfego de 2560 bits distribuídos de maneira uniforme a 400 Mbps, ou 50% da capacidade do transmissor.
O segundo cenário de tráfego propõe que o transmissor conectado no roteador 11 envie ao roteador 00 a quantidade de 10 pacotes de 16 flits cada, totalizando um tráfego de 2560 bits distribuídos de maneira uniforme a 800 Mbps, ou 100% da capacidade do transmissor.
A Tabela 5 apresenta quais foram os resultados de área obtidos para cada modelo de rede proposto através da síntese feita utilizando a ferramenta Xilinx ISE 10.
1 utilizando um dispositivo de prototipação FPGA Virtex5 XC5 VLX330T.
Este dispositivo foi escolhido por existirem disponíveis placas de prototipação com o respectivo FPGA no laboratório de pesquisa do grupo do autor.
Os resultados de área são obtidos em número de LUTs de quatro entradas utilizadas por o FPGA para representar o projeto de cada rede.
A partir de os resultados de área coletados é possível concluir que a codificação Johnson conforme descrito por o item &quot;2x2J «da Tabela 5 apresenta aumento de 14,6% de área em relação a codificação Gray, descrito por o item &quot;2x2G «da Tabela 5.
Estes resultados se assemelham aos obtidos por conforme descrito por a seção 3.1.2.3, onde é comparada a área de cada uma das codificações propostas.
Já para os modelos de rede que utilizam a combinação das filas síncronas e bi síncronas, no cenário Johnson conforme descrito por os itens &quot;2x2J «e &quot;2x2JS», houve uma redução de 47% na área da versão que utiliza filas síncronas e bi síncronas comparada a versão que só faz uso de filas bi síncronas.
Em o cenário Gray conforme descrito por os itens &quot;2x2G «e &quot;2x2GS», houve uma redução de 43% na área da versão que utiliza filas síncronas e bi síncronas comparada a versão que só faz uso de filas bi síncronas.
O autor esperava obter resultados de redução na área utilizando combinações de filas síncronas e bi síncronas, uma vez que afirma que existe aumento na área de uma fila bi síncrona comparado a uma fila síncrona.
A Tabela 6 descreve os resultados obtidos após realizar a simulação dos tráfegos para os modelos de rede propostos.
Como as filas com codificação Gray e codificação Johnson gastam o mesmo tempo para transmissão, os resultados obtidos para ambas as filas foram os mesmos, conforme demostrado por a Tabela 6.
Em os casos onde é feito uso de filas síncronas e filas bi síncronas ao mesmo tempo, detectou- se existir uma redução de 12% na latência e um aumento de 12% na vazão para o tráfego e uma redução de 4% na latência e um aumento de 4% na vazão para o tráfego.
O autor esperava obter resultados próximos aos medidos com relação a redução na latência e aumento na vazão, uma vez que esta diferença de tempo só é computada durante o chaveamento do pacote.
A Figura 60 ilustra através de um gráfico os valores da latência e vazão média de cada um dos cenários de tráfego propostos.
Por fim, foi calculada a média da vazão e da latência a partir de as médias de cada um dos tráfegos propostos para ambos os modelos de rede.
O modelo de rede que faz uso da fila síncrona e da fila bi síncrona comparado ao modelo que faz uso unicamente da fila bi síncrona apresentou ganhos de redução na média de todos os tráfegos ganhos de 6% na redução do tempo de transmissão e um aumento na vazão em 10%.
A partir de os resultados, conclui- se que a partir de os modelos de rede propostos que a codificação de ponteiros Gray apresenta 14,6% menor área comparada a codificação Johnson, sendo que ambas possuem o mesmo desempenho.
Em as questões relacionadas ao uso de síncronas e filas bi síncronas, os resultados apontam redução de 47% na área da rede utilizando filas bi síncronas com codificação Johnson e filas síncronas e redução de 43% na área da rede utilizando filas bi síncronas com codificação Gray e filas síncronas.
Além de os resultados de área, os cenários de tráfego propostos apresentaram que na média dos tráfegos a combinação de filas síncronas e bi síncronas possibilitaram uma redução de 6% na latência dos pacotes e aumento de 10% na vazão do tráfego.
Este estudo de caso propõe demostrar que a partir de a variação da frequência dos roteadores, é possível gerar redes menores com relação as suas características como a largura dos canais que interligam os roteadores, capazes de consumir menos área e que mesmo assim atingir desempenho equivalente ou superior em alguns cenários de tráfego.
Em este estudo de caso duas redes são propostas, a primeira de elas possuindo dimensões 2x2, comprimento de canais igual a 32 bits, profundidade das filas igual a 16 flits, algoritmo de roteamento XY, codificação de ponteiros Johnson para a fila bi síncrona e frequência de operação de 50 MHz para todos os roteadores, transmissores e receptores do tráfego.
A segunda rede foi gerada possuindo dimensões 2x2, comprimento de canais igual a 16 bits, profundidade das filas igual a 16 flits, algoritmo de roteamento XY e codificação de ponteiros Johnson para a fila bi síncrona.
A frequência de operação para os roteadores foi definida em 500 MHz, os demais roteadores, transmissores e receptores receberam frequência de operação de 50 MHz.
Apenas um cenário de tráfego sem concorrência foi definido, ele propõe que o transmissor do endereço 00 envie 10 pacotes de 16 flits, ou seja, 2560 bits para o endereço 11 a uma taxa de injeção uniforme de 800 Mbits, o que representa 100% da taxa de injeção do transmissor.
A Tabela 7 apresenta quais foram os resultados de área obtidos para cada modelo de rede proposto através da síntese feita utilizando a ferramenta Xilinx ISE 10.
1 num dispositivo de prototipação FPGA Virtex5 XC5 VLX330T.
Os resultados de área são obtidos em número de LUTs de quatro entradas utilizadas por o FPGA para representar o projeto de cada rede.
A partir de os resultados de área obtidos para cada um dos modelos de rede propostos é possível concluir um aumento de 32% na área no primeiro modelo de rede proposto que faz uso de largura nos canais dos roteadores de 32 bits comparado ao segundo modelo de rede que faz uso de largura nos canais dos roteadores de 16 bits, uma vez que não somente o número de fios aumenta entre cada roteador, como também o tamanho das filas, que são definidas em número de flits.
O autor esperava obter resultados de redução na área entre o primeiro e o segundo modelo uma vez que os modelos são diferentes em relação as suas características.
A Tabela 8 descreve os resultados obtidos após realizar a simulação do tráfego para ambos os modelos de rede propostos.
O segundo modelo de rede que dá suporte a duas frequências é 50% menor em relação a largura dos canais que interligam os roteadores, pois possui 16 bits contra 32 bits do primeiro modelo e apresenta ainda assim 52% menor latência e 6% maior vazão comparado ao primeiro modelo.
O autor esperava obter resultados com relação a vazão e latência próximos, porém, o aumento a frequência no segundo modelo, mesmo possuindo largura dos canais entre os roteadores 50% menor que o primeiro modelo resultou em resultados acima de o esperado com relação a latência.
A partir de os resultados, conclui- se que o cenário que propõe alterar a frequência foi aquele que além de consumir 32% menos área por fazer uso de uma rede menor conseguiu atingir 52% menor latência e 6% maior vazão.
O autor assume que leva em consideração as questões relacionadas ao aumento da frequência e ao consumo de energia, aspecto este não levado em consideração durante a geração de resultados deste trabalho, e também que o estudo de caso propõe diferença na frequência da ordem de 10 vezes entre ambos os modelos de rede.
Mesmo assim, este estudo de caso deixa claro que a frequência apresenta em alguns casos vantagens para geração de redes menores e capazes de atender com maior eficiência um tráfego sem comprometer a área como em outras propostas que sugerem variar o tamanho dos canais ou a profundidade das filas.
Este estudo de caso propõe estudar o impacto na área e no desempenho utilizando diferentes algoritmos de roteamento disponibilizados por o ambiente de geração de redes, que utilizam suas respectivas versões referentes ao componente &quot;Crossbar «contendo minimizações nas portas de saída deste componente para cada algoritmo de roteamento, conforme detalhado na seção 3.1.2.2.
Ao todo são utilizadas sete redes, todas compostas por as seguintes características, tamanho 3x3, largura dos canais que interligam os roteadores de 32 bits, profundidade das filas igual a 8 flits, codificação de ponteiros Johnson utilizado por a fila bisíncrona e frequência de operação igual a 50 MHz para os roteadores, transmissores e receptores.
Em cada uma das sete redes propostas é variado o algoritmo de roteamento, sendo eles:
&quot;XY&quot;; &quot;Negative First Minimal&quot;;
&quot;Negative First Non Minimal&quot;; &quot;North Last Minimal&quot;;
&quot;North Last Non Minimal&quot;; &quot;West First Minimal&quot;;
West First Non Minimal&quot;; O cenário de tráfego sugerido para os sete modelos de rede visa utilizar a capacidade do algoritmo de roteamento em assumir outros caminhos para o tráfego quando houver congestionamento.
Sendo assim quatro tráfegos são propostos, sendo que o primeiro de eles transmite do endereço 00 para o endereço 22 a quantidade de 10 pacotes de 32 bits cada, totalizando um tráfego de 10240 bits distribuídos de maneira uniforme a taxa máxima de 800 Mbits.
O segundo tráfego é transmite do endereço 22 para o endereço 00 a quantidade de 10 pacotes de 32 bits cada, totalizando um tráfego de 10240 bits distribuídos de maneira uniforme a taxa máxima de 800 Mbits.
O terceiro tráfego transmite do endereço 02 para o endereço 20 a quantidade de 10 pacotes de 32 bits cada, totalizando um tráfego de 10240 bits distribuídos de maneira uniforme a taxa máxima de 800 Mbits.
O quarto e último tráfego transmite do endereço 20 para o endereço 02 a quantidade de 10 pacotes de 32 bits cada, totalizando um tráfego de 10240 bits distribuídos de maneira uniforme a taxa máxima de 800 Mbits.
A Tabela 9 apresenta quais foram os resultados de área obtidos para cada um dos sete modelos de rede proposto através da síntese feita utilizando a ferramenta Xilinx ISE 10.
1 utilizando um dispositivo de prototipação FPGA Virtex5 XC5 VLX330T.
Os resultados de área são obtidos em número de LUTs de quatro entradas utilizadas por o FPGA para representar o projeto de cada rede.
A partir de os resultados de área obtidos conforme ilustrados por a Tabela 9 para cada um dos sete modelos de rede propostos é possível concluir que o algoritmo de roteamento &quot;Negative First Minimal «foi aquele que apresentou menor área, e o algoritmo &quot;Negative First Non Minimal «aquele que apresentou maior área.
A Tabela 8 descreve os resultados obtidos após realizar a simulação do tráfego para ambos os modelos de rede propostos.
O campo (Lat) representa a latência média em (ns) para cada um dos tráfegos, o campo (Vaz) representa a vazão média em (Mbps) para cada um dos tráfegos.
A partir de os modelos de rede propostos, a rede que atingiu o menor valor de latência média e o maior valor de vazão média para todos os tráfegos propostos foi a rede que utilizou algoritmo de roteamento XY.
Comparando com o cenário utilizando algoritmo de roteamento &quot;North Last Non Minimal «que gerou o maior valor de latência média e o menor valor de vazão média, o algoritmo XY gastou 2.65x menos tempo para transmitir os tráfegos e obteve 50% maior vazão para transmitir os tráfegos.
Em uma comparação direta de área entre os dois algoritmos, o algoritmo XY além de ser mais eficiente para o cenário proposto ocupa 11,6% menos área que o algoritmo &quot;North Last Non Minimal».
O cenário que consumiu menos área foi o que utiliza o algoritmo de roteamento &quot;Negative First Minimal», que comparado ao algoritmo XY apresentou 57,2% menos área, mas em contra partida, o algoritmo XY apresenta em relação a o algoritmo &quot;Negative First Minimal», 31% menos tempo para transmitir os tráfegos e 30% maior vazão para transmitir os tráfegos.
A partir de os resultados, conclui- se que para o cenário de rede e de tráfego proposto, o algoritmo XY foi aquele que apresentou a melhor relação de desempenho comparado ao consumo de área para ser sintetizado.
Já o algoritmo &quot;Negative First Minimal «foi o que apresentou menor consumo de área, e resultados de desempenho acima de a média comparado aos demais tráfegos.
O algoritmo de roteamento que gastou mais área para ser sintetizado e apresentou o pior desempenho de todos foi o algoritmo &quot;Negative First Non Minimal».
Este estudo de caso propõe comparar dois cenários de tráfego, um a partir de um modelo de aplicação CDCM e outro através do modelo de tráfego sintético.
Para ambos os modelos de tráfego utilizados foi defino um cenário de rede de tamanho 2x2, largura de canais igual a 16 bits, profundidade das filas igual a 8 flits, algoritmo de roteamento XY e codificação de ponteiro Johnson para a fila bi síncrona.
Optou- se por gerar uma única frequência de operação de 50 MHz para todos os roteadores, transmissores e receptores.
O cenário de tráfego proposto é ilustrado por a Figura 61 onde a aplicação proposta é particionada em quatro tarefas.
Cada tarefa possui um tempo de processamento e uma quantidade de informação a ser transferida.
O cenário de tráfego que faz uso do modelo de aplicação CDCM foi criado e mapeado utilizando o ambiente CAFES e o ambiente de geração do Testbench e do tráfego da ferramenta de geração de tráfego do ambiente Atlas conforme detalhado por a seção 4.3.
Durante o processo de mapeamento a tarefa A foi mapeada no endereço 00, a tarefa B no endereço 10, a tarefa C no endereço 01 e a tarefa D no endereço 11.
A partir de os valores referentes aos endereços onde as tarefas foram mapeadas e o valor a ser transmitido por cada tarefa foi então criado um tráfego sintético similar.
O tráfego sintético é composto por três transmissões, sendo a primeira do endereço 00 para o endereço 10, referente a tarefa (A-\&gt; B) ilustrada por a Figura 61, que transmite um pacote de tamanho igual a 60 flits, o equivalente a 15360 bits a uma taxa uniforme de 800 Mbits, ou seja, 100% da capacidade do transmissor.
A segunda transmissão é feita do endereço 10 para o endereço 01, referente a tarefa (C-\&gt; D) conforme ilustrada por a Figura 61, que transmite um pacote de tamanho igual a 40 flits, o equivalente a 10240 bits a uma taxa uniforme de 800 Mbits, ou seja, 100% da capacidade do transmissor.
A terceira e última transmissão é feita do endereço 01 para o endereço 11, referente a tarefa (B-\&gt; C) conforme ilustrada por a Figura 61, que transmite um pacote de tamanho igual a 20 flits, o equivalente a 5120 bits a uma taxa uniforme de 800 Mbits, ou seja, 100% da capacidade do transmissor.
A Tabela 11 descreve os resultados obtidos após realizar a simulação dos tráfegos propostos.
Os resultados obtidos demonstram que o tráfego utilizando modelo de aplicação CDCM aumentou em 6% a latência e reduziu a vazão em 10%.
O autor esperava obter resultados em que o tráfego sintético resultasse em maior saturação no tráfego, ou seja, aumento na latência e redução na vazão, uma vez num modelo sintético todo tráfego é transmitido a partir de o inicio da simulação, diferente do modelo de aplicação que só transmite uma tarefa a partir de o momento que sua dependência enviou o último flit do pacote a rede.
O autor acredita que por o modelo de rede proposto, e por o mapeamento da aplicação não causar concorrência na rede o tráfego sintético mesmo transmitindo todos os tráfegos ao mesmo tempo acabou não conseguindo reproduzir o comportamento esperado.
Mesmo não conseguindo reproduzir o comportamento esperado no estudo de caso proposto, a tendência ao fazer uso de tráfegos sintéticos é que todas as transmissões aconteçam de maneira simultânea na rede, o que obviamente tende a criar congestionamentos e aumentar o tempo de transmissão e reduzir a capacidade de transmissão da rede.
Já o modelo de aplicação, garante que cada uma das transmissões só aconteça quando um conjunto de dependências definidas para cada tarefa de uma aplicação for concluída.
Este trabalho se propôs a desenvolver um ambiente de geração e avaliação de redes intrachip não síncronas integrado ao ambiente Atlas.
O ambiente de geração de redes foi desenvolvido para permitir a geração parametrizável de instancias da rede Hermes-G. O ambiente de geração e avaliação de tráfego foi desenvolvido a partir de o modelo de tráfego sintético proposto por e por o modelo de tráfego de aplicações proposto por para permitir realizar a avaliação das redes geradas por o ambiente de geração de redes.
Em a visão do autor, o estado da arte carece de referências a trabalhos com a proposta de redes intrachip não síncronas em nível VHDL, e que de alguma forma permitam a parametrização das características da rede.
Este trabalho além de disponibilizar um projeto de rede não síncrona passível de parametrização das características da rede, disponibiliza um ambiente gráfico para geração de redes intrachip não síncronas de maneira intuitiva.
Ainda no estado da arte, no tema relacionado a caracterização do tráfego, foram encontrados vários indícios que a maneira como o tráfego é gerado e mapeado tem relação direta com desempenho da rede, e ainda, que o tráfego sintético utilizado por grande parte dos trabalhos pesquisados esta distante de conseguir representar o comportamento da aplicação.
Durante a investigação do estado da arte, diversas propostas foram encontradas promovendo evoluções no modelo de tráfego sintético.
Em este trabalho, o autor além de propor novas características ao modelo de tráfego sintético, propõe também gerar tráfego a partir de modelos de aplicações.
Além de a proposta dos modelos de tráfego, este trabalho disponibiliza ainda um ambiente de geração de tráfego para redes não síncronas, que permite gerar tráfego de maneira parametrizável.
Por fim, os trabalhos do estado da arte no tema de avaliação de tráfego para redes detalham utilizar as métricas de vazão e latência para avaliar o tempo gasto e a quantidade de informação transmitida por os pacotes.
Em a grande maioria dos trabalhos, a latência é medida em ciclos, e a vazão medida através do tráfego aceito.
Em a visão da proposta deste trabalho, uma vez que uma rede opere com diferentes frequências, a latência, ou tempo de transmissão do pacote deve ser avaliado em tempo absoluto e não em ciclos, pois mesmo conhecendo o caminho do tráfego e as frequências dos roteadores, é impossível mensurar o tempo gasto por um pacote em ciclos, uma vez que o ciclo não é capaz de medir com precisão o tempo do pacote.
O autor por convenção optou por avaliar a vazão em quantidade de informação transmitida (Mbps), e não em tráfego aceito, uma vez que numa rede não síncrona, a taxa de injeção de um pacote pode variar dependendo a frequência de operação da rede utilizada.
Este trabalho buscou explorar de maneira exaustiva os trabalhos relacionados aos temas de geração e avaliação de redes não síncronas.
Até onde se tem conhecimento, este trabalho contribui ao mundo cientifico com um ambiente de geração de redes intrachip não síncronas em nível VHDL passíveis de parametrização através de uma interface gráfica intuitiva.
Em nenhum trabalho lido é apresentado uma proposta semelhante.
Com relação a o resumo do estado da arte o trabalho detecta a existência de deficiências no modelo de tráfego sintético utilizado para avaliação de redes intrachip, e resume alguns trabalhos que apresentam propostas alternativas no sentido de evoluir o modelo sintético, apresentando ganhos significativos nos resultados obtidos.
Não somente neste documento, mas em outros trabalhos correlatos desenvolvidos por este autor, foram desenvolvidos estudos que trazem ao grupo de pesquisa do autor, possíveis indícios de pesquisa em relação a avanços na geração de tráfego a serem explorados.
Com relação a geração de tráfego, este trabalho promove a evolução do gerador de tráfego proposto por, nas questões relacionadas ao modelo de tráfego sintético introduzindo a distribuição exponencial decrescente e propondo algumas correções nos cálculos e nas interfaces do gerador.
Além disso, introduz um modelo de geração de tráfego que faz uso de modelos de aplicações para geração de tráfego.
A utilização deste novo modelo para geração de tráfego traz ao grupo de pesquisa do autor uma serie de novas questões e variáveis a serem exploradas por o modelo proposto.
Com relação a avaliação do tráfego, este trabalho propõe evoluir a ferramenta de avaliação de tráfego proposto por, adaptando as técnicas e as métricas utilizadas para avaliação do tráfego gerado para redes não síncronas.
Durante a revisão do estado da arte, o autor não encontrou nenhum trabalho propondo uma ferramenta de avaliação de tráfego para redes não síncronas, sendo que em todos aqueles que de alguma forma demostraram resultados para uma rede não síncrona, nenhum de eles apresentou uma proposta parecida a proposta por este trabalho para avaliar o tráfego.
Por fim, o autor ainda cita como contribuição os esforços desenvolvidos e pouco documentados neste trabalho relacionados a integração e verificação das ferramentas propostas ao fluxo de desenvolvimento de redes do ambiente Atlas.
Por este ambiente ter ampla aceitação da comunidade acadêmica no escopo de geração e avaliação de redes intrachip, este poderá ser utilizado no futuro por outros trabalhos.
Em a visão do autor, a maior contribuição deste trabalho é realizar a compilação de outros trabalhos, utilizando os ambientes propostos por e, e a rede intrachip não síncrona proposta por em algo maior, criando novos tópicos de pesquisa a serem explorados por o grupo de pesquisa do autor.
A partir de a proposta descrita por este trabalho, é possível definir um conjunto de trabalhos futuros a serem feitos.
Os seguintes trabalhos serão descritos a seguir:
Desenvolvimento de um componente de avaliação interna, responsável por coletar o tráfego entre os canais que interligam os roteadores.
Este componente deve levar em consideração que cada canal irá transmitir informação numa determinada frequência, e que as características da rede por serem parametrizáveis irão influenciar na geração das estruturas deste componente.
Adaptação do ambiente de avaliação de tráfego, para levar em consideração os valores coletados por o componente de avaliação interna conforme proposto por.
As métricas utilizadas para avaliação do tráfego de maneira interna em redes síncronas levam em consideração o ciclo de relógio para realizarem os cálculos de vazão e latência dos canais, devendo ser adaptadas para tempo absoluto, levando em consideração a frequência de operação dos roteadores.
Evolução das técnicas de mapeamento propostas por e utilizadas no ambiente CAFES, para levar em consideração a frequência de operação dos roteadores e um tempo de transmissão máximo de cada uma das mensagens das tarefas da aplicação.
A modificação implicará que o ambiente CAFES conheça a frequência dos roteadores para realizar o mapeamento.
O autor sugere que o arquivo de projeto da rede seja utilizado como entrada por o ambiente CAFES durante o mapeamento, uma vez que contem os valores das frequências dos roteadores definidas para um projeto de rede.
Evoluir o modelo de aplicações CDCM, permitindo que durante a geração de um modelo seja possível definir um número de pacotes para uma mensagem em flits.
Além disso, permitir que os pacotes de uma mensagem sejam transmitidos na rede conforme uma distribuição temporal a partir de as distribuições suportadas por o ambiente de geração de tráfego do ambiente Atlas, uma vez que hoje, uma mensagem é transmitida a taxa máxima de injeção do transmissor.
Propor evoluir o modelo de &quot;Testbench «da linguagem SystemC para a linguagem VHDL, uma vez que a linguagem SystemC não permite ser sintetizada para arquiteturas FPGA, e não é suportada por ferramentas de avaliação de consumo de energia.
Uma vez rescrito o &quot;Testbench», propor estudos de caso variando as características da rede não síncrona com uma rede síncrona avaliando o impacto da área em relação a o consumo de energia das redes.
