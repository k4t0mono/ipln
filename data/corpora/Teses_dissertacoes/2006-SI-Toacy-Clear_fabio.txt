O desenvolvimento de software dirigido por modelos, com a MDA, requer o refinamento de modelos de sistemas, inicialmente especificados em alto nível e sem características de plataformas, em modelos dependentes de plataformas.
A Model Driven Architecture (MDA) apresenta uma técnica de modelagem voltada para arquiteturas, em que é necessário aplicar mapeamentos e transformações em modelos de sistemas para plataformas.
Esse trabalho apresenta a abordagem FOMDA (Features-Oriented Model-Driven Architecture), que permite a desenvolvedores especificar modelos e gerenciar transformações adotando a técnica MDA.
A abordagem FOMDA combina Modelos de Features e MDA num ambiente onde desenvolvedores são habilitados para representar características através de features, mapeando- as para transformações que geram a aplicação final.
Este trabalho também apresenta um estudo de caso, que utiliza a abordagem FOMDA para auxiliar no desenvolvimento de um sistema de tempo real embarcado.
O Desenvolvimento de software Dirigido por Modelos (MDD) requer o refinamento de modelos de sistemas, inicialmente especificados em alto nível e sem características de plataformas, em modelos dependentes de plataformas.
A Model Driven Architecture (MDA) é uma abordagem para MDD em que é sugerido que os modelos de sistemas sejam especificados em três visões:
CIM (Computation Independent Model), que especifica modelos independentes de computação e de alto nível;
Pim (Platform Independent Model), que especifica modelos independentes de plataforma que também são representações de alto nível;
E PSM (Platform Specific Model), que especifica modelos dependentes de plataforma que são representações de baixo nível.
A MDA define que os modelos podem ser refinados de uma visão para outra utilizando um conjunto de mapeamentos de modelos de sistemas para transformações.
Boas também define que é necessário organizar estas transformações para possibilitar que um modelo especificado em alto nível (Pim) seja transformado para um outro dependente de plataforma (PSM).
No entanto, não é especificado na MDA como é possível administrar e organizar mapeamentos, transformações e modelos de sistemas para estas visões.
O presente trabalho propõe uma abordagem para organizar mapeamentos de modelos para transformações que refinam modelos de sistemas na visão Pim para modelos na visão PSM.
O aspecto chave na MDA é permitir que o desenvolvimento de um sistema seja decomposto em níveis de abstração das plataformas que serão utilizadas para desenvolver um sistema.
O termo plataforma é usado nesse documento para representar características de sistemas, como arquiteturas, tecnologias, serviços, hardware, ferramentas, ambientes de desenvolvimento, etc..
Além disso, é possível aplicar um conjunto de transformações nos modelos do sistema e gerar novos modelos e código específico para determinadas plataformas.
De acordo com Selic, o termo plataforma pode ser compreendido como &quot;qualquer conjunto de mecanismos de hardware ou software que habilitam a execução de aplicações de software».
No entanto, a MDA não define um formalismo para especificar modelos em níveis de independência das características de plataformas.
Um formalismo utilizado por projetistas para modelar e especificar regras para combinação de plataformas é o Modelo de Features (FM) (Tekinerdogan 2004, Czarnecki 1998).
Ele é composto por características (representando requisitos), informações textuais, como regras de composição, e rationales, que são informações detalhadas a respeito de uma característica.
A idéia é definir características (funcionais, arquiteturais, tecnológicas, etc.) de um domínio particular e, com base nas relações entre elas, usar- las para estabelecer diferentes configurações entre plataformas.
Esse trabalho apresenta a abordagem FOMDA (Features-Oriented Model Driven Architecture), que permite que desenvolvedores especifiquem modelos e gerenciem transformações adotando a técnica MDA.
A abordagem FOMDA combina Modelos de Features e MDA num ambiente onde desenvolvedores são habilitados a identificar mapeamentos e transformações de modelos para plataformas alvo usadas no desenvolvimento de um sistema.
As plataformas são especificadas como uma combinação de características num Modelo de Features e (b)).
Essas características são mapeadas para transformações, como pode ser visto na Figura 1 (a) e (c).
A seleção das características do Modelo de Features (FM) determina o conjunto de transformações que devem ser realizadas no refinamento de um modelo especificado em alto nível (Pim), para modelos de baixo nível (PSMs).
Isto é possível de ser visto na Figura 1 (b) e (c), em que as características selecionadas F1 e F3 identificam as transformações T1 e T3.
Muitas transformações podem ser utilizadas para refinar um Pim em PSMs.
Então é necessário ordenar as características selecionadas do FM num workflow.
Isto é mostrado na Figura 1 (b) e (d).
Esse trabalho também apresenta um estudo de caso.
Com o objetivo de comprovar que a abordagem FOMDA pode ser utilizada para auxiliar a identificar os mapeamentos e as transformações dos modelos de um sistema.
Esse estudo de caso demonstra como é possível refinar um modelo em alto nível (Pim) para um modelo em baixo nível (PSM).
O Pim é um modelo que contém requisitos de um sistema para controle de cadeira de rodas e o PSM é um modelo o qual pode ser utilizado para gerar código para o desenvolvimento de um sistema de tempo real embarcado.
As abordagens existentes para MDA, como em Deeltra, Oliveira E Almeida, não tratam adequadamente o desenvolvimento de sistemas para múltiplas plataformas.
Estas abordagens estão centradas em prover soluções para transformar modelos abstratos em modelos concretos e usar estes últimos para gerar código.
No entanto, elas não possibilitam gerar código para múltiplas plataformas, porque plataformas não auxiliam nas transformações dos modelos.
Diante de isso, o presente trabalho propõe uma nova abordagem para MDD, que permite o desenvolvimento de sistemas, a partir de modelos, para múltiplas plataformas.
A Object Management Group (OMG) é o grupo responsável em padronizar a MDA.
Em este âmbito, este grupo lança chamadas de propostas para abordagens com foco em MDD.
Uma de suas chamadas é referida como Query, Views and Transformations (QVT) e relata às contribuições relacionadas com consultas, visões e transformações de modelos na MDA.
Este trabalho apresenta uma contribuição para QVT, que motivou o presente trabalho a propor uma abordagem para documentar e visualizar mapeamentos e transformações de modelos.
Essa abordagem possibilita que consultas, visões e transformações sejam especificadas no processo de mapeamento e transformação de modelos.
Em a MDA, modelos abstratos são refinados para modelos concretos com o auxílio de transformações.
As transformações são realizadas por transformadores de modelos.
Os transformadores especificados em ferramentas como Jamda e UMT são estáticos.
Um transformador é estático quando não é possível modificar a sua transformação.
Existem propostas em que os transformadores são dinâmicos.
Em transformadores dinâmicos é possível modificar as transformações que ele realiza, assim como criar novos transformadores a partir de transformadores pré-fabricados.
Como as tecnologias disponíveis para desenvolver um sistema mudam com freqüência, a maioria dos transformadores de modelos precisa ser reescritos para efetuar novas transformações.
Isto ocorre porque estes transformadores são desenvolvidos para aplicar transformações para uma tecnologia específica.
Logo, eles não são reutilizáveis, se existirem mudanças nas tecnologias utilizadas por os sistemas.
Algumas vantagens para o reuso de transformadores de modelos são:
A) independência de plataformas;
B) a possibilidade de compor novos transformadores, em tempo de execução, a partir de outros já desenvolvidos;
C) a possibilidade de modificar transformações de acordo com as mudanças das plataformas alvo.
Em nenhuma das abordagens estudadas, como UMT, Jamda e RDL, os transformadores implementam todos estes aspectos.
Em o presente trabalho, todos os aspectos mencionados foram desenvolvidos.
Para tornar isto possível, a organização de transformações foi dividida em quatro etapas de abstração.
Em cada nível é possível especificar transformadores em níveis altos de abstração em relação a as características não funcionais de sistemas.
Esse trabalho tem como principal objetivo descrever uma nova solução para MDD (denominada FOMDA), utilizando a MDA e o Modelo de Features.
Como objetivos específicos tem- se:
Apresentar uma abordagem para gerar o código de um sistema para múltiplas plataformas alvo com base em um modelo especificado com a UML em alto nível;
Apresentar uma solução para transformar um Pim num PSM;
Apresentar uma solução para reutilização e composição de transformações;
Apresentar uma ferramenta que auxilia os projetistas na transformação de um Pim para um ou mais PSMs;
Apresentar um estudo de caso voltado para o domínio de sistemas embarcados.
Com este estudo, pretende-se atestar que os objetivos anteriores foram atingidos no presente trabalho.
O presente trabalho apresenta uma abordagem para desenvolvimento de software dirigido por modelos denominada FOMDA.
Esta abordagem oferece recursos para a representação dos modelos de um sistema nas visões da MDA e, além disso, utiliza o Modelo de Features para estabelecer a combinação de plataformas que precisam ser utilizadas no desenvolvimento de uma aplicação.
Para isso, esta abordagem divide o mapeamento e a transformação de modelos (explicados na Seção 2.4.4) em quatro níveis de abstração.
Cada nível deve ser utilizado para definir os mapeamentos e transformações de um modelo de sistema.
Um protótipo denominado FOMDA Toolkit foi desenvolvido para validar a abordagem FOMDA.
O protótipo tem por objetivo:
A) utilizar o Modelo de Features para representar as características não funcionais de um domínio de sistemas;
B) permitir a configuração das plataformas alvo, utilizadas para desenvolver um sistema, com base na seleção das características do Modelo de Features;
C) utilizar as plataformas alvo para efetuar e compor transformações nos modelos do sistema;
D) possibilitar a organização das transformações em quatro níveis de abstração;
E) utilizar os padrões definidos por a OMG como UML, MOF e XMI.
Para validar a abordagem, este trabalho traz um estudo de caso para o desenvolvimento de um Sistema de Tempo Real Embarcado (STRE).
Esse estudo de caso é apresentado no Capítulo 4 e detalha como transformar um modelo genérico, especificado em alto nível (especificado com a UML e sem características de plataformas), para um modelo específico de uma plataforma alvo (identificada num FM).
Um artigo foi submetido e aceito no congresso e foi publicado em Abril de 2006.
Este artigo apresentou a abordagem FOMDA como uma solução para o desenvolvimento dirigido a modelos e um exemplo do uso desta abordagem para o desenvolvimento de SETRs (o artigo consta no Anexo I deste documento).
O restante do trabalho está organizado como segue.
O Capítulo 2 apresenta as principais bases teóricas sobre a análise de requisitos para sistemas embarcados.
O Capítulo 3 apresenta as abordagens centradas na geração de código com base em modelos.
O Capítulo 4 apresenta a Model Driven Architecture.
O Capítulo 5 apresenta os trabalhos relacionados.
O da FOMDA.
O Capítulo 8 apresenta o protótipo de ferramenta FOMDA Toolkit.
O Capítulo 9 apresenta um estudo de caso para o desenvolvimento de sistemas embarcados de tempo real, utilizando a abordagem FOMDA.
As conclusões são apresentadas no Capítulo 10.
A fase de análise de requisitos da Engenharia de Software (ES) tem como função descobrir as características relacionadas a um sistema.
Ela inclui um processo de desenvolvimento voltado para o domínio de sistemas e inclui os aspectos relacionados à arquitetura e características de funcionalidades do sistema.
Segundo Douglass &quot;o conjunto de objetos externos significantes e suas interações com o sistema, formam a base para a análise de requisitos do sistema».
Para todo e qualquer objeto que exerça uma ação no sistema ou que seja acionado por ele, este faz parte da análise de requisitos.
Sistemas Embarcados (SiEs) são sistemas que, em sua grande maioria, possuem pouca disponibilidade de recursos para efetuar o processamento dos dados de entrada (Wagner e Carro 2003).
Os recursos podem ser entendidos como sendo físicos (de hardware computacional e de espaço físico disponível), e lógicos (softwares leves com o mínimo de funcionalidades e restrito ao hardware).
SiEs podem ser encontrados em máquinas de lavar, aparelhos de gravação e reprodução de DVDs, simuladores de vôo, aviões, robôs, brinquedos, cafeteiras, etc..
Em um sistema embarcado a análise de requisitos da Engenharia de Software também pode ser empregada.
Entretanto, nesta classe de sistemas alguns requisitos adicionais devem ser considerados, como, por exemplo, o limite de consumo de energia sem perda de desempenho, a baixa disponibilidade de memória, a necessidade de segurança e confiabilidade, e o curto tempo de projeto.
Geórgia e Jaelson dividem requisitos de sistemas em Requisitos Funcionais (RF) e Requisitos Não Funcionais (NFR).
RFs capturam o comportamento do sistema em termos de serviços, tarefas ou funções que o mesmo necessita fazer.
Em esta categoria enquadram- se requisitos que descrevem os objetivos do sistema.
Por exemplo, num sistema de cadeira de rodas, o objetivo é mover a cadeira de rodas utilizando algum controle.
Para cumprir com este objetivo, os requisitos funcionais da cadeira de rodas são:
As direções para as quais ela pode ir, quantos motores são necessários para mover a cadeira, quais dispositivos controlam a mesma, etc..
Requisitos funcionais geralmente são aqueles que significam entrada, processamento e saída de dados, controles, exceções e entidades.
Geórgia e Jaelson definem ainda requisitos não funcionais (RNF).
Estes são ditos como aqueles que impõem restrições no produto sendo desenvolvido, no processo de desenvolvimento do sistema, ou que especificam restrições externas que o produto ou processo necessita conhecer.
Exemplos de RNFs do mesmo sistema de cadeira de rodas são:
O tempo mínimo para que o dispositivo de freio seja acionado no momento em que a ordem de parar a cadeira for dada, o tempo mínimo de comunicação entre o dispositivo de controle e os motores, o requisito de tolerância a falhas que define que o dispositivo de freio e a comunicação com ele não pode falhar, etc..
Algumas características devem direcionar quais requisitos fazem parte do sistema.
Como SiEs são de natureza e funcionalidades distintas, muitas características podem ser relevantes no momento da identificação dos requisitos do sistema e outros não, no entanto é necessário ter conhecimento de quais aspectos são característicos destes sistemas.
Com base nestas características, muitas configurações podem ser estabelecidas.
Estas características englobam:
Shelf (COTS), que são baratos mas ocupam um espaço maior que um SoC pois não foram projetados para espaços pequenos.
COTS são componentes utilizados em computadores tradicionais, como placa mãe, memória, etc., que são organizados para aumentar a capacidade de processamento armazenamento de uma máquina tradicional para satisfazer as necessidades do sistema em desenvolvimento.
São indicados para serem empregados em objetos onde a restrição de espaço não é um problema.
Embarcados A escolha da relevância de uma característica depende do domínio do sistema.
No entanto, muitas de elas são necessárias em sistemas que são partes do domínio.
Com exceção da característica de necessidade, as outras são não funcionais, o que significa que podem estar presentes em muitas aplicações do domínio de sistemas embarcados.
Além disso, NFRs freqüentemente mudam conforme evoluem as arquiteturas de hardware.
A característica da necessidade pode ser dividida em muitos requisitos funcionais (RF).
Então, existem também subdivisões do domínio de sistemas embarcados, em que cada subdivisão especifica funcionalidades para sistemas semelhantes.
Uma subdivisão de características funcionais determina aspectos de um domínio de aplicações.
Por exemplo, um sistema embutido numa cadeira de rodas, que rastreia o solo em busca de obstáculos que possam colidir com ela arranja um conjunto de funcionalidades, algumas obrigatórias e outras opcionais para cada aplicação que venha a ser desenvolvida.
Características obrigatórias podem ser:
Controlar movimento, acionar trava, etc..
Características opcionais podem ser:
Detectar automaticamente um obstáculo, tomar decisão de trajetória, etc..
Então, pode- se organizar um domínio não somente de acordo com o tipo de sistema, como no caso domínio de SiEs e domínio de sistemas comerciais, mas também de acordo com aplicações semelhantes como domínio de aplicações para cadeira de rodas.
Cada aplicação para o domínio de sistemas de cadeira de rodas pode ao mesmo tempo especificar a seguintes necessidades:
Desempenho para processar as informações, restrições de tempo que definem o tempo máximo para que um aviso de colisão chegue até o usuário, restrições de espaço físico optando- se por um SoC ao invés de um COTS, restrições de força de cada motor da cadeira de rodas, memória suficiente para armazenar as imagens capturadas, etc..
Já para um sistema que monitora os freios da cadeira de rodas as características relevantes podem ser outros, como:
Tolerância a falhas, sensores e acionadores, não há a necessidade de desempenho como para o exemplo anterior (se a resposta não chegar num intervalo de tempo máximo, a cadeira pode colidir).
Características de desempenho e de restrições temporais estão estreitamente relacionadas porque quando for necessário desempenho, os requisitos temporais devem ser avaliados.
Tais características são definidas como aspectos de qualidade de serviço QoS.
Aspectos de custo são um pouco mais complexos, pois somente podem ser determinados após a definição da necessidade que, por sua vez, determina a disponibilidade de espaço, o desempenho, fluxo de dados, memória, etc, que determinam o custo total do equipamento, efetuando uma relação cíclica entre o custo final, a necessidade, os requisitos desta necessidade e o custo destes requisitos.
Assim, com base nestas características, os requisitos da aplicação podem ser identificados e a análise de requisitos pode ser feita.
A especificação de requisitos de sistemas embarcados envolve muitas camadas, em cada camada, um nível de detalhe adicional do sistema é especificado.
Em o exemplo do domínio de sistema de cadeira de rodas, dois sistemas que possuem RF e RNF distintos foram identificados, um que rastreia o solo em busca de obstáculos e outro que monitora o dispositivo de freio, cada um de eles como um subsistema de um sistema maior que é a cadeira de rodas.
Um processo identificado por Graaf e Lormans define em qual etapa cada requisito é analisado.
Estas etapas podem ser vistas na Figura 2.
A primeira etapa define os requisitos do sistema em geral, ou seja, requisitos funcionais e não funcionais.
Em esta etapa uma arquitetura geral é estabelecida.
Em o exemplo da cadeira de rodas, esta arquitetura seria uma visão geral do sistema, ou seja, a cadeira de rodas necessita de motores, de um subsistema que controle esta cadeira, de um subsistema de rastreia o solo em busca de colisões, de um subsistema que monitore o dispositivo de freio, de entre outros, onde o subsistema que monitora o dispositivo de freio deve obedecer a restrições temporais e de tolerância à falhas, enquanto que o subsistema rastreador de obstáculos deve obedecer a restrições de tempo.&amp;&amp;&amp;
A segunda etapa do processo utilizado por os mesmos autores é identificar os requisitos dos subsistemas, se houverem.
Com base nas arquiteturas identificadas no processo anterior, cada arquitetura é separada e seus requisitos funcionais e não funcionais são detalhados.
O subsistema que monitora o dispositivo de freio, por exemplo, possui requisitos funcionais que podem ser classificados como detectar falha no dispositivo, corrigir falha, informar ao usuário a falha ocorrida, acionar trava de emergência, etc., e requisitos não funcionais como a trava de emergência que deve ser aciona em tempo real logo que for detectada uma falha no dispositivo de freio especificam a maneira como cada funcionalidade deve ser cumprida por o sistema.
Estas informações formam um conjunto de características do domínio de aplicações para sistemas de cadeira de rodas e características particulares do sistema sendo analisado.
A terceira e última etapa do processo de desenvolvimento de software para sistemas embarcados de Graaf e Lormans é o detalhamento dos subsistemas em nível de componentes.
Novamente requisitos são melhores detalhados e finalmente componentes específicos da arquitetura são definidos.
Para detectar falha no dispositivo de freio, por exemplo, é necessário utilizar um sensor que detecte que o dispositivo está falhando, assim um componente da sub-arquitetura detectar falha no dispositivo foi encontrada.
Para acionar a trava de emergência, é necessário de um componente acionador, que aciona a trava de emergência assim que um problema com o dispositivo de freios for detectado.
Como a restrição da necessidade de acionar a trava de emergência é em tempo real, mas basta enviar um sinal para a trava de emergência, não há a necessidade de um alto processamento nem tampouco de muita memória, uma memória que apenas registre o erro ocorrido é suficiente.
No entanto, para comunicar outros subsistemas, como o caso em que seja necessário comunicar os motores e o sistema de detecção de colisão para pararem o funcionamento, há a necessidade de um dispositivo de comunicação rápido como, por exemplo, uma porta USB (Universal Serial Bus) que possibilita que o tráfego de informações flua mais rápido que portas seriais.
Há ainda a necessidade da programação de device drivers específicos para operar cada componente.
Estes processos assimilam- se com o ditado &quot;separar para conquistar», o subsistema é separado em subsistemas, que são separados em outros subsistemas até que se chegue á uma definição de componentes de hardware.
Brisolara define outra forma de encontrar os requisitos do sistema:
&quot;A especificação dos requisitos consiste na definição de quatro elementos principais, que são:
Funcionalidade desejada por o usuário;
Requisitos de Qualidade de Serviço (QoS), tais como:
Desempenho, restrições temporais, etc;
restrições de custo (área, consumo de potência, etc); (
iv) estrutura do domínio do problema».
É possível então estruturar os aspectos relevantes do sistema num dos quatro elementos principais da especificação de requisitos.
Esta proposta define uma estruturação das características relevantes do sistema adequadamente, pois facilita a especificação dos seus requisitos e possíveis objetos.
O primeiro dos quatro elementos principais é caracterizado por encontrar as características relevantes nas funcionalidades desejadas por o usuário.
Em esta etapa são avaliadas as tarefas que o sistema deve executar, os objetivos do sistema, os possíveis módulos de operação e interface entre o usuário e o sistema.
Aspectos temporais devem ser avaliados no segundo elemento denominado requisitos de qualidade de serviço QoS, como o tempo para execução de uma tarefa, o intervalo de tempo de resposta que um dispositivo leva para acionar outro dispositivo ou software.
As características relativas ao custeio do sistema devem ser avaliadas no terceiro elemento, denominado restrições de custo.
Em este elemento são avaliados, de acordo com o sistema, o espaço físico disponível para abrigar o conjunto de software e hardware, os dispositivos (micro-controladores, COTS, as arquiteturas de hardware embutidas no sistema (número de processadores, memória, barramento) e os softwares (sistema operacional de tempo real, linguagem de programação orientada a objetos ou estruturada).
Por fim, na estrutura do domínio do problema, o sistema deve ser enquadrado em sistemas críticos, quando requerem segurança a falhas, requerendo tolerância a altas temperaturas, pressão, falta de energia, e sistemas leves, os quais não lidam com situações extremas.
As maneiras de estruturar a especificação de requisitos, abordadas por Brisolara e por Graaf e Lormas, são apropriadas para a descoberta dos requisitos do sistema.
No entanto, existe um detalhe não abordado nessas maneiras:
O projeto do sistema após a especificação de requisitos.
Segundo Graaf e Lormans, requisitos capturam o que o sistema deve fazer, enquanto que o projeto mostra como construir o sistema.
Em a prática, a identificação dos requisitos do sistema é feita de forma adequada, porém o problema surge no momento de projetar o sistema colocando no projeto os requisitos identificados.
Há a necessidade de mostrar à equipe de desenvolvimento os requisitos não funcionais que devem ser colocados no sistema, para tanto eles devem ser especificados no projeto, o que não acontece na prática de desenvolvimento de sistemas embarcados.
Este é um problema específico de projeto de software onde os requisitos não funcionais são importantes, como projeto de software para SiEs.
Disciplinas de engenharia de software auxiliam na solução destes problemas, introduzindo notações para o projeto de sistemas, em especial para o projeto de sistemas orientados.
A programação orientada a objetos é uma metodologia que objetiva descrever as relações do sistema, ou RFs, em que cada objeto do sistema é uma unidade que pode se comunicar com outros objetos e requisitar a execução de uma determinada funcionalidade.
Cada RF numa análise orientada a objetos é uma funcionalidade de um objeto.
A notação que mais teve destaque e aceitação para a análise orientada a objetos é a UML.
Esta notação oferece maneiras de modelar os RNFs e RF de um sistema de forma adequada, visto que ao final do projeto, o objetivo é descrever a estruturação e relação entre os objetos num diagrama de classes.
Para suprir a necessidade de especificação de RNFs na fase de projeto, empresas do setor de sistemas embarcados têm utilizado apenas a especificação dos requisitos em linguagem natural, processando- os num editor de textos simples.
Esta atitude acaba sendo um ponto negativo no projeto destes sistemas, visto que as empresas continuamente reutilizam de partes de projetos anteriores, e fica difícil a organização de requisitos de forma textual, o que acarreta em formas de reuso de projetos não muito apropriadas.
Muitos dos RNFs descritos de forma textual, não são encontrados quando, no momento de reutilizar de projetos já prontos, necessitam ser reaplicados num novo projeto.
A UML oferece um conjunto de Perfis, que compreendem estereótipos, tagged values e restrições, que podem ser adicionadas aos requisitos do projeto, especificando como eles devem ser tratados por o sistema.
Como o uso da UML e dos Perfis que ela oferece, é possível especificar muitos dos RNFs identificados nesta Seção.
A definição de RNFs em projetos de sistemas é, portanto, um ponto positivo na modelagem de sistemas embarcados.
No entanto, após esta definição, existe uma diferença muito grande entre o código final de uma aplicação e o código que é gerado a partir de o modelo do sistema especificado na fase de projeto.
Um desafio atual para projetistas deste tipo de sistema é utilizar os NFRs especificados nos modelos de sistemas para gerar código.
Isto possibilita a geração de um código mais parecido com o código final das aplicações.
Algumas propostas que viabilizam isso são detalhadas na próxima Seção.
Algumas abordagens para desenvolvimento de software embarcado propõem a especificação dos NFRs em modelos de sistemas com o objetivo de gerar código para aplicações.
Becker Exemplifica como um modelo que contém requisitos não funcionais é mapeado para código específico de uma API Java denominada RTSJ (Java Real-Time System).
Selic apresenta alguns conceitos que viabilizam o sucesso no desenvolvimento de software embarcado tendo como propósito gerar código para múltiplas plataformas.
Estas abordagens tem por objetivo demonstrar como utilizar os NFRs especificados nos modelos de sistema e gerar código fonte para um conjunto de plataformas alvo.
A crescente disponibilidade de diferentes plataformas tem sido um fator determinante para o sucesso no desenvolvimento de software.
Esta disponibilidade permite aos desenvolvedores estabelecerem diferentes configurações entre plataformas.
Uma configuração determina as características das plataformas que uma aplicação demanda e que devem estar especificadas no projeto dessa aplicação.
Um desafio para o desenvolvimento de software embarcado é utilizar o RNFs, especialmente os que identificam características de plataformas, para gerar código para aplicações.
Este capítulo apresenta alguns conceitos que podem contribuir para superar este desafio.
Plataformas O desenvolvimento de software é um ofício que exige bastante conhecimento das tecnologias disponíveis para a construção de sistemas.
Em este ofício, um dos requisitos para uma boa administração da informação e sucesso do desenvolvimento de aplicações é conhecer as plataformas que possibilitam a construção de software, suas restrições e as possibilidades existentes para efetuar a comunicação entre elas.
Tekinerdogan apresenta exemplos das plataformas disponíveis para construção de software comercial.
Em esses exemplos são expostas algumas das plataformas existentes para desenvolvimento de software, informando qual o vendedor, o sistema operacional que pode rodar a plataforma, o tipo de arquitetura utilizada, a linguagem de programação e os serviços da arquitetura.
Tekinerdogan argumenta que existem algumas plataformas que são dependentes.
Por exemplo, se a plataforma escolhida no quesito vendedor for Microsoft, necessariamente ou muito provavelmente as sub-plataformas precisam ser da família dos produtos Microsoft, como a linguagem de programação C&amp;, lógica de negócio deve ser.
Net, o sistema operacional deve ser Windows, etc..
Pode haver uma combinação entre plataformas livres e plataformas Microsoft, no entanto cuidado deve ser tomado ao efetuar este tipo de combinação, como utilizar algumas características ou sub-plataformas Windows, efetuando integração com um sistema UNIX usando CORBA.
A ubiqüidade de plataformas possibilita que um sistema possa ser desenvolvido levando- se em conta muitas de suas características não funcionais.
No entanto, a troca freqüente das plataformas usadas para implantar um sistema é um problema visto por os projetistas de sistemas, porque isto implica no pouco reuso dos artefatos do software deste sistema.
Softwares desenvolvidos para uma determinada plataforma são difíceis de serem reutilizados em outra.
Um exemplo típico de sistemas em que são freqüentes as trocas de plataformas são os embarcados Uma das possíveis soluções para resolver o problema do reuso de artefatos de software em decorrência da troca freqüente das plataformas utilizadas para implantar um sistema é utilizar um Desenvolvimento de Software Dirigido por Modelos.
Frankel informa que o paradigma MDD é diferenciado da linha de produção da engenharia de software clássica, porque viabiliza um ágil desenvolvimento de software, utilizando a MDA (explicada na Seção 4).
Além disso, o paradigma MDD também possibilita o reuso dos artefatos de um sistema, mesmo quando houver a troca de plataformas.
O MDD adiciona uma prática de &quot;modelagem voltada para arquiteturas».
Por exemplo, um projetista pode refinar um modelo em alto nível num modelo específico de uma arquitetura.
Se esta arquitetura é Java e é composta por arquiteturas como EJB e Struts, o modelo refinado por o projetista deve conter características de EJB e de Struts.
Isto pode ser realizado por o projetista para usar o modelo refinado e gerar um código mais detalhado do que o código que seria gerado utilizando o modelo representado em alto nível (modelo não refinado para arquitetura).
Esta prática pode ser aplicada entre muitas das etapas definidas por um processo de desenvolvimento e possibilita a geração de artefatos de software com maiores detalhes do que em práticas tradicionais.
Portanto, o uso do MDD por projetistas auxilia no processo de desenvolvimento, reduzindo o tempo necessário para desenvolver sistemas Uma das vantagens do MDD é possibilitar a geração de códigos de melhor qualidade e em maior quantidade do que usando práticas tradicionais de desenvolvimento de software.
A geração de Código é realizada com o auxílio de ferramentas Case.
Greenfield e Short informam que ferramentas para geração automatizada de código disponíveis no mercado pouco auxiliaram, até a data de sua publicação, no desenvolvimento de código voltado para as plataformas usadas no desenvolvimento de um sistema.
Até o momento, a maioria das ferramentas Case pouco tem contribuído para a geração de código levando em conta RNFs de sistema, em especial os requisitos que representam características de plataformas.
Há algumas exceções, contudo, para a afirmação anterior, como a ferramenta OptimalJ, que usa os conceitos da MDA para gerar código para sistemas.
No entanto, a maioria das ferramentas Case produzem código ineficiente.
Devido a isso, o processo de desenvolvimento de software, em especial para sistemas embarcados, tem obtido pouco proveito de ferramentas Case.
Em o MDD, ao invés de utilizar apenas uma única transformação de um modelo UML diretamente para código, pode- se efetuar mais de uma transformação deste mesmo modelo.
A razão disto é que, em cada novo modelo que é gerado, seja possível especificar um detalhe que defina um produto final mais fiel aos requisitos.
A Figura 3 mostra algumas das maneiras utilizadas até o momento para transformar um modelo em código e também efetuar a engenharia reversa, que é transformar código em modelo.
As primeiras ferramentas Case seguiam a estrutura mostrada na Figura 3 (a).
Em esta estrutura, um modelo é convertido em código, utilizando uma ferramenta Case de uma plataforma específica, e a engenharia reversa converte o código em modelo.
Já na Figura 3 (b), foram acrescentados os conceitos de framework e padrões de linguagem, pois no modelo são representados requisitos para sistemas de um mesmo domínio.
A Figura 3 (c) apresenta uma possível representação para ferramentas Case, que possibilita aplicar um desenvolvimento dirigido a modelos como a MDA.
A Figura 3 (b) apresenta a visão adotada por a Engenharia de Domínio (ED).
Em esta visão, um framework é especificado (um modelo, contendo elementos UML, representando os requisitos de sistemas de um mesmo domínio), oferecendo conjuntos de requisitos que podem ser utilizados por muitos sistemas que possuem requisitos semelhantes.
A seleção dos requisitos para cada sistema é realizada utilizando linguagens para seleção dos elementos de frameworks, como RDL.
A terceira e mais recente das visões das ferramentas Case é projetar o modelo do sistema uma única vez e permitir que este modelo sofra sucessivas transformações.
Isto é realizado até que os modelos transformados ofereçam uma correta especificação do sistema, mapeado para determinadas plataformas.
Por fim, estes modelos são transformados em artefatos de software (Figura 3 (c)).
Essa última visão representa o esquema de funcionamento da MDA, discutida na Seção 2.4.
Uma análise de abordagens para ferramentas Case foi realizada em) com o objetivo de refinar modelos em alto nível para modelos de baixo nível e dependentes de plataforma.
Em esta análise, foi identificado que as ferramentas Case que seguem o modelo da Figura 3 (a) não são capazes de gerar código que obedeça a restrições como sincronização, tempo de resposta, de entre outros requisitos não funcionais.
Isto ocorre porque elas não levam em consideração a especificação de RNFs, como características de tempo real, para a geração de código.
Ferramentas Case que seguem o modelo da Figura 3 (b), como a encontrada em, facilitam o reuso de modelos, o desenvolvimento e a geração de código de qualidade, mas ainda assim não podem gerar códigos eficientes, como é desejável em aplicações para sistemas embarcados e também comerciais.
O terceiro modelo, da Figura 3 (c), é mais sugestivo e surge como uma solução para aplicar os RNFs (especificados no modelo do sistema) em código.
Em cada modelo pode- se especificar restrições específicas para a plataforma escolhida para desenvolver o sistema, detalhando- as em suas sub-plataformas.
Para realizarem um desenvolvimento dirigido por modelos as ferramentas Case que tem este propósito podem utilizar contribuições relacionadas com o termo Generative Programming, ou simplesmente Programação Gerativa.
A próxima seção apresenta algumas abordagens relacionadas com este termo.
Generative Programming (GP) é uma denominação para algumas abordagens relacionadas com o desenvolvimento de sistemas, que utilizam algum processo de automatização para geração de código.
Esse capítulo apresenta algumas abordagens para GP, que tem como foco a MDD.
Engenharia de Domínio (ED) é um processo de desenvolvimento de software que visa reutilizar modelos de sistema de mesmo domínio e permitir que estes sistemas sejam desenvolvidos com agilidade.
As técnicas tradicionais de projeto orientado a objetos focam no projeto de um software visando apenas o sistema que necessita ser construído.
O processo adotado por a ED avalia requisitos, não somente do sistema que necessita ser desenvolvido, mas também do domínio o qual pertence esta aplicação Para Czarnecki, a avaliação e documentação das características do domínio são realizadas em quatro componentes:
A) definição do domínio, onde exemplos de aplicações do domínio são expostos, bem como regras genéricas para inclusão e exclusão no domínio;
B) léxico do domínio;
C) modelos conceituais, representados por diagramas de objeto, de interação, de estados (relacionados com a UML) ou diagramas de entidade-relacionamento e fluxo de dados (relacionados com a análise estruturada);
D) Modelo de Features (FM Features Model), que explicita num diagrama a composição das características do domínio.
Um FM pode contemplar RNFs utilizados por sistemas embarcados, documentando- os no projeto das aplicações do mesmo domínio.
Estes requisitos podem ser representados como características do FM.
Segundo Griss, uma característica pode ser:
Uma seleção entre requisitos opcionais ou alternativos;
Uma funcionalidade;
Um requisito não funcional (como performance, hardware e arquitetura de implementação).
É possível utilizar o FM para especificar plataformas.
Tekinerdogan Propuseram uma abordagem para especificar regras para seleção de plataformas, em formato textual no FM.
As regras definidas por estes autores são muito úteis para definir uma correta configuração das características do FM que podem compor um sistema.
O FM pode satisfazer a necessidade de sistemas (como os embarcados) por a representação das arquiteturas, tecnologias e etc., utilizadas para o desenvolvimento destes sistemas (Basso, Oliveira e Becker 2006).
O Modelo de Features também é conhecido como Diagrama de Features.
Existem muitos formalismos para especificar um FM.
O formalismo adotado nesse trabalho é o proposto por Czarnecki, apresentado na Figura 4, que mostra os tipos de relacionamentos que podem ser estabelecidos entre as características no MF.
Como o FM é hierárquico, sendo interpretado muitas vezes como uma estrutura em árvore e em outras abordagens como um grafo, a composição das características é representada de forma que as de nível hierárquico superior são compostas por as características do nível inferior.
Por exemplo, na Figura 4 (a), a característica &quot;Feature «pode ser composta por a &quot;FeatureA».
Em a Figura 4 (f), a característica &quot;Feature «é composta por a (s) característica (s) &quot;FeatureG «e/ ou &quot;FeatureH».
O Diagrama de Features apresentado na Figura 5 pode expressar funcionalidades obrigatórias do sistema, funcionalidades mutuamente exclusivas e funcionalidades opcionais.
Além disso, o Modelo de Features é muito adequado também para modelar plataformas, porque ele possibilita combinar as características definidas no modelo e, assim, configurar uma ou mais plataformas.
A Figura 5 apresenta um FM para especificar características para aplicações do domínio de cadeira de rodas.
É possível especificar regras de dependência entre características no Diagrama de Features.
Usando extensões propostas por Tekinerdogan Ou por Riebisch, é possível especificar algumas regras para composição de características, que são dependentes, mas que não são possíveis de serem representadas utilizando apenas a sintaxe do Modelo de Features definido por Czarnecki.
Tais extensões são especificações textuais aplicadas em cada característica.
Para Oliveira E Basso, a seta que simboliza dependência no diagrama UML é utilizada para indicar relacionamentos de dependência.
A Figura 5 apresenta características para o domínio de sistemas para cadeira de rodas.
De acordo com as características definidas e as relações entre elas especificadas no modelo, é obrigatório, para cada sistema do domínio um motor traseiro, um dispositivo de segurança para trava de rodas traseiras da cadeira e um controle que deve ser ou por voz, ou por mouse ou por joystick.
O uso de um motor dianteiro, uma trava secundária e um controle automático são opcionais.
Um display, um sistema de detecção de obstáculos e um sistema de trajetória automática são opcionais para o desenvolvimento de um sistema de cadeiras de rodas.
Porém, caso o controle por voz tenha sido selecionado, então um display sonoro torna- se obrigatório para a cadeira de rodas.
Se um sistema de detecção de obstáculos for selecionado no domínio, então é obrigatório o uso de um display para informar ao usuário da cadeira de rodas os obstáculos.
Além disso, caso um controle automático tenha sido selecionado no domínio de cadeira de rodas, então é obrigatório que a cadeira de rodas tenha um sistema automático para decidir a trajetória a ser tomada por a cadeira de rodas.
Em este caso, a composition rule &quot;requires` Detecção Obstáculos'», definida na característica «Sist.
Trajetória Automática do FM «define que:
A o ser selecionada, então a detecção de obstáculos é necessária também.
As regras para configuração das características são definidas por as relações entre elas e por suas compositions rules.
De acordo com as regras definidas no FM, muitas configurações podem ser estabelecidas entre as características.
Uma correta especificação de um FM para um domínio de aplicações é abordada por a disciplina de Arquiteturas para Linha de Produtos (PLA -- Product Line Architectures).
Um conjunto de produtos que compartilham um conjunto de requisitos, onde cada produto além de os requisitos compartilhados possui também seus próprios requisitos, são ditos como representantes de uma Arquitetura para Linha de Produto (PLA) (Griss 2001).
Uma PLA endereça um domínio de aplicações.
Logo, um domínio de aplicações contempla aplicações semelhantes.
Assim, ED e PLA são assuntos interligados, pois uma PLA configura muitos produtos identificados por a ED.
Enquanto a segunda avalia o contexto geral das aplicações, buscando a decomposição de características de sistemas, a primeira avalia especificações das aplicações deste contexto geral, buscando o agrupamento de elas.
Combinações das características de sistemas (identificadas numa PLA) determinam o que uma aplicação do domínio definido por a PLA deve conter.
Cada aplicação pode estender estas características de duas maneiras:
1) adicionando novas funcionalidades;
2) definindo novos requisitos não funcionais.
Em o primeiro caso, abordagens para Generative Programming oferecem recursos para a geração de elementos em modelos de sistemas, para cada configuração da linha de produção.
Em o segundo caso, não existem abordagens que possibilitam gerar artefatos de um sistema que atendam aos requisitos não funcionais, como a geração de código para múltiplas plataformas de desenvolvimento, de maneira automatizada ou semi-automatizada.
Por este motivo, tipicamente, as abordagens para PLA limitam- se à geração dos artefatos de um sistema para as configurações funcionais especificadas na linha de produção.
Os engenheiros de PLA utilizam o FM mais a UML para especificar os requisitos do sistema.
O Modelo de Features oferece aos engenheiros de PLA uma maneira organizada de representar as variações na linha de produção.
A UML é uma notação que oferece a possibilidade de especificar RFs e RNFs de sistemas, que se tornou um padrão para a especificação destes.
O FM especifica RFs e RNFs de maneira mais geral, enquanto os elementos da UML possibilitam especificar- los detalhadamente.
A diferença entre projetos convencionais e de PLA é que os engenheiros da linha de produção estabelecem uma relação entre as características do FM e os requisitos representados em UML e utilizam isto para a geração automatizada ou semi-automatizada de código.
A análise de requisitos utilizando a UML é realizada de acordo com o processo de desenvolvimento adotado, sendo o mais recomendado o processo baseado em Engenharia de Domínio.
Em este último, os requisitos identificados na análise são extraídos de um conjunto de aplicações semelhantes.
A o especificar um FM, o engenheiro de PLA analisa um conjunto de funcionalidades (em geral, classes especificadas com a notação UML) que compõem cada característica.
Tipicamente, durante a análise, o engenheiro de PLA:
Especifica uma relação entre as classes/ funcionalidades do domínio e cada característica do FM;
Marca os elementos das classes como obrigatórios ou opcionais (usando estereótipos e tagged values);
Define um conjunto de funcionalidades para cada característica do FM, que podem ser automaticamente selecionadas de acordo com a instanciação1 do Modelo de Features;
Define um framework de funcionalidades para o domínio.
O Modelo de Features é utilizado como um mapa que descreve uma linha de produção.
Ele oferece componentes para seleção e personalização, que permitem acrescentar as características desejadas numa determinada aplicação.
No entanto, esse modelo é conceitual e seus elementos (ou características) não podem diretamente gerar código.
O Modelo de Features se encaixa muito bem no desenvolvimento de um framework, pois expressa características que descrevem o domínio da aplicação.
Estas características, transformadas em elementos do Diagrama de Classes, podem ser instanciadas e reutilizadas.
Após a conclusão da Análise de Domínio e especificação das características no FM, o processo adotado na Engenharia de Domínio é a Instanciação do Modelo de Features.
A instanciação do FM (conhecida em PLA como instanciação para linha de produto) é realizada selecionando características do FM.
Essa seleção é mostrada na Figura 6.
As características em destaque na figura representam uma instanciação do FM.
Sempre que uma nova aplicação for desenvolvida com base no domínio especificado por a De, a instanciação do FM deve ser realizada.
Portanto, as características marcadas na Figura 6 representam os requisitos de uma determinada aplicação.
O termo instanciação do Modelo de Features é usado para representar a seleção das características do diagrama por o projetista de uma aplicação.
Como o FM não possui relação direta com a UML, há a necessidade de oferecer recursos para estabelecer esta relação.
A geração de modelos para uma aplicação do domínio, usando FM e UML, somente é possível se uma relação entre estas for estabelecida.
Oliveira Aplicaram uma relação entre UML e FM.
Para gerar artefatos de sistemas, Oliveira Propuseram um Perfil UML para especificar a instanciação de frameworks orientados a objetos com base no FM e elementos UML decorados com marcações definidas por seu Perfil, denominado como UML-FI (UML for framework instatiation).
Para Oliveira:
&quot;a integração do FM com a linguagem UML provou ser uma boa estratégia para descrever precisamente os mecanismos usados para associar as características de um domínio de aplicação com elementos de projeto que realizam estas características».
A MDA é uma abordagem para MDD, que busca sustentar nos processos de desenvolvimento de software características como portabilidade, interoperabilidade, reutilização de modelos de projeto de softwares e de código.
Para isso, a MDA utiliza uma série de padrões definidos por a OMG.
Para compreender o mecanismo adotado por a MDA para mapear e transformar modelos, há a necessidade de abordar nesse trabalho os padrões e linguagens oferecidas por a OMG, que dão suporte para a MDA.
Estes padrões e linguagens têm por objetivo o intercâmbio e padronização na definição de modelos e são abordados a seguir.
Existem outras padronizações da OMG que podem ser usadas na MDA, no entanto esse trabalho concentra- se apenas nas definições do MOF, OCL e XMI.
O padrão &quot;Standard «MOF oferece um framework de gerenciamento de meta-dados e um conjunto de serviços para permitir o desenvolvimento de interoperabilidade para sistemas dirigidos a modelos e meta-dados.
Meta-dados são dados que descrevem dados.
Segundo o documento encontrado em, o objetivo primário do padrão MOF é prover um framework para gerência de meta-dados independentes de plataforma para a MDA, em que a notação de classe da UML é utilizada para representar os meta-modelos MOF.
Meta-modelos são representações gráficas de relações que podem ser estabelecidas entre elementos descritos por meta-dados, como por exemplo, num Diagrama de Classes UML, é possível criar elementos como:
Classes com atributos e métodos, relacionar- las com outras classes, definir interfaces, fazer uma classe realizar uma interface, de entre outros.
Cada um destes elementos é um meta-dado representado no MOF.
A OCL é uma linguagem formal para descrever expressões em modelos UML.
Expressões de OCL podem ser usadas para especificar operações/ ações que, quando executadas, alteram o estado do sistema.
Modeladores UML podem usar OCL para especificar restrições específicas de aplicações nos seus modelos.
Modeladores UML também podem usar OCL para especificar consultas (queries) no modelo UML, que é completamente independente de linguagem de programação.
OCL não é uma linguagem de programação, mas uma linguagem de especificação formal e tem por objetivo descrever objetos e suas relações.
O documento OMG que descreve a OCL expõe alguns possíveis usos desta linguagem de restrições de objetos:
A) como uma linguagem de consulta;
B) para especificar elementos estáticos em classes e tipos no Modelo de Classes;
C) para especificar constantes para estereótipos;
D) para descrever pré e pós-condições em operações e métodos;
E) para descrever guardas;
F) para descrever conjuntos alvos para mensagens e ações;
G) para especificar restrições em operações;
E h) para especificar regras de derivação para atributos em qualquer expressão sobre um modelo UML.
Um documento especificado em XMI, que é explicado mais adiante, pode conter definições OCL.
XMI é uma linguagem para intercâmbio de informações.
Ela permite o compartilhamento de objetos em formato XML.
XMI pode ser útil e aplicável a uma variedade de objetos:
Análise (UML), software (Java, C+), componentes (EJB, IDL, Corba Component Model) e bases de dados (CWM).
O XMI é usado em todos os níveis de objetos e meta-objetos em MOF.
Ela é um padrão útil para a troca de modelos entre ferramentas de modelagem UML.
Utilizando os padrões adotados por a OMG, em especial os padrões UML, MOF, XMI e OCL, a MDA auxilia o projetista na especificação dos requisitos de um sistema em diferentes visões.
Cada uma destas visões fornece detalhes diferentes de alguma característica da aplicação.
Para isto, a MDA oferece recursos como:
Especificação de um sistema independentemente da plataforma que o suporta;
Especificação de plataformas;
A escolha de uma plataforma particular para implementar o sistema;
Transformação da especificação de um sistema independente de plataforma para uma plataforma particular.
A MDA recomenda que modelos de sistema sejam especificados em três visões:
CIM, Pim e PSM.
O modelo independente de computação, ou CIM, é utilizado para descrever os objetivos do sistema.
Ele oferece ao projetista uma visão dos requisitos do sistema, sem mostrar os seus aspectos computacionais.
Em o CIM, conhecido como modelo de negócio ou modelo de domínio, é especificado o que o sistema precisa e pode fazer, sem o conhecimento da computação necessária para executar- lo.
Este modelo deve ser especificado para obter uma visão de como o sistema pode ser usado e, tipicamente, é independente de como ele deve ser programado.
Ainda não são especificadas, neste modelo, restrições das funcionalidades do sistema.
Ou seja, este modelo oferece ao projetista uma visão das possibilidades funcionais relevantes para o sistema em questão.
O CIM é utilizado como primeiro passo na elaboração de um sistema.
Em ele podem ser especificadas as características obrigatórias e opcionais, existentes num sistema de um determinado domínio de aplicações.
Para Miller e Mukerji, o modelo independente de computação (CIM) é caracterizado como sendo um mediador entre aquelas pessoas que são especialistas em relação a o domínio e seus requisitos e aquelas que são especialistas no projeto e construção dos artefatos do sistema.
O documento oficial da OMG que explica a MDA não informa quais são os diagramas presentes nas visões CIM, Pim e PSM.
No entanto, porque o documento referência CIM como modelo de domínio, pode- se entender que os diagramas presentes nessa visão da MDA sejam o Modelos de Features e o Diagrama de Casos de Uso da UML, os quais buscam capturar os requisitos do sistema.
Algumas abordagens definem o termo &quot;independente de computação «como sendo modelos que não podem gerar instâncias de objetos.
Assim, o FM pode conter representações de funcionalidades e o CIM pode ser composto por muitos diagramas UML que não o de Classes e Objetos, por exemplo.
A OMG não especifica quais diagramas estão presentes no CIM.
O modelo independente de plataforma, ou Pim, representa uma visão do sistema que contém a sua computação.
Ou seja, o Pim representa os requisitos na forma de suas interações computacionais, sem, entretanto, especificar detalhes da plataforma que eles utilizam.
Em esse modelo, enquadram- se RFs e RNFs que podem ser detalhados.
Boas práticas da disciplina de Engenharia de Software indicam que, no modelo de um sistema, não é adequado especificar características de uma plataforma, apesar de isto ser necessário na codificação do sistema.
Em geral, esta prática já vem sendo adotada em projetos de software, especificando as funcionalidades dos sistemas sem vincular- las a uma plataforma.
Existe a necessidade de documentar RNFs nos modelos de sistemas, como para sistemas embarcados.
A especificação dos RNFs nos modelos de sistemas restringe os RFs para as características não funcionais.
Como RNFs são alterados com freqüência, por motivos diversos, os modelos do sistema devem ser modificados para refletir cada nova necessidade não funcional.
Desde que os RNFs não representem características de arquiteturas, plataformas de hardware e tecnológicas, a especificação dos mesmos nos modelos do sistema continua pertencendo à visão Pim.
Requisitos não funcionais podem ser especificados nos modelos do sistema utilizando o mecanismo de marcações da UML.
Estas marcações podem ser feitas decorando os elementos do modelo com estereótipos, restrições e tagged values.
As marcações tipicamente são padronizadas por a OMG, o que significa dizer que para especificar um determinado requisito não funcional num elemento do modelo de um sistema é recomendável utilizar as marcações definidas por ela.
As marcações, tipicamente, representam RNFs e podem ser encontradas de acordo com cada Perfil definido para a UML.
Um Perfil utiliza o mecanismo de extensão da UML para representar características que não estão definidas no pacote Core do MOF.
Este pacote especifica os diagramas essenciais da UML.
Um exemplo de Perfil é o SPT (Schedulability, Performance and Time), que é utilizado para representar RNFs relacionados com restrições temporais (Becker Uma alternativa para não tornar os RFs específicos dos RNFs é utilizar dois níveis de modelos na visão Pim.
O primeiro modelo pode conter apenas os RFs do sistema, sem as marcações definidas por um Perfil.
O segundo modelo pode ser decorado com os RNFs relacionados a restrições temporais, o que quer dizer que passam a atender essas restrições temporais.
Caso ocorra, num sistema, uma mudança dos seus RNFs, é possível partir de um projeto do mesmo sistema no primeiro modelo e especificar os novos requisitos não funcionais num segundo modelo.
Esta prática é caracterizada como uma boa maneira de administrar os modelos do sistema, reduzindo o trabalho em caso de mudança nos NFRs de uma aplicação.
A visão CIM da MDA representa os requisitos do sistema capturados e explicitados de forma que não é avaliada a implementação destes.
Em a visão Pim, ao contrário de a anterior, estes requisitos devem ser avaliados e especificados em diagramas.
Logo, na visão Pim da MDA, Diagramas de Classe, de Objetos e de Seqüência podem ser definidos.
Modelos de Classes devem ser utilizados sem a especificação das características das plataformas que podem implementar- los, isto inclui levar com si os RNFs.
Algumas abordagens visam o desenvolvimento de frameworks no Pim.
Tais abordagens esperam construir aplicações com base no reuso de elementos destes frameworks.
Para as mesmas, o conceito de Engenharia de Domínio é de fundamental importância, visto que esta objetiva a construção de software flexível para reutilização.
O Pim, baseado na documentação OMG e em trabalhos como os de Tekinerdogan, Almeida E Oliveria, possui o legado da UML para instanciação de objetos e separa os modelos que são possíveis de gerar elementos instanciáveis dos modelos de descrição do sistema no CIM e dos modelos transformados para abrigar uma plataforma específica no PSM.
Esta separação de características aumenta o reuso de modelos de um projeto de sistema, visto que um modelo independente de plataforma pode ser utilizado muitas vezes para qualquer plataforma que possa implementar- lo e executar- lo.
O modelo específico de plataforma, ou PSM, é uma visão do sistema dos aspectos relacionados com a plataforma que deve implementar- lo.
O PSM combina a especificação do modelo independente de plataforma (Pim) com detalhes específicos de uma determinada plataforma.
Em este modelo, são escolhidas uma ou mais plataformas para implementar e executar uma aplicação.
Esta escolha implica definir as características necessárias para refinar o modelo Pim em a (s) plataforma (s) escolhida (s), especificando como os serviços de esta (s) plataforma (s) cooperam para realizar as funcionalidades do sistema.
Os elementos especificados no PSM são elementos prontos para a geração de código.
Os elementos do modelo do sistema no PSM, como possuem as características de uma ou mais plataformas, podem ser refinados para elas, o que significa dizer que podem gerar código para uma aplicação contendo características arquiteturais, de serviços, tecnológicas, etc..
O Modelo de Descrição de Plataformas (PDM) contém as características de plataformas disponíveis para o desenvolvimento de sistemas.
Para transformar um Pim num PSM, é necessário identificar as plataformas que podem efetuar este refinamento.
Willink define além de as visões CIM, Pim e PSM da MDA, uma quarta visão, em que é necessário documentar as plataformas que são utilizadas para desenvolver sistemas.
O mesmo autor denomina esta visão como PDM.
O PSM representa os requisitos avaliados no modelo Pim numa arquitetura específica, que foi identificada no PDM.
Em ele, é possível implementar o modelo Pim numa arquitetura específica.
Em a Figura 7 é mostrada a existência de um Pim, de um modelo de plataforma (PDM) e de uma transformação.
O Pim é mapeado para uma plataforma e transformado no PSM.
Para efetuar a conversão de um modelo independente de plataforma para outro dependente de plataforma a MDA sugere uma série de etapas (que são detalhadas na Seção Escolha de uma plataforma;
Marcação dos modelos para esta plataforma e;
Transformação do modelo para a plataforma específica.
O mapeamento pode ser realizado adicionando marcações (especificações de instâncias de modelos) nos modelos do sistema e associando os modelos marcados com algum compilador de modelos, que interpreta as marcações e gera um novo modelo dependente de uma plataforma.
Um compilador de modelos pode ser uma ferramenta que recebe como entrada um modelo, realiza um processamento nos dados de entrada em busca de algumas marcações em eles aplicadas e gera como saída outro modelo.
Marcado o modelo, ele pode ser transformado, utilizando uma ferramenta Case que conheça a plataforma escolhida.
Alternativamente, um compilador de modelos pode ser um elemento de um modelo que compõe a visão PDM de um sistema.
Em este caso, as marcas especificadas num elemento do modelo PDM devem possuir uma sintaxe, para possibilitar a expressão de mapeamentos e transformações de modelos entre as plataformas.
A Figura 7 apresenta uma única fase de mapeamento e transformação de modelos.
Um mapeamento pode ser feito como exemplificado anteriormente, marcando um elemento do Pim para ser transformado para uma determinada plataforma (Figura 7).
Marcações indicam como um modelo deve ser transformado.
Uma marcação pode vir de diferentes fontes.
Estas fontes podem ser:
Tipos de um modelo que são especificados por classes, associações ou outros elementos de modelo;
Regras de um modelo, por exemplo, regras de um padrão de projeto;
Um template pode conter muitas marcações, que especificam como um modelo deve ser transformado.
Por exemplo, pode haver um template para o mapeamento de um modelo de sistema para web.
O template deste modelo para a plataforma J2EE define as marcações para transformar este modelo num modelo que abrigue características da plataforma J2EE.
Outro template deste mesmo modelo, porém agora para a plataforma.
Net, pode conter marcações distintas, que especificam necessidades que devem ser obedecidas na sua transformação para esta plataforma.
Xdoclet é um exemplo de ferramenta e linguagem de marcação que opera com templates.
Ela define algumas marcações que podem ser utilizadas e especializadas nos códigos do sistema, gerando o código de acordo com as marcações definidas nas linhas de um programa.
É possível utilizar OCL e outras linguagens para definir templates.
A cada mapeamento de um modelo, originalmente um Pim, e a transformação deste para um outro modelo, implica no mesmo tornar- se cada vez mais específico de uma ou mais plataformas.
Quando são feitos mapeamentos num modelo e transformações lhe são aplicadas, ele passa a abrigar as características especificadas no mapeamento.
Isto significa dizer que o modelo vai recebendo características de implementação da arquitetura para a qual foi transformado.
O último modelo, PSM, sempre é o modelo do sistema especificado para refinamento numa arquitetura específica, ou seja, o modelo que abriga as características de uma plataforma.
Um modelo pode ser mapeado e transformado muitas vezes, até que ele assuma todas as características necessárias para tornar- se um modelo válido para uma plataforma, um PSM.
As etapas de mapeamentos e transformações de modelos podem ser visualizadas na Figura 8.
Almeida Introduziram o conceito de plataformas abstratas, para indicar modelos de nível intermediário entre um Pim e um PSM.
Para representar estes modelos intermediários, foi utilizada, na Figura 8, a denominação &quot;Modelo Intermed».
Os mesmos recebem características não funcionais, como as de arquiteturas de desenvolvimento, mais detalhadas do que as contidas no Pim.
Um mapeamento é a especificação de um Pim em determinadas características de plataformas.
O Pim pode ser transformado em outro modelo, mais concreto que o Pim, que especifica um determinado sub-conjunto de uma plataforma específica.
Assim, o Pim é transformado para um modelo de nível intermediário e este último é transformado para um As relações entre as visões Pim e PSM da MDA são realizadas em etapas de mapeamento e de transformação de modelos.
Estas etapas são o cerne da MDA, sendo possível estabelecer relações entre os modelos e regras para originar um novo modelo, que possa gerar código específico para implementação numa determinada plataforma.
No entanto, a MDA não determina as etapas de mapeamento e transformação.
Estas etapas ainda estão em fase de pesquisa e estabelecimento de padrões por a OMG.
A MDA também sugere que os modelos de sistemas sejam transformados de uma visão para outra.
Por exemplo, de uma visão Pim o modelo de um sistema pode ser transformado para um outro modelo na visão PSM.
Czarnecki e Simon classificam abordagens de MDA para transformação e divide- as em duas categorias:
Model-to-Code (M2C) e Model- to Model (M2M).
Em transformações M2C o objetivo é gerar código diretamente a partir de modelos.
Em transformações M2M, um objetivo é transformar um modelo de entrada (Pim) num outro modelo (PSM).
Em a MDA, as entradas e saídas de uma transformação definem um mapeamento.
Por exemplo, um Pim pode ser um modelo em que seus elementos estão decorados com marcações de um Perfil UML.
Este modelo é usado como uma entrada de uma transformação, que deve gerar como saída um modelo alvo ou código para uma aplicação.
Então um mapeamento descreve um modelo fonte e um modelo alvo, enquanto a transformação refina o modelo fonte no modelo alvo.
Czarnecki e Simon categorizam abordagens para transformação em dois grandes grupos:
Model- to code (M2C) e model- to model (M2M).
Segundo os mesmos autores, &quot;muitas ferramentas oferecem ambas transformações model- to model e model-tocode (exemplos são Jamda, XDE, e OptimalJ) «(Czarnecki e Simon 2003).
Em transformações M2C, o objetivo é gerar código diretamente de modelos ou templates.
Em transformações deste tipo, o modelo do sistema pode representar as características da plataforma alvo.
Por exemplo, o modelo do sistema contém características da linguagem de programação Java.
Abordagens para transformações da categoria M2C informam que os modelos prontos para a geração de código (PSMs) são transformados em código por um compilador de modelos.
Um compilador de modelos processa os elementos do modelo de entrada e gera uma saída.
O processamento busca elementos do modelo fonte e efetua nos elementos encontrados algumas transformações.
Estas transformações podem modificar um elemento, criar novos elementos e associar- los com outros elementos.
A saída de um compilador de modelos é composta por:
A) um ou mais arquivos, que podem ser representados em qualquer formato, incluindo os utilizados para intercâmbio de modelos como XMI;
B) objetos que são instancias do MOF, que estão na memória do computador e podem ser persistidos de alguma maneira.
Para as abordagens de transformações da categoria Model- to Model (M2M) o objetivo é gerar um novo modelo.
O modelo gerado por transformações M2M pode ser mais detalhado que o modelo anterior (recebido como entrada por a transformação), ou até mesmo ser outro modelo contendo novos elementos de um sistema.
Algumas abordagens para transformação de modelos da categoria M2M determinam que os elementos de um modelo, quando transformados por algum compilador de modelos, recebem marcações com estereótipos e restrições.
Czarnecki e Simon salientam que transformações M2M são necessárias para preencher grandes lacunas de abstrações entre Pims e PSMs.
É mais fácil gerar modelos intermediários do que gerar diretamente, a partir de um Pim, um PSM.
Além disso, para os mesmos autores, os modelos intermediários podem ser necessários para estabelecer otimização e ajustes no modelo (para propósitos de debugging) e oferecem uma visão do modelo do sistema mais especificamente para uma plataforma (Czarnecki e Simon 2003).
Czarnecki e Simon dividem abordagens para transformações M2M em outras cinco categorias:
Transformação de Manipulação Direta de Modelo (TMD):
Abordagens desta categoria oferecem mecanismos para manipular os elementos de um modelo.
Os elementos de um modelo, tipicamente, são representados utilizando o MOF.
Para manipular- los, as abordagens com foco em transformações desta categoria oferecem uma linguagem para a manipulação de modelos;
Relacional: O objetivo é relacionar dois elementos de um ou mais modelos.
Esta relação pode ser seguida de uma regra para transformação que determina a conversão de um modelo para o outro;
Baseadas em transformações de grafos:
Por exemplo, o objetivo é converter um modelo representado em UML para um que use outra representação como SLOOP;
Dirigidas por uma Estrutura de Transformações:
O objetivo é estruturar as transformações dos modelos;
Híbridas: Diferentes técnicas das categorias anteriores são combinadas.
A MDA também oferece recursos para a geração automática de código.
Isto quer dizer que, ao selecionar uma arquitetura, como por exemplo J2EE, o modelo independente de plataforma Pim, ao ser convertido num modelo específico de plataforma PSM, possibilita a geração automática de código para a arquitetura escolhida.
Tekinerdogan et.
Al. Afirmam que o desenvolvimento de um sistema em MDA, utilizando o caminho mais curto para gerar código a partir de um modelo UML, procede de um CIM para um Pim, de um Pim para um PSM e de um PSM para código.
Existem, atualmente, muitas ferramentas de desenvolvimento de projetos de software que convertem modelos UML em código e que aplicam alguns dos conceitos envolvidos na MDA, no entanto poucas utilizam o conceito de MDD.
Para gerar código, a ferramenta Case deve conhecer a plataforma fim.
Assim, o modelo do sistema, assumindo uma plataforma no PSM, pode ser transformado em código para aquela plataforma.
Por exemplo, supondo que o PSM foi originado a partir de mapeamentos do Pim para uma plataforma Java, utilizando plataformas como J2EE e EJB.
Somente pode ser gerado código para este modelo se a ferramenta utilizada for capaz de implementar estas plataformas, como a ferramenta Eclipse para a linguagem de programação Java, e interpretar o modelo PSM.
O código gerado possivelmente não teria serventia, se fosse utilizada, para tal feito, a ferramenta Jude, que gera código apenas para algumas características de J2SE (J2SE é parte integrante de J2EE).
Além disso, a ferramenta usada para geração de código necessita conhecer o PSM, ou seja, o modelo necessita conter especificações válidas para a plataforma.
Este capítulo apresenta os trabalhos relacionados, separando- os de acordo com alguns conceitos necessários para MDD e usados na abordagem FOMDA (apresentada no Capítulo 4).
Czarnecki e Simon categorizaram algumas abordagens para transformação de modelos na MDA.
Tal categorização é utilizada para definir os trabalhos relacionados com o presente trabalho.
M2M -- Manipulação Direta de Modelos A abordagem FOMDA aplica transformações da categoria TMD.
UMT, Jamda e RDL+ UML-FI são abordagens relacionadas com a FOMDA porque elas também aplicam transformações desta categoria.
É possível definir interpretadores de linguagens para transformação de modelos tanto na UMT quanto na Jamda.
No entanto, isso é realizado modificando o código dos protótipos UMT e/ ou Jamda.
Em a FOMDA Toolkit (um protótipo desenvolvido para a abordagem FOMDA) não há a necessidade disso, porque este protótipo já está preparado para a adição de interpretadores (que ocorre em tempo de execução).
A abordagem FOMDA traz inovações em relação a abordagens para manipulação direta de modelos.
Ela oferece recursos para a transformação de modelos como:
A) a capacidade de efetuar composição de transformadores dinamicamente;
B) adicionar elementos de modelos diretamente para parâmetros dos transformadores.
Em muitas abordagens, UMT e RDL_ UMLFI, para pesquisar um determinado elemento no modelo de um sistema é necessário efetuar uma varredura no mesmo.
Em a FOMDA este elemento pode ser identificado visualmente e ser adicionado num determinado transformador.
O protótipo FOMDA Toolkit auxilia o projetista de aplicações a realizar isso;
C) a validação dos elementos mapeados para os transformadores (isto restringe os elementos que podem ser recebidos por um transformador);
D) a capacidade de determinar a execução de transformadores quando determinadas plataformas forem necessárias no desenvolvimento do sistema;
F) a capacidade de personalizar uma transformação para uma determinada plataforma alvo.
Esses recursos não são encontrados em abordagens para manipulação direta de modelos como UMT, Jamda e RDL+ UMLFI.
Transformações da categoria de manipulação direta podem ser definidas como de baixo nível porque aplicam uma transformação diretamente nos elementos de um modelo.
Transformações de alto nível podem:
A) oferecer uma camada mais abstrata de transformações e mapeamentos do que as de baixo nível;
B) compor, organizar e coordenar as transformações de baixo nível;
C) possibilitar a visualização das transformações intermediárias entre um Pim e um PSM.
Transformações de alto nível podem ser definidas como dirigidas por uma estrutura de transformação.
M2M ­ Definição de Estrutura de Transformações A abordagem FOMDA utiliza quatro etapas para organização de transformações.
Estas quatro etapas são utilizadas para coordenar a transformação de um Pim para um PSM.
O objetivo desta divisão é tornar o processo de mapeamento e transformação de modelos (definido por a MDA) possível de ser administrado em níveis altos de abstração.
De o baixo nível (quarta etapa), em que é possível a manipulação direta de modelos, ao alto nível (primeira etapa), em que as transformações aplicadas nos modelos são coordenadas de acordo com características não funcionais de sistemas de um mesmo domínio, outras duas etapas oferecem:
A possibilidade de compor transformações de manipulação direta de modelos e de adicionar visualmente elementos de modelos para as entradas dos transformadores (terceira etapa);
A especificação, seleção e a troca das plataformas utilizadas por sistemas (segunda etapa).
Em a organização das transformações de alto nível o objetivo é descrever o processo de transformação de um modelo de um Pim para um PSM.
Para isso, é necessário especificar características de plataformas (que são utilizadas com o propósito de aplicar transformações) e organizar- las na ordem com que as transformações devem ser aplicadas no modelo do sistema.
Esta organização visa especificar os níveis intermediários de transformações compreendidos entre um Pim e um PSM, ou seja, documenta os mapeamentos do modelo do sistema para as características de plataformas disponíveis para implementar- lo num PDM.
A partir de esta especificação, é possível visualizar o &quot;caminho «que o modelo do sistema (inicialmente um Pim) deve &quot;percorrer «entre as características de plataformas e ser transformado por elas.
Isto deve ser realizado por o projetista até que o modelo contenha as características necessárias num PSM.
A organização das transformações de alto nível é especificada num workflow, chamado de FOMDA workflow.
O workflow organiza as características das plataformas, previamente especificadas num PDM (transformações da segunda etapa), e documenta as entradas e saídas de cada característica.
Boas abordou a organização de plataformas de desenvolvimento de software utilizando um workflow.
A idéia é semelhante à organização de alto nível de transformações que compreende a primeira etapa da FOMDA.
As plataformas são plugins desenvolvidos para a Ide Eclipse (com base no framework GME) e cada uma de elas é um compilador de modelos.
A abordagem de Boas é adequada para especificar ordem nas transformações de um Pim para um PSM.
No entanto, não é possível visualizar no seu workflow os tipos de modelos que podem ser manipulados por os compiladores de modelos e nem os tipos de modelos que são gerados por estes compiladores.
Além disso, não fica claro em sua abordagem como uma ferramenta deve interpretar o workflow e configurar os plugins.
OptimalJ é uma abordagem para organização de transformações M2M.
Ela oferece um framework, especificado na linguagem de programação Java, que possibilita especificar a ordem das transformações.
OptimalJ é uma ferramenta que possibilita a definição de transformações de nível intermediário entre um CIM, um Pim e um PSM.
A abordagem FOMDA formaliza a ordenação de transformações com o Diagrama de Atividades da UML, oferecendo uma solução para organizar as transformações necessárias entre um Pim e um PSM, independente da ferramenta MDA utilizada.
Outra abordagem para organização/ estruturação de transformações é proposta por especificados como pacotes UML.
Para tanto, Almeida Utiliza o mecanismo de extensão da UML, para estender o elemento pacote da UML.
Os objetivos desta extensão são:
As abordagens encontradas em, utilizadas para organização/ estruturação de transformações, são interessantes porque possibilitam organizar as transformações necessárias entre as três visões do desenvolvimento de um sistema definidas na MDA.
No entanto, elas carecem de uma estrutura que defina uma configuração correta entre as transformações.
Isto quer dizer que o projetista pode, utilizando tais abordagens, organizar transformações que não façam sentido no desenvolvimento de um sistema.
Por exemplo, o projetista pode indicar que o modelo do sistema é primeiro transformado por um compilador de modelos para um modelo MVC, representado em J2EE, e depois outro compilador de modelos converte este modelo num código para C&amp;.
A abordagem FOMDA minimiza este problema.
Isto porque as transformações que devem ser documentadas no workflow são representadas por as características de plataformas identificadas no PDM.
O PDM especifica as combinações válidas entre características de plataformas.
Isto significa que o workflow ordena as transformações que já foram previamente validadas como um conjunto no PDM.
Em a MDA é importante identificar as características de plataformas disponíveis para implementar um sistema.
O conceito de independência de plataformas é muito importante na MDA e somente pode ser usado se um conjunto das plataformas alvo for conhecido.
Em a transformação de um Pim para um PSM é importante conhecer as características do PSM.
Estas características podem oferecer detalhes que devem ser adicionados num modelo de sistema.
Para isso, existe a necessidade de uma representação formal das características de plataformas usadas num Um formalismo adotado por os projetistas para documentar características de sistemas, de entre eles os de plataformas, é o Modelo de Features.
O MF oferece um conjunto de relações que podem ser estabelecidas entre as características do modelo e, dessa maneira, estabelece uma sintaxe para a composição de elas no desenvolvimento de um sistema.
No entanto, o MF oferece apenas um conjunto de relacionamentos que podem estabelecer regras para a seleção das características do modelo.
Algumas informações como por exemplo, &quot;caso selecionar a característica A, então selecione B e C e se D for selecionada então selecione F e G», não podem ser especificadas apenas com as relações definidas por o FM.
Como identificado por Tekinerdogan &quot;Atualmente, na MDA a seleção de plataformas é implícita e não é provido suporte à semântica para guiar o engenheiro de software na escolha das plataformas corretas».
Para tanto, o mesmo autor propôs a especificação de regras textuais nas características do FM para a composição destas num desenvolvimento de um sistema.
A abordagem FOMDA utiliza o Modelo de Features para especificar características não funcionais de sistemas (como as que representam plataformas).
Esta especificação ocorre numa visão separada das demais da MDA, identificada por alguns autores como PDM.
Tekinerdogan Salienta que o MF pode ser utilizado para estabelecer as transformações de nível intermediário entre um Pim e um PSM.
No entanto, o mesmo autor não propõe uma solução de como utilizar o Modelo de Features para aplicar transformações.
A abordagem FOMDA propõe uma solução de como utilizar o MF para aplicar transformações.
Utilizando as características selecionadas do FM e as identificando como atividades num workflow, a abordagem FOMDA organiza as transformações de nível intermediário entre um Pim e um PSM.
O trabalho de Oliveira Define uma solução para a transformação de um CIM num Pim e de um Pim para PSM.
Para tanto, o mesmo define a linguagem RDL, utilizada para efetuar a manipulação direta de modelos de frameworks orientados a objetos.
Além disso, um perfil denominado UML-FI pode ser utilizado para acrescentar marcações nos elementos do modelo do framework.
As marcações servem para determinar os elementos de um modelo que são obrigatórios e os que são opcionais.
Transformadores podem ser especificados utilizando a sintaxe definida na linguagem RDL.
Um algoritmo de um transformador (escrito em RDL) pode, por exemplo, transformar os elementos contidos no framework (CIM) num novo modelo que contenha apenas os elementos de um modelo que são necessários para uma aplicação (Pim).
Uma análise das abordagens para MDA foi realizada para identificar se elas são suficientes para aplicar um desenvolvimento dirigido por modelos.
Como resultado, percebeuse que as mesmas aplicam parcialmente o conceito de MDA e, portanto, não são suficientes para aplicar o desenvolvimento de software por meio de modelos.
Este resultado levou à identificação de pontos interessantes para MDA que não são tratados nestas abordagens.
Estes pontos serviram como base para a elaboração da abordagem FOMDA e são listados a seguir.
As abordagens são focadas em transformações M2C e não em M2M.
Isto impossibilita a troca de plataformas/ arquiteturas sem muito esforço.
Em um desenvolvimento dirigido por modelos a troca de plataformas é um requisito essencial.
Se as transformações são realizadas diretamente de um modelo especificado em alto nível para código, a troca de plataforma implica em perda significante do código, devendo- se partir do modelo de alto nível para realizar novamente transformações para código.
Transformações M2M são mais flexíveis à mudanças de plataformas por possibilitarem que o modelo seja especificado em níveis de detalhes de plataformas;
As abordagens não oferecem estrutura suficiente para coordenar e validar transformações M2C.
Transformações M2C precisam gerar código similar ao que é gerado por o programador.
Portanto, estas transformações precisam ser coordenadas e validadas de acordo com as arquiteturas utilizadas por o programador.
As abordagens não oferecem estrutura suficiente para o projetista organize as transformações que ele precisa realizar no seu modelo.
Em um desenvolvimento dirigido por modelos com base em MDA é necessário ter uma visão do sistema sendo transformado em baixo e alto nível.
A visão de transformações de baixo nível possibilita analisar e transformar o modelo de um sistema como suas partes (Ex..
Não existe uma abordagem completa para MDA.
Para aplicar um MDD é necessário integrar as soluções das abordagens estudas e também os pontos discutidos nesta Seção.
Em o MDD, um modelo abstrato precisa ser refinado para um modelo concreto.
Modelos refinados contêm características das plataformas que são usadas para desenvolver uma aplicação.
Não existe na literatura pesquisada nenhuma abordagem que auxilia os projetistas no refinamento de modelos abstratos em modelos concretos para múltiplas plataformas.
Dado que o FM é usado para especificar características de plataformas e a MDA é usada para auxiliar em transformações, o objetivo desse trabalho é prover uma solução que utilize essas abordagens para compor e organizar transformações baseadas em características e, conseqüentemente, facilitar o mapeamento de um modelo mais geral para múltiplas plataformas.
Assim, é proposta a abordagem FOMDA.
O principal objetivo da abordagem FOMDA é definir uma solução para projetistas identificarem mapeamentos e transformações de modelos de sistemas.
Em esta abordagem, o Modelo de Features é utilizado para identificar plataformas.
Estas são usadas para identificar modelos fonte (especificados em alto nível) e modelos alvo (dependentes de uma plataforma).
Esta identificação representa um mapeamento.
Um mapeamento determina uma transformação que deve ser realizada por uma característica do FM para, a partir de o modelo fonte, gerar o modelo alvo.
Os mapeamentos e transformações de modelos são organizados num workflow.
Este workflow é uma extensão de alguns elementos do diagrama de atividades da UML.
A abordagem FOMDA define um Perfil UML para organização de mapeamentos e transformações de modelos neste workflow.
A FOMDA Toolkit é uma ferramenta protótipo que dá suporte à abordagem FOMDA.
Ela é utilizada por um projetista de uma aplicação para transformar um modelo especificado em alto nível (Pim), num modelo dependente de plataforma (PSM) ou código para uma aplicação.
O projetista de uma aplicação é um usuário da FOMDA Toolkit que pretende utilizar- la para gerar código para uma aplicação.
A entrada para a FOMDA Toolkit é um documento no formato XMI que especifica o modelo de um sistema.
Este documento contém meta-dados UML representados em formato XML.
Este protótipo utiliza um parser de XMI para converter os meta-dados, que estão em formato XML, para elementos que são instâncias do MOF.
Os meta-dados são disponibilizados em plataformas por a FOMDA Toolkit.
As plataformas são características de um FM).
Características de um FM descrevem requisitos de sistemas e podem ditar como uma transformação acontece.
Estas características podem conter transformadores de modelos da categoria TMD), discutida na Seção 7.1.
A instanciação do FM, descrita na Seção 3.3.4, provê características necessárias para desenvolver um sistema).
Estas características estão sujeitas ao uso de transformações e são organizadas num workflow).
Para transformar um modelo especificado em alto nível, o projetista de aplicação precisa utilizar as plataformas mais os mapeamentos e as transformações definidas na FOMDA Toolkit.
Esta definição é realizada por um projetista de transformações, que configura esse protótipo com base na abordagem FOMDA.
O projetista de transformações é um usuário da abordagem FOMDA e a utiliza para especificar:
O modelo de plataformas (PDM);
Os transformadores da categoria TMD;
As instâncias do PDM e a organização das transformações.
Para auxiliar o projetista de transformações a configurar a FOMDA Toolkit, a abordagem FOMDA divide a organização das plataformas, dos mapeamentos e das transformações de modelos em quatro etapas.
Em esta abordagem, as tarefas de identificar e instanciar o FM são realizadas na segunda etapa de organização (nesta etapa é possível especificar as plataformas).
Os mapeamentos de modelos são identificados num workflow que pertence à primeira etapa (alto nível) de organização.
As transformações são realizadas por transformadores e pertencem à quarta etapa de organização (baixo nível).
A terceira etapa possibilita organizar transformadores de modo a compor- los dinamicamente.
Detalhes desta abordagem são encontrados no próximo capítulo.
O projetista de uma aplicação especifica os requisitos de um sistema, ou domínio de sistemas (utilizando a UML), e os persiste num documento no formato XMI.
O projetista da aplicação precisa utilizar este documento como entrada para a FOMDA Toolkit e usar- la para efetuar transformações em modelos de sistemas.
As transformações podem originar novos modelos.
Em a FOMDA Toolkit, o documento no formato XMI é convertido para instâncias do MOF.
Então uma transformação na FOMDA Toolkit pode gerar novos documentos XMI, instâncias do MOF ou gerar código para uma aplicação.
A abordagem FOMDA auxilia o projetista de aplicações a efetuar tais transformações.
Em a abordagem FOMDA, o XMI do documento do modelo de sistema pode conter elementos que representam a visão Pim da MDA.
Modelos que especificam Diagramas de Classes, Diagramas de Objetos, Diagramas de Colaboração ou Diagramas de Seqüência são modelos que estão na visão Pim da MDA.
A FOMDA Toolkit foi desenvolvida para aplicar este esquema de MDD.
O objetivo do projetista de aplicação ao usar a FOMDA Toolkit é converter os elementos contidos no documento XMI, que estão na visão Pim da MDA, num PSM e usar- lo para gerar código para sua aplicação.
Para efetuar a conversão de um Pim para um PSM, é necessário utilizar transformações que manipulam os elementos contidos no Pim.
Para isto, é necessário conhecer os padrões da MDA, que são o MOF e XMI, descritos na Seção 4.1.
O XMI é padrão de linguagem que possibilita representar elementos de um sistema, especificados com UML, em formato textual.
Elementos definidos por a UML seguem o padrão MOF.
Então, elementos de um modelo especificados em UML são instâncias dos meta-dados definidos por o MOF e são persistidos em formato XMI.
Como o XMI é uma linguagem, documentos no formato XMI podem ser representados em versões diferentes da linguagem XMI.
Logo, alguns elementos definidos por o MOF são especificados de maneira diferente em cada versão da linguagem XMI.
Isto ocorre porque um elemento de um modelo de sistema pode ser persistido de maneiras diferentes para cada versão de XMI utilizada.
Existe uma limitação para as transformações que manipulam elementos contidos num documento no formato XMI.
Elas funcionam corretamente quando projetadas para manipular documentos especificados numa única versão dessa linguagem.
Porém, o mesmo não pode ser garantido se estes documentos estão especificados em outras versões do XMI.
Isto é um problema, porque numa transformação M2M de manipulação direta de modelos, um algoritmo precisa ser especificado e este precisa manipular um elemento específico do modelo do sistema.
Caso este algoritmo manipule um elemento do modelo especificado no formato XMI, como é realizado em abordagens como UMT, ele fica limitado a manipular os elementos de modelos que estão especificados numa determinada versão do XMI.
Para permitir que uma mesma transformação manipule qualquer modelo de um sistema, existe a necessidade do modelo ser representado num formato padrão.
Isto implica em evitar uma transformação manipule documentos no formato XMI.
Transformações na FOMDA Toolkit podem, então, manipular elementos representados em MOF, que identifica os elementos da UML num formato padrão.
Portanto, uma solução que torna os transformadores genéricos em relação a os elementos manipulados por eles é converter- los em objetos que são instâncias do MOF.
A abordagem FOMDA em conjunto com a FOMDA Toolkit adota tal solução para reuso de transformações da categoria M2M.
O reuso é obtido porque o modelo de um sistema, especificado no formato XMI, é convertido para objetos que são instâncias do MOF.
Para realizar esta conversão a abordagem conta com o auxílio da FOMDA Toolkit.
As transformações na FOMDA Toolkit manipulam objetos e não elementos de um documento especificado no formato XMI.
A abordagem FOMDA é utilizada para configurar as transformações na FOMDA Toolkit.
Existem algumas vantagens que as transformações da FOMDA apresentam em relação a as transformações de outras abordagens:
A) o rápido acesso de uma transformação aos elementos do modelo de sistema, porque estes são armazenados na memória de acesso aleatório do computador;
B) a independência das versões do XMI, utilizado para representar modelos;
E, como conseqüência, c) a reutilização das transformações de manipulação direta de modelos.
A Figura 9 esboça como o projetista de uma aplicação interage com a FOMDA Toolkit para aplicar transformações em modelos de sistemas.
Depois de converter os elementos do documento XMI para instâncias do MOF (com o auxílio da FOMDA Toolkit), o projetista do modelo do sistema deve manipular estas instâncias afim de transformar- las em outros elementos UML (transformação M2M) ou código para a aplicação (transformação M2C).
Isso deve ser realizado, levando em conta as plataformas (encontradas num PDM) que serão usadas para desenvolver a aplicação, também os mapeamentos do modelo de sistema para estas plataformas e as transformações que podem gerar o que é requerido por o mapeamento.
Para auxiliar o projetista de aplicação na manipulação do modelo de sistema, a abordagem FOMDA possibilita que plataformas, mapeamentos e transformações sejam previamente definidos na FOMDA Toolkit por um projetista de transformações.
Portanto o esquema para MDD apresentado na Figura 10 é totalmente configurável na FOMDA Toolkit, utilizando para isso a abordagem FOMDA.
Características não funcionais descrevem os requisitos do sistema e podem ditar como uma transformação acontece.
Características podem ser mapeadas para transformações, como mostrado na Figura 9 (a) e (c).
A instanciação do FM, descrita na Seção 2.3.4, provê as características sujeitas ao uso de transformações e necessárias para desenvolver um sistema, como mostrado na Figura 9 (b) e (c).
Para organizar as transformações que acrescentam as características selecionadas no FM, o projetista de transformações utiliza os modelos apresentados na Figura 9 (b), (c) e (d).
No entanto, para que o projetista de transformações possa especificar a ordem em que ocorrem as transformações compreendidas entre elementos numa visão Pim e uma PSM, ele tem que analisar as seguintes questões:
Qual é o ponto inicial?
Qual é o resultado esperado?
Qual é a próxima transformação?
A abordagem FOMDA objetiva auxiliar os projetistas de transformações a realizarem um plano e projetarem transformações que são utilizadas por projetistas de aplicações.
O plano e o projeto de transformações implicam na resposta das questões acima.
O plano envolve identificar os passos necessários para transformar um modelo de alto nível (Pim) em código fonte (Figura 9 (c)).
Gerar código a partir de modelos de alto nível não é uma solução adequada quando o conjunto de características não funcionais utilizadas por um sistema for extenso.
Em estes casos, os projetistas precisam considerar primeiro trabalhar com transformações M2M e gerar modelos intermediários entre um Pim e um PSM.
Além disso, o plano para transformação de modelos é necessário para documentar todas as camadas de transformação.
Deve ser informando o que é realizado em alto nível, para ter uma noção clara do que necessita ser feito antes do término de uma transformação, juntamente com a saída de baixo nível da mesma.
Para entender como os modelos identificados na Figura 9 são utilizados, é necessário saber a função que cada um exerce num desenvolvimento dirigido a modelos para a abordagem FOMDA.
A próxima seção apresenta um exemplo de uso desta abordagem.
Um exemplo de utilização da abordagem FOMDA pode ser visto na Figura 11.
Esta última apresenta alguns modelos, que são representados como retângulos na figura e especificam uma visão dos elementos de um sistema.
Estes elementos são requisitos de um sistema especificados em UML.
Os modelos representam requisitos de sistemas, visões da MDA (como Pim, PSM e PDM), e modelos que definem linguagens para manipulação de modelos.
Além disso, a Figura 11 contém também setas que simbolizam uma transformação dos modelos (retângulos) para outros modelos.
Para que o projetista de aplicação possa aplicar transformações no modelo de sistema é necessário que o projetista de transformações disponibilize transformadores na FOMDA Toolkit.
Ele faz isso contando com as quatro etapas de organização e transformação de modelos definidos por a abordagem FOMDA.
Um transformador de manipulação direta de modelos é um algoritmo que contém código para manipulação de modelos e possibilita organizar transformações de baixo nível.
Um algoritmo, tipicamente, efetua varreduras num modelo do sistema em busca de um determinado elemento.
Quando o algoritmo encontra o elemento pesquisado, ele aplica uma transformação do tipo M2C ou M2M no modelo do sistema.
Em a abordagem FOMDA, esse algoritmo é denominado transformador e é especificado por o projetista de transformações.
Para escrever o código dos transformadores, a MDA recomenda o uso de linguagens de transformação de modelos.
Estas linguagens são identificadas na Figura 10 por o modelo denominado &quot;Linguagens p/ Transformação de Modelos».
Para utilizar estas linguagens na abordagem FOMDA, é necessário o desenvolvimento de interpretadores/ parsers.
Estes últimos devem converter uma sentença especificada numa linguagem para uma sentença utilizada por a FOMDA Toolkit.
Em a Seção 8.1 é descrito como é possível escrever transformadores e interpretadores de linguagens para a FOMDA Toolkit».
Modelos &quot;e chega até o modelo «Transformações M2M».
Uma transformação M2M é realizada por algoritmos de transformação.
O PDM, descrito na Seção 4.5, é um Modelo de Features que documenta as características não funcionais de um domínio de aplicações e as regras para composição entre elas.
O PDM oferece, portanto, uma visão das características de plataformas disponíveis para programar um sistema e é usado na FOMDA Toolkit para documentar as plataformas.
O modelo identificado como &quot;Instância do PDM «é um Modelo de Features que contém as características não funcionais selecionadas por o projetista de uma aplicação.
O projetista de aplicação utiliza as configurações (PDM+ transformadores localizados em &quot;Transformações M2M&quot;), definidas por o projetista de transformações, para aplicar uma transformação num modelo do sistema (Pim).
Para tanto, o projetista de aplicação precisa:
1 a instância do PDM, o Pim e uma transformação As configurações do projetista de transformações definem uma receita que organiza e documenta o processo de transformações de modelos que o projetista de aplicações deve seguir.
Essa ordem precisa organizar as características do FM (instâncias do PDM), os elementos do Pim e as transformações.
Em esse ponto, o projetista de aplicações conta com o auxílio de um workflow, que documenta esta combinação.
Para organizar os modelos intermediários entre um Pim e um PSM, o projetista de transformações especifica e configura um workflow.
Este último é denominado como FOMDA workflow.
Ele é utilizado para fazer a combinação entre as características selecionadas no PDM, os elementos do Pim e as transformações.
Cada combinação de modelos (também chamada de sincronização de modelos) e de transformações precisa ser documentada no workflow.
O final do workflow é identificado por a geração dos artefatos do sistema.
O projetista de transformações pode especificar as entradas e saídas de cada transformação no workflow.
Ele pode indicar os estereótipos, tagged values e restrições que os modelos transformados por uma combinação (instancia do PDM, modelo do sistema (na visão Pim) e transformação M2M) recebem após uma transformação.
Além disso, é possível especificar ainda quais são as restrições que os elementos de um modelo precisam conter para serem manipulados por as transformações.
Assim, o workflow oferece ao projetista de aplicação uma receita para transformar Pims em PSMs e pode documentar exatamente o que ele deve fazer num MDD.
Os modelos da Figura 10 oferecem ao projetista de transformações a possibilidade de organizar a FOMDA Toolkit.
A organização das plataformas (PDM), organização de transformações e o mapeamento de transformações para arquiteturas definem ao projetista de uma aplicação o que deve ser feito por ele na FOMDA Toolkit para transformar um Pim em código para a aplicação.
Então os mapeamentos de modelos para transformações devem ser realizados por o projetista de aplicação, seguindo a configuração definida por o projetista de transformações.
As quatro etapas definidas na abordagem FOMDA são brevemente descritas na Figura existem trabalhos muito bons que suprem essa necessidade.
Logo, essa abordagem busca solucionar a transformação de um Pim para PSMs e também de PSMs para código.
Para tanto, as quatro etapas são direcionadas para o projetista de transformação que precisa configurar os mapeamentos e transformações de modelos identificados na Figura 11.
A abordagem FOMDA separa a especificação da organização das transformações em quatro etapas.
A Figura 13 apresenta as quatro etapas definidas na abordagem FOMDA, identificando recursos visuais que são disponibilizados na FOMDA.
Essa figura apresenta as configurações necessárias para aplicar transformações num MDD que compõem a terceira e a quarta etapas.
A segunda etapa compartilha o Modelo de Features com a primeira etapa de transformação de modelos, além de disponibilizar um workflow para documentar o processo de mapeamento e transformação de modelos de acordo com as características selecionadas no FM.
As etapas primeira e segunda são caracterizadas como transformações de alto nível, por não efetuarem manipulações diretas em modelos de sistemas, enquanto que a terceira e quarta etapas são caracterizadas como de baixo nível, por possibilitarem a manipulação direta dos elementos do modelo de um sistema.
A primeira etapa de organização de transformações é utilizada para representar as transformações em alto nível.
Em este nível de transformação, o projetista configura as plataformas alvo.
Isto é realizado da seguinte maneira:
As características do FM, usadas para transformação, são especificadas;
Em seguida, a ordem com que as características do FM efetuam transformações precisa ser descrita;
Por fim, os mapeamentos de um modelo fonte2 para uma característica do FM são documentados.
Isto implica em definir atividades, num Diagrama de Atividades, para representar transformações M2M de acordo com a instância do A segunda etapa de configuração de transformações é relacionada diretamente com uma característica.
Esta precisa ser configurada por o projetista de transformações.
As características do FM (definidas no PDM), que são utilizadas em transformação, são análogas às plataformas alvo na MDA, considerando que somente características não funcionais são definidas neste modelo.
Portanto, as intenções na abordagem FOMDA são as de utilizar FMs para a definição de PDMs e de possibilitar a definição de soluções genéricas para aplicar transformações.
Para que um PDM seja usado como uma solução genérica, é preciso oferecer aos projetistas de aplicações a flexibilidade para aplicar mais do que uma transformação em cada característica.
A solução para isso é, além de organizar as características do PDM com a intenção de aplicar transformações, organizar também as transformações que são realizadas individualmente por as características.
Para isso, é preciso trabalhar com transformações internas às características, que é realizada na abordagem provendo transformadores às características do MF.
Transformadores podem receber elementos de um modelo fonte e então aplicar transformações M2M ou M2C.
As transformações no modelo de um sistema ocorrem, realmente, nos transformadores.
Modelo fonte é um modelo do sistema que é recebido como entrada por um transformador.
Um transformador pode ser utilizado como interpretador de linguagens para transformação de modelos.
Em este caso, ele é qualificado como um interpretador ou parser, porque recebe como parâmetro um código que especifica uma transformação e não um modelo fonte.
Transformadores podem ser compostos para aplicar uma transformação mais específica ou acrescentar funcionalidades adicionais numa transformação.
Esta é a terceira etapa de transformação, em que o projetista de transformações está preocupado em organizar as transformações de manipulação direta de modelos e também compor- las para especificar novas transformações, reutilizando as já existentes.
Finalmente, é necessário especificar o algoritmo para aplicar uma transformação.
Este algoritmo é o transformador por si próprio e precisa ser escrito por o projetista de transformações na então denominada quarta etapa de organização de transformação (o baixo nível que possibilita a manipulação direta de modelos).
Este algoritmo pode ser especificado em linguagens para transformação de modelos, como RDL.
No entanto, no protótipo FOMDA Toolkit, somente é possível especificar transformadores com a linguagem de programação Java, sendo necessário o desenvolvimento de interpretadores.
Os transformadores da FOMDA são baseados na categoria de Transformação de Manipulação Direta de modelos (TMD), definida por Czarnecki e Simon (2003).
Para escrever transformadores desta categoria, o projetista de transformações precisa criar uma classe que herde de uma classe dedicada em aplicar transformações em modelos.
Esta classe é disponibilizada em abordagens para MDA com foco em transformações TMD e é denominada como um transformador.
Tipicamente, esta classe é abstrata e define uma operação abstrata.
Esta operação deve ser sobrescrita nas classes derivadas e deve especificar o algoritmo de transformação de manipulação direta de modelos.
Exemplos de ferramentas que disponibilizam classes abstratas para transformação de modelos são Jamda e UMT.
Os transformadores da FOMDA apresentam suaves modificações em relação a outras abordagens para TMD.
A primeira diferença é que os transformadores da FOMDA podem receber parâmetros, referenciados como parâmetros de transformação.
Isto elimina a necessidade de efetuar uma pesquisa interna no modelo do sistema, em busca de um determinado elemento.
A segunda diferença é que os transformadores podem compartilhar variáveis com outros transformadores, em tempo de execução.
Por fim, a última diferença é relacionada com o FM.
É possível determinar que um transformador seja executado, somente se determinada característica do FM for selecionada.
A Figura 14 apresenta parte do meta-modelo da FOMDA.
Esta figura especifica os meta-dados que são usados para aplicar transformações da categoria TMD em modelos de entrada.
O meta-dado denominado Transformer é uma interface e possui somente operações.
Este meta-dado disponibiliza operações para especificar transformações que são:
Execute e doTransformation.
Toda a classe que realiza a interface Transformer é um transformador na abordagem FOMDA.
A operação execute da interface Transformer é implementada por a classe abstrata AbstractTransformer.
Tal operação não pode ser sobrescrita por as classes filhas porque ela mantém a consistência na composição de transformações (assunto discutido na Seção 7.4.2).
Sempre que um transformador for executado na abordagem FOMDA, a operação execute será invocada.
Em a classe AbstractTransformer, no final da implementação da operação execute, uma chamada para a operação abstrata doTransformation é feita.
Isto implica na execução da operação doTransformation de uma classe derivada de AbstractTransformer.
A operação doTransformation precisa ser reimplementada em qualquer classe concreta que herde da classe abstrata AbstractTransformer.
Os transformadores somente precisam implementar o algoritmo de transformação na operação doTransformation.
O projetista de transformações, na abordagem FOMDA, define uma transformação numa classe que herda da classe AbstractTransformer e a implementa na operação doTransformation.
Todo o transformador tem associado a si um descritor de transformação.
Em a terceira etapa de organização de transformações é possível combinar muitos transformadores, para que estes especifiquem novas transformações.
Para tornar isto possível é necessário configurar cada transformador num descritor de transformação.
Em a Figura 14, é possível visualizar as informações contidas num descritor de transformação.
Este é o meta-dado TransformationDescriptor, em que os seguintes atributos são importantes:
Observer ­ identifica qual é a característica do FM que contém o transformador descrito por o descritor de transformação;
Name ­ o nome do transformador;
ClassName ­ identifica o nome da classe do transformador associado;
Result ­ armazena um objeto que é o resultado da execução do transformador associado;
ReturnType ­ identifica o tipo do objeto resultante da execução do transformador associado.
Transformadores podem conter parâmetros de transformação.
Cada parâmetro de um transformador pode armazenar um elemento do modelo do sistema.
Este elemento é adicionado ao parâmetro em tempo de execução de uma transformação, por o projetista de aplicação.
Esses parâmetros podem ser utilizados no algoritmo de um transformador.
Isto significa que estes podem ser utilizados numa transformação, como, por exemplo:
Um transformador` X'tem um parâmetro de transformação` P 1'.
Este parâmetro pode armazenar um elemento do tipo mof.
Core. Class, ou seja, um elemento tipo classe pode ser inserido no parâmetro` P1 minute do transformador `X'.
Então, em tempo de execução, o projetista de aplicação adiciona no parâmetro` P1 minute uma classe de um modelo de sistema e executa o transformador` X'.
Em o algoritmo de transformação do transformador` X', o valor contido no parâmetro` P1 minute pode ser recuperado e utilizado por o algoritmo deste transformador.
Um exemplo de um transformador pode ser observado na Figura 15.
Esta figura apresenta a classe denominada AddClassTransformer.
Esta última é um transformador, porque herda da classe abstrata AbstractTransformer.
Esta herança determina que a classe AddClassTransformer precisa implementar a operação doTransformation.
O construtor da classe AddClassTransformer recebe como parâmetro um objeto do tipo TransformationDescriptor e, dessa maneira, pode usar- lo para buscar informações a respeito de a transformação.
Um objeto do tipo TransformationDescriptor descreve a transformação e oferece recursos úteis para o desenvolvimento do algoritmo do transformador.
Estes recursos podem ser:
Objetos de interface gráfica, que podem ser utilizados para reportar uma mensagem ao projetista de aplicação no FOMDA Toolkit;
A característica de um Modelo de Features que contém o transformador (transformadores são mapeados para características do FM);
A implementação da operação doTransformation, mostrada na Figura 15, contém o algoritmo de transformação do transformador AddClassTransformer.
O algoritmo é escrito para adicionar uma nova classe num modelo do sistema.
Este modelo é recebido como parâmetro (denominado &quot;model&quot;) por o transformador em questão.
A linha 8 exemplifica como o projetista da transformação pode recuperar um parâmetro de transformação.
A classe AbstractTransformer contém um atributo chamado observer.
Este atributo contém o descritor de transformação e pode ser utilizado para recuperar os parâmetros de transformação num transformador.
Isto é feito invocando a operação getParameter do parâmetro é o nome do parâmetro de transformação, que foi cadastrado no descritor de um transformador (isto é explicado na Seção 4.4.2).
O retorno da operação getParameter é um parâmetro de um transformador, que, no meta-modelo da FOMDA, é uma instância do metadado TransformationParameter.
A classe TransformationDescriptor, apresentada na Figura 14, é o meta-dado que representa um descritor de transformação no meta-modelo da FOMDA.
Esta classe tem uma associação com a classe AbstractTransformer.
Tal associação pode conter um objeto que é um interpretador/ parser (se houver).
Um interpretador deve ser usado quando um transformador for especificado em linguagens para transformação de modelos.
Transformadores que não são instâncias do meta-dado Transformer precisam que um interpretador (este deve ser uma instância de Transformer) converta o algoritmo do transformador para instruções válidas na FOMDA Toolkit.
As transformações da categoria TMD precisam ser executadas por o projetista de aplicação.
Quando transformando um modelo de sistema os projetistas de aplicações precisam selecionar o transformador e os elementos do modelo do sistema que eles querem transformar, adicionar os elementos selecionados para os parâmetros requeridos por o transformador e requisitar a execução do transformador.
Para o projetista de aplicações, as transformações são utilizadas como foram definidas por o projetista de transformações e, portanto, ele não precisa ter o conhecimento de como construir- las.
Ainda assim, nas transformações de terceiro nível, ele pode adaptar uma transformação, efetuando uma combinação de transformadores.
A linha 9 da Figura 15 exemplifica como recuperar um elemento do modelo do sistema.
Este elemento é, em tempo de execução, adicionado por o projetista de aplicação no parâmetro de nome &quot;model «do transformador AddClassTransformer.
A operação getElement, do parâmetro de transformação denominado tp, retorna um objeto do tipo Object.
Este último deve ser convertido para um tipo específico e definido na linguagem java (ou, no caso de o protótipo FOMDA Toolkit, num tipo de dado do MOF).
A linha 9 mostra a conversão do elemento contido no parâmetro tp para o tipo «mof.
Core. Model».
Para especificar transformações na abordagem FOMDA, é preciso conhecer os metadados do MOF.
Alguns dos meta-dados do MOF são definidos no protótipo FOMDA Toolkit.
Em este protótipo, esses meta-dados são classes e interfaces codificadas em Java e podem ser utilizados nos algoritmos de transformação escritos nos transformadores.
Os elementos do modelo do sistema são instâncias destas classes.
De a linha 11 até a 15 do algoritmo da Figura 15, uma classe é criada e adicionada no modelo do sistema.
Em a linha 11, um objeto (newClass) do tipo «mof.
Core. Class «é instanciado.
Em a linha 12, é especificado o nome dessa classe como &quot;TheNewClass».
Em a linha 13, é especificada a visibilidade pública para o elemento criado.
Em a linha 14, o escopo desse elemento é definido como de instância.
Por fim, na linha 15, a classe criada é definida como abstrata.
As linhas 17 e 19 finalizam o algoritmo da operação doTransformation.
A operação addElement é definida para qualquer elemento do MOF.
Ela pode ser usada para adicionar elementos num elemento do modelo.
A linha 17 demonstra como adicionar um elemento, que foi criado no algoritmo, num outro elemento do mesmo modelo.
A linha 19 mostra o retorno do objeto denominado model, por a operação doTransformation.
O valor retornado por o transformador pode ser utilizado por outros, no que é chamado de terceira etapa de organização de transformações (apresentada na seção seguinte).
Realizou- se uma análise dos transformadores da categoria TMD, em abordagens como Jamda e UMT.
Esta análise identificou algumas limitações nestes transformadores, como:
1) eles precisam efetuar pesquisas dentro de um modelo para encontrar um determinado elemento e aplicar uma transformação;
2) o algoritmo de transformação é estático;
E 3) não são conhecidas as pré-condições para executar um transformador.
É interessante conhecer o que é necessário para executar um transformador, sem recorrer ao algoritmo de transformação de ele.
Utilizando algoritmos de transformação estáticos, uma vez compilada uma classe que aplica transformações (um transformador), o algoritmo de transformação desta classe não pode ser modificado.
Em a abordagem FOMDA, os transformadores da categoria TMD foram projetados para suprir as limitações de transformadores Jamda e UMT.
Por o momento, os recursos disponibilizados para transformadores TMD na FOMDA são parâmetros de transformação, variáveis compartilhadas, dependência de outros transformadores e cláusulas que testam se determinada característica do MF está selecionada para executar um determinado transformador.
Estes recursos possibilitam a composição de transformações e podem ser utilizados na organização de transformações de terceiro nível.
Em a terceira etapa de organização de transformações, Figura 13 (a), o projetista de transformações tem por objetivo reutilizar transformadores TMD.
Transformadores previamente desenvolvidos podem ser combinados de maneira a compor novas transformações.
Para isto, um editor para composição de transformações é disponibilizado na ferramenta FOMDA Toolkit.
Uma combinação estabelecida entre dois transformadores cria um terceiro transformador.
O algoritmo deste último é resultado das relações que são estabelecidas entre os dois primeiros.
Um exemplo de relação que pode ser estabelecida entre dois transformadores é a dependência.
Esta pode ser a dependência de um parâmetro de um transformador por o retorno de outro.
A combinação/ composição de transformações é explicada nos próximos tópicos dessa seção.
Relações estabelecidas entre diferentes transformadores os agrupam num mesmo conjunto.
Este conjunto representa um novo transformador.
Quando um transformador, que faz parte do conjunto de transformadores TMD, é executado, então os transformadores relacionados com ele são também automaticamente executados.
Isto significa dizer que, ao compor transformações, o projetista de transformações está automatizando parte do processo de transformação de um modelo de sistema.
Em geral, algoritmos para transformações da categoria TMD precisam pesquisar no modelo fonte por algum elemento específico.
A adição de alguns parâmetros em transformadores é usual para eliminar esta necessidade de pesquisa no modelo fonte e também para determinar os elementos que são necessários para uma transformação.
Em a abordagem FOMDA, um parâmetro de transformação é adicionado num transformador através de um descritor de transformação.
O descritor configura um transformador e permite a adição de parâmetros.
Em estes parâmetros, elementos do modelo fonte podem ser adicionados, em tempo de execução da transformação.
Transformadores tomam como entrada alguns elementos do modelo fonte.
Estes elementos podem estar contidos nos parâmetros de transformação.
Um transformador pode processar estes elementos e retornar um resultado.
Parâmetros de transformação configuram pré-requisitos para a execução de um transformador.
No entanto, estes parâmetros devem ser configurados no descritor de transformação.
Por exemplo, é possível especificar que um transformador, para poder efetuar uma transformação, precisa receber como entrada um elemento do modelo do sistema que é uma instância do tipo mof.
Core. Class.
Em a FOMDA, um parâmetro de transformação é uma instância do meta-dado TransformationParameter, que pode ser visto na Figura 16.
A Figura 16 apresenta a classe abstrata ParameterDescriptor.
Ela é usada como um meta-dado do meta-modelo da FOMDA para descrever um parâmetro.
Este meta-dado por o parâmetro;
Element -- é do tipo Object e armazena um objeto que é adicionado no parâmetro, em tempo de execução, e precisa ser do tipo informado no atributo type.
Utiliza- se uma restrição para determinar o tipo de elemento do modelo do sistema que pode ser adicionado no atributo element da classe ParameterDescriptor:
Somente elementos que são instâncias do tipo definido no atributo type da classe ParameterDescriptor.
Esta restrição é definida em OCL na Figura 17.
Para efetuar a composição de transformadores dinamicamente, como tornar possível que um transformador chame a execução de outro, é necessário avaliar a consistência entre os dois transformadores.
Por exemplo, se o transformador Y recebe o resultado do transformador X, então o tipo de retorno do transformador X tem que ser o mesmo tipo armazenado por o atributo type do parâmetro de nome &quot;param1 «do transformador Y. Em o meta-dado TransformationParameter, o atributo type determina o tipo do objeto que pode ser armazenado no atributo element do parâmetro de transformação.
Se no exemplo do parágrafo anterior, o retorno da transformação X for igual ao tipo especificado no atributo type do parâmetro de transformação de nome &quot;param1 «do transformador Y, então o transformador X pode ser adicionado no atributo dependency do parâmetro &quot;param1».
Isto determina uma dependência válida do parâmetro do transformador Y por o resultado do transformador X. Essa restrição é aplicada diretamente no meta-dado TransformationParameter e pode ser expressa utilizando OCL.
No caso de a abordagem FOMDA, atualmente, o atributo dependency do meta-dado TransformationParameter pode conter somente uma de entre duas possíveis instâncias de Object (que é o tipo definido para esse atributo):
Ou a instância é do meta-dado AbstractTransformer ou do meta-dado SharedVariable.
Logo, é preciso controlar o tipo de objeto que instanciado para atributo dependency do meta-dado TransformationParameter.
Essa regra é mostrada na Figura 18.
Em a abordagem FOMDA, transformadores podem compartilhar variáveis.
Estas podem ser utilizadas por diferentes transformadores para aplicar transformações.
Variáveis compartilhadas são instâncias do meta-dado SharedVariable.
Esta é uma classe que herda da classe ParameterDescriptor e, portanto, contém os mesmos atributos que um parâmetro de transformação (com exceção do atributo dependency).
Assim, da mesma forma que os parâmetros de transformação, variáveis compartilhadas por um transformador são configuradas no descritor de transformação deste.
É usual para um transformador delegar alguma transformação particular para outro transformador.
Para permitir que isto ocorra num transformador da categoria TMD, o mesmo precisa compartilhar uma variável com outros transformadores e chamar a execução de eles (invocando- lha operação execute).
Uma variável V1, que é usada por um transformador X, pode ser utilizada também por um transformador Y se, e somente se, o transformador Y tiver um parâmetro param1, em que o objeto armazenado no atributo dependency de param1 for V1, e V1 contenha um objeto no atributo element.
Esta relação determina que param1 depende do elemento contido em V1 (o objeto contido no atributo element de uma instância do meta-dado SharedVariable).
Além disso, para que um parâmetro de transformação dependa de uma variável compartilhada, a última das regras definidas em OCL na Figura 18 precisa ser satisfeita.
Ao contrário de um parâmetro de transformação, que recebe um elemento do modelo fonte do sistema em tempo de execução, um valor é informado para uma variável compartilhada no algoritmo de um transformador.
Este algoritmo precisa recuperar a variável compartilhada para adicionar em ela um elemento do modelo do sistema.
Esta variável é recuperada no algoritmo de transformação por o descritor de transformação.
Em a abordagem FOMDA, é possível configurar alguns transformadores para que estes somente sejam executados se determinadas características do FM estão selecionadas no PDM.
Em este ponto da organização de transformações de terceiro nível, o projetista de transformações ou de aplicação pode adicionar em transformadores cláusulas que testam se uma característica do PDM está selecionada.
Esta é a maneira de determinar transformações que são executadas somente se determinadas características do PDM estão selecionadas.
Se o teste de uma cláusula associada com um transformador for verdadeiro, então este é executado.
A execução automática de transformações é um ponto relevante da abordagem FOMDA, porque somente transformações relacionadas com as características previamente selecionadas no PDM são executadas.
As cláusulas utilizadas para determinar quais transformações podem ser executadas são divididas em três tipos:
Cláusulas lógicas (And, Or e Not);
Cláusulas de decisão (If e Else);
Cláusulas lógicas são usuais para testar a seleção de características de um PDM.
Toda cláusula lógica precisa avaliar a seleção de uma ou mais características do PDM.
Elas precisam conter instâncias do meta-dado FeatureElement, para permitir o teste de seleção de cada característica.
Toda característica de um PDM é uma instância do meta-dado FeatureElement, apresentado em destaque na Figura 19.
Os atributos testedFeature e testedFeatures dos meta-dados And, Or e Not podem armazenar este tipo de instância.
Uma cláusula lógica &quot;And «retorna verdadeiro se todas as características testadas (devem ser no mínimo duas) estão selecionadas no PDM e retorna falso se uma das características testadas não está selecionada.
Uma cláusula lógica &quot;Or «e avalia se duas ou mais características estão selecionadas no PDM.
Uma cláusula &quot;Or «retorna verdadeiro se no mínimo uma das características relacionadas com ela estiver selecionada no PDM, do contrário ela retorna falso.
Uma cláusula lógica &quot;Not «(representada por uma instância do meta-dado Not) nega a seleção de uma característica testada, ou seja, retorna verdadeiro se a característica não está selecionada no PDM e falso se ela estiver.
Cláusulas de decisão são instâncias do meta-dado DecisionClause.
Toda cláusula de decisão contém uma ou mais instâncias do meta-dado FeatureElement e uma instância do meta-dado ThenClause.
Isto significa que as cláusulas de decisão avaliam se uma ou mais características do PDM (que são instâncias de FeatureElement) estão selecionadas.
Caso todas as características avaliadas por uma cláusula de decisão estiverem selecionadas, então uma cláusula &quot;Then «é acionada.
Um descritor de transformação pode ter associado a ele zero ou mais cláusulas &quot;If».
Estas são instâncias do meta-dado If.
Cláusulas &quot;If «são cláusulas de decisão e podem conter zero ou mais cláusulas lógicas e zero ou mais cláusulas &quot;Else».
Cláusulas &quot;Else «são instâncias do meta-dado Else.
Estas cláusulas são testadas apenas se o retorno de uma cláusula &quot;If «(relacionada com a cláusula &quot;Else «ou com uma cláusula &quot;Else «antecessora) retornar falso.
Cada cláusula &quot;Else», subseqüente de uma cláusula &quot;If», somente é testada se a cláusula &quot;Else «antecessora não retornar verdadeiro.
Cada cláusula de decisão precisa ter associada a ela uma cláusula &quot;Then».
Cláusulas &quot;Then «são instâncias do meta-dado ThenClause e são usadas para determinar a execução de algum transformador, identificado por a associação entre os meta-dados ThenClause e o TransformationDescriptor.
Então, cláusulas &quot;If «e &quot;Else «podem, se suas condições de teste retornarem verdadeiro, chamar a operação execute de uma cláusula &quot;Then», para executar o transformador associado com a mesma.
Uma cláusula &quot;Then «contém um descritor de transformação associado.
Quando esta cláusula é acionada, isto implica na invocação da operação execute do descritor de transformação associado a ela.
Os recursos comentados na Seção 7.2 possibilitam a composição de transformações dinamicamente.
No entanto, tais recursos são limitados e não possibilitam especificar composições mais complexas.
Em este sentido, este tópico apresenta alguns recursos que são desejáveis para a composição de transformações que não foram devidamente especificados neste trabalho.
Além disso, são apresentadas possíveis soluções para adicionar esses recursos na organização de transformações de terceiro nível.
O uso de cláusulas por transformadores determina a execução de outros transformadores apenas se algumas características do PDM estão selecionadas no modelo.
Podem ser utilizadas mais de uma cláusula num mesmo transformador.
Isto significa que é possível executar mais de um transformador.
Muitas vezes é interessante ordenar a execução das transformações relacionadas às cláusulas.
No entanto, não é possível especificar ordem para a execução de transformadores relacionados com cláusulas, na organização de transformações de terceiro nível.
Um recurso que pode estar embutido em transformadores TMD é permitir que determinados trechos de um algoritmo de um transformador sejam especializados por outros transformadores.
É desejável que, em determinadas linhas de um algoritmo de transformação, seja possível delegar uma transformação para outro transformador.
Isto é possível de ser feito em transformadores TMD na abordagem FOMDA, porém de maneira estática, o que significa dizer que isto é realizado no código do transformador.
É interessante determinar qual é o transformador que é executado, numa determinada linha de um algoritmo de transformação de um outro transformador, dinamicamente.
No entanto, isto não é possível de ser realizado com os recursos oferecidos em organização de transformações de terceiro nível.
Uma possível solução é definir pontos de especialização dentro de o algoritmo de transformação de um transformador.
Pontos de especialização são linhas ou trechos de um algoritmo de transformação, que podem ser executadas por outros transformadores.
Transformadores podem ser adicionados nestes pontos dinamicamente.
A operação execute destes transformadores pode ser invocada quando o ponto de especialização for alcançado na execução do algoritmo de transformação.
Para tanto, é necessário definir nos pontos de especialização, as interfaces que os transformadores que especializam cada ponto do algoritmo precisam implementar.
Um estudo mais aprimorado e detalhado precisa ser realizado para adicionar estes recursos em transformações de terceiro nível.
Em a MDA, a identificação das plataformas alvo, utilizadas para desenvolver um determinado sistema, é uma tarefa importante.
As plataformas alvo identificam características que um PSM deve conter.
Portanto, estas plataformas podem determinar transformações que são aplicadas num Pim até que ele contenha detalhes que o colocam numa visão PSM.
Willink e Boas introduziram na MDA uma quarta visão (apresentada na Seção 4.5), denominada PDM, em que é possível especificar plataformas alvo de um domínio de sistemas.
A abordagem FOMDA utiliza as características especificadas por os projetistas de transformações no PDM, para auxiliar o projetista de aplicações na transformação de um Pim para um PSM.
A especificação do PDM é categorizada como a primeira etapa de organização de transformação na abordagem em questão.
A visão PDM pode ser utilizada por o projetista de transformações para especificar os requisitos disponíveis para o desenvolvimento de softwares de uma família de sistemas.
Em esta visão, é possível especificar requisitos de um domínio relacionados com características de arquiteturas, serviços, tecnologias, hardware, etc..
Abordagens centradas em GP, em especial as que utilizam ED e PLA, auxiliam o projetista de transformações a identificar características de um domínio de sistemas e, portanto, podem auxiliar na especificação do PDM.
Abordagens centradas em GP utilizam o Modelo de Features (FM) para identificar características de sistemas.
Logo, o FM é o diagrama mais adequado para modelar plataformas alvo, utilizadas no desenvolvimento de software, e pode ser utilizado para especificar a visão PDM da MDA.
Por definição, o PDM é análogo a um Modelo de Features, que contém características de plataformas.
Para especificar o PDM, a abordagem FOMDA utiliza o Modelo de Features por os seguintes motivos:
Ele é bem aceito por os engenheiros de software em abordagens para PLA;
Possibilita que características de plataformas sejam identificadas no diagrama;
E oferece sintaxe para a seleção das características do modelo.
Esta seleção pode determinar a configuração das características de plataformas alvo para desenvolver uma aplicação.
As características de um PDM, que são selecionadas no processo de instanciação (explicado na Seção 3.3.4), configuram um produto.
Ou seja, elas determinam aquilo que deve fazer parte de uma aplicação.
Tipicamente, numa visão PDM onde é utilizado o FM para especificação dos requisitos de sistemas, somente características não funcionais (como as que descrevem plataformas alvo) são especificadas.
Então, as características que são selecionadas no PDM configuram os recursos das plataformas alvo que devem ser utilizados no desenvolvimento de um sistema.
A abordagem FOMDA utiliza o FM na visão PDM, porque este permite a configuração semi-automatizada das características das plataformas alvo (desde que exista uma ferramenta que o interprete, como a FOMDA Toolkit).
A instância do PDM determina a transição da primeira para a segunda na abordagem FOMDA.
Em a abordagem FOMDA, características do Modelo de Features (na visão PDM) podem ser mapeadas para transformações.
Qualquer característica selecionada no PDM pode aplicar uma transformação num modelo fonte, gerando um novo modelo ou código.
Portanto, uma característica é um compilador de modelos, que contém transformações.
Estas últimas são identificadas na Figura 20 por T1, T2 e T3.
Uma instância do PDM (Modelo de Features com características selecionadas) determina um conjunto de características que configuram uma plataforma alvo.
A configuração formada por este conjunto determina as características que devem ser utilizadas para desenvolver uma aplicação.
Logo, as características selecionadas podem ser utilizadas para organizar transformações em alto nível porque documentam com exatidão as arquiteturas/ plataformas às quais o modelo de um sistema deve ser transformado.
Portanto, o projetista de um sistema pode se beneficiar do PDM para transformar o seu modelo de uma visão idependente de plataforma (Pim) numa visão dependente de plataforma (PSM).
A Figura 20 apresenta um exemplo, em que as características &quot;Característica «A», &quot;Característica B «e &quot;Característica C «compõem uma plataforma alvo.
Essa figura demonstra que é possível utilizar o PDM para auxiliar em transformações de modelos.
A mesma figura apresenta uma entrada de um modelo na visão Pim para &quot;máquina «representada por um retângulo contendo a visão PDM (um FM).
Esta máquina transforma o modelo de um sistema na visão Pim para outro na visão PSM.
Esta transformação é realizada por as três características selecionadas no PDM, pois cada uma destas contém um transformador.
Em o exemplo da Figura 20, a &quot;Característica A «contém o transformador T1.
Tanto o Pim quanto o PDM podem representar requisitos de qualquer domínio de aplicações, desde que o Pim utilize algumas características definidas no PDM (que é especificado para um domínio particular).
Portanto, o PDM deve conter um conjunto genérico de características, que pode ser aplicado para o desenvolvimento de qualquer aplicação pertencente ao domínio que ele representa.
Este modelo recebe como entrada um Pim qualquer e o transforma num PSM, que contém as características selecionadas no FM.
As características &quot;Característica «A», &quot;Característica B «e &quot;Característica C «destacadas na Figura 20 são utilizadas para transformar um modelo de entrada (Pim) num modelo refinado (PSM).
Tais características estão &quot;mapeadas «para as transformações T1, T2 e T3, então o modelo resultante das transformações (PSM) é o modelo de entrada (Pim) somado às transformações T1, T2 e T3.
O mapeamento de uma transformação para uma característica do FM ocorre por a adição de transformadores à característica.
O projetista de transformações desenvolve transformadores no terceiro e quarto níveis de organização de transformações da abordagem FOMDA.
Estes transformadores são organizados dentro de características do FM.
Portanto, o FM configura um conjunto de transformações que visam gerar modelos intermediários entre um Pim e um PSM ou o próprio PSM.
O FM pode ser utilizado para aplicar transformações no modelo fonte de um sistema.
No entanto, ele não especifica a ordem em que as transformações são aplicadas no modelo fonte.
Por exemplo, na Figura 20, não é possível saber qual é a ordem em que as transformações são aplicadas no Pim:
Se primeiro T1 depois T2 e por fim T3 ou se primeiro T1 depois T3 e por fim T2.
A ordenação das transformações é interessante, porque, por exemplo, T3 pode precisar de um modelo mais refinado que o Pim (que contenha alguns estereótipos) e T2 pode gerar o modelo mais refinado que T3 precisa receber como entrada.
Em este caso, não há sentido em aplicar a transformação T3 no modelo do sistema antes de T2.
Então, a solução para este caso é especificar a ordem para a geração do PSM, como, por exemplo, PSM $= Pim+ T1+ T2+ T3.
A abordagem FOMDA utiliza o primeiro nível de transformação para documentar esta ordenação.
Em a abordagem FOMDA, o Modelo de Descrição de Plataformas (PDM) é um Modelo de Features.
O objetivo do projetista de transformações ao especificar o PDM é identificar características não funcionais que podem ser utilizadas para desenvolver sistemas numa organização.
Características que ele pode especificar nesta visão são relacionadas com arquiteturas de desenvolvimento, padrões de projeto, serviços de software, tecnologias de desenvolvimento, hardware, restrições temporais, etc..
O objetivo do projetista de transformações, na primeira etapa de organização de transformações da FOMDA, é determinar um domínio tecnológico e arquitetural, que o projetista de aplicações pode utilizar para desenvolver qualquer aplicação deste domínio.
A primeira etapa de organização de transformações é baseada na abordagem de Tekinerdogan et A Figura 21 apresenta um exemplo de PDM, em o qual características não funcionais, utilizadas para desenvolver aplicações numa organização qualquer, foram especificadas.
Este é um exemplo simples e especifica que:
O uso de padrões de projeto (design patterns) é opcional, mas caso esteja selecionado no modelo, podem ser utilizados os padrões MVC e Observer;
O desenvolvimento de uma aplicação precisa da escolha de uma linguagem de programação, que deve ser Java ou VB.
Net; Toda a aplicação precisa conter uma interface gráfica de usuário, que deve ser desenvolvida com Swing, JSP ou ASP.
É determinado que, se a linguagem de programação escolhida for Java, então a interface gráfica não pode ser ASP.
De a mesma maneira, se a linguagem escolhida for VB.
Net, a interface gráfica da aplicação não pode ser Swing nem JSP.
Não é possível especificar estas regras graficamente no FM.
Porém, como foi explicado na Seção 2.3.2, composition rules podem ser adicionadas nas características do FM.
Isto pode ser feito nas características Java e VB.
Net, em que as regras para seleção destas características são especificadas textualmente como composition rules.
Em a abordagem FOMDA, a partir de esta seleção, o PDM é utilizado para aplicar transformações num modelo de sistema.
O PDM recebe como entrada um Pim e o transforma num PSM.
Isto é realizado com o auxílio da ferramenta FOMDA Toolkit, de maneira semi-automatizada, ou seja, é necessária a intervenção do projetista de aplicação.
Cada característica selecionada no PDM precisa efetuar uma transformação.
Uma transformação pode adicionar, por exemplo, marcações no modelo de entrada, que podem ser utilizadas por outras transformações para gerar o PSM.
Em este sentido, é importante identificar quais são as transformações que cada característica deve realizar num modelo de sistema.
Transformações são transformadores especificados na terceira e quartas etapas de organização de transformação e podem ser adicionadas nas características do FM.
Isto significa que mapeamentos de transformadores da categoria TMD podem ser utilizados por cada característica do modelo.
Características do FM não possuem relação direta com transformações nas abordagens estudas na literatura.
Logo, o meta-modelo de Features, mostrado na Figura 23, foi estendido para suportar transformadores, como é mostrado na Figura 24.
A Figura 23 apresenta o meta-modelo de Features, especificado com base no Modelo de Features de Czarnecki.
Em a Tabela 2, a coluna &quot;Meta-dado «contém os meta-dados (definidos na Figura 23) que são utilizados para especificar os possíveis relacionamentos que podem ser estabelecidos entre as características do Modelo de Features de Czarnecki.
FOMDAFeatureElement é o meta-dado que especifica uma característica do FM, com extensões para aplicar transformações.
Este meta-dado possui um relacionamento com o meta-dado TransformationDescriptor, que descreve uma transformação.
Uma instância do meta-dado TransformationDescriptor precisa conter uma instância do meta-dado Transformer, que é o transformador da categoria TMD.
Uma característica de um FM pode aplicar mais de uma transformação e, para isto, ela deve disponibilizar mais de um transformador.
Analisando as características em destaque na Figura 22, é possível ter uma noção das características que são utilizadas para transformar um Pim num PSM.
Como discutido anteriormente, para transformar um Pim num PSM, é necessário especificar ordem nas transformações.
Para identificar a ordem das transformações é necessário identificar antes as entradas e saídas de cada característica do FM.
Isto implica em identificar que tipo de elemento uma característica do FM pode adicionar no modelo fonte do sistema (após uma determinada transformação).
Além disso, também é necessário identificar as marcações nos elementos do modelo de sistema.
Estas são utilizadas por uma característica do FM para aplicar transformações.
Portanto, identificar o que uma característica recebe como entrada e o que ela gera como saída é uma tarefa importante.
A abordagem FOMDA resolve isso adicionando às características parâmetros de entrada e de saída.
O meta-dado FeatureParameter pode ser utilizado para documentar parâmetros de entrada e saída de cada característica.
Ele é um tipo de ParameterDescriptor e, portanto, contém um nome e descreve o tipo de objeto que pode ser armazenado no atributo element.
Além disso, um parâmetro de uma característica pode conter marcações, que são estereótipos restrições ou tagged values.
Estas marcações servem para documentar, de maneira detalhada, os elementos de modelos que podem ser recebidos ou gerados por uma característica.
Como cada característica pode conter muitos transformadores e os transformadores podem receber parâmetros distintos, as características também o podem.
Além disso, é possível especificar mais de uma saída para uma característica, visto que transformadores podem efetuar transformações diferentes e, portanto, gerar modelos diferentes como resultado.
A adição de parâmetros de entrada e saída às características do FM é um ponto positivo na abordagem FOMDA, porque documenta em alto nível as entradas e saídas das transformações.
Transformações de nível intermediário, como consecutivas transformações Pim-paraPSM, requerem um plano de transformação.
Este plano precisa documentar as transformações aplicadas entre um modelo fonte e um modelo alvo, além de a ordem em que elas são executadas no contexto geral das transformações.
Como a FOMDA é uma abordagem para organização de transformações, em que quatro etapas de transformações podem ser utilizadas para transformar um Pim num PSM, o projetista de transformações pode fazer este plano de acordo com cada etapa de transformação.
Quando modelando o plano de transformações em alto nível, o projetista de transformações especifica as entradas e saídas das plataformas, os mapeamentos do modelo fonte para as mesmas e a ordem com que estas últimas são usadas para aplicar transformações no modelo fonte.
Quando projetando o plano de transformações de baixo nível, é mais relevante o mapeamento de elementos do modelo fonte para os parâmetros de transformação, transformadores, etc..
Para desenvolver sistemas que são dirigidos por modelos, usando a MDA, uma apresentação gráfica da ordem das transformações e dos mapeamentos entre plataformas é necessária.
Tal apresentação pode guiar o projetista de aplicações na especificação das consecutivas transformações M2M, necessárias para transformar um Pim num PSM.
O Modelo de Features é utilizado para efetuar esta transformação.
No entanto, este modelo não oferece maneiras para especificar a ordem com que suas características são utilizadas para transformar um Pim num PSM, nem para especificar mapeamentos de modelos fonte de um sistema entre plataformas alvo.
Para resolver esta carência do FM, a abordagem FOMDA propõe o uso de workflows.
A definição de workflow que consta na organização Workflow Management Coalition determina que um workflow é a automação de um processo de negócio ou a facilitação deste processo, de maneira total ou parcial, realizada por um sistema de software.
Para a abordagem FOMDA, o uso de workflows define um mecanismo semi-automático para aplicar mapeamentos de transformações para modelos de um sistema.
A ferramenta FOMDA Toolkit pode utilizar estes workflows para guiar os projetistas de aplicações na transformação de um Pim num PSM e no mapeamento de um modelo fonte para uma plataforma alvo.
Em a abordagem FOMDA, o workflow representa o primeiro nível de organização de transformações.
Ele é definido como FOMDA Workflow, porque os elementos em ele definidos precisam representar instâncias dos meta-dados do meta-modelo FOMDA.
Em este workflow, as características selecionadas no FM são transformações de alto nível, especificadas como atividades.
As atividades são organizadas por transições, que indicam o mapeamento de um modelo fonte para uma determinada plataforma (característica selecionada no FM).
Em o FOMDA Workflow, as transições podem conter guardas.
Estas podem especificar o tipo de modelo esperado como resultado de uma transformação.
Além disso, este workflow pode conter ações, que especificam uma intervenção do projetista de aplicações numa determinada transformação de um modelo.
Por exemplo, uma ação pode indicar ao projetista de aplicações que ele precisa selecionar um elemento do modelo de sistema e adicionar este elemento num parâmetro de um transformador.
Ainda, objetos podem ser utilizados no workflow.
Estes servem para especificar, de entre outros recursos, parâmetros de entrada e saída de transformações.
Para cada combinação de características do PDM (FM), que determinam uma ou mais plataformas alvo, é necessário um workflow que documente as atividades de transformação.
Isto motiva a organização de transformações em camadas (enquanto uma camada de transformação refere- se a cada transformação de uma plataforma alvo).
Cada camada recebe como entrada um modelo em alto nível e aplica alguma transformação, tornando o modelo específico de uma ou mais características (transformação Pim-para-PSM).
O workflow, assim como o PDM e os transformadores, pode ser reutilizado para transformar qualquer modelo que precise da combinação de características do PDM.
A Figura 25 demonstra a organização das características selecionadas no PDM da Figura 22 num workflow.
Em o workflow definido na Figura 25, as características selecionadas no PDM são identificadas por atividades decoradas com o estereótipo &quot;FeatureElement «e representam transformadores de plataformas alvo em alto nível.
O workflow precisa apresentar todas as características selecionadas no PDM, mesmo as que não são utilizadas para aplicar transformações no modelo do sistema.
Como as características são utilizadas para transformar um Pim num PSM e depois o PSM em código, é necessário informar qual de elas recebe o Pim, quais geram o PSM, quais geram código e quais não efetuam transformações no modelo do sistema.
Para isso, podem ser especificados estados de guarda nas transições das atividades de transformação.
O valor dos estados de guarda pode ser informações, que identificam o modelo gerado por as atividades de transformação.
Estados de guarda são utilizados com o propósito de documentação na abordagem FOMDA.
O modelo da Figura 25 pode ser melhor documentado utilizando estados de guarda nas transições das atividades de transformação.
A Figura 26 demonstra o uso de guardas no workflow.
Em a Figura 26, a transição do estado inicial para a atividade App Domain contém a guarda e identifica em qual característica o Pim deve ser transformado primeiro.
Logo, uma transição entre atividades, juntamente com uma guarda, documenta o mapeamento de um modelo do sistema para uma transformação, que é representada por uma das características selecionadas no PDM.
A transição entre a atividade App Domain e Design Patterns contém a guarda.
Esta última recebe este nome porque é usada para indicar que a atividade fonte da transição (App Domain) não efetua nenhuma transformação no modelo recebido como entrada.
No caso de a Figura 26, o Pim é o modelo de entrada para a atividade App Domain e o modelo de saída da mesma é a identidade do Pim, ou seja, ele próprio sem transformações.
A atividade identificada como Design Patterns também não efetua transformações no modelo de entrada e gera como saída o mesmo modelo recebido como entrada.
A atividade identificada como MVC recebe a saída da atividade Design Patterns (o Pim) e gera como saída (identificada por o estado de guarda) o Pim mais alguns elementos que representam o padrão de projeto MVC.
Estes elementos são classes decoradas com os estereótipos &quot;entity», &quot;boundary «e &quot;control».
A transformação realizada em MVC é caracterizada como de nível intermediário entre um Pim e um PSM.
O PSM é gerado depois que a atividade Swing for alcançada no workflow.
Entretanto, esta atividade precisa do modelo gerado na atividade MVC para realizar sua transformação.
A transformação na atividade Swing pode, por exemplo, fazer com que todas as classes que estejam decoradas com o estereótipo &quot;boundary «(que representa uma classe de interface gráfica no padrão MVC) herdem de JPane, que é uma classe definida para interface gráfica de Swing da linguagem de programação Java.
Esta é uma prática definida como modelagem intencional, em que os modelos do sistema são especificados para gerar código para uma plataforma alvo.
A atividade &quot;Java «aplica uma transformação no PSM e gera código Java a partir de ele.
A atividade Swing precisa de um modelo como entrada que contenha o estereótipo &quot;boundary».
Esta informação não foi especificada no workflow apresentado na Figura 26 e, com o objetivo de documentar melhor as entradas e saídas das transformações de alto nível, objetos são definidos para identificar as entradas e saídas para as atividades de transformação, como mostrado na Figura 27.
Estes objetos são instâncias do meta-dado FeatureParameter do meta-modelo FOMDA e são identificados por o estereótipo &quot;FeatureParameter».
Além disso, estes objetos podem conter tagged values, que documentam o que o parâmetro precisa conter, seja ele de entrada ou saída de uma característica.
Parâmetros de entrada para uma característica são identificados por uma transição que contém o estereótipo &quot;FeatureInput».
Tal transição precisa ter como destino uma atividade decorada com o estereótipo &quot;FeatureElement «e como fonte um objeto decorado com o estereótipo &quot;FeatureParameter».
Parâmetros de saída de uma característica documentam os possíveis modelos resultantes de transformações da mesma.
Parâmetros de saída são identificados por transições decoradas com o estereótipo &quot;FeatureOutput».
Estas transições precisam ter como destino um objeto decorado com o estereótipo &quot;FeatureParameter «e como fonte uma atividade decorada com o estereótipo &quot;FeatureElement».
O uso dos objetos e estereótipos identificados na Figura 27 é adequado para documentar o que cada característica do PDM precisa receber como entrada e gerar como saída.
Em este sentido, torna- se mais simples o mapeamento de um modelo (gerado por uma transformação numa atividade) para outra atividade de transformação.
Estereótipos aplicados em transições identificam o estado de um modelo.
O estereótipo &quot;SourceModel «pode ser utilizado em transições e identifica que o estado de um modelo é de um modelo fonte.
Transições decoradas com o estereótipo &quot;TargetModel «indicam que um modelo está no estado de modelo alvo.
Isto determina que é possível efetuar, em modelos que se encontram neste estado, uma transformação M2C, que gera código para uma aplicação.
Portanto, no exemplo da Figura 27, a transição da atividade de transformação Swing para ProgrLang identifica, além de o modelo (estado de guarda especificado na transição) que é trafegado de uma transformação para outra, um modelo pronto para geração de código.
Transições decoradas com o estereótipo &quot;IntermediateModel «identificam modelos em nível intermediário entre um Pim e um PSM.
Isto significa que o modelo trafegado por transições decoradas com este estereótipo está num estado independente de plataforma, porém mais refinado do que o que está num estado de modelo fonte.
Transições decoradas com o estereótipo &quot;SourceCode «identificam que o estado de um modelo é o de código fonte para uma aplicação.
Em o exemplo da Figura 27, a transição da atividade de transformação Java para o estado final do workflow indica que o estado do modelo trafegado é de código fonte.
Tal transição contém o estado de guarda, que indica o tipo de código gerado na atividade de transformação Java.
O workflow especificado na Figura 27 documenta as transformações em alto nível.
O objetivo principal deste workflow é guiar o projetista de aplicações no mapeamento de um modelo fonte de um sistema para atividades de transformação, enquanto o modelo alvo não for alcançado.
Isto é possível, porque foram configurados no workflow os tipos dos parâmetros de entrada e de saída das atividades de transformação e a ordem com que elas são usadas por o projetista de aplicações, para aplicar transformações.
O workflow oferece visões de transformações de alto nível, que recebem como entrada modelos fonte e geram modelos alvo.
A transformação é aplicada internamente nas características do PDM (representadas como atividades decoradas com &quot;FeatureElement&quot;), por o terceiro e quarto nível de organização de transformações.
Para a abordagem FOMDA, atividades com o estado de sub-atividade contêm outro Diagrama de Atividades, que documenta as transformações internas das características.
Cada workflow (representado como uma atividade num outro workflow) representa uma organização detalhada da transformação efetuada por a atividade de transformação.
Isto quer dizer que atividades que contêm um estado de sub-atividade precisam documentar mapeamentos e transformações que são realizadas internamente em elas.
A Figura 28 apresenta um exemplo, em que um workflow organiza as transformações internas da atividade de transformação denominada MVC.
Workflows de alto nível identificam atividades de transformação.
As atividades que contêm um estado de sub-atividade contêm transformações internas.
As transformações internas de uma atividade de transformação são especificadas num outro workflow, denominado de workflow de baixo nível.
Workflows de baixo nível precisam ter o mesmo nome das atividades que os referenciam no workflow de alto nível.
O workflow denominado MVC é um workflow de baixo nível.
Ele é referenciado por a atividade MVC, definida no workflow de alto nível mostrado na Figura 27.
O primeiro passo para especificar transformações internas de uma atividade de transformação é recuperar os parâmetros de entrada que ela possui.
Como as atividades de um workflow de alto nível contêm parâmetros de entrada e de saída, em workflows de baixo nível estes parâmetros podem ser utilizados.
A adição dos parâmetros de entrada e de saída de uma atividade num workflow de baixo nível pode ser feita automaticamente, se os parâmetros de entrada foram definidos no workflow de transformações alto nível.
Isto significa que os parâmetros de uma atividade de transformação podem ser trazidos para os workflows que identificam sub-estados de atividades.
Como um trabalho futuro, pretende-se adicionar recursos na ferramenta FOMDA Toolkit, para a especificação dos workflows.
O workflow MVC contém ações que identificam tarefas que o sistema, ou o projetista de aplicações, precisa realizar para transformar um modelo fonte num modelo alvo.
Em o exemplo da Figura 28, a ação identificada como select informa que uma seleção de um elemento deve ser realizada no modelo fonte.
Este modelo deve estar contido no parâmetro de entrada da característica denominado model (primeiro objeto do workflow).
Em o mesmo exemplo, a transição da ação select para um objeto decorado com o estereótipo &quot;SourceModelElement «(denominado domain_ class) determina o tipo de elemento que deve ser pesquisado no modelo fonte, que está contido no parâmetro de entrada de MVC (o parâmetro model).
O tipo do objeto domain_ class é mof.
Core. Model e isto implica que elementos deste tipo são pesquisados no parâmetro model.
Os objetivos de informar a seleção de elementos nos parâmetros de entrada são:
Mapear valores corretos para parâmetros de entrada de um transformador e possibilitar que isso ocorra de forma automatizada.
Após a seleção de um elemento em parâmetros de entrada de uma atividade de transformação, é necessário mapear o elemento para parâmetros de transformação de um transformador.
Ações identificadas como mapping definem que o elemento selecionado precisa ser adicionado num parâmetro de um transformador.
Em o exemplo da Figura 28, a ação mapping informa que os elementos selecionados no parâmetro de entrada de uma atividade de transformação (que são do tipo mof.
Core. Class) precisam ser mapeados para os parâmetros de transformação &quot;mInput», &quot;vInput «e &quot;cInput».
Todos estes parâmetros recebem elementos do tipo mof.
Core. Class.
Isto configura um mapeamento possível, porque os tipos dos parâmetros de transformação devem ser os mesmos dos elementos que são mapeados para eles.
O estereótipo &quot;TransformationParameter «deve ser utilizado em objetos e especifica um parâmetro de um transformador.
Transições de objetos decorados com este estereótipo para atividades decoradas com o estereótipo &quot;Transformation Descriptor», devem estar decoradas com o estereótipo &quot;TransformationInput».
Elas indicam que o objeto decorado com o estereótipo &quot;TransformationParameter «representa um parâmetro de entrada do transformador.
Em o workflow MVC, é possível visualizar as atividades Model Transformer, View Transformer e Controller Transformer.
As três podem ser executadas em paralelo.
Isto significa que estas atividades não precisam ser ordenadas, porque as transformações que elas realizam no elemento que está contido em seus parâmetros de transformação são independentes.
Atividades decoradas com estereótipo &quot;TransformationDescriptor «são descritores de transformação e podem documentar uma transformação.
Elas podem conter transições decoradas com &quot;TransformationAlgorithm».
Este estereótipo é usado para documentar qual é o algoritmo de transformação de um transformador.
Em o FOMDA Workflow, transformadores TMD são objetos que são decorados com o estereótipo &quot;Transformer».
Estes objetos precisam definir o nome e o tipo do transformador.
O tipo precisa ser uma classe válida no sistema e, portanto, esta classe deve herdar da classe AbstractTransformer ou implementar a interface Transformer.
Ações identificadas como execute determinam a execução de um transformador.
Em o exemplo da Figura 28, as ações execute determinam a execução dos seguintes transformadores:
ModelTransformer, ViewTransformer e ControllerTransformer.
Os transformadores devem ter concluído sua transformação para gerar o modelo alvo.
Isto é representado no workflow por o estado de união do Diagrama de Atividades.
Em o exemplo da Figura 28, o modelo alvo é obtido no final do workflow, após a execução dos transformadores ModelTransformer, ViewTransformer e Controller-Transformer.
Um protótipo de ferramenta, denominado FOMDA Toolkit, foi desenvolvido para validar a abordagem FOMDA.
Os seguintes recursos são disponibilizados no protótipo:
A especificação e instanciação do PDM (primeira e segunda etapa de organização de transformações);
A especificação de transformadores;
E a composição de transformações (terceira etapa de organização de transformações).
Transformações As seguintes funcionalidades relacionadas com o PDM estão disponíveis no protótipo:
Especificação do PDM (constituída de um Modelo de Features);
Documentação das características do Modelo de Features;
Em cada característica do PDM, podem ser especificadas suas regras de composição.
Existem duas maneiras de especificar regras em características do PDM, na FOMDA Toolkit.
Composition Rules são informações textuais de uma característica e identificam a segunda forma de especificar regras para composição de uma característica no PDM.
A FOMDA Toolkit oferece funcionalidades para que o projetista de transformações especifique as regras textuais para composição de uma característica.
A Figura 29 (c) mostra uma aba denominada Composition Rules, onde tais regras podem ser definidas para uma característica do PDM.
Tomando como exemplo o modelo mostrado na Figura 21, a regra textual &quot;requires MVC «pode ser adicionada na característica Swing e determina que, se Swing for selecionada no modelo, então MVC deve ser selecionada também.
Funcionalidades para documentar as características do PDM foram adicionadas no protótipo FOMDA Toolkit.
Rationales são documentações de uma característica, que podem ser visualizadas graficamente no Diagrama de Features.
Estas especificam detalhes de uma característica, como, por exemplo, os atributos (no sentido literal) que a mesma possui.
Objetivos e decisões também são documentações que podem ser adicionadas numa característica do PDM, mas não são mostradas graficamente no Diagrama de Features.
Estas últimas podem ser especificadas na aba Issues and Decisions.
A ferramenta FOMDA Toolkit também guia o projetista de uma aplicação durante a instanciação do PDM.
Cada característica identificada na Figura 29 (b) contribui para a instanciação do PDM e pode compor uma plataforma alvo.
As relações estabelecidas entre as características do FM determinam a sintaxe para a composição de elas no PDM:
A ferramenta FOMDA Toolkit verifica os tipos de relacionamentos estabelecidos entre as características e, de acordo com cada relacionamento, seleciona automaticamente algumas características.
Sempre que uma característica for selecionada por o projetista de aplicação, a instanciação do PDM é realizada por o protótipo FOMDA Toolkit.
Para isto, este protótipo verifica quais características podem ser selecionadas automaticamente e em quais relacionamentos é necessário que o projetista escolha uma característica no PDM.
A instanciação do PDM ocorre da seguinte forma:
Se uma característica A for selecionada e esta possuir uma relação de obrigatoriedade com uma característica B, em que A é hierarquicamente superior a B, então B é selecionada automaticamente;
Se uma característica C for selecionada e esta for hierarquicamente inferior a uma característica B, e B for inferior a uma característica A, então as características B e A são automaticamente selecionadas (nesta mesma ordem) durante a instanciação do Se uma característica A for selecionada e esta tiver um relacionamento obrigatório de exclusão mútua, que relaciona duas características (B e C), e estas são hierarquicamente inferiores à característica A, então a ferramenta requisita ao projetista de uma aplicação que ele escolha a seleção de B ou de C;&amp;&amp;&amp;
Se uma característica A for selecionada e esta tiver um relacionamento or, que identifica a necessidade de selecionar uma ou mais características relacionadas com A, e este relacionamento contém as características B e C, sendo estas últimas hierarquicamente inferiores à característica A, então a ferramenta requisita a seleção de B e/ ou de C ao projetista de aplicação;
Se uma característica A for selecionada e esta tiver um relacionamento que indica a não obrigatoriedade de outra (s) característica (s) (seja ele um relacionamento opcional de exclusão mútua ou opcional de uma única característica), então a ferramenta não utiliza este relacionamento para efetuar a seleção automática das características relacionadas;
Se uma característica A for selecionada e esta tiver um relacionamento de dependência com uma característica B, sendo que A dependente de B, então a ferramenta seleciona automaticamente a característica B;
Sempre que uma característica A for selecionada e esta for mutuamente exclusiva com uma característica B, por um relacionamento de exclusão mútua, e B já estiver selecionada no modelo, então o presente protótipo oferece ao projetista de aplicação a possibilidade de desmarcar a característica B. Sempre que uma característica A for desmarcada, então todas as características hierarquicamente inferiores a ela, que também estiverem selecionadas, são automaticamente desmarcadas.
Transformações A abordagem FOMDA define que os transformadores devem ser adicionados nas características do PDM.
Transformadores devem ser escritos com a linguagem Java e compilados.
Para poderem ser utilizados no protótipo FOMDA Toolkit, os mesmos devem ser empacotados num arquivo com a extensão.
Jar. Em o momento, arquivos com a extensão.
Jar são anexados ao protótipo em tempo de compilação.
No entanto, futuramente, os mesmos deverão ser anexados ao protótipo em tempo de execução.
Por fim, os transformadores podem ser adicionados às características do PDM, utilizando os recursos definidos na Figura 30.
Os seguintes campos especificam, num descritor de transformação, as seguintes informações:
Name (obrigatório) -- o nome do transformador.
Description (opcional) -- a descrição do que o transformador faz.
Src (opcional) -- caso o transformador seja especificado numa linguagem para transformação de modelos que não seja em Java, o arquivo que contém o algoritmo do transformador pode ser informado no campo identificado como Src.
Em este caso, no campo identificado como ClassName, deve ser especificado o nome da classe que interpreta a linguagem utilizada para especificar o algoritmo do transformador.
Se o campo Src estiver vazio, então o transformador é a classe informada no campo ClassName.
ClassName (obrigatório) -- representa o próprio transformador.
Deve ser especificado o nome completo (a hierarquia de pacotes mais o nome da classe) de uma classe escrita em Java.
Por exemplo: Com. Transformadores.
TransformadorDeModelos, em que Transformador DeModelos é o nome da classe e com. Transformadores é a hierarquia de pacotes desta classe.
Se, ao invés de ser um transformador, a classe representa um interpretador, então a informação deste campo precisa ser classe, que é o interpretador.
Language (opcional) -- a linguagem utilizada para escrever o algoritmo do transformador.
Transformation Description Version (opcional) -- a versão do algoritmo de transformação.
Language Version (opcional) -- a versão da linguagem utilizada para especificar o transformador.
Autor Data (opcional) -- dados a respeito de o autor do transformador.
Parâmetros de Transformação são adicionados em (opcionais):
Parameter Name (obrigatório) -- O nome do parâmetro de transformação;
Parameter Type (obrigatório) -- O tipo do elemento que é armazenado por o parâmetro;
Uma tabela apresenta os parâmetros de transformação adicionados no descritor de transformação.
Variáveis Compartilhadas são adicionadas em (opcionais):
Variable Name (obrigatório) -- O nome da variável compartilhada;
Variable Class (obrigatório) -- O tipo de elemento que pode ser armazenado na variável compartilhada;
Uma tabela apresenta as variáveis compartilhadas adicionadas no descritor de transformação.
Return Type (obrigatório) -- o tipo de retorno do transformador, que deve ser um tipo válido para o protótipo.
Transformações Em a abordagem FOMDA, a organização de transformações na terceira etapa serve para compor transformações e também para executar- las.
A composição de transformações pode ser realizada das seguintes formas:
Adicionando dependências de um parâmetro de um transformador por o resultado/ retorno da execução de outro transformador;
Adicionando dependências de um parâmetro de um transformador por uma variável compartilhada por outro;
Adicionando cláusulas nos transformadores, que executam transformações relacionadas com as cláusulas.
A execução ocorre somente se as características que as cláusulas testam estão selecionadas no PDM.
Além disso, o mapeamento de um elemento de um modelo de sistema para parâmetros de transformadores (disponibilizados numa das características do PDM) e a execução destes por parte de o projetista de aplicação, fazem parte da organização de transformações de terceiro nível.
A ferramenta FOMDA Toolkit oferece recursos para a terceira etapa de organização de transformações.
A Figura 29 (b) destaca no PDM a característica MVC.
Para efetuar as transformações internas em MVC, é necessário selecionar, num pop-up que aparece na tela quando um clique com o botão direito do mouse é feito sobre uma característica do modelo, a opção &quot;Abrir Visão Interna da Característica».
Isto determina a abertura da tela de &quot;visão interna de uma característica do PDM «por o protótipo FOMDA.
O protótipo FOMDA Toolkit não oferece recursos para a definição dos parâmetros de entrada e de saída das características.
No entanto, o mesmo possibilita a abertura de um modelo de sistema e a manipulação dos elementos deste último.
Em a Figura 31 (a) é possível visualizar uma aba denominada «Input 1.
Esta aba apresenta um modelo de um sistema estruturado em árvore.
Input 1 é um parâmetro da característica MVC, que é representado como uma aba na tela de visão interna desta característica.
É possível adicionar mais de um parâmetro nas características do PDM.
Para isto, é necessário abrir no protótipo a tela de visão interna das características.
Para adicionar um parâmetro de entrada em MVC, por exemplo, é necessário selecionar o menu &quot;File «e neste a opção &quot;Abrir Modelo Fonte».
Para adicionar um modelo de um sistema num parâmetro de uma característica, este modelo precisa ser um documento no formato XMI ou XMILight.
Em breve, o protótipo deve ser estendido para a especificação dos parâmetros de entrada e de saída das características do A Figura 31 (b) apresenta os descritores de transformações da característica MVC.
Cada descritor de transformação é representado como um botão na tela, que representa a visão interna da característica que o contém.
Estes botões servem para adicionar no Diagrama de Composição de Transformações DCT) um novo transformador idêntico ao transformador representado por o botão.
Quando o mouse é posicionado sobre estes botões, as informações do nome e a descrição do transformador são mostradas.
Os transformadores podem ser adicionados no DCT, com o objetivo de compor novos transformadores e de utilizar um transformador para executar uma transformação.
A Figura 31 (d) identifica recursos oferecidos para a execução de transformações.
Um parâmetro de um transformador pode ser selecionado no DCT.
Os elementos de um modelo, que estão numa das entradas da característica, podem ser selecionados e arrastados para o Diagrama de Composição e Transformação.
Isto determina a adição deste elemento no parâmetro de transformação selecionado no DCT.
O transformador é executado quando o projetista de aplicação seleciona a opção &quot;execute «no pop-up menu.
O pop-up menu é mostrado quando um clique com o botão direito do mouse é feito sobre um descritor de transformação (este último deve estar representado no DCT).
A Figura 32 apresenta um exemplo de composição de transformações, utilizando o DCT do protótipo.
Este exemplo não tem relação com os exemplos anteriores, porque ele tem o objetivo de mostrar o que pode ser realizado para compor transformações utilizando o protótipo FOMDA Toolkit.
Em este exemplo, o transformador identificado como Schedulable Transformer contém um parâmetro de transformação de nome object e uma variável compartilhada identificada com o mesmo nome.
Além disso, o mesmo transformador contém duas cláusulas &quot;If».
Uma destas cláusulas testa se a característica &quot;RTSJ «está selecionada no PDM e a outra testa se a característica &quot;FemtoAPI «está selecionada no PDM.
A primeira de elas determina a execução do transformador identificado como Schedulable RTSJ Transformer e a segunda determina a execução do Shedulable FemtoAPI Transformer.
Ambos os transformadores dependem do valor contido na variável compartilhada por Schedulable Transformer.
Se o transformador Schedulable Transformer for executado, então a sua variável compartilhada recebe um elemento do modelo do sistema que é adicionado por este transformador.
Em o algoritmo de transformação deste transformador, o elemento que é adicionado em sua variável compartilhada (denominada object) é o mesmo objeto recebido como parâmetro por o transformador.
Para compor transformações, é necessário ter conhecimento do algoritmo do transformador.
A descrição deste algoritmo pode ser informada no descritor de transformação (no campo Description).
Após a execução do transformador Schedulable Transformer, as cláusulas relacionadas a ele são testadas e os transformadores relacionados com cada uma destas cláusulas são executados.
Isto ocorre se, e somente se, as características que estas cláusulas avaliam estiverem selecionadas no PDM.
Como o valor do parâmetro dos transformadores Schedulable RTSJ Transformer e Schedulable FemtoAPI Transformer depende do valor armazenado por a variável compartilhada de Schedulable Transformer, a execução destes transformadores precisa, primeiro, recuperar o valor contido na variável compartilhada de Schedulable Transformer.
Este valor deve ser adicionado no parâmetro de transformação dos transformadores Schedulable RTSJ Transformer e Schedulable FemtoAPI Transformer.
Isto é tratado por a FOMDA Toolkit, que organiza as &quot;pendências «de um transformador antes de executar o seu algoritmo.
Como foi argumentado no desenvolvimento desse trabalho, a organização de transformações de terceiro nível pode auxiliar no reuso de transformadores TMD.
Identificou- se que estes transformadores precisam oferecer outros recursos, além de aqueles já definidos nesse trabalho, para a organização de transformações de terceiro nível.
Assim, como um trabalho futuro, pretende-se adicionar aos transformadores TMD os recursos identificados na Seção 7.2.5.
Em o presente trabalho, um estudo de caso descreveu como transformar um modelo em alto nível (Pim) para um modelo de baixo nível (PSM).
No entanto, não foi exemplificado neste estudo de caso como transformar um CIM num Pim.
Logo, pretende-se, futuramente, estender o estudo de caso apresentado aqui e demonstrar como a FOMDA pode ser usada para transformar um modelo de domínio (CIM), que contenha requisitos de sistemas de cadeira de rodas (apresentados na Seção 3.3.2), num modelo independente de plataforma (Pim).
O presente trabalho apresentou o meta-modelo da FOMDA.
Este último pode ser utilizado como um Perfil da UML, para especificar mapeamentos e transformações de modelos de sistemas.
Como outro trabalho futuro, pretende-se especificar os meta-dados do meta-modelo FOMDA num Perfil para a UML.
A abordagem FOMDA pode ser utilizada para projetar qualquer tipo de sistema.
Esta abordagem pode ser adaptada para o desenvolvimento de Sistemas Embarcados de Tempo Real (STRE), dado que ela oferece mecanismos para capturar requisitos de sistemas (especialmente os não funcionais) e para mapear- los para serviços providos por plataformas.
Para ilustrar esta adaptação, este Capítulo apresenta um estudo de caso relacionado com o projeto de um STRE.
Sistemas Embarcados de Tempo Real O projetista de transformações inicia a organização dos mapeamentos e transformações de modelos por a primeira das etapas da FOMDA.
Em esta etapa, o projetista de transformações precisa especificar num Modelo de Features as características das plataformas que são utilizadas pra desenvolver muitos tipos de STREs.
O exemplo da Figura 33 apresenta possíveis requisitos não funcionais para um STRE.
Ela define que qualquer produto deve ter pelo menos as seguintes características:
Uma linguagem de programação (Java, C, ou C+);
Um fluxo de execução que pode ser concorrente ou não;
Uma abordagem para administração de tempo que pode ser feito com programação de baixo nível (low level programming) ou por chamadas de sistemas (system calls);
E um processador de hardware relacionado.
A característica de infra-estrutura é opcional, mas quando concurrent ou system call é selecionada, então a infra-estrutura é necessária.
Conseqüentemente, se infra-estrutura é necessária, o projetista pode escolher entre os sistemas operacionais, API e middleware.
Regras de composição textuais devem ser definidas na abordagem FOMDA para especificar as relações de dependência e de exclusão mútua como regras para seleção de plataformas.
A Tabela 3 apresenta algumas regras textuais para a composição das características do FM exemplificado na Figura 33.
Depois de definir o FM, o projetista de transformações pode configurar a plataforma alvo selecionando as características relacionadas.
Esta seleção é conhecida como instanciação do Modelo de Features.
A Figura 34 apresenta uma possível instanciação do modelo apresentado na Figura 33.
As características selecionadas estão marcadas em cinza.
Em este exemplo, as seguintes características estão selecionadas:
Java, como linguagem de programação;
Fluxo de execução concorrente, administração de tempo usando chamadas de sistemas;
FemtoAPI como uma infra-estrutura de API;
E FemtoJava como processador.
Depois de instanciar o PDM é possível utilizar- lo para aplicar transformações num modelo fonte.
Este modelo fonte é descrito nesta seção, que apresenta um estudo de caso que exemplifica a geração de um SETR usando as etapas de organização da abordagem FOMDA.
O problema consta na transformação de um modelo de sistema especificado em alto nível para um modelo específico de FemtoAPI.
O modelo em consideração contém requisitos para um sistema de controle de movimento de uma cadeira de rodas motorizada.
Estes requisitos estão decorados com restrições de tempo real, que são marcações Wehrmeister 2005).
A Figura 35 (a) apresenta dois objetos colaborando (extraídos de um diagrama mais geral) que são usados para exemplificar os mapeamentos propostos.
Os objetos na Figura 35 (a) foram selecionados para este estudo porque eles contém informações temporais importantes em as quais a respectiva implementação é altamente dependente de plataforma.
Os seguintes aspectos, por o momento, devem ser observados durante a implementação do sistema e conseqüente transformação de modelo para código:
Portanto, o presente trabalho é desafiado por o seguinte problema:
Como gerar o SETR final de acordo com a seleção de plataformas por o projetista da aplicação?
Essa seção guia o leitor na abordagem FOMDA para resolver o problema referido.
As características selecionadas na Figura 34 são utilizadas para aplicar transformações num modelo de um sistema.
Isto quer dizer que um modelo (um Pim) precisa ser transformado para a plataforma alvo composta de:
Java, FemtoJava, Concurrent, SystemCall e FemtoAPI.
Cada uma destas características pode transformar um Pim num PSM.
A Figura 35 (b) dá um exemplo de organização de algumas das características selecionadas na Figura 34 para aplicar transformações no modelo fonte da Figura 35 (a).
A transição do estado inicial do workflow para a atividade de transformação denominada EmbeddedControlSystem identifica o início da transformação.
O estereótipo &quot;SourceModel «pode ser utilizado em transições e identificam que o estado de um modelo é de um modelo fonte.
Transições podem conter estados de guarda, que identificam que tipo de modelo uma transição trafega para os demais elementos do diagrama.
Atividades de transformação são decoradas com o estereótipo &quot;FeatureElement «e precisam conter como nome uma das características selecionadas no MF.
Em esse exemplo, a transformação inicia com o mapeamento (transição) de um Pim (estado de guarda), que é o modelo-fonte (estereótipo &quot;SourceModel&quot;), para a atividade de transformação EmbeddedControlSystem.
Em seguida, uma transição que contém o estado de guarda identitiy informa o mapeamento de um resultado desta atividade para o objeto denominado fInput1.
O objeto fInput1 definido na Figura 35 b) está decorado com o estereótipo &quot;FeatureParameter».
Isto indica que ele é um parâmetro da característica que determina o nome da atividade de transformação.
Ele contém uma transição decorada com &quot;FeatureInput «para a atividade de transformação FemtoAPI.
Então, este objeto é um parâmetro de entrada para a característica FemtoAPI, visto que esta é representada no workflow como uma atividade que contém o estereótipo &quot;FeatureElement».
Um parâmetro de entrada de uma característica indica o tipo do elemento de um modelo de um sistema que pode ser mapeado para a característica.
Em o exemplo da Figura 35 (b), o objeto fInput1 é do tipo Model, o que significa que a característica FemtoAPI precisa receber como entrada um elemento deste tipo para aplicar transformações.
De o contrário, FemtoAPI não pode realizar a transformação.
De acordo com a ordem das transformações identificadas nesse exemplo, a atividade de transformação FemtoAPI recebe no parâmetro de entrada fInput1, o modelo retornado por a atividade EmbeddedControlSystem.
Este modelo é descrito como identity.
Esta atividade efetua uma transformação e armazena o resultado no seu parâmetro de saída fOutput1.
O resultado desta transformação no modelo de entrada é identificado por o estado de guarda contido na transição do objeto fOutput1 para o objeto jInput1.
Em o exemplo, o tipo de modelo trafegado por a transição entre estes objetos é o PSM.
Todo o mapeamento que é realizado no workflow de alto nível deve ser feito entre um parâmetro de entrada e um parâmetro de saída.
Por esse motivo o modelo que é saída da atividade FemtoAPI não foi mapeado diretamente para o parâmetro de entrada de java.
Além disso, existe a possibilidade de mapear a saída de FemtoAPI para outras atividades de transformação, o que justifica a necessidade de uma mapeamento ser realizado entre um parâmetro de saída e, no mínimo, um parâmetro de entrada de uma outra característica.
Em o exemplo da Figura 35 (b), o elemento de um modelo contido no parâmetro de saída fOutput1 é um elemento pronto para geração de código.
A transição do objeto fOutput1 para o jInput1 indica o mapeamento do elemento de modelo, contido no parâmetro fOutput1, para o parâmetro de entrada da atividade de transformação Java, denominado jInput1.
Java aplica uma transformação que gera código para uma aplicação.
Isto é identificado por a transição desta última para o estado final do workflow.
Tal transição contém o estado de guarda java code.
Em o mesmo exemplo da Figura 35 (b) o workflow documenta a ordem com que as características do MF são usadas para aplicar transformações (M2M e M2C).
Além de essas especificações, é necessário identificar como as atividades de transformação transformam um modelo contido num de seus parâmetros de entrada.
Isto é realizado na FOMDA definindo workflows de baixo nível.
Um workflow de baixo nível é definido por uma atividade de transformação (do workflow de alto nível) que contém um estado de sub-atividade.
A Figura 36 documenta as transformações internas da atividade de transformação FemtoAPI.
O objeto fInput1 é o mesmo do workflow da Figura 35 (b).
Existe uma transição de ele para uma ação identificada como select.
Esta determina que uma seleção (no parâmetro de entrada da atividade de transformação) de elementos do mesmo tipo dos objetos do modelo fonte (elementos do modelo da aplicação do projetista de aplicações) decorados com o estereótipo &quot;SourceModelElement».
Dentro de um parâmetro de entrada do tipo Model, uma pesquisa é realizada para selecionar apenas elementos do tipo Object.
Quando um elemento é selecionado, ele é mapeado (ação identificada como mapping) para parâmetros de transformação.
Estes parâmetros são identificados por objetos decorados com estereótipo &quot;TransformationParameter «e são utilizados por transformadores da categoria TMD (quarto nível de organização de transformação).
Após mapear elementos do tipo Object para o parâmetro de transformação, identificado como Object, do transformador sptTransf, o projetista pode requisitar a execução deste transformador.
Isto é documentado no workflow com uma ação denominada execute.
A execução do transformador gera como saída um modelo identificado por a guarda FemtoAPI PSM, ou seja, um PSM que contém características de FemtoAPI.
A sub-atividade FemtoAPI terminou, mas o projetista precisa seguir a transição de ela para a próxima atividade ou objeto, identificado no workflow da Figura 35 (b).
Em o âmbito de identificar o workflow, algumas questões são relevantes:
A) como identificar os parâmetros de uma transformação?
B) como organizar transformações e seus parâmetros (levando em conta a mudança de plataformas alvo no MF?
C) como reutilizar os modelos gerados no caso de haver mudança de plataformas alvo?
Estas questões podem ser respondidas analisando corretamente o MF.
A Figura 37 apresenta um exemplo em que as características API e FemtoAPI estão selecionadas no MF.
O propósito com que FemtoAPI é utilizada para aplicar transformações num modelo é converter classes deste modelo, especificadas numa visão Pim, em classes onde os tipos dos atributos são de tipos definidos por a API FemtoAPI.
Além disso, algumas das classes especificadas na visão Pim precisam, após a transformação ser realizada em FemtoAPI, herdar da classe RealtimeThread.
É necessário identificar o que é o Pim para a característica FemtoAPI e, dessa maneira, identificar um pré-requisito para ela.
Em o trabalho publicado anteriormente, optou- se por especificar que a entrada de FemtoAPI é um modelo decorado com marcações do perfil SPT, ou seja, um modelo de nível intermediário entre um Pim e um &quot;FemtoAPI PSM».
O mesmo pré-requisito é mantido para a característica FemtoAPI no presente trabalho.
Para as características RTSJ, TAFTAPI e GenericAPI o parâmetro de entrada é o mesmo que para FemtoAPI.
O propósito que elas serão usadas num contexto de transformação de modelos também é o mesmo que o de FemtoAPI.
Logo, uma conclusão que pode ser tirada em relação a as quatro características filhas de API é que todas elas recebem como parâmetro de entrada o mesmo modelo decorado com o perfil SPT.
Isto garante que caso exista a troca de FemtoAPI por RTSJ, pode- se reutilizar o mesmo parâmetro de entrada de FemtoAPI em RTSJ.
Dado que todas as Apis precisam receber como entrada o mesmo modelo, é preciso garantir que isto ocorra num processo de transformação de modelos na abordagem FOMDA.
Uma análise detalhada do MF (mostrado na Figura 33) revela que a característica API pode determinar um modelo de saída, que serve como entrada comum para RTSJ, FemtoAPI, TAFTAPI e GenericAPI.
Isto é possível porque a característica API é hierarquicamente superior a estas últimas e, portanto, pode ser dita como sendo de nível mais abstrato.
Logo, características de nível mais abstrato podem ser utilizadas para reusar modelos em caso de troca nas plataformas alvo de um sistema.
Com base nessa análise, foi possível concluir que características de nível hierárquico mais alto no Modelo de Features podem ser úteis para reuso de modelos, em caso de mudanças de plataformas alvo.
Isto pode ser observado no centro da Figura 37, em que três partes de três workflows descrevem a mudança de plataformas alvo no quesito API.
API é, portanto, uma característica do FM que define como saída, um mesmo modelo que é usado como parâmetro de entrada por as características FemtoAPI, RTSJ, TAFTAPI e GenericAPI.
O modelo que é parâmetro de saída de API pode ser reutilizado, sem alterações, em caso de mudança das características relacionadas com API.
A mudança da característica FemtoAPI para RTSJ é representada no MF por a seleção desta última.
Sendo assim, o reuso de modelos pode ser garantido em níveis de independência que são determinados por a hierarquia das características no MF.
Em caso de mudança de plataformas alvo, é possível recorrer para modelos independentes de plataforma (ou de nível intermediário entre o Pim e o PSM).
Tais modelos podem ser encontrados em transformações realizadas em características de níveis hierárquicos superiores à característica que representa a plataforma alterada.
Outra análise das características do MF identificou que algumas de elas não têm relação hierárquica, mas podem contribuir para a reutilização de modelos.
Isto determina que a solução para reuso de modelos (apresentada anteriormente) não se aplica nos casos em que as características não possuem relação hierárquica.
Tomando como exemplo a Figura 33, as características selecionadas, que são usadas com o propósito de aplicar transformações num modelo de um sistema e que não tem relação hierárquica são:
Java, Concurrent, FemtoAPI, SystemCall e FemtoJava.
Todas elas precisam estar documentadas no workflow de alto nível.
Analisando os propósitos de cada uma, é possível avaliar se elas efetuam transformações M2M, gerando modelos intermediários entre um Pim e um PSM ou mesmo o PSM, e M2C, gerando código para uma aplicação.
A análise dos propósitos das características do FM implica na ordenação das transformações no FOMDA Workflow.
Em o exemplo, Java pode ser uma característica que tem o propósito de gerar código Java e, portanto, tem como parâmetro de entrada um modelo contendo classes.
Concurrent é uma característica relacionada com concorrência e pode identificar no workflow a geração de um modelo que contenha marcações relacionadas com concorrência.
É possível utilizar o perfil SPT para decorar elementos de um modelo e especificar em eles as características relacionadas com concorrência.
De a mesma maneira, SystemCall pode identificar que marcações que representam chamadas de sistema precisam ser especificadas num modelo de sistema.
Características como Concurrent e SystemCall são exemplos de transformações que identificam a necessidade de especificar marcações, definidas por perfis da UML, num modelo de sistema.
Tais marcações precisam especificar detalhes não funcionais num Pim, tornando- o específico destes detalhes.
Um modelo que contém marcações não funcionais pode ser definido como um Pim ou de nível intermediário entre o Pim e o PSM.
Ele pode ser reutilizado em transformações para mais de uma plataforma alvo.
FemtoAPI e RTSJ são exemplos de transformações que podem receber estes tipos de modelos como entrada e, dessa maneira, tais modelos podem ser reutilizados na mudança de plataformas alvo.
Com base nas análises realizadas no MF da Figura 33, foi possível especificar os workflows definidos na Figura 38.
O workflow denominado FirstLevelEmbedded Applications oferece a vantagem de, em caso de mudança de plataforma como, por exemplo, mudar de FemtoAPI para RTSJ, que apenas a atividade FemtoAPI e seus respectivos parâmetros sejam removidos do workflow.
Em este último devem ser inseridos a nova atividade RTSJ e seus parâmetros de entrada e de saída.
Além disso, esta atividade precisa ser configurada num outro workflow para aplicar transformações internas.
O workflow definido na Figura 39, denominado Java, especifica as transformações internas da atividade de transformação Java do primeiro workflow da Figura 38.
Este workflow especifica que elementos do tipo mof.
Core. Class são selecionados no parâmetro de entrada da característica Java.
Em seguida estes parâmetros são mapeados para o parâmetro de transformação do transformador Generic Java Transformer.
Por fim, este transformador é executado e o código Java, respectivo à classe mapeada para o parâmetro deste transformador, é gerado.
Domínios Específicos, conhecidas como Domain Specific Modeling Languages (DSML).
A vantagem em acrescentar transformadores neste tipo de característica está em auxiliar o projetista de aplicações na especificação das marcações nos modelos de um sistema, caso o mesmo já não as tenha especificado.
A organização das transformações de um Pim para um PSM é documentada nos workflows identificados neste estudo de caso.
Eles foram especificados de modo a responder as questões levantadas anteriormente.
Para isso, foram feitas análises detalhadas dos relacionamentos entre as características definidas no Modelo de Features e do propósito que cada uma é utilizada para aplicar transformações num modelo de entrada.
Como resultado da análise, foi identificada a necessidade de modelos de nível intermediário estarem decorados com marcações definidas por perfis da UML.
Logo, algumas das características selecionadas no MF identificam a necessidade do uso de perfis para a transformação de modelos.
Modelos decorados com marcações podem ser reutilizados em caso de uma mudança das plataformas alvo.
Esta Seção exemplifica como utilizar transformadores de baixo nível na abordagem FOMDA.
Para isso, o modelo da Figura 41 é utilizado como exemplo.
O modelo da Figura 41 apresenta um Diagrama de Colaboração que é utilizado para exemplificar os mapeamentos definidos na Figura 38.
Para demonstrar a transformação do modelo fonte da Figura 41, uma transformação M2M é aplicada usando o transformador da Figura 42.
O transformador precisa receber como um parâmetro um elemento do tipo mof.
Collaboration. Object e, baseado no perfil SPT, deve aplicar a transformação de um modelo fonte para o modelo alvo FemtoAPI.
Analisando o código do transformador, na linha 5 é posto o código para obter o parâmetro de transformação object (este é o elemento de modelo de sistema que é pesquisado por a ação select do workflow da Figura 36).
A linha 7 mostra como obter a classe alvo de um objeto, baseado na especificação do MOF.
A classe alvo é o elemento do modelo fonte que a transformação M2M é aplicada, tornando- a dependente da plataforma alvo FemtoAPI.
A Linha 10 mostra como o transformador FOMDA testa se alguma característica do FM está selecionada.
Quando a característica Concurrent esta selecionada no FM ou a classe alvo é ativa ou ela contém o estereótipo &quot;SAschedRes», então a classe alvo precisa herdar da classe RealtimeThread.
Este mapeamento é baseado no trabalho de Becker (Becker De as linhas 18 à 22 o projetista de transformações precisa escrever um algoritmo para aplicar transformações sobre as mensagens decoradas com o estereótipo &quot;SAresponse».
Mensagens que contém este estereótipo são mapeadas para a plataforma alvo FemtoAPI adicionando duas operações na classe alvo:
MainTask e exceptionTask.
As linhas 23-43 contém o algoritmo para adicionar a operação mainTask à classe alvo, em que o corpo da operação (onde é determinado o código de implementação para esta operação) pode ser gerado no código da linha 31 até a 41.
Este código pode ser usado para adicionar código Java específico de FemtoAPI no elemento associado, e pode ainda ser usado posteriormente por um outro transformador.
Em este algoritmo de transformação o foco está em realizar transformações M2M para modificar uma classe e não para gerar código desta.
Exception (&quot;Parameter object must contains a type&quot;);
/* the target class must inherit from RealtimeThread class*/ Class superClass $= new superClass.
SetName (&quot;RealtimeThread&quot;);
As classes alvo, por o momento, não estão prontas para a geração de código porque a operação mainTask, assim como outros elementos das classes alvo, precisam conter seções de código dentro de o corpo de seus elementos, como realizado por Becker (Becker Depois, estes comentários podem ser organizados dentro de o corpo dos elementos num transformador M2C para, então, gerar o código correto.
De as linhas 21-22 o projetista de transformações pode escrever o algoritmo para pesquisar por mensagens decoradas com o estereótipo &quot;SAtrigger».
O algoritmo precisa contendo tipos específicos de FemtoAPI precisam ser gerados (por exemplo:
PeriodicParameters, AbsoluteTime, etcFOMDA) como uma solução para mapeamento de transformação de modelos de sistemas num MDD.
Esta abordagem é proposta para auxiliar projetistas de aplicações na definição de mapeamentos e transformações de quaisquer modelos de sistemas (especificados em UML) para múltiplas plataformas alvo.
Isto é feito configurando transformações model- to model e model- to code, em camadas.
Cada camada representa alguma plataforma alvo para a qual o sistema precisa ser mapeado e transformado.
A tarefa de configurar mapeamentos e transformações de modelos de sistemas é dividida em quatro níveis, a fim de simplificar e tornar mais claras as transformações.
A abordagem FOMDA define que transformações de baixo nível são caracterizadas como de manipulação direta de modelos.
Em esta categoria, o projetista precisa escrever algoritmos de transformadores, para aplicar transformações nos elementos do modelo fonte.
Isto é feito em conjunto com a organização de transformações de terceiro nível.
O segundo nível de transformação serve para configurar entradas, saídas e transformadores de plataformas alvo.
Finalmente, o primeiro nível de organização de transformações representa workflows, que servem para guiar o projetista de aplicações nos mapeamentos e transformações em plataformas alvo.
A divisão das transformações em quatro níveis possibilitou que os transformadores pudessem ser reaproveitados no caso de troca das plataformas alvo.
Quando é necessário o uso de outras plataformas, além de as selecionadas no PDM, é necessária apenas uma redefinição das transformações (especificadas em alto nível no FOMDA Workflow).
Esta tarefa se torna simples, porque estas transformações já estão especificadas nas plataformas, sendo necessário apenas que o projetista organize- as no workflow e informe quais são os parâmetros de entrada e saída de cada transformador.
Um estudo de caso foi apresentado para avaliar a aplicação da abordagem FOMDA no desenvolvimento de um sistema embarcado de tempo real.
Este estudo apresentou como converter um modelo geral em alto nível (Pim) para um modelo específico de uma plataforma alvo (PSM).
Além disso, este estudo possibilitou avaliar o reuso de modelos e de transformações.
Análises feitas no Modelo de Features e nas transformações (que podem ser realizadas por as características desse modelo) identificaram interessantes práticas que viabilizam o reuso de modelos.
As características de nível hierárquico superior no FM podem auxiliar na identificação do uso de marcações em modelos de sistema.
Um modelo decorado com marcações provenientes de perfis UML pode ser reutilizado por muitos transformadores, para diferentes plataformas.
Isto determina que modelos podem ser especificados em camadas, que determinam o seu nível de independência de plataformas.
De essa maneira, é possível identificar quando um modelo pode ser reutilizado, em caso da troca das plataformas utilizadas para desenvolver uma aplicação.
Os resultados obtidos são otimistas e levam a conclusão de que a abordagem FOMDA pode auxiliar no desenvolvimento de software para múltiplas plataformas.
Além disso, esta abordagem pode ser utilizada para desenvolver software para muitos domínios, como para o domínio de sistemas comerciais e de sistemas embarcados.
Ela pode levar os projetistas a repensarem os seus processos de desenvolvimento de software.
Estes processos podem ser decompostos em níveis de independência das características específicas das plataformas alvo, utilizadas para desenvolver sistemas.
