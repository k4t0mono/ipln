Atualmente a área de teste de software tem se tornado fundamental para garantia da qualidade dos produtos desenvolvidos.
Dentro de o processo de teste, o teste unitário é realizado na menor parte funcional de um software e visa descobrir defeitos nestas unidades.
JUnit é uma ferramenta de apoio ao teste unitário, a qual auxilia desenvolvedores na automação dos testes e verificação dos resultados.
Porém, muito tempo, custo e esforço ainda são gastos para codificar os drivers e os stubs de teste necessários a esta ferramenta, o que muitas vezes inviabiliza o seu uso.
Outro problema encontrado no processo de teste unitário é a necessidade de especificação dos casos de teste numa linguagem de mais alto nível, que seja independente de linguagem de programação.
O Perfil de Teste da UML 2.
0 (U2TP) resolve este problema, pois permite representar e documentar todos artefatos utilizados no processo de teste.
Esta dissertação de mestrado tem por objetivo a geração totalmente automatizada de drivers e stubs de teste para ferramenta JUnit a partir de especificações de testes modeladas com a U2TP.
Um estudo de caso mostrou que os algoritmos propostos geraram corretamente todo código de teste para todos elementos explorados neste trabalho.
O estudo de caso teve como principais objetivos a validação correta do código gerado, bem como uma análise quantitativa em relação a o tempo envolvido e número de linhas de código geradas.
Com a crescente demanda de sistemas de software cada vez mais complexos e também com o avanço da tecnologia, o processo de teste tornou- se fundamental para garantia de qualidade dos produtos de software.
Atualmente é necessário integrar o processo de teste cada vez mais cedo dentro de as fases de desenvolvimento do software.
De essa forma, falhas de projeto e de implementação podem ser descobertas mais cedo, ajudando a diminuir o custo e o retrabalho.
Entretanto, muito tempo ainda é gasto para testar produtos de software, e é nas atividades testes que se concentram os maiores esforços, custos e tempo.
Dentro de o primeiro ciclo de desenvolvimento do software, a fase de codificação é freqüentemente responsável por gerar o maior percentual de defeitos num sistema.
Uma forma de reduzir esse percentual é a realização dos testes unitários.
Um teste unitário é realizado na menor parte funcional de um software (uma função, uma classe, um procedimento, etc).
Posteriormente ao teste unitário é realizado o teste de integração, que visa garantir a integração destas unidades e o teste de sistema, que visa garantir o funcionamento do sistema como um todo.
Finalmente tem- se o teste de aceitação que visa garantir o funcionamento correto do sistema em relação a os requisitos do usuário.
Para cada nível de teste são gerados casos de teste.
Casos de testes servem para executar o software sob algumas condições dado um conjunto de valores de entrada e verificar as saídas correspondentes A automação de testes vem sendo uma das formas de reduzir o tempo gasto nas atividades de teste.
Ela está ganhando muita importância e aceitação no mercado, pois auxilia desenvolvedores a executar e verificar testes automaticamente.
Existe uma classificação das ferramentas de teste de acordo com a fase do processo de teste ao qual dão apoio, por exemplo, ao planejamento de teste, projeto de casos de teste, execução de teste, entre outras atividades.
Uma série de ferramentas para teste de unidade conhecidas como ferramentas XUnit, entre elas cppUnit (para linguagem c+), dUnit (para linguagem Delphi), VBUnit (para linguagem Visual Basic), JUnit (para linguagem Java) e NUnit (para linguagem.
Net), está sendo bastante utilizadas para automatização da execução dos testes.
Elas diminuem o tempo para execução dos testes e proporcionam que as saídas, ou seja, os resultados possam ser verificados, garantindo assim maior confiabilidade para o testador.
As diferentes ferramentas da família XUnit diferem basicamente na linguagem de programação dos programas que executam.
Algumas vantagens dessas ferramentas incluem:
Verificação automatizada dos resultados e diagnóstico preciso do tipo de erro e/ ou defeito;
O código que coordena a execução do teste, conhecido como driver, fica armazenado num repositório para eventuais modificações no código, favorecendo a manutenção do código.
Satisfação do programador, uma vez que este tem a sensação de executar e verificar o resultado, resultando num maior comprometimento do programador com a execução dos testes.
Para utilizar uma dessas ferramentas, é necessário especificar e desenvolver os casos de teste.
Esses casos de testes constituem o driver de teste usado por a ferramenta.
Também pode ser necessário especificar e desenvolver os stubs de teste.
Um driver é uma classe que simula o programa principal do elemento a ser testado, ou seja, faz chamadas ao módulo a ser testado.
Um stub serve para substituir os módulos que estejam subordinados ao módulo a ser testado.
Esses elementos são códigos auxiliares desenvolvidos para dar suporte à unidade a ser testada, são os chamados Test Harness.
Test Harness são trechos de códigos que devem ser escritos para possibilitar o teste do produto final sendo desenvolvido, mas não fazem parte deste.
Autores como e ressaltam que os Test Harness representam sobrecarga, já que seu desenvolvimento às vezes demanda tempo, custo e esforço, minimizando assim as vantagens da automação dos testes.
Outra problema, é que os Test Harness são dependentes de linguagem de programação, ou seja, cada ferramenta tem uma codificação própria desses elementos.
Outra forma de reduzir o tempo e custo gasto nas atividades de teste é o uso de padrões.
Entretanto, o processo de teste unitário muitas vezes não segue um padrão que possa ser facilmente seguido.
Segundo, o processo de teste unitário muitas vezes é executado informalmente por o próprio desenvolvedor.
Isso traz problemas graves como:
Defeitos encontrados não são registrados;
Dificuldade de reuso e falta de planejamento.
Por exemplo, na Extreme Programming através do Test Driver Development ­ TDD, os drivers de testes são feitos antes mesmo do código ser desenvolvido.
Isso induz a um código potencialmente livre de erros.
Porém, nessa abordagem não há um planejamento das atividades de teste, nem a portabilidade dos drivers de teste.
Assim, a maneira como um caso de teste é especificado nessa abordagem é totalmente ad-hoc, pois ele é feito por o próprio programador e sem nenhum planejamento.
Outro problema encontrado no processo de teste unitário, é que muitas vezes apesar de haver um planejamento das atividades de teste, a especificação dos casos de teste não segue um padrão de documentação dos artefatos de teste;
Também não existe uma linguagem universal para especificação de testes que pode ser usada independentemente do tipo de linguagem em que o sistema é desenvolvido.
Assim, para resolver esses problemas é preciso uma notação padrão para especificação de testes.
Recentemente a OMG (Object Management Group) disponibilizou a visualização, especificação, construção e documentação de artefatos de teste para sistemas complexos de software.
A U2TP proporciona que todos artefatos utilizados para testar um sistema possam ser especificados e modelados em UML, auxiliando assim na documentação, entendimento e rastreabilidade dos artefatos de testes.
Outra vantagem da U2TP é a definição de um conjunto de conceitos próprios à área de testes que podem ser representados e mapeados para diferentes ferramentas de testes, como por exemplo:
JUnit (teste unitário) e TTCN-3 (teste de integração e sistema).
Um estudo para avaliar a viabilidade de uso de umas das ferramentas da família XUnit descritas anteriormente foi realizado em projeto de uma grande empresa de desenvolvimento de software instalada no Parque Tecnológico da PUCRS.
O projeto era composto por três equipes:
Projeto, Construção (Cliente e Servidor) e Teste de Integração.
A Figura 1 ilustra os papéis das equipes dentro de o projeto e o relacionamento entre as equipes.
De acordo com a Figura 1, a equipe de projeto especifica os documentos de design para que a equipe de construção (Cliente e Servidor) desenvolva o software.
Esses documentos de design são descritos em pseudocódigo.
A equipe de construção Cliente desenvolve em linguagem Visual Basic 6.0 e a equipe de construção Servidor em linguagem C+.
Antes da codificação, os programadores especificam os casos de teste em nível de unidade baseado no documento de design.
De essa forma, uma vez codificado o documento de design, os programadores executam os casos de testes especificados anteriormente.
A equipe de Integração é responsável por testar e integrar os módulos já testados individualmente.
Um dos problemas vivenciados por este projeto de desenvolvimento de software era o tempo gasto para execução dos casos de testes unitários.
Um grande número de defeitos estava sendo descoberto por a equipe de teste de integração.
Isso mostrava que os testes unitários não estavam sendo realizados com eficiência.
Entre os defeitos encontrados, aproximadamente 70% estavam relacionados à equipe de construção Cliente e de entre esse percentual, cerca de 60% dos defeitos era relacionado a erros de tela (layout).
Para tentar minimizar esse problema, foi realizado um estudo de caso para avaliar a viabilidade de utilização de uma ferramenta para teste unitário da família XUnit.
A ferramenta escolhida foi VBUnit.
Depois de dois meses de estudo foram realizados alguns testes e um projeto piloto foi implantado.
Os resultados desse estudo mostraram que os Drivers e Stubs de teste desenvolvidos para a ferramenta necessitavam de um esforço muito grande para codificação dos mesmos, o que inviabilizou o uso da ferramenta.
De essa forma, o que se observou foi a necessidade de especificar e gerar drivers e stubs de teste automaticamente, o que reduziria o esforço e o tempo gasto para a codificação dos mesmos.
Como forma de minimizar os problemas descritos anteriormente, este trabalho propõe gerar automaticamente drivers e stubs de teste para ferramenta de teste unitário JUnit a partir de a especificação de teste unitário modeladas com o U2TP.
Com isso é possível contribuir com o uso da U2TP para especificação de teste em nível de unidade e reduzir o tempo gasto para codificação de drivers e stubs de teste.
Investigar as possibilidades e os requisitos para conversão de uma especificação de teste unitário usando o U2TP na codificação equivalente para a ferramenta JUnit;
Propor algoritmos para geração de drivers e stubs para ferramenta JUnit a partir de a especificação do U2TP;
Especificar e implementar um protótipo de um ambiente que dê suporte as estes algoritmos.
Este trabalho está organizado em nove capítulos.
Em o capítulo um foi apresentada a introdução do presente trabalho, descrevendo a contextualização do problema bem como a proposta e seus objetivos.
Os demais capítulos estão organizados como segue:
JUnit e geração de drivers de teste a partir de modelos UML.
Em o final do capítulo é apresentada uma tabela comparativa entre as abordagens;
Mapeamento U 2 TP-JUnit e Modelo de Mapeamento U 2 TP-XMI;
Serão descritos os algoritmos de mapeamento usados para capturar os elementos para classes bem como o gerador de código usado para gerar esses elementos.
Finalizando o capítulo, será apresentado o protótipo desenvolvido;
O processo de desenvolvimento de software é descrito como uma série de fases, procedimentos e passos que resultam na produção de um software.
Dentro de o processo de desenvolvimento de software estão outros processos, incluindo o Teste.
Teste de software é o processo de executar o software de uma maneira controlada com o objetivo de avaliar se o mesmo se comporta conforme o especificado.
Entretanto, a dificuldade em testar um sistema de software é caracterizada por alguns pontos importantes tais como;
Assim, para que o processo de teste possa efetivamente fornecer um benefício em termos de custo, esforço e tempo, é importante que as atividades de teste sejam bem planejadas.
O processo de teste de software é composto por atividades que têm por objetivo executar um programa a fim de revelar suas falhas e avaliar sua qualidade.
Ele é muito importante em toda etapa de desenvolvimento do software e, se bem aplicado, proporciona um aumento da qualidade do produto desenvolvido.
Não existe na literatura um consenso sobre quais são as atividades chave do processo de teste.
A norma 829 da IEEE define um conjunto de documentos (artefatos) para as atividades de teste de software.
A norma separa as atividades de teste em três etapas:
Preparação do Teste;
Execução do Teste e Registro do Teste. Alguns autores também identificam tais etapas, como em, Assim, as principais atividades do processo de teste de software são descritas abaixo:
Planejamento: Em esta atividade é gerado um plano de teste que deve conter informações sobre a abrangência, a abordagem, os recursos e a programação da atividade de teste.
Projeto de casos de teste:
Em esta atividade são definidos os casos de teste usados para testar o sistema.
Devem ser identificadas as características específicas a serem testadas por o projeto.
Procedimento de Teste:
Em esta atividade são identificadas todas as etapas necessárias para operar o sistema e exercitar os casos de testes especificados para implementar o projeto de teste já definido;
Execução dos Testes:
Em esta atividade os testes são executados.
A execução dos testes começa em nível de unidade até integração e sistema.
Avaliação e/ ou Resultados dos testes:
Em esta atividade são relatados todos os resultados e destacadas as discrepâncias encontradas nos resultados.
Em a elaboração do planejamento dos testes uma das etapas é decidir qual a estratégia de teste será usada.
A estratégia de teste compreende a definição dos seguintes itens:
O nível de teste, ou seja, a definição da fase do desenvolvimento do software em que o teste será aplicado;
A técnica de teste a ser utilizada;
O critério de teste a ser adotado e o tipo de teste a ser aplicado no software.
A Figura 2, extraída de, ilustra os relacionamentos entre os níveis, tipos e técnicas de teste de software.
O nível de teste depende da fase do desenvolvimento do software em que o teste poderá ser aplicado.
Os três principais níveis são:
Unidade, discutido detalhadamente na seção A técnica de teste direciona a escolha de critérios para projetos de casos de teste, que, ao serem executados, vão exercitar os elementos requeridos por a abordagem do teste.
As principais técnicas são:
Testes Estruturais, também conhecidos como Testes de Caixa Branca e Testes Funcionais, também conhecidos como Testes de Caixa Preta.
Os testes estruturais concentram- se no código fonte do sistema sob teste, tem por objetivo testar o programa internamente.
Os testes funcionais concentram- se nos requisitos do software a ser testado, tem por objetivo testar as funcionalidades do sistema.
O critério de teste serve para orientar o testador na geração dos casos de teste.
São definidos de acordo com a técnica de teste usada, por exemplo, se a técnica escolhida for Caixa Branca, alguns critérios para escolha dos casos de teste são:
Teste de caminho básico, testes de condições, loops, entre outros.
Já se a técnica escolhida for Caixa Preta, alguns critérios para escolha dos casos de teste são:
Análise do valor Limite, Classes de Equivalência, entre outros.
Os tipos de teste referem- se às características do software que podem ser testadas, tais como:
Teste de Funcionalidade, Teste de Interface, Teste de Desempenho;
Teste de Carga (Stress) entre outros.
Dentro de o processo de teste de software, algumas atividades são delegadas a pessoas com capacidade específicas para executar- las.
Não existe um consenso na literatura sobre os possíveis papéis dentro de o processo de teste e também sobre qual ou quais atividades cada papel é responsável.
Entretanto, os papéis e responsabilidades comuns encontrados em algumas literaturas conforme e são:
Gerente de Teste: É a pessoa central que trata de todos os assuntos relacionados a teste de software.
Um gerente de teste é normalmente responsável por a definição da política de teste usada na organização, incluindo:
Planejamento de testes, documentação dos testes, controle e monitoramento dos testes, aquisição de ferramentas de teste, participação em inspeções, revisões do trabalho de teste, entre outros;
Engenheiro de Teste: Também conhecido como projetista de teste, é responsável principalmente por especificar e projetar os casos de teste.
Testador: É aquele que executa o teste.
Em nível de unidade o testador é freqüentemente o próprio programador.
O Teste Unitário ou Teste de Unidade é a primeira fase do processo de teste de software, e é considerado um dos fundamentos principais do desenvolvimento de software.
É nessa fase que são descobertos o maior número de defeitos.
Ele é executado para melhorar a qualidade geral do software que passa por a equipe de teste de integração, sistema e depois para o cliente.
Segundo, um teste de unidade é realizado na menor parte funcional de um comparar funcionalidades de um determinado módulo com aquilo que foi descrito na especificação do mesmo, de forma a assegurar que o mesmo não o contradiga.
Para uma unidade é considerada o menor componente de software que pode ser testado.
Essa unidade pode ser caracterizada de vários modos, considerando um sistema orientado a objetos, uma unidade:
Executa uma única função coesa;
Pode ser compilada separadamente e contém código que se ajusta numa única página ou tela.
A Figura 3, adaptada de, ilustra algumas dessas unidades:
Uma unidade é tradicionalmente vista como uma função ou um procedimento considerando uma linguagem de programa procedural.
Em sistemas orientados a objetos, um pacote (com uma ou mais classes), classes, objetos ou métodos são considerados unidades individuais.
Uma unidade também pode ser considerada um componente COTS Component-of- the- shelf, os chamados componentes de prateleira (disponíveis externamente), como também os componentes in-house (disponíveis internamente).
De essa forma, uma unidade é definida dentro de o projeto de software que será desenvolvido.
Cabe ao Engenheiro de Teste decidir qual será o nível de abstração da unidade a ser testada.
Os casos de teste em nível de unidade são normalmente feitos por a pessoa que escreveu o código.
O código fonte está quase sempre disponível no teste de unidade (exceto nos componentes COTS) e os que desenvolveram estão familiarizados com os detalhes do código;
Conseqüentemente, eles podem fazer um uso construtivo destas informações.
Porém, um problema comum é que o programador é quem tem que especificar e projetar os casos de teste, mas muitas vezes ele não tem o mesmo conhecimento que um engenheiro de teste.
Assim, essa especificação muitas vezes é feita de maneira ad-hoc sendo que freqüentemente não há uma documentação dos casos de teste.
Segundo testes unitários devem ser planejados.
Isso evita que programadores especifiquem e desenvolvam os testes.
Para preparar um teste unitário é preciso executar as seguintes atividades I. Planejar a abordagem geral para o teste unitário;
II. Especificar e projetar os casos de teste;
III. Definir os relacionamentos entre os testes;
IV. Preparar o código auxiliar necessário para o teste de unidade (Drivers e Stubs).
A atividade que pode ser automatizada de entre as descritas acima é a criação de Drivers e Stubs de teste.
O desenvolvimento de Drivers e Stubs consome recursos, tempo, custo e esforço.
Esses elementos podem ser desenvolvidos em vários níveis de funcionalidades.
Por exemplo, um Driver pode ter as seguintes funções:
I. Fazer chamadas a uma unidade sob teste;
II. Passar parâmetros para uma unidade sob teste;
III. Mostrar parâmetros e IV.
Mostrar resultados (parâmetros de saída).
Um Stub também pode exibir diferentes níveis de funcionalidade:
I. Mostrar uma mensagem que foi chamada por uma unidade sob teste;
II. Mostrar parâmetros de entrada passados por uma unidade sob teste e III.
Passar valores para uma unidade sob teste.
A Figura 4, adaptada de, ilustra como Drivers e Stubs são relacionados em testes unitários.
Para a realização dos testes unitários, algumas abordagens como o Test Driven Development ­ TDD a qual segue os princípios da Extreme Programming, vem sendo muito usada em sistemas orientados a objetos.
Em essa abordagem, os casos de teste os quais constituem o driver de teste são escritos antes do código a ser testado, e o desenvolvedor escreve o código de teste para todo código produzido.
Porém, como descrito em, um problema muito comum encontrado no processo de teste unitário é a forma como ele é executado, ou seja, informalmente.
Quando é feito por o próprio programador, como no TDD, o próprio programador é responsável por projetar e codificar os casos de teste, sendo que estas duas atividades são realizadas simultaneamente e não havendo, portanto, uma especificação dos casos de teste.
Outro problema encontrado no processo de teste unitário é estabelecer uma maneira padrão para especificação dos casos de teste que possa ser facilmente usada independentemente do tipo de sistema que será desenvolvido.
Por exemplo, atualmente com o uso de uma nova notação para especificação e representação de teste de software, o U2TP, todos os artefatos produzidos no processo de teste unitário podem ser modelados e documentados, proporcionando assim uma notação padrão que pode ser usada independente do tipo de linguagem de programação que o sistema será desenvolvido.
O Capítulo 4 abordará em detalhes o U2TP.
Atualmente uma gama de ferramentas para teste unitário conhecidas como família XUnit estão sendo bastante usadas.
Elas estão ganhando bastante aceitação no mercado por serem fáceis de usar e por serem ferramentas de código livre.
De entre estas ferramentas, umas das ferramentas de maior popularidade e atualmente uma das mais usadas é o JUnit.
Os principais motivos de sua popularidade e uso são:
Evironment (ambiente de desenvolvimento integrado), como por exempplo:
Eclipse, NetBeans e BlueJ;
Por esses motivos e também por a possibilidade de mapeamento com alguns conceitos dão U2TP essa ferramenta foi escolhida para a proposta do presente trabalho.
A próxima seção descreve detalhadamente o framework JUnit.
Junit é um framework para teste de unidade usado por programadores que desenvolvem aplicações em linguagem Java.
A Figura 5, adaptada de, ilustra o diagrama de classes do Framework JUnit.
O JUnit possui diversos pacotes:
Framework como o pacote básico, runner que serve para representar algumas classes abstratas e para a execução dos testes, textui e swingui para apresentar ao usuário diferentes tipos de interfaces e extensions para algumas contribuições úteis ao framework.
Apesar de fácil de usar e de ser bastante popular, o JUnit possui um código bastante complexo.
Ele foi construído baseado em diversos padrões de projeto, entre eles (Command, Template Method, Collecting Parameter, Observer e Adapter).
As duas principais classes do JUnit são:
TestCase e TestSuite.
Essas classes implementam a interface Test que contém o método run responsável por a execução dos testes.
A classe TestCase é responsável por executar um caso de teste, que corresponde a um método testado no JUnit.
A classe TestSuite é responsável por executar um conjunto de casos de teste ou classes de teste.
Toda vez que um caso de teste é executado no JUnit ele:
O JUnit repete esse procedimento usando reflexão até encontrar todos os métodos de teste.
A o executar um caso de teste usando o JUnit, todas as suas expectativas são validadas através dos métodos da classe Assert.
O JUnit registra todo o caminho percorrido durante as falhas obtidas nos métodos da classe e relata os resultados após a execução de todos os testes.
Existem duas maneiras através de as quais um teste pode falhar no JUnit.
Ou o teste produz o resultado errado ou lança uma exceção não esperada (por exemplo, IndexOutOfBoundsException).
O JUnit denomina o primeiro caso como &quot;failure», ou falha, e o segundo de &quot;error», ou erro.
De essa forma um teste no JUnit pode apresentar como resultado três valores:
Pass, fail ou error.
Assim, a classe TestFailure reporta todos os tipos de erros ou falhas que podem ser geradas depois da execução de um teste.
Alguns dos métodos de assertivas mais usados do JUnit são mostrados abaixo:
O JUnit foi adaptado a uma variedade de Ides, que favorecem a escrita do código para uma melhor interpretação dos procedimentos de teste.
As Ide's mais conhecidas com suporte ao JUnit são Eclipse e NetBeans.
Para usar a ferramenta JUnit deve- se:
Crie uma classe que estenda junit.
Framework. TestCase classe de teste o SuaClasse:
Este capítulo abordou o processo de teste de software de um modo geral, descrevendo os principais termos encontrados na área de teste de software, as principais atividades, bem como os papéis envolvidos.
Também foram abordados mais detalhadamente o processo de teste unitário e a ferramenta JUnit.
O processo de teste de software é composto por uma série de atividades que, em conjunto, têm por objetivo a detecção de defeitos e o aumento da qualidade do software.
De entre os níveis de teste, o teste de unidade é considerado um dos mais importante, pois é responsável por localizar e corrigir os defeitos já no início do ciclo de desenvolvimento do software.
Apesar de tal importância, muitas vezes o teste de unidade não tem um planejamento adequado.
Em algumas abordagens como o TDD, o teste é realizado antes do código ser desenvolvido e isso induz a um código potencialmente livre de erros.
Porém, não existe um planejamento das atividades de teste e as especificações dos testes são feitas de maneira adhoc.
Outro problema é a necessidade de estabelecer uma maneira para especificação de testes unitários utilizando um modelo como a UML para especificações de testes.
Com isso é possível documentar os artefatos de testes, ajudando tanto na documentação como no entendimento desses artefatos.
Também é possível abstrair os testes num maior nível, minimizando assim a dependência dos testes em relação a linguagens de programação.
Uma gama de ferramentas para testes automatizados conhecidas como ferramentas da família XUnit têm contribuído para reduzir o tempo e esforço gasto na execução de testes, pois permitem a execução e verificação automatizada dos testes.
Porém, a geração automatizada dos drivers e stubs de teste a partir de especificações de testes não são suportados por essas ferramentas, ou seja, o desenvolvimento desses elementos, ainda requer muito tempo, custo e esforço por parte de o desenvolvedor, pois o mesmo tem que desenvolver (codificar) esses elementos.
Uma forma de minimizar esses problemas é possibilitar que o Engenheiro de Teste fique responsável por especificar os casos de teste.
Isso pode ser realizado usando uma notação padrão para especificação de teste de software, como por exemplo, UML, mais especificamente o U2TP.
Uma vez especificado um projeto de teste, o testador, que em nível de unidade corresponde ao desenvolvedor, fica responsável por executar estes testes.
Assim, para este trabalho dois papéis são definidos no processo de teste unitário, um Engenheiro de Teste e um Testador.
A o optar por o uso de ferramentas como XUnit, a questão é minimizar o custo e esforço necessário para a geração de drivers e stubs, o que é abordado neste trabalho através da geração automatizada.
Segundo, as técnicas de teste de software tradicionais, como as técnicas de diagramas UML.
A combinação de modelagem e de testes pode ser vista sobre duas perspectivas:
Teste Baseado em Modelos:
Consiste no desenvolvimento de artefatos de teste a partir de modelos UML existentes.
Em modelos UML são encontradas informações sobre testes.
Modelos UML fornecem a primeira informação para o desenvolvimento de casos de teste e suítes de teste usadas para testar um sistema.
Modelagem de Teste:
Consiste no desenvolvimento de artefatos de teste com a UML.
O desenvolvimento do teste é baseado no uso da UML e segue os mesmos princípios fundamentais, como qualquer outra atividade dentro de o processo de desenvolvimento do software.
A segunda perspectiva é o foco deste trabalho, onde os conceitos da U2TP são utilizados para modelar e especificar teste em nível de unidade.
Porém, a primeira perspectiva é fundamental para dar suporte ao desenvolvimento, modelagem e especificação de teste com o U2TP, pois é a partir de diagramas UML existentes (projetos de software existentes) que são especificadas informações sobre o que deve ou não ser testado.
Assim, o restante desse capítulo aborda como alguns diagramas da UML podem auxiliar a abstrair informações sobre teste em nível de unidade.
Primeiramente serão apresentados alguns diagramas da UML, descrevendo seus conceitos e sua utilidade dentro de o processo de desenvolvimento de software.
Em seguida, será abordado como estes diagramas podem ser utilizados para especificar informações sobre testes em nível de unidade.
Os exemplos descritos nas próximas seções são baseados num Sistema de Ponto de Venda, extraído de.
Diagramas de caso de uso são fundamentais para a fase inicial de análise num sistema.
São através dos casos de uso que são definidas as principais funcionalidades e os requisitos de um sistema.
Um diagrama de caso de uso é composto por:
Caso de Uso:
Descreve a funcionalidade de um determinado sistema.
Atores: Uma entidade externa ao sistema que, de alguma maneira, participa da história do caso de uso.
A Figura 6, extraída de, mostra um exemplo de um diagrama de caso de uso para o sistema de ponto de venda.
Cada caso de uso pode ser descrito detalhadamente, mostrando todo o fluxo de interações que devem ser executadas para satisfazer o caso de uso, são os chamados casos de uso expandidos.
Segundo, eles são úteis para obter uma compreensão mais profunda das funcionalidades do sistema.
A Figura 7, extraída de, ilustra o caso de expandido para o caso de uso Comprar Itens.
Diagramas de casos de uso são muito usados em testes funcionais.
Testes baseados em casos de uso podem ser divididos em dois grupos.
O primeiro grupo é baseado no próprio caso de uso, e é a partir deste que se definem os objetivos a serem testados, ou seja, as principais funcionalidades do sistema.
São testes de alto nível e são úteis em testes de integração e sistema.
O segundo grupo é baseado nos casos de uso expandidos, os quais oferecem informações sobre todos os passos de iteração para realizar uma dada funcionalidade.
Por exemplo, de acordo com o caso de uso expandido descrito anteriormente, é possível saber a seqüência de passos que devem ser seguidos para satisfazer o caso de uso Comprar Itens.
Por exemplo, na seqüência 2, pode ser gerado um caso de teste para saber se o código (UCP) é conhecido do sistema.
Outro caso de teste, é testar o total de uma venda, descrito na seqüência seja, testar se o sistema está fornecendo o troco correto para o cliente.
É muito importante ressaltar que muitas vezes um caso de uso expandido, analisado isoladamente, não fornece todas as informações necessárias para gerar casos de teste.
Por isso, é interessante analisar um caso de uso expandido em conjunto com outros diagramas da UML como, por exemplo, diagrama de seqüência, diagrama de classe e diagrama de atividades para então gerar os casos de teste.
Outra questão importante em relação a os casos de uso expandido são as pré e póscondições.
Sempre que elas aparecerem é comum realizar casos de testes para validar- las.
Diagrama de classes mostram a estrutura estática de um sistema.
Segundo, as informações típicas de um diagrama de classe neste nível incluem:
Classes, associações e atributos;
Interfaces, com suas operações e constantes;
Informação do tipo de atributo;
Navegabilidade e dependências.
Um diagrama de classes em nível de projeto enfatiza uma classe como uma entidade de software, ou seja, pode conter todas informações necessárias para que essa classe possa ser transformada numa classe em linguagem de programação (como por exemplo, uma classe Java).
A Figura 8 mostra o pacote Venda do Sistema Ponto de Vendas com duas classes:
Uma classe pode conter vários métodos.
Cada método que possui uma funcionalidade relevante, por exemplo, que efetua uma operação, ou um cálculo, é método candidato a ser testado.
Cada um desses métodos representa um caso de teste para a classe e juntos, esses casos de teste representam um suíte de teste para a classe.
As assinaturas dos métodos também são importantes para realizar os testes, pois mostram o tipo de retorno dos métodos, tipos de parâmetros e principalmente se existe alguma dependência de um método em relação a outros.
Os construtores de uma classe em nível de projeto também são usados em teste de unidade.
Um construtor é um conjunto de instruções criadas para criar e inicializar uma instância (um objeto).
Uma vez que os objetos são inicializados, os métodos que dependem da inicialização desses objetos podem ser testados.
Em o exemplo da Figura 8, e com base na descrição do caso de uso expandido Comprar Item da Figura 7, alguns casos de teste podem ser gerados.
Por exemplo, o método total da classe Venda deve ser testado para saber se o mesmo está calculando corretamente a compra de determinados itens de venda.
O método efetuarPagamento também da classe Venda deve ser testado para garantir que o troco seja devolvido corretamente ao cliente.
O método subTotal da classe LinhadeItemVenda deve ser testado para garantir que os subtotais de um item de venda são calculados corretamente.
Um diagrama de atividades descreve o fluxo de controle de um procedimento.
Segundo, um diagrama de atividades pode ser usado nas seguintes situações:
Para analisar um caso de uso:
Através de diagramas de atividades é possível compreender que ações precisam acontecer e quais são as dependências comportamentais entre eles.
Para compreender um sistema wokflow:
Um diagrama de atividades é muito útil para a compreensão de um sistema de negócio, mostrando como o negócio funciona e como ele pode mudar.
Crud ­ é a abreviação para as operações Create (criar), Retrieve (recuperar), Update (atualizar) e Delete (deletar).
Para descrever um algoritmo complicado:
Um diagrama de atividades pode mostrar todos os caminhos de execução de um algoritmo.
Um exemplo de um diagrama de atividades pode ser visto na Figura 9.
Em este exemplo, é mostrado o fluxo de execução da operação efetuarPagamento da classe Venda.
Segundo, um diagrama de atividades é usado principalmente para especificar testes estruturais.
Diagramas de atividades fornecem informações similares a um grafo de fluxo de controle (um teste tradicional de caixa branca), embora num nível mais alto de abstração.
Para testes unitários, diagramas de atividades fornecem medidas de cobertura de código.
Por exemplo, um diagrama de atividade pode mostrar todos os passos necessários para uma dada atividade.
Em o exemplo da Figura 9, o diagrama de atividades descreve as condições para o cálculo da operação efetuarPagamento.
De essa forma, existem duas situações a serem consideradas.
A primeira é quando a quantia fornecida é maior que o total.
A segunda é quando a quantia fornecida é menor que o total.
Portanto, estes dois caminhos, geram dois casos de teste para a operação, um teste positivo e um teste negativo.
Diagramas de atividades também são muito úteis para mostrar o fluxo de execução dos casos de teste, especificando a ordem em a qual os casos de teste devem ser executados.
O objetivo de um diagrama de seqüência é mostrar uma interação, isto é, uma seqüência de mensagens trocadas entre vários objetos num determinado contexto.
A Figura 10 ilustra um exemplo de um diagrama de seqüência para a operação teminarVenda, da classe Venda.
Diagramas de seqüência mostram todas as seqüências de mensagens trocadas entre os objetos.
Isto é importante, pois é possível saber que mensagem está sendo enviada, em que ordem e para qual objeto.
Esse comportamento pode ser usado no contexto de teste de unitário.
Em o exemplo do diagrama de seqüência da Figura 10, é possível verificar a seqüência de mensagens enviadas aos objetos para terminar uma venda.
Estas seqüências de mensagens podem ser validadas por casos de testes.
Segundo, alguns problemas típicos que podem ser descobertos através de testes baseados em diagramas de seqüência são:
Saídas incorretas ou ausentes;
Mensagem correta passada ao objeto errado;
Mensagem incorreta passada ao objeto correto;
Mensagem enviada para um objeto destruído (finalizado);
Exceção correta, mas gerada por o objeto errado;
Exceção incorreta gerada por o objeto correto.
Os diagramas de seqüência são muito úteis quando não se tem acesso à estrutura interna de uma classe, assim, é possível mostrar o comportamento das mensagens como uma caixa preta.
Este capítulo apresentou como alguns diagramas da UML fornecem informações úteis à especificação e projetos de teste em nível de unidade.
De essa forma, cada diagrama do modelo de projeto deve ser analisado em detalhes para transformar o mesmo num modelo de projeto de teste.
Este capítulo apresenta os principais elementos do perfil de teste da UML 2.
0. É apresentado um metamodelo baseado no MOF para teste.
Também serão descritos e discutidos os elementos apropriados para testes em nível de unidade.
UML 2.0 define uma linguagem para projetar, visualizar especificar, construir e documentar artefatos de testes para sistemas.
A linguagem para modelagem de testes pode ser usada para tecnologias de objetos e componentes e pode ser aplicada para testes de sistemas em vários domínios de aplicação.
O perfil de teste da UML pode ser usado somente para a manipulação dos artefatos de teste ou de uma maneira integrada com UML para a manipulação conjunta de um sistema com seus respectivos artefatos de teste.
O U2TP é baseada na especificação da UML 2.
0. Ele é definido usando a abordagem de metamodelagem da UML.
Sendo assim, o U2TP foi projetada com os seguintes princípios:·
Integração com a UML:
O Perfil de Teste da UML é definido na base do metamodelo definido no volume da superestrutura da UML 2.
0 e segue os principais Perfis da UML como definido no volume da superestrutura da UML 2.
0.· Reuso:
O Perfil de Teste da UML faz uso direto dos conceitos da UML e estende e adiciona novos conceitos somente quando necessários.
O U2TP está baseada no metamodelo MOF.
O MOF é o padrão da OMG para a construção de metamodelos.
É uma especificação que define uma linguagem abstrata para metamodelagem e um framework para especificação, construção e gerenciamento de metamodelos independentes de plataforma.
Exemplos de sistemas que usam o MOF incluem ferramentas de modelagem e desenvolvimento, sistemas data warehouse, repositórios de metadados, entre outros.
O U2TP está organizada em quatro grupos lógicos de conceitos:
Arquitetura de Teste -- define conceitos relacionados a estrutura e configuração de teste.
Dados de Teste -- define conceitos para dados de teste usados em procedimentos de teste.
Comportamento de teste -- define conceitos relacionados aos aspectos dinâmicos dos procedimentos de teste.
Tempo de Teste -- define conceitos quantificados por tempo para procedimentos de teste.
Os elementos mais importantes do U2TP estão listados na Tabela 1, adaptada de.
Esses elementos serão discutidos nas próximas seções.
Este grupo define os principais elementos e seus relacionamentos envolvidos num teste.
A Figura 11, extraída de, ilustra os principais elementos.
Descrição: O System Under Test (Sut) é o sistema sob teste, ou seja, o que está será testado.
Um Sut pode ter diferentes níveis de abstração:
Um sistema completo, um subsistema, um pacote, um único componente ou até mesmo uma única classe.
Como o U2TP é direcionado somente para testes de caixa preta, o Sut fornece somente um conjunto de operações através das interfaces disponíveis publicamente.
Nenhuma informação sobre a estrutura interna do Sut é disponível.
O Sut estende a metaclasse Property do metamodelo MOF.
Notação: A notação para o Sut é nomear o que se deseja testar com o estereotipo O Sut é usado dentro de o elemento TestContext (seção 4.3.2).
Descrição: Um TestContext (contexto de teste) é uma classe que representa o agrupamento de vários casos de teste, ou seja, representa o conceito conhecido como suíte de teste.
Um TestContext estende um Structured Classifier, outra metaclasse definida no metamodelo MOF.
Notação: A notação para o elemento TestContext é uma classe com o estereotipo Descrição:
O elemento TestControl (Controle de Teste) é uma especificação usada para determinar como o Sut deve ser testado para um determinado Contexto de Teste.
Permite especificar a ordem de execução dos casos de teste.
Descrição: Um TestComponent (Componente de Teste) é uma classe de um sistema em teste.
O objetivo de um TestComponent é ajudar a realizar o comportamento de um ou mais casos de teste.
TestComponents interagem com o Sut ou com outros TestComponents para realizar os casos de testes que são definidos dentro de o contexto de teste.
O elemento TestComponent estende um Structured Classifier.
Notação: A notação para o elemento TestComponent é uma classe com o estereotipo Descrição:
Arbiter é uma interface predefinida fornecida juntamente com o U2TP.
O propósito de uma implementação Arbiter é determinar o Verdict, ou seja, o resultado final para um caso de teste.
Descrição: Scheduler é uma interface pré-definida fornecida com o U2TP.
O propósito da implementação de um scheduler é controlar a execução de diferentes TestComponents.
O Scheduler mantém a informação sobre qual TestComponent está executando e colabora com o arbiter, para informar o Verdict final para o caso de teste.
Mantém o controle sob a criação e destruição do TestComponent e ele sabe quais TestComponents estão participando de cada caso de teste.
Este grupo define os conceitos necessários para representar todos os elementos que fazem parte dos aspectos dinâmicos dos procedimentos de teste.
A Figura 12, extraída de, ilustra os principais elementos.
Descrição Verdict é um tipo de dados enumeration prédefinido que contém os valores:
Fail, inconclusive, pass e error.
Pass: Indica que o caso de teste é completo e que o Sut se comportou como esperado.
Fail: Descreve que o propósito do caso de teste foi violado, ou seja, o resultado esperado foi diferente do resultado real.
Inconclusive: É usado quando nenhum valor &quot;Pass «ou &quot;Fail «pode ser fornecido.
Error: É usado para indicar erros (exceções) dentro de o sistema sob teste.
Um caso de teste (seção 4.4.2) sempre produz um dos Verdicts descritos acima.
O Verdict de um caso de teste é calculado por a interface Arbiter.
Descrição: Um TestCase (caso de teste) é uma especificação de uma situação particular para testar o sistema, incluindo o que testar, bem como entradas, resultados, e sob quais condições.
Um TestCase estende um Operator, uma metaclasse definida no metamodelo MOF e um Behavior, outra metaclasse definida no metamodelo MOF.
Restrições: O tipo de retorno de um caso de teste deve ser um Verdict.
O estereótipo de um caso de teste não pode ser aplicado a ambos:
O comportamento e sua especificação.
Se o estereótipo de um caso de teste for aplicado numa operação, o classifier (classe) desta operação tem que ter estereótipo TestContext aplicado.
Se o estereótipo de um caso de teste for aplicado a um comportamento, o comportamento desse caso de teste, tem que ter o estereótipo TestContext aplicado.
Notação: A notação para um caso de teste é uma operação com o estereótipo Este grupo contém os conceitos necessários para descrever os elementos de dados de teste usados para exercitar os casos de teste.
Esses elementos contêm os tipos de dados que são usados para execução de um ou mais casos de teste.
A Figura 13, extraída de, ilustra os elementos principais do grupo de dados de teste.
Descrição: Um DataPool representa um conjunto concreto de valores de dados que são usados para produzir o resultado de um caso de teste.
Um DataPool contém um ou vários DataPartition (seção 4.5.2), mas só pode estar associado a um TestContext ou TestComponent.
Um DataPool estende as metaclasses classifier e property do MOF.
Notação: A notação para um DataPool é uma classe estereotipada com Descrição:
Um DataPartition é usado para definir classes de equivalência para um determinado tipo de dados.
Um DataPartition também estende a metaclasse classifier do MOF.
Notação: A notação para o elemento DataPartition é uma classe com o estereótipo aplicado.
Descrição: Um DataSelector é uma operação que define como valores de dados ou classes de equivalência são selecionadas de DataPool ou DataPartition.
Um DataSelector também estende a metaclasse operation do MOF.
Notação: A notação para o elemento DataSelector é uma operação estereotipada com Este último grupo define um conjunto de conceitos para especificar restrições de tempo, e/ ou de observações de tempo.
O objetivo principal desse grupo é definir conceitos para restrições e controle do comportamento dos testes no que diz respeito ao tempo.
Os dois elementos principais desse grupo são:
Timer e TimeZone.
Descrição: Timer é uma interface predefinida fornecida no U2TP.
Um Timer é um mecanismo que pode gerar um timeout quando um valor especificado de tempo acontece.
Isto pode ser quando um intervalo de tempo pré-especificado expira num determinado momento (normalmente no momento em que o Timer é inicializado).
Descrição: Timezones servem como mecanismos de agrupamento para TestComponents em teste de sistema.
Cada TestComponents pertence a no máximo um timezone.
TestComponents com o mesmo timezone possuem a mesma percepção de tempo, por exemplo, possuem tempos sincronizados.
Esta seção apresenta um metamodelo padrão para o Perfil de teste da UML 2.
0, o qual é uma instância do MOF.
Este metamodelo é limitado aos elementos da arquitetura e comportamento de teste e é apresentado na Figura 14 extraída de.
A maioria dos elementos do Perfil de Teste apresentados anteriormente também estão presentes no metamodelo.
O elemento central dessa figura é o elemento &quot;TestContext», que tem associação com todos os demais elementos.
Ele representa o passo inicial para especificação da parte de arquitetura de teste, e a partir de ele, os demais elementos são instanciados e utilizados.
Cada elemento da Figura 14, como apresentado anteriormente, possui uma descrição, uma notação e tem um objetivo específico dentro de o perfil.
A Figura 15, extraída de, mostra os elementos principais do grupo de dados de teste.
O elemento central desse grupo é o DataPool.
O elemento DataPartition é usado obrigatoriamente sempre que o elemento DataPool for usado, por a associação de agregação entre esses dois elementos.
O elemento DataSelector, deve estar associado a no máximo um DataPool e um DataPartition.
A Figura 16, extraída de, fornece três interfaces que tecnicamente não fazem parte do metamodelo baseado no MOF, são elas:
Timer, Arbiter e Scheduler.
Os elementos apresentados nas seções anteriores são usados em todos os níveis de teste.
Em nível de unidade, os elementos apropriados e explorados nesse trabalho são apresentados na Figura 17.
A Figura 17 ilustra o metamodelo para representação de teste em nível de unidade para os elementos pertencentes aos grupos de Arquitetura de Teste (Sut, TestContext, TestComponent, TestCase, TestControl), Comportamento de Teste (Comportamento e Verdict) e Dados de teste (DataPool e DataPartition).
Como podemos observar por a Figura 17, a cardinalidade de algumas associaçõess mudaram, como é o exemplo da associação de TestContext com Sut, onde agora, um TestContext deve obrigatoriamente ter um ou mais Sut associados.
Assim, como este metamodelo é focado somente para teste de unidade, algumas restrições foram acrescentadas as associações entre os elementos.
Sut: Esse elemento é especificado para representar a unidade sob teste.
Sempre haverá no mínimo um Sut.
TestContext: Esse elemento é especificado para representar uma suíte de testes para a unidade a ser testada.
Assim, um TestContext tem que conter no mínimo um Sut e um Testcase.
TestCase: Esse elemento é especificado para representar os casos de teste em nível de unidade.
Sempre haverá no mínimo um caso de teste para testar o Sut.
TestComponent: Esse elemento é especificado como sinônimo de um &quot;stub «em teste unitário, ou seja, é usado para simular serviços explicitamente requisitados por o Sut.
Pode ser usado sempre que um ou mais casos de teste necessitar de serviços que não estejam disponíveis no projeto de teste.
TestControl: Esse elemento deve especificado para indicar a ordem de execução dos casos de teste sempre que for necessário.
Comportamento: Esse elemento é especificado para representar o comportamento de um caso de teste.
Precisa ser especificado para cada caso de teste.
Verdict: Esse elemento é especificado para especificar o veredito dos casos de teste.
DataPool: Esse elemento pode ser usado para representar um conjunto de valores concretos usados por um ou mais casos de teste para testar um determinado Sut.
DataPartition: Esse elemento pode ser usado para particionar os valores de DataPool quando for necssário.
Alguns elementos apresentados anteriormente possuem um mapeamento direto dos conceitos para a ferramenta JUnit.
A Tabela 2, adaptada de, apresenta esse mapeamento.
Um contexto de teste no JUnit é realizado como uma especialização (ou subclasse) de TestCase.
Sut Qualquer classe que possa ser testada no JUnit.
TestComponent Não há um mapeamento explicito desse elemento.
TestCase Um caso de teste é realizado no JUnit como uma operação pertencente a uma subclasse de TestCase.
TestControl Um TestControl é implementado no JUnit sobrecarregando o método runTest.
Verdict Em o JUnit os valores predefinidos para Verdict são:
Pass, fail e error.
Dados de Teste DataPool Qualquer classe com operações de acesso aos dados dessa classe.
DataPartition Qualquer classe com operações de acesso aos dados dessa classe.
DataSelector Uma operação de acesso a um datappol ou datapartition.
Uma metodologia para usar o U2TP é proposta em e.
Os autores assumem que o U2TP é usado efetivamente a partir de um modelo de projeto UML existente.
Quanto mais enriquecido de detalhes de informações for este modelo, mais fácil será aplicar o perfil para especificar os casos de teste para este modelo.
Também definem para cada grupo do U2TP quais elementos são obrigatórios e quais são opcionais.
Entretanto, na metodologia não há uma divisão desses elementos entre os níveis de teste (unidade, integração e sistema).
A metodologia está baseada na arquitetura MDA -- Model Driver Architecture e A idéia principal da metodologia é reaproveitar sempre que possível diagramas da UML do projeto de sistema para especificação de teste.
De essa forma foram descritos alguns pressupostos de como usar as notações da U2TP para cada grupo.
Para o grupo de arquitetura de teste deve- se especificar dois elementos que são obrigatórios:
Sut e TestContext.
O primeiro é especificado nomeando uma classe ou um objeto do modelo de sistema, como Sut, definindo o que será testado.
O segundo é especificado criando uma nova classe e nomeando essa como TestContext, listando todos seus atributos e casos de teste.
Outro elemento que pode ser especificado, mas que não é obrigatório, é o elemento TestComponent.
Os autores ressaltam que em nível de unidade esse elemento não é necessário.
Para definir a ordem de execução dos casos de teste sempre que necessário deve- se especificar o elemento TestControl.
Se existirem diagramas de atividades no modelo de projeto de sistema, cada atividade ilustra um caso de teste, e o fluxo das atividades descrevem o fluxo dos casos de teste na especificação do TestControl.
Se existirem diagramas de casos de uso no modelo de projeto de sistema, cada caso de uso descreve um caso de teste que pode ser especificado junto no TestControl.
Esse elemento é opcional para o grupo de arquitetura de teste.
Para especificação do comportamento dos casos de teste são usados diagramas de interação do modelo do sistema.
Com isso pode- se renomear ou agrupar instâncias e nomear com o estereótipo de acordo com seus papéis (por exemplo, TestComponent ou Sut).
É preciso nomear o elemento Verdict no final de cada especificação do caso de teste.
Normalmente um verdict num caso de teste é configurado com &quot;pass».
Pode- se definir os objetivos de teste para cada caso de teste.
Em testes de integração ou sistema, um objetivo de teste pode ser um caso de uso.
Esse elemento não é obrigatório.
Timers podem ser derivados de especificações de restrições de tempo com diagramas de seqüência ou diagrama de máquina de estados.
O autor ressalta que em nível de unidade timers não são usados.
Esse elemento também não é obrigatório.
De acordo com os autores, a grande idéia de transformar um projeto de sistema num projeto de teste é fortalecer a inclusão do teste cada vez mais cedo dentro de as fases de desenvolvimento de software e o reuso, quando possível, de alguns diagramas do modelo de projeto de sistema para o modelo de projeto de teste.
Esse capítulo apresentou os principais elementos do U2TP.
Cada elemento possui uma descrição, uma semântica e uma notação.
O metamodelo apresentado na seção 4.7 define como esses elementos se relacionam.
A seção 4.8 apresentou quais elementos do U2TP são apropriados para teste em nível de unidade, os quais serão explorados neste trabalho para geração automática de drivers e stubs para JUnit.
A geração proposta é baseada no refinamento do mapeamento dos conceitos do U2TP para os conceitos do JUnit, definido por o próprio U2TP.
Esse capítulo também apresentou uma metodologia para usar o U2TP.
Essa metodologia assume que o U2TP é usado efetivamente a partir de um modelo de projeto existente.
Assim, usando o U2TP é possível transformar um modelo de projeto existente num modelo de projeto de teste.
Esta metodologia será adotada neste trabalho.
O U2TP foi desenvolvido para facilitar a especificação, construção, documentação e visualização dos artefatos utilizados no processo de teste.
Ela é capaz de capturar todas informações que podem ser necessárias para representar diferentes processos de teste.
Por se tratar de um modelo UML, o U2TP segue um padrão que pode ser usado independente de linguagem de programação.
Com isso, é possível especificar teste num nível mais alto de abstração.
Permite que testes sejam especificados como uma caixa preta.
U2TP permite a integração com diferentes ferramentas, e em diferentes domínios de aplicação.
Através de ferramentas de modelagem com suporte a exportação/ importação de documentos como XMI (XML Metadata Interchange) é possível à troca, ou seja, o intercâmbio entre modelos, o que facilita a manutenção e portabilidade dos artefatos de teste.
Outra vantagem do U2TP é a possibilidade de geração de código, ou seja, possibilita a geração de testes a partir de aspectos estruturais (estáticos) e comportamentais (dinâmicos) de modelos UML.
Assim, é possível usar seus conceitos para fazer o mapeamento dos mesmos com diferentes ferramentas de testes e para diferentes linguagens de programação.
Os trabalhos relacionados apresentados neste capítulo estão divididos em três grupos:
Geração automatizada de drivers a partir de ambientes integrados de desenvolvimento de Software (Ide);
geração automatizada de casos de teste para JUnit e geração automatizada de drivers a partir de modelos UML.
Estes são discutidos e comparados ao final do capítulo.
Atualmente o uso de Ides (Eclipse, NetBeans, JBuilder) como ambiente de desenvolvimento de software está bastante difundido.
Alguns dos motivos incluem:
Suporte a vários padrões, portabilidade, flexibilidade e também possibilidade de integração com outras ferramentas, como por exemplo, o JUnit.
A ferramenta JUnit, foi adaptada a uma variedade de Ides que permitem armazenar todo o código de teste num repositório facilitando assim a manutenção e documentação do código desenvolvido.
Essas Ides possibilitam que a estrutura do driver de teste possa ser gerada automaticamente.
Segundo, o principal objetivo das Ides é fornecer meios simples e interativos para criar métodos e classes de teste, sem a necessidade de escrever o driver de teste.
Já em, o autor ressalta que a grande dificuldade em relação a a geração do driver de teste é a codificação automatizada da parte dinâmica dos casos de teste, a qual não é contemplada nestas Ides.
Por exemplo, no Eclipse e NetBeans, para gerar o Driver de teste o desenvolvedor precisa selecionar a classe que deseja testar e os métodos desta.
Uma vez selecionados, a estrutura estática do driver é gerada automaticamente.
A Figura 18 mostra esse procedimento no Eclipse, e o esqueleto do driver correspondente gerado.
Entretanto, não existe uma especificação do comportamento dos casos de teste, ou seja, o próprio desenvolvedor é o responsável por especificar e codificar o comportamento dos casos de teste.
A geração dos Stubs de teste também não é suportada por essas Ides ficando, portanto, de responsabilidade do programador gerar esse elemento.
Uma abordagem para geração automatizada de drivers de teste para a ferramenta JUnit é encontrada em.
A abordagem usa uma linguagem de especificação formal (JML ­ Java Modeling Language) para verificar assertivas em tempo de execução.
Em essa abordagem, ao invés de especificar as saídas esperadas (oráculos de teste) e comparar então com aquelas produzidas por a execução do teste, o comportamento do método testado é monitorado para decidir se o teste passou ou falhou.
Este monitoramento é feito usando a linguagem de especificação formal JML.
A Figura 19, extraída, ilustra um exemplo de especificação JML para uma classe denominada Person.
Especificações formais incluem invariantes, pré e pós-condições.
De essa forma, é assumido que tais especificações são suficientes para mostrar o comportamento desejado para o caso de teste.
Porém, a qualidade gerada dos oráculos de teste dependerá da qualidade das especificações das pós-condições, que são de responsabilidade do usuário (programador).
Como podemos observar por a Figura 19, para cada método testado, é especificado o comportamento correspondente em JML.
Assim, através das variáveis:
Requires, assignable e ensures são especificadas as condições para a execução de cada caso de teste.
A variável signals é responsável por lançar uma exceção no caso de alguma condição for violada.
De essa forma, o comportamento do método testado é monitorado e os drivers de teste são gerados automaticamente, bem como as saídas esperadas para cada caso de teste.
Porém, a configuração dos valores de entrada (por exemplo, configuração do método setup do Junit) é feita manualmente por o programador.
A geração de stubs de teste também não é contemplada nessa abordagem.
Em é proposta a geração automatizada de casos de testes a partir de programas orientados a aspectos AOP ­ Aspect-Oriented Programming.
Essa abordagem usa a linguagem AspectJ, uma extensão para Java de linguagem orientada a aspectos.
AspectJ adiciona alguns novos conceitos na linguagem Java como:
Join points, pointcuts, advice e aspect.
Também é definida uma linguagem para teste denominada AOTDL (Aspect-Oriented Test Description Language) ­ linguagem de descrição de teste orientada a aspectos.
A idéia de usar AOP é dividir aspectos genéricos da linguagem em aspectos específicos da aplicação, como por exemplo, aspectos de pré e pós-condições, aspectos de monitoração, aspectos de comportamento, etc..
De essa forma foi definida a AOTDL como aspecto para teste.
A AOTDL envia mensagens em tempo de execução à unidade testada (métodos de classes) para identificar oráculos de teste.
A Figura 20, extraída de, ilustra a visão geral da proposta.
Uma ferramenta denominada JAOUT foi desenvolvida para prova de conceitos.
De acordo com a Figura 20, a AOTDL é traduzida para a ferramenta JAOUT.
Em seguida, os aspectos são compilados para arquivos Java (arquivos de classes).
A ferramenta então gera classes de testes correspondentes para a ferramenta JUnit para a unidade a ser testada.
Os arquivos de classes podem servir como oráculos de teste.
Finalizando, abastecida com as entradas de testes geradas automaticamente por a classe JMLAutoTest, a unidade testada é executada, e os resultados são verificados em tempo de execução através do lançamento de exceções.
A Figura 21, extraída de, ilustra exemplos de AOP e AOTDL para uma classe denominada Stack.
Outro tipo de abordagem, sendo esta baseada em modelos UML, é um Add-in que a ferramenta Rational Rose disponibiliza, denominado TestExpert.
Este Add-in propõe a geração automatizada da estrutura do Driver de teste para as ferramentas JUnit e cppUnit, através da geração de classes de teste baseado em modelos UML usando templates de teste (das ferramentas JUnit e Cppunit).
Porém, o comportamento do teste descrevendo a lógica de execução do teste não é gerado.
A Figura 22 mostra a visão geral da abordagem (geração para cppUnit).
De acordo com a Figura 22, baseado nas informações contidas no modelo Rose, um script extrai classes de código de teste.
Esse script então preenche o template das classes de teste (JUnit e CppUnit).
O template usa as classes internas do JUnit e cppUnit para gerar o código de teste automaticamente.
Para geração do código de teste, uma ou mais classe do modelo Rose devem ser selecionadas e para cada uma destas, as operaçõea a serem testadas.
Feito isso, os drivers são gerados automaticamente.
Uma vantagem dessa abordagem é a possibilidade de geração da parte estática do driver de teste para ambas as ferramentas:
JUnit e CppUnit.
Porém, a parte dinâmica dos casos de teste não é gerada automaticamente.
A geração de stubs também não é contemplada nessa abordagem.
Outra abordagem que utiliza a UML para gerar parcialmente Drivers de teste para JUnit é encontrada em.
Em esta abordagem, o cenário para geração dos Drivers de teste utiliza diagramas de seqüência.
A Figura 23, extraída de, ilustra o cenário proposto para geração dos Drivers de teste.
Primeiramente os casos de teste são modelados com diagramas de seqüência, assumindo que casos de teste são tipicamente baseados num conjunto de mensagens enviadas por um único objeto do diagrama de seqüência.
O modelo UML é então exportado para um arquivo XMI que é carregado para a ferramenta SCENTOR.
SCENTOR é uma ferramenta desenvolvida para validar o mapeamento proposto nessa abordagem.
Também é possível carregar uma especificação de teste já previamente especificada (no formato XML).
É necessário adicionar valores concretos para cada método chamado por o objeto e especificar o resultado esperado.
Também é necessário especificar os métodos setUp e tearDown.
Seqüência. Uma vantagem dessa abordagem é poder gerar junto com os casos de teste, seus respectivos comportamentos, embora isso não seja totalmente automatizado, pois é preciso a interação do usuário para preencher as entradas e as saídas para cada objeto testado.
Também é importante ressaltar que esse mapeamento não explora os conceitos específicos de teste do U2TP.
Essa abordagem também não contempla a geração de Stubs de teste.
Em, também é proposto um trabalho muito parecido com a abordagem de.
Em essa abordagem é apresentado um conceito para geração de testes automatizados para aplicações orientadas a objetos através de uma ferramenta denominada SEDITEC, a qual implementa esses conceitos para aplicações Java.
O autor usa diagramas de seqüência para geração de testes automatizados.
Em esta abordagem, toda classe e seus respectivos métodos, têm seus comportamentos especificados por um ou mais diagrama de seqüência, o autor descreve sete itens que ele considera fundamental para tornar um diagrama de seqüência &quot;testável», ou seja, para especificações de teste.
Os diagramas de seqüência são completados com um conjunto de dados de casos de teste que consistem de valores de entradas e valores de retornos para os métodos chamados no diagrama.
Diagramas de seqüência também podem ser combinados, dessa forma, Stubs de teste também podem ser gerados.
Porém, a geração de stubs nessa abordagem está relacionada com as pré-condições para a execução dos testes.
Por exemplo, num diagrama de seqüência um objeto pode ser criado com seus valores iniciais, e em outro diagrama, este mesmo é testado através da seqüência de mensagens enviadas a ele.
Essa abordagem também permite a geração dos casos de teste para a ferramenta JUnit, embora não haja um mapeamento direto destes testes com os conceitos do JUnit.
Para validação da abordagem, foi desenvolvida uma ferramenta denominada SEDITEC que suporta a execução de diagramas de seqüência testáveis para aplicações Java.
A ferramenta importa extensões de ferramentas Case, como por exemplo, Together2, ou arquivos no formato XML.
De essa forma é possível:
Combinar diagramas de seqüência;
Especificar um conjunto de dados de valores de entrada para cada diagrama de seqüência e executar suítes de testes.
O principal objetivo dessa abordagem é introduzir o teste já nas primeiras fases de desenvolvimento do software, através da validação do comportamento das classes especificadas por diagramas de seqüência.
Essa abordagem gera os drivers de teste com os respectivos comportamentos sem nenhum tipo de interação, embora o driver gerado seja específico para a ferramenta SEDITEC.
Também como em, as especificações de testes não exploram conceitos específicos de teste do U2TP.
O que se pôde observar nos trabalhos descritos neste capítulo, é que eles não oferecem meios eficientes para gerar todo código de teste.
Os seguintes critérios foram utilizados para analisar cada uma das propostas descritas:
Usa diagramas UML para especificação do teste:
Quais diagramas UML são usados?
Interação do Usuário:
É necessário algum tipo de interação do usuário para geração do código de teste?
Geração total do código:
Todo código de teste é gerado automaticamente, incluindo Drivers e Stubs, com o respectivo comportamento dos casos de teste?
Together é uma ferramenta de modelagem da Borland que tem por finalidade fornecer suporte nas áreas de análise de negócio, projeto, arquitetura e desenvolvimento.
Utiliza conceitos específicos do U2TP:
São utilizados conceitos do U2TP para especificação do teste?
Geração para JUnit:
A geração do código tem como alvo a ferramenta JUnit?
Geração de Stubs de teste:
Suporta a geração de stubs?
Através da análise da Tabela 3, as seguintes considerações podem ser formuladas:
A maioria das abordagens usam diagramas da UML para geração do código, exceto as Ides e especificações JML e AOTDL.
Todas abordagens requerem algum tipo de interação do usuário para gerar o código de teste automaticamente, exceto em SEDITEC, onde a ferramenta gera automaticamente todo código de teste;
Apenas em SEDITEC é gerado todo o driver de teste, incluindo o comportamento dos casos de teste e stubs de teste, contudo, esta não enfoca a ferramenta JUnit;
Nenhuma das abordagens descritas utiliza os conceitos próprios do U2TP para geração do código de teste;
Assim, uma vantagem do presente trabalho, não encontrada em nenhum trabalho descrito anteriormente, é a possibilidade de gerar todo código de teste incluindo os Drivers e Stubs sem requerer nenhum tipo de interação do usuário.
Outra vantagem é que o stub de teste gerado no presente trabalho é somente o necessário para a execução do teste, diferente de SEDITEC, que gera stubs representando apenas pré-condições para a execução dos testes.
A automação de testes já é uma realidade atualmente no processo de teste, pois ajuda a reduzir o tempo gasto para execução dos testes.
Ferramentas para automação de testes estão bem difundidas, especialmente ferramentas para teste de unidade.
As ferramentas da família XUnit vêm sendo cada vez mais utilizadas no processo de teste unitário, pois ajudam a diminuir o tempo gasto para execução dos testes e possibilitam a verificação automatizada dos resultados.
A ferramenta JUnit em particular, foi adaptada a uma variedade de Ides que facilitam seu uso.
Entretanto, um problema comum encontrado nessas ferramentas é a necessidade de codificação dos drivers e stubs de teste, pois muito custo e esforço ainda são gastos para codificar esses elementos, o que muitas vezes inviabiliza o uso dessas ferramentas.
Uma forma de resolver esse problema é a possibilidade de gerar esses elementos automaticamente a partir de algum tipo de especificação em mais alto nível.
O U2TP, por possuir um conjunto de elementos e conceitos específicos para teste, permite o mapeamento para diferentes ferramentas como JUnit e TTCN-3.
Além de permitir esse mapeamento, ele também permite representar o processo de teste num nível mais alto de abstração, através de notações UML.
Com isso, é possível usar esta notação para representação de testes voltados a diferentes linguagens de programação, além de favorecer o entendimento e a documentação dos artefatos de teste.
Sendo assim, o objetivo desse trabalho é gerar automaticamente drivers e stubs de teste para ferramenta de teste unitário JUnit a partir de especificações de teste unitário modeladas com a U2TP.
As contribuições deste trabalho incluem:
Diminuir o custo e esforço gasto para codificação de drivers e stubs de teste, uma vez que esses elementos são gerados automaticamente;
Fortalecer o uso do U2TP para especificação de teste, especialmente testes unitários;
Aumentar a qualidade do código de teste gerado, uma vez que a especificação do teste é feita num maior nível de abstração (UML);
Fortalecer a abordagem sugerida na literatura para realização de teste unitário, a qual difere a pessoa que especifica e projeta o teste (engenheiro de teste), daquela que executa o teste (testador).
Isto diminui problemas graves como:
Com base nos objetivos descritos anteriormente, esse capítulo apresenta a proposta do presente trabalho.
Como podemos observar na Figura 24, como entrada para a geração do código tem- se o modelo de projeto do sistema em UML e o modelo de projeto de teste em U2TP.
Os modelos de projeto e de teste devem respeitar uma série de pressupostos assumidos neste trabalho, discutidos na Seção 6.2.
Esses dois modelos são gerados a partir de uma ferramenta de modelagem.
Esta deve dar suporte à importação/ exportação de documentos XMI, tanto para diagramas estruturais como comportamentais da UML.
A ferramenta exporta um documento XMI representando estes dois modelos.
A geração dos drivers e stubs correspondentes é realizada em duas etapas, Extração e Geração.
A extração (Figura 24, item 6) é baseada em dois modelos adotados neste trabalho, a saber Modelo de Mapeamento U 2 TP-JUnit e Modelo de Mapeamento U 2 TP-XMI.
O Modelo de Mapeamento U 2 TP-JUnit (Figura 24, item 2) define quais elementos do U2TP são necessários para geração de drivers e stubs para ferramenta JUnit.
O Modelo de Mapeamento U 2 TP-XMI (Figura 24, item 4) define quais rótulos (tags) do documento XMI correspondem aos conceitos buscados e como os relacionamentos entre estes devem ser explorados.
O extrator então instancia o Modelo de Mapeamento U 2 TP-JUnit com base no documento XMI recebido como entrada e juntamente com o Analisador (Figura 24, item 5) captura todos elementos que comporão os drivers e stubs para a ferramenta JUnit.
Então, o Gerador de Código (Figura 24, item 7) gera os elementos seguindo o template do JUnit (Figura 24, item 3).
Como saída tem- se a geração automatizada de um driver para ferramenta JUnit e stubs de teste na linguagem Java.
É importante ressaltar que o processo requer o mínimo de interação com o usuário e a geração do código e totalmente automatizada.
As próximas seções descrevem detalhadamente cada um das etapas da Figura 24.
Este trabalho adota a metodologia de.
Além de isto, define quais são os pressupostos necessários para especificar e modelar teste em nível de unidade com o U2TP a fim de gerar automaticamente os drivers e stubs de teste.
Estes pressupostos estão divididos em dois grupos:
Projeto de Software e Projeto de teste.
Assume- se a existência de um modelo de projeto UML correspondente ao que será testado.
Este deve conter obrigatoriamente um diagrama de classes em nível de projeto, pois a partir deste, métodos de classes podem ser testados.
Outros diagramas são opcionais (diagramas de caso de uso expandido, diagramas de seqüência e diagramas de atividade).
Entretanto, se cada classe do modelo de projeto tiver seu comportamento especificado por diagramas de seqüência, estes poderão ser utilizados para gerar Stubs de teste.
Também, devese mencionar que para especificar os casos de teste, embora não seja obrigatório, é interessante que o modelo de projeto de sistema contenha diagramas de casos de uso expandido, para a partir destes, derivar os métodos mais relevantes a serem testados.
Assume- se a definição de um pacote de teste.
Em a explanação que segue, será apresentado um exemplo baseado num modelo de projeto de software extraído de.
Em seguida, esse modelo de projeto de software será transformado num modelo de projeto de teste, sobre o qual serão discutidos e exemplificados os pressupostos assumidos.
A Figura 25 ilustra o pacote Vendas do sistema.
Os elementos especificados para o grupo de arquitetura de teste são especificados no modelo de projeto de software (Sut e TestComponent) e no modelo de projeto de teste (TestContext, TestCase, TestControl e TestComponent).
Todas as classes do modelo de projeto de software que serão testadas devem ser estereotipadas com como no projeto ilustrado na Figura 25.
Deve haver uma e somente uma classe TestContext estereotipada com Deve haver no mínimo um caso de teste especificado dentro de a classe, cada qual representado através de uma operação estereotipada com A Figura 26 ilustra o novo pacote para teste unitário denominado TestVenda.
Em o pacote foi especificado um testcontext, denominado TestVenda com três casos de teste:
O elemento TestComponent pode ser especificado tanto no modelo de Projeto de Software como no modelo de Projeto de Teste:
A) Projeto de Teste:
Se um caso de teste necessitar de uma funcionalidade que não esteja definida nos Sust (exemplo do caso de teste testSubTotal), pode- se especificar uma nova classe (desde que a mesma não esteja no projeto de software) com o mínimo de funcionalidades necessárias para auxiliar na execução de um ou mais casos de teste.
Esta classe também deve ser estereotipada com como ilustrado na Figura 26.
Somente o atributo preço foi definido, juntamente com seus métodos acessores e modificadores.
Vale ressaltar que para o exemplo da Figura 25, não é necessário especificar elemento TestComponent, pois classe EspecificacaodeProduto já está no modelo de projeto de software e pode ser usada para auxiliar na execução do caso de teste testSubTotal.
Assim, o testcomponent foi especificado no exemplo da Figura 26 somente para descrever o contexto em que ele poderia ser usado.
B) Projeto de Software:
Pode- se estereotipar classes do modelo de projeto de software com toda vez que a mesma for usada para auxiliar na execução de um ou mais casos de.
De essa forma, a classe EspecificacaodeProduto da Figura 25 também poderia ser um testcomponent, e poderia ser estereotipada com Em este exemplo, ela não foi especificada no modelo de projeto de software porque a classe EspecificacaodeProduto será interpretada como um Stub de teste.
Cabe salientar que se no modelo de projeto de sistema não tiver diagramas de seqüência, não será possível gerar os Stubs de teste, exceto no caso em que o mesmo é gerado a partir de o elemento TestComponent.
O elemento TestControl, se adotado, deve ser especificado através de um diagrama de atividades.
A Figura 27 ilustra um exemplo de como usar esse elemento.
Cada atividade do diagrama deve conter o nome igual ao respectivo caso de teste.
Também devem possuir o estereótipo Se o elemento TestControl não for adotado, os casos de testes serão executados na mesma ordem em que eles foram definidos na classe TestContext.
Para o grupo de comportamento de teste são especificados os elementos testcase e verdict, os quais são especificados no modelo de projeto de teste.
Para especificar o comportamento de um caso de teste devem ser usados diagramas de seqüência.
A Figura 28 ilustra o comportamento para o caso de teste subTotal da classe LinhadeItemVenda.
Os pressupostos necessários para modelar o comportamento de um caso de teste através de um diagrama de seqüência são descritos abaixo:
TestComponent ou de qualquer classe do modelo de projeto, que será interpretada com um TestComponent.
Estas instâncias devem ser nomeadas.
É importante ressaltar que através das novas notações da UML 2.
0, é possível representar as pré-condições com referências a outros diagramas de seqüência.
Mas como a maioria das ferramentas de modelagem atuais ainda não suportam a UML 2.
0, essa notação não foi adotada neste trabalho.
A Figura 30 mostra esta notação para o comportamento do caso de teste testSubtotal com referência a o diagrama da Figura 29.
Também é possível representar as pós-condições para os casos de teste.
De a mesma forma que as pré-condições, é preciso definir uma nova operação na classe TestContex, e estereotipar- la com (estereotipo também não fornecido por o U2TP).
As póscondições também são representadas por um diagrama de seqüência que também deve ter o mesmo nome da operação estereotipada com associado ao diagrama.
A Seção 4.8 descreve quais elementos do U2TP são apropriados para especificação do teste unitário.
Este trabalho adota os elementos pertencentes à arquitetura de teste (TestContext, Sut, Testcomponent, TestCase e TestControl) e Comportamento de Teste (TestCase e Verdict).
O grupo Dados de Teste, embora importante, não foi adotado neste trabalho por a complexidade de gerar esses elementos no código correspondente à ferramenta JUnit.
A Tabela 2, apresentada no Capítulo 4, mostra como os elementos do U2TP são mapeados para os conceitos correspondentes na ferramenta JUnit.
Além destes, foram acrescentados neste trabalho dois novos elementos ao U2TP para especificação de testes, a saber Configuration e Stub.
O diagrama de classes da Figura 31 apresenta todos os elementos usados para geração de código no JUnit.
As classes na cor branca representam os conceitos adotados do U2TP e as classes em cor escura representam os novos elementos.
Para cada elemento apresentado na Figura 32, a Tabela 4 descreve como esses elementos são representados no JUnit.
É representado como um atributo, uma variável de instância no JUnit.
TestComponent é representado como um atributo, uma variável de instância no JUnit.
Setup representa todos os objetos criados dentro de o método setUp.
Teardown representa a finalização dos objetos dentro de o método Teardown.
TestCase é representado como um método no JUnit.
Esse método deve TestControl é representado no JUnit sobrecarregando o método runTest.
Verdict é representado através de assertivas usadas nos casos de teste.
Comportamento define o comportamento de cada caso de teste, e também o comportamento do elemento SetUp e Teardown.
Stub é representado como um atributo, uma variável de instância no JUnit.
Como podemos observar por a Tabela 4, cada elemento do U2TP é representado de uma maneira no JUnit.
Assim, para fazer o mapeamento desses elementos para o código correspondente no JUnit, é usado um template que define a representação da estrutura do Driver do JUnit.
Estes elementos foram adotados para este trabalho por possuírem esse mapeamento direto para o conceitos do JUnit.
Entretanto, os elementos pertencentes ao grupo Dados de Teste (DataPool e DataPartition) não foram definidos no Modelo de Mapeamento para ferramenta JUnit.
O motivo por o qual não foi possível fazer o mapeamento destes elementos para o código equivalente a ferramenta JUnit foi a complexidade para gerar os mesmos.
De acordo com o template da Figura 32, a linha 1 representa o pacote do elemento TestContext.
A linha 2 representa o pacote do próprio JUnit.
As linhas 3, 4 e 5 representam os pacotes das classes Sut, TestComponent e Stub respectivamente.
As linhas 7 e 8 representam os pacotes do JUnit (esses pacotes são gerados se o elemento testcontrol for especificado).
A linha 9 representa o elemento TestContext.
As linhas 10, 11 e 12 representam a declaração dos elementos Sut, TestComponent e Stub respectivamente (somente o elemento Sut é obrigatório).
As linhas 13 a 16 representam o método construtor do TestContext que também só é gerado se o elemento testcontrol for especificado.
As linhas 16 a 20 representam o método Setup do JUnit.
De a mesma forma, as linhas 21 a 24 representam o método Teardown do JUnit.
As linhas 25 a 29 representam um caso de teste.
Dentro de o corpo do caso de teste, as linhas 26 a 28 representam seu comportamento.
Finalizando, as linhas 30 a 35 representam o elemento TestControl, que no JUnit é implementado através do método TestSuite.
O driver de teste apresentado na Figura 33 ilustra a representação dos elementos descritos na Tabela 4 para o código correspondente para o JUnit baseado neste template, considerando o exemplo do sistema Venda apresentados nas Figuras 25, 26, 27, 28 e 29.
O código correspondente ao elemento Stub é ilustrado na Figura 34.
Private double preco;
Esta seção apresenta o modelo de mapeamento dos elementos do U2TP para o documento XMI.
Um documento XMI -- XML Metadata Interchange é um tipo de arquivo XML Extensible Markup Language que permite a codificação de modelos UML em XML.
É baseada no MOF e ambos são padrões adaptados por a OMG.
Um documento XMI utiliza o MOF como metamodelo e XML como linguagem padrão para formatação dos dados a serem transferidos, mapeando de MOF para XML.
Como a UML também é baseada na MOF, o XMI apresenta- se como um formato de intercâmbio.
Portanto, um documento XMI é um documento escrito em XML, que utiliza tags definidas por a especificação do XMI para representar as informações.
Um documento XMI possui um arquivo DTD -- Document Type Data (definição do tipo de documento) o qual define a sua estrutura.
Cada DTD usado por um documento XMI deve satisfazer os seguintes requisitos:
Todo elemento XML definido por uma especificação XMI deve ser declarado num Cada construção de metamodelo (classe, atributo e associação) deve ter uma declaração de elemento correspondente;
Qualquer elemento XML que represente extensões do metamodelo deve ser declarado num DTD externo ou interno.
A partir de o XMI, foram identificados quais elementos XML estavam envolvidos na descrição dos elementos utilizados neste trabalho tanto do modelo de projeto de sistema quanto no modelo de projeto de teste com o U2TP e extensões propostas.
Estes são apresentadas na Figura 35.
O modelo apresentado na Figura 35 descreve todas as tags (rótulos) e seus relacionamentos que são usados para mapear os elementos do U2TP.
A Tabela 5 descreve como os elementos do U2TP são mapeados para o modelo XMI.
Este capítulo descreve a transformação dos elementos contidos no documento XMI para os conceitos do JUnit.
Essa transformação é composta por algoritmos extratores que têm por objetivo mapear os elementos do JUnit para classes e, através do gerador de código, gerar os drivers e stubs de teste.
Primeiramente será apresentado o analisador (parser) usado neste trabalho, depois será apresentada uma descrição dos elementos do modelo XMI.
Finalizando o capítulo, é apresentado o funcionamento do extrator de código, dos algoritmos de mapeamento e do gerador do código.
Um analisador, também conhecido como parser, faz a análise num determinado conteúdo e/ ou documento para ver se ele está de acordo com as regras de uma determinada linguagem e/ ou estrutura.
Em arquivos XML, um parser verifica se a sintaxe está correta, ou seja, se as tags estão montadas de forma correta.
Atualmente para manipulação de documentos XML os parsers mais usados atualmente são:
Dom, Sax, STaX, JAXB e Beans.
Para este trabalho foi usado o parser Dom -- Document Object Model.
Ele é o mapeamento para Java do padrão Dom do W3C.
Como os elementos do JUnit estão distribuídos por todo o documento XMI sem nenhuma ordem pré-definida, o parser Dom permite armazenar esses elementos e um modelo orientado a objetos representando os mesmos em memória para que estes possam ser manipulados.
Assim a idéia básica é transformar um documento XML em objetos.
O analisador Dom transforma o documento numa árvore de &quot;nós «(nodos) que reproduz a estrutura de itens do documento.
A Figura 36, adaptada de, ilustra o funcionamento básico do analisador Dom.
Conforme ilustra a Figura 36, vários métodos na interface Nodo do Dom define relacionamentos entre os nodos que promovem formas de movimentação por as conexões entre eles.
Em o exemplo da Figura 37 é ilustrado um nodo (objeto) equivalente a tag e seus relacionamentos.
Note que o nodo tem como pai o nodo e como filho o nodo Se existir mais de uma tag «no documento XMI, cada tag corresponde a um nodo (objeto).
De essa forma, um conjunto de nodos relacionados a uma mesma tag forma uma coleção de NodeList, ou seja, uma lista de nodos rotulados com uma dada tag.
Por exemplo, uma NodeListPackage é uma lista de nodos Node Package.
Esta seção descreve os elementos do modelo XMI apresentado na Seção 6.5, ou seja, serão descritos quais atributos serão utilizados para capturar os elementos do documento XMI.
Assim, cada tag juntamente com os atributos usados para capturar os elementos são descritos a seguir:
A tabela abaixo ilustra os atributos usados deste nodo:
Atributos Usados xmi.
Id name namespace Descrição identificador do pacote nome do pacote identificador do pacote o qual o pacote pertence Nodo Lista de Nodos NodePackage Representa todos os nodos classes declarados no documento XMI.
A tabela abaixo ilustra os atributos usados deste nodo:
Atributos Usados xmi.
Id name namespace Descrição Nodo Lista de Nodos identificador da classe nome da classe identificador do pacote à qual a classe pertence NodeClass Representa todos os nodos diagramas declarados no documento XMI.
A tabela abaixo ilustra os atributos usados deste nodo:
Atributos Usados xmi.
Id name diagramType onwer Descrição Nodo Lista de Nodos identificador do diagrama NodeDiagram NodeListDiagram nome do diagrama tipo de diagrama identificador dos objetos declarados dentro de o diagrama DiagramElement\&gt;:
Representa todos os elementos filhos do nodo Diagram.
A tabela abaixo ilustra os atributos usados deste nodo:
Atributos Usados subject Descrição Nodo Lista de Nodos identificador NodeDiagramElement NodeListDiagramElement objetos do diagrama Interaction\&gt;:
Representa todos os nodos interações dos diagramas de seqüência definidos no documento XMI.
A tabela abaixo ilustra os atributos usados deste nodo:
Atributos Usados xmi.
Id Descrição Lista de Nodos identificador da interação do NodeInteraction NodeListInteraction diagrama (diagrama de seqüência) nome da interação (nome do diagrama de seqüência) name Nodo ClassifierRole\&gt;:
Representa todos nodos objetos declarados nos diagramas de seqüência definidos no documento XMI.
A tabela abaixo ilustra os atributos usados deste nodo:
Atributos Usados xmi.
Id name base Descrição Nodo Lista de Nodos identificador do objeto NodeClassifierRole NodeListClassifierRole nome do objeto identificador da classe que o objeto instancia Message\&gt;:
Representa todos os nodos mensagens dos diagramas de seqüência definidos no documento XMI.
A tabela abaixo ilustra os atributos usados deste nodo:
Atributos Usados Descrição name nome da mensagem sender identificador do objeto que envia a mensagem receiver identificador do objeto que recebe a mensagem Nodo NodeMessage Lista de Nodos NodeListMessage Stereotype\&gt;:
Representa todos os nodos estereótipos declarados no documento XMI.
A tabela abaixo ilustra os atributos usados deste nodo:
Atributos Usados Descrição Nodo Lista de Nodos xmi.
Id identificador do estereotipo NodeStereotype NodeListStereotype name nome do estereotipo extendElement Identificador da classe e/ ou operação que o estereotipo estende DataType\&gt;:
Representa todos os nodos tipos de dados declarados no documento XMI.
A tabela abaixo ilustra os atributos usados deste nodo:
Atributos Usados xmi.
Id name visibility Descrição identificador do tipo de dados nome do tipo de dados visibilidade do tipo de dados Nodo Lista de Nodos NodeDataType NodeListDataType Operation\&gt;:
Representa todos os nodos operações de classes declaradas no documento XMI.
A tabela abaixo os atributos usados deste nodo:
Atributos Usados xmi.
Id name visibility Descrição identificador da operação nome da operação visibilidade da operação Nodo Lista de Nodos NodeOperation NodeListOperation Parameter\&gt;:
Representa todos os nodos parâmetros das operações definidos no documento XMI.
A tabela abaixo ilustra os atributos usados deste nodo:
Atributos Usados xmi.
Id name kind type Descrição Nodo Lista de Nodos identificador do parâmetro NodeParameter NodeListParameter nome do parâmetro esse atributo tem dois tipos:
Atributos Usados Descrição xmi.
Id identificador do atributo name nome do atributo type identificador do tipo de dados do atributo visibility visibilidade do atributo Nodo NodeAttribute Lista de Nodos NodeListAttribute ActionState\&gt;:
Representa todos os diagramas de atividades declarados no documento XMI.
A tabela abaixo ilustra os atributos usados deste nodo:
Atributos Usados name Descrição nome da atividade Nodo Lista de Nodos NodeActionState NodeListActionState Cabe salientar que os algoritmos de mapeamento desenvolvidos são dependentes dos documentos XMI gerados por a ferramenta de modelagem Rationale Rose e também do analisador Dom.
Para fazer o mapeamento dos elementos para o código, foi definido um modelo de classes em nível de projeto.
Cada classe do diagrama é responsável por armazenar os elementos do JUnit, exceto as classes Algoritmo e Parser.
A Figura 38 descreve o diagrama de classes.
As classes Sut, TestCase, TestControl, Comportamento, Setup, Teardown, TestComponent e Stub são classes que armazenam os elementos que serão gerados por o gerador de código.
Essas classes contêm apenas operações de acesso (get).
Para desenvolver os algoritmos três classes principais estão envolvidas:
Parser, Algoritmo e TestContext:
Faz a análise no documento XMI e armazena as tags (nodos) que serão usadas para mapear os elementos.
A Figura 39 descreve a classe parser.
Define um conjunto de métodos públicos e privados usados para extrair os elementos do XMI necessários à geração dos drivers e stubs no JUnit.
A Figura 40 descreve a classe Algoritmo.
A classe Algoritmo implementa o padrão singleton.
De essa forma só é permitida uma instância desta classe.
Ela tem como atributo uma instância da classe Parser de tal forma que seus métodos possam usar os métodos públicos de Parser de acordo com suas necessidades.
Uma descrição dos métodos públicos e privados de desta classe é descrito no Anexo I. Esta classe se relaciona com todos os elementos do JUnit, já que ela é responsável por gerar esses elementos.
A Figura 41 descreve a classe Testcontext.
Os algoritmos de mapeamento identificam a maioria dos elementos a partir de estereótipos, mapeando- os para o diagrama de classes da Figura 38.
A Tabela 6 ilustra para cada elemento o estereótipo usado para buscar- lo no documento XMI e o nodo que o estereótipo estende.
Algoritmo: GetExtendedElementByStereotype;
Entrada: Stereotype;
Considere o nodo Stereotype\&gt; da Figura 43.
Se fosse passado o estereótipo &quot;Sut «como parâmetro para o método getExtendedElementsByStereotype, este retornaria uma lista contendo os «xmi.
Id «de classes que o estereótipo estende.
Como podemos observar o atributo &quot;extendedElement «estende duas classes:
&quot;S. 298.1247.52.2 «e &quot;S. 298124752.20».
Como mencionado anteriormente, uma coleção de nodos equivale a um NodeList.
Assim, na maioria das vezes, para percorrer estas listas são utlizados iteratores (iterator), assumindo- se que existe um método iterator para a conversão da lista num iterator.
Para descrever os algoritmos envolvidos na busca de cada elemento, foram usados diagramas de seqüência.
De essa forma, é possível identificar quais métodos são usados para buscar cada elemento e em que ordem esses métodos são executados.
As próximas seções apresentam os diagramas com os respectivos métodos usados para buscar cada elemento.
Buscar o pacote e o nome do elemento TestContext a partir de a classe estereotipada com Assume- se que sempre existe um e somente um elemento TestContext, como especificado na Seção 6.2.2.
Considere o exemplo da Figura 26 (Seção 6.2.2).
O objetivo é buscar o nome e o pacote do elemento TestContext, que no exemplo da Figura 26 corresponde à TestVenda nos dois casos.
A Figura 44 mostra o diagrama de seqüência com os métodos usados para buscar esse elemento.
Sempre haverá um único idClass para o estereótipo TestContext, e este é passado para o método getTestContextById, que retorna uma instância da classe Testcontext.
A Figura 46 descreve o algoritmo deste método.
Algoritmo: GetTestContextById;
Entrada: IdClass;
Quando o elemento TestContext é criado, este por sua vez gera os demais elementos, como descrito na Figura 47.
Uma vez extraídos todos os elementos, o gerador de código descrito na Seção 7.5 mostra como esses elementos são gerados.
Buscar o pacote, o nome, bem como as instâncias das classes estereotipadas com Pode ter um ou mais Sut.
Considere o exemplo da Figura 25.
O objetivo é buscar os nomes e os pacotes do Sut, que no exemplo correspondem a:
Venda e LinhadeItemVenda, ambos do pacote Venda.
Considere ainda o exemplo da Figura 28 (Seção De essa forma, a idéia é buscar todas as instâncias de cada um dos Suts.
A Figura 48 mostra o diagrama de seqüência com os métodos usados para buscar os Suts.
Saída: ListSut;
5 listSut.
Add (getSutById (idClass));
Entrada: IdClass;
Saída: Sut;
LinhadeItemVenda da Figura 25.
Através de seu identificador, é preciso buscar suas instâncias, nos diagramas de seqüência correspondentes aos casos de teste.
Um exemplo é mostrado na Figura 28, Seção 6.3.1.
Este nome de instâncias é buscado na tag ClassifierRole\&gt;.
Como podemos observar na Figura 51, o valor do atributo xmi.
Id $= &quot;S. 298.1247.52.20 «é igual ao valor do atributo base $= &quot;S. 298.1247.52.20 «do nodo ClassifierRole\&gt;, como ilustra a Figura 52.
De essa forma, são identificadas todas as instâncias referentes aos objetos dos diagramas de seqüência correspondentes ao comportamento de casos de teste.
Em o exemplo da Figura 53 é mostrado o trecho do documento XMI correspondente ao comportamento do caso de teste testSubTotal.
De acordo com a Figura 53, o atributo name $= &quot;testSutTotal «e o atributo diagramType $= &quot;SequenceDiagram «identificam que este nodo corresponde ao diagrama de seqüência equivalente ao comportamento do caso de teste.
Também como podemos observar, o atributo subject $= &quot;G. 14 «é uma das instâncias do Sut declaradas naquele diagrama.
Porém, nem todas as instâncias são do Sut.
De essa forma, deve- se buscar todas as instâncias, sendo estas representadas por o atributo &quot;subject «e depois verificar quais de elas são do Sut.
Voltando ao exemplo da Figura 53, o atributo subject $= &quot;G. 14», corresponde ao atributo «xmi.
Id &quot;de o nodo ClassifierRole\&gt; denominado «LIV», como mostra a Figura 52.
A Figura 54 descreve o algoritmo que busca as instâncias do Sut.
Algoritmo: GetObjetosSut;
Entrada: IdClass;
Saída: ListObjetosSut;
Primeiramente são percorridos todos os nodos Diagram\&gt; para verificar se o tipo de diagrama é de seqüência (linhas 4 a 7).
Para cada diagrama encontrado, é armazenado o &quot;name «na variável nomeDiagram.
Em seguida, são identificados os nomes dos casos de teste e armazenados na variável nomeTestCase.
É verificado se o nome do caso de teste é igual ao nome do diagrama, se verdadeiro, são identificados os nodos filhos do diagrama de seqüência.
Para cada nodo encontrado, é armazenado o atributo &quot;subject «na lista listSubject.
A lista listSubject é percorrida e cada &quot;subject «é passado para método getObjeto que retorna o nome do objeto correspondente (linha 24).
Assim, cada nome encontrado é adicionado na lista listObjetosSut.
A Figura 55 descreve o algoritmo.
Algoritmo: GetObjeto;
Entrada: IdClass;
O algoritmo da Figura 55 busca o &quot;name «de um objeto a partir de seu «xmi.
Id». Voltando ao exemplo da Figura 52, considerando xmi.
Id $= &quot;G. 14», retornará o &quot;name «igual a Buscar o nome e o comportamento dos elementos TestCases.
Assume- se a existência de uma ou mais operações estereotipadas com na classe estereotipada com TestContext.
Considere o exemplo da Figura 26 (Seção 6.2.2).
O objetivo é buscar os casos de teste, que no exemplo correspondem aos casos de teste testSubTotal, testTotal e testEfetuarPagamento.
Agora considere o exemplo da Figura 28.
Em esta Figura, tem- se o comportamento do caso de teste testSubTotal.
Assim, para cada caso de teste também são identificados seus respectivos comportamentos.
A Figura 56 mostra o diagrama de seqüência com os métodos usados para buscar os testcases.
Saída: ListTestCase;
5 listTestCase.
Add (getTestCaseById (idTestCase));
Para cada IdTestCase do TestCase encontrado, um objeto TestCase é criado através do Entrada:
IdTestCase; Assim, para cada caso de teste é criada uma instância passando o nome e o comportamento, sendo este último buscado através do método getComportamentoTestCase.
O comportamento de um caso de teste é composto basicamente por objetos e mensagens, podendo também conter declaração de variáveis locais.
Para explicar o algoritmo é importante entender como ele é representado no documento XMI.
A tag que representa o comportamento de um caso de teste é a Interaction\&gt;.
Em esta tag são definidas todas as mensagens do diagrama de seqüência.
As Figuras 59 e 60 ilustram o comportamento do caso de teste testSubTotal, referente a o caso de teste da Figura 28.
Para cada nodo Interaction\&gt; é verificado se o atributo &quot;name «é igual ao nome do caso de teste.
Caso verdadeiro, são identificados os filhos da interação, ou seja, as mensagens, representadas por os nodos Message\&gt;.
Cada mensagem contém um identificador do objeto que recebe a mensagem (atributo &quot;receiver&quot;) e um identificador do objeto que envia a mensagem (atributo &quot;send&quot;).
Estes correspondem a os «xmi.
Id «dos objetos representados por os nodos\ UML:
ClassifierRole\&gt;. O objeto que recebe a primeira mensagem &quot;EspecificaçãodeProduto «é o objeto que possui o atributo xmi.
Id $= &quot;G. 15 «denominado &quot;esp1 «conforme mostra a Figura 60.
De essa forma, a idéia para buscar o comportamento de um caso de teste é a seguinte:
São identificadas todas mensagens (junto com os objetos destinatários das mesmas) exceto as três últimas mensagens.
O exemplo das Figuras 59 e 60 correspondem o seguinte código num driver JUnit:
Essas mensagens são geradas antes de montar a assertiva para o caso de teste.
Em este exemplo específico, as mensagens correspondem aos construtores das classes (EspecificaçãodeProduto e LinhaItemVenda).
Porém, caso não fossem mensagens equivalentes a construtores de classes, o mapeamento seria feito da seguinte forma:
Conforme os pressupostos descritos na Seção 6.3, as três últimas mensagens são usadas para montar a assertiva para o caso de teste, como segue:
A última mensagem corresponde ao veredito do caso de teste (Por exemplo, &quot;pass «ou &quot;fail&quot;).
Esta mensagem equivale ao tipo de assertiva usada no caso de teste.
A antepenúltima mensagem normalmente corresponde ao método testado, que será igual à mensagem representada por o caso de teste.
A penúltima mensagem corresponde ao valor correspondente do resultado do caso de teste.
O algoritmo da Figura 61 descreve detalhadamente como é buscado o comportamento do caso de teste:
Entrada: NomeTestCase;
Saída: Comportamento;
Primeiramente, é percorrida a lista com os nodes Interaction\&gt; até encontrar o atributo &quot;name «igual ao caso de teste passado por parâmetro (linhas 2 à 4).
Se encontrado, são identificados todos os filhos de Interaction\&gt;, isto é, as mensagens (linha 5).
São armazenadas as posições das três últimas mensagens.
Para cada mensagem é armazenado o &quot;name «na variável nameMessage, o nome do objeto que recebe a mensagem na variável nomeObjeto, sendo este buscado através do método getObjeto (ver Figura 55) e o identificador da classe que o objeto instancia na variável idClass, sendo este buscado através do método getClassById.
Se mensagem for menor que antepenúltima, significa que ainda não é o método testado, então é verificado se a mensagem é igual ao construtor de uma classe, que pode ser um sut, testcomponent ou uma classe do modelo de projeto que será interpretada como um TestComponent, através do método verificaConstrutor (ver Anexo I, algoritmo 2).
Se a mensagem for um construtor de uma classe e se a mesma é comum a todos casos de teste, então ela é gerada dentro de o método Setup como segue:
Caso contrário, se o nome da mensagem não for comum a todos casos de teste, então ela é gerada como segue:
EspecificacaodeProduto esp1 $= new EspecificacaodeProduto;
Isto significa que na hora de gerar o código, esta mensagem é declarada como uma variável local, dentro de o corpo do caso de teste.
Seguindo o algoritmo, se mensagem é igual à antepenúltima, ou seja, se é a métodos getIdOperation e getDataType (ver Anexo I, algoritmos 3 e 4 respectivamente).
Este é buscado para poder gerar a assertiva correta para o caso de teste.
Se um caso de teste assertEquals.
Também é armazenado o método testado na variável metodoTestado, sendo este composto por o objeto e a mensagem (linha 24).
Seguindo o algoritmo, se mensagem for igual a penúltima (linha 25), ou seja, se é a mensagem que corresponde ao resultado do caso de teste, a mesma é armazenada na variável resultado.
Esta variável será usada mais adiante para montar a assertiva para o caso de teste.
Se mensagem for igual a última (linha 27) então é buscado o veredito para o caso de teste.
Assim, se o nome da mensagem for igual a &quot;pass «então é buscado o tipo de assertiva através do método getAssertiva (ver Anexo I, algoritmo 5).
Já, se o nome da mensagem for igual a &quot;fail «é usada a assertiva assertFail.
Finalizando o algoritmo, uma vez buscada a assertiva (linha 25 ou 27), o método testado (linha 24) e o resultado do teste (linha 26), os mesmos são adicionados na lista listComportamento.
Porém são consideradas duas situações para adicionar esses elementos na lista.
Se assertiva for igual a assertTue a assertiva é montada como segue:
Já se assertiva for igual a assertEquals, ela é montada como segue:
Buscar o comportamento do elemento Setup.
Assume- se a existência de uma e somente uma operação estereotipada com Considere o exemplo da Figura 29 (Seção 6.4.2).
O objetivo é gerar as mensagens do diagrama de seqüência juntamente com os objetos dentro de o método setup da ferramenta JUnit.
A Figura 62 mostra o diagrama de seqüência com os métodos usados para buscar este elemento.
Sempre haverá um único idOperation para o estereótipo setup.
O mesmo é passado para o método getSetupById que retorna uma instância da classe setup.
A Figura 64 descreve o algoritmo deste método.
Assim, uma vez criada uma instância de Setup, é passado o comportamento, sendo este buscado através do método getComportamentoSetup.
O algoritmo para buscar o comportamento do elemento Setup é igual ao algoritmo que busca o comportamento do caso até a parte em que são identificadas as três últimas mensagens.
A Figura 65 ilustra o algoritmo deste método.
Entrada: NameOperation;
Saída: Comportamento;
Uma vez encontrada a interação, são identificados os filhos, isto é, as mensagens.
Para cada mensagem, é armazenado o &quot;name «na variável nameMessage, e o objeto que recebe e mensagem, na variável nomeObjeto, sendo este buscado por o método getObjeto (ver Figura 55).
Uma vez encontrado o nome da mensagem e o nome do objeto, os mesmos são adicionados na lista listComportamento.
É criada uma instância de Comportamento passando a lista.
Abaixo é mostrado o mapeamento para o código:
Para buscar o elemento Teardown, o procedimento é o mesmo, mudando apenas como ele é representado no JUnit (ver template, Seção 6.4).
Buscar o pacote, nome, construtores, atributos, métodos e instâncias de cada elemento TestComponent.
Podem existir várias classes estereotipadas com Considere o exemplo da Figura 26.
O objetivo é buscar e gerar a classe estereotipada com que no exemplo, corresponde à classe EspProduto.
O TestComponent é referenciado dentro de o driver de teste (ver template Seção 6.4) e também fora de o driver de teste como uma nova classe JAVA e seus respectivos, construtores, atributos e métodos.
A Figura 66 mostra o diagrama de seqüência com os métodos usados para buscar este elemento.
Os elementos Testcomponent são identificados através do método construtores, atributos, métodos e instâncias.
A Figura 67 descreve o algoritmo deste método.
Saída: ListTestComponent;
5 listTestComponent.
Add (getTestComponentById (idClass));
Para cada idClass encontrado, um testcomponent é criado através do método Entrada:
IdClass; Saída:
Testcomponent; TestComponent testcomponent TestComponent (pacote,, getObjeto (id));
Os métodos getConstrutores (Anexo I, algoritmo 6), getAttribute (Anexo I, algoritmo 7), getOperation (ver Anexo I, algoritmo 8) e getObjeto (ver Figura 55), buscam os construtores, atributos, operações e instâncias de cada testcomponent respectivamente.
Os elementos Stubs são identificados a partir de outros diagramas de seqüência do modelo de projeto do sistema.
Para compreender como funciona o algoritmo para gerar esse elemento, é importante saber o contexto em o qual ele é usado.
Um Stub é um tipo de TestComponent, porém diferente do testcomponent que é gerado a partir de o modelo de projeto de teste e de Software, o Stub é gerado somente a partir de o modelo de projeto do software.
Em o exemplo explorado no capítulo 6 (Sistema Venda), um dos casos de teste envolve o método subTotal da classe LinhadeItemVenda.
Porém, para testar esse método, é preciso saber o preço de cada produto.
Observando a Figura 69 que representa dependência da classe LinhadeItemVenda com a classe EspecificaçãodeProduto.
Assim, como a classe EspecificaçãodeProduto não é um Sut e não foi especificada como um TestComponent, ela é gerada como um Stub de teste.
A representação destas mensagens no documento XMI é ilustrado na Figura 70 através do nodo Interaction\&gt;.
De essa forma a idéia geral do algoritmo é a seguinte:
São identificados todos diagramas de seqüência diferentes daqueles que representam o comportamento de casos de teste, como descrito na Figura 70.
Para cada diagrama de seqüência, é verificado se existe alguma mensagem do diagrama igual ao método a ser testado, situação esta descrita através da primeira mensagem da Figura 70.
Se existir, é preciso verificar se o objeto que recebe esta mensagem envia uma outra mensagem para outro objeto, situação descrita na Figura 70 ilustrado por os atributos receiver $= &quot;G. 58 «e sender $ ` G. 58».
Em caso verdadeiro, é verificado se o objeto que recebe esta mensagem é uma instância de Sut.
Se não for uma instância de Sut, é buscada a classe que o objeto instância e essa classe será mapeada como um Stub de teste.
A Figura 71 mostra o diagrama de seqüência com os métodos usados para buscar este elemento.
Cada caso de teste encontrado é passado para o método getStubByTestCase que retorna um lista com todas classes Stubs.
A Figura 73 ilustra o algoritmo deste método.
Entrada: NameTestCase;
Saída: Stub;
ListOnwer. Add (nodeDiagram.
Onwer); 9 para i de 0 até tamanho de NodeListInteraction faça para j de 0 até tamanho de NodeListMessage faça para k de 0 até tamanho de NodeListClassifierRole faça para l de 0 até tamanho de NodeListClass faça Stub stub $= new Stub (n..
Name, NodeListClass.
Next. Name, getConstrutores (id), getAtributos (id), getOperation (id), getobjetos (id));
Primeiramente, a lista com os nodos Diagram\&gt; é percorrida até encontrar aqueles que sejam diagramas de seqüência.
Para cada nodo correspondente ao diagrama de seqüência encontrado, é verifica se o &quot;name «do diagrama é diferente dos casos de teste.
Se diferente, é armazenado na lista ListOnwer o atributo &quot;onwer «dos diagramas de seqüência (linhas 3 à 7).
O próxima passo é percorrer os nodos Interaction\&gt; e a ListOnwer e comparar se o atributo «xmi.
Id &quot;de a interação é igual ao atributo «onwer «da ListOnwer.
Caso iguais, são identificados os filhos da interação, isto é, as mensagens.
Para cada mensagem, é verificado se a mesma é igual ao nome do caso de teste passado por parâmetro.
Se forem iguais, é armazenado o atributo &quot;receiver «da mensagem.
Uma vez armazenado o identificador do objeto que recebe a mensagem, é verificado se a próxima mensagem é envidada por o mesmo objeto que recebeu a mensagem anterior, ou seja, aquela de nome igual ao caso de teste.
Se verdadeiro, é armazenado o atributo &quot;receiver «desta mensagem na variável receiverAux.
Assim, a lista com os nodos ClassifierRole\&gt; é percorrida até encontrar o atributo «xmi.
Id &quot;igual a variável receiverAux e quando encontrado, é armazenado o atributo «base «na variável base (linhas 22 a 25), ou seja, é buscado o identificador da classe que o objeto instancia.
Finalizando o algoritmo, a lista com os nodos Class\&gt; é percorrida até encontrar o atributo «xmi.
Id «da classe igual a variável base e se encontrado, é criado um novo objeto Stub denominado stub passando o nome do pacote, o nome da classe, os construtores, os atributos, os métodos e os objetos.
Os algoritmos que buscam os construtores, atributos, métodos e objetos são os mesmos usados para o elemento testcomponent, mudando apenas o identificador passado por parâmetro.
Buscar os nomes das atividades na ordem em que elas aparecem no diagrama de atividades especificado para o elemento TestControl.
É assumido no máximo um elemento testcontrol.
Considere o exemplo da Figura 27, Seção 6.2.3.
O objetivo é buscar o nome de cada atividade do diagrama de atividades na ordem em que elas aparecem, no exemplo:
Para cada IdTestcase encontrado, é buscado o nome do caso de teste através do método getTestCaseById (linha Cada nome passado para método getTestControlByTestCase que retorna o nome da atividade do diagrama de atividade na ordem em que ela aparece.
A Figura 76 ilustra o algoritmo deste método.
Entrada: NameTestCase;
Saída: NomeAtividade;
A lista com os nodos ActionState\&gt; é percorrida, e para cada atributo &quot;name «é verificado se o nome da atividade é igual ao nome do caso de teste passado como parâmetro.
Caso iguais, a mesma é retornada.
O gerador do código é responsável por gerar os elementos de acordo com o template apresentado na Seção 6.4.
Seja testcontext uma instância de TestContext criada como explorado na Seção 7.2, abaixo é descrito como cada elemento é gerado:
&quot;import&quot;+ &quot;import «3 -- Gerando o nome do elemento TestContext:
O exemplo acima mostrou a geração da classe Java para o elemento TestComponent.
Para a classe correspondente ao elemento Stub o procedimento é o mesmo.
Para validação dos algoritmos desenvolvidos foi implementado um protótipo, sendo este feito na linguagem de programação Java.
Um dos motivos da escolha dessa linguagem está relacionado com o próprio JUnit, que é todo baseado nesta linguagem.
Outro motivo é que esta linguagem disponibiliza diversas Apis que têm suporte à manipulação de documentos XML, como por exemplo, Dom, que foi a API que usada.
Para geração do documento XMI, algumas ferramentas de modelagem foram analisadas, entre elas:
Rational Rose (IBM), Enterprise Architect (Sparx Systems), Jude (ferramenta free), Together Architect (Borland), argoUML (ferramenta free), Visual Paradigm (ferramenta free), Poseidon for UML (ferramenta free) e ObjectDomain (ferramenta free).
Um requisito fundamental era que as ferramentas suportassem a geração de arquivos XMI tanto de diagramas estruturais como diagramas comportamentais da UML.
As ferramentas que suportaram estes requisitos foram:
Rational Rose, Enterprise Architect, Together Architect e Poseidon for UML.
Entre estas ferramentas a Rational Rose foi escolhida.
A escolha desta ferramenta teve como critérios:
Ser uma ferramenta muito conceituada e conhecida na modelagem de sistemas, tanta na área acadêmica como na área industrial e aderência do XMI ao padrão OMG.
A interface do protótipo é simples.
A interação com o usuário é mínima e a geração dos Drivers e Stubs é totalmente automatizada.
A Figura 77 ilustra o protótipo com o Driver e Stub gerado no exemplo do sistema Venda, explorado no capítulo 6.
Como mencionado anteriormente, o objetivo é proporcionar o mínimo de interação do usuário para geração do código.
De essa forma, para gerar o código, basta clicar no botão &quot;abrir arquivo», escolher o arquivo XMI e clicar no botão &quot;Gerar Driver».
O driver é gerado automaticamente, como mostrado no lado esquerdo da tela (Figura 77 (a)).
Se existirem Stubs e/ ou testcomponents para este driver, aparecerá uma mensagem informando o usuário que existem Stubs para serem gerados.
Assim, basta o usuário clicar no botão &quot;Gerar Stub «que o mesmo é gerado automaticamente (Figura 77 (b)).
O código pode ser exportado tanto num arquivo txt, como também pode ser exportado para um arquivo Java (Figura 77 (c)).
Assim, é possível importar esse arquivo para o ambiente de programação que o sistema está sendo desenvolvido e executar os testes.
Este capítulo descreve o estudo de caso realizado para validar a proposta do presente trabalho.
Para realizar o estudo de caso, foi utilizado um sistema desenvolvido por o CPTS ­ Centro de Pesquisa em Teste de Software da PUCRS.
O sistema refere- se a um sistema de locações de DVDs.
Para este, existe um projeto em UML, uma implementação na linguagem Java, bem como vários drivers de teste codificados para ferramenta Junit.
Além de a existência dos artefatos já mencionados, a complexidade dos diferentes cenários de teste permitiram explorar especificações de teste em U2TP com todos os elementos deste perfil adotados neste trabalho, em especificações de diferentes complexidades.
Com isso, espera- se testar de maneira bastante completa a geração automatizada proposta neste trabalho.
Este estudo de caso baseou- se nos seguintes documentos recebidos do CPTS:
Modelo de Projeto de Software;
Diagrama de casos de uso e diagramas de casos de uso expandidos e Vários drivers de teste (com os respectivos stubs, quando pertinentes), sendo que apenas três estavam completos.
Os drivers foram implementados no Junit por um testador do CPTS.
Utilizando o Eclipse, o mesmo gerou automaticamente a estrutura de cada driver a partir de o código Java das classes testadas.
Este esqueleto foi então completado com a implementação de cada caso de teste.
O tempo gasto para esta especificação foi fornecido por o testador.
O estudo de caso centrou- se em dois objetivos:
Verificar a correção do código gerado e Levantar dados quantitativos referentes ao tempo envolvido no processo de teste unitário e a qualidade do código gerado.
Assim, as próximas seções descrevem o modelo de projeto do sistema e o modelo de projeto de teste.
Em o final do capítulo, será feita uma análise dos resultados.
O projeto do sistema de Locação de DVDs é composto por um conjunto de diagramas da UML, entre eles, Diagramas de Casos de Uso (incluindo os casos de uso expandidos) e Diagramas de Classe.
A Figura 78 ilustra o diagrama de classes do sistema, tal como recebido do CPTS.
As classes escolhidas como foco para os testes unitários foram:
Categoria, CatalogoCategoria e CatalogoCliente.
Dois foram os motivos desta escolha:
Em o conjunto, contemplam todas as possíveis situações consideradas neste trabalho para geração automatizada de drivers e stubs;
As mesmas correspondem aos três drivers completamente codificados recebidos do Assim, para cada classe serão especificados os testes e conseqüentemente os drivers gerados.
Os drivers destas mesmas classes codificados por o testador são apresentados no Anexo Para especificação dos testes, foi usado o diagrama de classes do modelo de projeto e os diagramas de casos de uso e casos de uso expandidos, sendo este último muito importante para compreender o funcionamento do sistema.
Cada operação da classe foi considerada um caso de teste.
Esta seção descreve a transformação do modelo de projeto do software para o projeto de teste em U2TP, respeitando os pressupostos descritos na Seção 6.2.
Foram gerados três drivers de teste referentes às classes Categoria, CatalogoCategoria, CatalogoCliente.
A Figura 79 mostra a arquitetura do projeto de teste, e os diagramas das Figuras 80, 81, 82 e 83 definem o comportamento dos casos de teste.
Os casos de teste especificados foram referentes às quatro operações da classe Categoria.
Considerando esta especificação, a Figura 84 mostra o driver de teste gerado automaticamente para a classe Categoria.
Como podemos observar por a Figura 84, não foram gerados os métodos Setup e Teardown, pois os mesmos não foram especificados.
Também pode- se observar que o Sut não foi declarado como uma variável global, pois cada caso de teste define um novo objeto Sut localmente, justificando assim o correto funcionamento dos algoritmos que geram esses elementos.
Em relação a os pacotes gerados, pode- se observar que foi gerado todo o caminho correto na declaração dos pacotes.
Em este exemplo, não foi gerado nenhum Stub de teste.
Em relação a as assertivas algumas observações são ressaltadas:
Foram geradas duas assertivas assertEquals referentes aos casos de teste Foram geradas duas assertivas assertTrue referentes aos casos de teste testGetPreco e testSetPreco, pois o tipo de retorno é um double, validando dessa forma o algoritmo que busca as assertivas usadas nos casos de teste.
A Figura 85 mostra a arquitetura do projeto de teste da classe CatalogoCategoria.
Em esta especificação foram definidos os elementos Setup e Teardown.
Os diagramas das Figuras 86 e 87 mostram o comportamento dos métodos Setup e Teardown respectivamente.
Os diagramas das Figuras 88, 89, 90 e 91 definem o comportamento dos casos de teste.
Note que no pacote de teste foi definido um componente de teste, denominado ConexaoBD.
Este foi especificado para fazer a conexão com o banco de dados.
Também foi especificado outro componente de teste denominado Categoria, sendo este especificado no modelo de projeto do software.
A identificação destes foi feita com base na documentação recebida.
Considerando esta especificação, a Figura 92 ilustra o driver de teste gerado automaticamente para a classe CatalogoCategoria.
Como podemos observar por a Figura 92, o sut foi declarado como uma variável global (linha 6), pois o mesmo é comum a todos casos de teste.
Já o TestComponent Categoria, foi definido localmente para cada caso de teste.
Em relação a os métodos setup e teardown, pode- se observar que eles foram gerados corretamente conforme especificado nos diagramas de seqüência.
Outra observação em relação a o driver gerado é a declaração de novas variáveis locais.
Veja o exemplo do caso de teste testNew_ config.
Em este, foi declarado o atributo CRes do tipo CatalogoCategoria, justificando o funcionamento correto do algoritmo que busca o Em relação a as assertivas algumas observações são ressaltadas:
Foram geradas três assertivas assertEquals referentes aos casos de teste testNew_ config Foi gerada uma assertiva assertTrue referente a o caso de teste testDdit_ config (comparando um double).
As Figuras 93 e 94 ilustram o código Java gerado para os testcomponents:
Categoria e ConexaoBD respectivamente.
Como podemos observar por as Figuras 93 e 94, foi gerado somente a estrutura (esqueleto) destas classes.
O primeiro componente de teste foi especificado no modelo de projeto do sistema, e como podemos observar por a Figura 93, gerou o pacote com todo o caminho.
Já o segundo, foi especificado no modelo de projeto de teste, gerando o pacote pertencente ao pacote de teste.
A Figura 95 mostra a arquitetura do projeto de teste.
De a mesma forma que a classe CatalogoCategoria, nesta especificação foram definidos os elementos Setup e Teardown.
Para especificação deste último driver, foi modificado o modelo de projeto do sistema, e acrescentando a este um diagrama de seqüência referente a o cadastramento de um novo Cliente.
O objetivo da criação deste novo diagrama de seqüência é gerar o Stub de teste para o driver da classe CatalogoCliente.
A Figura 96 descreve o diagrama de seqüência especificado.
Como podemos observar por a Figura 96, para incluir um novo cliente é necessário criar primeiramente um novo cliente, ou seja, a um relacionamento entre CatalagoCliente que é um Sut com a classe Cliente.
De essa forma, a classe cliente será gerada como um Stub de teste.
Outro elemento especificado neste exemplo é o elemento testcontrol.
Embora ele não tenha sido especificado e codificado por o testador do CTPS, neste exemplo ele será usado.
O objetivo é verificar se o mesmo é gerado corretamente.
A Figura 97 ilustra o elemento Testcontrol descrevendo a ordem de execução dos casos de teste para classe CatalogoCliente.
As especificações dos comportamentos dos métodos setup e teardown são descritas abaixo nas Figuras 98 e 99 respectivamente.
Os diagramas das Figuras 100, 101 e 102 definem o comportamento dos casos de teste.
Considerando esta especificação, a Figura 103 ilustra o driver de teste gerado automaticamente para a classe CatalogoCliente.
Cliente c $= new Cliente&quot;;
Teste&quot;); Public Cliente c $= new Cliente (0, &quot;Cliente teste», Rua dos Transviados , 240», cc.
New_ cliente (c);
Cliente c $= new Cliente;
Como podemos observar por a Figura 103, além de todas as observações já descritas nos drivers gerados anteriormente, neste exemplo foi gerado o elemento TestControl, representado por o código em negrito.
Note que também foram gerados os pacotes próprios do JUnit referentes a classe TestSuite (import junit.
Framework. Test e import junit.
Framework. TestSuite), como definido no template.
Também foi gerada o código Java para o testcomponent referente a a classe ConexaoBD.
Em este exemplo, foi gerado um Stub de teste (classe Cliente) a partir de diagramas de seqüência do modelo de projeto de teste, validando assim o algoritmo que gera esse elemento.
O mesmo foi gerado como variável local para cada caso de teste.
A Figura 104 ilustra a classe Java gerado para o Stub Cliente.
Os três experimentos descritos na seção 8.3 permitiram também uma análise quantitativa sobre a abordagem proposta neste trabalho.
Para isto, foram comparados os tempos envolvidos para produção dos drivers e stubs por o testador do CPTS, bem como envolvidos na geração automática, incluindo neste o tempo necessário para as respectivas especificações em U2TP.
As Tabelas 7, 8 e 9 apresentam os resultados.
A Tabela 10 mostra o tempo total e o número de linhas de código total entre a geração do código a partir de especificações U2TP com a codificação do teste feita por o testador.
Como podemos observar por a Tabela 10, o tempo total gasto na geração das especificações e geração automática de drivers e stubs foi nove minutos menor que o tempo gasto na codificação por o testador, tendo sido geradas 15 linhas de código a menos.
Desta forma, pode- se verificar que uma especificação de teste feita com o U2TP pode ser muito bem aplicada no contexto de teste unitário, sendo que a qualidade do código gerado é melhor, pois o mesmo é gerado num nível mais alto de abstração e por uma pessoa especialista no assunto, um engenheiro de teste.
Com base nos drivers gerados e nos resultados obtidos na seção 8.4 pode- se concluir que o estudo de caso foi bastante satisfatório.
A Tabela 11 mostra que foi possível gerar todos os elementos e que os experimentos contemplaram todos cenários previstos neste trabalho.
Outra questão importante em relação a o estudo de caso é quanto a a documentação dos artefatos de teste.
Pôde- se verificar a facilidade do engenheiro de teste manter e documentar os testes a partir de o projeto de teste especificado, o que possibilita facilmente a realização de testes de regressão toda vez que o projeto de teste for alterado.
Esta dissertação de mestrado apresentou uma proposta para geração automatizada de drivers e stubs de teste para ferramenta JUnit a partir de especificações de testes modeladas com o U2TP.
Foram especificados elementos pertencentes ao grupo de arquitetura e comportamento de teste.
Para prova de conceito, foi implementado um protótipo que permitiu gerar todo código de teste.
Como visto, o teste unitário é o principal responsável por a detecção de defeitos dentro de a fase de codificação do software.
Entretando, como na maioria das vezes o teste unitário é feito por o próprio programador, ele ainda é feito de maneira ad-hoc, ou seja, sem nenhum planejamento.
De entre os principais problemas e dificuldades encontradas no processo de teste unitário, foi ressaltado principalmente a dificuldade de documentar e especificar casos de teste em nível de unidade, os quais dão origem aos drivers de teste.
Em este trabalho, foi assumido que um engenheiro de teste especifica e projeta os casos de teste usando o U2TP.
Já o programador, a quem freqüentemente é atribuído o papel de testador no teste unitário, é responsável por executar estes testes.
Além de minimizar problemas como dificuldade de documentação e especificação dos testes, outras vantagens podem ser ressaltadas, entre elas a qualidade do código gerado é melhor, pois os testes são especificados num nível mais alto de abstração e a qualidade dos testes também é melhor, pois estes são especificados por um engenheiro de teste, que detém maior conhecimento que o programador.
O tempo aparenta ser no mínimo equivalente, como visto no estudo de caso.
Em relação a a ferramenta JUnit, foi destacado que, além de ser uma das ferramentas mais usadas, é possível gerar a estrutura do driver de teste automaticamente através de Ides, por exemplo.
Porém, também foi destacado que o tempo, custo e esforço necessário para desenvolver o código de teste para esta ferramenta ainda é muito grande, o que muitas vezes inviabilizam o seu uso.
Através do resultado do estudo de caso, pode- se verificar que as convenções adotadas e os algoritmos propostos foram suficientes para geração de todo código de teste, pois os drivers foram gerados corretamente.
Observa- se que o código foi gerado com 15 linhas de código a menos que na codificação dos drivers feita por o testador, embora o código seja dependente da habilidade do programador do driver.
Também vale ressaltar que embora o tempo gasto para especificação dos testes com o U2TP e o tempo gasto para codificação dos testes por o testador tenham sido parecidos, na especificação dos testes foi consumido um tempo menor e res ultando numa melhor qualidade do código gerado.
A Tabela 12 descreve as principais diferenças deste trabalho em relação a os trabalhos relacionados apresentados no Capítulo 5.
Como podemos observar por a última linha da Tabela 12, este trabalho é o único que usa três tipos de diagramas da UML para geração do código (Diagrama de classes, atividades e seqüência).
Apenas SEDITEC é comparável a este trabalho, ao não requerer nenhuma interação com o usuário e gera todo o código de teste.
Embora SEDITEC não tenha JUnit como ferramenta alvo.
Este trabalho é o único de utiliza os conceitos do U2TP para geração do código de teste.
Outro diferencial está relacionado com a geração de Stubs de Teste, pois é o único que gera esse elemento a partir de outros diagramas de seqüência do modelo de projeto de Software.
Em o SEDITEC, os stubs são gerados como pré-condições.
Através deste trabalho, é possível introduzir e incentivar o teste já nas primeiras fases de desenvolvimento do software, e esse é um dos principais desafios dentro de o processo de teste, ou seja, conseguir identificar e remover os defeitos o quanto antes, diminuindo assim o custo e esforço gasto nas atividades de teste.
A geração dos Drivers e Stubs de teste para ferramenta JUnit ficou limitada ao tipo de documento XMI gerado por a ferramenta Rationale Rose.
Entretanto, uma limitação deste trabalho, é que os algoritmos desenvolvidos são dependentes do documento XMI gerado por a ferramenta Rationale Rose e também do parser Dom.
De essa forma, não foi possível propor algoritmos genéricos, que gerasse todo código a partir de documentos XMI gerados por outras ferramentas, pois seria necessário converter o XMI gerado por cada uma das ferramentas para este modelo.
Em relação a o grupo Dados de Teste, não foi possível gerar esses elementos automaticamente, devido a complexidade de mapeamento para o código equivalente a ferramenta JUnit.
Outra limitação deste trabalho é que a geração de Drivers e Stubs ficou limitada a ferramenta JUnit, embora também seja possível estender para outras ferramentas, como:
CppUnit e NUnit.
Como trabalhos futuros, são propostos:
Especificar e implementar os requisitos e conversões necessárias para gerar de forma genérica os elementos DataPool e DataPartition.
Explorar as conversões necessárias para usar a U2TP na geração de Drivers e Stubs de teste para outras ferramentas de teste unitário, especialmente cppUnit e NUnit;
Explorar e estender os conceitos da U2TP para outros níveis de teste, com a geração de código correspondente;
Desenvolver um framework que possibilite a geração do código considerando diferentes documentos XMI.
Integrar o protótipo num ambiente de desenvolvimento de software, como, por exemplo, Eclipse.
