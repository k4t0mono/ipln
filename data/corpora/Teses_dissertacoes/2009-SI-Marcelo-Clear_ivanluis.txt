Os Sistemas Multiagentes têm apresentado grande crescimento na área de desenvolvimento de software como um paradigma promissor para enfrentar a complexidade dos cenários atuais de tecnologia da informação.
Muitas abordagens surgem no intuito de consolidar formas e meios de desenvolver um SMA, que podem ser classificadas como Metodologias, Linguagens de Modelagem e Plataformas de Implementação.
Além disso, alguns trabalhos são propostos como tentativa de unificar os conceitos envolvidos e as notações que simbolizam estes conceitos, havendo uma gama enorme de simbologias divergentes e muitos conceitos em comuns entre estas abordagens.
Este trabalho apresenta comparações entre estes conceitos e notações visuais no intuito de encontrar um meio de mapear estas abordagens, mostrando suas divergências e convergências.
Como um primeiro passo no sentido da unificação, esse trabalho estende o Meta-modelo de Representação Interna de Agentes para permitir o mapeamento completo da metodologia Tropos.
Assim, demonstra- se como um metamodelo pode prover a interoperabilidade entre diferentes abordagens desvinculando a criação de um SMA das exigências de específicas metodologias ou linguagens de modelagem.
Também é gerado um esqueleto de código fonte a partir deste meta-modelo para o framework SemantiCore através de um protótipo, sendo possível estender- lo para que suporte a geração de código-fonte para qualquer plataforma de implementação.
Este processo de mapeamento e geração de código é demonstrado através da aplicação de um exemplo presente da literatura da área.
Palavras Chave: Agentes de software, Sistema Multiagentes, Mapeamento de Conceitos de SMA, Geração de Código de SMA.
Segundo Bergenti, Gleizes e Zambonelli Agentes Sistemas Multiagentes têm emergido como uma poderosa tecnologia para enfrentar a complexidade de uma variedade de cenários atuais de tecnologia da informação.
Em os últimos anos, tem crescido o volume de pesquisas relacionadas à identificação e definição de modelos, ferramentas, e técnicas que suportem o desenvolvimento de SMAs.
Estas pesquisas de engenharia de software orientada a agentes resultam em novas abordagens de modelagem, técnicas, metodologias e ferramentas, baseados em agentes.
Estas abordagens podem ser classificadas como:
Metodologias de desenvolvimento:
Que nos traz propostas de como planejar, organizar e sistematizar um SMA.
Por exemplo, Prometheus, Tropos e Ingenias.
Linguagens de Modelagem de SMA:
As soluções de meta-modelos apresentam propostas de como deve ser estruturado o agente e os SMAs quanto a suas entidades, relacionamentos e entre estas restrições.
Em muitas soluções, este meta-modelo traz com si uma notação visual que representa estas entidades e relacionamentos, tais como o Anote, o Mas-ML e o Message.
Plataformas de implementação:
São, geralmente, frameworks que possibilitam a implementação do SMA numa linguagem de programação, utilizando recursos relacionados.
Algumas plataformas suportam características de específicas metodologias, como a plataforma Jack que suporta a metodologia Prometheus.
Como muitas abordagens incorporam características dos três tipos apresentados, alguns pesquisadores apresentam propostas para a unificação destas diversas soluções, como a Notação Unificada para representação de SMAs, e o Meta-Modelo Unificado para modelagem de SMAs, apresentados no capítulo 3.
Embora estas propostas abordem a unificação de meta-modelos, não existe uma solução integrada que incorpore o mapeamento dos meta-modelos de diferentes metodologias e que seja capaz de gerar o esqueleto de código para uma plataforma de implementação, independente da metodologia ou da linguagem de modelagem utilizada.
Este trabalho é um passo preliminar para a busca de integração de soluções apresentado como um esforço inicial para ser referência na incorporação de outras abordagens pesquisadas e também presentes na literatura.
Como o primeiro passo este trabalho apresenta o Mas Meta--model Interchange para integrar a metodologia Tropos a partir de a extensão do MRIA, a fim de gerar código de software para plataforma SemantiCore.
Em as subseções a seguir, serão apresentados a questão de pesquisa, o objetivo geral, os objetivos específicos e a metodologia e organização da dissertação.
Questão de Pesquisa De acordo com, a integração de soluções que abordam desde a modelagem até a implementação, contribuirá para a construção de SMAs aplicados a indústria em larga-escala.
Em este sentido, emerge a questão de pesquisa deste estudo:
&quot;É possível gerar uma abordagem que permita a integração entre diferentes metodologias e linguagens de modelagem de SMAs e os diversos tipos de plataformas de implementação?».
Objetivo Geral O objetivo geral deste trabalho é propor uma abordagem que permita a integração de soluções para o desenvolvimento de SMAs, permitindo a geração automática de esqueletos de código em plataforma de implementação.
Além disso, este trabalho possui também o objetivo de contribuir para as metodologias e linguagens de modelagem na identificação de possíveis lacunas conceituiais, e como escopo da pesquisa este trabalho utiliza a metodologia Tropos e a plataforma SemantiCore.
Objetivos Específicos Os objetivos específicos deste trabalho são os seguintes:
Aprofundar o estudo teórico sobre as metodologias, linguagens de modelagem e plataformas voltadas ao desenvolvimento de SMAs.
Identificar trabalhos correlatos que possam contribuir para esta pesquisa.
Verificar a possibilidade de unificação de conceitos das várias metodologias.
Comparar conceitos das entidades e relacionamentos abordados em metodologias e linguagens de modelagem de SMAs, bem como símbolos utilizados nas notações visuais para representação dos elementos que compõem o meta-modelo de cada abordagem.
Propor uma extensão do meta-modelo de representação interna de agentes proposto em Santos que cubra os conceitos e os relacionamentos da metodologia Tropos.
Verificar a possibilidade de extensão do meta-modelo proposto para suporte às outras abordagens.
Desenvolver um protótipo que automatize o processo de mapeamento de soluções para o meta-modelo proposto, e posteriormente gere um esqueleto de código da aplicação para o framework SemantiCore.
Apresentar um exemplo de uso publicado na literatura que ilustre o potencial desta abordagem.
Metodologia e Organização da Dissertação Esta pesquisa estrutura- se em duas fases.
Inicialmente, será feita a revisão bibliográfica, compilação e comparação de diferentes metodologias e linguagens de modelagem de SMA, presentes na literatura.
A partir de esta análise comparativa, um conjunto de conceitos será definido como base para o desenvolvimento de um metamodelo que ofereça interoperabilidade entre os conceitos comparados e compilados.
Em a segunda etapa, será feita a compatibilização dos conceitos apresentados na linguagem com os conceitos existentes no MRIA.
A partir deste mapeamento, será feita uma extensão deste meta-modelo para a construção do MMI.
A cada nova metodologia ou linguagem de modelagem suportada será ampliado a semântica do MMI e este será refatorado.
Após, será estendido o tradutor do meta-modelo abordado em para traduzir modelos das abordagens suportadas para o MMI, e este para a estrutura de código do ambiente de desenvolvimento.
Por fim, será feito um exemplo de uso para a ilustração da proposta.
Desta forma, este trabalho está dividido em sete partes:
Embasamento teórico, trabalhos relacionados, estudo comparativo de meta-modelos e notações visuais, a extensão do meta-modelo de representação interna de agentes, implementação do protótipo estendido e considerações finais juntamente com trabalhos futuros.
Prometheus, Ingenias e MESSAGE, assim como os metamodelos e linguagens de modelagem Anote e Mas-ML voltadas ao desenvolvimento de sistemas multiagentes, e as plataformas de implementação de SMAs SemantiCore, Jason e Jack.
Em o Capítulo 4 está descrito um estudo comparativo entre meta-modelos e notações visuais.
Durante a pesquisa são identificados os conceitos e relacionamentos das metodologias e linguagens de modelagem abordadas, bem como a notação visual que os representam.
Em o Capítulo 5 é apresentado o MMI, uma proposta de extensão de um metamodelo para que suporte os conceitos da estrutura interna de um agente e possa receber o mapeamento das metodologias ou linguagens de modelagem pesquisadas.
Para demonstração da extensão deste meta-modelo, é utilizada a metodologia de desenvolvimento de SMAs Tropos, com mapeamento de suas entidades relacionamentos para este meta-modelo.
Em o Capítulo 6 é apresentado um protótipo estendido que automatiza o mapeamento dos modelos Tropos gerados por o software TAOM4E para os conceitos do meta-modelo estendido proposto, e a posterior geração de código para o framework SemantiCore.
Em o Capítulo 7, serão apresentadas as conclusões, assim como os possíveis trabalhos futuros.
Por fim serão descritas as referências bibliográficas utilizadas nesse trabalho.
Este capítulo apresenta inicialmente os conceitos de diferentes autores sobre agentes de software e sistemas multiagentes (SMAs).
Após, apresenta um levantamento bibliográfico para as metodologias de desenvolvimento de SMAs MASUP, Tropos, Prometheus, Ingenias e MESSAGE, e as linguagens de modelagens Anote e Mas-ML, no intuito de verificar o quanto estas metodologias diferem- se e a existência de um conjunto comum, sendo realizada uma comparação entre estas abordagens no capítulo 4.
Esta pesquisa foca na metodologia Tropos, abordando os conceitos e relacionamentos que formam seus meta-modelos, utilizando- o para demonstrar a interoperabilidade entre diferentes abordagens.
Por fim, apresenta as plataformas de implementação SemantiCore, Jack e Jason, focando no framework SemantiCore por utilizar- lo como base na demonstração de como gerar código de SMA a partir de um meta-modelo interoperável entre metodologias ou linguagens de modelagem.
Agentes de Software Agentes de software possuem diversas definições, sendo algumas mais voltadas a Inteligência Artificial e outras mais utilizadas na área de Engenharia de Software.
Segundo Russel e Novig um agente é tudo que pode ser considerado capaz de perceber e agir no ambiente através de sensores e atuadores, conforme ilustrado na figura 1.
O termo percepção faz referência às entradas do agente em qualquer momento, e sua sequência é a história completa de tudo que o agente já percebeu.
O comportamento do agente é descrito por a função de agente, a qual mapeia qualquer seqüência de percepções específicas para uma ação.
O comportamento de um agente é implementado por as ações e percepções dos agentes, e dividem- se em quatro tipos básicos:
Agentes reativos simples, agentes reativos baseados em modelo, agentes baseados em objetivos e agentes baseados na utilidade.
Agentes reativos simples selecionam ações com base na percepção atual, ignorando o histórico de percepções;
Os agentes reativos baseados em modelos utilizam um modelo de mundo, em o qual o agente deve manter um tipo de estado interno que dependa do histórico de percepções e das informações sobre o modo como o mundo evolui independentemente do agente, e sobre como as ações do próprio agente afetam o mundo;
Agentes baseados em objetivos possuem uma descrição do estado atual, e informações sobre os resultados de possíveis ações para alcance dos seus objetivos;
Em um agente baseado na utilidade, a função de utilidade mapeia um estado ou uma sequência de estados que descrevem o grau de satisfação associado ao sucesso no alcance dos objetivos do agente.
Wooldridge caracteriza os agentes conforme sua arquitetura interna, abrangendo os agentes BDI (Belief, Desire and Intention) e agentes reativos.
De acordo com Müller, um agente BDI é composto por desejos, crenças e intenções, e pode também conter planos e objetivos.
Os planos são formados por um conjunto de ações e pode ser executado por um agente no alcance de seus objetivos.
Os objetivos são classificados como subconjunto dos desejos, os quais, segundo Odell, definem os estados futuros que o agente deve atingir.
A crença de um agente, segundo Müller, expressa suas expectativas sobre o estado atual do mundo e a probabilidade de um curso de ação atingir determinados efeitos, enquanto uma intenção é um compromisso para executar um plano.
A arquitetura de agentes BDI baseia- se na manipulação de estruturas de dados que representam as crenças, desejos e intenções dos agentes, para a tomada de decisão.
Esta arquitetura tem suas bases na tradição filosófica de entender o raciocínio prático, ou seja, o processo de decidir, momento a momento, qual ação deve ser realizada no amparo de seus objetivos.
A arquitetura reativa apóia a implementação de um mapeamento direto da tomada de decisão, seguindo da situação para a ação.
Um conjunto de comportamentos para a conclusão das tarefas faz- se necessário, e vários destes comportamentos podem trabalhar simultaneamente.
Nwana classifica agentes de software quanto a a sua mobilidade, por a presença ou não de um raciocínio simbólico (agente deliberativo ou reativo), ou por a presença de atributos considerados primários:
Autonomia, cooperação e aprendizado.
A mobilidade num agente é determinada por a habilidade em se locomover por algum tipo de rede.
Os agentes deliberativos são capazes de se engajar numa negociação por um pensamento, enquanto os reativos possuem seu comportamento dependente de estímulos gerados por o ambiente onde está inserido.
Os agentes autônomos podem executar ações por conta própria para satisfazer seus objetivos.
A cooperação permite que os agentes interajam com outros agentes e possivelmente com seres humanos utilizando uma linguagem de comunicação.
Por fim, o aprendizado permite ao agente ser &quot;inteligente», devendo aprender com as reações e interações no ambiente externo.
Quando um agente apresenta mais de uma das características citadas, é considerado híbrido.
Os limites desta classificação não devem ser interpretados como linhas bem definidas, pois o fato de agentes cooperativos possuírem uma ênfase maior em autonomia e cooperação que agentes com capacidade de aprendizado não implica que os agentes cooperativos não possam desenvolver características de aprendizado, conforme ilustrado na figura 2.
Os agentes podem atuar isoladamente no alcance de seu objetivo ou em conjunto com outros agentes formando um sistema multiagentes.
Sistemas Multiagentes Os Sistemas Multiagentes (SMAs) são compostos por múltiplos agentes que interagem entre si para atingir um objetivo comum.
Os agentes dentro de um sistema multiagentes podem apresentar diferentes atributos, de acordo com o ambiente em que estão inseridos.
Segundo Wooldridge, um agente está situado num ambiente que constitui o contexto em que todas as interações entre os agentes ocorrem com dispersão do controle, dos dados e do conhecimento por a comunidade de agentes.
Para Juchen, num projeto de um SMA, é importante considerar o tipo do ambiente em o qual os agentes estarão situados, pois a situacionalidade determina a maneira de atuar e de perceber as alterações no ambiente e o tipo de representação de ambiente sobre a qual cada um dos agentes atuará.
Para que haja o processo colaborativo em sistemas multiagentes diferentes, ou até entre agentes do mesmo SMA, é essencial que haja uma forma de comunicação comum, disciplinada e inteligível entre todos agentes para que os objetivos sejam alcançados de forma eficiente.
Existem diversas maneiras para agentes se comunicarem entre si em sistemas multiagentes, de acordo com Baker:
Comunicação direta, federada (também chamada de comunicação assistida), em difusão de mensagens (broadcast) e através de blackboard com uso de um repositório comum.
Em a comunicação direta, cada agente comunica- se diretamente com qualquer outro agente sem intermediários;
Em a federada é utilizado um agente chamado de facilitador que atua como coordenador intermediando a comunicação com outros SMAs;
A comunicação por difusão é utilizada em situações onde a mensagem deve ser enviada para todos os agentes do ambiente, ou quando o agente remetente não conhece o agente destinatário e então envia a mensagem a todos os agentes;
E por quadro-negro, baseia- se num modelo de memória compartilhada, ou seja, um repositório onde todos os agentes possuem acesso para receberem e contribuírem através de mensagens a outros agentes para obterem informações sobre o ambiente.
Além de as formas de comunicação dos agentes, é necessária uma linguagem que estabeleça um protocolo para comunicação inteligível por todos os agentes que compõem um SMA e comum para o ambiente onde o agente se situa.
De acordo com Weiss, um protocolo de comunicação especifica os tipos de troca de mensagem entre agentes:
Propor um curso de ação, aceitar um curso de ação, rejeitar um curso de ação, cancelar um curso de ação, discordar de um curso de ação proposto e contrapropor um curso de ação.
As mais usadas são a KQML e FIPA-ACL.
Segundo muitos pesquisadores buscam o desenvolvimento de metodologias para a construção de sistemas multiagentes, com diferentes iniciativas, embora não exista um consenso quanto a a melhor metodologia para o desenvolvimento de sistemas multiagentes.
Algumas destas abordagens trazem com si propostas de linguagem de modelagem, com meta-modelo e notação própria que permite a modelagem num ambiente de desenvolvimento integrado com geração de código e execução da aplicação.
Entretanto algumas abordagens limitam- se à metodologia ou plataforma em a qual foi projetada.
Estas abordagens podem ser classificadas como:
Visão geral sobre metodologias e linguagens de modelagem de SMAs Este trabalho concentra- se no estudo das metodologias e linguagens de modelagem de SMAs do ponto de vista de seus conceitos, relacionamentos e restrições.
Alguns conceitos presentes nos meta-modelos estudados são representados visualmente segundo notações próprias de cada abordagem.
Uma metodologia de desenvolvimento de SMA nos traz propostas de como planejar, organizar e sistematizar este sistema, ou seja, trata do processo de desenvolvimento do sistema, guiando o desenvolvedor passo a passo.
Uma metodologia pode abranger, além de o processo, um meta-modelo que guie a sua aplicação.
A linguagem de modelagem é um elemento essencial em tecnologia de software que propicia a sistematização visual e a organização do sistema em modelos, os quais são passíveis de mapeamento para a implementação e a codificação.
Uma linguagem de modelagem é definida por um meta-modelo que descreve os conceitos a serem utilizados através das entidades, relacionamentos e restrições entre estes conceitos.
Uma linguagem de modelagem além de possibilitar uma melhor compreensão para o desenvolvedor traz junto com o meta-modelo uma notação visual que representa as entidades e relacionamentos deste meta-modelo.
Um meta-modelo é uma representação dos tipos de entidades que podem existir num modelo, suas relações e restrições de aplicação.
Este meta-modelo contém todos os conceitos que podem ser usados para projetar e descrever o sistema estudado e podem ser representados por uma notação visual.
Uma notação visual é um sistema técnico de símbolos usados para representar elementos dentro de um sistema.
Para que uma notação visual tenha melhor aceitação deve apresentar características que a torne utilizável e consistente, sendo que alguns critérios foram propostos por Rumbaugh em.
Em um cenário ideal, um desenvolvedor seria capaz de especificar um sistema de agentes sem considerar uma linguagem de modelagem específica para uma determinada arquitetura, em a qual o sistema será implementado.
Estas especificações são encontradas em diversas metodologias para o desenvolvimento de SMAs, com uso de meta-modelo e notação visual.
Entretanto, não há uma forma padronizada para modelagem de SMAs, apenas esforços e iniciativas em busca desta padronização, como um meta-modelo unificado baseado em agentes e uma notação visual unificada.
Esta seção apresenta uma visão geral sobre as metodologias de desenvolvimento e linguagens de modelagem de SMAs MASUP, Tropos, Anote, Prometheus, Ingenias, Message e Mas-ML.
Os paradigmas tradicionais de engenharia de software são limitados para representar as características de sistemas multiagentes.
Embora muitas abordagens relacionadas ao desenvolvimento de SMA existam, a maioria foca em linguagens de modelagem de SMA, havendo poucas abordagens que combinam processos conhecidos e aceitos de desenvolvimento, como o Processo Unificado, e uma linguagem expressiva em representação.
O Multi-Agent Systems Unified Process (MASUP) é uma variação do Processo Unificado (UP) para modelagem de sistemas orientados a agentes, com objetivo principal de identificar as aplicabilidades de soluções baseadas em agentes de software durante a modelagem.
O MASUP inicia- se como o UP, mas na fase de análise e projeto deriva diferentes artefatos para modelar características específicas de agentes, conforme ilustrado na figura 3.
Desta forma, o MASUP apresenta- se totalmente compatível com o UP e, portanto, partes que não são aplicadas à agente de software podem ser modeladas usando as técnicas tradicionais do UP.
Em a fase do levantamento de requisitos, o MASUP utiliza a mesma abordagem de casos de uso do Processo Unificado, de modo que o foco desta etapa está na captura de requisitos.
Esta fase é responsável por especificar os papéis a serem desempenhados por os agentes, identificar atores e ações, e detalhar os casos de usos.
Ainda na fase dos requisitos, as funcionalidades envolvidas no sistema são identificadas, e de elas deriva diferentes artefatos para modelar as características específicas de cada agente.
Para a modelagem destes artefatos, o MASUP utiliza os diagramas da Agent-based Unified Modeling Language (AUML).
De acordo com Blois e Santos, na fase de análise do MASUP é feito o link entre a fase de requisitos e a fase de projeto, compreendendo as seguintes atribuições:
A revisão dos diagramas de atividades gerados no projeto, de forma a descobrir quais atividades envolvem uma tomada de decisão que necessita ser codificada diretamente no sistema e que na modelagem original é realizada por algum ator;
Identificação de papéis requeridos para a solução baseada em SMA nos diagramas de atividades gerados para a próxima fase;
Especificação dos papéis de cada agente e suas atribuições;
Identificação dos agentes que devem desempenhar funções específicas;
E definição das relações entre os agentes que compõem a arquitetura social dos SMA.
Esta fase identifica novas responsabilidades capazes de preencher os papéis requeridos para uma solução de sistemas multiagentes, considerando os seguintes aspectos:
Os agentes identificados nesta fase são especificados por a Classe de Agentes, apresentados na figura 4.
A fase de projeto da metodologia MASUP tem como objetivo as seguintes atividades:
A especificação do cenário de interação dos agentes;
A complementação da especificação da classe agente com as ações de comunicação necessárias para implementar as interações modeladas;
E a identificação dos serviços de infra-estrutura envolvidos num cenário especificado por a interação modelada.
O Tropos é uma metodologia de desenvolvimento de SMAs baseada no framework i*.
Este framework provê noções como atores, objetivos e dependências entre atores que são utilizadas durante todo o ciclo de desenvolvimento.
A metodologia Tropos suporta todas as atividades de análise e projeto no processo de desenvolvimento de software.
De acordo com Bresciane e outros, o Tropos introduz cinco principais fases de desenvolvimento:
Fase inicial de requisitos, fase final de requisitos, projeto arquitetural, projeto detalhado e implementação.
A fase inicial de análise de requisitos consiste em identificar e analisar as partes interessadas (stakeholders) do domínio e seus objetivos.
Os stakeholders são modelados como atores sociais que dependem um do outro para alcançar seus objetivos, realizar seus planos e fornecer seus recursos.
A fase final dos requisitos estende o modelo conceitual incluindo um novo ator que representa o sistema e as dependências com outros atores do ambiente.
Estas dependências definem os requisitos funcionais e não funcionais do sistema.
A fase de projeto de arquitetura define a arquitetura global do sistema em termos de subsistemas (atores) interconectados através de dados e fluxos de controles (dependências).
Esta fase é dividida em três passos:
Em o primeiro passo é definida toda a arquitetura organizacional, quando novos atores são introduzidos no sistema, e apresentados num diagrama de atores estendido;
Em o segundo, são identificadas as capacidades necessárias para os atores completarem seus objetivos e planos.
As capacidades podem ser facilmente identificadas analisando o diagrama de ator estendido, em o qual cada relacionamento de dependência se tornará uma ou mais capacidades iniciadas por um evento externo, e o terceiro passo consiste em definir um conjunto de tipos de agentes e atribuir a cada tipo uma ou mais capacidades diferentes.
Em a fase de detalhamento do projeto são especificados em detalhes os objetivos, metas, capacidades e comunicação dos agentes.
Em esta fase, são feitas as escolhas da plataforma de desenvolvimento para a implementação do sistema.
Durante esta fase, o Tropos faz a utilização do diagrama de atividades da UML para representar a capacidade e os planos, e adota um subconjunto de diagramas proposto por a AUML para especificação do protocolo de agentes.
A última fase da metodologia Tropos é responsável por a implementação do projeto detalhado.
Segundo Bresciani, para esta fase, o Tropos utiliza a plataforma BDI JACK para implementar o SMA.
Segundo Silva, a modelagem realizada em Tropos é bastante confusa e rebuscada, o que dificulta esta fase do processo de desenvolvimento.
A fase de projeto detalhado é orientada especificamente à plataforma JACK.
Segundo Bresciane e outros, os modelos em Tropos são instâncias de um meta-modelo conceitual que aborda os conceitos de ator, posição, agentes, papéis, objetivo, planos e recursos e os relacionamentos de dependência, meios-fins (meansends), contribuição e decomposição Estes conceitos possuem uma representação numa notação que Tropos incorpora do framework i*, demonstrada na figura 5 montada a partir de recortes das figuras 1 e 2 de.
O ator, em Tropos, representa um agente, um papel ou uma posição.
A metodologia Tropos define conceitos de agente, papel e posição, como:
O Tropos adota o conceito clássico da Inteligência Artificial para agentes, que o define por suas propriedades de autonomia, habilidade social, reatividade, pró-atividade;
O papel é definido como uma caracterização abstrata do comportamento de um ator social dentro de um contexto específico;
E a posição representa um conjunto de papéis, tipicamente executado por um agente.
Um agente pode ocupar uma posição enquanto uma posição cobre o papel, conforme representado no meta-modelo de Tropos com enfoque no conceito de ator, ilustrado na figura 6.
O objetivo representa interesses estratégicos do ator.
O Tropos distingue objetivo em Hardgoal, referente a o objetivo propriamente dito, e Softgoal, o qual não possui uma definição clara ou critério para decisão quanto a sua satisfação, sendo tipicamente utilizado para modelar requisitos não-funcionais.
O plano representa, num nível abstrato, o caminho para se fazer algo.
A execução do plano pode ser o meio para satisfazer um objetivo.
Um recurso representa uma entidade física ou informacional, enquanto que a crença representa o conhecimento de mundo do ator.
Já a capacidade representa a habilidade de um ator definir, escolher e executar um plano para alcançar um objetivo, dada certas condições do mundo e na presença de um evento.
A dependência, em Tropos, indica um relacionamento entre dois atores em o qual um ator depende do outro por alguma razão, seja para alcançar um objetivo, executar um plano, ou entregar um recurso.
O ator que depende de outro é chamado de depender, e o outro ator desta relação de dependência é chamando de dependee, sendo objeto de dependência (seja um plano, recurso ou objetivo) chamando de dependum.
Estes conceitos focado no ator são mostrados no meta-modelo do Tropos, conforme a figura 7.
A contribuição é uma relação ternária entre o ponto de vista de um ator, e dois objetivos.
Esta contribuição identifica o quanto um objetivo contribui positivamente ou negativamente para outro, e é mensurada utilizando métricas qualitativas denotadas por+ ternária que define a decomposição de objetivos em subobjetivos.
No conceito de objetivo, Bresciane e outros demonstram duas especializações de objetivo para representar a entidade Hardgoal e Softgoal, e como objetivos podem ser analisados de um ponto de vista de um ator através da análise de meios-fins (Means-ends Analysis), da contribuição e da decomposição.
Estes conceitos no meta-modelo de Tropos estão representados na figura 8.
A análise de meios-fins é uma relação ternária entre um ponto de vista de um ator, um objetivo como fim, e um plano.
No conceito de plano, a análise de meios-fins e as decomposições And/ OR definidas sob objetivos são aplicadas também aos planos.
Assim, segundo Bresciane, a decomposição And/ OR é utilizada para modelar a estrutura do plano.
Este conceito está representado na figura 9.
O meta-modelo de Tropos traz os conceitos de posição, agente e papel como especializações de ator, onde o ator pode ser um agente e ocupar posições na organização, bem como exercer papéis.
O conceito de dependência em Tropos traz uma abordagem de interação dos agentes num SMA, em o qual há o depender, o dependee e o dependum.
Além de a dependência, Tropos traz os relacionamentos de contribuição para representar de que forma uma entidade contribui para outra no alcance de um objetivo.
E por fim, o relacionamento de decomposição de Tropos permite decompor objetivos em subobjetivos e planos em subplanos, e especifica o tipo destas decomposições com o operador lógico And ou OR.
Estas entidades e relacionamentos contribuem para a proposta deste trabalho, através de adição destes conceitos e um processo de mapeamento dos modelos Tropos para a proposta, abordado no capítulo sobre o metamodelo estendido.
Anote O Anote oferece uma forma padrão de descrever os conceitos relacionados ao processo de modelagem de sistemas multiagentes, e fornece aos usuários uma expressiva linguagem de modelagem visual para desenvolver e trocar modelos baseados nos conceitos de agentes.
Segundo Choren e Lucena, o Anote possui um meta-modelo, que funciona como guia para a modelagem do sistema, coberto por uma notação visual que representa as entidades e relacionamentos, no intuito de facilitar ao desenvolvedor a construção do SMAs.
Os conceitos da linguagem de modelagem Anote são apresentados em.
Os principais conceitos do Anote são:
Agente, organização, recurso, objetivo, cenário, ação e mensagem, representados em seu meta-modelo, como ilustrado na figura 10.
Em o Anote, um agente é um módulo que está habilitado a desempenhar ações, sendo o principal bloco na construção da organização do sistema.
Um agente age no sistema no sentido de alcançar um objetivo, com execução de ações e interações com outros agentes durante a execução da ação.
Um agente possui uma limitação de percepção ou conhecimento do ambiente do sistema.
Organização é um grupo de um ou mais agentes trabalhando juntos para prover um serviço.
Trata- se de uma entidade virtual que age como um container de agentes, não havendo uma entidade computacional que a represente, embora seus serviços sejam providos e seus objetivos alcançados coletivamente por os agentes que a compõe.
Em um SMA pode haver várias organizações que provêem serviços umas às outras, conectadas por um relacionamento de provider/ customer que define como um agente numa organização pode depender ou interagir com um agente de outra organização.
Recursos são utilizados para representar entidades não-autônomas a serem manipuladas por o agente enquanto ele desempenha uma ação, como um programa externo ou um banco de dados.
Os recursos descrevem a ontologia do agente e são utilizados para modelar o ambiente do sistema, sendo modelados por conceitos orientados a objetos.
A entidade objetivo representa o objetivo do sistema, alcançado por um ou mais agentes associados com as ações referenciadas por um cenário que implementa este objetivo.
Os objetivos são o ponto de partida na modelagem de SMAs e podem ser combinados em várias alternativas de subobjetivos.
Um cenário ilustra o objetivo que constitui uma situação no sistema, ou seja, ilustra uma sequência de ações de um agente com intenção de realizar um objetivo específico num contexto.
O cenário descreve o contexto em o qual cada agente age, classificandose como um contexto usual que mostra a execução das ações habituais de um agente, ou um contexto variante, o qual exige a adaptação do agente para execução de possíveis novas ações.
Ação é uma computação que resulta em alteração do estado do agente, vinculada a uma pré-condição.
Quando a ação for executada e a pré-condição for válida é esperada uma transição associada, que juntas formam os planos de ação do agente.
A ação é dividida em dois tipos:
Ação direta (DirectAction) e ação adaptativa (AdaptiveAction).
A ação direta é usualmente executada por um agente enquanto ele participa de um cenário (ou contexto) para o alcance de um objetivo, enquanto que a ação adaptativa é executada quando o contexto requer a adaptação do agente por motivo de alguma funcionalidade.
A mensagem é o envio de informação de um agente para o outro num alto nível de um tipo de ato de fala para troca de informações.
Estas mensagens são construídas através de um protocolo assíncrono que definem os padrões de interação entre os agentes.
Para a especificação do SMA, o Anote fornece um conjunto de modelo ou visões juntamente com uma representação específica de cada visão.
Estas visões são agrupadas em estruturais e dinâmicas, e abrangem outras visões como a de objetivo, agentes, cenários, planos, interação, organização e ontologias.
A visão estrutural ou estática define as propriedades estáticas de um sistema multiagentes.
Fazem parte da visão estrutural as modelagens de objetivos, agentes e do ambiente do sistema.
A visão de objetivos especifica os objetivos do sistema.
É o primeiro passo para o processo de modelagem de sistemas multiagentes.
Os objetivos complexos podem funcionalmente ser decompostos em objetivos e fluxos constituintes, fornecendo uma descrição como uma árvore hierárquica dos objetivos.
Em o Anote, um objetivo é um nó na árvore de hierarquia de objetivos e é representado como um retângulo com os cantos arredondados, ilustrado na figura 11.
A visão de Agentes especifica a estrutura do agente, os tipos de agentes que existem numa solução multiagentes e seus relacionamentos.
Os agentes são vistos como elementos discretos da modelagem, nenhum detalhe sobre seu comportamento é fornecido.
A interação entre agentes é especificada na visão de agente usando o relacionamento de associação.
Em Anote, um agente é representado como um retângulo.
A visão dinâmica define as propriedades comportamentais de um sistema multiagentes.
Em o Anote, a visão dinâmica é usada para modelar os cenários, planos e interações do sistema.
A visão de Cenário captura o comportamento do agente em contextos específicos, tais como a forma que os objetivos podem ser ou não alcançados, em quais circunstâncias o agente pode se adaptar, aprender ou ter um comportamento autônomo.
Um cenário elabora caminhos para atingir os objetivos dos agentes em duas fases:
Por o curso de comportamento normal, e por trajetos alternativos para cada seqüência de comportamento, sendo que cada trajeto corresponde a um cenário e possui uma descrição textual associada.
Um cenário especifica o agente principal, as pré-condições, o plano usual de ação, a interação e os planos alternativos de ações.
As visões de planos especificam as ações que um agente deve executar para realizar um plano de ação descrito num cenário.
Um plano de ação é modelado de maneira que permita que o agente trace as suas ações internas, seqüenciando os eventos para atingir seu objetivo e tomar as decisões baseadas em seu conhecimento atual.
A descrição de plano de ação do agente vem dos cursos de ação (normal e alternativo) descritos na visão de cenário.
Os planos de ação são representados como um diagrama de ações muito similar a um diagrama de estados (com estados e transições de ação), como ilustrado na figura 13.
As transições adaptativas permitem que os desenvolvedores do sistema mostrem quando e sob que circunstâncias um agente deve mudar seu comportamento executando um conjunto de ações especificadas nos planos de ação alternativos de um Cenário.
A Visão de Interação do Sistema representa o conjunto de mensagens que os agentes trocam ao realizar um plano de ação.
As interações são representadas como um diagrama da conversação que descreve os discursos entre os agentes, os quais permitem ao desenvolvedor mostrar o estado atual de uma conversação e fazer uma consistência entre as mensagens emitidas por um agente e as mensagens recebidas por outros, como ilustrado na figura 14.
A visão de organização define a estrutura de um sistema multiagentes, especificando as organizações do sistema e seus relacionamentos.
Esta visão modela as organizações de agentes do sistema, e possui caixas como notação visual para demonstrar o conjunto dos agentes que lhe pertencem, como ilustrado na figura 15.
Uma dependência mostra que as organizações estão arranjadas num modelo clienteservidor, e expressam que um agente de uma organização requer o serviço de um agente em outra organização.
Uma seta tracejada representa a dependência entre organizações, indicando o cliente e o servidor.
A visão de ontologia identifica o componente não-agente do sistema, e define o mundo onde o agente irá atuar.
Além disso, esta visão provê uma descrição estrutural dos recursos de ambiente do agente.
Em esta visão, o Anote pode especificar um ambiente de sistema multiagentes através de uma ontologia, representada por recursos.
Através destas visões, o Anote aborda os objetivos, os agentes e o alcance de seus objetivos, os componentes que constroem o ambiente, o contexto em o qual o agente alcançará seus objetivos, as ações dos agentes, o diálogo entre os agentes e sua organização lógica.
O Prometheus é uma metodologia para desenvolvimento de sistemas de agentes inteligentes, criada em colaboração com o Agent Oriented Software (A os) 1.
Trata- se de uma metodologia que atua em todas as atividades requeridas no desenvolvimento de sistemas de agentes inteligentes, voltados a desenvolvedores especialistas ou não.
Segundo Padgham e Winikoff, as principais características do Prometheus são:
Suporte ao desenvolvimento de agentes inteligentes que usam objetivos, crenças, planos e eventos;
Suporte do início ao fim ao desenvolvimento de SMAs, desde a especificação até a implementação do sistema.
A metodologia disponibiliza um processo detalhado que especifica os artefatos de projetos construídos e os passos para derivação de artefatos.
Esta metodologia abrange um mecanismo de estrutura hierárquica que permite a construção do projeto em múltiplos níveis de abstração.
Ela possui uma abordagem interativa de engenharia de software, e provê uma automática verificação dos artefatos.
O Prometheus consiste em três fases:
Especificação, projeto arquitetural e projeto detalhado, como ilustrado na figura 16.
A fase de especificação do sistema é responsável por identificar os objetivos, desenvolver os cenários de casos de uso ilustrando a operação do sistema, identificar as funcionalidades e especificar as ações e percepções.
O projeto arquitetural define quais agentes existirão e como interagirão no ambiente, envolvendo atividades como:
Definição dos tipos de agentes e das interações entre os agentes de um SMA.
A fase de projeto detalhado abrange a estrutura interna de cada agente e de que forma será realizada sua tarefa dentro de o sistema.
De acordo com Silva, são duas as ferramentas que atualmente utilizam o Prometheus:
O JACK e PDT (Prometheus Projeto Tool).
O ambiente de desenvolvimento do JACK inclui uma ferramenta de modelagem para a construção dos diagramas e resulta na geração do código na linguagem de programação.
A ferramenta PDT permite ao usuário inserir e alterar projetos de SMAs, verificar possíveis inconsistências, gerar automaticamente um conjunto de diagramas de acordo com a metodologia e gerar automaticamente a descrição do projeto.
Padghan e Winikoff e Padghan apresentam uma notação que representa os conceitos utilizados na metodologia Prometheus, embora nas referências eles não sejam claramente definidos.
As notações divergem em alguns pontos entre cada referência.
Em um trabalho é apresentada uma notação para entidade incident, e em outro esta entidade não é abordada;
O protocolo possui notações diferentes em cada um das referências;
A notação de evento é apresentada somente em;
A notação de objetivo é apresentada somente em, bem como a funcionalidade.
Estas notações estão ilustradas na figura 17.
O Ingenias provê uma linguagem para modelar sistemas multiagentes, e ferramentas de suporte para análise, projeto, verificação e geração de código por o Ingenias Development Kit (IDK).
Estas ferramentas, tão bem quanto a a linguagem, são baseadas em especificações do seu meta-modelo que define as diferentes visões e conceitos de como o sistema multiagentes pode ser descrito.
Estas visões são divididas em visão organizacional, de agentes, de ambiente, de tarefas e objetivos, e de interação.
A organização é um conjunto de entidades com relacionamentos de agregação e heranças, que define o local onde agentes, recursos, objetivos e tarefas existem.
De o ponto de vista de agentes, cada agente é definido por seu propósito (objetivos que um agente tem o compromisso de prosseguir), responsabilidades (quais tarefas tem que executar), e capacidades (papéis que podem executar).
Estes propósitos definem o estado mental do agente, a sua gestão e transformação.
O estado mental consiste de metas do agente e informações sobre a satisfação dessas metas, conhecimentos do mundo e fatos que refletem a sua experiência passada para a tomada de decisão.
O ambiente é definido por a percepção e atuação dos agentes.
Em a visão de ambiente, identificam- se os recursos disponíveis e aplicações as quais um agente pode interagir.
O ponto de visão de tarefas e objetivos explica como um objetivo alcançado afeta outras objetivos existentes usando relacionamentos de decomposição e dependência.
Este ponto de vista também é responsável por descrever as conseqüências de se desempenhar uma tarefa e o porquê ela deve ser executada.
O ponto de visão de interação aborda a troca de informação ou requisições entre agentes, ou entre agente e usuários humanos.
Em o Ingenias é considerada a motivação da interação e seus participantes e as informações sobre o estado mental exigido por cada agente durante a interação, assim como as tarefas executadas no processo.
Desta forma, o Ingenias expressa em nível de projeto como um agente inicia e continua numa interação.
Os Protocolos de interação podem ser especificados usando diferentes formalismos:
AUML, diagrama de colaboração UML e diagramas GRASIA, que é uma especialização do diagrama de colaboração UML para abordar questões intencionais associadas a uma interação.
A metodologia Ingenias adota uma hierarquia de conceitos básicos que possuem uma notação visual, conforme apresentado na figura 18.
Segundo Gomez-Sanz, o meta-modelo do Ingenias é uma evolução do meta-modelo do MESSAGE, resultando em cinco meta-modelos:
De o agente, da organização, da interação, de tarefas e objetivos.
O meta-modelo de agentes descreve agentes particulares, com enfoque nas funcionalidades do agente e no projeto de seu controle.
Em o Ingenias, o agente é uma entidade autônoma caracterizada por ter identidade única, propósitos, responsabilidades e capacidades.
Este meta-modelo abrange a responsabilidade e o comportamento do agente, apresentado na figura 19.
As responsabilidades no meta-modelo são contempladas por o uso de papéis no sistema que abrangem as tarefas a serem executadas para o alcance dos objetivos.
O papel no Ingenias é uma abstração de um conjunto de funções que possui estado e depende da entidade agente para desempenhar- lo.
O comportamento no Ingenias engloba o controle do agente mediante mecanismos que vão assegurar as execuções das tarefas, através do estado mental do agente (entrada de um conjunto de dados), o qual possibilita a inclusão do aprendizado nas capacidades do agente.
O estado mental do agente são as informações gerenciadas e processadas que permitem ao agente tomar decisões.
Desta forma, o Ingenias introduz duas entidades conceituais para representar o estado mental do agente:
O gerenciador do estado mental que mantém a coerência do conhecimento armazenado com a evolução do estado mental mediante a criação, destruição, modificação e monitoramento do conhecimento do agente;
E o processador do estado mental que é direcionado a tomada de decisão em busca do alcance de objetivos, resultando na execução de uma sequência de tarefas.
Em o intuito de descobrir a evolução do estado mental do agente, o Ingenias utiliza a entidade Consulta de Entidade Autônoma para fazer referência às propriedades do agente.
A consulta ao agente contém uma expressão de restrição que um agente deve satisfazer.
O meta-modelo de interação busca definir o contexto das interações com enfoque no objetivo da interação e como será afetado o sistema, bem como quais serão as execuções da interação e quais as mensagens e a ordem em que as mesmas serão aplicadas.
Este meta-modelo aborda agentes, papéis, objetivos, interações e unidades de interações.
Os agentes e papéis são os atores numa interação.
Este meta-modelo é ilustrado na figura 20.
O meta-modelo de objetivos e tarefas define as ações e responsabilidades identificadas nos meta-modelos de organização, interação e de agentes, como ilustrado na figura 21.
Este meta-modelo traz os conceitos de objetivos e tarefas para esta metodologia.
Em Ingenias, uma tarefa é uma unidade transformadora de estado global com précondições e pós-condições, sendo ela vista como processo.
Para uma simplificação do meta-modelo, o Ingenias optou por restringir o que se pode fazer numa tarefa, omitindo o estado da tarefa, e colocando- a restrita num tempo finito.
Em esta metodologia, objetivos são entidades auto-representativas que guiam o comportamento do agente e relacionam- se com as entidades agentes, papéis e organização.
A organização é separada em três definições:
Estrutural, funcional e social.
Este meta-modelo é apresentado na figura 22.
A visão estrutural da organização proporciona a decomposição da organização em grupos e fluxos de trabalhos, onde cada grupo contém agentes, recursos, aplicações e papéis relacionados num fluxo de trabalho.
Em a descrição funcional, o fluxo de trabalho estabelece como são utilizados os recursos, quais tarefas são necessárias para a execução de um objetivo, e quem são os responsáveis por executar- lo.
O fluxo de trabalho apresenta como as tarefas são associadas e executadas.
O fluxo de trabalho pode ser decomposto em outros fluxos de trabalho ou tarefas.
As tarefas são executadas por agentes diretamente ou através de seus papéis.
Em uma descrição social de organização, são consideradas as relações de restrições sociais entre organizações, agentes e grupos, indicando a interação entre estas entidades.
Estas relações são relações de subordinação, prestação de serviços e requisitos de um serviço.
Em uma relação de subordinação o subordinado cumpre todas as ordens do subordinador, em contradição com a característica de liberdade de atuação dos agentes.
Esta relação é decomposta em relação de obediência incondicional e condicionada.
A relação condicional é similar a um contrato, onde a infração de alguma condição implica na invalidade do contrato.
As relações de provedor e cliente de recurso fazem referência a um serviço oferecido por uma entidade e outra que a consome (cliente).
Os agentes buscam satisfazer um objetivo, e nesta busca poder entrar em contato com outros agentes utilizando tanto reação de busca de serviços quanto subordinação para satisfazer este objetivo.
O propósito do meta-modelo de ambiente é representar o mundo em que o SMA está inserido, contendo as entidades recursos, aplicações e agentes, limitando a percepção e a atuação dos agentes.
Este meta-modelo é ilustrado na figura 23.
As aplicações servem como atuadores e sensores dos agentes, servindo de interface para o mundo real.
Os recursos podem ser utilizados ou não por um agente e são categorizados como consumíveis e não consumíveis.
Além disso, os recursos são relacionados às tarefas através dos relacionamentos de consumo, produção e limitação.
A relação de consumo indica o uso de um recurso e decrementa sua quantidade disponível;
O MESSAGE possui uma linguagem de modelagem que estende o meta-modelo UML com conceitos de orientação a agentes.
De acordo com Caire e outros, a maioria das entidades do MESSAGE podem ser agrupadas nas categorias:
Entidade Concreta (ConcreteEntity), compostas por as entidades agente, organização, papel e recurso;
Atividade (Activity), compostas por as entidades tarefas, interação e protocolo de interação;
Estado Mental (MentalStateEntity), composto por as entidades objetivo, entidade informacional e mensagem.
A figura 24 ilustra uma visão geral de como estas entidades são relacionadas numa visão com enfoque na entidade agente.
O meta-modelo que representa todas as entidades, relacionamentos e restrições da metodologia MESSAGE está dividido em visões e pacotes, podendo ser acessado no site oficial do projeto MESSAGE da Eurescom.
Os conceitos aqui relacionados referem- se à metodologia de desenvolvimento de SMAs de acordo com Cervenka Evans O agente é uma entidade autônoma e atômica.
Um agente pode executar papéis, prover serviços, executar tarefas, alcançar objetivos, usar recursos, ser parte de uma organização, e participar numa interação ou protocolo de interação.
Um serviço, provido por um agente, é análogo a operação de um objeto.
A organização2 é um grupo de agentes trabalhando juntos num propósito comum.
Trata- se de uma entidade virtual, ou seja, o sistema não tem uma entidade computacional que corresponda à organização.
Esta entidade atua como forma de relacionar agentes numa relação organizacional com subordinação, controle e gerenciamento de procedimento, fluxos de tarefas e interação.
O papel exercido por um agente possibilita a separação lógica da própria identificação do agente, uma vez que um papel descreve as características externas de um agente num contexto específico quando este o exerce.
Além de o agente, um papel pode ser exercido também por uma organização.
Também é função de um papel prover serviços, executar tarefas, alcançar objetivos, usar recursos, ser parte de uma organização e participar numa interação ou protocolos de interação.
O recurso é um conceito utilizado para representar entidades não autônomas como um banco de dados e pode ser utilizado por uma entidade autônoma.
Tarefa é uma unidade de atividade ligada a uma única entidade autônoma principal, sendo esta seu executor.
Uma tarefa possui pré e pós-condições (restrições que definem o estado da tarefa).
Quando uma pré-condição é válida espera- se que ocorra uma pós-condição associada ao término da tarefa.
A tarefa pode ser composta por subtarefas, possuir estados associados, e estar relacionada com objetivos a serem alcançados.
Interação é um conceito que o MESSAGE importou da metodologia Gaia.
A interação possui mais que um participante e um propósito que os participantes têm por objetivo alcançar coletivamente.
Um protocolo de interação define o padrão de trocas de mensagens associadas com a interação.
Objetivos são intenções de entidades autônomas para alcançar um estado desejado.
Alguns objetivos são intrínsecos ao agente e derivados de seus propósitos, persistindo durante toda vida do agente.
Outros são transientes, que expressam o propósito em termos de funções úteis ao alcance um &quot;bom valor «de um estado.
Objetivos implicam em tarefas e podem ser decompostos em subobjetivos.
Uma entidade informacional é um objetivo que encapsula informações enquanto uma entidade mensagem é um objetivo que incorpora uma comunicação entre agentes.
A transmissão de uma mensagem é realizada num tempo finito e requer uma ação a ser executada por o remetente, bem como por o destinatário, possuindo um ato da fala (speech Em MESSAGE, um agente ou uma organização são comumente chamados de entidades autônomas act) que categoriza a mensagem em termos de intenção do remetente, e um conteúdo composto por uma entidade informacional.
O MESSAGE introduz uma notação estendida da UML para suas entidades e relacionamentos, conforme ilustrado na figura 25.
De acordo com Cervenka, o MESSAGE define visões ou perspectivas para diferentes aspectos do modelo.
As visões são divididas em:
Visão de objetivo/ tarefa, visão de agentes/ papel, visão de interação e visão de domínio.
A visão de objetivo/ tarefa mostra a dependência entre um objetivo e uma tarefa.
Objetivos podem ser ligados através de uma dependência lógica com tarefas para formar gráficos que mostram como alcançar um objetivo ou conjunto de subobjetivos, e como as tarefas podem ser executadas para o alcance destes objetivos.
A visão de Agentes/ papel foca um agente individualmente e seus papéis.
Para cada agente/ papel são usados esquemas suportados por diferentes diagramas para explicitar características, tais como:
Por qual objetivo o agente é responsável, que eventos são necessários, quais recursos ele controla e quais tarefas serão executadas (regras de comportamento).
A visão de interação aborda as interações, os papéis relacionados ao agente, a informação fornecida ou alcançada por agentes numa interação, e o evento que inicia a interação.
A visão de domínio mostra o domínio específico de conceitos e relacionamentos que são relevantes para o sistema em desenvolvimento.
Para esta visão, o MESSAGE utiliza os diagramas de classe da UML.
O Mas-ML (Multi-Agent System Modeling Language) é uma linguagem de modelagem de sistema multiagentes que visa modelar todos os aspectos dinâmicos e estruturais definidos no framework Tao apresentado por Silva e outros em.
O meta-modelo do Mas-ML é definido estendendo o meta-modelo do UML de acordo com as entidades e relacionamentos definidos no Tao.
De acordo com Silva, o Tamming Agent and Object (Tao) é um framework desenvolvido com base em pesquisas sobre metodologias orientadas a objetos e orientadas a agentes, e sobre teorias e linguagens existentes relacionadas ao desenvolvimento de SMAs.
O Tao oferece suporte a novas metodologias e linguagens que se baseiam em seus conceitos.
Os conceitos definidos por o Tao dividem- se quanto a os aspectos estruturais e dinâmicos.
Em a descrição dos aspectos estruturais, as entidades que podem ser descritas são definidas juntamente com suas propriedades e relacionamentos associados.
Os aspectos dinâmicos definem a criação e a destruição de entidades e também o comportamento independente de domínio.
Ambos os aspectos são representados em Mas-ML através de diagramas estruturais e dinâmicos durante a fase de projeto e análise.
Para o diagrama dinâmico da Mas-ML, é utilizado o diagrama de seqüência estendido da UML com objetivo de modelar a interação entre as entidades, sua execução interna e os protocolos de interação entre os agentes.
O diagrama estrutural da Mas-ML é composto por o diagrama de classes estendido e dois novos diagramas chamados diagramas de organização e de papel.
O diagrama de classes da Mas-ML estende o diagrama de classes da UML com o objetivo de modelar os agentes, as organizações e os ambientes, utilizando os relacionamentos inhabitat, association e specialization do framework Tao.
O diagrama de organização modela organizações, agentes, papéis de objetos e ambientes, utilizando os relacionamentos ownership, play e inhabit.
O diagrama de papel modela os papéis do agente, papéis de objetos e a classe, utilizando os relacionamentos control, dependency, association, aggregation e specialization.
Mas-ML insere novas metaclasses para prover uma extensão de UML em que possam ser representados os agentes, as organizações, os ambientes, os papéis de agentes e os papéis de objetos como demonstrado na figura 26.
Segundo Silva, as entidades definidas no Tao são objetos, agentes, organização, papel de agente, papel de objeto, ambiente e evento.
Por uma questão de similaridade entre algumas entidades, o Mas-ML define uma nova abstração chamada elemento como base de definição para a maioria das entidades.
Esta entidade elemento possui estado, comportamento e relacionamentos com outros elementos.
De as entidades definidas por o Tao apenas evento não é baseada na entidade elemento.
Mas-ML também apresenta uma notação para suas entidades e relacionamento, ilustradas na figura 27.
As definições seguintes são referente a a linguagem de modelagem Mas-ML, e estão de acordo com Silva em.
Os objetos são elementos que possuem:
Um estado que armazena informações sobre o ambiente, sobre si mesmo e sobre outros objetos;
Comportamentos para definir quais operações serão executadas;
E relacionamentos para demonstrar como os objetos estão relacionados aos agentes, papéis e outros objetos do sistema.
Um objeto pode executar um papel definido por a organização que utiliza este objeto, e pode controlar seu estado, mas não seu comportamento, não sendo autônomo por sempre depender da requisição de outro objeto.
Agentes são elementos que definem as propriedades de estado mental e comportamento.
O estado mental de um agente é expresso por crenças, objetivos, planos e ações.
A crença é o conhecimento de um agente sobre o ambiente, outro agente e de si mesmo, o que inclui questões como:
O que o agente sabe, o que o agente vê, suas memórias e suas percepções sobre tudo que acontece dentro de o SMA.
O objetivo consiste no estado futuro que um agente deseja alcançar através da execução de planos.
Um plano pode ser modelado utilizando uma máquina de estados, em a qual os estados são compostos por:
Estado inicial, estado intermediário, estado final e transição entre dois estados.
Os estados podem ser definidos, brevemente como:
O estado inicial, que descreve as restrições para o estado mental do agente antes de executar o plano, conceito equivalente às pré-condições;
O estado intermediário, que descreve as ações que um agente deve executar, sendo que esta execução pode alterar seu estado mental enquanto o agente as executa.
As ações compõem o plano e quando executadas levam o agente mais próximo de seu objetivo;
As transições são definidas com base nas alterações do estado mental do agente;
O estado final descreve o estado mental do agente após executar o plano.
O comportamento de um agente é expresso por meio de seus planos e ações, e baseado em suas características, tais como autonomia, interação e adaptação.
O relacionamento descreve como um agente relaciona- se a outro elemento.
O ambiente é o habitar de agentes, organização e objetos.
O estado e comportamento de um ambiente são baseados em suas características, podendo ser passivo como um objeto ou ativo (autônomo, adaptativo e interativo) como um agente.
Os eventos são gerados por objetos, ambientes, agentes e organização.
Um evento pode iniciar a execução de ações associadas a agentes ou operações associadas a objetos de acordo com a percepção deste evento.
A organização é um grupo de agentes num SMA que define suborganizações e um conjunto de leis (axiomas ou regras estabelecidas) que os agentes desta organização devem obedecer, assim como papéis que devem ser executados.
O estado de uma organização é representado por seus objetivos, crenças e axiomas, e o comportamento é representado por ações, planos e papéis que os agentes pertencentes da organização devem executar.
A organização relaciona- se com as entidades crença, objetivo, ação, plano e axioma.
O papel em Mas-ML é um elemento que define um conjunto de propriedades e relacionamentos, e divide- se em papel de objeto e papel de agente.
O papel de objeto guia, restringe e pode incrementar o estado e o comportamento de um objeto e de como ele é visualizado (ou acessado) por outros elementos.
O papel de agente guia e restringe o comportamento de um agente.
Este papel descreve o objetivo do agente para executar o papel, as crenças e ações a serem executadas, podendo também adicionar novos objetivos e crenças, e define os direitos e deveres e protocolos relacionados ao agente enquanto executa este papel.
O estado de um papel de agente é definido por sua crença gerada a partir de fatos do ambiente e de seu objetivo, formado por o objetivo do agente ao executar este papel.
Os objetivos do grupo de papéis formam o objetivo da organização.
O comportamento de um papel de agente é definido por as regras e direitos e protocolos.
As regras definem as ações atribuídas ao agente durante a execução do papel, e os direitos definem as ações que o agente pode executar durante a execução do papel.
O protocolo define o conjunto de mensagens que um agente está habilitado a enviar e receber de outro agente numa interação.
Os relacionamentos de agentes são baseados nos protocolos associados ao papel.
Durante a extensão da UML novas entidades e relacionamentos foram adicionados para a Mas-ML.
Os relacionamentos do Mas-ML especializam- se em associação e relacionamento direto, este último especializa- se em dependência, generalização e as novas metaclasses inhabit, ownership, play e control incluídas no meta-modelo do MASML.
O relacionamento inhabit é uma nova metaclasse que especifica a criação e destruição de um elemento (também chamado de cidadão) num habitat e sua entrada e saída mediante permissão deste habitat.
Este relacionamento é aplicado ao ambiente, ao agente, ao objeto ou à organização.
O relacionamento ownership especifica que um elemento (o membro) é definido no escopo de outro elemento (o dono) e que o membro deve obedecer a um conjunto de restrições globais do dono.
O membro não existe fora de o escopo do dono e o dono conhece todos seus membros.
Este relacionamento é aplicado ao papel (membro) e a organização (dono) que as define, desta forma a organização possui total controle sobre o papel.
O relacionamento play especifica que um elemento é relacionado a um papel.
Quando um agente ou organização executa um papel, eles incorporam os objetivos e crenças do papel.
O relacionamento que liga dois papéis define a interação entre os elementos que os executam.
O relacionamento control define que o elemento controlado deve fazer qualquer coisa que o elemento controlador requer.
Este relacionamento pode ser usado entre dois papéis de agentes.
Os demais relacionamentos são conceitos da UML utilizados na modelagem de SMAs, conforme ilustrado na figura 28.
Visão geral sobre metodologias e linguagens de modelagem de SMAs As Plataformas de implementação se SMAs são geralmente frameworks que possibilitam o desenvolvimento dos SMAs numa linguagem de programação.
Algumas plataformas são propostas como suporte a metodologias e meta-modelos específicos através de um ambiente integrado de desenvolvimento e outras apresentam maior flexibilidade de uso.
Em esta seção, serão apresentadas as diferentes plataformas de implementação de SMAs estudadas.
Esse estudo foi realizado com o objetivo de verificar os conceitos de SMA tratadas nas plataformas.
O SemantiCore é um framework que surgiu a partir de uma extensão da arquitetura Web Life.
A finalidade deste framework é prover uma camada de abstração sobre uma arquitetura distribuída para criação de SMAs na Web Semântica.
O desenvolvimento de SMAs com o SemantiCore é possível através de sua instanciação num domínio específico.
Este framework fornece uma interface para o desenvolvimento de aplicações e encapsula os detalhes de implementação, tais como protocolos de comunicação, envio e recebimento de mensagens, entre outros, como ilustrada na figura 29.
O framework SemantiCore é dividido em dois modelos:
O modelo do agente (SemanticAgent) e o do domínio semântico.
Ambos possuem pontos de flexibilidade (hotspots) que permitem aos desenvolvedores adaptar diferentes padrões, protocolos e tecnologias às funcionalidades do framework.
O modelo de agente define todos os elementos necessários para a construção do agente, que quando implementado, é capaz de acessar seus componentes com intuito de realizar determinadas tarefas.
Os agentes do SemantiCore são compostos por quatro componentes, em o qual cada componente é responsável por uma tarefa específica.
Estes componentes são:
Sensorial, Decisório, Executor e Efetuador, conforme ilustrado na figura 30.
O componente sensorial é responsável por perceber e capturar os recursos que trafegam no ambiente, sendo composto por uma série de sensores definidos por o desenvolvedor.
Cada sensor captura um tipo diferente de objeto no ambiente, sendo estes encaminhados para processamento em outros componentes.
O componente decisório encapsula o mecanismo de tomada de decisão do agente, sendo este um dos pontos de flexibilidade (hotspots) do framework.
Em a Web semântica é importante que o componente opere sobre ontologias escritas em OWL para a definição semântica dos dados.
O escopo do componente decisório deve ser uma instância de uma ação (classe Action) com mapeamento das ações a serem executadas adequadamente, aplicadas tanto ao agente quanto a os elementos do domínio semântico.
O desenvolvedor pode implementar suas ações estendendo a classe Action.
Para o conceito de ação no SemantiCore, Escobar e outros consideram o conceito de processos, modelado por Ferber em.
O componente executor contém e executa os planos de ação do agente.
Este componente trabalha com o mecanismo de fluxo de trabalho (workflow) para controlar as transições das atividades dentro de um processo deste fluxo.
O componente efetuador é responsável por o encapsulamento de dados em mensagens para transmitir- las no ambiente.
Este componente armazena vários efetuadores, onde cada um tem o objetivo de publicar um tipo diferente de objeto no ambiente.
Esta comunicação utiliza diferentes padrões como Web Service SOAP e FIPA-ACL.
Ainda de acordo com Escobar e outros, os componentes do agente semântico estão associados a quatro classes que representam os componentes estruturais básicos de um agente no SemantiCore, que são:
O sensorial (classe Sensor), o efetuador (classe Effector), o decisório (classe Rule) e o executor (classe Action).
O SemantiCore define o ambiente onde o agente atuará através do domínio semântico, e requer um domínio Web para sua execução.
O domínio Web está vinculado ao domínio semântico que é administrado por duas entidades:
O controlador de domínio e o gerente do ambiente.
O Controlador de Domínio (Domain Controller) registra os agentes no ambiente e o Gerente de Ambiente atua como uma ponte entre o domínio semântico do SemantiCore e os domínios Web convencionais.
O modelo de domínio está ilustrado na figura 31.
A versão mais atual do SemantiCore é a versão 2006 a qual apresenta como inovações a forma de como onde os agentes podem ser descritos usando representação ontológica, a capacidade de criação de domínios e agentes distribuídos e a separação entre o barramento de controle e o de dados.
A representação ontológica dos agentes do SemantiCore utiliza a linguagem OWL.
A figura 32 ilustra esta representação, em a qual se observa a classe Fact e suas especializações SimpleFact, FuncitonBasedFact e ComposedFact.
Estas classes representam fatos usados como pré e pós-condição das ações e na seleção de mensagem nos sensores.
De entre elas, a classe SimpleFact representa um fato simples através das propriedades sujeito, predicado e objeto que formam um tripla RDF.
Os fatos são utilizados principalmente na tomada de decisão do agente.
A possibilidade de distribuição de um agente permite aos componentes do SemantiCore 2006 estarem espalhados em distintas partes do domínio e serem localizados através do componente sensorial.
Uma tabela de roteamento com os endereços dos componentes é criada para determinar o caminho entre os componentes do sistema, permitindo assim ao componente transmissor, recuperar a localização do componente de destino ao solicitar um envio de informação.
A distribuição de mensagens e o controle de localização dos componentes é responsabilidade do framework SemantiCore.
Para o processo de comunicação no SemantiCore é apresentado dois tipos de barramento:
De controle e de dados.
O barramento de controle trafega as mensagens num formato fixo e proprietário sem acesso ao desenvolvedor, visando garantir a integridade da execução ao agente.
O barramento de dados trafega as mensagens de dados entre diferentes agentes, estando ligado diretamente ao componente sensorial e efetuador para recepção e envio de mensagens de outros agentes.
O formato de mensagens do barramento de dados é um dos hostposts do framework, a ser definido por o desenvolvedor.
Estudos utilizando a plataforma de implementação SemantiCore são apresentados por Blois e outros e Escobar e outros.
Em o primeiro estudo, é apresentado um caso de estudo adaptado de um clássico exemplo da Web Semântica, construído sobre solução baseada em agentes.
O segundo estudo apresenta o desenvolvimento do SemantiCore Mobile, com objetivo de prover suporte de aplicações multiagentes em dispositivos móveis e embarcados.
O Jason é uma plataforma de desenvolvimento de sistemas multiagentes, apresentada por Bordini e outros, baseada num interpretador para uma versão estendida da linguagem AgentSpeak.
Segundo Hübner e outros, além de interpretar a linguagem AgentSpeak original, o Jason possui os seguintes recursos:
A linguagem AgentSpeak (L) foi projetada para a programação de agentes BDI na forma de sistemas de planejamento reativos (reactive planning systems).
Esta linguagem é orientada a agentes e baseada na lógica de primeira ordem, com uso de eventos e ações baseada em arquitetura BDI, como Procedural Reasoning System (PRS).
Embora o Jason tenha sido implementado com base na linguagem AgentSpeak, ele ainda possibilita uma série de extensões que são necessárias para o desenvolvimento de sistemas multiagentes.
Um agente AgentSpeak é definido por um conjunto de crenças que permite obter seu estado inicial através de um conjunto de fórmulas atômicas de primeira ordem e um conjunto de planos que formam sua biblioteca de planos.
Para se descrever um plano, o Jason introduz as noções de objetivos e eventos de disparo.
Em esta abordagem, o objetivo de um agente é um estado do sistema que o agente deseja alcançar, sendo dividido em objetivos de alcance e objetivos de teste.
Em o primeiro, o agente deseja atingir o estado de mundo onde a fórmula atômica associada é verdadeira.
Em o segundo, o agente deseja testar se a fórmula atômica associada é (ou pode ser unida com) uma de suas crenças.
O objetivo é atingido através da biblioteca de planos do agente, determinada a partir de um conjunto de ações que deve ser executada.
Um plano da biblioteca de planos é constituído de cabeçalho e corpo.
O cabeçalho é formado por um evento de disparo (triggering event), o qual define quais eventos podem iniciar a execução de um plano e um conjunto de literais representando um contexto.
O corpo do plano inclui ações básicas, ou seja, ações que representam operações atômicas que o agente pode executar a fim de alterar o ambiente.
Um evento pode ser interno quando gerado por a execução de um plano, ou externo quando gerado por as atualizações de crenças que resultam da percepção do ambiente.
O contexto deve ser conseqüência lógica do conjunto de crenças do agente no momento em que o evento é selecionado por o agente para o plano ser considerado aplicável.
O Jason é implementado em Java e está disponível em código aberto com um ambiente de desenvolvimento integrado (Ide) que permite a execução de programas também em modo de depuração.
Uma vantagem do uso da linguagem AgentSpeak para o desenvolvimento de sistemas multiagentes é que ela possui semântica formal, o que possibilita a verificação formal de sistemas programados.
O JACK Inteligent Agent é um framework desenvolvido por Agent Oriented Software (A os) que traz um conceito de agentes inteligentes numa forte tendência a engenharia de software comercial com suporte ao modelo BDI.
O JACK é a terceira geração de frameworks de agentes, desenhada como um conjunto de componentes leves com alto desempenho de forte tipação de dados.
Segundo Howden e outros, os principais objetivos do JACK são:
Fornecer aos desenvolvedores um framework que provê um robusto, estável e leve produto;
De uma perspectiva de engenharia de software, o JACK é constituído por uma instalação independente de arquitetura, e acrescido de um conjunto de plugins de componentes que abordam os requisitos específicos da arquitetura de agentes.
Em uma visão de programação, o JACK consiste em três principais extensões para Java:
Um conjunto de adições sintáticas, um compilador e um conjunto de classes chamado Kernel, formando a linguagem de programação orientada a agente Jack Agent Language (JAL).
O conjunto de adições sintáticas de JACK se divide em:
Um pequeno número de palavras-chave para identificar o principal componente do agente;
Um conjunto de expressões para definição de atributos fortemente tipados;
Um conjunto de expressões para definição de relacionamentos estáticos;
E num conjunto de expressões para manipulação do estado de um agente.
O compilador do JACK converte as adições sintáticas em classes Java e em expressões que podem ser carregadas e chamadas por outro código Java.
O compilador também transforma parcialmente o código de planos para obter uma correta semântica da arquitetura BDI.
O kernel do JACK provê o suporte em tempo de execução requerido na geração de código, o qual inclui gerenciamento automático de concorrência entre tarefas, comportamento padrão para agentes em reação a eventos, falhas de ação e tarefas, numa infra-estrutura de comunicação para aplicações multiagentes.
Este kernel suporta múltiplos agentes com um processo único, muitos processos, e uma mescla dos dois, sendo esta particularidade conveniente para economizar recursos do sistema.
Segundo Nunes, os agentes JACK são componentes de software autônomos que têm objetivos explícitos para atingir ou eventos para tratar.
O agente pode exibir um comportamento racional sob estímulos pró-ativos (direcionado a objetivos) e reativos (orientado a eventos).
Ainda segundo Nunes, cada agente possui um conjunto de crenças sobre o mundo, de eventos que ele irá responder, e objetivos que deseja atingir.
O alcance de um objetivo pode ser tanto em resposta a uma requisição de um agente externo, como uma conseqüência à ocorrência de um evento, ou quando uma ou mais de suas crenças mudam.
Um conjunto de planos descreve como o agente pode lidar com os objetivos e eventos que possam surgir.
Quando um agente JACK é criado no sistema, ele normalmente fica inativo até que receba um objetivo ou um evento ao qual ele deve responder.
Uma vez que ele receba tal objetivo ou tal evento, o agente determina quais ações são necessárias para alcançar o objetivo ou responder ao evento.
Assim, o Jack apresenta- se como uma plataforma de desenvolvimento de SMAs, com uma linguagem de programação orientada a agentes e voltada para aplicações industriais.
O JACK possui aplicações comerciais como Unmanned Aerial Vehicles (UAVs), e continua em desenvolvimento atualmente.
Considerações Em esse capítulo, foi apresentado todo o estudo teórico realizado para o desenvolvimento do meta-modelo, sendo que este foi uma pesquisa refeita e mais aprofundada em relação a o estudo bibliográfico apresentado em, no intuito de incrementar a proposta deste trabalho com novas abordagens.
O estudo de agentes de software possibilitou uma visão geral da área, além de permitir a identificação das características internas de agentes tratadas na literatura.
Por outro lado, com o estudo das abordagens, foi possível a definição de um meta-modelo inicial.
Ainda nesse capítulo, foram introduzidos os conceitos de restrições de integridade e linguagem OCL, possibilitando assim a aplicação das restrições de integridade e a posterior verificação da consistência de modelos instanciados a partir de o meta-modelo.
Por fim, o estudo de algumas plataformas de implementação de SMAs foi realizado com o objetivo de verificar a possibilidade de geração de código nas mesmas.
Em o capítulo seguinte será apresentado o processo de desenvolvimento do metamodelo baseado no estudo teórico realizado ao longo desse capítulo.
Meta-modelo de representação interna de um agente O meta-modelo para representação interna de agentes de software foi proposto por Santos a partir de o estudo de algumas metodologias e plataformas de implementação de SMAs.
O trabalho de Santos justifica- se por a deficiência na modelagem interna dos agentes de software encontrada nas abordagens pesquisadas e por a necessidade de representar a estrutura interna e o comportamento de um agente para sua posterior implementação.
Em uma análise comparativa com as metodologias MASUP, Tropos, MaSE, Mas-ML, Mas- CommonKADS e Prometheus, Santos identificou algumas entidades e relacionamentos para modelagem interna de agentes, sintetizando os conceitos pesquisados.
Após um processo de refinamento, Santos propôs o MRIA apresentando a definição das entidades, relacionamentos e restrições presentes no metamodelo.
Santos define pacotes para a organização das entidades e relacionamentos do Pacote Decision, o qual contém as entidades Belief, Term, Sentence, Operator e Rule.
Este pacote é responsável por a tomada de decisão dos agentes.
Pacote Sensorial, constituído por as entidades Perceptron, Event, InternalEvent e ExternalEvent.
Este pacote é responsável por a percepção e disparo de eventos internos e externos.
Pacote Communication, contendo as entidades Protocol, Message e Field.
Este pacote representa a interface de interação e comunicação do agente.
Pacote Executor, formado por as entidades Action e Plan.
Este pacote é responsável por as tarefas a serem executadas por o agente.
Pacote Main, o qual possui as entidades Agent, Goal, Resource e Role.
O meta-modelo define os seguintes conceitos.
Agente (Agent):
É um sistema computacional inserido num ambiente, capaz de atingir os objetivos planejados por meio de ações autônomas nesse ambiente.
Objetivo (Goal):
Representa os desejos ou estados futuros que o agente deve atingir.
Recursos (Resource):
Representa uma entidade física ou uma informação.
Papel (Role):
Responsável por uma representação abstrata de uma função de agente, serviço ou identificação dentro de um grupo.
Cada papel pode ter associado a si um conjunto de atribuições e restrições.
Plano (Plan):
Formada por um conjunto de ações, de acordo com a definição de Woldridge, a qual define o plano constituído por pré-condições, corpo e pós-condições.
Ação (Action):
Também conhecido como tarefa, apresenta- se como parte de um trabalho que pode ser atribuída a um agente ou ser executada por este.
Protocolo (Protocol):
Representa o protocolo da mensagem a ser utilizada por o agente.
Mensagem (Message):
Representa as mensagens de entrada e saída do agente.
Campo (Field):
Representa os parâmetros que compõem determinado tipo de mensagem.
Percepção (Perceptron):
Responsável por perceber as mensagens que vem do ambiente para o agente de acordo com um padrão pré-definido.
Evento (Event):
Tem a função de comunicar alterações no ambiente, mensagens enviadas por outros agentes ou mesmo mensagem enviada internamente.
Para cada evento espera- se que o agente dispare uma ação ou um plano.
Evento Interno (InternalEvent):
Especializada da entidade Event, a qual representa uma alteração interna no comportamento do agente.
Evento Externo (ExternalEvent):
Especializada da entidade Event, representa os eventos externos disparados por as mensagens aceitas.
Crença (Belief):
Representa as crenças de um agente expressas em expectativas sobre o estado atual do mundo e sobre a probabilidade de um curso de ação atingir determinados efeitos.
Termo (Term):
Constituído por uma expressão lógica que se refere a um objeto.
Sentença (Sentence):
Uma sentença enuncia fatos, sendo representado por um símbolo de predicado seguido por uma lista de termos, podendo utilizar conectivos lógicos.
Operador (Operator):
Representa os conectivos lógicos utilizados na relação entre uma sentença e uma crença.
Regra (Rule):
Representa os tipos de sentença que devem necessariamente possuir crenças como antecedentes e conseqüentes, em que a primeira implica na segunda.
Os relacionamentos e restrições apresentados entre as entidades do meta-modelo são:
Agent has Resource:
Um agente usa zero ou mais recursos de determinado tipo para auxiliar no alcance de seus objetivos.
Um recurso é usado por um ou mais agentes.
Agent starts InternalEvent:
Um agente dispara zero ou mais eventos internos.
Estes eventos possuem um Clock que pode disparar- lo quando o tempo atribuído coincidir com o tempo atual do sistema ou mesmo sem nenhuma condição associada.
Um evento interno é disparado por um agente.
Agent has Belief:
Um agente contém zero ou mais crenças que armazenam seus conhecimentos.
Uma crença está relacionada com zero ou mais agentes.
Agent has Perceptron:
Um agente contém um ou mais Perceptrons que percebem e avaliam as mensagens recebidas do ambiente.
Um Perceptron está relacionado a um agente.
Agent plays Role:
Um agente exerce um ou mais papéis relacionados a sociedades.
Um papel é exercido por um ou mais agentes.
Role aims Goal:
Um papel almeja o alcance de um ou mais objetivos.
Um objetivo é almejado por um papel.
Role must execute Action:
Um papel deve executar zero ou mais ações.
Uma ação deve ser executada por zero ou um papel.
Goal aggregates Goal:
Um objetivo agrega zero ou mais subobjetivos.
Um objetivo é agregado por zero ou um objetivo.
Plan achieves Goal:
Um plano alcança um ou mais objetivos.
Um objetivo é alcançado por um ou mais planos.
Perceptron starts ExternalEvent:
Um perceptron dispara um evento externo.
Um evento externo é disparado por um perceptron.
Perceptron evaluates Message:
Um perceptron avalia uma ou mais mensagens.
Uma mensagem é avaliada por um perceptron.
InternalEvent extends Event:
Um evento interno especializa um evento.
ExternalEvent extends Event:
Um evento externo especializa um evento.
Event generates Belief:
Um evento gera uma ou mais crenças.
Uma crença é gerada por zero ou um evento.
Plan is composed by Action:
Um plano é composto por uma ou mais ações.
Uma ação compõe zero ou um plano.
Action generates Belief:
Uma ação gera uma ou mais crenças, agindo como póscondições.
Uma crença é gerada por zero ou uma ação.
Belief controls Action:
Uma crença regula zero ou mais ações, agindo como précondições.
Uma ação é regulada por zero ou mais crenças.
Action publishes Message:
Uma ação publica zero ou mais mensagens no ambiente.
Uma mensagem é publicada por uma ação.
Action follows Action:
Uma ação posterior sucede zero ou mais ações.
Uma ação anterior precede zero ou mais ações.
Plan aggregates Plan:
Um plano agrega zero ou mais subplanos.
Um plano é agregado por zero ou um plano.
Belief controls Plan:
Uma crença regula zero ou mais planos, agindo como précondição.
Um plano é regulado por zero ou mais crenças.
Rule has antecedent Belief:
Uma regra tem uma crença como antecedente.
Uma crença é antecedente de zero ou mais regras.
Rule has consequent Belief:
Uma regra tem uma crença como conseqüente.
Uma crença é conseqüente de zero ou mais regra.
Sentence extends Belief:
Uma sentença especializa uma crença.
Term extends Belief:
Um termo especializa uma crença.
Sentence Operator Belief: Uma sentença agrega zero ou mais crenças com o uso de uma classe associativa Operator.
Uma crença é agregada por zero ou mais sentenças com o uso de uma classe associativa Operator.
Rule extends Sentence:
Uma regra especializa uma sentença.
Protocol aggregates Message:
Um protocolo agrega zero ou mais mensagens.
Uma mensagem é agregada por um protocolo.
Message is composed by Field:
Uma mensagem é composta por um ou mais campos.
Um campo compõe uma mensagem.
Message follows Message:
Uma mensagem posterior sucede zero ou mais mensagens.
Uma mensagem anterior precede zero ou mais mensagens.
Field aggregates Field:
Um campo agrega zero ou mais subcampos.
Um campo é agregado por zero ou um campo.
Estas entidades, relacionamentos e restrições formam a proposta de um metamodelo de representação interna de um agente de software.
Sua estrutura modelada está representada na figura 33.
Além de o meta-modelo de representação interna de um agente, Santos apresenta um mapeamento deste meta-modelo para a plataforma de implementação SemantiCore, juntamente com um protótipo que aborda este mapeamento.
Meta-modelo unificado O Meta--modelo Unificado tem como objetivo a integração e interoperabilidade de abordagens metodológicas para desenvolvimento de SMAs.
Esta abordagem envolve a definição de um framework para especificação de SMAs o qual inclui a identificação de um conjunto mínimo de conceitos e métodos.
Esta proposta procura unificar os meta-modelos de ADELFE, Ingenias, PASSI, Rica e Tropos.
É realizada uma compatibilização dos conceitos dessas abordagens através de comparações entre os meta-modelos, com objetivo de se chegar a um meta-modelo comum.
Após esta compatibilização foi proposto um metamodelo inicial que, após passar por um processo de refinamento, formou a proposta atual do Meta-modelo Unificado de Sistemas Multiagentes (MMM ­ Multiagent Meta--Model).
Esta proposta abrange conceitos de agente, papel, tarefa, ambiente e organização, conforme ilustrado na figura 34.
Estes conceitos são definidos, resumidamente, como:
Agente: É uma entidade capaz de agir no ambiente onde está situado, é autônomo por controlar seu próprio comportamento baseado em estímulos interno ou externos, pode comunicar com outros agentes e é capaz de perceber seu ambiente.
Papel: É uma abstração de uma porção de comportamentos sociais de um agente.
Tarefa: Especifica um conjunto de atividades que geram algum efeito.
Ambiente: Algo que o agente possa interagir e/ ou perceber.
Organização: Pode ser definida como uma agregação de papéis, podendo também emergir através da interação entre agentes, sendo que este conceito não foi estabelecido durante a elaboração desta proposta, ficando determinado que é apenas composto por papéis.
Comunicação: É uma propriedade essencial de um agente, a qual permite a interação de um agente para com outro.
Conversação: É uma especialização da comunicação, a qual é definida como a comunicação entre agentes com um propósito pretendido.
Representação: Este conceito foi encontrado na metodologia Adelfe, e adicionado a esta proposta, onde um agente possui uma representação do mundo em termos de crença sobre outro agente, sobre si mesmo e sobre o ambiente onde está inserido.
Esta representação determina o comportamento do agente, podendo ser compartilhada entre os agentes.
Agente cognitivo:
Em esta pesquisa, o agente cognitivo é considerado como o próprio agente, sendo pró-ativo e usa uma representação de seu ambiente.
Esta proposta de meta-modelo está em andamento e será alvo de futuros refinamentos a partir de a inclusão de outras metodologias.
Notação Unificada A Notação Unificada é uma iniciativa que visa um nível de maturidade para modelagem de sistemas multiagentes similar ao da orientação a objetos.
Para a formulação desta notação foram consideradas as metodologias Gaia, O-MaSE, Tropos, Prometheus e Passi.
Os desenvolvedores de cada metodologia abordada envolveram- se nesta proposta no sentido de produzir` uma notação comum, pois acreditam que compartilhando uma notação visual, toma- se o primeiro passo para fazer as metodologias orientadas a agentes serem aplicáveis em consumo industrial.
Esta notação será usada em cada uma das metodologias envolvidas e será integrada dentro de ferramentas que a suporte.
Os conceitos de cada metodologia foram identificados juntamente com seus símbolos para que a padronização fosse criada.
Para confecção dos símbolos foram considerados os critérios propostos por Rumbaugh para desenvolvimento de notações visuais.
De acordo com estes critérios a notação deve:
Possuir um claro mapeamento dos conceitos para símbolos.
Não apresentar sobrecarga de símbolos.
Possuir mapeamento uniforme dos conceitos para símbolos.
Ser fácil desenhar por as mãos.
Possuir boa aparência quando impressos.
Usar imagem monocromática.
Copiar bem ao enviar por fax e cópias usando imagens monocromáticas.
Ser coerente com práticas passadas.
Ser auto consistente.
Possuir distinções não muito sutis.
Possibilitar que casos comuns apareçam simples.
Possuir detalhes suprimíveis.
A proposta sintetizou os seguintes conceitos e seus símbolos associados conforme a figura 35: &quot;Objetivo «&quot;leve «(Softgoals), Ator, Capacidade, Plano, Recurso, Serviço, Objetivo, Agente, Percepção, Evento, Posição, Organização, Papel, Mensagem, Conversação e Ação.
Os conceitos adotados para estas entidades, resumidamente, são:
O Objetivo leve (Softgoal) é utilizado para modelar requisitos não-funcionais.
O Ator (Actor) é uma entidade externa que pode ser um ser humano ou um software.
A Capacidade (Capability) é um módulo que contém planos, eventos, dados e subcapacidades.
O Plano (Plan) é o principal conceito da plataforma de agentes BDI, algumas vezes chamado de tarefa.
O Recurso (Resource) representa informações e recursos externos a serem utilizados por o agente, tais como um banco de dados, uma impressora, um objeto ou um conjunto de crenças.
O Serviço (Service) foi adicionado nesta proposta dado o crescimento de SMAs baseados em serviço e por este conceito estar presente no PASSI, amparando assim este conceito nesta metodologia.
Em o PASSI o conceito de serviço é um único bloco coerente de atividades em o qual um agente irá desempenhar, sendo o serviço associado com o papel do agente.
O Objetivo (Goal) representa a pró-atividade dos agentes.
O Agente (Agent) representa uma entidade autônoma.
A Percepção (Percept) percebe as informações que o agente recebe do ambiente.
O Evento (Event) representa a reatividade de um agente a uma ocorrência significante.
A Posição (Position) é um espaço reservado para um ou mais papéis numa organização.
A Organização (Environment) representa as formas de organizações particulares.
O Papel (Role), a Mensagem (Message) e a conversação (Conversation) são utilizadas para representar os aspectos sociais do agente, assim como a posição e a organização.
A Ação (Action) representa as ações executadas por o agente, e afetam o ambiente onde o agente está situado.
Os relacionamentos entre estas entidades são representadas por links que podem apresentar rótulos de acordo com seu tipo.
Exemplo: &quot;e «inicia\&gt;».
Padghan acredita que a remoção da incompatibilidade gratuita entre as notações encontradas nestas metodologias contribui positivamente para a visualização entre similaridades e diferenças de entidades e notações de cada abordagem, e permite a extensão para abrangência desta proposta.
A pesquisa da Metodologia Unificada está em desenvolvimento em busca de maiores unificações.
Considerações Em este capítulo, foi apresentado os trabalhos relacionados a proposta desta pesquisa.
De entre estes trabalhos, o Metamodelo de Representação Interna de um agente foi tomado como foco desta pesquisa para que seja tomado como base na construção desta proposta, incrementando e extendendo- o.
A Notação Unificada para representação de SMAs e o Meta-Modelo Unificado para modelagem de SMAs, apresentam propostas que abordam a unificação de meta-modelos, mas não uma solução integrada que incorpore o mapeamento dos meta-modelos de diferentes metodologias e que seja capaz de gerar o esqueleto de código para uma plataforma de implementação, independente da metodologia ou da linguagem de modelagem utilizada.
Em o capítulo seguinte será apresentado o estudo para servir de base na consolidação da proposta de integração de soluções de SMAs, com uma compilação comparativa de meta-modelos e notações.
Estudo comparativo de meta-modelos e notações visuais Diferentes meta-modelos e notações visuais são encontrados em soluções para o desenvolvimento de SMAs.
Para compor a construção desta proposta é apresentada uma revisão destes meta-modelos, e suas respectivas notações, no intuito de identificar elementos fundamentais, seus conceitos e relacionamentos.
Além de o MRIA, foram pesquisadas as linguagens de modelagem de Sistemas Multiagentes Anote e Mas-ML, as metodologias Ingenias, Prometheus, Tropos e MESSAGE.
Os meta-modelos destas abordagens foram investigados no intuito de encontrar conceitos e entidades utilizados para composição de um meta-modelo que represente as características comuns e relevantes a todas as abordagens.
Durante a pesquisa não foi possível encontrar o meta-modelo da metodologia Prometheus.
Para levantamento de seus conceitos e relacionamentos, inspecionamos diferentes trabalhos sobre a metodologia e procuramos resolver as inconsistências apresentadas nestes trabalhos sobre o corpo conceitual da metodologia.
A comparação das entidades partiu das definições do MRIA, identificando os conceitos e relacionamentos que esse compartilha com as demais abordagens e outros conceitos e relacionamentos que estejam ausentes e que possam ser introduzidos no MRIA, ampliando a sua semântica.
Vale lembrar que as abordagens trazem conceitos relacionados ao SMA como um todo e o foco deste trabalho foi o subconjunto dessas abordagens voltado à descrição do agente e suas partes internas.
Os conceitos, notações e comparações entre as entidades encontradas na pesquisa, exceto do MRIA que não possui notação visual, são apresentadas nas subseções seguintes.
Durante esta pesquisa encontramos o uso dos termos ator e agente para representar um agente de software.
Em o decorrer deste trabalho usaremos o termo agente.
Em o Anote, o Agente é um modulo que interage com outro agente e desempenha as ações no sentido de alcançar um objetivo, e possui uma limitação de percepção do ambiente do sistema.
Em o Mas-ML, os Agentes são elementos que definem um comportamento e um estado mental, o qual é formado por as crenças, objetivos, planos e ações.
Além de o Agente, Mas-ML aborda o conceito de Objeto com características semelhantes a um agente, porém não autônomo.
Ingenias no Ingenias, o Agente é uma entidade autônoma caracterizada por ter identidade única, propósitos, responsabilidades e capacidades.
Em o MESSAGE, o Agente é uma entidade autônoma e atômica que pode executar papéis, prover serviços, executar tarefas, alcançar objetivos, usar recursos, ser parte de uma organização e participar numa interação com outro agente.
Tropos no Tropos um Ator representa um Agente, um Papel ou uma Posição.
O Agente no Tropos é autônomo, reativo, pró-ativo e possui habilidade social.
Prometheus no Prometheus, o Agente é um software que está situado num ambiente, é autônomo, reativo, próativo, flexível, robusto e social.
O conceito de Agente é apresentado em todas as abordagens pesquisadas, com exceção do Tropos que modela o Agente como um Ator.
As demais abordagens apresentam definições similares, tornando assim o conceito de Agente passível de mapeamento entre estas abordagens.
A metodologia Tropos modela o agente como um Ator, por incorporar os conceitos do framework i*, sendo este ator uma entidade autônoma e social, similar aos conceitos Notação visual para o conceito de Agente do Mas-ML.
Notação visual para o conceito de Objeto do Mas-ML.
Notação para ator do Tropos de Agentes nas demais abordagens.
O Ator em Tropos pode representar, além de um Agente, um papel ou uma posição, onde o papel é uma caracterização abstrata do comportamento de um ator social dentro de um contexto específico e a posição representa um conjunto de papéis, tipicamente executados por um agente.
A linguagem de modelagem Mas-ML, além de apresentar o conceito de Agente, aborda também o Objeto com características similares ao Agente, porém sem autonomia.
Segundo Silva, o Objeto em Mas-ML é um elemento que possui informações sobre o ambiente, sobre si mesmo e sobre outros objetos, e pode executar um papel definido por a organização, podendo controlar seu estado mas não seu comportamento, não sendo autônomo por sempre depender da requisição de outro objeto.
As notações visuais para o Agente divergem entre as metodologias e linguagens de modelagem de SMA.
O Ingenias e o Prometheus apresentam um símbolo com forma de bonecos que fazem alusão à forma humana, enquanto que Tropos utiliza um círculo e MESSAGE uma elipse.
Já o Anote apresenta um retângulo com uma marcação &quot;A «e o nome do Agente dentro de esta forma geométrica, similar ao Mas-ML que apresenta um retângulo para o Objeto e o retângulo com bordas arredondadas para o Agente, diferenciando assim o Objeto do Agente.
Durante a pesquisa encontramos as nomenclaturas Objetivos e &quot;Objetivos Leves «(SoftGoal), sendo que esta pesquisa adota o termo Objetivo.
A definição de Objetivo como um estado que um Agente deseja alcançar está presente na maioria das abordagens e será o conceito adotado nesta pesquisa.
Notação visual para o conceito de SoftGoal (requisitos não-funcionais) do Tropos.
Notação visual para o conceito de HardGoal (requisitos funcionais) do Tropos.
Em estas abordagens, o objetivo é um estado que o Ingenias agente deseja alcançar.
Em o Mas-ML este conceito é abordado como um atributo e modelado como estereótipo da entidade Property (da UML).
Prometheus em Prometheus, o objetivo implementa a pró-atividade de um agente, representando o seu propósito em existir O conceito de Objetivo é apresentado em todas as abordagens pesquisadas com conceitos semelhantes.
O Tropos aborda, além de o objetivo, o conceito de SoftGoal para modelar os requisitos não-funcionais de um SMA.
Com o mesmo intuito o Ingenias apresenta o recurso para modelar os requisitos não-funcionais, porém esta pesquisa adotou apenas o conceito de objetivo.
As definições apresentadas para o objetivo são equivalentes tornando o conceito de objetivo passível de mapeamento entre estas abordagens.
As notações visuais para este conceito coincidem entre o Tropos e o Anote, e divergem entre as demais abordagens.
Tropos e Anote representam visualmente o objetivo com o símbolo de um retângulo com bordas arredondadas.
Além disso, o Tropos apresenta uma nuvem para representar o SoftGoal, representação esta importada do framework i*.
O Ingenias apresenta um círculo para a notação de objetivo.
O MESSAGE apresenta um círculo com bordas duplas e o Prometheus apresenta uma elipse.
Embora o Objetivo esteja presente entre os conceitos do Mas-ML, esta linguagem não apresenta um símbolo para este conceito.
Durante a pesquisa encontramos as nomenclaturas Papel, Funcionalidades e Cenário, sendo que esta pesquisa adota o termo Papel.
A definição de Papel como representação abstrata de uma função ou comportamento de um agente é coerente com as abordagens estudadas e será o adotado nesta pesquisa.
Em o Mas-ML o Papel atua como um guia e restringe o comportamento, podendo ser associado a um agente ou a um objeto, sendo representados por as entidades AgentRole e ObjectRole respectivamente.
Ingenias O papel no Ingenias é uma abstração de um conjunto de funções que possui estado e depende da entidade agente para desempenhar- lo.
Em o MESSAGE, o conceito de Papel possibilita a separação lógica da própria identificação do agente, uma vez que um papel descreve as características externas de um agente num contexto específico quando um agente o exerce.
Tropos no Tropos, o Papel é representado junto com o Notação visual para o conceito de Papel do Objeto do Mas-ML.
Notação visual para o conceito de Papel do Agente do Mas-ML.
Conceito de Ator. Em esta metodologia o Papel é definido como uma caracterização abstrata do comportamento de um ator social dentro de um contexto específico Prometheus Prometheus apresenta conceito de Funcionalidades semelhante ao conceito de Papel em outras abordagens.
Em esta metodologia Funcionalidade é a habilidade necessária para atingir os objetivos.
O conceito de Papel é apresentado em todas as abordagens pesquisadas com conceitos semelhantes.
O MRIA aborda o Papel como uma representação abstrata do comportamento, identificador do agente dentro de um grupo e associado a atribuições e restrições.
O Anote, embora aborde o conceito de Papel, não apresenta esta entidade na composição de seu meta-modelo.
O Mas-ML possui o conceito papel tato associado a objeto quanto a agentes.
As definições de papel nas abordagens pesquisadas são equivalentes, tornando este conceito passível de mapeamento entre estas abordagens.
As notações visuais encontradas para este conceito divergem entre as abordagens.
O Mas-ML apresenta um retângulo com um corte reto na borda superior esquerda para o papel do objeto, e um retângulo com a base com um corte curvilíneo para representar o Papel do Agente.
O Ingenias apresenta um retângulo com um pequeno corte na parte superior na forma da base de um círculo como símbolo para o papel.
O MESSAGE apresenta uma elipse vertical cortada próximo a o meio por uma linha curvilínea.
O Prometheus apresenta um retângulo.
O Tropos por apresentar o conceito de Ator como modelador de Papel, não possui uma notação visual especificamente para o Papel.
Durante a pesquisa encontramos as nomenclaturas Recurso, Aplicação (Ingenias) e Dados (Prometheus), com características associadas a semântica de Recurso, mas utilizaremos o termo Recurso para representar esse conceito.
A definição do Recurso como uma entidade não autônoma e/ ou informacional a ser utilizada por o Agente está coerente com todas as abordagens e será a usada neste trabalho.
O MRIA é o único que associa recurso ao agente.
As demais abordagens relacionam recurso ao ambiente.
Para o MRIA, o recurso representa uma entidade física ou uma informação.
Anote O Anote e o MESSAGE modelam recurso como uma entidade não autônoma, como um banco de dados ou um programa externo usado por o agente Ingenias no Ingenias um recurso representa requisitos não funcionais.
Esta metodologia apresenta a entidade Aplicação utilizada para modelar uma camada de aplicação para entidades de sistemas computacionais, sendo este conceito similar ao conceito de Recurso de outras abordagens.
O Mas-ML não apresenta este conceito.
Tropos no Tropos o Recurso representa uma entidade física ou informacional.
Prometheus O Prometheus utiliza o conceito de Dados (Data), que além de representar as crenças de um agente, representa as informações disponíveis no ambiente a ser utilizada por o agente, como no exemplo apresentado em, em a qual é utilizada a entidade Data para representar um Banco de Dados.
O conceito de Recurso é apresentado no MRIA, no MESSAGE, no Ingenias, no Tropos e no Prometheus com conceitos semelhantes.
As definições encontradas nas abordagens para o recurso são equivalentes entre si, tornando este conceito passível de mapeamento entre as abordagens que o apresentam.
Além de as definições de recurso, o Ingenias aborda o conceito de Aplicação para modelar as aplicações computacionais que podem estar disponíveis no SMA, e o Notação visual para o conceito de Aplicação do Ingenias.
Notação visual para o conceito de Data/ Belief do Prometheus Prometheus apresenta o conceito de Dados para representar um Recurso e também as Crenças de um Agente.
As notações visuais para este conceito coincidem entre o MESSAGE e o Prometheus e divergem entre as demais abordagens.
O MESSAGE e o Prometheus representam visualmente o Recurso (Dados no Prometheus) com o símbolo de um cilindro, fazendo alusão à notação utilizada para bancos de dados.
O Ingenias apresenta a notação de Recurso como um triângulo com a ponta para baixo e o Tropos como um retângulo.
Além disso o Ingenias apresenta uma notação para a Aplicação como um quadrado com uma linha em seu interior na parte superior dividindo- o, notação esta semelhante ao diagrama de classes da UML.
Embora o Recurso esteja presente entre os conceitos do Anote e do Mas-ML, estas linguagens não apresentam um símbolo para este conceito.
Evento Durante a pesquisa encontramos a nomenclatura Evento, e este termo foi adotado nesta pesquisa.
Os conceitos encontrados para Evento podem ser divididos numa comunicação de alteração ocorrida no ambiente, ou na estrutura interna do agente, embora ambos impliquem num comportamento do agente como resposta.
Esta definição será a utilizada nesta pesquisa.
Em o Mas-ML o evento pode iniciar a execução de ações de um agente ou operações de um objeto de acordo com a percepção associada a este evento.
Esta linguagem de modelagem de SMA utiliza a metaclasse Event da UML para representação de eventos.
Tropos O Tropos aborda o conceito de Evento como um lançador de capacidades.
Prometheus no Prometheus, o Evento pode ser percebido de um ambiente, de outro agente ou disparado por uma ocorrência interna.
O conceito de Evento é apresentado em todas as abordagens pesquisadas com conceitos semelhantes.
Embora o evento esteja presente conceitualmente em todas as abordagens, o Anote e o Tropos não apresentam uma entidade Evento em seus metamodelos.
As definições apresentadas para o Evento nas demais metodologias são equivalentes tornando este conceito passível de mapeamento entre estas abordagens.
Apenas o Ingenias e o Prometheus possuem uma notação visual para o evento, e estas divergem entre si.
O Ingenias apresenta um quadrado dividido em sua parte superior por uma linha e com seu lado esquerdo com fissuras, para representar o Evento, e o Prometheus o simboliza através de uma elipse.
Percepção Durante a pesquisa encontramos somente a nomenclatura Percepção, sendo este termo adotado nesta pesquisa.
A definição de Percepção apresentada no MRIA está coerente com as demais definições do Mas-ML, Ingenias e Prometheus, sendo esta adotada nesta pesquisa.
O conceito de Percepção é apresentado no MRIA, Ingenias, Prometheus e MASML.
Em o Mas-ML, a Percepção é realizada por a Crença não apresentando uma entidade para este conceito no seu meta-modelo.
O Anote, o MESSAGE e o Tropos não apresentam este conceito em seus respectivos meta-modelos.
As definições apresentadas para a Percepção nas demais abordagens são equivalentes, tornando este conceito passível de mapeamento entre si.
Somente o Prometheus e o Ingenias apresentam notação visual para este conceito.
O Ingenias utiliza o mesmo símbolo do evento, porém adicionado a letra &quot;A «no centro.
O Prometheus utiliza uma estrela para representar a Percepção.
Notação visual para o conceito de AplicationEvent.
De o Ingenias.
Esta seção aborda as definições para o Plano encontradas nas abordagens pesquisadas com suas respectivas notações.
Durante a pesquisa encontramos as nomenclaturas Plano, Plano de Ação e Fluxo de Trabalho, sendo que esta pesquisa adota o termo Plano.
A definição comum entre as abordagens para o Plano é uma sequência de ações para alcançar um objetivo, sendo este conceito adotado nesta pesquisa.
Em o MRIA o Plano é formado por um conjunto de ações, com pré-condições, corpo e pós-condições associadas.
Anote no Anote, planos de ação são representados como diagramas de ações, não possuindo uma entidade que represente explicitamente o plano Em o Mas-ML, o plano é uma sequência de ações executadas para alcançar um objetivo.
Este conceito é modelado por a metaclasse PlanClass.
Ingenias O Ingenias apresenta o conceito de Fluxo de Trabalho, semelhante ao conceito de Plano de outras abordagens.
Em esta metodologia, o Fluxo de Trabalho permite contextualizar a execução de tarefas e relacionar- las independentemente de seus executadores O Message não apresenta este conceito.
Tropos no Tropos o Plano representa o meio para satisfazer Prometheus O Prometheus na sua fase de Projeto Detalhado (Detailed Design) foca na estrutura interna de cada agente do SMA, trabalhando com agentes baseados em planos e que possuam uma biblioteca de planos definidos por o usuário.
Além disso, no Prometheus os planos otimizam o tempo de resposta aos eventos, Notação visual para o conceito de Fluxo de Trabalho do Ingenias.
O conceito de Plano é apresentado nas abordagens pesquisadas com definições semelhantes.
O MRIA aborda o Plano como um conjunto de Ações com pré-condições, corpo e pós-condições associadas.
O Ingenias apresenta o conceito de Fluxo de Trabalho para contextualizar as Tarefas no alcance de um Objetivo.
O Prometheus apresenta uma biblioteca de planos para agilizar a resposta aos eventos.
O Anote usa um diagrama de ações, não possuindo uma entidade para este conceito em seu meta-modelo.
O MESSAGE é a única abordagem que não apresenta este conceito.
As definições apresentadas para Plano no MRIA, Mas-ML, Ingenias, Tropos e Prometheus são equivalentes tornando este conceito passível de mapeamento entre estas abordagens.
Apenas Ingenias, Tropos e Prometheus apresentam notações visuais para este conceito, e as três divergem entre si.
Ingenias apresenta três elipses ligadas por traços para representar o Fluxo de Trabalho.
Tropos apresenta um losango para simbolizar o Plano, enquanto que o Prometheus utiliza um retângulo com bordas arredondadas.
Durante a pesquisa encontramos as nomenclaturas Ação e Tarefa sendo que esta pesquisa adota o termo Ação.
A definição de Ação como parte de um trabalho ou de um plano que causa mudança no estado do agente quando executada é coerente com as abordagens que utilizam este conceito, sendo esta definição adotada nesta pesquisa.
Em o MRIA, a Ação é parte de um trabalho que pode ser atribuído a um agente.
Anote no Anote a ação é uma computação que resulta em alteração do estado do agente.
Em esta linguagem a ação é dividida em dois tipos:
Ação direta e ação adaptativa, onde a primeira é usualmente executada por um agente enquanto participa de um cenário (ou contexto) para o Notação visual para o conceito de Estado de ação do Anote Notação visual para o conceito de Estado de ação adaptativo do Anote alcance de um objetivo, e a segunda é executada quando o contexto requer a adaptação do agente por motivo de alguma funcionalidade.
As ações compõem o plano e são modeladas como características do comportamento de um agente.
Este conceito é representado por a entidade AgentAction Ingenias O Ingenias apresenta o conceito de Tarefa, similar ao conceito de Ações nas outras abordagens.
Em esta metodologia a execução de tarefas é um meio de satisfazer os objetivos, e de representar uma atividade ou uma capacidade associada a um agente ou a um papel.
Em o MESSAGE, a Tarefa é uma operação que pode causar mudança no estado do mundo do agente Tropos Conforme apresentado no capítulo da base teórica, Tropos é uma metodologia estendida no framework i*.
Em este framework é apresentado o conceito de Tarefa como uma forma particular de se fazer algo.
Esse conceito, assim como a notação visual correspondente, foi absorvido por Tropos na forma de Plano.
O conceito de Ação nas demais abordagens está presente em Tropos como parte da definição do Plano, e não como um entidade própria que compõe seu meta-modelo.
Prometheus no Prometheus, as Ações são executadas por agentes para efetuar uma mudança no ambiente.
O conceito de Ação é apresentado no MRIA, Anote, Mas-ML, Tropos e Prometheus.
O Ingenias e o MESSAGE utilizam o termo Tarefa com conceitos semelhantes à ação de outras abordagens.
O conceito de Tarefa é apresentado apenas por Ingenias e MESSAGE.
Em o Ingenias uma tarefa é usada para representar uma atividade ou uma capacidade associada a um agente ou a um papel.
Ela também é usada 19 Notação visual para o conceito de Tarefa do Ingenias Notação visual para o conceito de Tarefa do MESSAGE para expressar atividades realizadas numa organização, atividades de gestão ou tomada de decisão.
Em o MESSAGE uma tarefa é uma unidade de conhecimento.
Em o Anote a Ação é dividida em Ação direta, quando se executa em curso normal, e Ação Adaptativa, quando uma ação toma um curso alternativo durante sua execução.
O Tropos não possui uma entidade que represente a Ação em seu meta-modelo.
As definições apresentadas para a Ação são equivalentes tornando este conceito passível de mapeamento entre estas abordagens.
Apenas Anote, Ingenias, MESSAGE e Prometheus apresentam notações visuais para este conceito.
Estas notações coincidem entre o Prometheus e o MESSAGE e divergem entre as demais abordagens.
O Anote apresenta um retângulo com os lados curvilíneos, separando por um traço inclinado no canto superior esquerdo a ação direta da adaptativa.
O Ingenias apresenta uma elipse para representar este conceito e MESSAGE e Prometheus apresentam um pentágono horizontal com um cumprimento maior e proporcional da linha da base e do topo.
Durante a pesquisa encontramos as nomenclaturas Mensagem e Interação, sendo que esta pesquisa adota o termo Mensagem.
A definição de Mensagem como uma informação transportada de um agente para outro é coerente com as definições destas abordagens, sendo este conceito adotado nesta pesquisa.
O conceito de Mensagem é apresentado em todas as abordagens pesquisadas com conceitos semelhantes.
O Mas-ML estende a classe Message da UML para criação de uma nova metaclasse para representar este conceito.
O Ingenias e o MESSAGE utilizam a nomenclatura Interação para as trocas de mensagens entre os agentes.
Tropos 21 Notação para o conceito de Interação do Ingenias 22 Notação para o conceito de Interação do MESSAGE.
Apenas Ingenias, MESSAGE e Prometheus apresentam notações visuais para este conceito, com símbolos que divergem entre si.
O Ingenias apresenta o símbolo utilizado para uma notação visual com dois símbolos de agente interagindo com duas setas para representar a Interação entre agentes.
O MESSAGE apresenta um hexágono para representar a Interação, e o Prometheus utiliza o símbolo de um envelope fazendo alusão a um correio, para representar a Mensagem.
Esta seção aborda as definições para o Protocolo encontradas nas abordagens pesquisadas com suas respectivas notações.
Durante a pesquisa encontramos apenas a nomenclatura Protocolo.
A definição para este conceito como o padrão de troca de mensagens associadas com uma interação entre agentes é coerente com as demais, sendo este conceito adotado nesta pesquisa.
O conceito de Protocolo é apresentado no MRIA, Anote, Mas-ML, MESSAGE e Prometheus.
Embora o Anote apresente este conceito, não há um entidade para o Protocolo no seu meta-modelo.
O Tropos e o Ingenias não possuem uma entidade que represente o Protocolo em seus meta-modelos.
As definições apresentadas para o Protocolo são equivalentes tornando este conceito passível de mapeamento entre estas abordagens.
Apenas Prometheus apresenta uma notação visual para este conceito, apresentando como símbolo de Protocolo uma seta com duas pontas, uma para a esquerda e uma para a direita, fazendo uma alusão à troca de mensagens dos Agentes.
Esta seção aborda as definições para a Crença encontradas nas abordagens pesquisadas com suas respectivas notações.
Durante a pesquisa encontramos as nomenclaturas Crença, Estado Mental e Dados sendo que esta pesquisa adota o termo Crença.
A definição de Crença como o conhecimento e expectativas de um agente sobre o estado atual do mundo é coerente com as demais, sendo este conceito adotado para a Crença nesta pesquisa.
Em o Mas-ML, a crença é o conhecimento de um agente sobre o ambiente, outro agente e de si mesmo, e suas percepções sobre tudo que acontece dentro de o SMA Ingenias Em o Ingenias a crença é um conjunto de afirmações que não são certezas, apenas expectativas.
Além de o conceito de Crença, esta metodologia apresenta o conceito de Entidade Mental com conceitos semelhante a Crença em outras abordagens.
Em esta metodologia o estado mental é representado por várias entidades que abordam, entre outras coisas, as informações sobre o mundo, a determinação sobre o que deve ser requerido para cada entidade mental em determinados momentos, e as entidades utilizadas no processo de decisão.
Em o MESSAGE a crença é uma entidade que faz parte do estado mental do agente sendo entendida como uma situação verdadeira.
Tropos em Tropos a crença representa o conhecimento de mundo do Ator.
Prometheus no Prometheus, a Crença armazena informações sobre o estado do mundo do Agente.
Esta metodologia utiliza a entidade Data para representar este conceito, além de utilizar esse mesmo símbolo para representar o O conceito de Crença é apresentado em quase todas as abordagens, com exceção do Anote, com conceitos semelhantes.
O Ingenias aborda além de a Crença, o conceito de Entidade Mental para modelar, entre outras coisas, as informações sobre o mundo vista por os Agentes, e o conceito de Fato como uma informação que o agente aceita como confiável.
As demais definições apresentadas para este conceito são equivalentes tornando- a assim passível de mapeamento entre estas abordagens.
De entre as abordagens pesquisadas, apenas Ingenias apresenta uma notação somente para Crença e apresenta uma nuvem como símbolo para este conceito.
Além 23 Notação visual para o conceito de Estado Mental do Ingenias disso, esta metodologia apresenta também um círculo com a letra &quot;M «no centro, para representar a Entidade Mental.
O Prometheus utiliza o mesmo símbolo que representa o Recurso para representar a Crença.
As demais abordagens não possuem uma notação visual para este conceito.
Esta seção aborda as definições para a Regra encontradas nas abordagens pesquisadas com suas respectivas notações.
Durante a pesquisa encontramos as nomenclaturas Regra, Axioma e Fato sendo que esta pesquisa adota o termo Regra.
A Regra é apresentada entre as abordagens, de uma forma geral, como controladora do comportamento de um agente, sendo este conceito adotado nesta pesquisa.
Em o MRIA a regra é vista como um tipo de sentença que necessariamente deve possuir crenças como antecedentes e conseqüentes, em que a primeira implica na segunda.
Anote O Anote não apresenta este conceito.
O Mas-ML aborda o conceito de Axioma semelhante ao conceito de regras em outras abordagens.
Em esta linguagem de modelagem de SMA, o Axioma é uma regra, principio ou lei estabelecida, a qual caracteriza as limitações globais de uma organização.
Este conceito é apresentado como um atributo de um agente e modelado como estereótipos da entidade Property da Ingenias O Ingenias apresenta o conceito de Fato, similar ao conceito de regras em outras abordagens.
Em esta metodologia o Fato descreve uma informação que o Agente aceita como confiável.
Em o MESSAGE, a Regra é representada por duas entidades (BehaviorRule e InferenceRule) usadas para Notação visual para o conceito de Fato do Ingenias modelar as regras de comportamento e regras de inferências como uma declaração sobre o que um agente conclui de evidencias sobre o mundo.
Tropos O Tropos não apresenta este conceito.
Prometheus O Prometheus não apresenta este conceito.
O conceito de Regra é apresentado no MRIA e no MESSAGE.
O Mas-ML apresenta o conceito de Axioma semelhante ao conceito de Regra, assim como o Ingenias apresenta a entidade Fato.
As demais abordagens não apresentam este conceito.
As definições apresentadas para a Regra são equivalentes tornando este conceito passível de mapeamento entre estas abordagens.
Nenhuma abordagem apresenta uma notação visual para a Regra.
O Ingenias apresenta a mesma notação de Recurso como notação para o Fato.
Esta seção aborda as definições para a Capacidade encontradas nas abordagens pesquisadas com suas respectivas notações.
Durante a pesquisa encontramos duas nomenclaturas Capacidade e Serviço sendo que esta pesquisa adota o termo Capacidade.
A definição de Capacidade é semelhante em MESSAGE (que utiliza o termo Serviço) e Prometheus, os quais a definem como a funcionalidade que o agente é capaz de desempenhar.
Estas definições divergem da definição de Tropos, que apresenta a Capacidade como a habilidade do agente em escolher um plano para determinado objetivo.
Esta pesquisa adota os dois conceitos para a Capacidade.
O conceito de Capacidade é apresentado no MESSAGE, no Tropos e no Prometheus.
As demais abordagens não apresentam este conceito.
As definições apresentadas em MESSAGE e Prometheus são equivalentes tornando este conceito passível de mapeamento entre estas abordagens.
A definição apresentada em Tropos complementa a definições de MESSAGE e Prometheus, e ao estender este conceito, permite o mapeamento entre estas três abordagens.
Apenas MESSAGE e Prometheus apresentam notações visuais para este conceito, e estes símbolos divergem entre si.
Para representar este conceito, MESSAGE apresenta um hexágono com a lateral direita para dentro de a figura e Prometheus apresenta um retângulo com bordas arredondadas.
Esta seção aborda a definição para o Compromisso encontrado na metodologia Ingenias, com sua respectiva notação.
Apenas a metodologia Ingenias apresenta o conceito de Compromisso.
Este conceito é correlato ao conceito de Dependência do Tropos, e ambos podem ser mapeados para troca de mensagem e solicitação de execução de um plano, alcance de um objetivo, fornecimento de um recurso, etc..
A notação do Ingenias para o Compromisso são dois círculos formando uma intersecção, fazendo alusão ao enlace de dois anéis, simbolizando o compromisso destes dois agentes.
Notação visual para o conceito de Compromisso do Ingenias Esta seção aborda as definições para a Organização encontradas nas abordagens pesquisadas com suas respectivas notações.
A definição da Organização como um grupo de agentes com um propósito comum é coerente com as demais, sendo este conceito adotado nesta pesquisa.
O conceito de Organização é apresentado no Anote, Mas-ML, Ingenias e MESSAGE.
Os conceitos abordados para a Organização nestas quatros abordagens são correlatos e passíveis de mapeamento.
O MRIA, o Tropos e o Prometheus não apresentam este conceito.
O Anote, o Mas-ML, o Ingenias e o MESSAGE apresentam notações visuais para este conceito que divergem entre si.
O Anote apresenta como símbolo um cubo.
Mas-ML apresenta um retângulo com a linha da base e do topo curvilíneo.
O Ingenias apresenta um retângulo com três círculos em cima, fazendo alusão a vários agentes juntos, e o MESSAGE apresenta um triângulo apontado para cima.
Esta seção aborda os conceitos apresentados relacionados ao Ambiente, encontrados nas abordagens pesquisadas.
A definição de Ambiente como o local (ou habitat) onde o agente está situado e percebido por este agente é coerente com as abordagens, sendo este conceito adotado para o Objetivo nesta pesquisa.
Em o Anote o agente está situado num Ambiente de um SMA, e este ambiente pode ser especificado por um ontologia.
Em o Mas-ML, o conceito de ambiente é estendido do Tao, e é modelado como o habitat de agentes e objetivos.
Este conceito dividi- se em ambiente ativo ou passivo, onde no primeiro habitam agentes e no segundo objetos.
Ingenias no Ingenias, o ambiente é definido por a percepção e atuação dos agentes.
Esta metodologia apresenta uma visão de ambiente para identificar os recursos e aplicações disponíveis no ambiente com as quais um agente pode interagir.
Segundo Caire, o Agente no MESSAGE está situado num ambiente, porém esta metodologia não apresenta uma entidade no seu meta-modelo para modelar o ambiente.
Tropos O Tropos não apresenta este conceito em seu metamodelo.
Prometheus no Prometheus, o Ambiente é o local onde os Agentes estão situados.
O conceito de Ambiente é apresentado no Anote, Mas-ML, Ingenias, MESSAGE e Prometheus e são passíveis de mapeamento.
O MRIA e o Tropos não apresentam este conceito.
Nenhuma abordagem apresenta notação visual para representar o Ambiente.
Considerações Em este capítulo, foram apresentadas as definições e notações visuais para os conceitos encontrados nas metodologias e linguagens de modelagens de SMA pesquisadas.
Foram abordados os conceito de Agente, Objetivo, Papel, Recurso, Evento, Percepção, Plano, Ação, Mensagem, Protocolo, Crença, Regra, Capacidade, Compromisso, Organização e Ambiente e suas respectivas notações nas Metodologias Ingenias, MESSAGE, Tropos e Prometheus e linguagens de modelagens de SMA Anote, Mas-ML, além de o MRIA.
Estas comparações foram tabeladas, e seus conceitos foram compatibilizados a fim de permitir um mapeamento do conceito entre estas abordagens.
Também foram encontradas e demonstradas as notações que são equivalentes e divergentes.
Puderam- se perceber as diferentes nomenclaturas utilizadas para conceitos similares, Sendo que um termo representativo para os conceitos foi selecionado.
Além disso, algumas definições se completam, havendo pouca divergência entre os conceitos, permitindo o mapeamento entre eles sem que haja incoerência ou perda em seus significados.
As notações são extremamente divergentes entre as abordagens.
Alguns símbolos são iguais para conceitos diferentes, e outros não fazem referência ao conceito que está sendo representado.
Levando em consideração os princípios de Rumbaugh, muitas dessas notações não se enquadram nestes requisitos, e percebe- se uma nãopadronização entre as simbologias das abordagens pesquisadas.
Este capítulo propõe uma extensão ao MRIA para composição do MMI.
São abordadas as adições de novos conceitos e alterações nas entidades e relacionamentos do meta-modelo, e, por fim, são apresentadas as considerações finais sobre a extensão proposta.
A proposta de extensão do MRIA Esta proposta estende o MRIA para suportar o meta-modelo do Tropos com objetivo de demonstrar a cobertura aos modelos derivados das metodologias e linguagens de modelagem pesquisadas neste trabalho.
Os conceitos de cada entidade e relacionamento que compõem o MRIA estão elencados e definidos na seção 3.1 do capítulo de Trabalhos Relacionados.
Como passo inicial, foi utilizada a metodologia Tropos para demonstrar como um meta-modelo pode oferecer um intercâmbio entre os diferentes modelos, a fim de mapear as entidades relevantes das metodologias de acordo com a base teórica de sistemas multiagentes.
Durante o processo de extensão do meta-modelo, a metodologia Tropos foi analisada em profundidade e a ausência de conceitos que estão presentes na literatura indicam lacunas conceituais dessa metodologia.
Conseqüentemente, este meta-modelo contribui para a metodologia ou linguagem de modelagem que está sendo coberta, demonstrando a ausência de conceitos não abordados, mas presentes na literatura.
A extensão realizada para cobertura dos modelos do Tropos resultou na criação do MMI, e num processo de mapeamento desta metodologia para este novo meta-modelo e posterior análise de consistência e geração de código.
O processo de mapeamento de entidades e relacionamentos do Tropos para o meta-modelo proposto considera os meta-modelos apresentados em, e os conceitos presentes na ferramenta TAOM4E, que é a ferramenta que dá suporte a modelagem usando a metodologia Tropos.
Esta ferramenta permite ao desenvolvedor modelar o sistema multiagentes de acordo com a metodologia Tropos abordando as suas três fases especificadas na seção 3.2.3 deste trabalho.
A ferramenta TAOM4E gera um arquivo XML contendo o modelo de aplicação Tropos.
Este arquivo é utilizado no protótipo proposto neste trabalho para demonstrar o processo de mapeamento entre um modelo de Tropos e o MMI.
Embora os meta-modelos de Tropos apresentem entidades que foram suprimidas no TAOM4E, foram considerados os relacionamentos e as entidades presentes neste software, pois o uso do mesmo esclarece algumas questões inconsistentes derivadas das explicações presentes nos artigos estudados sobre esta metodologia.
A seguir são apresentados os conceitos da metodologia Tropos e seu mapeamento para o MMI.
Mapeamento dos conceitos de Tropos Durante o mapeamentos forma compatibilizados os conceitos de Tropos para a construção do MMI.
Foram mapeados os conceitos de ator, objetivo, plano, recurso, além de os relacionamentos de dependência, decomposição e contribuição.
Estes conceitos estão sumarizados na tabela 17.
Vale lembrar que para a composição deste meta-modelo partiu- se do MRIA e assim, alguns dos seus conceitos também foram adequados neste mapeamento.
Um ator no Tropos pode ser um Em a ferramenta TAOM4E o ator em papel, uma posição ou um agente.
Tropos é mapeado diretamente para agentes, sendo este mapeamento adotado por este trabalho.
Assim, o ator de Tropos é mapeado para agente do MMI.
Objetivo objetivo representado Softgoal em por sendo Tropos Hardgoal é Ambas e mapeadas primeiro objetivo, as entidades para foram conceito atribuindo da o equivalente ao conceito de objetivo desenvolvedor a tarefa de tornar o apresentado na seção 5.4 e o softgoal computável.
Papel Um ator em Tropos é um agente que pode ocupar um papel.
Tropos foi mapeado para a entidade papel existente no MMI, embora a ferramenta TAOM4E mapeie o ator diretamente para agentes.
Além sociedade da entidade papel do MRIA é agora representado por o relacionamento com entidade organização, adicionada na extensão deste metamodelo.
Recurso recurso entidade em Tropos que participa uma Esta entidade foi mapeada para dos entidade recurso do MMI.
Plano O plano em Tropos é uma forma de Esta entidade foi mapeada para se fazer algo entidade plano do MMI.
Em o Tropos há o conceito de subobjetivos através do relacionamento de decomposição.
Em o processo de mapeamento, este conceito foi mapeado para as especializações do objetivo que são o objetivo simples (SimpleGoal) e o objetivo composto (ComposedGoal), sendo este último formado por agregações de objetivos, conforme ilustrado na figura 36.
O plano em Tropos participa do relacionamento de dependência em o qual um ator pode depender de outro para realizar um plano, e do relacionamento de meios-fins, onde este plano é um meio para alcançar um objetivo.
O Tropos possui o conceito de subplanos num relacionamento de decomposição, o qual foi mapeado através da entidade plano e de um relacionamento de especialização em planos simples ou compostos.
Os planos compostos são formados por a agregação de planos compostos ou simples, conforme ilustrado na figura 37.
Em Tropos um ator pode ser uma posição.
Em esta metodologia uma posição é um conjunto de papéis a ser ocupado por um agente.
A idéia de uma posição nos remete ao conceito de organização, que é formada por agentes que podem executar papéis e são vinculadas a esta organização de tal forma que o papel pertence a uma organização e o conjunto de vários papéis forma uma posição.
O agente pode alcançar um objetivo através de três formas.
Um agente pode alcançar um objetivo diretamente.
Este relacionamento foi adicionado ao meta-modelo, pois um agente pode ter um objetivo inerente a si, independente da execução de um papel ou da ocupação de uma posição.
Um agente pode executar um papel, e este papel alcança um objetivo.
O papel é uma função que pode ser incorporada ao agente, e está vinculada a uma organização.
Logo ao exercer este papel o agente incorpora este objetivo e almeja alcançar- lo.
Um agente pode ocupar uma posição.
Esta posição é composta por vários papéis e cada papel possui seu objetivo.
Desta forma o agente alcança um objetivo através do papel coberto por a posição ocupada por o agente.
Uma organização alcança um objetivo e é composta por vários papéis executados por agentes diretamente ou através de uma posição.
O alcance dos objetivos de cada papel que compõe uma organização contribui para o alcance do objetivo da organização.
Embora o conceito de organização não esteja presente em Tropos, esta entidade foi adicionada ao MMI para que ele possa mapear alguns conceitos relacionados ao sistema multiagentes e não apenas a estrutura interna de cada agente.
O conceito de organização esta presente na linguagem de modelagem Anote, a qual apresenta a organização como uma entidade virtual para representar um grupo de agentes trabalhando juntos para prover um serviço.
O relacionamento de dependência de Tropos foi mapeado através de troca de mensagens entre agentes.
Em o MMI, assim como no MRIA, a comunicação entre agentes se dá através das mensagens disparadas por as ações que compõem um plano.
A mensagem esta relacionada à entidade campo e ao protocolo, com os quais é possível especificar o objeto de dependência de um agente para com o outro.
As mensagens recebidas por o agente são percebidas através da entidade perceptron, que podem iniciar eventos e estes eventos podem provocar o envio de mensagens de retorno.
O relacionamento de contribuição de Tropos indica que um plano, recurso ou objetivo contribuem para um objetivo de forma positiva ou negativa, adotando como Tropos foi mapeada para a entidade crença com suas especializações termos, sentença, e a classe de relacionamento operador para armazenar estas contribuições.
O desenvolvedor pode estabelecer uma métrica apropriada para o uso destas informações.
O relacionamento de decomposição utilizado para objetivos e planos em Tropos foi mapeado para o MMI como objetivos ou planos simples e objetivos ou planos compostos.
O relacionamento de meios-fins de Tropos indica que um objetivo, plano ou um recurso é um meio para se satisfazer um objetivo.
O objetivo é um meio para se alcançar outro objetivo através das entidades SimpleGoal ou HardGoal;
Um plano é um meio para alcançar um objetivo através do relacionamento plan achieve goal;
E um recurso é um meio para se alcançar um objetivo através do relacionamento plan has resource e plan achieve goal, onde o plano pode utilizar ou prover este recurso ao ser executado.
Novos conceitos e alterações adicionados A extensão ao MRIA implicou em alteração de algumas entidades e seus atributos.
Estas alterações, juntamente com os novos conceitos e relacionamentos adicionados formam o meta-modelo proposto nesta pesquisa.
O objetivo do MRIA foi mapeado para as especializações objetivo simples ou type para mapear o relacionamento de decomposição de Tropos.
Assim como a entidade objetivo, o plano possui as novas especializações plano simples e plano composto.
Para relacionamento Agent has Resource foi movido para Plan has Resource, uma vez que recursos são utilizados ou consumidos por planos.
O relacionamento do MRIA que representa o alcance do objetivo por um agente foi estendido por novos conceitos.
Em o MRIA, o agente pode alcançar um objetivo somente através de um papel.
Em esta extensão proposta, o agente pode alcançar um objetivo que compete diretamente a ele, não necessitando de executar um papel.
O conceito de posição foi adicionado ao MRIA, e esta posição cobre um ou mais papéis.
Assim, um agente pode ocupar uma posição, que agrega papéis e estes alcançam objetivos.
O atributo society foi removido da entidade papel, e substituído por um relacionamento com a entidade organização.
Esta entidade representa um novo conceito adicionado ao meta-modelo, referente a o sistema multiagentes e não a estrutura interna de um agente.
O conceito posição do Tropos foi adicionado ao meta-modelo.
Este conceito foi mapeado para a nova entidade position e relacionada à entidade papel, formando o relacionamento position cover role.
Além disso, foi adicionada a entidade organization e vinculado ao papel, pois um papel pertence a uma organização e esta organização possui um objetivo.
Esta entidade está presente em Anote, Ingenias, Prometheus e Mas-ML O meta-modelo proposto é apresentado na figura 39.
A cada compilação de uma metodlogia que ainda não está mapeada, é realizada uma extensão e/ ou alteração no MMI para que a suporte, bem como a verificação de consistências dos modelos gerados a partir deste meta-modelo.
O MMI é um metamodelo que será adaptado e enriquecido a cada nova metodologia suportada, absorverndo os conceitos da metodologia que estão presententes na literatura de agentes e sistemas muiltiagentes.
Estes novos conceitos possibilitam o suporte de novas metodologias afim de manter um kernel de conceitos que possa suportar modelos de diferentes metodologias para sejam passíveis de mapeamento para código de diferentes plataformas de implementação.
Vale ressaltar que a cada nova adoação de metodologia o MMI se altera e consequentemente deve ser realizado um novo rol de regras OCL para verificação de consistência.
Conceitos do MMI A proposta é estruturada em pacotes para facilitar a compreensão.
Sendo assim, na Figura 40 é apresentada a visão geral dos pacotes do meta-modelo estendido.
Esta seção apresenta também as restrições de integridades escrita na linguagem OCL, pois segundo o uso desta linguagem permite uma restrição nãoambígua e tornam um modelo mais preciso e mais detalhado, podendo ser verificadas por ferramentas de automação para garantir que estão corretas e consistentes com outros elementos do modelo.
Devemos considerar que todas as restrições aplicadas ao MMI usado na classificação dos atributos de cada conceito no protótipo, com o objetivo de evitar constantes conversões de tipos de dados no mesmo.
Em as figuras 41, 42, 43, 44 e 45 são apresentados os diferentes pacotes que compõem o meta-modelo, sendo eles:
Pacote Main, Pacote Sensorial, Pacote Executor, Pacote Decision e Pacote Communication.
Estes pacotes foram importados do MRIA não havendo necessidade de alteração durante o mapeamento.
Após a apresentação visual, são detalhados os atributos de cada pacote, os relacionamentos entre conceitos e as restrições de integridade aplicadas utilizando a linguagem OCL.
Detalhamento do pacote Main:
Agent: Um agente, representado por a entidade agent, é um sistema computacional inserido num ambiente, capaz de atingir os objetivos planejados por meio de ações autônomas nesse ambiente.
Esta entidade possui os seguintes atributos:
Agent. A o atributo state é aplicada uma restrição de obrigatoriedade e uma restrição que indica que o atributo pode assumir os seguintes valores:
Created, execution, ready, blocked e finished.
As restrições em OCL para o conceito de agente são apresentadas da seguinte forma:
O conceito Agent possui os seguintes relacionamentos:
Agent starts InternalEvent:
Um agente dispara zero ou mais eventos internos.
Estes podem ser disparados no instante em que os clocks dos mesmos coincidirem com o tempo atual do sistema ou mesmo sem nenhuma condição associada.
Um evento interno é disparado por um agente.
Agent has Belief:
Um agente contém zero ou mais crenças que armazenam seu conhecimento.
Uma crença está contida em zero ou mais agentes.
Agent has Perceptron:
Um agente contém um ou mais perceptrons que avaliam as mensagens recebidas do ambiente.
Um perceptron está contido num agente.
Agent plays Role:
Um agente exerce um ou mais papéis relacionados a organização.
Um papel é exercido por um ou mais agentes.
Agent aims Goal:
Um agente almeja o alcance de um ou mais objetivos.
Um objetivo é almejado por zero ou mais agentes.
Role: É uma representação abstrata de uma função de agente, serviço ou identificação dentro de um grupo, e pode ter associado a si um conjunto de atribuições e restrições.
Esta entidade possui o atributo name que identifica unicamente o papel na organização.
A o atributo name é aplicada uma restrição de integridade e uma restrição de unicidade.
Essa restrição pode ser expressa da seguinte maneira:
Role aims Goal:
Um papel almeja o alcance de um ou mais objetivos.
Um objetivo é almejado por um papel.
Role has Organization:
Um papel tem uma organização.
Uma organização pode conter zero ou mais papéis.
Role must execute Action:
Um papel deve executar zero ou mais ações.
Uma ação deve ser executada por zero ou um papel.
Role can execute Action:
Um papel pode executar zero ou mais ações.
Uma ação pode ser executada por zero ou um papel.
Em os dois últimos relacionamentos é aplicada uma restrição de integridade que indica que um papel pode ou deve executar pelo menos uma ação, conforme a seguir:
Nessses relacionamentos também é aplicada uma restrição de integridade que indica que as ações de um plano que alcança um objetivo almejado por um papel devem estar de entre as ações que o papel pode ou deve executar:
Goal: É um estado que o agente deseja alcançar.
Esta entidade possui os seguintes atributos:
Name, atributo alfanumérico que identifica um objetivo;
State, atributo alfanumérico que define o estado necessário para que um plano alcance esse objetivo.
Esse estado é representado por as crenças que o agente possui.
A o atributo state é aplicada apenas uma restrição de obrigatoriedade O conceito Goal possui os seguintes relacionamentos:
Role aims Goal.
Agent aims Goal.
Organization aims Goal.
ComposedGoal is aggregates Goal.
SimpleGoal extends Goal:
Um objetivo simples especializa um objetivo.
ComposedGoal extends Goal:
Um objetivo composto especializa um objetivo.
Plan achieves Goal:
Um plano alcança um ou mais objetivos.
Um objetivo é alcançado por um ou mais planos.
Composed Goal: Um objetivo pode agregar outros objetivos, formando desta forma o objetivo composto para alcance do estado desejado por o agente.
Segundo, o objetivo principal pode conter subobjetivos para seu alcance, podendo fazer parte deste objetivo principal, sendo assim este conceito é representado no MMI por o objetivo composto.
Este objetivo composto pode conter objetivos relacionandos através de uma conjução por o operador lógico And, ou disjunção por o operador lógico OR, sendo estes valores lógicos reprentados por o atributo type.
Esta entidade é uma especialização da entidade objetivo (Goal).
Destaca que a noção de subobjetivo é ambígua.
Em certos casos, subobjetivo é conceituado como um objetivo contido no caminho do alcance do objetivo principal, outras vezes, é considerado como uma parte do objetivo principal.
Para o segundo caso, conforme, podemos denominar- lo como objetivo parcial.
ComposedGoal is aggregates Goal:
Um objetivo composto é agregado por um o ou mais objetivos.
Um objetivo agrega zero ou mais objetivos compostos.
Simple Goal: Representa um objetivo simples, em o qual o agente pode executar- lo sozinho para alcançar um determinado estado.
Esta entidade é uma especialização da entidade objetivo (Goal).
SimpleGoal extends Goal.
Position: Representa um conjunto de papéis executados por agentes.
Esta entidade possui o atributo.
Name que identifica unicamente o nome da posição.
A o atributo name é aplicada uma restrição de obrigatoriedade e uma restrição de unicidade.
O conceito Position possui os seguintes relacionamentos:
Position cover Role:
Uma posição cobre zero ou mais papéis.
Um papel é coberto por zero ou mais posições.
Organization: É um grupo de agentes desempenhando funções com um propósito comum.
Esta entidade possui o atributo name para identificar- la.
A o atributo name é aplicada uma restrição de obrigatoriedade e uma restrição de unicidade.
O conceito Organization possui os seguintes relacionamentos:
Role has Organization.
Organization aims Goal:
Uma organização almeja o alcance de um ou mais objetivos.
Um objetivo é almejado por zero ou mais organizações.
Detalhamento do pacote Sensorial:
Perceptron: Representada por a entidade Perceptron, é responsável por perceber as mensagens vindas do ambiente para o agente de acordo com um padrão prédefinido.
Esta entidade possui os seguintes atributos:
Name, atributo alfanumérico que identifica um perceptron;
Type, atributo alfanumérico que define o padrão de mensagens aceita por um perceptron.
A o atributo name é aplicada uma restrição de obrigatoriedade e uma restrição de unicidade.
A o atributo type é aplicada apenas uma restrição de obrigatoriedade O conceito Perceptron possui os seguintes relacionamentos:
Agent has Perceptron.
Perceptron starts ExternalEvent:
Um perceptron dispara um evento externo.
Um evento externo é disparado por um perceptron.
Perceptron evaluates Message:
Um perceptron avalia uma ou mais mensagens.
Uma mensagem é avaliada por um perceptron.
Event: É uma comunicação da alteração ocorrida no ambiente onde o agente está situado.
Esta entidade possui o atributo alfanumérico name que identifica unicamente um evento.
A o atributo name é aplicada uma restrição de obrigatoriedade e uma restrição de unicidade.
O conceito Event possui os seguintes relacionamentos:
InternalEvent extends Event:
Um evento interno especializa um evento.
ExternalEvent extends Event:
Um evento externo especializa um evento.
Event generates Belief:
Um evento gera uma ou mais crenças.
Uma crença é gerada por zero ou um evento.
InternalEvent: Representa as alterações internas no comportamento do agente.
Esta entidade possui o atributo numérico clock que define o instante de tempo que um evento interno será disparado.
O conceito InternalEvent possui os seguintes relacionamentos:
Agent starts InternalEvent.
InternalEvent extends Event.
Detalhamento dos atributos do pacote Executor:
Action: É parte de um trabalho que pode ser atribuído a um agente Esta entdiade possui o atributo alfanumérico name que identifica unicamente uma ação.
A o atributo name é aplicada uma restrição de obrigatoriedade e uma restrição de unicidade.
O conceito Action possui os seguintes relacionamentos:
Role must execute Action.
Role can execute Action.
Plan is composed by Action:
Um plano é composto por uma ou mais ações.
Uma ação compõe zero ou um plano.
Action generates Belief:
Uma ação gera uma ou mais crenças, sendo tratadas como pós-condições dessa.
Uma crença é gerada por zero ou uma ação.
Belief controls Action:
Uma crença regula zero ou mais ações, sendo tratada como pré-condição destas.
Uma ação é regulada por zero ou mais crenças.
Action publishes Message:
Uma ação publica zero ou mais mensagens no ambiente.
Uma mensagem é publicada por uma ação.
Action follows Action:
Uma ação posterior sucede zero ou mais ações.
Uma ação anterior precede zero ou mais ações.
Plan: É formado por conjuntos de ações com pré-condições (circunstâncias em o qual o plano é aplicável), corpo (sequência de ações) e pós-condições (o estado que o plano pode atingir) associadas, que um agente deve executar para atingir seus objetivos.
Esta entidade possui os atributos:
Name, atributo alfanumérico que identifica um plano;
State, atributo alfanumérico que descreve o estado atual da execução de um plano.
Esse estado pode ser representado por crenças do agente ou ainda por ações que estão sendo executadas num dado instante.
A o atributo name é aplicada uma restrição de obrigatoriedade e uma restrição de unicidade.
A o atributo state é aplicada apenas uma restrição de obrigatoriedade.
O conceito Plan possui os seguintes relacionamentos:
Plan achieves Goal.
Plan is composed by Action.
Belief controls Plan:
Uma crença regula zero ou mais planos, sendo tratada como pré-condição destes.
Um plano é regulado por zero ou mais crenças.
Plan has Resource:
Um plano usa zero ou mais recursos de determinado tipo para auxiliar no alcance de seus objetivos.
Um recurso é usado por um ou mais planos.
ComposedPlan aggregates Plan.
SimplePlan extends Plan:
Um plano simples especializa um objetivo.
ComposedPlan extends Plan:
Um plano composto especializa um objetivo.
ComposedPlan: Um plano pode agregar outros planos formando desta forma o plano composto para alcance do objetivo do agente.
Este plano composto pode conter outros planos relacionando- os através de uma conjução por o operador lógico And, ou disjunção por o operador lógico OR, sendo estes valores lógicos representados por o atributo type.
Esta entidade é uma especialização da entidade plano (Plan).
Composed Plan aggregates Plan:
Um plano agrega zero ou mais subplanos, que também são planos.
Um plano é agregado por zero ou um plano.
SimplePlan: Representa um plano simples que o agente executa para alcançar seu objetivo.
Esta entidade é uma especialização da entidade plan (Plan).
SimplePlan extends Plan.
Resource: Representa uma entidade física ou uma informação a ser utilizada por um agente durante a execução de um plano.
Esta entidade possui os atributos:
Detalhamento do pacote Decision:
Belief: Representa as expectativas de um agente sobre o estado atual do mundo e sobre a probabilidade de um curso de ação atingir certos efeitos.
Esta entidade possui os atributos:
Id, atributo alfanumérico que identifica uma crença;
Agent has Belief.
Event generates Belief.
Action generates Belief.
Belief controls Action.
Belief controls Plan.
Sentence extends Belief:
Uma sentença especializa uma crença.
Sentence Operator Belief: Uma sentença agrega zero ou mais crenças com o uso de uma classe associativa Operator.
Uma crença é agregada por zero ou mais sentenças com o uso de uma classe associativa Operator.
Rule extends Sentence:
Uma regra especializa uma sentença.
Rule é um tipo de sentença que necessariamente deve possuir crenças como antecedentes e conseqüentes, em que a primeira implica na segunda.
Rule has antecedent Belief:
Uma regra tem uma crença como antecedente.
Uma crença é antecedente de zero ou mais regras.
Rule has consequent Belief:
Uma regra tem uma crença como conseqüente.
Uma crença é conseqüente de zero ou mais regras.
Term extends Belief:
Um termo especializa uma crença.
Operator: Id, atributo alfanumérico que identifica um operador;
Symbol, atributo alfanumérico que representa o conetivo lógico associado ao conceito Operator, podendo assumir os valores, e.
A o atributo id é aplicada uma restrição de obrigatoriedade e uma restrição de unicidade.
Enquanto que ao atributo symbol é aplicada apenas uma restrição de obrigatoriedade.
O conceito Operator possui os seguintes relacionamentos:
Sentence Operator Belief. O pacote Decision possui o relacionamento detalhado a seguir:
Rule extends Sentence:
É um tipo de sentença que necessariamente deve possuir crenças como antecedentes e conseqüentes, em que a primeira implica na segunda.
Uma regra especializa uma sentença.
Detalhamento do pacote Communication:
Protocol: Representa o protocolo da mensagem a ser utilizada por o agente.
Esta entidade possui o atributo alfanumérico name que identifica o nome de um protocolo de comunicação usado por o agente.
A o atributo name é aplicada uma restrição de obrigatoriedade e uma restrição de unicidade.
O conceito Protocol possui os seguintes relacionamentos:
Protocol aggregates Message:
Um protocolo agrega zero ou mais mensagens.
Uma mensagem é agregada por um protocolo.
Message: Representa as mensagens de entrada e saída dos agentes.
Esta entidade possui os atributos:
Id, atributo alfanumérico usado como identificador de uma mensagem;
Source, atributo alfanumérico usado para identificar o agente emissor de uma mensagem;
Target, atributo alfanumérico usado para identificar o agente receptor de uma mensagem;
Type, atributo alfanumérico usado para identificar o tipo de mensagem ou performativo de determinado protocolo correspondente a uma mensagem;
Language, atributo alfanumérico usado para identificar a linguagem que está sendo utilizada para a representação de uma mensagem.
A o atributo id é aplicada uma restrição de obrigatoriedade e uma restrição de unicidade.
A os atributos source, target, type e language é aplicada apenas uma restrição de obrigatoriedade.
O conceito Message possui os seguintes relacionamentos:
Perceptron evaluates Message.
Action publishes Message.
Protocol aggregates Message.
Message is composed by Field:
Uma mensagem é composta por um ou mais campos.
Um campo compõe uma mensagem.
Message follows: Message:
Uma mensagem posterior sucede zero ou mais mensagens.
Uma mensagem anterior precede zero ou mais mensagens.
Field: Representa os diferentes parâmetros que compõem um determinado tipo de identifica um campo;
Name, atributo alfanumérico que descreve o nome de um para determinado tipo de mensagem;
Value, atributo alfanumérico que define o valor de um campo.
A o atributo id é aplicada uma restrição de obrigatoriedade e uma restrição de unicidade.
A o atributos name é aplicada apenas uma restrição de obrigatoriedade.
A o atributo required é aplicada uma restrição de obrigatoriedade e uma restrição que indica que esse atributo pode assumir o valor` True 'ou` False'.
O conceito Field possui os seguintes relacionamentos:
Message is composed by Field.
Field aggregates Field:
Um campo agrega zero ou mais subcampos, que também são campos.
Um campo é agregado por zero ou um campo.
Considerações Em este capítulo, foi apresentado o meta-modelo gerado a partir de a compilação dos conceitos do Tropos e do MRIA.
As entidades, atributos e relacionamentos do metamodelo foram detalhados.
Em seguida foi apresentado o meta-modelo estendido juntamente com seus conceitos e detalhamento das entidades, dos atributos e dos relacionamentos que compõe este meta-modelo estendido.
O meta-modelo apresentado tem sua base principal no MRIA.
Além disso, recebeu contribuição de conceitos da metodologia Tropos como:
Dependência entre agentes num sistema multiagentes para alcance cooperativo de um objetivo, a decomposição de planos em subplanos e objetivo em subobjetivos e o conceito de posição o qual agrupa papéis.
Além disso, foi identificada uma lacuna conceitual na metodologia Tropos com relação a os conceitos de crença, percepção e eventos que estão presentes na literatura da área.
Os aspectos macro do SMA não estão plenamente incorporados, pois este metamodelo partiu do MRIA que abrange especificamente a estrutura interna de um agente e incorporou os conceitos da metodologia Tropos para desse suporte aos seus modelos.
Assim, o foco do MMI está na estrutura interna de um agente, embora seja estendido para suportar novas metodologias, neste será incorporado os aspectos macros que suportes estes novos modelos.
Em o próximo capítulo será apresentado todo o processo de construção do protótipo para o uso do meta-modelo estendido.
Em sequência, será apresentado um exemplo de uso que ilustre toda a abordagem.
Em este capítulo, serão apresentadas as ferramentas utilizadas para a construção do protótipo MMI4E (Mas Meta--model For Eclipse), a partir de o protótipo de Santos, permitindo o mapeamento dos modelos Tropos para os modelos do MMI através de um assistente (Wizard) e a criação e validação de modelos com base no MMI.
Após, são apresentados também o processo de consistência dos modelos de aplicação e a geração de código, seguido do mapeamento dos conceitos e dos relacionamentos do MMI para a plataforma de implementação SemantiCore.
Em este capítulo também é detalhado o desenvolvimento do protótipo, como o mesmo pode ser estendido e são descritas quais restrições de integridade já estão cobertas no mesmo.
Além disso, é explicado o padrão de representação dos modelos em XML da ferramenta TAOM4E e do MMI4E, e as funcionalidades do protótipo por meio de a visualização de suas interfaces.
Por fim, é apresentado um exemplo de uso que ilustre toda a abordagem.
Ferramentas Utilizadas Para o desenvolvimento do protótipo foram utilizadas a linguagem de programação Java 6, a ferramenta de verificação de restrição de integridade Use e a ferramenta de auxilio de geração de código Velocity.
A ferramenta Use (UML-based Specification Environment) foi escolhida por preencher os requisitos básicos necessários para o protótipo, tendo como principal contribuição a possibilidade de.
Compilação das restrições OCL e a possibilidade de verificação de consistência entre o metamodelo e os modelos.
A versão utilizada é a Use Para a geração de código, foi escolhida a ferramenta Velocity da Apache Software Foundation sob licença de software Apache.
O Velocity oferece alguns projetos, de os quais este protótipo utiliza o Velocity Engine, sendo escrito em JAVA e pode ser facilmente integrado em aplicações Web e frameworks.
O MMI4E abrange um processo de consistência de modelos e geração de códigos através da entrada de um modelo de aplicação.
O protótipo recebe como entrada três arquivos:
Um arquivo XMI representando o MMI, sendo gerado por o software Argo/ UML, um arquivo OCL com as restrições aplicadas ao metamodelo, e um arquivo XML representando o modelo de aplicação, sendo este um modelo Tropos gerado por a ferramenta TAOM4E e mapeado para o MMI através de um assistente de importação (Wizard).
Este processo pode ser visualizado através da figura 46.
O processo do MMI4E divide- se em quatro passos:
Entrada dos arquivos do metamodelo e regras OCL, importação e mapeamento do modelo de entrada, verificação das restrições OCL, verificação da consistência entre o modelo de aplicação e as restrições aplicadas ao meta-modelo, e por fim a geração de código a partir de o modelo de aplicação.
Em o primeiro passo, o protótipo recebe como entradas o arquivo XMI do metamodelo e o arquivo OCL das restrições de integridade no desenvolvimento do software, antes mesmo de executar- lo.
Esses dois arquivos são transformados por um parser do protótipo num arquivo Use.
Com isso, o arquivo Use gerado poderá ser usado como entrada da ferramenta Use que verificará se as restrições aplicadas ao meta-modelo estão escritas de maneira correta.
Em o segundo passo, o protótipo recebe um modelo Tropos modelado na ferramenta TAOM4E e mapeia- o para um modelo MMI utilizando um assistente de importação (Wizard).
Este Wizard realiza os mapeamentos automáticos quando possível e interage com o usuário para tomadas de decisões e preenchimento de informações não disponíveis no modelo original.
Após o mapeamento é gerado um arquivo XML para representar o modelo de aplicação utilizando os conceitos do MMI.
Uma vez realizado o primeiro passo, pode- se verificar se o modelo de aplicação gerado por o segundo passo está consistente com o MMI Para isso, o protótipo usa o modelo de aplicação representado por um arquivo XML num formato proprietário.
Esse arquivo será transformado num arquivo do CMD que será utilizado como entrada da ferramenta Use, instanciando o meta-modelo com o modelo de uma aplicação.
Com isso, a ferramenta Use terá a representação do meta-modelo e suas restrições (por meio de o arquivo Use gerado no primeiro passo) e a representação de um modelo de aplicação (por meio de o arquivo CMD).
Desta forma, a ferramenta Use pode verificar se um modelo de aplicação está consistente com o meta-modelo definido.
Caso esteja consistente, o protótipo permitirá a geração de código do modelo numa dada plataforma de implementação.
Em caso negativo, o modelo deve ser atualizado até que esteja de acordo com o MMI e suas restrições.
O quarto passo consiste na geração de código para uma plataforma de implementação como o SemantiCore.
Basicamente, este passo recebe como entrada o arquivo XML e o transforma em código fonte proprietário de uma plataforma de implementação por meio de um parser definido por o usuário.
Assim, o modelo de entrada é o elemento mapeado e será validado para geração de código, e este deve respeitar as restrições vinculadas ao MMI.
O MMI4E realiza um mapeamento entre o metamodelo de Tropos com base no MMI e posteriormente verifica a consistência e gera código voltados à plataforma SemantiCore.
Mapeamento do MMI para o SemantiCore Em esta seção, será apresentado o mapeamento criado entre os conceitos e relacionamentos do MMI e os elementos da plataforma para a correta geração de código a partir de o uso de um modelo de aplicação.
O mapeamento dos conceitos é descrito a seguir:
Agent: Um conceito Agent foi mapeado para uma extensão da classe SemanticAgent.
O atributo name foi mapeado para o nome da extensão;
O atributo state não foi mapeado diretamente, pois o SemantiCore trata o estado do agente internamente;
O atributo environment foi mapeado para o atributo environment passado como argumento de um SemanticAgent num arquivo semanticoreconfig.
Xml que instancia os agentes na plataforma.
A figura 47 exemplifica parte do mapeamento:
Goal: Um conceito Goal com suas especializações SimpleGoal e ComposedGoal foram mapeados para uma classe Goal.
O atributo name foi mapeado para o nome de uma instância da classe;
Os atributos state e type (do ComposedGoal) não foram mapeados, sendo que o atributo state não foi mapeado diretamente pois a plataforma trata o estado dos objetivos internamente.
A figura 48 exemplifica parte do mapeamento, onde o primeiro parâmetro indica o agente e o segundo indica o modelo de ontologia associado ao objetivo:
Resource: Um conceito Resource foi mapeado para um atributo de uma extensão da classe ActionPlan.
Os atributos name, type e value foram mapeados respectivamente para o nome, o tipo e o valor do atributo que representa o conceito Resource.
A figura 49 seguir exemplifica parte do mapeamento:
Perceptron: Um conceito Perceptron foi mapeado para uma extensão da classe Sensor.
O atributo name foi concatenado com a palavra Sensor e mapeado para o nome da extensão;
O atributo type foi mapeado para o argumento do tipo Object passado no método evaluate da extensão.
A figura 50 exemplifica parte do mapeamento:
Plan: Um conceito Plan com suas especializações SimplePlan e ComposedPlan foram mapeados para uma extensão da classe ActionPlan.
O atributo name foi mapeado para o nome da extensão;
Os atributos state e type (do ComposedPlan) não foram mapeados, sendo que o atributo state não foi mapeado diretamente para o SemantiCore pois o estado de um plano é tratado internamente na plataforma.
A figura 51 exemplifica parte do mapeamento:
Action: Um conceito Action foi mapeado para uma extensão da classe Action.
O atributo name foi mapeado para o nome da extensão.
A figura 52 exemplifica parte do mapeamento:
Term: Um conceito Term foi mapeado para uma classe SimpleFact.
O atributo id foi mapeado para o nome de uma instância da classe e o atributo description foi mapeado para os atributos sujeito, predicado e objeto passados como argumentos da instância.
A figura 53 a seguir exemplifica parte do mapeamento:
SimpleFact contribution1 $= new SimpleFact (&quot;simpleGoal Portable», &quot;Contributes+», &quot;SimpleGoal Available eCulture&quot;);
Sentence: Um conceito Sentence pode ser mapeado para uma classe ComposedFact ou para duas instâncias, cada uma pode ser das classes SimpleFact, ComposedFact ou Rule.
Explicações adicionais sobre o mapeamento de um conceito Sentence são apresentadas no detalhamento do relacionamento Sentence Operator Belief.
Quando o conceito Sentence é mapeado para uma classe ComposedFact, o atributo id é mapeado para o nome de uma instância da classe e o atributo description não é mapeado diretamente para o SemantiCore, pois não existe um atributo que permita a descrição de uma sentença.
A figura 54 exemplifica parte de um possível mapeamento, onde contributions representa o nome da instância, e a e b representam SimpleFacts instanciados:
ComposedFact contributions $= new ComposedFact;
Rule: Um conceito Rule foi mapeado para uma classe Rule.
O atributo id foi mapeado para o nome de uma instância da classe e o atributo description foi mapeado para o atributo name da instância.
A figura 55 exemplifica parte do mapeamento, onde regra representa o nome da instância, DecisaoCompra representa o atributo name, enquanto u e v representam respectivamente as crenças antecedente e conseqüente da regra:
Message: Um conceito Message foi mapeado para uma extensão da classe SemanticMessage.
O atributo id foi mapeado para o nome de uma instância da extensão;
Os atributos source e target foram mapeados respectivamente para os atributos from e to, já existentes na SemanticMessage;
O atributo type foi concatenado com a palavra Message e mapeado para o nome da extensão;
O atributo language foi mapeado para o atributo language que foi incluído na extensão.
A figura 56 exemplifica parte do mapeamento:
Protocol: Um conceito Protocol foi mapeado para um atributo que foi incluído nas extensões da classe SemanticMessage (conceitos Message associados a um conceito Protocol).
O atributo name foi mapeado para o valor desse atributo.
O trecho a seguir exemplifica parte do mapeamento:
Field: Um conceito Field foi mapeado para um atributo que foi incluído nas extensões da classe SemanticMessage (conceito Message associado a um conceito Field).
O atributo id não foi mapeado diretamente para o SemantiCore, pois o mesmo não necessita ser gerado em código visto que sua função é apenas permitir a associação com um conceito Message;
O atributo name foi mapeado para o nome do atributo incluído;
O atributo value foi mapeado para o valor do atributo incluído;
O atributo required não foi mapeado diretamente, pois esse apenas indica se o valor de um campo deve ou não ser informado.
A figura 58 exemplifica parte do mapeamento:
Detalhado o mapeamento dos conceitos do MMI para a plataforma SemantiCore, o mapeamento dos relacionamentos entre esses conceitos é descrito a seguir:
Plan has Resource:
Como explicado no detalhamento do conceito Resource, esse conceito foi mapeado para um atributo de uma extensão da classe ActionPlan.
A figura 59 exemplifica parte do mapeamento:
Agent has Belief:
Um conceito Belief foi mapeado para uma classe SimpleFact, ComposedFact ou Rule criada e adicionada no método setup de uma extensão da classe SemanticAgent.
A figura 60 exemplifica parte do mapeamento:
SimpleFact contribution1 $= new SimpleFact (&quot;simpleGoal Portable», &quot;Contribrutes +, SimpleGoal Available eCulture&quot;);
Agent has Perceptron:
Esse relacionamento foi mapeado para uma chamada do método addSensor dentro de o método setup de uma extensão da classe SemanticAgent.
A figura 61 exemplifica parte do mapeamento:
Plan achieves Goal:
Um conceito Plan foi mapeado para o atributo plan da classe Goal.
O plano é representado no terceiro argumento apresentado no trecho a seguir:
ComposedPlan aggregates Plan:
Um conceito Plan foi mapeado para uma extensão da classe ActionPlan.
Uma instância do tipo ActionPlan pode ser incluída numa outra instância do mesmo tipo por o uso do método addAction.
A figura 63 exemplifica parte do mapeamento:
Plan is composed by Action:
Um conceito Action foi mapeado para uma extensão da classe Action.
Uma instância do tipo Action pode ser incluída numa instância do tipo ActionPlan por o uso do método addAction.
A figura 64 exemplifica parte do mapeamento:
Belief controls Plan:
Um conceito Belief foi mapeado para o atributo preCondition de uma extensão da classe Action que inicia um ActionPlan.
A figura 65 exemplifica parte do mapeamento, onde preCondition representa a crença e AcaoInicial representa a ação que inicia um plano:
SimpleFact preCondition $= new SimpleFact (&quot;simpleGoal Portable», &quot;Contribrutes+», &quot;SimpleGoal Available eCulture&quot;);
SimpleFact postCondition $= new SimpleFact (&quot;simpleGoal eCulture System», &quot;Contribrutes+», &quot;Usable eCulture System&quot;);
Action generates Belief:
Um conceito Belief foi mapeado para o atributo postCondition de uma extensão da classe Action.
A figura 66 parte do mapeamento, onde Contributions representa a ação e postCondition representa a crença:
SimpleFact preCondition $= new SimpleFact (&quot;simpleGoal Portable», &quot;Contribrutes+», &quot;SimpleGoal Available eCulture&quot;);
SimpleFact postCondition $= new SimpleFact (&quot;simpleGoal eCulture System», &quot;Contribrutes+», &quot;Usable eCulture System&quot;);
Belief controls Action:
Um conceito Belief foi mapeado para o atributo preCondition de uma extensão da classe Action.
A figura 67 exemplifica parte do mapeamento, onde EnviarProposta representa a ação e preCondition representa a crença:
SimpleFact preCondition $= new SimpleFact (&quot;simpleGoal Portable», &quot;Contribrutes+», &quot;SimpleGoal Available eCulture&quot;);
SimpleFact postCondition $= new SimpleFact (&quot;simpleGoal eCulture System», &quot;Contribrutes+», &quot;Usable eCulture System&quot;);
Action publishes Message:
Um conceito Message foi mapeado para uma extensão da classe SemanticMessage.
A instância dessa extensão é passada como argumento do método transmit da extensão da classe Action.
A figura 68 exemplifica parte do mapeamento:
Rule has antecedent Belief:
SimpleFact, ComposedFact ou Rule é mapeada para o atributo fact da instância da classe Rule.
O trecho de código para esse relacionamento pode ser visto no mapeamento do conceito Rule.
Rule has consequent Belief:
A instância de uma classe SimpleFact, ComposedFact ou Rule é mapeada para o atributo consequence da instância da classe Rule.
O trecho de código para esse relacionamento pode ser visto no mapeamento do conceito Rule.
Sentence Operator Belief: Caso o atributo symbol de Operator seja igual à, a Sentence é mapeada para uma instância da classe ComposedFact.
Caso o atributo symbol tenha o valor, a Sentence é mapeada para duas instâncias, cada uma pode ser das classes SimpleFact, ComposedFact ou Rule.
Por fim, caso o valor de symbol seja, a crença que a Sentence agrega é negada e é mapeada para uma instância da classe SimpleFact, ComposedFact ou Rule.
O trecho de código para esse relacionamento pode ser visto no mapeamento do conceito Sentence.
Perceptron evaluates Message:
Esse relacionamento foi mapeado para o método evaluate de uma extensão da classe Sensor.
A figura 69 exemplifica parte do mapeamento:
Protocol aggregates Message:
Esse relacionamento foi mapeado para o atributo protocol que foi incluído nas extensões da classe SemanticMessage.
A figura 70 exemplifica parte do mapeamento:
Message is composed by Field:
Esse relacionamento foi mapeado para atributos que foram incluídos nas extensões da classe SemanticMessage.
A figura 71 exemplifica parte do mapeamento:
Action follows Action:
O valor do atributo postCondition de uma extensão da classe Action definida previamente deve ter o mesmo valor do atributo preCondition de uma extensão da classe Action definida na seqüência.
A figura 72 exemplifica parte do mapeamento:
Field aggregates Field:
O atributo representando o subcampo no relacionamento deve ser mapeado para o atributo de um campo representado por uma classe que é um atributo de uma extensão da classe SemanticMessage.
A figura 73 exemplifica parte do mapeamento:
Os conceitos Role, Position, Organization, InternalEvent, ExternalEvent e os relacionamentos Agent plays Role, Agent starts InternalEvent, Role aims Goal, Role must execute Action, Role can execute Action, Role has Organization, ComposedGoal aggregates Goal, Perceptron starts ExternalEvent, Message follows Message, Event generates Belief não foram mapeados diretamente para o SemantiCore, pois a plataforma não trata esses conceitos.
O conceito Operator não foi mapeado diretamente para o SemantiCore, porém, foi considerado no mapeamento do relacionamento Sentence Operator Belief.
Desenvolvimento do Protótipo Em esta seção será apresentada a arquitetura do protótipo criado para o uso do MMI.
Os principais objetivos desse protótipo são mapear os modelos de Tropos, facilitar a entrada de dados de modelos de aplicação, verificar a consistência desses modelos com o meta-modelo e possibilitar a geração de código numa plataforma de implementação, neste caso, no SemantiCore.
O protótipo é dividido nos seguintes pacotes principais:
Sucintamente, estes pacotes podem ser descritos como:
Application: Armazena as classes geradas que representam os agentes de um modelo de aplicação na plataforma SemantiCore Concepts:
Estas classes representam os conceitos do MMI e todos os atributos, independente implementação.
Constraints: Armazena o arquivo constraints.
Ocl, contendo todas as restrições aplicáveis ao metamodelo.
Gui: Este pacote armazena todas as interfaces gráficas do protótipo.
Além de os subpacotes gui.
Consult e gui.
Register, o pacote é composto por as classes CreateModel, LoadModel, MainGui e UseLog.
A Figura 76 apresenta a estrutura geral do mesmo.
A classe MainGui representa a interface principal da aplicação.
Os principais atributos dessa classe são:
ArrayList model, Vector conceptsList Vector relationshipsList.
O primeiro atributo representa todos os dados de um modelo de aplicação corrente, o segundo representa uma lista dos conceitos criados para esse modelo e o último representa uma lista dos relacionamentos entre esses conceitos.
As classes CreateModel, LoadModel e ImportModel possuem uma referência para MainGui.
A primeira é responsável por o armazenamento de um modelo num arquivo XML no padrão de representação de modelos do protótipo.
A segunda permite o carregamento de um modelo representado por um arquivo desse mesmo tipo.
A terceira permite importar um modelo gerado por outras ferramentas, no caso deste trabalho do modelo Tropos construído na ferramenta TAOM4E, para o assistente de importação (Wizard).
Por fim, a classe UseLog representa a interface gráfica onde são apresentados os resultados da checagem de modelos de aplicação.
O pacote gui ainda é constituído por os subpacotes gui.
Register e gui.
Consult. O pacote gui.
Consult armazena todas as interfaces gráficas das consultas de conceitos do protótipo.
Estas interfaces apresentam o conteúdo de cada conceito que é consultado.
Cada interface possui uma referência para MainGui e outra para a classe que armazena o conceito (por exemplo, ConsultAction possui uma referência para MainGui e para Action).
O pacote gui.
Register armazena todas as interfaces gráficas dos cadastros da aplicação.
Além de os subpacotes gui.
Register. Concepts e gui.
Register. Relationships, o pacote é composto por as classes CreateConcept e CreateRelationship.
A primeira consiste numa interface gráfica onde é feita a escolha do tipo de conceito que será criado e a segunda consiste numa interface gráfica onde é feita a escolha do tipo de relacionamento entre conceitos que será criado.
Ambas possuem uma referência para a classe MainGui.
Este pacote possui um subpacote gui.
Register. Relationship.
O pacote gui.
Register. Relationship armazena todas as interfaces gráficas dos cadastros de relacionamentos da aplicação.
Assim, em cada interface devem ser informados os dados do relacionamento a ser cadastrado.
Cada uma das classes desse pacote possui uma referência para MainGui e uma lista para cada conceito que participa de um tipo de relacionamento.
Por exemplo, a classe ActionBelief possui duas listas:
Uma de ações (Vector actionsList) e outra de crenças (Vector beliefsList).
Metamodel: Armazena o arquivo metamodel.
Xmi, para representação do Diagrama de Classes UML do MMI Esse arquivo foi gerado com a ferramenta Argo/ UML Parser:
Armazena classes responsáveis por as traduções do protótipo.
Este pacote composto por as ObjectToUseParser, classes MetamodelToUseParser, CodeParser ModelToObjectParser, ObjectToSemantiCoreParser, conforme ilustrado na figura 77.
A classe MetamodelToUseParser:
Traduz do arquivo XMI que representa o metamodelo juntamente com o arquivo de restrições de integridade OCL para um arquivo Use usado como entrada da ferramenta Use.
Esta classe possui os atributos xmiPathname, oclPathname e usePathname, que representam respectivamente os caminhos dos arquivos metamodel.
Xmi, constraints.
Ocl e o caminho onde será gerado o arquivo Metamodel.
Use. A classe ModelToObjectParser traduz do arquivo que representa o modelo da aplicação para um objeto da classe Metamodel.
Esta classe possui o atributo xmlPathname que indica o caminho do arquivo XML referente a o modelo da aplicação.
Além de o método construtor, possui três métodos:
ReadXML, readConcepts readRelationships.
O primeiro retorna um objeto da classe Metamodel contendo todos os conceitos e relacionamentos do modelo, o segundo retorna uma lista com todos os conceitos do modelo enquanto o último retorna uma lista com todos os relacionamentos do modelo.
A classe ObjectToUseParser:
Traduz de um objeto da classe Metamodel para um arquivo CMD usado como entrada da ferramenta Use.
Esta classe possui os atributos usePathname e metamodel.
O primeiro indica o caminho onde será gerado o arquivo Model.
Cmd e o segundo representa um objeto da classe Metamodel que contém o modelo da aplicação.
Possui o método convertModelToUse que traduz o modelo da aplicação num arquivo Model.
Cmd. A classe abstrata CodeParser:
É estendida para a construção de parsers entre modelos de aplicação e código fonte da plataforma de implementação de SMA.
Além de o ferramenta Velocity, e parseMetamodel (Metamodel metamodel), responsável por a tradução do modelo em código.
Este último consiste num método abstrato que deverá ser implementado na classe filha, conforme a plataforma de implementação escolhida.
A classe ObjectToSemantiCoreParser:
Traduz de um objeto da classe Metamodel para código fonte da plataforma SemantiCore.
Para isso, deve estender a classe CodeParser e implementar o método parseMetamodel (Metamodel metamodel).
Em esse método são feitas as chamadas para os demais métodos do tipo parser, os quais são:
Cada um desses métodos recebe um objeto da classe Metamodel como argumento e efetua a criação de um tipo de arquivo no SemantiCore.
Dentro de cada método ainda existe uma chamada para um método do tipo createContext que recebe como argumentos apenas os atributos do objeto da classe Metamodel relevantes para o contexto do arquivo que está sendo criado.
Por exemplo, o método parseAction efetua a chamada do método variável de contexto Velocity.
Uma vez atribuídos os valores às variáveis de contexto Velocity, as mesmas podem ser referenciadas por arquivos do tipo VTL que servirão como templates para os arquivos gerados.
Relationship: Armazena classes utilizadas para guardar temporariamente os valores dos relacionamentos do meta-modelo durante o processo de geração de código com a plataforma de implementação.
Todas as classes desse pacote estendem a classe Relationship, que é composta por três atributos, são eles:
Support: Armazena as classes Metamodel, ClassAux, FormatPlan FormatResource para auxiliar o protótipo.
A classe Metamodel é responsável por armazenar todos os conceitos e relacionamentos de um modelo de aplicação.
Esta classe possui uma lista (ArrayList) de cada conceito e de cada relacionamento do meta-modelo.
A classe ClassAux é utilizada na classe MetamodelToUseParser para armazenar temporariamente os dados de conceitos do meta-modelo.
Esta classe possui um atributo A classe FormatPlan.
É responsável por a formatação em caixa baixa ou caixa alta do atributo name do plano a ser gerado no código fonte da plataforma de implementação.
Esta classe possui os atributos name, nameUpper, nameLower e state, todos do tipo A classe FormatResource é responsável por a formatação em caixa baixa ou caixa alta do atributo name do recurso a ser gerado no código fonte da plataforma de implementação.
Esta classe possui os atributos name, nameUpper, nameLower, type e Este pacote possui o subpacote support.
Semanticore Em este pacote são armazenadas as classes auxiliares MessageAux e TermAux usadas para a geração de código para a plataforma SemantiCore.
A classe MessageAux:
É responsável por armazenar os dados de um conceito Message e dos conceitos Protocol e Field que se relacionam com o mesmo.
E a classe TermAux:
É responsável por armazenar o atributo id de um termo e armazenar partes do atributo description desse termo nos atributos subject, predicate e object que serão usados no SemantiCore para a representação de um SimpleFact.
Use: Armazena os subpacotes use.
Source e use.
Output, além de os arquivos Metamodel.
Use e Model.
Cmd, utilizados como entrada da ferramenta Use, sendo que o primeiro contém as definições dos conceitos, dos relacionamentos e das restrições aplicadas ao meta-modelo, enquanto o segundo representa o modelo de uma aplicação instanciada do meta-modelo.
O pacote use.
Source armazena as classes que foram criadas com o objetivo de integrar a ferramenta Use com o protótipo desenvolvido.
Sendo assim, foram criadas as seguintes classes:
MyMain, MyModelToGraph, MyOptions, MySession e MyShell.
Essas têm como base algumas classes do código fonte da ferramenta Use com pequenas modificações, possibilitando assim seu uso com o protótipo.
A classe MyMain tem como origem a classe org.
Tzi. Use.
Main. Ela difere da classe original na referência para as novas classes MyOptions, MySession e MyShell, ao invés de ter referência para as classes Options, Session e Shell.
Além disso, esta classe, mapeia as saídas da ferramenta Use para os arquivos logUse txt e logErr txt.
MyModelToGraph tem como origem classe org.
Tzi. Use.
Main. Shell.
ModelToGraph. Ela difere da classe original na alteração do escopo default da classe para público, permitindo assim o acesso por a classe MyShell.
A classe MyOptions tem como origem a classe org.
Tzi. Use.
Config. Options.
Ela difere da classe original nos valores dos atributos specFileName e cmdFileName, representando respectivamente o arquivo Use do meta-modelo e o arquivo CMD do modelo de aplicação.
De essa maneira, tornaram- se possíveis várias checagens de consistência do modelo para uma mesma instância da aplicação Use.
A classe MySession tem como origem a classe org.
Tzi. Use.
Main. Session.
Ela difere system), possibilitando o retorno e a atribuição do estado atual do sistema.
A classe MyShell tem como origem a classe org.
Tzi. Use.
Main. Shell.
Difere da classe original na atribuição do valor false à variável fFinished, possibilitando assim novas checagens de consistência para uma mesma instância da aplicação Use, e no método sistema.
O pacote use.
Output armazena os arquivos que gravam as saídas que seriam impressas no console da ferramenta Use, são eles:
LogUse_ txt e logErr txt.
Assim, o primeiro arquivo armazena erros na estrutura do modelo criado e erros de consistência do modelo com o meta-modelo e suas restrições de integridade, enquanto que o segundo armazena apenas os erros de construção dos arquivos de entrada da ferramenta Use (caso a modelagem seja feita por o protótipo, não ocorrem erros de construção).
Velocity: Armazena todos os arquivos do tipo de template VTL usados na geração de código.
Foram criados os templates action_ vm, agent_ vm, decision_ vm, message_ vm, perceptron_ vm, plan_ vm, semanticoreconfig_ vm e semanticoreinstatiation_ vm para a geração de código para a plataforma de implementação SemantiCore.
O template action_ vm é utilizado para gerar código de uma classe Action, o agent_ vm de uma classe SemantiAgent, o decision_ vm de uma classe DecisonEngine, o message_ vm de uma classe SemanticMessage, o perceptron_ vm de uma classe Sensor, o plan_ vm de uma classe ActionPlan, semanticoreconfig.
Xmlx semanticoreconfig_ vm para semanticoreconfig_ vm para geração do arquivo do arquivo semanticoreconfig.
Xml. Este pacote possui o subpacote velocity.
Conf, o qual armazena os arquivos de configuração de manutenção de logs da ferramenta Velocity, são eles:
Wizard: Armazena as classes responsáveis por iniciar um assistente de importação de metodologias ou linguagens de modelagem de SMA para o MMI.
Este pacote armazena também o arquivo model.
Xml, sendo este o modelo de aplicação resultante do mapeamento, a ser verificado a consistência e gerado o código.
O pacote wizard contém as classes Wizard, WizardForm, ConceptForm, RelationshipForm, Menu, ConceptIndex, RelationshipIndex, Welcome, ModelMapper, Model, Metamodel, ImportProcessor, XMLHandler.
Estas classes seus relacionamentos estão ilustradas no diagrama de classe UML apresentado na figura 78.
A classe Wizard é responsável por desenhar a janela principal do assistente de importação assim como os elementos gráficos que são comum em todas as telas.
Para a A classe WizardForm é uma classe abstrata que utilizada por todos os formulários do assistente, e implementa um painel permitindo a navegabilidade entre as telas, utilizando para isso os objetos previous, current e next.
A classe ConceptForm é uma classe abstrata que estende a classe WizardForm e implementa a classe ActionListener do java.
Awt. Event.
Esta classe implementa a estrutura de um formulário para todos os conceitos a serem importados, interagindo com o usuário através de campos de textos e botões para preenchimento de informações necessários para o mapeamento dos modelos Tropos para o MMI.
A classe RelationshipForm é uma classe abstrata que estende a classe WizardForm.
Assim como a classe ConceptForm está para os conceitos, esta classe implementa a estrutura de um formulário para todos os relacionamentos a serem importados através de interatividade com o usuário.
A classe Menu implementa um tipo abstrato de dados para construção dos menus do assistente.
A classe ConceptIndex é uma classe abstrata que estende a classe WizardForm.
Esta classe implementa uma tela principal para todos os conceitos a serem mapeados.
A partir de esta tela o usuário pode selecionar para qual instância dos conceitos deseja importar e pode partir para os próximos conceitos.
A classe RelationshipIndex é uma classe abstrata que estende a classe WizardForm.
Esta classe implementa uma tela principal para todos os relacionamentos a serem mapeados.
Após a seleção do conceito, através da tela do ConceptIndex, é aberta a tela implementada por a classe RelationshipIndex em a qual o usuário pode selecionar para qual instância do relacionamento deseja importar e pode partir para os próximos conceitos.
A classe Welcome é uma classe abstrata que estende a classe WizardForm, que quando implementada apresenta uma tela inicial de boas vindas e uma breve explicação e dicas de acordo com a abordagem a ser importada.
A classe ModelMapper recebe o arquivo a ser importado por o método ImportModel da tela principal do protótipo, antes de iniciar o assistente, verifica a metodologia ou linguagem de modelagem que será importada.
Após selecionado a abordagem, esta classe instancia o processador de importação adequado, carrega os conceitos e relacionamentos a serem mapeados, cria o modelo de importação e inicia o assistente.
Este procedimento está ilustrado na figura 79.
ImportProcessor importProcessor $= new TroposImport (docReader.
GetElementsByTagName (&quot;TroposClasses&quot;), docReader.\&gt;
Wizard wizard $= new Wizard (new &quot;Model «(&quot;Tropos», importProcessor), loader);
A classe Model representa o modelo a ser mapeado, contendo o nome do modelo e o processador de importação utilizado.
A classe Metamodel possui uma lista encadeada (para todos os conceitos e todos os relacionamentos do MMI, e permite a adição de instâncias destes conceitos ou relacionamentos em suas respectivas listas.
Estas listas serão posteriormente mapeadase processadas para ser gerado o novo arquivo com o modelo de aplicação coerente ao MMI.
A classe ImportProcessor é um classe abstrata que implementa o processamento nome do modelo, handler do tipo XMLHandler contendo o arquivo XML importado a ser manipulado, metamodelo do tipo Metamodel contendo listas com todos os conceitos e de aplicação pós-mapeamento.
A classe XMLHandler utiliza a biblioteca java.
Io para manipular e escrever o arquivo novo a ser gerado com os conceitos mapeados.
Além de estas classes, o pacote Wizard pode possuir subpacotes para cada metodologia ou linguagem de modelagem a serem mapeadas, e como o foco deste trabalho é o mapeamento da metodologia Tropos, foi criado um subpacote wizard.
Tropos o qual estende as classses abstratas deste assistente para permitir a correta importação dos modelos Tropos para o MMI.
O pacote wizard.
Tropos possui a classe TroposWelcome, o qual implementa a tela de boas-vindas para a importação da metodologia Tropos e dicas que guiam o usuário ao preenchimento dos formulários, e a classe TroposImport sendo esta uma extensão da classe abstrata ImportProcessor, contendo os métodos que mapeiam os conceitos e relacinoamento de Tropos para o MMI.
Os principais métodos para o processo de mapeamento da classe TroposImport são o mapConcepts e o mapRelationships, sendo estes indexadores para os métodos mapActor, mapResource, mapGoal, mapPlan, mapDependency, mapDecomposition, mapContribution e mapMeansEnd.
A figura 80 mostra um trecho de código deste processo de mapeamento.
Este pacote possui, também, um subpacote para cada conceito, os quais são:
Wizard. Tropos.
Action, wizard.
Tropos. Agent, wizard.
Tropos. Belief, wizard.
Tropos. Event, wizard.
Tropos. Field, wizard.
Tropos. Goal, wizard.
Tropos. Message, wizard.
Tropos. Organization, wizard.
Tropos. Perceptron, wizard.
Tropos. Plan, wizard.
Tropos. Position, wizard.
Tropos. Resource e wizard.
Tropos. Role.
Cada subpacote deste estende as classes abstratas ConceptForm, ConceptIndex, RelationshipForm, RelationshipIndex para criar as telas de interação com o usuário para permitir a interação no processo de mapeamento, além de usarem a classe TroposImport para mapear estes conceitos com os valores atribuídos no assistente.
Além disso, nestes subpacote estão as classes dos relacionamentos a qual cada conceito participa permitindo o usuário interagir quando o processo de mapeamento não puder ser automático.
Este assistente é flexível o suficiente para suportar mapeamento de novas abordagens, para posterior verificação de consistência e geração de código.
Especialização do Protótipo Uma importante característica do protótipo desenvolvido é a possibilidade de extensão do mesmo de forma que possa ser usado para mapear modelos de novas abordagens e gerar código em outras plataformas de implementação existentes.
Para isso, os seguintes passos são necessários:
Mapeamento dos conceitos e relacionamentos da metodologia ou linguagem de modelagel para o MMI estendendo- o quando necessário.
Criação de subpacotes do pacote Wizard do assistente de importação, e extensão da classe ImportProcessor, Welcome, ConceptForm, ConceptIndex, RelationshipForm e RelationshipIndex.
Mapeamento dos conceitos e relacionamentos do meta-modelo para a plataforma de implementação escolhida.
Criação de uma classe que estende a classe CodeParser e implementa o método parseMetamodel (Metamodel metamodel).
Em esse método, os valores dos conceitos e dos relacionamentos de um modelo devem ser atribuídos a diferentes variáveis inclusas em contextos da ferramenta Velocity.
Com isso, os valores podem ser recuperados por arquivos VTL que servirão como templates para os arquivos gerados.
Criação dos arquivos VTL usados na geração de código para determinada plataforma de implementação.
Conforme a plataforma de implementação usada, pode ser necessária a criação de classes que auxiliem na geração de código.
Padrão de Representação de modelos Tropos e modelos MMI O padrão de representação dos modelos em XML utilizado por o protótipo foi criado com o objetivo de facilitar a integração do mesmo com diferentes ferramentas.
Assim, o arquivo XML gerado pode ser traduzido para uma entrada da ferramenta Use (representada por o arquivo Model.
Cmd), assim como pode ser traduzido para código fonte de uma plataforma de implementação, como SemantiCore utilzada neste trabalho.
Em a figura 81 apresentado um exemplo de um possível trecho de um modelo de aplicação representado no padrão utilizado por o protótipo estendido.
Este protótipo estendido, utiliza os mesmos conceitos desenvolvido por Santos em seu trabalho.
Desta forma, na figura 81, a primeira linha representa apenas a inicialização do arquivo XML.
As tags e indicam respectivamente o início e o fim do modelo de aplicação.
Existem dois tipos de elementos no padrão:
Concept e relationship.
O elemento concept é composto por o atributo def, descrevendo o conceito do metamodelo, e por os atributos relacionados ao conceito.
Porém, existem duas exceções, essas ocorrem quando o atributo def for igual à Sentence ou à Rule.
Em a primeira, além de def e dos atributos relacionados ao conceito, o elemento concept possui os atributos beliefA, beliefB e operator, descrevendo o relacionamento de agregação entre o conceito Sentence e o conceito Belief com o uso do atributo symbol da classe associativa Operator.
Em a segunda, o elemento concept além de def e dos atributos relacionados ao conceito, também é composto por os atributos antecedent e consequent, descrevendo os relacionamentos entre um conceito Rule e dois conceitos Belief.
Em o exemplo, é apresentado um concept com os atributos def igual à Agent, name igual à Cliente, state igual à created e environment igual à ComponentesEnvironment.
Além disso, é apresentado um concept com o atributo def igual à SimpleGoal, atributo name igual à Comprar.
De maneira semelhante, o elemento relationship sempre possui um atributo def, descrevendo o relacionamento do metamodelo, e dois atributos, idA e idB, identificando os conceitos participantes do relacionamento.
Assim, no exemplo é apresentado um relationship com os atributos def igual à Agent_ SimpleGoal, idA igual à Cliente e idB igual à Comprar De maneira similar, o padrão de representação do arquivo gerado por o software TAOM4E para modelos Tropos utiliza a linguagem XML para estruturar seus modelos e cada arquivo é criado ao se salvar um modelo desenhado visualmente por esta ferramenta.
A figura 82, retirada de um trecho do arquivo gerado por o TAOM4E, ilustra este padrão.
Em a figura 82, a primeira tag apresenta a inicialização do arquivo XML, a versão utilizada os tipos de caracteres aceitos.
As tags marcam o conteúdo modelado no software, identificados por um identificador gerado por o TAOM4E.
Para demonstrar as entidades, é utilizado a tag/\&gt;, com um tipo, um identificador e o identificador do dono do elemento.
Em o exemplo apresentado, o HardGoal Comprar pertence ao Actor Cliente, vinculados através de seu Id. Além de a tag é utilizado a tag para os relacionamentos Tropos, tais como dependência, meios-fins e contribuição.
Um exemplo do uso da tag está apresentada na figura 50 retirada de um trecho de código gerado por o software TAOM4E.
Em a figura 83 é demonstrado um exemplo de representação XML de um relacionamento meios-fins (Means-ends) e dependência (Dependency).
Em o exemplo acima, o atributo type da classe TroposRelations determina qual tipo de relacionamento utilizado, o atributo id é o identificador deste relacionamento e o name traz o nome do relacionamento.
Em o primeiro relacionamento, de meios-fins, os atributos targets e sources, informa qual entidade é o meio e qual entidade o fim, e o Actor identifica a qual ator pertence esta entidade.
Em o segundo relacionamento, de dependência, além de as entidades já citadas, há tag com o atributo id que a identifica.
Esta tag possui os atributos markupe que atua como um rótulo, o qual mostra qual entidade é o dependee, depender e dependum neste relacionamento, bem como o motivo why desta relação, e o atributo contents que traz o identificador da entidade relacionada.
Utilização do Protótipo Em esta seção será apresentado o detalhamento da estrutura geral do protótipo e serão mostradas as suas funcionalidades específicas por meio de a visualização de suas interfaces.
A tela principal do protótipo é composta por quatro menus principais, são eles:
File, Model, Code e Help.
A Figura apresenta a tela principal do protótipo.
O menu Model possibilita a checagem de modelos com base no meta-modelo e suas restrições de integridade.
Para isso, existe o item Check Model que quando acionado dispara o processo de checagem retornando para o usuário possíveis erros de consistência entre o modelo de aplicação e o meta-modelo proposto e suas restrições.
O menu Code permite a geração de código caso o modelo esteja consistente com o meta-modelo e suas restrições.
Em o escopo deste trabalho, foi feita a geração de código na plataforma SemantiCore.
Sendo assim, quando o item Generate SemantiCore code é acionado será gerado o código fonte da plataforma respeitando a modelagem realizada.
O menu Help apresenta apenas informações sobre a versão do protótipo disponibilizada no item About.
A importação de um modelo de outra abordagem é realizada ao selecionar a opção Import do menu principal, e após será aberto uma janela de seleção para escolha do menu, conforme ilustrado na figura 85.
Embora este protótipo seja extensível para diferentes abordagens, apenas os modelos tropos são suportados para mapeamento, pois este é o objetivo deste trabalho.
Após a escolha do modelo, é iniciado o Assistente de Importação (Wizard) para a metodologia do modelo.
Junto com a tela é carregado o modelo e o objeto que processa o mapeamento do Tropos para o MMI.
Em esta fase, todos os mapeamentos que puderam ser automáticos já foram realizados na instância do processador de importação.
A o iniciar o Wizard, é apresentado uma tela de boas vindas com informações sobre o assistente e dicas que guiam o usuário no processo de mapeamento, conforme ilustrado na figura.
Após a tela de boas vindas, é apresentada a tela inicial do conceito, sendo o agente o primeiro conceito, o qual lista todas as instâncias deste conceito encontradas na importação, conforme ilustrado na figura 87.
Cada item pode ser selecionado para que o mapeamento seja completado.
Esta interação é necessária quando não foi possível mapear o conceito automaticamente, pois há conceitos que não estão presentes nas metodologias inseridas e este assistente completa- as para que se adéqüe ao MMI.
Uma vez que uma instância de um conceito foi selecionado, é aberto um formulário para que seja completado informações restantes, conforme ilustrado na figura 88.
Em o exemplo da figura, foi selecionado o agente Citizen, e o assistente espera que seja selecionado o estado do agente e seja atribuído o ambiente em o qual este agente está inserido.
Para facilitar este processo, o Wizard possui ilustrações em suas telas das entidades que estão sendo mapeadas, para auxiliar a compreensão do usuário nas tomadas de decisões ou atribuições de informações.
Após preenchido o formulário do conceito selecionado, é exibido uma tela dos relacionamentos em que este conceito está inserido, conforme ilustrado na figura 89.
Este passo é de fundamental importância para o processo de importação, pois demonstra os mapeamentos já realizados automaticamente e espera a decisão para os relacionamentos que possuem mais de uma opção de mapeamento.
Em esta fase, lista- se todas os relacionamentos e estes são menus clicáveis, sendo que cada escolha leva a próxima tela de opção de preenchimento do relacionamento escolhido.
É possível voltar pra esta tela para seleção de todos os itens, porém não são obrigatórios, e o usuário pode prosseguir para o próximo passo a qualquer momento.
Mesmo com este processo, há a possibilidade do modelo não estar consistente pois o usuário não está obrigado a preencher todos os campos, sendo assim a verificação de consistência validará o modelo, e permitirá futuras atualizações de adequação.
A seleção de um relacionamento, conforme exposto anteriormente, exibe a tela para tomada de decisão de como este relacionamento será mapeado.
A figura 90 traz um exemplo deste mapeamento, em o qual o agente pode alcançar os objetivos listados de três formas:
Através de uma posição, de um papel ou relacionar o agente diretamente ao objetivo.
Após realizar o mapeamento, será apresentado a tela da próxima entidade.
Assim como no exemplo foi exibido o conceito de agente, em seguida será o conceito de objetivo, seguidos por papel, organização, posição, enfim, por todos os conceitos presentes no MMI.
Uma vez mapeado, o modelo de aplicação é gerado de acordo com o MMI e este é enviado à tela inicial do protótipo, conforme ilustrado na figura 91.
Em esta tela é possível alterar qualquer entrada, com modificação dos conceitos apenas clicando em cima de o conceito ou relacionamento escolhido.
Além de a alteração, é possível criar ou remover o conceito ou relacionamento.
Uma vez que o protótipo está com o modelo carregado e completo, esta ferramenta permite a checagem de consistência através da opção model e depois check model.
Em essa checagem, são gerados dois arquivos dentro de o subpacote use.
Output, são eles:
LogErr_ txt e logUse txt.
O primeiro foi utilizado com maior freqüência durante o desenvolvimento do protótipo, pois apresenta erros na construção dos arquivos de entrada da ferramenta Use.
O segundo arquivo apresenta erros na estrutura do modelo criado e erros de consistência do modelo com MMI e suas restrições de integridade.
Em esse caso, podem ocorrer erros na construção do modelo e o conteúdo do arquivo é apresentado numa interface do protótipo.
Caso não sejam encontrados erros estruturais, o modelo está consistente e é exibido uma janela com todas as invariantes verificadas e o número de falhas, conforme ilustrado na figura 92.
Após gerado os esqueleto de código para a plataforma SemantiCore por meio de o menu Code ­ Generate SemantiCore code, pode- se utilizar o menu Code ­ Launch SemantiCore para iniciar a plataforma com os agentes instanciados e sendo executados, pronto para utilizar os recursos disponíveis desta plataforma de implementação de SMA, conforme ilustrado na figura 94.
Exemplo de Aplicação Para demonstração da proposta desta pesquisa, utilizamos um exemplo apresentado em para demonstrar a metodologia Tropos.
Este exemplo é um fragmento de uma aplicação real desenvolvida para o governo de Trentino (Província Autônoma de Trento, ou PAT).
Este sistema, chamado de eCulture system, é um &quot;broker «de informações culturais e serviços para a PAT, incluindo informações obtidas de museus, exibições e outras organizações culturais e eventos, o qual pode ser utilizado por diversos usuários, incluindo cidadãos de Trento e turistas procurando o que fazer, ou estudantes escolares pesquisando por conteúdos relevantes a seus estudos.
Em a fase de requisitos iniciais, Tropos identifica os stakeholders e suas intenções.
Para o exemplo do eCulture System, foram identificados os seguintes stakeholders:
Província Autônoma de Trento (PAT), que é a agência do governo, com objetivo de incluir informações e serviços públicos, incrementar o turismo através de novas informações de serviços;
Museu, que é o maior fornecedor de informações culturais, e possibilita uma interface de seu sistema para outros sistemas culturais ou de serviços;
Visitante, que quer acessar as informações culturais antes ou durante sua visita a Trento;
Cidadãos, os quais desejam acessar facilmente informações;
Durante o processo de mapeamento do modelo de Tropos gerado no modelador TAOM4E cada ator é mapeado para um agente, possuindo este mapeamento baseado na utilização deste software que durante a modelagem, para a fase de arquitetura, é criado uma tabela de capacidades onde é convertido cada ator para agentes, sendo este processo adotado nesta pesquisa durante a fase de mapeamento de modelo Tropos para o metamodelo estendido proposto.
Em a fase de requisitos finais, Tropos foca no sistema, neste caso no sistema eCulture System, juntamente com suas funções e qualidades.
O sistema é representado por um ator e suas dependências com outros atores que juntos definem os requisitos funcionais e não funcionais.
Em a figura 95, Bresciane entre outros demonstra um conjunto de objetivos e softgoals que o ator PAT delega para o ator eCulture System, e também o diagrama de objetivos de eCulture System com as decomposições de objetivos e a forma de contribuição entre objetivos e/ ou softgoals.
Os objetivos e softgoals de Tropos são mapeados para o metamodelo estendido proposto com objetivo simples ou objetivo composto, ficando a cargo de o desenvolvedor implementar o softgoal como objetivo, pois trata- se um requisito não-funcional.
O relacionamento de contribuição do Tropos para com o objetivo é mapeado para crença, em o qual durante o processo de importação esta contribuição é armazenada em sua base de crenças, contendo quais objetivos contribuem e de que forma para outros objetivos.
Ainda nesta fase, há uma revisão do diagrama de ator após a introdução do ator na dependência.
A figura 96 apresenta como a dependência é analisada dentro de o diagrama de objetivo do sistema.
De esta análise pode se observar:
O objetivo &quot;busca de informação «(search information) pode ser alcançado por diferentes planos:
Busca por área, busca por área geográfica, busca por palavras chaves e busca por período;
É demonstrado a decomposição em subplanos para os quatro tipos de pesquisas, em o qual o subplano &quot;encontrar fontes de informação «depende do Museu para a descrição das informações a serem providas e o subplano &quot;sintetizar resultados «depende do Museu para consulta do resultado, e por fim, ao pesquisar informações sobre uma determinada área temática, o cidadão é obrigado a fornecer informações, utilizando um formulário de especificação de área.
Em o processo de mapeamento para o metamodelo estendido proposto, o recurso área especification form é mapeado para recurso a ser relacionado com um ou mais planos.
Para a realização dos relacionamentos, no momento da importação o protótipo proposto possibilita a associação com entidades já existentes ou criação de novas entidades.
Assim, o protótipo lista os planos existentes ou possibilita a criação de novo plano para ser vinculado com este recurso, e conseqüentemente realizar a associação deste plano com uma ou mais ações e um objetivo.
Como utilizamos a mensagem para o mapeamento de dependência de Tropos para o metamodelo estendido proposto, a relação de dependência entre o ator eCulture system e Citizen, o mapeamento trata este relacionamento como uma mensagem a ser disparada por uma ação, neste caso a mensagem é disparada por uma ação que compõe o plano search by área contendo como conteúdo da mensagem o recurso área especification form.
Assim como anteriormente, a dependência do depender Citizen para o dependee information é mapeado para o conteúdo da mensagem a ser disparada por uma ação presente na estrutura interna do agente remetente.
Esta ação é criada ou selecionada e devidamente associada através do protótipo durante o processo de importação.
Para este último mapeamento de dependência, pode se considerar o conteúdo da menagem como information», pois o dependum está vinculado a estrutura interna do dependee, podendo constatar esta afirmação ao se utilizar o modelador TAOM4E para criação de dependência.
O relacionamento de meios-fins é mapeado para uma associação entre entidade.
Assim o relacionamento do plano search by área para o objetivo search information é mapeado para o relacionamento plan achieve goal, bem como os planos search by geografical area, search by keywords e search by time period.
O relacionamento de decomposição And ou OR é mapeado para plano simples ou plano composto e objetivos simples ou objetivo composto, e tanto o plano quanto objetivo possui um atributo type que identifica se esta decomposição é do tipo And ou OR.
Assim, o plano search by area é mapeado para um plano composto do tipo And por os planos area, que por sua vez é composto por os planos simples query sources e find info sources.
Os relacionamentos de dependência entre o ator eCulture System e Museum, por os recursos info about source e query result são mapeados para envio de mensagens, através de ação ligados no primeiro relacionamento ao plano find info sources e no segundo ao plano syntesize results da estrutura interna do agente eCulture System contendo como conteúdo da mensagem consecutivamente:
O agente eCulture System solicita o recurso info about source do agente Museum e o agente eCulture System solicita o recurso query result do agente Museum.
A fase arquitetural define a arquitetura global do sistema em termos de subsistemas, representado por atores, interconectados entre si por um sistema de dependência, demonstrados na figura 97.
Estes relacionamentos de dependência entre atores para alcance de objetivos formam a estrutura multiagentes, onde há a comunicação e cooperação entre diferentes agentes para alcance de objetivos particulares pertencentes à estrutura interna de cada agente.
A dependência é mapeada através de mensagens ligadas a ação de cada agente remetente (tratado em Tropos como depender).
Desta forma, é realizada a importação de um modelo Tropos para o MMI intermediado por o protótipo.
Este modelo Tropos, na importação com o protótipo, foi gerado por o software TAOM4E através de uma modelagem visual e salvo num arquivo XML com descrição das entidades e relacionamentos modelados.
Este arquivo é lido e através de um assistente de importação é mapeado como apresentado nesta seção, passo a passo.
Para ilustrar o escopo do código da plataforma SemantiCore gerado por o protótipo, a partir de a modelagem do exemplo exposto, abordaremos os arquivos gerados:
DependencySensor do tipo semanticore.
Sensor classe gerada no DependencyMessage pacote do tipo SemanticMessage geradas no pacote semanticore.
A classe eCultureSystem do tipo SemanticAgent geradas no pacote application;
A classes eCultureSystemDecision do tipo DecisionEngine geradas no pacote semanticore.
A classe SynthesizeResults do tipo ActionPlan geradas no pacote semanticore.
E as classes ActionSynthesizeResults do tipo Action geradas no pacote semanticore.
Os arquivos semanticoreconfig.
Xml e semanticoreinstantiation.
Xml e as classes DependencySensor, DependencyMessage e SynthesizeResults puderam ser geradas automaticamente em sua totalidade.
Para a classe eCultureSystem foram gerados automaticamente os termos, as sentenças e as regras associadas ao agente.
Assim como foram criadas as associações com as classes Sensor, ActionPlan e a associação entre as classes ActionPlan e Action.
Além disso, no Semanticore, cada ação deve estar associada à pelo menos um plano, e no MMI, uma ação pode ser independente de planos.
Caso isso ocorra, o trecho de código com a criação e o uso de uma classe ActionPlan não é gerado automaticamente.
Um pequeno trecho do código desta classe ilustra este mapeamento na figura 98.
Super (env, agentName, arg);
Para a classe eCultureSystemDecision foi gerada apenas a estrutura geral da classe, pois as demais estruturas do mecanismo decisório serão dependentes de cada aplicação modelada.
De entre o código gerado, está inclusa a assinatura do método decide, responsável por avaliar os fatos que a classe SemanticAgent recebe do ambiente.
Um trecho abreviado do código desta classe está demonstrado na figura 99.
SimpleFact simpleFactA $= (SimpleFact)( (ComposedFact) SimpleFact simpleFactB $= (SimpleFact)( (ComposedFact) SimpleFact m $= new SimpleFact (&quot;simpleGoal Portable», &quot;Contributes+», &quot;SimpleGoal Available eCulture&quot;);
Para a classe ActionSynthesizeResults foram geradas automaticamente as mensagens associadas à ação assim como as crenças geradas por a mesma.
O campo content (conteúdo da mensagem) associado a uma mensagem (extensão da classe SemanticMessage) não foi gerado, pois esse terá um valor diferente para cada execução da aplicação.
Um trecho do código desta classe está demonstrado na figura 100.
SimpleFact fact $= new SimpleFact (&quot;SimplePlan «Synthesize Result», &quot;Dependency», &quot;Resouce Query Result&quot;);
DependencyMessage message $= new DependencyMessage (eCultureSystem, Museum, fact, «fipa-sl, null);
Considerações Em esse capítulo foi detalhado a implementação e exemplo de uso, apresentado com as ferramentas utilizadas, o mapeamento do MMI para o SemantiCore, o desenvolvimento do protótipo e sua especialização, o padrão de representação dos modelos do Tropos e do MMI, a utilização do protótipo.
E um exemplo de aplicação.
Para a composição do protótipo, foram utilizadas as ferramentas Use para compilação das restrições OCL, verificando assim a consistência do modelo e Velocity para geração de código integrado ao protótipo.
Além de estas ferramentas foi desenvolvido um Wizard para importação de modelos de outras abordagens para o MMI, que neste trabalho foram mapeados os modelos de Tropos gerados por a ferramenta TOM4E.
Após foi apresentado os quatros passos utilizados para o uso do protótipo, chamado de MMI4E.
Após, foram apresentados o mapeamento do MMI para o Semanticore.
Em este mapeamento as entidades, atributos e relacionamentos do MMI foram mapeados para código da plataforma SemantiCore.
Em seguida, foi apresentado o desenvolvimento do protótipo, abordando os seus conceitos e estrutura geral através dos pacotes, diagramas de classes e trechos de código.
Além disso, foi apresentado os passos a serem tomadas para a especialização deste protótipo possibilitando cobertura para novos modelos de diferentes abordagens e geração de códigos para outras plataformas de implementação.
Este capítulo apresenta, também, o padrão de representação dos modelos de Tropos gerados por o TAOM4E e do modelo do MMI.
É descrito os elementos que compõem estes padrões de representação de modelo, permitindo assim o mapeamento de um modelo para o outro.
A utilização do protótipo é apresentada em detalhes através da visualização de suas interfaces.
Inicialmente é apresentada a tela inicial, os menus e suas funcionalidades.
Após, é apresentado os passos para a importação dos modelos e o assistente de importação.
O assistente de importação é demonstrado através de suas telas, passando por índice do conceito, formulário do conceito, índice do relacionamento e formulário do relacionamento.
E por fim é apresentado o processo de verificação de consistência e geração do código para a plataforma SemantiCore.
Um exemplo de aplicação é apresentado para ilustrar a abordagem desta proposta.
Como exemplo foi utilizado um fragmento de uma aplicação real desenvolvida para o governo da Província Autônoma de Trento, sendo este um exemplo de uso do Tropos publicado na literatura.
Após o exemplo, é demonstrado o código gerado por o protótipo para a plataforma de implementação SemantiCore.
Como principais contribuições têm- se a possibilidade de inserir novos conceitos não abordados na metodologia Tropos, embora presente na literatura, durante o processo de importação.
O assistente mapeia os conceitos e possibilita a criação de novas entidades e relacionamentos tais como crenças, pós e pré-condições para planos e ações, adição de ações que compõe uma ação, mensagens, percepções, entre outros.
A pesquisa realizada busca possibilitar uma integração de soluções que abrangem metodologias, linguagens de modelagem e plataformas de desenvolvimento de SMAs, bem como os meta-modelos inerentes destas abordagens, junto ao MRIA, apresentado no capítulo 3.
Além disso, é proposta uma extensão ao protótipo de Santos, para a geração do esqueleto de código de aplicações para a plataforma de implementação de SMAs, desconsiderando aspectos específicos de cada abordagem pesquisada.
Em este trabalho, foram pesquisadas as metodologias MASUP, Tropos, Prometheus e Ingenias, e as linguagens de modelagem de agentes Anote, Mas-ML e Message, além de as plataformas de implementação SemantiCore, Jason e Jack.
De entre os estudos realizados, apresentou- se uma análise comparativa dos conceitos das metodologias e linguagens de modelagem, com enfoque nas entidades e relacionamentos que formam o metamodelo de cada abordagem, bem como a utilização de notações visuais, quando presente.
Em o MMI foram mesclados os conceitos de sistemas multiagentes aos conceitos da estrutura interna de um agente para suportar a metodologia Tropos.
Foram adicionados os conceitos de Posição e Organização, e foram alterados os conceitos de objetivo, plano e o relacionamento entre objetivo e agente.
Este metamodelo suporta as entidades e relacionamentos da metodologia Tropos, através de um mapeamento apresentado no capítulo 5.
Para a proposta do metamodelo estendido, são consideradas as características tratadas na literatura e nas metodologias estudadas.
Assim, torna- se possível o mapeamento destas metodologias estudadas para o metamodelo proposto.
Em este processo, este metamodelo absorve os conceitos presentes nas metodologias quando estendido.
Após, busca- se um mapeamento direto para a geração de código fonte para plataformas de sistemas multiagentes.
Além disso, também foram estudadas duas soluções que buscam unificar conceitos de entidade e relacionamentos de algumas metodologias através de um Metamodelo Unificado, e padronizar símbolos de notações visuais através da Notação Unificada.
Segundo Padghan, uma notação visual única Constitui- se num primeiro passo para elevar o nível de maturidade de desenvolvimento de SMAs.
Este nível de maturidade já é constatado na programação orientada a objetos, e um metamodelo unificado torna possível abordar diferentes metodologias, focando- se no processo de desenvolvimento, uma vez que as entidades e relacionamentos são comuns.
Estas propostas buscam integrar soluções ao desenvolvimento de SMAs, porém não apresentam um mapeamento direto para geração de código fonte para plataformas de sistema multiagentes através de um processo automático de importação, verificação e geração de código.
De o estudo realizado, as maiores contribuições são:
A síntese das abordagens das metodologias e linguagens de modelagem estudadas, com enfoque no metamodelo de cada abordagem;
O mapeamento dos conceitos de cada entidade e relacionamento de todas as metodologias e linguagens de modelagem pesquisadas, bem como a tabulação dos diferentes símbolos utilizados na notação visual de cada abordagem, o que torna possível o mapeamento entre elas e a interoperabilidade entre os diferentes metamodelos;
A constatação e demonstração da possibilidade de extensões ao metamodelo que possam dar cobertura a todos estes conceitos, trazendo independência entre o processo de desenvolvimento do software para plataformas de implementação;
A extensão ao protótipo proposto por Santos para suporte ao MMI, permitindo a importação de modelos do ambientes de modelagem TAOM4E para o MMI, verificação de consistência através de novas adições de restrições de integridades e novos mapeamentos de adequação ao metamodelo estendido para geração de esqueleto de código para a plataforma SemantiCore.
Contudo, surgem diversas possibilidades de trabalhos futuros para esta pesquisa.
A principal continuação deste trabalho é a adoção das outras metodologias e linguagens de modelagem já mapeadas, resultando em novas extensões deste metamodelo, com intuito de suportar um número maior de soluções voltadas ao desenvolvimento de SMAs.
Uma vez que os conceitos das entidades e relacionamentos destas soluções já estão mapeados, a extensão desta proposta para abranger as demais linguagens e metodologias é facilitada, contribuindo para uma interoperabilidade entre os metamodelos destas abordagens evidenciando os conceitos que não são abrangidos, porém estão presentes na literatura.
Uma vez que os símbolos das notações diagramáticas estão mapeados, torna- se mais fácil a construção de um ambiente visual que permita a criação dos modelos com notação diagramática para o metamodelo, auxiliando a construção e a visualização de diferentes modelos por o uso de diagramas com importação, mapeamento e comparação destes símbolos, a fim de se alcançar um ambiente visual com símbolos que estejam coerentes com as notações já utilizadas nas abordagens existentes.
Por fim, o protótipo estendido é adaptável para receber novas importações de diferentes metodologias e estender as regras de restrições para verificação de seus modelos.
Esta adaptação é possível pois há flexibilidade nos arquivos para geração de código, sendo este um template, o qual permite gerar código para a plataforma de implementação desejada.
