Este trabalho disserta a respeito de Sistemas Digitais Reconfiguráveis (SDRs).
Aborda as tendências acadêmicas e industriais dessa tecnologia.
Em função de estas, é proposta uma classificação de SDRs conforme seus objetivos e tecnologia empregada.
O estudo de SDRs evidência duas carências:
Ferramentas e dispositivos que permitam reconfiguração parcial.
Entre os FPGAs disponíveis comercialmente é identificado um que contempla características arquiteturais para implementação de SDRs.
Em função de um estudo minucioso da organização interna de FPGAs da família Virtex, são desenvolvidas algumas ferramentas para o projeto e implementação de SDRs.
Estas ferramentas almejam prover a reconfiguração remota, parcial e dinâmica.
As ferramentas foram validadas em plataformas de prototipação com dispositivo Virtex.
O trabalho também reflete sobre problemas para implementação de SDR por causa de limitações impostas por as características dos atuais FPGAs comerciais.
Para diminuir esse problema, é proposto um barramento para interconexão de diferentes módulos de hardware num FPGA.
Palavras-chave: FPGAs Virtex, Ferramentas para reconfiguração, reconfiguração parcial, reconfiguração remota, barramento para interconexão de cores, Sistemas digitais Reconfiguráveis.
Este Capítulo define o escopo do trabalho e o contextualiza, bem como introduz o que seja reconfiguração dinâmica, além de outras definições necessárias para o bom entendimento do mesmo.
Muitas aplicações emergentes em telecomunicações e multimídia necessitam que suas funcionalidades permaneçam flexíveis mesmo depois do sistema ter sido manufaturado.
Tal flexibilidade é fundamental, uma vez que requisitos dos usuários, características dos sistemas, padrões e protocolos podem mudar durante a vida do produto.
Essa maleabilidade também pode prover novas abordagens de implementação voltadas para ganhos de desempenho, redução dos custos do sistema ou redução do consumo geral de energia.
A flexibilidade funcional é comumente obtida através de atualizações de software, mas desta forma a mudança é limitada somente à parte programável dos sistemas.
Desenvolvimentos recentes na tecnologia de matrizes de elementos lógicos programáveis no campo (Field-Programmable Gate Arrays, ou FPGAs) têm introduzido suporte para modificações rápidas e em tempo de execução do hardware do sistema.
Essas modificações referem- se a mudanças em circuitos digitais via reconfiguração com ou sem a interrupção da operação do circuito.
A implementação de sistemas que exigem flexibilidade, alto desempenho, alta taxa de transferência de dados e eficiência no consumo de energia são possibilitadas por essas tecnologias.
Isto inclui aplicações de televisão digital, comunicação sem fio reconfigurável, sistemas de computação de alto desempenho, processamento de imagens em tempo real, produtos para consumo atualizáveis remotamente, entre outros.
Além de as características citadas acima, a reconfigurabilidade também contribui para a economia de recursos:
Quando uma dada tarefa pode ser realizada em várias fases, uma diferente configuração pode ser carregada para cada fase seqüencialmente,.
Desta forma o tamanho do sistema pode ser menor, o que implica na redução de preço.
Reconfigurabilidade também faz do desenvolvimento e teste de hardware tarefas mais rápidas e mais baratas.
E pode ainda ser usada como tecnologia para construção de sistemas tolerantes a falhas:
Tais sistemas podem realizar autoverificação e reconfigurar a si mesmos, substituindo elementos defeituosos por elementos reserva disponíveis.
Este trabalho insere- se no contexto de que há necessidade de se identificar dispositivos que permitam a implementação de sistemas digitais reconfiguráveis (SDR), e documentar a seu respeito.
Por ser uma área relativamente nova, a computação reconfigurável introduz alguns neologismos e altera o significado de algumas expressões.
Assim sendo, a seguir são apresentados conceitos, palavras e expressões relevantes ao entendimento deste trabalho.
Dispositivo que consiste de uma matriz de blocos lógicos, cercada de blocos de entrada e saída, e conectada por fios de interconexão, onde todos esses itens são configuráveis.
Configuração: Programação dos elementos internos do FPGA, através de bits de memória ou tecnologia do tipo anti-fusível.
Granularidade: Característica do dispositivo ou sistema relacionada com o grão;
Sendo que entende- se por grão a menor unidade configurável de a qual é composta um dispositivo (FPGA), ou um SDR que pode conter diversos FPGAs.
Grão-grande: Os FPGAs de grão grande podem possuir como grão unidades lógicas e aritméticas (ULAs) e/ ou pequenos microprocessadores e memórias.
Como exemplos desse tipo de arquitetura podem ser citadas as máquinas RAW e a arquitetura GARP.
Grão-médio: Os blocos lógicos dos FPGAs que têm grão médio freqüentemente contêm duas ou mais tabelas-verdade (look-up tables ou LUTs) e dois ou mais flip-flops.
A maioria das arquiteturas de FPGAs implementa a lógica em LUTs de quatro entradas.
Como exemplos de dispositivos que atualmente possuem grão médio podem ser citados as famílias Spartan e Virtex, da Xilinx;
Flex e Apex, da Altera;
E AT40K, da Atmel.
Grão-pequeno: Em os dispositivos com grão pequeno há um grande número de blocos lógicos simples.
Os blocos lógicos normalmente contêm uma função lógica de duas entradas ou um multiplexador 4 para 1 e um flip-flop.
As famílias SPGA (Actel) e AT6000 (Atmel) são exemplos de dispositivos de grão pequeno.
Reconfiguração total:
É a forma de configuração onde o dispositivo reconfigurável é inteiramente alterado.
Também tratada apenas como configuração.
Reconfiguração parcial:
É a forma de configuração que permite que somente uma porção do sistema reconfigurável seja reconfigurada.
Uma reconfiguração parcial pode ser não-disruptiva -- onde as porções do sistema que não estão sendo reconfiguradas permanecem completamente funcionais durante o ciclo de reconfiguração;
Ou disruptiva -- onde a reconfiguração parcial afeta outras partes do sistema, tipicamente necessitando de uma parada no sistema inteiro.
Reconfiguração dinâmica:
Também chamada de run-time reconfiguration (RTR), on-the-fly reconfiguration ou in-circuit reconfiguration.
Todas essas expressões podem ser traduzidas também como reconfiguração em tempo de execução.
Não há necessidade de reiniciar o circuito ou remover elementos reconfiguráveis para programação.
Reconfiguração extrínseca:
O sistema pode ser reconfigurado parcialmente, mas somente considerando cada FPGA que o compõe como unidade atômica de reconfiguração.
O sistema FireFly pode ser citado como exemplo.
Reconfiguração intrínseca:
Cada FPGA que compõe o sistema pode ser reconfigurado parcialmente.
Por exemplo podem ser citados os FPGAs das famílias Virtex (Xilinx) e AT40K (da Atmel).
Dynamically Programmable Gate Array. Dispositivo que utiliza a técnica de implementação do circuito de controle de configuração que permite a existência de múltiplas configurações simultaneamente carregadas, usando uma de elas ativa num determinado instante.
Cache-Logic: É um termo usado para indicar hardware reconfigurável dinamicamente através de chaveamento de contexto, como o DPGA.
É uma marca registrada da empresa Atmel.
Core: Um core é um módulo de hardware, digital ou analógico, podendo ser descrito em diferentes níveis de abstração.
Estes cores são pré-projetados, pré-verificados (por simulação funcional e back annotation) e prototipados em hardware pelo menos uma vez.
Os cores são usados para construir aplicações maiores e mais complexas num dado circuito integrado Sistemas digiais baseados em FPGAs têm demonstrado ser uma boa alternativa entre implementações em software e em ASICS, mas ainda apresentam alguns pontos fracos.
Esses pontos, ou desvantagens, podem ser minimizados em função de novas pesquisas nessa área.
De entre as possibilidades de evolução dos sistemas digiais baseados em FPGAs, destaca- se a reconfiguração dinâmica de FPGAs.
As Seções seguintes mostram as atuais desvantagens dessa classe de sistemas digitais e apresentam a idéia de reconfiguração dinâmica -- assuntos que motivaram esta dissertação.
Os resultados iniciais dos sistemas baseados em FPGAs foram impressionantes, por a flexibilidade que possibilitam, mas principalmente por o ganho de desempenho sobre GPPs.
Contudo esses sistemas apresentam algumas limitações implícitas, tais como:
Tempo de configuração:
O tempo para carregar uma configuração no FPGA é um fator que depõe contra sua utilização em sistemas dinamicamente reconfiguráveis.
Para FPGAs demostrarem ganhos sobre processadores de propósito geral, precisam amortizar o tempo de reconfiguração sobre enormes quantidades de dados, o que limita sua aplicabilidade.
Compatibilidade em relação a novos dispositivos:
Para obter benefícios de uma nova família de FPGAs, os sistemas desenvolvidos devem ser resintetizados e muitas vezes até mesmo reescritos.
Restrições de tamanho:
Atualmente FPGAs comerciais (bem como as ferramentas de CAD disponíveis) permitem que sejam implementados cores de tamanho limitado por o tamanho dos recursos disponíveis no dispositivo.
Tempo de compilação:
Tarefas de síntese, roteamento e posicionamento consomem centenas de vezes mais tempo que a compilação de software para GPPs.
Outras observações podem ser feitas a partir de a abstração do funcionamento de um FPGA, que pode ser visto como possuidor de duas camadas, do ponto de vista da implementação de algoritmos:
Camada operacional:
Onde tomam lugar blocos lógicos configuráveis (ou CLBs -- Configurable Logic Blocs), blocos de entrada/ saída (Input/ Output Blocks -- IOBs) e roteamento.
Este tipo de arquitetura baseada em CLB é projetada para manipular dados em nível de bits.
Camada de configuração:
Pode ser vista como uma grande SRAM.
A configuração é carregada nessa memória antes da fase operacional, o que caracteriza uma arquitetura estaticamente configurável.
Em vista de isso, pesquisas vêm sendo realizadas no sentido de virtualizar a lógica referente a a aplicação, além de revisões quanto a o tamanho do grão dos dispositivos que servirão como base para tais aplicações, e.
Em esse sentido, a reconfiguração dinâmica exerce importante papel, no intuito de incrementar a flexibilidade e a agilidade na reconfiguração dos dispositivos.
O campo da computação reconfigurável avançou amplamente na década passada, utilizando FPGAs como a base para sistemas reprogramáveis de alto desempenho.
Muitos desses sistemas alcançaram altos níveis de desempenho e demostraram sua aplicabilidade à resolução de uma grande variedade de problemas.
Contudo, apesar de os autores desses sistemas os classificarem como reconfiguráveis, eles são tipicamente configurados uma vez antes de iniciarem a execução da aplicação.
Sistemas RTR são distintos de sistemas digitais estaticamente configuráveis por permitirem especialização da lógica e/ ou do roteamento em tempo de execução.
A Figura 1.1 ilustra o que seja RTR através de um gráfico com três eixos.
Os eixos x e y indicam o plano espacial, em o qual ocorre o roteamento e o posicionamento da lógica a ser implementada num FPGA.
Sistemas digitais baseados em FPGAs, mas que não são dinamicamente reconfiguráveis podem ser vistos apenas neste plano.
Contudo, para SDRs, há a necessidade de uma análise temporal das reconfigurações.
Em vista de isso foi introduzido o eixo z, que indica as diferentes implementações de módulos funcionais no dispositivo, em relação a o tempo que ocorreram.
As áreas de um programa que podem ser aceleradas através do uso de hardware reconfigurável freqüentemente são muito numerosas ou complexas para serem carregadas simultaneamente no FPGA disponível.
Para esses casos, é interessante que seja possível trocar entre diferentes configurações no mesmo dispositivo.
RTR cria a possibilidade de se pensar em hardware de forma semelhante ao conceito de memória virtual.
Conforme essa idéia, o hardware físico pode ser muito menor que do que o somatório dos recursos requeridos para cada uma das configurações.
Então, ao invés de reduzir o número de configurações que são mapeadas, apenas ocorre uma troca entre o hardware necessário e o hardware implementado fisicamente.
Apesar de a aparente vasta aplicabilidade para sistemas RTR, existem poucos sistemas que de fato implementam esta característica.
Isto se dá por dois fatores principais:
Falta de software para projeto, depuração e teste;
Falta de hardware (comercialmente disponível) especialmente projetado para permitir RTR.
Essas lacunas motivam a pesquisa no desenvolvimento de técnicas de projeto para sistemas digitais parcialmente reconfiguráveis.
Conforme a Seção anterior, existem dois grandes problemas relacionados com o projeto e a implementação de sistemas que utilizem RTR.
Este trabalho pretende contribuir para a redução de ambos.
A respeito de a falta de hardware, são estudadas arquiteturas de FPGAs disponíveis comercialmente.
É analisada a possibilidade de implementar um sistema digital parcialmente reconfigurável nesses dispositivos.
Além de isto, é proposta a criação de uma interface (lógica) para conexão entre cores.
Interface esta que viabilizaria a virtualização do hardware, pois que facilitaria a inserção e a remoção de cores num FPGA.
Relativamente a a falta software, é realizado um estudo minucioso da organização interna de uma família de FPGAs.
Em vista deste estudo são definidas (em linhas gerais) as necessidades para projeto de CAD para RTR nesses dispositivos.
A conseqüência deste trabalho é o desenvolvimento de uma ferramenta que possibilita a reconfiguração parcial e remota de cores.
Para que os objetivos mencionados na Seção 1.4 sejam atingidos, este trabalho organiza- se da seguinte forma:
O estado-da-arte em sistemas digitais reconfiguráveis é mostrado no Capítulo 2.
A análise do estado- da arte inicia- se por a definição de critérios para comparação entre as diversas arquiteturas reconfiguráveis;
Passa por as propostas de hardware reconfigurável e por métodos de projeto, avaliação e implementação;
E termina com a descrição de alguns sistemas digitais reconfiguráveis.
Duas iniciativas encontradas na literatura para preenchimento da lacuna de ferramentas para desenvolvimento de sistemas digitais dinamicamente reconfiguráveis são abordadas no Capítulo 3, sendo que a segunda foi adotada para a implementação de um estudo de caso sobre reconfiguração parcial neste trabalho.
O Capítulo 4 apresenta FPGAs disponíveis comercialmente que permitem reconfiguração parcial.
Além de isto, como este trabalho propõe a criação de uma interface para conexão de cores em dispositivos da família Virtex, um estudo minucioso de sua arquitetura interna foi imprescindível.
Este estudo é também mostrado no Capítulo 4.
O Capítulo 5 explicita a contribuição deste trabalho para a comunidade científica.
Apresenta um reconfigurador parcial e remoto de FPGAs, bem como implementa um estudo de caso em reconfiguração parcial.
Sua última Seção sugere características para uma interface para conexão de cores FPGAs, nos moldes do que já existe para ASICs.
Este trabalho foi organizado de forma que há possibilidade de uma leitura não seqüencial, ou seja, o leitor pode iniciar por onde melhor lhe aprouver.
Contudo, o Capítulo 5 é exceção, pois contém elementos compreensíveis apenas através do entendimento do Capítulo 4.
A conclusão do trabalho é feita no Capítulo 6, onde também há indicações para trabalhos futuros.
Este Capítulo objetiva situar o leitor no que se refere ao estado-da-arte em computação reconfigurável.
Primeiramente explicita critérios de classificação de sistemas digitais reconfiguráveis, e em seguida exibe uma tabela classificando diversos SDRs conforme esses critérios.
Ainda no que tange à classificação, neste Capítulo é feita análise de SDRs em relação a o tempo, à tecnologia empregada e aos tipos de problemas que procuravam endereçar.
Em os próximos itens são apresentados os critérios de algumas tentativas de classificação de SDRs.
A taxonomia destes sistemas é complementada com a inclusão dos quesitos reconfigurabilidade e abrangência da reconfigurabilidade.
A escolha destes critérios busca a elaboração de um conjunto de características de classificação cujos elementos sejam ortogonais entre si.
Olimpo é uma proposta de taxonomia para arquiteturas reconfiguráveis baseada nos critérios de objetivo da arquitetura, granularidade, integração e reconfigurabilidade da rede de interconexão.
A Figura 2.1 exibe essa proposta no formato de árvore.
A seguir serão descritos os critérios de classificação do Olimpo.
Uma arquitetura reconfigurável pode ter como meta uma das duas características abaixo:
Tolerância a falhas:
É um dos primeiros campos onde a computação reconfigurável foi implementada.
Durante a fabricação e a utilização, há uma certa possibilidade de que uma parte do circuito integrado torne- se defeituosa.
Em arquiteturas clássicas uma parte defeituosa implica que o circuito integrado inteiro está inutilizado.
Contudo, numa arquitetura reconfigurável tolerante a falhas, o sistema ainda poderia continuar operando, pois é capaz de detectar e corrigir um certo conjunto de falhas.
Acréscimo de velocidade:
O uso de arquiteturas reconfiguráveis para incrementar o desempenho de sistemas é uma tecnologia que emergiu rapidamente a partir de a década de 80, principalmente por a possibilidade de implementação de certos algoritmos lentos nos atuais diretamente em hardware.
Granularidade o número de portas NAND de duas entradas equivalentes, o número total de transistores, a área normalizada total, ou por o número de entradas e saídas.
A classificação do Olimpo trata granularidade, contudo, conforme definido na Seção 1.2.
Quanto a o quesito forma de integração a classificação pode ser a seguinte:
Sistemas Autônomos:
Dada a carga inicial, o sistema adapta- se dinamicamente (e sem interferência externa) até que o resultado parcial convirja na direção de um resultado esperado.
O melhor exemplo para essa característica é a simulação de sistemas vivos, por exemplo, implementação de algoritmos genéticos.
Sistemas fortemente acoplados:
Unidades de reconfiguração atuam como unidades de execução do processador, e podem manipular dados diretamente de seus registradores, ou de um barramento comum.
Sistemas fracamente acoplados:
Unidades de reconfiguração são anexadas ao sistema como co-processadores, comumente numa placa em separado.
Este quesito trata da rede de interconexão entre unidades reconfiguráveis, que pode ser fixa ou reconfigurável.
Arquitetura com rede externa reconfigurável:
Uma rede reconfigurável conecta todas as unidades reconfiguráveis, criando uma grande unidade reconfigurável virtual, garantindo uma maior escalabilidade para o sistema.
Arquitetura com rede fixa:
É uma arquitetura mais barata e mais simples.
Pode não ser adequada para aplicações com computações intensivas, mas é suficiente para a maioria das aplicações.
Hardware dinamicamente reconfigurável é a tecnologia que impulsiona o desenvolvimento de sistemas que unam as características de processadores de propósito geral (GPPs) e a flexibilidade de FPGAs.
Sob este prisma, SDRs podem ser classificados quanto a sua atuação como coprocessadores, com relação a a arquitetura da memória, e com relação a a execução dos programas por o sistema reconfigurável.
Levando- se em consideração um FPGA e um GPP como descritos acima, existem diversas formas de usar- los num sistema.
Uma forma de classificar esses sistemas é através dos diferentes níveis de interação entre o FPGA e o GPP:
Coprocessamento: O microprocessador lança uma instrução, ou seqüência de instruções que pode ser detectada e interpretada por o FPGA.
Em a realidade, o FPGA atuaria como um coprocessador.
Chamada remota de funções:
O microprocessador lança uma instrução, ou seqüência de instruções que é interpretada por o FPGA como uma chamada remota de função (Remote Procedure Call -- RPC).
É semelhante ao coprocessamento, exceto por o fato que é uma interface mais poderosa que usa sincronização explícita sempre que necessário.
Modelo Cliente--Servidor:
O algoritmo implementado no FPGA é um processo servidor que atua de forma semelhante ao mecanismo do RPC, mas onde comunicações podem chegar de qualquer processo que esteja sendo executado por o microprocessador.
Processos paralelos:
Os processos que são executados por o FPGA são independentes daqueles que são executados por o GPP.
A comunicação entre processos pode acontecer a qualquer momento, via troca de mensagens.
O programa que está sendo executado no coprocessador FPGA normalmente precisa de certa quantidade de variáveis e de armazenamento temporário para sua operação.
Assim, pode haver três diferentes modelos de memória:
FPGA sem acesso a memória externa:
Em alguns casos o algoritmo executado no FPGA pode operar sem memória externa.
É uma situação aceitável somente quando o FPGA necessita de poucos estados para sua operação.
FPGA compartilha memória com o microprocessador:
O FPGA pode usar qualquer memória associada ao barramento por ele compartilhado.
Contudo isto gera sobrecarga de tempo e espaço para que seja negociada a arbitragem de acesso a memória.
Pode ser necessária a existência de um controlador de endereçamento, o que tenderá a reduzir a velocidade de acesso a memória para processamento intensivo de dados.
FPGA com memória local própria:
O algoritmo da parte reconfigurável é organizado com memória privada, consumindo o mínimo de ciclos de relógio para cada acesso, aumentando o desempenho durante um processamento.
Contudo pode haver duplicação de dados com relação a o GPP.
Por este motivo é também necessário um controle de coerência e um meio para troca de mensagens.
Os modelos de operação de memória não são necessariamente mutuamente exclusivos, isto é, podem não ser ortogonais.
Memória de bloco:
A memória local é suficientemente grande para conter um conjunto de dados completo para o processamento.
Por exemplo este poderia ser um quadro de vídeo completo a ser processado por um algoritmo de compressão de imagens.
Memória de fila:
A memória age como uma fila enquanto há troca de dados e resultados com o microprocessador.
Como exemplo tem- se o armazenamento de uma região completa de suporte para um filtro de tempo real.
Cache: A memória local pode funcionar como uma cache sobre uma estrutura de dados maior controlada por o GPP.
Existem também diversas formas dos módulos funcionais serem configurados no FPGA.
Estes modelos podem explorar diferentes partes da relação custo/ desempenho das implementações para suportar execução de programas no FPGA.
Hardware puro:
O algoritmo é convertido (por síntese para hardware) numa descrição de hardware que é carregada no FPGA.
Microprocessador de aplicações específicas:
O algoritmo é compilado num código de máquina abstrato, para um processador abstrato (Application Specific Instruction-Set Processor ASIP).
Os dois são então co-otimizados para produzir a descrição de um processador de aplicação específica e o código de máquina para ele.
A descrição do microprocessador pode então ser compilada num FPGA.
Reutilização seqüencial:
O algoritmo pode ser muito grande para ser implementado no FPGA, ou por razões de engenharia ou econômicas divide- se o algoritmo em partes, de tal forma que ele seja executado parcialmente, usando a capacidade de reconfiguração dinâmica do FPGA.
Os ganhos relacionados com a reutilização do hardware devem ser balanceados com o tempo que é gasto com a reconfiguração.
Uso múltiplo simultâneo:
Se os recursos do FPGA são grandes o bastante, é possível haver um número de algoritmos co-residentes, e cada um de eles pode interagir separadamente com o processador.
Uso sob demanda:
Existe a possibilidade de sistemas computacionais serem construídos onde o hardware não existe todo ao mesmo tempo, mas cuja demanda de tempo-real do sistema dita qual parte do hardware deve ser construída e qual parte deve ser destruída.
Há uma analogia razoável com sistemas de memória virtual, e por isto esse esquema pode ser chamado de &quot;hardware virtual».
Um SDR pode ser configurado de duas formas:
Estática ou dinamicamente.
Em a primeira o arquivo de configuração de um FPGA é carregado somente uma vez antes da execução de uma tarefa, e o FPGA será reconfigurado somente depois desta execução.
Em a segunda, dinâmica, o arquivo de configuração do FPGA pode mudar parte do dispositivo a qualquer momento.
Portanto, pode- se adotar os seguintes critérios de classificação para SDRs:
Sistema estático:
Possui pouca flexibilidade.
A configuração do sistema ocorre antes do início da execução da tarefa a que se propõe executar.
Durante toda execução o FPGA permanece inalterado.
Após, pode ser reconfigurado totalmente.
É o mais comumente utilizado.
Sistema dinâmico:
Envolve um a arquivo de configuração que pode mudar durante a execução de uma tarefa por o FPGA.
Tem como objetivos adaptação dinâmica a mudanças de especificação, bem como manipulação de especificações incompletas.
O propósito desta Subseção é comparar, através da Tabela 2.1, algumas das mais importantes arquiteturas na área de computação reconfigurável.
Foram utilizados os critérios analisados previamente para prover a classificação, por serem aqueles ortogonais o bastante para permitir clareza na comparação entre os sistemas.
As arquiteturas reconfiguráveis podem ser analizadas temporalmente, em função de os problemas a que se dispuseram resolver.
A partir de o amadurecimento da tecnologia habilitadora para esses sistemas (FPGAs), alguns centros de pesquisa criaram as primeiras arquiteturas reconfiguráveis, com o intuito principal de aumentar o desempenho de algoritmos que até então eram executados em software.
Dentro de esta primeira geração estão projetos como DECPeRLe, PRISM e Splash.
Alguns sistemas mais modernos ainda utilizam essa abordagem, como o Transmogrifier2, o Rpm-2 e o SPYDER.
Tais sistemas podem ser vistos como a primeira geração dos sistemas digitais reconfiguráveis, conforme a Figura 2.2 à esquerda.
Já neste primeiro momento verificou- se a eficiência da utilização de FPGAs em domínios de aplicação específicos, tanto em termos de desempenho com relação a abordagens em software quanto no que tange ao critério econômico, quando comparada a soluções ASIC.
Contudo também alguns problemas foram detectados.
Em geral esses sistemas possuíam um gargalo de comunicação entre P e FPGAs e apresentavam um tempo de reconfiguração muito alto, além de poderem ser reconfigurados apenas totalmente.
Essa última desvantagem significa que o sistema precisava necessariamente ser parado para que pudesse ser reconfigurado.
Em função de isso novas propostas de arquiteturas surgiram.
O problema de comunicação entre P e FPGAs contou com o avanço da tecnologia habilitadora para ser resolvido, formando uma segunda geração de SDRs (Figura 2.2, centro).
Com o aumento do número de transistores por circuito integrado (Ci) tornou- se possível o desenvolvimento de um sistema composto por P, FPGA (s) e memória num único Ci (System-on-a-Chip, ou simplesmente SoC).
Foram desenvolvidos SoCs de granularidade baixa (FIPSoC, TRUMPET) e com granularidade média (Garp, Outro avanço tecnológico ocorrido foi a possibilidade de reconfiguração dinâmica.
Isto permitiu que as arquiteturas em questão pudessem ser reconfiguradas sem que precisassem parar totalmente de desempenhar suas funções.
Essa reconfiguração dinâmica pode ser realizada por chaveamento de contexto, como o que ocorre com os sistemas derivados do DPGA.
Este também é o caso do DISC, FireFly, FIPSoC e Garp.
Tais sistemas encontram- se na segunda geração de SDRs, conforme a Figura 2.2.
Splash2 apresenta uma reconfiguração alternativa, na sua rede de interconexão externa.
Além de as abordagens derivadas de avanços tecnológicos e resolução de antigos problemas, arquiteturas reconfiguráveis têm sido utilizadas para implementação de algoritmos genéticos.
FireFly é um exemplo de &quot;hardware evolutivo «criado a partir desse enfoque.
Demonstra uma utilização exótica de reconfiguração parcial e dinâmica, embora ambas ocorram de forma extrínseca.
Contudo, analisando as características da segunda geração, e comparando- as a trabalhos em desenvolvimento, percebe- se a tendência de especialização das aplicações-alvo (workload) para algoritmos baseados em fluxo de dados.
Uma necessidade emergente para computação reconfigurável são aplicações multimídia, que demandam certos tipos de operações que não são facilmente implementadas (ou não são executadas eficientemente) em FPGAs convencionais (multiplicadores, por exemplo).
Além disso há necessidade de preservação da aplicação, a fim de tornar- la menos dependente do dispositivo para o qual foi projetada.
A isto denomina- se virtualização do hardware e é detalhada no Item 2.1.2.4.
Essa virtualização pode ocorrer através de métodos diferentes, tais como:
Configurações baseadas no fluxo de computações;
Por um pipeline de configurações;
Reconfigurações em função de um anel de retroalimentação.
A Figura 2.2-direita mostra essa tendência e cita exemplos de dispositivos que implementam as idéias citadas acima, evidenciando uma terceira geração de sistemas digitais reconfiguráveis.
Informações adicionais a respeito de arquiteturas reconfiguráveis totalmente funcionais podem ser encontradas no site do pesquisador Steve Guccione.
É importante ressaltar que esta classificação temporal para SDRs é uma contribuição do presente trabalho.
As Seções a seguir abordam as características que um dispositivo reconfigurável deve ter para permitir reconfiguração dinâmica.
O primeiro item aborda reconfiguração por chaveamento de contexto, o segundo traz o conceito de SoC dinamicamente reconfigurável e o terceiro trata da questão da regularidade do dispositivo e de características como relocação e desfragmentação.
A organização interna do DPGA é particularmente bem adaptada para computação reconfigurável.
Diferentemente de FPGAs normais, onde a função de cada elemento da matriz é determinada por seqüências relativamente lentas de reconfiguração, os elementos da matriz DPGA podem chavear rapidamente1 entre várias configurações pré-programadas.
Semelhantemente aos FPGAs, DPGAs são compostos de uma cadeia de elementos computacionalmente simples.
Muitos FPGAs modernos são construídos como LUTs programáveis.
A LUT também é o elemento configurável do DPGA.
Em um FPGA comum, após a configuração, o roteamento permanece fixo durante o funcionamento do sistema.
Em o DPGA, ao contrário, há uma rede de interconexão também programável, que permite aos elementos serem ligados conforme a aplicação necessita.
Cada elemento do DPGA usa uma segunda LUT para armazenar um diferente contexto.
Uma mensagem de configuração global informa a cada elemento do DPGA qual a função que irá desempenhar no próximo ciclo do relógio.
A interconexão configurável num DPGA tem uma tabela de configurações carregadas, e seleciona entre as configurações baseada no identificador de contexto corrente.
A o custo de um tamanho maior de elementos e interconexão, o DPGA serve como um FPGA de múltiplo contexto.
Com o espaço dos contextos pré-carregados, o DPGA pode chavear entre funcionalidades completamente diferentes, de um ciclo de relógio para outro.
A tabela de configuração do DPGA efetivamente atua como uma (memória) cache de configurações de elementos da matriz.
Dan1 Rapidamente, neste contexto, significa em apenas um ciclo de relógio.
Os múltiplos contextos carregados permitem a utilização mais eficiente da matriz de elementos.
Em aplicações mais pesadas, a rápida reconfiguração permite a uma única matriz DPGA ser carregada com múltiplas configurações simultaneamente.
O DPGA pode chavear entre configurações para acelerar diferentes partes de uma aplicação.
Essa tecnologia foi utilizada para implementação do Trumpet.
FIPSoC é um dispositivo do tipo Sistem-on-a-Chip criado por a empresa SIDSA, e tem por objetivo o desenvolvimento rápido de aplicações analógicas e digitais integradas.
A Figura células analógicas otimizadas para aquisição de sinais e conversões A/ D e D/ A. A SIDSA disponibiliza várias ferramentas de CAD integradas, que possibilitam ao usuário especificar, simular e mapear todo o projeto em apenas um circuito integrado.
A lógica programável do FIPSoC é uma matriz de macro células digitais (Digital Macro Cells -- DMCs) que podem ser configuradas para funções específicas.
As DMCs são de grão pequeno, baseadas em células de RAM estática programáveis, que incluem LUTs de 4 entradas e 4 flip-flops para cada uma.
O subsistema analógico consiste de blocos analógicos configuráveis (Configurable Analog Blocks) de grão grande2.
Os CABs permitem configurar diferentes funções analógicas, tais como amplificação diferencial e conversão de dados.
Existe uma parte digital das células analógicas que pode ser independentemente controlada por o P ou por o A configuração do circuito integrado é armazenada em bits de RAM estática.
Pode ser feito o download de uma nova configuração para a memória de configuração enquanto a célula está em operação (semelhante ao cache de configurações do DPGA).
Não há a necessidade de parar o circuito integrado para reconfigurar- lo:
Configurações extras podem ser carregadas em tempo-real, dentro de a idéia de reconfiguração parcial.
Por exemplo, enquanto uma parte do FIPSoC realiza uma recuperação de contexto numa determinada área, outra parte do dispositivo pode estar fazendo uma computação de propósito geral.
Esta reconfiguração dinâmica, parcial ou total, pode também ser colocada em funcionamento por o próprio hardware reconfigurável, sem a intervenção do P. A reconfiguração dinâmica pode ser aplicada sobre uma única célula digital configurável, sobre um conjunto selecionado de elas, ou sobre toda a lógica reconfigurável.
Este modelo trata de uma proposta de FPGA que permite reconfiguração em tempo de execução, com ênfase na otimização de relocação e desfragmentação dos recursos do dispositivo.
Um dos problemas dos sistemas que permitem RTR ocorre quando duas configurações parciais são sobrepostas durante a compilação na mesma posição física no FPGA.
Uma solução para este problema é permitir que o posicionamento final das configurações ocorra em tempo de execução, de forma que aconteça a relocação dinâmica dessas configurações.
Utilizando relocação, uma nova configuração pode ser posicionada no FPGA onde ela causar menos conflitos com outras configurações já presentes no dispositivo.
A Figura 2.4 ilustra uma situação onde relocação e desfragmentação são utilizadas.
O primeiro desenho mostra o estado inicial do FPGA, onde os diferentes tons de cinza indicam diferentes módulos funcionais, e a parte em branco significa recursos de lógica não utilizados (livres).
Observe- se que há uma área branca entre as áreas hachuradas.
O segundo desenho mostra o início da desfragmentação (Figura 2.4-2).
A lógica que encontrava- se na quinta linha do dispositivo é transferida para uma memória auxiliar, para, em seguida (Figura 2.4-3), ser escrita na linha quatro.
Ação semelhante ocorre com a lógica que encontra- se na linha 6 (Figura 2.4-4).
Então, a Figura 2.4-5 denota um dispositivo cuja lógica foi relocada, a fim de prover a desfragmentação.
Mesmo com a relocação, dispositivos que permitam RTR podem ainda sofrer com alguns conflitos de posicionamento.
Mas estes podem ser evitados usando uma otimização de hardware adicional.
Como dispositivos que permitem RTR carregam e descarregam configurações no decorrer de o tempo, a localização da área desocupada no FPGA é fragmentada, de forma semelhante ao que ocorre com a memória de programas e dados de um sistema computacional genérico.
Mesmo que haja área vazia suficiente no FPGA para receber uma determinada configuração, pode acontecer que esta esteja distribuída por o dispositivo.
Uma configuração normalmente requer uma área contígua, então acabará tendo que sobrescrever uma área do Ci que contém uma configuração válida.
Um dispositivo que pretenda permitir RTR deve incorporar a possibilidade de realizar desfragmentação, consolidando áreas não-utilizadas movendo configurações válidas para novas áreas, disponibilizando assim as áreas vazias.
Uma nova arquitetura, baseada nos princípios de relocação e desfragmentação foi proposta, e chamada de R/ D FPGA.
Usando alguns poucos e simples conceitos na fase de projeto de um FPGA, pode ser assegurado que ele permita relocação e desfragmentação.
Tais conceitos são:
O primeiro é o conceito de configuração parcial, já citado na Seção 1.2.
A proposta do R/ D FPGA é baseada num core genérico parcialmente configurável.
A Figura 2.5 (a) mostra um dispositivo cuja lógica programável é composta por elementos configuráveis individualmente, o que permite a reconfiguração parcial.
A segunda idéia é a de homogeneidade.
Se cada célula na estrutura for idêntica, não haverá obstáculos funcionais para mover uma configuração de uma posição para outra dentro de os limi21 tes do dispositivo.
De a mesma forma, a estrutura de roteamento deve ser homogênea para evitar limitações de posicionamento.
O terceiro conceito é o de Entrada/ Saída (E/ S) virtualizada.
Uma estrutura de E/ S baseada em barramento fornece um método independente de posição para ler e escrever dados de configurações individuais.
As configurações então não são limitadas por restrições de E/ S evitando a preocupação com o posicionamento dos pinos externos do FPGA.
Com isto o roteamento de E/ S permanece inalterado quando a configuração é mapeada para uma nova localização.
A quarta idéia é a de unidimensionalidade.
FPGAs comerciais atuais são baseados numa estrutura bidimensional.
O movimento de configurações em duas dimensões para relocação e desfragmentação pode ser muito difícil, pois há muitas possibilidades diferentes de posicionamento a serem consideradas.
Uma estrutura em linhas, onde cada linha seria uma estrutura atômica para configuração do FPGA, removeria a complexidade da relocação e desfragmentação.
Isto se dá porque reduz as configurações em objetos unidimensionais, onde a única variação da área de configuração permitida é no número de linhas utilizadas.
Operações de rotação horizontal ou vertical, ou deslocamento horizontal não são mais necessárias.
A única operação requerida para relocação de uma configuração é a mudança no deslocamento vertical.
Por causa de a unidimensionalidade, a E/ S virtualizada também é simplificada.
Ao invés de incluir fios de E/ S ao longo de cada coluna e de cada linha do FPGA, esses fios são necessários somente para cada coluna.
Apesar de a abordagem 2D proporcionar maior flexibilidade de roteamento, acaba por complicar os programas de roteamento e posicionamento.
Em uma estrutura de roteamento unidimensional, o posicionamento dos cores é restrito ao longo de apenas um eixo, o que faz com este ocorra muito mais rápido.
A lógica programável do R/ D FPGA é composta por uma matriz de bits de SRAM.
Esses bits são habilitados para leitura/ escrita através da decodificação do endereço de linha por os dados de programação.
Contudo, a coluna do decodificador, multiplexador e drivers tri-state de entrada foi substituída por uma estrutura denominada área de preparação (staging), conforme Figura 2.5 (b).
Essa área de preparação é uma pequena área de armazenamento temporário (buffer), o qual é essencialmente um conjunto de células de memória igual ao número de uma linha de programação do FPGA.
Cada linha, e por conseguinte a área de preparação, contém palavras de dados para configuração.
Uma vez que a informação para a linha esteja completa na área de preparação, a área inteira é escrita numa operação na memória de configuração do FPGA, conforme o endereço contido na linha de endereços.
Essa estrutura é semelhante à proposta implementada nos FPGAs da família Virtex da Xilinx.
Em a área de preparação do R/ D FPGA há um pequeno decodificador que habilita leituras/ escritas endereçáveis.
A coluna de decodificação determina qual das palavras na área de preparação está sendo referenciada num dado momento.
O decodificador de linha inclui uma sutil modificação, qual seja, a adição de dois registradores, um multiplexador 2 para 1 para escolher entre esses registradores, e um somador.
Todas essas estruturas são iguais em largura ao endereço da linha.
Isto permite que um deslocamento vertical seja carregado num ou mais registradores para ser adicionado ao novo endereço de linha, o que resulta num novo endereço de linha relocado.
Um dos registradores é o registrador de escrita de deslocamento, o qual armazena o deslocamento de relocação enquanto uma configuração é escrita.
O outro é o registrador de leitura, que é usado durante a desfragmentação para ler do FPGA uma configuração relocada.
O ponto principal da arquitetura proposta é a possibilidade de posicionar a lógica em qualquer parte do FPGA, independentemente dos pinos de E/ S que são necessários para comunicação com o mundo externo.
Somado a isto, a relocação e a desfragmentação ocorrem de forma simplificada, criando o ambiente ideal para implementação de sistemas RTR.
Esta Seção aborda métodos utilizados no projeto e/ ou na implementação de sistemas digitais reconfiguráveis.
O Item 2.4.1 propõe uma métrica para avaliação de sistemas RTR, a fim de analisar a viabilidade de implementação de um sistema assim perante um estático.
Já o Item 2.4.2 traz um framework de uma ferramenta para projeto de planta-baixa temporal, que viabilizaria o projeto de sistemas RTR.
Os itens 2.4.3 e 2.4.4 apresentam diferentes enfoques relativos a métodos para projeto de sistemas com características de reconfiguração dinâmica.
Pesquisadores do departamento de engenharia elétrica da Brigham Young University desenvolveram o protótipo de um sistema de rede neural baseada em RTR parcial.
O sistema foi chamado de RRANN-2 (Run-time Rreconfigurable Artificial Neural Network).
Durante o projeto e implementação do RRANN-2, foi desenvolvido um método de projeto para sistemas RTR.
O ponto mais importante deste método é maximizar a lógica que permanecerá inalterada (estática) e minimizar a lógica que precisa ser modificada durante a execução da aplicação (dinâmica).
Esta maximização dá- se por o particionamento da aplicação em blocos funcionais que são, em sua maior parte, comuns a todas configurações utilizadas na implementação da aplicação.
Esses blocos representam as partes da configuração que não mudam, e, portanto, podem ser implementadas como um circuito estático.
O projeto de recursos para reconfiguração dinâmica só ocorrerá quando não houver unidade funcional correspondente entre a configuração implementada e a que será utilizada.
Adicionalmente, a parte estática do circuito é utilizada para reter estados intermediários do dispositivo reconfigurável.
Isto elimina circuitos de controle e roteamento que seriam necessários para armazenar valores.
O segundo passo no desenvolvimento de um projeto de RTR parcial é mapear fisicamente os blocos no dispositivo.
Além de as restrições de implementação e localização necessárias, um bloco lógico também é restringido por o contexto físico que o cerca.
Todos os assuntos referentes a interconexão global, localização global, e posicionamento e interconexão com os blocos próximos têm que ser resolvidos.
O problema é que muitas dessas restrições não são conhecidas em tempo de projeto, o que vem a requerer um difícil processo interativo.
Os autores deste método ressaltam a necessidade de pesquisa contínua nessa área, para cristalizar conhecimento a respeito de uma metodologia de projeto para sistemas RTR.
Também citam a falta de CAD eficiente para suportar definições de restrições, posicionamento e roteamento.
Os aumentos na eficiência providos através de RTR não são obtidos sem custo.
Tempo e largura de banda de memória adicionais são necessários para transferir os bits de configuração do circuito de uma unidade de armazenamento fora de o FPGA para dentro de a memória de configuração do dispositivo.
Em alguns casos esse tempo extra elimina as vantagens de uma especialização em tempo de execução.
Para outros casos, contudo, a relação entre custo de reconfiguração e ganhos em desempenho e economia de recursos compensa em muito o tempo de configuração.
Foi proposta uma forma de avaliar a validade da utilização de RTR através de um método que calcula o equilíbrio entre ganho de eficiência e custo de configuração.
A base da análise que realizaram é a densidade funcional.
A métrica de densidade funcional é definida nos termos de custo da implementação de uma lógica no hardware.
Esse custo é tradicionalmente medido como o produto entre a área total requerida para implementar a lógica em hardware e tempo total de operação:
E aplica- se àqueles sistemas onde a vazão (número de operações por segundo) é mais importante que a latência.
Inclui o tempo necessário para execução, controle, inicialização e transferência de dados.
Densidade Funcional (D) mede a vazão computacional de uma unidade de hardware, e é definida como o inverso de C:
A métrica densidade funcional em (2.2) será utilizada para comparar circuitos modificados estaticamente contra as alternativas em reconfiguração dinâmica.
O incremento na densidade funcional de alguns sistemas RTR sobre as alternativas es taticamente reconfiguráveis é computada como a diferença normalizada entre segue:
E, como A porcentagem de incremento é medida multiplicando (2.3) por 100.
A maior diferença entre sistemas RTR e os estáticos é o custo adicional de reconfiguração.
Os dispositivos atuais exigem que a configuração do circuito e a execução ocorram separadamente.
Isto força a adição do tempo de configuração ao tempo total de operação de um sistema RTR.
Para estes sistemas, o tempo total de operação inclui o tempo total de execução () e o tempo total de configuração (), ou:
Substituindo em (2.2) tem- se a densidade funcional acrescida do custo de configuração:
A partir de (2.5) fica claro que o tempo de configuração reduz a densidade funcional.
Contudo, apesar de o tempo de configuração absoluto ser um importante parâmetro, o tempo de configuração relativamente a o tempo de execução é muito mais informativo.
A taxa de configuração:
Substituindo este tempo em (2.2) obtem- se a métrica de densidade funcional:
Como sugerido em, tempos longos de configuração podem ser tolerados se houver um tempo, a sobrecarga imposta por a longo de execução correspondente (pequeno).
Em o limite, se configuração é negligenciável.
Tais sistemas aproximam- se da máxima densidade funcional provida por RTR.
Essa valor máximo () é calculado ignorando- se o tempo de configuração:
Usando- se, o limite superior do incremento () sobre um sistema estático pode ser encontrado.
Este parâmetro sugere o benefício máximo de um sistema RTR, e é uma boa indicação da pertinência da utilização de RTR para uma dada aplicação:
Além de propor essas métricas, os autores do artigo sugerem que ao projetar sistemas RTR procure- se aumentar ao máximo o tempo de execução do sistema, para que se justifique o uso de sistema estático A seguir será justificado o tempo de configuração de uma aplicação RTR, segundo a abordagem apresentada acima.
A aplicação analisada é a implementação de uma rede neural que usa o algoritmo de aprendizagem por retro-propagação em FPGAs (denominada RRANN-Runtime Reconfigured Neural Network).
Como mostrado na Figura 2.6, o algoritmo é particionado em três estágios:
Como sugerido na Figura 2.6, o algoritmo é executado da seguinte forma:
Configuração dos recursos do FPGA com o processador neural de pós-alimentação, e computação dos dados;
O circuito de retro-propagação é configurado e entra em execução;
O circuito de atualização é implementado e executa, completando uma iteração do algoritmo.
Este processo de reconfiguração e execução continua até os resultados do algoritmo de treinamento convergirem.
Uma vez que a abordagem RTR requer todo hardware apenas por um estágio por vez, o algoritmo inteiro pode ser executado com menos recursos do que numa abordagem estática.
Este processo é uma reconfiguração em tempo de execução extrínseca, isto é, o sistema como um todo é reconfigurado dinamicamente, mas a reconfiguração do dispositivo é estática, uma vez que é interrompida a execução de uma determinada lógica para que outra seja configurada e executada.
Ainda assim é uma abordagem dinâmica, e a possibilidade de substituir controle e aritmética associados a um algoritmo inativo por outros estágios incrementa a eficiência do hardware.
Em a Tabela 2.2 são mostrados os parâmetros de comparação entre o sistema estático e o sistema dinâmico, para uma rede de 60 neurônios.
Como mostrado, o circuito RTR completa o algoritmo com um terço do hardware necessário para o sistema estático.
Essa redução em hardware fornece um incremento máximo na densidade funcional de 168% sobre a alternativa estática.
Para calcular a densidade funcional de cada sistema, o tempo total de operação e a área devem ser determinados.
O tempo de execução e área de uma rede neural executando RRANN depende do número de neurônios implementados nesta rede.
Com o aumento de neurônios, tanto a área quanto o tempo de execução crescem linearmente.
A Tabela 2.2 sumariza os parâmetros de um sistema com 60 neurônios, para um sistema estático e outro RTR (com reconfiguração extrínseca).
A abordagem RTR tem uma evidente vantagem em termos de área sobre o sistema estático.
Se o tempo de configuração () for ignorado, o sistema RTR provê um ganho de 435% em densidade funcional ().
Esse resultado sugere que um sistema reconfigurável em tempo de execução pode tolerar um tempo de configuração de até 4 vezes o tempo de execução () e ainda assim prover maior densidade funcional que um sistema estático.
Contudo, para que seja conhecida a densidade funcional real de um sistema RTR, o tempo de configuração deve ser considerado.
Assumindo que o dispositivo a taxa de configuração () ficaria em 9,9.
Como esse resultado é superior a, a versão RTR provê menos densidade funcional que a versão estática.
Como mostrado na Tabela 2.2, a abordagem RTR reduz em 52% a densidade funcional da aplicação.
Apesar de isto, para redes com mais neurônios e com mais tempo de execução, a tendência é que diminua, tornando a abordagem RTR viável.
Por causa de o elevado tempo de reconfiguração de RRANN, e sua alta sensibilidade ao tempo de configuração, uma arquitetura nova, chamada de RRANN-II foi desenvolvida.
A estrutura básica do sistema RRANN-2 foi projetada para explorar a característica de reconfigurabilidade parcial do FPGA Clay, da National Semiconductor.
Essa particularidade é usada para redução do tempo de reconfiguração, pois não há mais necessidade de configurar o sistema inteiro.
RRANN-2 consiste de um processador de propósito geral e um conjunto de processadores de propósito específico para execução do algoritmo de retro-propagação.
Os três processadores neurais foram projetados para compartilhar o máximo de hardware, com a finalidade de reduzir informação de configuração para cada passo de reconfiguração.
Assim como no caso de o RRANN, o RRANN-II envolveu o projeto de um processador neural de propósito geral e um conjunto de processadores de propósito específico para executar o algoritmo de retro-propagação.
RRANN-II difere de RRANN por explorar as similaridades entre os processadores neurais.
Os 3 processadores neurais são projetados para compartilhar o máximo de hardware possível, no intuito de reduzir os dados de configuração, em cada passo de reconfiguração.
Quanto mais recursos compartilhados por cada processador, menos dados de configuração são necessários para converter um processador neural para o próximo.
Para o projeto de reconfiguração dinâmica intrínseca de RRANN-II foi necessário muito esforço de projeto e layout manual.
Funções comuns foram identificadas manualmente e também manualmente mapeadas no hardware.
Funções únicas a cada estágio foram identificadas e projetadas para operar corretamente com os subcircuitos remanescentes no dispositivo durante a configuração.
Os parâmetros de 60 neurônios para um sistema estático e outro dinâmico são listados na Tabela 2.3.
Como mostrado, o circuito de propósito específico RTR completa o algoritmo com um terço do hardware necessário para o sistema estático.
Esta redução de hardware acarreta um incremento na densidade funcional de 168% sobre a alternativa estática.
Para calcular a densidade funcional real do sistema RTR o tempo de configuração deve ser conhecido.
Os três passos de reconfiguração requeridos por o RRANN-II consomem 2,42ms quando a reconfiguração global é utilizada.
Apesar de isto justificar o sistema com uma taxa de reconfiguração de 1,62ms, o incremento total obtido por a utilização de RTR é de apenas 1,4%.
Reconfigurando somente as partes do circuito que precisam ser mudadas, o tempo de reconfiguração é reduzido para 1,16ms. Esta redução no tempo de configuração tem impacto significante na densidade funcional total.
Como resumido na Tabela 2.3, a taxa de configuração é reduzida para 0,78 e um incremento na densidade funcional é de 50%.
Dynasty é uma iniciativa que visa implementar uma biblioteca para projeto de sistemas RTR.
A implementação é baseada na abstração de RTR no sentido da utilização de uma planta-baixa temporal, que permite manipulação do projeto nas dimensões espacial e temporal.
Projeto de planta-baixa (floorplanning) é uma técnica comum em fluxos de projetos para FPGAs/ ASICs, a qual é utilizada para definir ou modificar posições espaciais de módulos de projeto, no sentido de incrementar desempenho ou eficiência na implementação do mesmo.
Para fins de diferenciação, este tipo de projeto de planta-baixa será doravante denominado planta-baixa espacial.
Uma planta-baixa espacial de um projeto estático (que não sofrerá reconfiguração) permanece inalterado durante todo o tempo de vida do projeto.
Em sistemas RTR, contudo, a presença e a posição espacial de cada módulo de projeto reconfigurado podem mudar com o tempo.
Em cada instante durante o tempo de execução, o projeto de planta-baixa espacial é determinado por a sua coordenada num eixo de projeto temporal.
Um plano definido por a coordenada temporal corresponde ao projeto de planta-baixa temporal para uma configuração de projeto.
Este conceito é ilustrado na Figura 1.1.
O processo de transformação do projeto de alto nível na forma comportamental para sua implementação em projetos de planta-baixa espacial posicionados num espaço temporal foi chamado de projeto de planta-baixa temporal.
Este processo combina dois problemas de fluxo de projeto:
Particionamento e seqüenciamento de módulos de projeto em configurações de projeto (também chamadas de particionamento temporal), e (ii) posicionamento temporal de módulos de projeto e conexão com a área reconfigurável de cada configuração.
Em o sentido de permitir completa exploração de projeto espacial das porções RTR do projeto, o projeto de planta-baixa temporal precisa resolver outros problemas relacionados:
Escalonamento (particionamento do passo de controle), (iv) alocação de unidades funcionais, e (v) alocação de registradores.
O projeto de planta-baixa temporal fornece ao projetista uma melhor abstração de projeto de espaço para sistemas RTR.
O fluxo de projeto convencional não provê visualização do espaço em relação a o tempo, além de que torna sua exploração uma tarefa difícil.
Por outro lado, projeto de planta-baixa temporal é bem ajustado para visualização de projeto para dimensões espacial ou temporal, em 2 ou 3D.
Dynasty é um framework extensível e portável, projetado para pesquisa de técnicas e métodos para projeto de sistemas RTR.
Em o sentido de suportar a geração de plantas-baixas espaciais tardiamente no fluxo de projeto (necessário no caso de sistemas RTR), a representação interna do projeto disponibiliza visões de projeto em vários níveis de abstração:
Comportamental, estrutural, projeto de planta-baixa temporal, e disposição (layout).
Uma representação robusta de projeto implementada como uma coleção de classes C+ é usada para capturar soluções de projeto durante todo o fluxo do projeto.
Outro conjunto de classes em C+ é utilizado para implementar o gerenciamento de biblioteca baseado num servidor comum de bibliotecas.
A representação interna do projeto permite combinação de visões de projeto durante o desenvolvimento do sistema RTR.
Por exemplo, durante o projeto de planta-baixa temporal várias porções do projeto podem estar disponíveis nas visões arquiteturais e comportamentais.
Representações incompletas do projeto são também suportadas, com o intuito de permitir inserção posterior de controladores, ou outros circuitos estáticos.
A representação interna do projeto também facilita a análise de métricas de projeto e armazenamento de resultados analisados.
Abaixo são citadas as ferramentas do Dynasty que permitem a exploração do espaço de soluções de um projeto de sistema RTR:
Visualizador do grafo de dados e controle (CDFG):
Provê informação sobre comportamento do sistema, o qual será implementado durante o fluxo de projeto.
Navegador de estrutura e hierarquia do projeto:
Fornece detalhes de todos os elementos do projeto e suas relações hierárquicas.
Isto permite alocação de elementos/ módulos para operadores CDFG.
Editor de controle de iterações e escalonador de configurações:
É uma ferramenta de análise que permite ajuste, controle e escalonamento de configurações através do espaço de soluções do projeto.
Gerador de planta-baixa 3 D:
Permite visualização e manipulação de relacionamentos entre módulos, com o projeto de planta-baixa espacial e entre duas ou mais configurações.
Editor de disposição detalhada:
Permite manipulação de elementos de disposição detalhados, tais como chaves lógicas e roteamento.
Os parâmetros e estruturas de uma solução em RTR podem ser diretamente manipulados via interface gráfica do Dynasty.
Uma mudança em qualquer visão será propagada para representações de projeto relevantes em outras visões.
Por exemplo, quando um módulo é colocado numa configuração cujos resultados acarretam uma violação na dependência de dados do CDFG, o passo de controle e o escalonador de configurações são automaticamente recalculados para refletir a latência de projeto e a sobrecarga de configuração resultantes.
A ferramenta central do framework é o 3D Floorplanner, que é um gerador de plantas-baixas.
Ele utiliza visualização de projetos 2D para mostrar projetos de plantas-baixas espaciais para cada configuração, as quais podem ser inseridas no tempo (terceira dimensão) usando- se controles de navegação entre configurações.
O 3D Floorplanner usa um número de características que facilitam a manipulação de múltiplas configurações parciais:
Amostragem simultânea de múltiplos projetos de planta-baixa espaciais, que pode também ser utilizada para verificar conflitos de compartilhamento de recursos entre configurações.
Estimador de tempo de configuração, que calcula o número de bits de configuração necessários para mudar entre duas configurações ou para o projeto inteiro.
É possível demarcar regiões como &quot;não utilizáveis», o que é útil para posterior inserção de módulos, ou controle do posicionamento e do roteamento do projeto.
Com relação a a simulação, o framework Dynasty suporta dois níveis de abstração:
O 3D Floorplanner pode gerar um modelo de simulação em VHDL para o projeto RTR.
O projeto finalizado pode ser importado para a ferramenta de roteamento e posicionamento da Xilinx, onde um modelo de temporização detalhado pode ser gerado e simulado por ferramentas de terceiros.
Chaveamento dinâmico de circuito (Dynamic Circuit Switching -- DCS):
A implementação de DCS no framework Dynasty usa multiplexadores virtuais, chaves e demultiplexadores que são implementados como procedimentos VHDL parametrizáveis, num pacote VHDL separado.
A síntese automática de um controlador de configurações não é diretamente suportada por o framework Dynasty.
Contudo, o 3D Floorplanner pode gerar um escalonador de configurações num arquivo texto (nos formatos VHDL e pseudo-código), a partir de o qual tal controlador pode ser construído, através da utilização de ferramentas de projeto e compilação padrões.
Módulos de projeto que não são reconfigurados durante o tempo de execução podem ser sintetizados fora de o framework Dynasty, e então importados para dentro de posições reservadas na plantabaixa, e conectados com as partes remanescentes do projeto através de rótulos únicos de rede.
Apesar de os FPGAS atuais possuírem características de hardware interessantes, como dispositivos com mais de um milhão de portas lógicas equivalentes, altas taxas de relógio, reconfiguração rápida e grande largura de banda, seu uso para reconfiguração dinâmica ainda é limitado.
Essa limitada aplicabilidade deve- se a exígua oferta de ferramentas para automação de projeto e implementação, e também por a ausência de um modelo computacional que abstraia os recursos fixos dos dispositivos da descrição do hardware a ser projetado.
A Figura 2.7 ilustra três situações relativas a uma determinada aplicação que se prentende implementar num FPGA.
Em o primeiro caso, o FPGA oferece mais recursos do que seria necesário para esta aplicação.
Portanto é possível realizar a configuração do dispositivo.
Em o caso seguinte, o download do arquivo de configuração ainda é possível, mas o FPGA ficaria sem nenhum recurso adicional disponível.
Em contrapartida, no último caso, para um fluxo de projeto e implementação convencionais, seria impossível implementar a aplicação, já que ela demandaria mais recursos do que os existentes no dispositivo de destino.
Portanto, a limitação de recursos de hardware tende a prejudicar a aplicabilidade desses sistemas.
Em tais modelos de projeto de hardware, a escolha de um algoritmo para aplicação está restrita ao tamanho do hardware disponível.
Além disso, uma estrutura de computação tem que ser fixa em tempo de execução, sem a possibilidade de alocação dinâmica de recursos.
Além disso, programas desenvolvidos para um dispositivo em particular (ou conjunto de dispositivos) possuem compatibilidade de código-fonte bastante limitada, e nenhuma compatibilidade do arquivo de configuração entre dispositivos de diferentes fabricantes.
Organizar um programa para uma nova geração de dispositivos, ou para um dispositivo menor e mais barato, ou ainda com consumo mais baixo, tipicamente requer esforço humano substancial.
Como solução a estes problemas, é apresentada a computação organizada em fluxos para execução reconfigurável (Stream Computations for Reconfigurable Execution -- Score).
O modelo computacional Score tenta resolver a limitação de recursos físicos através da virtualização de recursos computacionais, de comunicação e de memória do hardware reconfigurável.
Configurações do FPGA são particionadas em páginas de tamanho fixo que se comunicam:
Em analogia à memória virtual, o hardware é carregado (paged in) sob demanda.
A comunicação por fluxo entre as páginas que não estão simultaneamente no dispositivo pode ser transparentemente buferizada3 através da memória.
O fluxo é uma ligação unidirecional páginaà-página.
Este esquema permite uma aplicação particionada explorar mais as páginas disponíveis fisicamente, sem necessidade de recompilação.
Em função de essa abordagem, Score permite que as reconfigurações sejam menos freqüentes, o que acarreta a amortização do custo de reconfiguração sobre um grande conjunto de dados.
Com um projeto adequado de hardware, este esquema permite compatibilidade binária e escalabilidade entre diferentes famílias de dispositivos através da compatibilidade das páginas.
Para as aplicações beneficiarem- se dos recursos físicos adicionais (páginas), o modelo de programação é uma abstração natural da comunicação que ocorre espacialmente entre blocos de hardware.
Isto é, o grafo do fluxo de dados captura os blocos de computação (operadores) e a comunicação (fluxo) entre eles.
Uma vez capturado, é possível explorar técnicas para mapeamento desses grafos em hardware de tamanho arbitrário.
Além de o mais, a composição em tempo de execução dos grafos é suportada, possibilitando uma estrutura de aplicação orientada a dados, alocação dinâmica de recursos e integração entre módulos de hardware (cores) desenvolvidos ou compilados separadamente.
Analisando- se a natureza estática de uma configuração, verifica- se a existência de dois problemas significativos:
A) Uma computação pode requerer mais hardware do que há disponível;
B) Um projeto de hardware não explora recursos adicionais de hardware que serão disponibilizados em futuras gerações desse hardware.
Uma técnica chamada de reconfiguração por pipeline de configurações pode implementar uma lógica maior que a capacidade do dispositivo alvo, através de rápidas e sucessivas reconfigurações desse hardware.
Pipeline de configurações envolve a virtualização do hardware por a divisão da lógica estática em pequenos pedaços que corresponderão a estágios do pipeline na aplicação.
A Figura 2.9 ilustra o processo de virtualização de uma lógica com cinco estágios num dispositivo capaz de implementar apenas três desses estágios.
A Figura 2.9-a mostra a aplicação com 5 estágios, e cada estágio do pipeline em sete ciclos consecutivos de relógio.
A Figura 2.9-b ilustra o estado dos estágios implementados no dispositivo, bem como a forma que a aplicação é executada.
Em este exemplo, o primeiro estágio do pipe virtual é configurado no ciclo 1, e está pronto para ser executado no ciclo seguinte, e é executado por dois ciclos consecutivos.
Embora não haja 4 estágios físicos no pipe, no ciclo 4, o quarto estágio do pipe virtual é configurado no estágio físico 1, substituindo o primeiro estágio virtual.
Em geral, quando uma aplicação é virtualizada através de um dispositivo com estágios virtuais, num dispositivo com capacidade para implementar estágios, com, a vazão da implementação é proporcional a:
A vazão é uma função linear da capacidade do dispositivo.
Portanto, o aumento de desempenho não ocorre apenas quando novas gerações de dispositivos aumentam sua freqüência de relógio;
Mas também acontece quando diminui o tamanho dos transistores, por o acréscimo de recursos num mesmo circuito integrado, até que.
Como alguns estágios são configurados enquanto outros estão sendo executados, a reconfiguração não diminui a performance.
Uma reconfiguração por pipeline de configurações é considerada bem sucedida quando tem- se a configuração de um estágio do pipe por ciclo de relógio.
Para obter- se isto conectou- se ao dispositivo um buffer de configuração on- chip, enquanto um pequeno controlador gerência o processo de configuração.
Contudo, a reconfiguração por pipeline impõe algumas restrições quanto a os tipos de aplicações.
Ciclo: Esta Seção tem por objetivo mostrar dispositivos que têm características compatíveis com alguma tendência citada na Seção 2.2, ou então que implementam métodos citados na Seção 2.4.
Pode- se notar que são dispositivos com grão grande em sua maioria, todos suportam reconfiguração dinâmica, embora uns por pipeline de configurações e outros por chaveamento de contexto.
Garp é um processador baseado no conjunto de instruções MIPS-II.
Foi projetado com o intuito de acelerar laços de programas de propósito geral.
Garp atua como um coprocessador junto ao MIPS, e consiste numa matriz bidimensional de CLBs interconectados por recursos de roteamento programáveis.
A célula lógica básica do vetor reconfigurável é uma unidade de 2 bits com quatro entradas de 2 bits cada.
A matriz tem pelo menos 24 blocos lógicos numa coluna, de os quais 16 blocos a partir de a primeira posição são conectados ao barramento do processador.
A configuração da matriz é carregada da memória.
Uma vez que um tempo significativo é necessário para carregar a configuração inteira, muitas abordagens têm sido tentadas para encurtar a latência da reconfiguração.
Uma dessas é a habilidade de reconfigurar parcialmente o vetor.
Uma unidade de memória cache é embutida junto ao sistema, e armazena as configurações usadas recentemente para um rápido recarregamento.
Em a Figura 2.10 pode ser observado um esquema da matriz Garp, onde é mostrado o bloco de dados reconfigurável.
Barramentos de memória provêem uma reconfiguração com alta largura de banda e alta taxa de transferência de dados entre a matriz e a memória.
Um suporte de software em baixo nível foi introduzido através de um conjunto de instruções de controle.
Como diferentes configurações da matriz exigem diferentes tempos de execução, uma instrução que inicia a execução contém o parâmetro de contagem de relógio, que especifica o com37 primento da execução no processador em ciclos de relógio.
A plataforma de desenvolvimento de software consiste de um compilador C e uma linguagem de configuração da matriz, que é utilizada para descrever a configuração a ser carregada na matriz do Garp.
Seguindo a idéia de unidades reconfiguráveis fortemente acopladas a um processador, o projeto Garp coloca um microprocessador completo com uma unidade reconfigurável num mesmo circuito integrado, e demonstra o incremento no desempenho se comparado a um microprocessador convencional.
Seu problema é o custo em termos de tempo, envolvido na programação do sistema, que ainda é muito alto.
PipeRench é um dispositivo composto de uma rede de elementos lógicos e de armazenamento interconectados.
Difere dos FPGAs convencionais porque propõe a virtualização do hardware, utilizando um pipeline de configurações.
É particularmente interessante para aplicações baseadas em fluxos uniformes (como processamento de imagens ou sons), ou qualquer computação simples e regular sobre grandes conjuntos de pequenos elementos de dados.
Com este dispositivo há um ganho considerável de desempenho sobre processadores convencionais.
Enquanto estes forçam uma serialização de operações intrinsecamente paralelas, PipeRench explora o paralelismo dessas operações, além de aumentar a flexibilidade e diminuir o tempo de projeto do sistema.
PipeRench também demostra ser uma alternativa interessante sobre FPGAs convencionais.
As limitações citadas na Seção 1.4 são relativizadas por a proposta de virtualização do hardware, implementado através de um pipeline de configurações (conforme analisado no Item 2.4.4).
Em a implementação atual, PipeRench atua como um processador acoplado.
A Figura 2.11 é uma visão abstrata de um estágio do PipeRench, e a Figura 2.12 é uma visão mais detalhada de um elemento de processamento (EP).
PipeRench contém um conjunto de estágios físicos de pipeline.
Cada estágio possui uma rede de interconexão e um conjunto de EPs.
Cada EP contém uma unidade lógica e aritmética (ULA) e um conjunto de registradores para comunicação entre estágios (registrador de passagem).
Cada ULA contém LUTs e controle extra para propagação de vai-um, detecção de zero, e assim por diante.
Lógica combinacional pode ser implementada usando um conjunto de ULAs de bits.
Funções combinacionais complexas podem ser obtidas com o cascateamento das linhas de propagação de vai-um, através da rede de interconexão.
A partir de as redes de interconexão os EPs podem acessar operandos dos estágios anteriores que estão armazenados nos registradores de saída, bem como saídas (buferizadas ou não) de outros EPs do mesmo estágio.
Em função de a virtualização do hardware, nenhum barramento dos EPs pode conectar estágios consecutivos.
Contudo, os EPs podem acessar barramentos de E/ S globais.
Esses barramentos são necessários porque os estágios do pipeline de uma dada aplicação podem estar fisicamente em qualquer uma das classes.
Para alcançar seus destinos, entradas e saídas da aplicação devem usar um barramento global.
O registrador de passagem provê a interconexão de EP de uma classe para o EP correspondente na classe subseqüente.
A ULA pode escrever suas saídas em quaisquer dos registradores.
Se a ULA não escreve em algum registrador do EP atual, seu valor é recebido do registrador equivalente da classe anterior.
Enquanto o registrador de passagem perfaz as conexões interclasses, a ligação entre EPs da mesma classe é realizada horizontalmente através da rede de interconexão.
Em cada classe, a rede de interconexão aceita entradas a partir de cada EP daquela classe, além de a entrada de valores de cada registrador de passagem da classe anterior.
Além de o mais, um registrador de deslocamento em cada EP desloca bits para a esquerda.
Assim, PipeRench pode manipular os alinhamentos de dados necessários para aritmética baseada em palavras.
Como na implementação atual o PipeRench é um co-processador, a largura de banda entre ele, a memória principal e o processador é limitada.
Isto inviabiliza alguns tipos de aplicações.
Mas pretende-se que, em fases posteriores o PipeRench torne- se parte integrante da UCP, e que haja uma incorporação dos conceitos de computação reconfigurável ao conjunto de instruções do processador.
O microprocessador RAW consiste de um conjunto de unidades de processamento replicadas e altamente interconectadas, conforme pode ser observado na Figura 2.13:
Cada uma dessas unidades contém um processador simples, semelhante a processadores RISC, uma porção de memória para instruções e dados, lógica configurável, e chaves programáveis.
A arquitetura RAW tem duas partes reconfiguráveis.
Em a primeira camada (mais baixa) existe lógica reconfigurável de grão pequeno em cada unidade.
A outra parte é a rede que interconecta essas unidades.
RAW usa software para implementar operações como renomear registradores, escalonamento de instruções e verificação de dependências.
Esta abordagem diminui o suporte de hardware para estas operações, o que disponibiliza mais área do circuito integrado para memória e lógica, resultando num clock mais rápido, e reduz a verificação da complexidade do circuito integrado.
A granularidade do RAW é mais grossa que a maioria dos sistemas baseados em FPGAs, pois o nó cor40 responde a um P, e não a LUTs.
Ainda comparando, RAW tem um tempo de configuração menor, atrasos de propagação melhores para operações comuns, requisitos de roteamento mais baixos, e menor área por operação semelhante a operações de ULAs.
Porém, RAW pode ainda manter o mesmo nível de paralelismo de granularidade fina que um sistema FPGA.
O sistema inteiro é distribuído sem a necessidade de uma unidade de controle central.
Cada unidade é independente com suas próprias memórias de dados, intruções e chaves -- sem um gargalo potencial de acesso à memória.
A maior parte dos recursos do RAW estão sob o controle de um compilador.
Ao invés de construir uma lógica especializada para cada operação dinâmica, tal como renomear registradores, ou prever saltos, a arquitetura RAW introduz um enfoque muito mais simples.
Conseqüentemente o compilador é muito mais complexo, e tende a eliminar intervenções do usuário durante o tempo de compilação.
Contudo, ainda há a necessidade de implementação de um compilador que manipule uma quantidade maior de programas, e explore agressivamente a capacidade de paralelismo de RAW.
Trumpet é um circuito integrado de teste que foi projetado para uso no estudo das vantagens envolvidas no projeto de matrizes reconfiguráveis acopladas a bancos de memória DRAM de alta capacidade.
O ponto alto desta arquitetura consiste numa rede de &quot;páginas computacionais «(submatrizes configuráveis) e páginas de memória (Configurable Memory Blocks -- CMBs).
Páginas computacionais são baseadas em LUTs de 5 entradas.
Páginas de memória e computacionais são interconectadas por uma rede (em forma de árvore) que se estende desde cada submatriz (folhas), alcançando os blocos lógicos individualmente, até uma conexão com um microprocessador (raiz).
A Figura 2.14 ilustra essa arquitetura.
Cada submatriz, CMB e chaveador necessitam um ou mais conjuntos de bits de configuração, dependentes da aplicação.
Tais conjuntos de bits podem ser pré-carregados na DRAM, e carregados sob demanda em seus respectivos destinos.
Submatrizes e CMBs são arranjados em pares para propósitos de reconfiguração, enquanto a configuração de cada chaveador pode ser assinalada ao CMB mais próximo.
Desta forma é possível conseguir reconfiguração total ou parcial no tempo em que se leva para configurar um subarray, um CMB e um ou dois chaveadores.
Além disso, conjuntos de bits de estados para CMBs e submatrizes podem ser carregados para inicialização, diagnóstico, ou chaveamento de contexto.
Trumpet é importante por ser uma das primeiras abordagens a valorizar a união de processador, memória e lógica reconfigurável.
Grandes bancos de memória tornam possível armazenar várias configurações num mesmo circuito integrado, possibilitando uma rápida reconfiguração em tempo de execução.
Também vale ressaltar que o dispositivo Trumpet serve como base para a abordagem proposta para o Score (Seção 2.4.3).
Apesar de não haver comprovação de que Trumpet represente o melhor equilíbrio na utilização de recursos de memória e processamento, ainda assim é um passo importante nessa direção.
Interfaces para conexão entre cores Com o aumento da densidade ocasionado por os avanços na tecnologia de semicondutores, tornouse possível a integração de numerosas funções num único circuito integrado.
Com isto, alguns periféricos que antes comunicavam- se com o processador através de barramentos externos, agora são integrados na mesma pastilha.
Conseqüentemente, os projetistas passaram a ter que se preocupar com problemas tais como ter desenvolver barramentos intra-dispositivo que provejam comunicação entre os cores embutidos, e de cada core com o mundo externo.
Em vista de essa necessidade várias iniciativas surgiram.
A maioria é voltada para ASICs, muito embora seus princípios possam ser aproveitados para o desenvolvimento de barramentos de comunicação para SoCs ou mesmo para FPGAs convencionais.
A seguir, serão mostradas as principais idéias de dois desses barramentos, que inspiram a proposta apresentada na Seção 5.6.
CoreConnect é uma iniciativa da IBM para prover integração e reutilização de processadores e cores de aplicações específicas num só dispositivo (SoC).
A arquitetura do barramento CoreConnect permite aos projetistas de hardware montar projetos de SoCs facilmente, desde que o façam utilizando cores projetados com as especificações do barramento.
Isto faz com que o tempo de projeto e, conseqüentemente o time- to-- market, do produto sejam bastante reduzidos.
Conforme pode ser visto na Figura 2.15, essa arquitetura é composta por um barramento de processador local (PLB -- Processor Local Bus), barramento periférico interno ao circuito integrado (OPB -- On- chip Peripheral Bus), um circuito que une esses dois barramentos (bus bridge), e um barramento de controle de dispositivo (DCR -- Device Control Register).
Periféricos podem ser conectados ao PLB com uma grande largura de banda e baixa latência.
Cores com freqüência mais baixa são conectados ao OPB, reduzindo o tráfego no PLB, o que aumenta o desempenho geral do sistema.
O princípio de funcionamento baseia- se num árbitro, que decide qual core de sistema (System core) vai fazer acesso o barramento de cada vez.
O PLB soluciona questões de alto desempenho e baixa latência para cores integrados ao SoC.
Ele é totalmente síncrono, e suporta a conexão de até 8 cores atuando como mestres e múltiplos cores escravos, cujo número vaira de acordo com a implementação do árbitro.
Existem 3 diferentes versões de arquitetura, com 32, 64 ou 128 bits.
Possui ainda barramentos de dados diferentes para leitura e escrita, o que torna possível transferências sobrepostas, a altas taxas.
A especificação do PLB descreve uma arquitetura de sistema com detalhamento de sinais e transações.
O OPB é um barramento de entrada e saída, criado para aliviar gargalos de desempenho entre periféricos e o PLB.
Exemplos de periféricos são portas paralelas, portas seriais, UARTs e outros dispositivos de banda estreita.
Este barramento permite aos projetistas de sistema integrar facilmente periféricos ao ASIC.
O OPB possui as seguintes características:
Protocolo totalmente síncrono, com barramentos para dados e endereços separados (cada qual com 32 bits);
Dimensionamento de barramento que permite transferências de bytes, palavras, e meiaspalavras;
Protocolo de endereçamento seqüencial (para modo rajada);
Inserção de ciclos de espera, para transferências de reduzida latência.
A IBM disponibiliza, além de as especificações do CoreConnect, um conjunto de ferramentas e testbenchs em VHDL ou Verilog.
Wishbone é uma interface portável para uso com cores, como um barramento interno para aplicações em SoCs.
Propõe a reutilização de projetos, diminuindo o problema de integração de cores.
Assim como o CoreConnect, o Wishbone também contribui para a diminuição do time-- tomarket de produtos.
A arquitetura Wishbone permite conectar cores de uma forma simples, flexível e portável.
Geralmente esses cores são desenvolvidos independentemente, e são integrados por terceiros.
O barramento Wishbone auxilia o integrador de sistemas através de uma tentativa de padronização da interface entre cores.
Wishbone utiliza uma arquitetura mestre/ escravo.
Isto significa que módulos com interfaces mestre iniciam transações de dados, e interfaces escravo participam passivamente dessas transações.
Mestres e escravos comunicam- se através de uma interface de interconexão chamada de Intercon.
A rede de interconexão do Wishbone pode ser modificada por o integrador do sistema, conforme sua necessidade.
A isto chama- se interconexão variável.
A interconexão variável permite ao integrador do sistema mudar a forma com que as interfaces mestre e escravo comunicam- se entre si.
Por exemplo, um par de interfaces mestre e escravo podem comunicar- se através de topologia ponto-a-ponto, barramento compartilhado, ou por um chaveador crossbar.
O esquema de interconexão variável é muito diferente do esquema utilizado em barramentos de computadores, como PCI, ISA, etc..
Esses sistemas usam placas de circuito impresso e conectores fixos (hardwired).
As interfaces nesses barramentos não podem ser mudadas, o que limita seriamente a forma como as placas comunicam- se umas com as outras.
Wishbone elimina essa limitação permitindo que o integrador mude a interconexão do sistema.
Isto é possível por que os circuitos integrados possuem caminhos que podem ser ajustados (roteamento e portas lógicas configuráveis).
Isto pode ser configurado no dispositivo utilizando- se uma descrição em VHDL (ou Verilog), e com o auxílio de uma variedade de ferramentas que sintetizam essa descrição.
Os autores do Wishbone (Silicore Corporation) afirmam que geralmente definem as interconexões utilizando VHDL, o que permite que as interconexões sejam definidas de forma a melhor adaptar- se à aplicação.
Conforme mencionado anteriormente, uma das grandes lacunas a serem preenchidas para o bom desenvolvimento da tecnologia de reconfiguração parcial de dispositivos FPGAs é a falta de ferramentas de CAD que permitam o projeto e a implementação de sistemas dinamicamente reconfiguráveis.
Duas iniciativas destacam- se no intuito de preencher parcialmente esse vazio.
A primeira de elas é uma pesquisa acadêmica realizada na Universidade de York, que pretende o desenvolvimento de um conjunto de ferramentas de CAD baseado em Java que permita RTR.
Uma visão geral desta pesquisa é mostrada na Seção 3.1.
A segunda iniciativa no sentido de prover ferramentas para reconfiguração parcial parte da indústria.
A equipe de desenvolvimento da empresa Xilinx (fabricante de FPGAs) criou um conjunto de classes Java, denominado JBits, com a intenção de servir como uma API (Application Programming Interface) para manipular o arquivo de configuração de seus FPGAs.
Esta API é descrita na Seção 3.2.
Durante o desenvolvimento de aplicações para computadores configuráveis (Custom Computing Machines -- CCMs), projetistas devem realizar duas tarefas gerais.
Primeiro, devem projetar o circuito que implementa a funcionalidade necessária para a aplicação.
Isto é tipicamente feito usando ferramentas comerciais de CAD, tais como as que provêem síntese lógica e física, em conjunto com programa para supervisionar a operação da aplicação.
Em os casos de aplicações RTR de maior com47 plexidade, este programa de controle pode ser igualmente complexo, carregando uma variedade de configurações e dados, sob demanda, conforme a necessidade da aplicação.
Atualmente, o programa de controle e a descrição do circuito devem ser desenvolvidos simultânea e independentemente;
O projetista é responsável por garantir que esses dois pedaços de programas irão cooperar corretamente, tipicamente através de ciclos de carga, execução e compilação repetidos.
Esta divisão entre descrição do circuito e programa de controle é na realidade a divisão da aplicação entre partes estática e dinâmica:
A estática representada por a biblioteca de circuitos, e a dinâmica constituída por o programa de controle, que escolhe configurações de hardware de uma biblioteca, configura o dispositivo e executa a aplicação.
Contudo, devido a as mudanças que ocorrem no campo da computação reconfigurável, tratar separadamente as partes estáticas e dinâmicas da aplicação é inadequado e limitante.
O que é necessário é uma única e integrada descrição que permita ao projetista naturalmente expressar as partes dinâmicas e estáticas da aplicação simultânea e conjuntamente.
Em esse sentido, Brad Hutchings e Peter Bellows propuseram uma abordagem de projeto e uma ferramenta de CAD com o objetivo de criar uma descrição integrada.
Seu projeto foi desenvolvido baseado nos seguintes requisitos:
A ferramenta deve usar uma liguagem de programação existente, sem extensões.
Isto possibilita que um grande número de programadores possam usar a ferramenta.
O paradigma de controle da CCM deve ser o de CCM independente.
Detalhes de controle da CCM devem ser elevados a um nível mais alto de abstração, com o objetivo de facilitar o processo de redirecionamento das aplicações para vários dispositivos-alvo.
O método de descrição deve suportar RTR total e parcial.
Espera- se que esse seja o tipo de CCMs que mais necessita ferramentas de CAD.
A descrição integrada deve servir para simulação e execução, sem modificações.
O sistema JHDL é implementado como um conjunto de bibliotecas de classes Java, com funcionalidade dividida em duas áreas básicas:
Simulação de circuito e suporte à execução da CCM.
As classes referentes ao suporte da execução provêem acesso transparente às funções de controle da CCM via mecanismos de construção/ destruição.
Projetistas desenvolvem circuitos em JHDL selecionando um conjunto de elementos síncronos ou combinacionais, e ligando- os de modo a formar um circuito síncrono arbitrário.
Existem três classes diferentes que podem ser utilizadas para implementar um circuito:
Cl (combinacional), Synchronous (síncrono) e Structural (interconexão entre elementos síncronos e combinatórios).
Em o uso de cada classe, o projetista define uma nova classe que herda características da classe apropriada e implementa a funcionalidade desejada no construtor e em outros métodos.
Circuitos individuais são interconectados instanciando objetos Wire e passando esses objetos como argumentos para os construtores.
Os autores deste projeto relatam que foi feita uma comparação de produtividade com alunos de sua instituição, entre VHDL e JHDL.
Segundo eles, para usuários novatos, JHDL originou um ganho significativo no tempo de projeto.
Contudo JHDL, em função de ser baseada em Java, acarreta um tempo de simulação bastante elevado.
Maiores informações a respeito de o status atual do projeto JHDL podem ser obtidas no endereço.
Apesar de FPGAs baseados em SRAM poderem sofrer inúmeras configurações, existem muito poucas ferramentas, bem como poucas informações disponíveis comercialmente para realização de RTR.
Este cenário começou a mudar com a apresentação da família de FPGAs XC6200 da Xilinx, que permitia reconfiguração parcial.
Porém, tal família não logrou sucesso por não ter surgido nenhuma ferramenta comercial que explorasse a característica de RTR da XC6200.
Em o sentido de criar um conjunto de ferramentas para reconfiguração parcial, a Xilinx iniciou o projeto JERC6K, vinculado à família 6200.
Com a descontinuação dessa família, o projeto foi transferido para suportar a família XC4000, e foi renomeado para Xilinx Bitstream Interface (ou XBI).
Esse programa foi mais tarde renomeado para JBits.
Contudo, a família XC4000 não continha suporte para reconfiguração parcial.
Quaisquer mudanças na configuração do circuito exigiam a parada do dispositivo, e sua reconfiguração era lenta ao ponto de ser inaceitável para determinadas aplicações.
Mais recentemente, o conjunto de classes JBits foi portado para a família de dispositivos Virtex.
JBits é um conjunto de classes Java que fornecem uma API que permite manipular o arquivo de configuração da família de FPGAs Virtex da Xilinx.
Esta interface opera tanto em arquivos de configuração gerados por as ferramentas de projeto da Xilinx quanto em arquivos de configuração lidos do hardware.
A motivação original do JBits foi suportar reconfiguração dinâmica em FPGAs da família Virtex.
Para atender a este requisito, a ferramenta deve ser rápida e prover informações físicas a respeito de o circuito a ser reconfigurado.
A solução encontrada foi criar uma biblioteca de classes que dá acesso a todos os elementos arquiteturais reconfiguráveis do dispositivo.
Isto permite que o circuito seja reconfigurado sem a necessidade de se refazer o posicionamento e roteamento com as ferramentas convencionais.
O fluxo de projeto com o uso do JBits é ilustrado na Figura 3.1.
A Figura 3.1-a mostra uma aplicação Java escrita por o usuário.
Este programa acessa a Interface do JBits para manipular os recursos configuráveis do FPGA.
Cada chamada de função no nível de interface do JBits realiza uma ou mais chamadas de funções à Interface em Nível de Bit.
Em este nível, é possível modificar até um único bit no arquivo de configuração.
Mesmo que seja possível configurar bits individualmente, não é provável que o usuário do circuito deseje lidar com um nível tão baixo de abstração.
Por isto, a Interface JBits disponibiliza uma abstração que permite a modificação de conjuntos de bits.
Outro nível de detalhe que deve ser escondido do usuário diz respeito às especificidades relativas a dispositivos diferentes de uma mesma família de FPGAs.
A Interface em Nível de Bit pode ser vista como uma camada que provê suporte necessário para que detalhes como a localização de um bit num FPGA XCV300 ou num FGPA XCV150 seja transparente para o usuário.
Finalmente, a Interface em Nível de Bit interage com a classe Bitstream.
Esta classe gerência o arquivo de configuração do dispositivo e provê suporte para leitura e escrita das configurações dos arquivos e para eles.
Ademais, a classe Bitstream pode receber dados lidos diretamente do dispositivo (readback) e mapear- los para o formato de bitstream.
Esta habilidade de gerenciar dados obtidos por readback é HardWare InterFace) para configurar o dispositivo e realizar o readback (Figura 3.1-d).
Além de o que foi exposto, ainda há outra parte relacionada na Figura 3.1: A biblioteca de Cores.
Essa biblioteca é um conjunto de classes em java que define macrocélulas, ou módulos parametrizáveis de hardware, que podem ser adicionados ou removidos do dispositivo.
O modelo de programação utilizado por o JBits é baseado numa matriz bidimensional de CLBs.
Cada CLB é referenciada por uma linha e uma coluna.
Assim, todos os recursos configuráveis na CLB selecionada podem ser configurados ou analisados.
Além disso, o controle de todo o roteamento adjacente à CLB selecionada torna- se disponível.
Por o fato do controle ser ao nível de CLB, os arquivos de configuração podem ser modificados ou gerados rapidamente.
Esta API tem sido utilizada para construir circuitos completos ou para modificar circuitos existentes.
Esta API pode ser utilizada como base para a construção de outras ferramentas.
Isto inclui ferramentas de projeto tradicionais para executar tarefas como posicionamento e roteamento do circuito, bem como ferramentas de aplicação específica, como por exemplo um configurador de cores.
O JBits fornece uma abordagem de linguagem de alto nível para desenvolvimento de sistemas reconfiguráveis incluindo reconfiguração em tempo de execução.
É necessário que o projetista tenha conhecimento do seu circuito e dos detalhes de configuração do dispositivo, pois, caso contrário, o JBits pode gerar dados que danifiquem o dispositivo.
A maior desvantagem da API JBits é sua natureza manual.
Tudo deve ser explicitamente relacionado no código-fonte.
Esta característica, contudo, pode ser amenizada com a utilização de cores ou macrocélulas.
Devido a esta necessidade Fde especificação explícita de todos recursos, a interface JBits favorece circuitos mais estruturados.
Circuitos não-estruturados (lógica aleatória, por exemplo) não são bem adaptadas para uso com o JBits.
Outra limitação importante é que a API Jbits requer que o usuário seja familiarizado com a arquitetura do dispositivo.
Conforme antes citado, a utilização de aplicações desenvolvidas com o auxílio das classes JBits, sem o devido conhecimento de detalhes arquiteturais do dispositivo, pode causar danos físicos ao FPGA.
Além de isto, como a interface JBits necessariamente atua no nível de configuração do bitstream, a criação ou modificação de um arquivo de configuração com o JBits elimina qualquer possibilidade de utilização de ferramentas de análise disponíveis para depuração futura do circuito.
Especificamente, a habilidade de realizar quaisquer tipos de análises de temporização está ausente no JBits.
XHWIF, a interface de hardware Xilinx (Xilinx Hardware InterFace), é uma interface escrita em Java para comunicação entre um computador hopedeiro (host) e uma placa baseada em FPGA.
Ela é composta por métodos para leitura e escrita de bitstreams no FPGA, e métodos para descrição do tipo e do número de FPGAs na placa em questão.
Também inclui métodos para leitura e escrita nas memórias na placa, e possibilita ligar- la e desligar- la.
A interface padroniza a forma de comunicação com o hardware, de tal forma que, utilizando a mesma interface, diversas aplicações podem comunicar- se com uma variedade de placas.
Toda informação específica do hardware é encapsulada dentro de uma classe que implementa a interface XHWIF.
Utilizando a interface nativa Java (JNI -- Java Native Interface), que permite que programas Java interajam com programas C, chamadas à interface são convertidas em chamadas aos drivers da placa.
Esta metodologia possibilita que as aplicações comuniquem- se diretamente com os drivers ou com o barramento.
Escondendo informações específicas do barramento e dos drivers na classe qualquer barramento, que pode ser PCI, ISA, ou qualquer outro padrão.
Esta possibilidade admite a depuração do projeto mesmo sem o acesso direto ao hardware, além de permitir que diversos usuários testem suas aplicações no mesmo hardware (obviamente, através de um escalonamento no tempo).
Em a documentação do JBits encontra- se afirmação de que reconfiguração dinâmica pode ser obtida nenhuma referência a respeito de uma reconfiguração dinâmica realizada com a utilização do JBits, teoricamente isto pode ser possível, segundo o método a seguir descrito.
Uma aplicação RTR pode realizar chamadas à interface JBits para modificar os dados do arquivo em seguida faria chamadas para realizar download e readback dos dados de configuração.
Contudo, em testes realizados no laboratório do GAPH, observou- se que a geração do arquivo de configuração parcial utilizando JBits deu- se com erro.
Primeiramente foi criado o bitstream completo, depois, com a ferramenta que é descrita na Seção 5.1, foi gerado o bitstream parcial.
Quando tentou- se realizar o download parcial, o software utilizado para isto (JTagProgrammer) retornou mensagem de erro.
Posteriormente, analisando- se o arquivo de configuração parcial, percebeu- se que o protocolo de configuração gerado não condizia com o que é descrito na documentação do dispositivo.
A última versão do JBits (2.7), no entanto, gera um bitstream parcial correto.
Utilizando- se o JTagProgrammer é possível carregar o bitstream parcial no dispositivo.
Contudo, o FPGA não é configurado corretamente, em função de limitações do JTagProgrammer.
Tais limitações são comentadas na Seção 5.5.
Em o sentido de obter maior vantagem do suporte da arquitetura Virtex à reconfiguração parcial, a API JBits foi estendida com a API JRTR.
Esta interface provê um modelo de cache onde as mudanças dos dados de configuração são ajustadas, e somente os dados realmente necessários são escritos no dispositivo, ou lidos de ele.
A recente adição do programa JRTR (Java Run-Time Reconfiguration) à nova versão do conjunto de classes JBits resultou no suporte direto à reconfiguração parcial.
Este suporte utiliza uma combinação de técnicas de hardware e programas para permitir que pequenas alterações sejam feitas diretamente no arquivo de configuração da Virtex, de forma rápida e sem a interrupção da operação.
A interface do JBits existente é ainda utilizada para ler e escrever arquivos de configurações do disco, ou de outro dispositivo externo.
O JRTR Bitstream Parser/ Generator é utilizado para analisar o arquivo de configuração, e para manter a imagem dos dados e as informações de acesso.
A API atual provê controle simples, mas completo, da cache de configurações.
O usuário pode produzir configurações parciais em qualquer tempo, e então carregar- las no hardware.
Hardware que habilita reconfiguração parcial.
Os primeiros dispositivos que suportaram reconfiguração parcial foram criados por as empresas National, Algotronix e Xilinx.
Os resultados foram as famílias de FPGAS Clay, Cal1024 e XC6200, respectivamente.
Tais FPGAs não lograram grande sucesso comercial principalmente por o fato de não terem sido produzidas ferramentas eficientes de projeto, de roteamento e de posicionamento.
Outro fabricante de FPGAs, a Altera, alega que a partir de a família Apex permitiu reconfiguração parcial.
Contudo isto ocorre de forma muito limitada.
A reconfiguração parcial dessa família dá- se através do projeto de lógica em RAM, criando uma LUT1 onde podem ser implementadas funções com 7 entradas e 16 saídas.
Depois dessa lógica ser implementada no bloco de RAM o sistema pode reescrever- la em qualquer tempo, mudando a configuração de parte do sistema.
A grande limitação desta abordagem é que em algum lugar do circuito deve- se armazenar todas as configurações possíveis que irão modificar a RAM, isto porque não há como fazer a carga externa de novas configurações.
Portanto, na visão deste autor, a família Apex não suporta reconfiguração parcial, e a alegação do fabricante é incorreta, constituindo mais uma peça de publicidade que uma informação técnica.
Duas empresas -- Atmel e Xilinx -- comercializam famílias FPGAs que permitem reconfiguração parcial.
Em a próxima Seção será feita uma breve descrição da família AT40k da Atmel.
A Seção disposição dos elementos internos de sua arquitetura no arquivo de configuração.
Ver subseção 1.2.1 Os FPGAs da família AT40K foram especialmente projetados para suportarem Cache Logic, que é uma técnica para construir sistemas e lógica adaptáveis, permitindo reconfigurar parte do dispositivo sem interromper a operação da lógica remanescente.
Em um sistema de Cache Logic somente as porções da aplicação que estão ativas num dado momento realmente estão implementadas no FPGA, enquanto funções inativas são armazenadas externamente numa memória de configuração.
Se novas funções se fazem necessárias, as antigas são sobrescritas, como mostrado no diagrama da Figura 4.1.
Este procedimento aproveita- se da latência funcional inerente a muitas aplicações -- em qualquer tempo dado, somente uma pequena proporção da lógica está de fato ativa.
Ou seja, funções podem ser substituídas em tempo de execução no FPGA, enquanto o sistema continua a operar.
A implementação do Cache Logic é conceitualmente semelhante à organização de caches em subsistemas de memória.
Em o cache de memória uma memória de velocidade mais rápida (normalmente uma SRAM) é utilizada para armazenar os dados ativos, enquanto um maior volume de dados reside numa memória de menor custo, tais como DRAM, EPROM ou disco magnético, etc..
Cache Logic trabalha de forma semelhante.
Em a Cache Logic somente uma pequena porção do circuito -- aquelas funções que são em ela carregadas -- estão ativas no sistema num dado momento, enquanto as funções não utilizadas permanecem numa memória de custo mais baixo.
À medida que novas funções são requeridas, elas podem ser carregadas na Cache Logic, substituindo ou complementando a lógica já presente.
A habilidade de implementar Cache Logic requer do FPGA a capacidade de ser reconfigurado dinamicamente.
Outro requisito é a simetria da arquitetura.
Isto é necessário para tornar possível o posicionamento arbitrário de blocos genéricos, numa localização que esteja disponível no momento necessário.
Existem dois tipos de Cache Logic:
Predeterminada e dinâmica.
A primeira envolve o uso de funções predeterminadas, gravadas numa memória externa não volátil (EPROM, por exemplo).
Essas funções são previamente roteadas e posicionadas, e o arquivo de configuração correspondente a elas foi previamente gerado.
A implementação dessas funções é previamente controlada por um gerenciador residente na Cache Logic.
Novas funções devem ser carregadas na Cache Logic em background, sem promover uma parada na operação da cache.
O segundo tipo de Cache Logic, dinâmica, é a base para construção de um hardware evolutivo.
Cache dinâmico envolve a determinação da lógica, posicionamento e roteamento, geração do arquivo de configuração, e configuração da Cache Logic em tempo de execução.
Os principais aspectos abrangidos no desenvolvimento dessa capacidade incluem o escalonamenteo e alocação de funções, coleta de lógica aleatória e detecção de colisão.
De acordo com a tendência em desenvolver sistemas que integrem lógica programável, memória e processador genérico num único dispositivo (SoC), com a possibilidade de desenvolvimento de soluções integradas de hardware e software, a ATMEL produziu o FPSLIC (Field Programmable System Level Integrated Circuits).
O FPSLIC é um dispositivo que integra num único chip o core de um processador AVR de 8 bits (RISC) que atua como controlador capaz de processar até 30 MIPS (Figura 4.2-a), um FPGA AT40K para o bloco de dados (Figura 4.2-b), um multiplicador em hardware (Figura 4.2-c), controladores de memória e de configurações, e 32K de memória SRAM (Figura 4.2-d) -- tudo no mesmo Ci.
A Figura (Figura 4.2- e) e os blocos lógicos com conexões em 8 lados, para implementar funções complexas sem causar impacto nos recursos de barramento (Figura 4.2-f).
Esta arquitetura possibilita a prototipação rápida de sistemas complexos com um baixo consumo de potência, e é passível de ser reconfigurada dinamicamente.
Foi desenvolvido para o FPSLIC um conjunto de ferramentas de suporte para criação de sistemas integrados GPP-FPGAs, utilizando síntese, simuladores e co-simulação.
Devido a esta integração entre componentes de hardware e software, problemas de implementação podem ser detectados em estágios preliminares de projeto, diminuindo o impacto desses problemas na estimativa de tempo do projeto.
Esta integração permite também a redução no consumo de potência executando funções de algoritmos complexos em DSP ou FPGAs, ao invés de usar componentes em software.
Além de isto, o microcontrolador pode ser usado para controlar a Cache Logic, auxiliando no processo de reconfiguração dinâmica do sistema.
Cada FPGA da família Virtex possui CLBs, IOBs, blocos de RAM, recursos de relógio, roteamento programável e configuração do circuito elétrico.
Essas funcionalidades lógicas são determinadas através de um arquivo de configuração.
Arquivos de configuração contêm uma mescla de comandos e dados.
Eles podem ser lidos e escritos através de uma das interfaces de configuração da Virtex.
A memória de configuração da Virtex pode ser vista como uma matriz bidimensional de bits.
Estes bits são agrupados em quadros verticais com um bit de largura, e se estendem do topo à base da matriz.
Um quadro é a unidade atômica de configuração:
É a menor porção de memória de configuração que pode ser lida ou escrita.
Quadros são lidos e escritos seqüencialmente, com endereços crescentes para cada operação.
Múltiplos quadros consecutivos podem ser lidos ou escritos com um único comando de configuração.
A matriz de CLBs inteira, mais o bloco de interconexão de SelectRAM podem ser lidos ou escritos com apenas um comando.
Cada bloco de conteúdo de SelectRAM deve ser lido ou escrito separadamente.
Como os quadros podem ser lidos ou escritos individualmente, é possível reconfigurar parcialmente esses dispositivos através da modificação desses quadros no arquivo de configuração.
Além de isto, a disposição regular de elementos permite ações de relocação e desfragmentação, que são importantes para reconfiguração parcial.
Em esta Figura nota- se que cada CLB contém duas fatias (Slices), que por sua vez contém duas LUTs cada, além de recursos de Carry2 e dois flip-flops.
Os elementos internos ao FPGA (CLBs, IOBs, BlockRAMs, recursos de relógio e roteamento programável) são distribuídos por o dispositivo de forma regular.
Tal regularidade pode ser denotada através da disposição desses elementos em colunas, conforme a Figura 4.4.
Em a Figura 4.4 ainda podem ser vistos os quadros em relação a a uma coluna.
Cada coluna CLB é cortada verticalmente por 48 quadros sucessivos.
Como a disposição das CLBs é em colunas, a modificação de uma CLB implica na alteração de todas as CLBs da coluna a que pertence.
Notese ainda na mesma Figura que as colunas são numeradas a partir de o 0 (zero) -- atribuído à coluna central.
As demais colunas são numeradas em ordem crescente, com valores pares à esquerda da coluna central, e ímpares à sua direita.
Tal numeração será importante para localização de elementos, conforme o item 4.2.3.
Conforme mencionado anteriormente, a memória de configuração da Virtex pode ser vista como uma matriz regular de bits.
Esses bits são agrupados em quadros verticais com um bit de largura, que se estendem do topo à base da matriz.
Cada quadro contém informações de cada elemento de uma coluna.
Cada CLB é cortado por 48 quadros, utilizando 18 bits de cada um.
Desta forma, um CLB é completamente configurado por 864 bits.
A Figura 4.5 mostra uma abstração da composição de um quadro de uma coluna de CLBs.
Os 18 primeiros bits de um quadro correspondem aos 2 IOBs do topo da coluna, e os 18 últimos, aos 2 IOBs da base da coluna (Figura 4.4).
Entre esses grupos, há conjuntos de 18 bits correspondentes aos CLBs do dispositivo.
Para o dispositivo XCV300, há 32 desses conjuntos.
Em o arquivo de configuração dos FPGAs da família Virtex as informações são gravadas em conjuntos de 32 bits, chamados palavras.
Portanto, o quadro deve conter um número de bits que seja múltiplo de 32.
Por exemplo, para quadro ilustrado na Figura 4.5 há 612 bits (576 para CLBs e 36 para os IOBs).
Como 612 não é divisível por 32 (o resto desta divisão seria 0,125 palavras), são adicionados 28 bits, de forma que o quadro passa a ter 640 bits -- o que equivale a 20 palavras.
Uma vez que a organização dos quadros da Virtex exige uma palavra de preenchimento3 ao final de cada quadro[ XIL00a], uma coluna de CLBs do XCV300 possui 21 palavras, ou 672 bits de altura.
As características dos FPGAs membros da família Virtex podem ser vistas na Tabela 4.1.
Em ela constam o número de colunas e linhas de cada dispositivo, bem como o número de bits e palavras por quadro.
Estas informações são relevantes para as equações que serão analisadas nas Seções adiante.
Calculando- se o total de quadros, pode- se chegar ao número de bits necessários à configuração de um FPGA Virtex.
Este total é dado por a Equação 4.1:
Palavra contendo 32 zeros Onde:
IOB é o número de quadros por coluna de IOBs;
RAM é o número de quadros por coluna de RAM;
RAMConnect é o número de quadros por coluna de RAMConnect;
A constante 2 significa que há dois conjuntos de IOB+ RAM+ RAMConnect (um à esquerda e outro à direita do FPGA);
Relógio é a coluna central da Virtex, que possui 8 quadros;
A constante 3 representa que há um quadro de preenchimento depois de cada coluna de RAM, e outro para complementar as colunas de CLBs+ RAMConnect.
Por exemplo, substituindo as constantes na equação, tem- se que o total de quadros do FPGA XCV300 é de 2605.
Como cada quadro possui 21 palavras de 32 bits, o XCV300 possui 1.750.560 bits de configuração, excetuando- se palavras de comando e sincronização, que serão discutidas na próxima Seção.
Os bits de configuração de um FPGA da família Virtex são organizados num arquivo de configuração chamado de bitstream.
Uma ferramenta para síntese de alto nível pode gerar dois formatos de bitstream.
O primeiro é o formato binário, mais compacto, utilizado normalmente para configurar FPGAs (possui a extensão».
Bit&quot;). O segundo tem o formato ASCII, utilizado para fins didáticos (possui a extensão».
Rbt&quot;). É possível realizar o download de ambas formas, mas através da segunda é possível analisar a estrutura do arquivo de configuração.
Os números entre parênteses correspondem aos quadros de um XCV300 O bitstream é composto por um fluxo de palavras que segue o protocolo de configuração determinado por o fabricante para o dispositivo.
Este protocolo de configuração é controlado por uma coleção de registradores de 32 bits.
A lógica de configuração é controlada e acessada através desses registradores, que são exibidos na Tabela 4.2.
O formato do registrador no arquivo de configuração é exibido na Figura 4.6.
Segundo o fabricante do dispositivo, os campos que estão preenchidos com zero ou um devem permanecer desta forma.
Em esta figura, um &quot;X «indica um campo onde o bit correspondente é variável, e deve ser escrito.
As linhas verticais são usadas para facilitar a leitura, separando a palavra em nibbles.
A Figura 4.7 mostra a estrutura do arquivo de configuração para um dispositivo XCV300, composto por 54.744 palavras.
Há uma seqüência de inicialização composta por uma palavra de enchimento, uma palavra de sincronização e 16 palavras que correspondem aos comandos de escrita de valores nos registradores internos de configuração do FPGA (Figura 4.7-I).
A última palavra da inicialização é uma escrita no registrador FDRI e indica quantas palavras de dados (quadros com informações de configuração da lógica a ser implementada) seguirão- se- (Figura 4.7-II).
Em estas palavras é que está escrita a lógica que será implementada no FPGA.
Seguem- se dados do primeiro bloco de RAM (Figura 4.7-III) que é precedido por comandos que informam que serão gravados dados em RAM.
Essa estrutura repete- se para o segundo bloco de RAM (Figura 4.7-IV).
O número de palavras dos blocos de RAM diferem porque o primeiro bloco é seguido de um quadro de enchimento.
O arquivo de configuração possui um método para verificação de erro, através do registrador de verificação de redundância cíclica (Cyclic Redundancy Check -- CRC).
Quando uma informação é escrita em algum registrador (exceto o LOUT) um valor de CRC de 16 bits é calculado, usando tanto os dados como o endereço do registrador.
Este valor é armazenado no registrador de CRC.
A o final de uma série de escritas, um valor pré calculado é escrito no registrador.
Se o resultado for um valor diferente de zero, isto indica que algum erro ocorreu, e o bit CRC_ ERROR, acessível através do registrador de estado, é setado.
A Figura 4.8 ilustra este processo.
O CRC é calculado em dois pontos do arquivo de configuração.
O primeiro ocorre logo após a escrita do segundo bloco de RAM (porção V da Figura 4.7) e o segundo aconte depois da escrita do último quadro de preenchimento (parte VII da Figura 4.7).
A Figura 4.7-V inclui a escrita de 3 palavras que indicam que será escrito o último quadro (Figura quadro (LFRM -- last frame).
A terceira é a seleção do registrador FDRI, que precede a escrita de um ou mais quadros de configuração.
Ainda antes de completar bitstream, há comandos informando a inicialização do dispositivo.
Isto se dá através de 4 palavras (Figura 4.7 -- VII), que são:*
seleção do registrador CMD (palavra);*
escrita no registrador CMD (palavra).
Essa escrita é a indicação da inicialização do dispositivo, através do comando &quot;START&quot;;*
seleção do registrador CTL (control -- palavra);*
escrita no registrador CTL, com a indicação do modo de leitura ou escrita, a utilização de buffers tri-state, além de informar se a interface da configuração atual permanecerá após a reconfiguração (palavra).
Depois ocorre a seleção do registrador de CRC, e a conseqüente escrita de seu valor final.
Ainda conforme a Figura 4.10, as últimas 4 palavras são um preenchimento utilizado para indicar o fechamento do arquivo (Figura 4.7-VII).
A identificação dos registradores de comandos e do formato da palavra de dados para cada um de eles é necessária para que seja possível a modificação dos parâmetros para uma reconfiguração parcial.
Por exemplo, uma reconfiguração pode ser disruptiva ou não, dependendo da seleção de um bit no registrador Cor.
Logo após a seleção deste registrador, o bit 15 da palavra de dados indicará se o modo de inicialização do FPGA será StartUp (dinâmico) ou ShutDown (estático) -- na Figura 4.9 a inicialização é estática.
A Figura 4.9 mostra as 18 primeiras palavras de um arquivo de configuração para o dispositivo XCV300.
Para fins didáticos, o arquivo foi comentado.
Ao lado de as palavras de configuração há uma breve descrição de seu significado.
Já a descrição das últimas 36 palavras do arquivo de configuração pode ser acompanhada através da Figura 4.10.
A próxima Subseção vai explicar outro aspecto de grande relevância para obtenção de uma reconfiguração parcial.
Trata- se da localização de elementos (LUTs, e determinados bits de uma LUT) dentro de o FPGA.
Para que seja factível uma reconfiguração parcial, além de o domínio da escrita nos registradores de um FPGA, faz- se necessária a possibilidade de localizar determinados bits no arquivo de configuração.
A tarefa a princípio é árdua, pois que somadas todas as palavras de um bitstream (conforme a Figura 4.7) e multiplicadas por sua largura em bits (32), tem- se que localizar um bit de entre 1.750.560 bits!
Analisando as equações apresentadas em, é possível estabelecer um roteiro para localização de um determinado bit de uma CLB no arquivo de configuração.
Como conseqüência disto, torna- se possível a leitura de um conjunto de elementos.
Este trabalho está direcionado para realização da reconfiguração parcial de LUTs configuradas como memória (LUTSelectRAM).
Assim, os exemplos a seguir referem- se à localização do bit 14 de uma F-LUT.
O posicionamento de uma CLB em coordenadas pré-definidas pode ser obtido através da edição do arquivo de restrições de usuário (UCF, do inglês User Constraints File).
As coordenadas de uma CLB são dadas, pois, por Linha (Row), Coluna (Column) e Fatia (Slice), no seguinte formato:
R1 C1_ S0.
O primeiro passo para a localização desse bit no arquivo de configuração é o cálculo do Major Address (MJA), ou seja, a coluna onde está a CLB que contém o bit em questão.
Para tanto se fazem necessárias algumas informações (será usada a notação e as equações sugeridas em):
Linha onde encontra- se a CLB desejada:
Coluna onde encontra- se a CLB desejada:
Número de colunas do dispositivo:
Além de isto, há que se aplicar o seguinte algoritmo abaixo:
Considerando o dispositivo XCV100, e aplicando as informações no algoritmo acima, para o caso dado, o Major Address será:
Assim, como mostrado na Figura 4.11, a CLB denotada por R1 C1_ S0 encontra- se na coluna 30 do FPGA.
O passo seguinte é identificar em qual quadro desta coluna encontra- se o bit desejado.
Tal informação é chamada Minor Address, ou MNA, e é dada por a Equação 4.2: Onde:*
wd equivale ao número de bits por palavra (32)* a diferença entre lut_ bit+ wd e o restante da equação deve- se ao deslocamento horizontal dependente da fatia onde se encontra o bit desejado.
Em a Figura 4.12 pode ser visto que há uma distância em quadros considerável entre as LUTs da fatia 0 e as LUTs da fatia 1.
Se Slice $= 0, MNA $= lut_ bit+ 32.
Se Slice $= 1, MNA $= 15 -- lut_ bit.
Utilizando a Equação 4.2 obtém- se:,
portanto, MNA $= 46.
A Figura 4.12 mostra um ilustração do que foi obtido até agora.
Através do MJA encontrou- se a coluna desejada.
O MNA indicou em qual quadro encontra- se o bit procurado.
Contudo, até o momento não é sabida a altura (em bits) onde se localiza o bit 14 da F-Lut contida em R1 C1_ S0.
A posição vertical do bit (relativa ao quadro) é obtida através do cálculo do Frame Bit Index, ou fm_ bit_ idx, por a Equação 4.3: Onde:
FG vale 1 caso o bit desejado encontre- se na G-Lut, e 0 para F-Lut;
CLB é multiplicado por 18 porque esta é a altura em bits de um CLB, logo esta multiplicação fornece o início de um CLB, conforme a linha onde se encontra;
O valor 3 adicionado indica que o bit inicial de uma LUT fica 3 bits abaixo de o início de um Conforme, quando escreve- se um arquivo de configuração no FPGA, uma palavra de preenchimento é colocada ao final de cada quadro.
Quando se obtém um arquivo de configuração por ReadBack5, uma palavra de preenchimento precede as palavras de informações válidas.
Logo, para ReadBack, RW $= 1.
Como neste caso é uma operação de escrita, RW $= 0.
Substituindo os valores deste estudo de caso na equação, obtém- se:
Operação de leitura do estado de um dispositivo físico.
Portanto, para este caso, o bit 14 da F-Lut em questão está na posição 21 do quadro 46, tudo na coluna 30 do FPGA XCV100, como também pode ser observado na Figura 4.12.
Contudo, não basta saber onde o bit está fisicamente.
Para que seja procedida a leitura deste bit, é imprescindível sua localização no arquivo de configuração.
Como visto na Tabela 4.1, um quadro da XCV100 é composto por 14 palavras de 32 bits.
Então, a primeira informação necessária para localização do bit no arquivo de configuração é a identificação da palavra inicial do quadro (Frame Start Word, ou fm_ st_ wd) que contém esse bit.
Para este cálculo, há que se levar em consideração os seguintes tópicos:
O número de quadros do relógio (8) deve ser &quot;saltado», já que está no início do arquivo de configuração (8 quadros após o primeiro comando de FDRI);
Deve- se somar ao valor 8 o deslocamento relativo ao número de colunas e o número de quadros;
O número de palavras por quadro do dispositivo (FL $= 14) deve multiplicar a resultante do cálculo acima, para que se obtenha a palavra inicial do quadro;
Como o caso que está sendo analisado trata- se da escrita de um bit, adiciona- se RW x FL, com RW $= 0.
Então chega- se à Equação 4.4: Aplicando- se os valores deste exemplo, tem- se:
Resta, pois, computar dois valores para que seja localizado o bit exato através do arquivo de configuração:
O primeiro é a palavra em que esse bit se encontra, e o segundo é a posição desse bit na palavra.
A Figura 4.13 ilustra o quadro que se inicia na palavra 20.244 do arquivo de configuração.
Dada a palavra em que o quadro é iniciado, a palavra em que se encontra o bit desejado é obtida por a divisão do índice do bit em relação a o quadro (fm_ bit_ idx) por o número de bits da palavra, sendo que o resultado deve ser truncado6 (Equação 4.5).
Para o exemplo em questão, fm_ wd $= 0, portanto, o bit desejado está na palavra 20.244.
Ou seja, na Figura 4.13 corresponde à linha 0.
O último passo, então, é encontrar o bit na palavra.
Este cálculo é dado por a equação 4.6: Observa- se na Figura 4.13 que desta forma foi localizado o bit 14 da F-Lut da CLB R1 C1_ S0.
Recapitulando o problema e a seqüência das equações, tem- se que MJA indica a coluna que contêm a CLB R1 C1_ S0.
O MNA informa o quadro onde está o bit que se quer encontrar.
Fm_ bit_ idx mostra a posição desse bit em relação a o quadro, conforme a Figura 4.12.
Fm_ st_ wd indica, no arquivo de configuração, a palavra onde o quadro informado por o MNA é iniciado.
Fm_ wd é o deslocamento, em termos de palavras, do início do quadro até a palavra que contém o bit procurado.
Finalmente, fm_ wd_ bit_ idx localiza o bit desejado dentro de uma palavra.
Desta forma está compreendida a localização de um determinado bit dentro de um FPGA Virtex, o que é essencial para que se proceda a uma reconfiguração parcial.
Em o próximo capítulo serão descritas ferramentas para manipulação de bitstreams desenvolvidas a partir de o estudo apresentado nesta Seção.
Como uma das lacunas para o desenvolvimento da tecnologia de reconfiguração dinâmica de sistemas digitais é a falta de ferramentas de CAD, durante a pesquisa que originou esta dissertação, buscou- se desenvolver um conjuno de ferramentas que contribuísse à diminuição dessa carência.
Este Capítulo mostra dois conjuntos de aplicativos desenvolvidos para manipular arquivos de configuração, desde um nível mais baixo (bit) até a reconfiguração de módulos completos de hardware.
O primeiro conjunto compreende aplicativos baseados nas classes JBits para prover reconfiguração remota de FPGAs, além de possibilitar que essa reconfiguração ocorra sem que o usuário tenha conhecimento de detalhes arquiteturais do dispositivo com o qual está trabalhando.
O segundo conjunto é composto por outros três aplicativos desenvolvidos sem o auxílio do JBits, baseados apenas nos estudos da estrutura e organização interna de FPGAs da família Virtex, descritos na Seção 4.2.
O primeiro aplicativo deste conjunto permite manipular um arquivo de configuração em nível de bit, oferecendo grande flexibilidade e permitindo a geração de um bitstream parcial.
O segundo aplicativo trata apenas de esconder alguns detalhes referentes aos protocolos de configuração, permitindo ao usuário manipular sua aplicação no nível de LUTs.
O terceiro programa deste conjunto é uma ferramenta de alto nível que permite a unificação de cores através de uma interface gráfica, gerando um novo arquivo de configuração a partir de dois cores iniciais.
Essas ferramentas podem servir de base para uma ferramenta de CAD de mais alto nível, à A necessidade de uma certa compatibilização entre os cores que serão inseridos ou removidos de determinado sistema induz ao desenvolvimento de uma interface de comunicação entre esses módulos, e de eles com o mundo externo.
Esta proposta é apresentada na Seção 5.6.
A primeira ferramenta desenvolvida tem o objetivo de manipular dados contidos em LUTs, fazendo uso das classes oferecidas por o JBits.
Todo o trabalho de reconfiguração é feito sobre o bitstream, ou seja, com hard cores e não soft cores.
A aplicação criada permite as seguintes funcionalidades:
As duas primeiras funcionalidades implicam na possibilidade de modificar o comportamento do circuito por a alteração dos seus parâmetros de configuração do circuito.
A terceira funcionalidade pode significar uma grande redução de custos para o projetista do sistema.
Por exemplo, um determinado fabricante detecta um erro em seu circuito.
Se reconfiguração remota é utilizada, ele pode atualizar o hardware de todos os seus clientes à distância, sem que estes percebam que o sistema foi modificado.
Outros exemplos, como atualização do hardware em função de evolução na tecnologia (por exemplo, um novo algoritmo de compressão de imagem para set-top box) também são válidos.
A ferramenta em questão foi desenvolvida em Java.
Ela permite acessar remotamente os bitstreams e visualizar suas configurações.
Possibilita modificação de LUTs, procura de uma LUT com uma configuração específica e visualização da listagem de todas as LUTs com configurações diferentes da configuração padrão.
Após modificar o bitstream é possível salvar- lo e baixar- lo remotamente para a placa sem a necessidade de nenhum software extra.
Trecho de código mostrando a utilização de um método da classe JBits.
Atrasaram um pouco o desenvolvimento, pois não estavam documentadas, mas não impediram que os objetivos propostos para essa ferramenta fossem plenamente alcançados.
O configurador de bitstreams foi implementado seguindo o paradigma cliente-servidor.
O lado servidor da aplicação (Figura 5.2) é responsável por atender os clientes e executar todas as funções citadas anteriormente e passar via sockets as respostas para os clientes.
Em a chamada da aplicação deve ser informado qual é o dispositivo alvo e qual a porta que aceitará conexões.
Também é responsabilidade do servidor salvar um arquivo de configuração e realizar a chamada ao programa JTAGProgrammer, que realiza o download da configuração para o dispositivo alvo.
O lado cliente (Figura 5.3) provê uma interface que permite facilmente localizar elementos no bitstream.
O cliente é disponibilizado na forma de um applet, o que possibilita que remotamente se façam modificações em bitstreams previamente colocados na máquina servidora.
Em o applet o usuário deve informar o endereço IP da máquina onde está sendo rodado o lado servidor da aplicação, bem como a porta que está aceitando conexões.
O usuário também precisa conhecer previamente o caminho e o nome do arquivo de configuração que deseja alterar no servidor.
O usuário não precisa saber qual é o dispositivo-alvo da aplicação, pois essa informação é resgatada do próprio bitstream lido.
O exemplo da Figura 5.3 é baseado na aplicação descrita no item 5.3.2 deste documento.
Esta Figura mostra, no retângulo central (com fundo branco), um relatório das ações realizadas na experiência.
Primeiramente foram listados todos bitstreams disponíveis na máquina servidora (não aparecem todos porque houve uma rolagem na tela em função de o espaço).
Em seguida foram lidos os valores armazenados nas LUTs F de coordenadas R18 C5R1 C1_ S0, R19 C5R1 C1_ S0, e R20 C5R1 C1_ S0 (o formato des76 sas coordenadas foi explicado no item 4.2.3).
Tais LUTs foram escolhidas dadas as características da aplicação (as mesmas explicitadas na Tabela 5.3 -- Em a Seção seguinte).
Em seguida foi alterado o bit 14 da F-LUT de coordenada R19 C5R1 C1_ S0.
Logo após o bitstream foi salvo e foi realizado o download remoto.
O dispositivo foi configurado com sucesso, e a aplicação funcionou como esperado.
Uma vez obtido sucesso com a reconfiguração remota de bitstreams com a ferramenta descrita na Seção 5.1, verificou- se a possibilidade de prover reconfiguração de um circuito num nível mais alto que a manipulação de LUTs.
Uma nova ferramenta foi desenvolvida, com o objetivo de &quot;esconder «do usuário final a arquitetura do FPGA.
Devido a a complexidade na manipulação de bitstreams uma camada de software é acrescentada, de forma que a aplicação final (na forma de uma applet) mostre ao usuário apenas os parâmetros que devem ser alterados, sem que ele precise saber como e onde estão armazenados no circuito.
Determinadas aplicações em hardware podem ser flexíveis quanto a alguns parâmetros.
Por exemplo, num projeto realizado no GAPH em parceria com uma indústria de telecomunicações, foi projetado um circuito que substitui canais de uma portadora E1.
Este canal pode trabalhar com dados de E/ S codificados de duas formas diferentes (HDB3 ou AMI).
Além de a codificação, há a definição de quantos e quais canais serão substituídos, o endereço inicial dos canais a substituir, e a transmissão ou não do canal de serviço.
Todos esses parâmetros podem ser alterados remotamente, utilizando- se recursos da ferramenta descrita na Seção 5.1.
A Figura 5.4 ilustra os comandos para gerar o applet de configuração de uma determinada aplicação.
Os quatro primeiros parâmetros dentro de a tag «informam o número de sinais passíveis de alteração, o nome do bitstream, o endereço IP do servidor e a porta de conexão.
Os parâmetros seguintes informam os sinais que podem ser alterados.
Por exemplo, o sinal &quot;code «definirá se o circuito trabalhará com codificação AMI ou HDB3.
Note- se ainda nesta Figura, que o formato dos parâmetros que o usuário enxerga pode ter a base numérica especificada.
Em este exemplo existem parâmetros em hexadecimal e binário, mas pode haver sinais exibidos em decimal.
Em a próxima versão da ferramenta, contudo, algumas informações serão exibidas de forma ainda mais abstrata.
Por exemplo, ao invés de escolher entre 0 ou 1 no campo para especificar a codificação, será fornecida ao usuário uma list
Box com as opções textuais AMI e HDB3.
Para cada parâmetro é possível definir as coordenadas da LUT onde se encontra (linha, coluna, fatia e LUT F ou G), se o valor que está sendo trabalhado está em hexadecimal ou binário, o bit inicial e o bit final que se deseja alterar.
Excetuando- se estas informações de arquitetura, o projetista do hardware não precisa ter nenhum conhecimento a respeito de o endereçamento de elementos do FPGA.
E o usuário do sistema, por sua vez, não precisa saber sequer com qual FPGA está trabalhando:
Basta conhecer a funcionalidade do seu circuito.
Uma vez editada a página html, ela é utilizada para reconfiguração e download.
A Figura 5.5 mostra a aplicação tal qual o usuário do circuito a enxergará.
Em a applet de reconfiguração tem- se basicamente os parâmetros a inserir, o formato dos parâmetros, a leitura do bitstream original e o download do bitstream modificado.
A Figura 5.5 mostra a aplicação tal qual o usuário do circuito a enxergará.
Em a applet de reconfiguração tem- se basicamente os parâmetros a inserir, o formato dos parâmetros e a leitura do bitstream original e o download do bitstream modificado.
Fica claro que o usuário não precisa saber detalhes estruturais do FPGA com o qual está trabalhando:
Basta conhecer a funcionalidade do seu circuito.
Em este processo evidenciam- se três atores:
O desenvolvedor do software, o projetista do circuito, e o usuário do sistema.
O desenvolvedor do programa vai implementar uma camada de software para esconder detalhes arquiteturais do usuário do circuito e do projetista do hardware.
O programador deve conhecer o funcionamento das classes JBits -- como acessar e alterar informações do bitstream, bem como o posicionamento dos parâmetros a serem reconfigurado.
Esta etapa realiza- se uma única vez, incorporando o conhecimento adquirido no desenvolvimento da ferramenta da seção 5.1.
O projetista de hardware realiza seu projeto em VHDL conhecendo apenas o posicionamento dos elementos de memória.
Então cria uma página html para possibilitar a reconfiguração do circuito.
Já o usuário do circuito não precisa sequer saber em qual família de FPGAs seu sistema foi implementado.
Ou seja, não há necessidade que ele tenha noção nem de VHDL, nem de JBits.
O usuário só deve conhecer a funcionalidade do seu circuito e os parâmetros que deve alterar.
Através de um applet disponibilizado através de uma página na internet ele altera esses parâmetros e reconfigura seu sistema de forma transparente.
A reconfiguração parcial é o primeiro passo para a &quot;virtualização «do hardware.
Este termo significa que módulos de hardware podem ser alternadamente inseridos e removidos de um FPGA em operação, exatamente como ocorre com sistemas de memória virtual.
Para isto é necessário que o dispositivo FPGA permita reconfiguração parcial e dinâmica.
Em o sentido de prover um mecanismo para manipulação de arquivos de configuração para FPGAs da família Virtex, desenvolvemos uma aplicação escrita em Java, mas sem a utilização das classes JBits.
Baseada no estudo minucioso da arquitetura interna de FPGAs da família Virtex (item 4.2.3), e de seu arquivo de configuração, essa ferramenta realiza as mesmas operações citadas na Seção 5.1, além de gerar um bitstream parcial.
A entrada básica do programa é um arquivo de configuração completo, e um arquivo-texto contendo os parâmetros do protocolo para geração de um bitstream parcial, caso seja necessário.
Como nesta ferramenta se está trabalhando com bitstreams no formato rawbits (arquivo no formato ASCII, com extensão».
Rbt&quot;) ao invés de o formato binário (com extensão».
Bit&quot;), a abertura do arquivo de configuração completo pode ser um pouco lenta.
Isto se dá porque as informações do arquivo de configuração são trazidas todas de uma vez para memória, e são tratadas como uma grande matriz bidimensional.
Esta estrutura foi escolhida por representar diretamente a forma com que as informações são tratadas, conforme exposto na Seção 4.2.
Ou seja, o programa manipula uma matriz de tantas colunas quantos forem os bits que compõem uma palavra do dispositivo, e tantas linhas quantas forem necessárias para a configuração do dispositivo, levando- se em consideração protocolos de inicialização, sincronização, escrita da lógica, escrita em memória, CRC e comandos de finalização da configuração.
A Figura 5.6 mostra a interface dessa ferramenta.
Em o retângulo maior, o usuário visualiza o conteúdo de um arquivo de configuração.
A área retangular na parte inferior direita da Figura 5.6 mostra as opções para localização de elementos dentro de o bitstream.
É possível realizar a busca por um bit específico informando- se LUT, Fatia, Linha e Coluna desejados.
Então o bit correspondente é destacado na tela à esquerda, onde este bit pode ser alterado.
Também é possível visualizar todos os bits de uma LUT, todos os bits de uma linha e todos os bits de uma coluna.
Depois da alteração seja de algum bit de informação, ou de um bit de algum registrador de comando, quando for efetuada a ação de &quot;Salvar «o arquivo, o CRC é recalculado e gravado no registrador apropriado.
Caso seja acionada a opção &quot;Salvar Parcial», um bitstream parcial é gerado, conforme os bits que foram alterados e os parâmetros que foram informados no início do processo.
Tais parâmetros foram mantidos flexíveis em função de a possível necessidade de alterações que podem ocorrer, uma vez que não foi ainda possível realizar um download de bitstream parcial que reconfigurasse com sucesso o FPGA.
Por isso foi criado um arquivo que define os parâmetros de inicialização de um bitstream parcial, chamado de &quot;prototipoparcial_ Txt».
Em este arquivo são colocados quatro tipos de informações:
Blocos (conforme a Figura 4.7), registradores, comandos e parâmetros de registradores.
Tais informações podem ser vistas na Tabela 5.2.
Algumas informações do cabeçalho do arquivo de configuração parcial são cópias do bitstream total.
São as linhas 1, 2 e 4 da Figura 5.7.
O campo design name (linha 3) indica o nome do arquivo do projeto que gerou este bitstream.
No caso de o arquivo de configuração ser salvo com outro nome, esta linha é modificada para o nome do arquivo salvo.
A família de dispositivos para o qual este bitstream foi gerado é indicada na linha 4 (neste exemplo, a família de FPGAs é a Virtex).
O campo part (linha 5) indica o dispositivo para o qual este bistream foi gerado (neste exemplo é o FPGA Virtex XCV300).
O campo date (linha 6) é captado no momento em que a janela do bitstream parcial é aberta, e ao salvar o arquivo ela é atualizada.
O campo bits (linha 7) refere- se ao número de bits que este arquivo de configuração parcial contém.
As linhas seguintes trazem as palavras de sincronização com o dispositivo (dummyword e syncword).
Figura 5.7: Detalhamento do cabeçalho do arquivo de configuração parcial.
A partir de a linha 10 do arquivo de configuração é que o protocolo de reconfiguração parcial é realizado.
A lógica deste protocolo reside em manter a configuração pré-existente no dispositivo, permitindo que apenas os quadros onde ocorreram modificações sejam carregados no dispositivo.
Isto se dá através da seqüência de shutdown, que podem ser vistas na Figura 5.8.
A linha 11 determina um reset no registrador de CRC.
Em seguida é ativado o registrador Cor, e em ele são escritas informações que modificam exatamente o bit de shutdown.
Uma escrita no registrador CMD inicializa o protocolo.
Um primeiro cálculo de CRC é realizado para garantir que as informações até este ponto estão corretas, e novamente o registrador de CRC é resetado.
O sinal GHIGH_ B é setado, para evitar contenção no momento da escrita dos novos dados.
Ou seja, para garantir que não haverá conflito de informações previamente configuradas, todas as saídas de CLBs e sinais que serão afetados por a reconfiguração são colocados em '1' (um).
O registrador seguinte (Cor) informa que a seqüência de shutdown terminou.
Então o registrador Far informa a partir de que coordenada (linha, coluna, LUT e fatia) será realizada a reconfiguração.
A seqüência então é semelhante ao protocolo de configuração de um bitstream completo.
Há a escrita de uma palavra de configuração no registrador de comando (wcfg -- linhas 26 e 27) e então o registrador FDRI informa quantas palavras serão escritas.
Como neste exemplo foi alterado o bit 14, da linha 1, coluna 2, LUT F da fatia 0, apenas um quadro será escrito.
Ainda conforme o exemplo, por tratar- se de um FPGA Virtex XCV300, um quadro é composto por 21 palavras portanto, o registrador FDRI informa a escrita de 21 palavras.
O registrador Far é o responsável por informar as coordenadas do primeiro quadro da seqüência a ser reconfigurada.
Em a linha 25, coluna &quot;significado «da Figura 5.8, os valores indicam que a seqüência de quadros a serem reconfigurados inicia- se na linha 1, coluna 2, e trata- se de uma F LUT na fatia 0, e passa por o bit 14.
Já os 5 bits menos significativos da linha do registrador FDRI -- informam que serão escritas 21 palavras.
Logo depois da escrita das 21 palavras, há uma verificação de CRC e a escrita de um quadro de preenchimento.
A isto segue- se uma escrita no registrador CTL que informa que a interface da configuração deve permanecer após a reconfiguração.
Finalmente outra verificação de CRC ocorre e a escrita de 4 palavras de preenchimento termina o arquivo de configuração.
O valor armazenado na F-LUT, da CLB localizada na linha 20, coluna 5 funciona como RESET do circuito;
O valor armazenado na F-LUT, da CLB localizada na linha 19, coluna 5 funciona como Clock Enable para o contador;
O valor armazenado na F-LUT, da CLB localizada na linha 19, coluna 5 define se contador será incremental ou decremental.
Os valores são mostrados nos 3 leds menos significativos, enquanto o resultado da contagem é mostrado nos 4 leds mais significativos.
O led 3 deve permanecer apagado.
A Tabela 5.3 mostra os efeitos de modificações nos bits referidos acima.
O estado inicial (sem modificação dos bits em questão) é o de contagem congelada (todos bits relevantes em 1).
Tabela 5.3: Bits configuráveis do contador e seus respectivos efeitos.
Função: I/ D CKE RST Efeito Reset Congela Incrementa Decrementa Com o domínio do endereçamento de elementos internos ao FPGA (LUTs), localizar e modificar tais bits não foi problemático.
Em uma experiência inicial foram localizados os bits que interessavam e foram modificados de forma que o contador fosse incremental.
Foi gerado um arquivo de configuração total e realizado o download na placa.
A configuração foi bem sucedida e o a aplicação comportou- se conforme previsto.
A tentativa seguinte foi gerar um arquivo de configuração parcial.
As primeiras experiências foram realizadas com um protocolo de configuração parcial que estava em conformidade com o que está descrito na documentação do fabricante do dispositivo.
Contudo, quando de as tentativas de realizar download para a placa de prototipação, ocorriam erros de INIT e DONE, sinais retornados da placa de prototipação para a aplicação que realiza o download (HardwareDebugger).
De isto denota- se que o protocolo de configuração parcial estava errado.
Estudou- se, então, mais detalhadamente o protocolo de configuração parcial e realizaram- se alguns testes, até que se chegou no protocolo descrito no item 5.3.1.
Com este protocolo foi possível gerar um arquivo de configuração parcial de tal forma que o download fosse bem sucedido, ou seja, não houveram mais erros de INIT e DONE.
Como efeito co-lateral, criou- se a ferramenta para reconfiguração parcial de forma flexível o bastante para que o protocolo de reconfiguração parcial seja modificado facilmente.
Notou- se, nessas experiências, que o tempo de download do bitstream parcial foi bastante baixo, em relação a o bitstream completo.
Enquanto para este último o tempo ficou em torno de 35 segundos, para o primeiro foi de 0,17 segundo, para um quadro modificado.
Isto se dá porque o tempo de configuração é diretamente proporcional à quantidade de bits de configuração que é enviada à placa.
Contudo, apesar de o download ter ocorrido, o dispositivo não foi reconfigurado.
Tal problema deve- se à ferramenta de download, que envia sinais à placa de prototipação que coloca o FPGA num estado de reset -- ou seja, eliminando a configuração anterior antes de configurar com o novo bitstream.
O fabricante do software em questão informou que nova versão está sendo desenvolvida, e que tal problema será eliminado nesta versão.
Infelizmente a nova ferramenta não ficou pronta antes da escrita deste volume.
Partindo do domínio do endereçamento de elementos em FPGAs da família Virtex, em conjunto com o conhecimento adquirido no desenvolvimento da ferramenta descrita na Seção 5.3, definiu- se a criação de um software para manipulação de cores.
Essa nova ferramenta deveria possuir as seguintes características:
Para geração de um terceiro arquivo de configuração;
Assim como a ferramenta anterior, o unificador de cores foi programado em Java, sem o auxílio do JBits.
Sua interface gráfica é semelhante à da ferramenta BoardScope (da Xilinx) a fim de ser facilmente compreendida por o usuário.
Essa interface pode ser vista na Figura 5.9, que também mostra uma funcionalidade interessante da ferramenta.
O arquivo de configuração utilizado no exemplo é exibido de forma visual.
Em esse caso, o bitstream foi gerado para um FPGA XCV300.
Por isto, a Figura 5.9 mostra 32 quadrados em cada coluna e 48 quadrados em cada linha.
Ou seja, cada quadrado representa um CLB para este dspositivo.
Quadrados cinza-claros e cinza-chumbo representam que as respectivas LUTs permanecem com seus valores originais inalterados.
Quadrados em contornados com branco mostram onde está implementada a lógica da aplicação.
Outra funcionalidade da ferramenta é a exibição dos valores contidos em cada CLB.
Para tanto basta arrastar o mouse sobre a CLB que se deseja saber o valor.
Então esse valor é mostrado numa janela auxiliar da aplicação, conforme a Figura 5.10.
A ferramenta ainda apresenta a opção de download, que chama o software HardwareDebugger para realizar a configuração do dispositivo.
Esta ferramenta é fundamental para validação da idéia de uma interface para conexão de cores.
Ou seja, será utilizada para realizar a inserção e remoção de cores que conectarão- se- através de uma interface.
Esta interface proverá a comunicação entre os cores e de eles com o mundo externo.
A proposta desta interface é feita na Seção 5.5.
Já a validação desta ferramenta é mostrada no item a seguir.
Uma segunda experiência foi proposta, mas ainda não está operacional.
Trata- se de reconfigurar cores de modo a garantir o roteamento entre eles.
Esta é uma necessidade quando se pretende que os cores envolvidos comuniquem- se entre si.
Se os cores em questão forem disjuntos, ou seja, se possuírem apenas comunicação com o mundo externo e não um com o outro, não há problema de roteamento, nem sequer há necessidade de um barramento para prover a conexão entre eles.
Mas também não faz sentido, no contexto deste trabalho, uma aplicação implementada desta forma.
Contudo, pretende-se exatamente que seja possível reconfigurar o FPGA parcialmente para inserir ou remover cores que tenham interdependências ou que de alguma forma necessitem comunicar- se.
Mesmo que o barramento em questão ainda seja apenas uma proposta, é possível vislumbrar uma forma de conectar cores a ele, conforme é explanado no item a seguir.
Enquanto o protótipo de barramento de interconexão de cores para FPGAs está sendo desenvolvido por outro membro do GAPH, este trabalho propõe um método para interconexão entre um core de aplicação e esse barramento.
De a Figura 5.13 pode ser abstraída esta idéia.
Em a Figura armazenados em memória para utilização posterior.
Repete- se a operação com um segundo módulo, correspondente à uma interface para conexão de cores.
É realizada uma concatenação dos dois, gerando um terceiro bitstram completo.
O download do bitstream gerado foi parcialmente bem sucedido.
O bitstream configurou a placa, o core do barramento apresentou o comportamento esperado, mas o core da aplicação não comunicouse com o barramento.
Verificou- se então que a ferramenta para unificação de cores não garante que o roteamento seja mantido.
Novas experiências estão sendo feitas, com a utilização de dummy cores, mas até o fechamento deste volume não havia sido obtido sucesso.
A computação reconfigurável será uma realidade somente quando houver uma certa independência da aplicação em relação a o dispositivo para a qual foi projetada.
Tal independência pode ser entendida como a possibilidade da aplicação ser executada em dispositivos configuráveis compatíveis, mesmo que estes possuam mais (ou menos) recursos computacionais do que o dispositivo para o qual a aplicação foi inicialmente escrita.
Ou seja, é preciso que ocorra a virtualização do hardware para que seja obtida a sobrevivência da aplicação.
Passos importantes estão sendo dados com esse objetivo, mas há uma lacuna ainda não preenchida nesse caminho.
A computação reconfigurável pressupõe virtualização do hardware.
Lógica programável baseada em SRAM;
Disposição regular dos recursos de lógica programável;
Possibilidade de reconfiguração dinâmica;
Microprocessador, memória e lógica programável no mesmo circuito integrado;
Um barramento que permita a inserção/ remoção de cores sem que seja interrompida a comunicação de cores pré-existentes entre si e com o mundo externo.
O último item é a lacuna a ser preenchida aqui.
A idéia é prover uma maneira de diminuir os problemas de integração em SoCs, aumentando a portabilidade e disponibilidade de cores, o que resulta numa aceleração no tempo para um determinado produto chegar ao mercado.
O que se encontra até agora é uma dificuldade na integração de cores por não haver uma padronização nos esquemas de interconexão.
Isto requer a criação de lógica de cola para conectar cada parte dos cores envolvidos entre si e com o mundo externo.
Fica evidente que a existência de um barramento de interconexão de cores possibilitaria sua integração de forma mais simples e rápida.
Analogamente, essa interface pode ser comparada a um barramento de um microcomputador, tal como o barramento Em este sentido, este trabalho propõe um método para prover esse barramento num FPGA comercial, cuja arquitetura não previu tal necessidade.
Em a Seção 2.6 foram analisadas propostas de barramentos semelhantes, mas que foram idealizadas para ASICs.
Em o item 5.5.1 é apresentada nossa proposta.
O processo de inserção ou remoção de cores do FPGA é especialmente prejudicado em função de problemas relacionados com roteamento e conflitos de entrada e saída.
Fica claro que os dispositivos da família Virtex não foram projetados com recursos previamente estabelecidos que facilitassem esse processo.
Em vista de essa necessidade, caso pretenda- se utilizar o FPGA com essa finalidade, é imprescindível estabelecer uma forma de comunicação entre cores e dos cores com o mundo externo.
Isto pode ser possível com o projeto de um core que atue como um árbitro entre os cores de aplicações.
Tal módulo, chamado a partir de agora de &quot;barramento «é configurado no dispositivo e em ele permanece de forma estática.
Esse barramento é composto por duas partes.
A primeira é o controlador tem por função prover conexão com os pinos de entrada e saída do dispositivo.
Os demais cores que forem configurados no dispositivo comunicarse-ão somente com o controlador.
Desta forma, tem- se uma entrada e saída virtualizada, tornando possível a inserção e remoção de cores como se inserem ou removem páginas num sistema de memória virtual.
A segunda parte do barramento é um cPara que seja factível uma reconfiguração parcial, além de o domínio da escrita nos registradores de um FPGA, faz- se necessária a possibilidade de localizar determinados bits no arquivo de configuração.
A tarefa a princípio é árdua, pois que somadas todas as palavras de um bitstream (conforme a Figura 4.7) e multiplicadas por sua largura em bits (32), tem- se que localizar um bit de entre 1.750.560 bits!
ircuito que atua como árbitro.
Tem por objetivos gerenciar o aceite ou rejeição de conexões de novos cores, bem como controlar possíveis conflitos relativos aos acessos aos pinos e entrada/ saída do dispositivo.
Quando um determinado módulo de aplicação deseja comunicar- se com outro, ou com o mundo externo, envia um pedido de requisição ao árbitro.
Se a linha de comunicação (ou de acesso ao pino de entrada/ saída) requisitada está disponível, o árbitro permite que o core utilize o recurso solicitado.
Caso contrário, o core permanece num estado de espera até que o árbitro permita que acesse o recurso.
Ainda na Figura 5.14 percebe- se que tanto o árbitro quanto o controlador são posicionados de forma vertical.
Isto deve- se às seguintes considerações:
FPGAs da família Virtex possuem estrutura interna em colunas de CLBs;
CLBs são cortadas verticalmente por quadros;
Um quadro é a unidade atômica de reconfiguração;
Os módulos em questão devem permanecer no dispositivo de forma estática.
Em resumo, se o controlador e/ ou o barramento fossem em parte posicionados nas mesmas colunas que os cores de aplicações, quando estes fossem reconfigurados, fatalmente todo o FPGA teria que parar sua execução, pois o funcionamento barramento seria interrompido.
Embora não seja escopo deste trabalho o projeto desse circuito, toda pesquisa aqui realizada serviu como base para que experimentos com o barramento fosse viável.
Este trabalho propôs- se a investigar reconfiguração parcial, remota e dinâmica de FPGAs comercialmente disponíveis.
A contribuição para o estado-da-arte em computação reconfigurável ocorre em três diferentes aspectos:
Apresenta uma revisão do estado- da arte em sistemas digitais reconfiguráveis;
Realiza um estudo aprofundado da organização interna dos FPGAs da família Virtex;
Mostra um conjunto de ferramentas desenvolvidas durante esta pesquisa que se destinam a auxiliar na reconfiguração parcial e remota de FPGAs.
A primeira contribuição classifica SDRs segundo uma série de critérios, e identifica uma tendências em computação configurável.
A segunda contribuição é o estudo aprofundado dos FGPAs Virtex, que possibilita o endereçamento componentes no FPGA, bem como o entendimento de seu protocolo de configuração.
Como conseqüência, é possível a terceira contribuição deste trabalho.
As ferramentas produzidas no âmbito desta pesquisa permitem tanto manipular individualmente bits armazenados em LUTRAMs, quanto tornam possível a reconfiguração de cores.
Em vista de o que foi pesquisado e experimentado, a reconfiguração remota não só é factivel de ser implementanta, como tem aplicação industrial imediata.
E apesar de isto não está sendo ainda comercialmente explorada.
Quando de a pesquisa sobre o endereçamento de elementos, trabalhou- se com a modificação do comportamento de um circuito em função de bits armazenados em LUTRAM.
Esse tipo de reconfiguração, ainda que completa, local ou remota, ajuda a reduzir o custo do sistema, pois reduz em muito o hardware de controle do circuito.
A reconfiguração de parâmetros, de forma parcial, apresenta sobre a experiência acima a vantagem de tempo, pois é muito mais rápida.
Esta reconfiguração parcial não foi totalmente validada, por causa de problemas já descritos.
A despeito deste contratempo, gerou- se o bitstream parcial de forma correta.
Outra conclusão a que se chega é que os FPGAs Virtex podem ser parcialmente reconfigurados, porém não existe suporte algum para tal característica.
Ainda que disponibilizem uma biblioteca de classes em Java para manipular o bitstream de seus dispositivos, essa biblioteca não está suficientemente madura e é mal documentada.
Percebeu- se claramente que o fabricante não explorou esta característica devido a as dificuldades de desenvolver o CAD para tal suporte à reconfiguração parcial.
Mesmo que academicamente a idéia de reconfiguração dinâmica seja amplamente investigada, nota- se que a indústria investe pouco nesta tecnologia.
Isto provavelmente se dê por não terem surgido ainda aplicações comerciais em grande escala que necessitem dessa característica.
Outro motivo possível é a dificuldade de desenvolver CAD para reconfiguração dinâmica e para roteamento.
Saliente- se que FPGAs mais antigos contemplavam essa característica, mas foram descontinuados por não terem sido desenvolvidas ferramentas eficientes para auxiliar na sua utilização.
Ainda que a reconfiguração parcial de parâmetros de hardware seja interessante, a reconfiguração de cores só será realmente útil se for possível conectar cores diretamamente usando barramentos internos aos FPGAs.
A o conhecimento do autor deste texto, tais barramentos ainda não existem, e seu desenvolvimento é bastante problemático conforme ficou comprovado por trabalho de Dissertação complementar a este Em suma:
Reconfiguração completa remota funciona e CAD é simples de desenvolver;
Reconfiguração de parâmetros completa/ parcial, local/ remota, é também factível de se implementar;
Reconfiguração parcial de parte do circuito é difícil com os atuais FPGAs, pois necessita de CAD para projeto e barramento interno para interconexão de cores.
Ainda, com base nas tendências observadas, FPGAs de grão mais grosso (ULAs, processadores) com reconfiguração parcial em nível de instruções (parâmetros) são uma alternativa interessante para aplicações como multimídia e telecomunicações.
A idéia é que haja uma rede de elementos de processamento com conexão/ funcionalidade definidas por instruções configuradas em RAM.
O conjunto de ferramentas desenvolvidas pode ser integrado de duas formas distintas nos atuais sistemas de CAD.
A primeira utilização é na forma de uma ferramenta que é fornecida ao usuário, juntamente com o arquivo de configuração.
Esta forma de utilização permite que o usuário personalize seu circuito, sem a necessidade de ferramentas de síntese.
A segunda forma de aplicação é sua integração a ferramentas de projeto conjunto de hardware e software.
A idéia é permitir que os módulos de hardware obtidos por as metodologias de codesign sejam alocados sob demanda no dispositivo programável.
Hoje, a capacidade do dispositivo programável deve ser suficiente para conter todos os módulos de hardware.
De a forma proposta, teremos uma abordagem de &quot;hardware dinâmico», da mesma forma que temos &quot;memória virtual «para software.
Segundo um dos autores do JBits é possível realizar o download parcial numa placa de prototipação não disponível em nossos laboratórios.
Portanto, um dos trabalhos futuros seria testar a reconfiguração parcial numa placa do fabricante Celoxica.
Em conseguindo- se a reconfiguração parcial, o trabalho seguinte seria a realização de experimentos com reconfiguração dinâmica.
Outra investigação interessante seria avaliar FPGAs de outros fabricantes que dizem suportar reconfiguração dinâmica.
O FIPSoC (da Sidsa) é uma alternativa, mas o FPSLIC (da ATMEL) parece ser uma opção mais madura, já acompanhada de algumas ferramentas de CAD.
Finalmente, a proposta de barramento para interconexão de cores deve ser revista e ampliada.
Um estudo mais aprofundado de iniciativas de barramentos como o Wishbone e o CoreConnect, juntamente com análise de características de dispositivos SoCs, poderiam gerar a proposta de um novo tipo de dispositivo reconfigurável que incorporasse esse barramento.
