Toda vez que um agente de software adquire conhecimento por a experiência ou por a absorção de novos conceitos é necessário controlar quais são os conhecimentos que o agente domina, ou seja, é necessário gerir seu conhecimento.
Sabendo- se que um processo de Gestão de Conhecimento serve como um controlador dos recursos de conhecimento de uma organização, auxiliando a encontrar, organizar e compartilhar o conhecimento, o presente trabalho utilizou- se das partes deste processo para desenvolver um framework para a organização do conhecimento de agentes de software, onde o conhecimento é estruturado por meio de ontologias.
O framework proposto permite aos agentes capturar conhecimento para a execução de suas tarefas e também compartilhar o conhecimento disponível para que ele possa ser reusado por outros agentes do sistema.
O entendimento e uso de ontologias e motores de inferência são características fundamentais em aplicações que objetivam utilizar o framework proposto, pois, além de estruturar o conhecimento disponível, ontologias são utilizadas na representação do conteúdo de mensagens e dos objetivos dos agentes.
Palavras-chave: Agentes de software.
Gestão de Conhecimento. Sistemas Multiagentes.
Ontologias. O desenvolvimento de agentes inteligentes de software se confunde com a própria busca de tecnologias inteligentes por os pesquisadores de Inteligência Artificial.
A idéia de se criar um software inteligente, capaz de pensar de forma similar a um ser humano, sempre atraiu inúmeros pesquisadores.
A analogia com a capacidade dos seres humanos de pensar, norteou a busca por entidades de software capazes de imitar o comportamento humano.
Um agente de software, segundo Weiss, pode ser definido como um sistema de computador situado num ambiente e capaz de agir de forma autônoma para atingir um objetivo, onde a autonomia refere- se à capacidade de agir de acordo com sua própria linha de controle.
Para a construção de sistemas complexos, geralmente são utilizados vários agentes que desempenham tarefas voltadas ao alcance de seus objetivos especializados (objetivos locais) e que estão de acordo com os objetivos globais do sistema.
Um sistema que possui vários agentes atuando num ambiente é denominado sistema multiagentes ou SMA.
O desenvolvimento de SMAs é uma área em franca expansão devido a a sua adaptação à resolução de problemas distribuídos.
Existem, atualmente, diversas plataformas disponíveis que auxiliam na criação de aplicações do tipo SMA, como Jade, OpenCybele e MadKit.
Além de os requisitos como infra-estrutura de comunicação e administração de agentes, que são básicos para uma plataforma que objetiva auxiliar na construção deste tipo de sistema, há outros requisitos também fundamentais.
Este é o caso das formas de representação de conhecimento, que permitem a troca estruturada de conhecimento entre os agentes de software.
De acordo com Obitko e Marik, ontologias executam um importante papel no compartilhamento e exploração de conhecimento.
As ontologias estabelecem uma terminologia comum usada tanto por humanos quanto por agentes de software para o entendimento dos conceitos de um domínio.
De entre as várias definições para o termo ontologia existentes na literatura, a mais citada é a oferecida por Gruber:
&quot;Uma ontologia é uma especificação explícita de uma conceituação».
Sendo um agente uma entidade de software que possui, em tese, a capacidade de aprender ou, em outras palavras, a capacidade de adquirir conhecimento através de experiência, por a absorção de novos conceitos ou por a reação a mudanças no ambiente, torna- se necessário o uso de mecanismos ou processos para controlar o conhecimento que o agente domina.
A Gestão de Conhecimento (GC) refere- se à criação, identificação, integração, recuperação, compartilhamento e utilização do conhecimento dentro de o ambiente organizacional.
Em a prática, GC compreende a identificação e o mapeamento dos recursos intelectuais da organização, gerando conhecimento novo, melhorando a competitividade e tornando uma vasta quantidade de informações acessíveis.
Sabendo- se que um processo de GC serve como um controlador dos recursos de conhecimento de uma organização, auxiliando a encontrar, organizar e compartilhar o conhecimento e, considerando- se um SMA como uma organização de agentes, no presente trabalho será apresentado o desenvolvimento de um framework para a organização do conhecimento de agentes de software, com o uso de ontologias e técnicas de GC.
Em a literatura foram encontrados vários modelos conceituais de arquiteturas de software para GC corporativa, como as apresentadas em e, que têm como objetivo expandir o alcance e potencializar a velocidade da transferência do conhecimento.
Porém, não foram encontradas arquiteturas que utilizam, de forma completa e integrada, um processo de GC com o objetivo de gerir o conhecimento interno do sistema, fato que é a motivação deste trabalho.
Em este contexto, o framework proposto tem como principal objetivo permitir à agentes de diferentes arquiteturas internas formalizarem o conhecimento adquirido durante a execução de suas tarefas e também transmitir esse conhecimento para que ele possa ser reusado.
A arquitetura conta com procedimentos para o mapeamento de atividades comumente encontradas num processo de GC, como as atividades criar, organizar, armazenar, distribuir, capturar e aplicar conhecimento.
A representação do conhecimento e o entendimento de ontologias são características fundamentais em aplicações que objetivam usar o framework proposto.
Em o framework, tanto o formato para representação do conteúdo de mensagens, quanto o mecanismo de tomada de decisão remetem ao uso de ontologias e motores de inferência.
Para a representação de ontologias, optou- se por a linguagem OWL Dl, que é baseada em XML e RDF e utiliza lógica descritiva para a explicitação de conhecimento.
Como o framework proposto não objetiva servir de base para a construção de SMAs, mas sim agregar uma nova funcionalidade a agentes de software, torna- se necessária a sua integração em plataformas de desenvolvimento de SMAs.
Para tanto, deve ser feito o mapeamento entre os elementos contidos no framework e os elementos da arquitetura interna dos agentes da plataforma de desenvolvimento selecionada.
Em este trabalho, será mostrado o mapeamento sobre o Jade, que é uma plataforma para desenvolvimento de SMAs, e sobre o SemantiCore, que é um framework que provê uma definição interna de agente capaz de oferecer aos desenvolvedores uma abstração de alto nível para a construção de SMAs para a Web Semântica.
Para demonstrar a viabilidade da arquitetura, depois de sua instanciação sobre o SemantiCore, foi desenvolvida uma aplicação tendo- se como base o exemplo apresentado em.
Em este exemplo, há dois agentes, Lucy e Pete, que precisam agendar sessões de fisioterapia para a mãe.
Esta aplicação permite a avaliação da arquitetura em termos de sua funcionalidade e abragência com relação a a solução do problema proposto.
Considerando- se um SMA como uma organização que tende a se beneficiar com a coleta e classificação do conhecimento disponível entre seus membros e um agente de software como uma entidade que necessita explicitar seu conhecimento para se comunicar de maneira eficiente, parte- se para a análise da adoção de um processo de Gestão de Conhecimento em sociedades de agentes.
Em este sentido, emerge a questão de pesquisa deste estudo:
&quot;Como organizar o conhecimento de agentes de software de forma a permitir a recuperação e troca de conhecimento?».
Uma vez definida a questão de pesquisa, definiu- se o objetivo geral e os objetivos específicos deste trabalho, os quais são apresentados a seguir.
Propor e aplicar sobre uma plataforma de desenvolvimento de SMAs, um modelo de arquitetura de software que possibilite, através de técnicas de representação de conhecimento e ontologias, a organização do conhecimento disponível em agentes de software.
Aprofundar o estudo teórico sobre trabalhos relacionados ao problema abordado.
Identificar responsabilidades e ações referentes às atividades de um processo de GC numa arquitetura de agentes.
Definir o que é um objeto de conhecimento e modelar- lo no escopo do trabalho proposto.
Propor um modelo de arquitetura de software para Gestão de Conhecimento.
Mapear e implementar as primitivas do modelo proposto.
Aplicar o modelo proposto sobre o SemantiCore.
Projetar e implementar uma aplicação que possibilite o uso do modelo proposto.
Este trabalho está dividido em três partes:
Fundamentação teórica, proposta da arquitetura e caso de validação.
O Capítulo 2 apresenta a fundamentação teórica necessária para um bom entendimento do trabalho, onde são esclarecidos aspectos de agentes de software, GC e seus processos associados, Web Semântica e ontologias.
Em o Capítulo 3 são apresentados alguns trabalhos encontrados na literatura que estão relacionados à organização do conhecimento de agentes de software.
Durante a apresentação dos trabalhos, vários aspectos do framework proposto são salientados, auxiliando na identificação das contribuições desta dissertação.
Em o Capítulo 4 é descrito o modelo conceitual do framework proposto e o seu mapeamento sobre as plataformas Jade e SemantiCore.
Além disso, discorre- se sobre a aplicação de um processo de GC numa arquitetura de agentes.
Já no Capítulo 5 são apresentadas as diretrizes de implementação do framework, indicando as técnicas utilizadas para a construção de seus elementos.
Para um bom entendimento da arquitetura proposta e dos trabalhos relacionados é necessária a compreensão dos fundamentos teóricos e das tecnologias básicas em os quais a arquitetura se baseia.
Assim, nas seções 2.1 e 2.2 são apresentadas características de agentes de software e SMAs.
Como a arquitetura proposta deverá ser integrada a plataformas de desenvolvimento de SMAs, na Seção 2.3 são descritas quatro plataformas disponíveis na literatura.
Já na Seção 2.4, é esclarecido o conceito de GC e é apresentada também, uma síntese de processos de GC encontrados na literatura.
Ainda na Seção 2.4, falase do uso da técnica de raciocínio baseado em casos em GC.
O uso da Web como um meio por onde agentes navegam e fazem requisições, trocando informações com anotações semânticas, é o tema da seção 2.5, que trata de Web Semântica e ontologias.
Existe, atualmente, um grande debate sobre como conceituar exatamente um agente de software.
Entre as muitas definições usadas na literatura, cita- se a dada por Wooldridge em:
&quot;Um agente é um sistema de computador encapsulado que está situado num ambiente e que é capaz de agir de forma flexível e autônoma neste ambiente a fim de satisfazer seus objetivos».
Para entender melhor o que é um agente, é necessário entender primeiro quais são as suas características.
Muitas definições são usadas na literatura, mas algumas características permanecem em todas elas.
São estas características que serão utilizadas para conceituar um agente de software neste trabalho.
Assim, um agente é uma entidade de software que:
É autônoma ­ isto significa que, uma vez criado, um agente age de forma autônoma com relação a as outras entidades de um sistema.
Isto não quer dizer que um agente não se comunique ou coopere com outras entidades, mas que o seu fluxo de execução é independente e, mais importante, que o agente tem autonomia de atuação (onde atuação não quer dizer apenas fluxo de execução independente, mas existência de mecanismos de dedução, associação e indução).
Atua num ambiente ­ o conceito de ambiente relaciona- se fortemente a existência de vários agentes atuando num sistema e também a capacidade do agente de perceber o que acontece ao seu redor.
É inteligente ­ a inteligência deve ser entendida neste contexto como a capacidade de atuar segundo objetivos e de acordo com o conhecimento que o agente possui do seu ambiente e das suas ações.
Possui um modelo limitado do mundo ­ o seu escopo limitado deve- se à complexidade das entidades que atuam no ambiente e aos objetivos específicos de cada agente.
Com isso, um agente só possui o modelo de mundo necessário ao desempenho de suas tarefas e ao alcance de seus objetivos.
De maneira resumida, um agente é uma entidade de software que, a partir de informações sentidas no ambiente, captadas através da interação direta com outros agentes de software ou humanos, ou geradas a partir de os mecanismos dedutivos internos ao agente, atua num ambiente buscando o alcance de seus objetivos.
Lo Definem um SMA como um &quot;grupo de agentes que interagem entre si para resolver um problema ou cumprir uma tarefa numa plataforma baseada em agentes».
Algumas características de SMAs foram sumarizadas por Zhu e co-autores em.
Segundo estes autores, em SMAs:
Cada agente tem uma habilidade parcial para resolver um determinado problema;
Não há um controle global do sistema;
Dados e conhecimento para solucionar um problema são descentralizados;
E a computação é assíncrona.
Ribeiro dá a seguinte definição para SMA:
&quot;Um SMA é um sistema formado por diversos agentes que mantém alguma relação entre as suas ações e que atuam num ambiente.»
Em esta definição, o conceito de ambiente fica bastante evidente como sendo uma parte de um SMA.
O ambiente delimita o escopo de atuação dos agentes, servindo como base de informações para os sensores e como canal de saída das ações dos agentes.
Outra questão que é salientada nesta definição é a relação que deve existir entre as diferentes ações dos agentes de um SMA.
Esta restrição indica que as ações dos agentes devem estar associadas de alguma forma e que esta associação deve servir aos objetivos individuais dos agentes e ao objetivo de todo o sistema ou sociedade de agentes.
Considerando que os agentes num espaço aberto são autônomos, ou seja, que o agente pode perceber o ambiente e agir baseado nos resultados percebidos, é razoável considerar- se um SMA como uma sociedade, onde os agentes vivem e executam tarefas.
O entendimento de um SMA como uma sociedade ou organização de agentes será referenciado no decorrer deste trabalho.
Como as técnicas de Engenharia de Software possuem limitações quanto a a representação de requisitos específicos de SMAs, vêm sendo propostas algumas arquiteturas que incorporam conceitos de agência nativos em seus modelos.
Estas arquiteturas tiveram origem em esforços de consórcios de instituições de pesquisa e em empresas de grande porte, que procuram utilizar SMAs como solução de problemas distribuídos complexos.
Embora exista um avanço na criação de plataformas para a implementação de SMAs, não existe nenhuma plataforma que seja considerada como padrão para todos os domínios de aplicações existentes.
Para que uma plataforma de implementação de SMAs seja completa é preciso tanto o suporte ao desenvolvimento da parte interna dos agentes quanto o suporte à criação da infra-estrutura de atuação dos agentes em sua organização (parte externa).
De entre as plataformas disponíveis para a implementação de SMAs, como o Madkit, o Jade, o OpenCybele e o SemantiCore1, são poucas as que oferecem suporte total à sua confecção, como será mostrado a seguir, através da descrição das plataformas citadas.
Madkit O kit de ferramentas MadKit -- a Multi-Agent Development Kit -- surgiu da necessidade de fornecer uma plataforma genérica de SMAs, altamente adaptável e escalável.
O objetivo era construir uma infra-estrutura para modelos de agentes variados e fazer os serviços básicos inteiramente extensíveis e substituíveis (GUTKNECHT e Segundo Ferber, MadKit é uma plataforma multiagentes para o desenvolvimento e execução de aplicações baseadas num paradigma orientado a organização.
A plataforma MadKit é construída de acordo com o modelo Aalaadin, ilustrado na Figura 2.1, onde:
Agente: Classe que define o ciclo de vida abstrato básico.
Um agente é especificado como uma entidade de comunicação ativa que executa papéis dentro de o grupo (a arquitetura interna dos agentes não é explicitada no modelo).
A definição de agente é intencionalmente genérica para permitir que os desenvolvedores adotem a definição mais propícia para a sua aplicação.
Grupos: São definidos como conjuntos atômicos de agentes agregados.
Cada agente é parte de um ou mais grupos.
O SemantiCore será definido, ao longo de o trabalho, como uma plataforma para desenvolvimento de SMAs por auxiliar no desenvolvimento de aplicações baseadas em agentes na Web Semântica.
Papel: É uma representação abstrata de uma função, serviço ou identificação do agente dentro de um grupo.
Cada agente pode ter múltiplos papéis e cada papel executado por um agente é local no grupo.
Em adição a esses três conceitos elementares, Madkit tem três princípios para o desenvolvimento:
Arquitetura de micro-- kernel:
É um pequeno e otimizado kernel do agente que tem como função controlar grupos e agentes locais, gerenciar o ciclo de vida do agente e transmitir mensagens locais.
&quot;Agentificação «de serviços:
Em o MadKit, todos os serviços, exceto os fornecidos por o kernel, são executados por agentes.
Modelo de componente para interface gráfica:
A interface gráfica é baseada na especificação do Java Bean.
Cada agente é o único responsável por sua interface gráfica e seus aspectos, como rendering, eventos, processamento, ações, entre outros.
De maneira simplificada, os serviços do sistema são oferecidos por um agente especial, o &quot;KernelAgent», e por o grupo &quot;System».
Os agentes são separados em grupos e existe um agente especial com o papel de facilitador (&quot;Broker&quot;), que localiza os agentes na sociedade.
A comunicação ocorre por um sistema de mensagens onde podem ser enviadas tanto mensagens síncronas quanto assíncronas.
Jade (Java Agent DEvelopment Framework) é um framework de desenvolvimento de software totalmente implementado na linguagem Java.
Tem como objetivo suportar o desenvolvimento de aplicações de SMAs através de um middleware2 (que segue as especificações da FIPA -- Foundation for Intelligent Physical Agents) e de um conjunto de ferramentas gráficas que suportam as fases de desenvolvimento e verificação Jade permite o desenvolvimento de sistemas capazes de trabalhar de uma maneira pró-ativa (de acordo com regras pré-definidas), de se comunicar e negociar diretamente com outras partes do sistema e de se coordenar a fim de solucionar problemas.
De entre a lista de características do Jade, apresentada por Bellifemine e coautores em, destacam- se:
Plataforma de agentes distribuída:
O Jade pode ser dividido em vários hosts ou máquinas, desde que eles possam ser conectados via RMI (Remote Method Invocation).
Apenas uma aplicação Java e uma Java Virtual Machine é executada em cada host.
Os agentes são implementados como threads Java e são inseridos dentro de repositórios de agentes chamados de Agent Containers, que provêem todo o suporte para a execução do agente.
Interface gráfica:
Interface visual que permite gerenciar vários agentes e repositórios de agentes, inclusive remotamente.
Ferramentas de depuração:
Ferramentas que ajudam no desenvolvimento e na depuração de aplicações multiagentes baseadas em Jade.
Transporte de mensagens:
Transporte de mensagens no formato FIPAACL dentro de a mesma plataforma de agentes.
Middleware pode ser definido como uma camada de software que concentra funcionalidades tradicionalmente dispersas entre aplicações.
Ambiente de agentes complacente a FIPA:
O Jade contém um sistema gerenciador de agentes (Agent Management System), um facilitador de diretórios (Directory Facilitator) e um canal de comunicação dos agentes (Agent Communication Channel).
Todos estes componentes são automaticamente carregados quando o ambiente é iniciado.
OpenCybele é um ambiente construído em Java para controle e execução de agentes baseados em eventos, ou seja, os agentes executam de acordo com os eventos percebidos do ambiente.
É uma releitura de código aberto do CybeleTM, desenvolvida por o Intelligent Automation Incorporated3 (IAI).
Com a sua arquitetura de camadas de serviços são promovidas diversas capacidades plug-and-play de serviços, tais como tratamento de erros, gerenciamento de threads, tratamento de eventos, comunicação e migração.
Em o OpenCybele, os serviços de agentes são categorizados dentro de três tipos de camadas:
Básica, fundamental e suplementar (as camadas estão representadas graficamente na Figura 2.2).
Essa distribuição é baseada na relevância do serviço para o agente que está executando na plataforma.
As aplicações de agentes desenvolvidas com o OpenCybele interagem somente com a infra-estrutura do Cybele kernel, que depende, por sua vez, das execuções subjacentes dos serviços de infra-estrutura para executar de acordo com o paradigma baseado em agentes do Cybele.
SemantiCore O SemantiCore é estruturado como um framework para omitir ligações específicas da plataforma e para prover primitivas para a criação de aplicações organizadas num conjunto de agentes que realizam suas tarefas no ambiente Web, surgiu a partir de uma extensão na arquitetura Web Life e atualmente se encontra disponível na versão 2006 ­ SemantiCore 2006.
O framework SemantiCore é dividido em dois modelos:
O modelo do agente (SemanticAgent), responsável por as definições internas dos agentes, e o modelo do domínio semântico, responsável por a definição da composição do domínio e suas entidades administrativas.
Os dois modelos dispõem de pontos de flexibilidade (hotspots) permitindo aos desenvolvedores associar diferentes padrões, protocolos e tecnologias.
O modelo do agente possui uma estrutura orientada a componentes, onde cada componente contribui para uma parte essencial do funcionamento do agente, agregando todos os aspectos necessários a sua implementação.
Com a retirada de um ou mais componentes não relacionados ao desempenho das tarefas do agente é possível simplificar a sua arquitetura.
São quatro os componentes básicos do agente:
Sensorial: Permite que o agente recupere objetos a partir de o ambiente.
O componente sensorial armazena os diversos sensores definidos por o desenvolvedor (cada sensor captura um tipo diferente de objeto do ambiente) e também verifica se algum destes sensores deve ser ativado por o recebimento de alguma mensagem do ambiente.
Se um ou mais sensores forem ativados, os objetos são enviados para os outros componentes para processamento.
Um sensor OWL (OWLSensor) é um tipo especial de sensor já definido na plataforma que captura objetos em OWL no ambiente.
Decisório: Encapsula o mecanismo de tomada de decisão do agente.
O mecanismo decisório presente no componente é um dos pontos de flexibilidade do framework (hotspot).
Embora o mecanismo decisório seja um hotspot, o SemantiCore possui uma integração nativa com o Jena, possibilitando o uso de máquinas de inferência neste componente.
Para que a saída gerada por o componente decisório possa ser entendida, ela deve ser uma instância de uma ação (Action).
As ações mapeiam todos os possíveis comandos que um agente deve entender para trabalhar de forma apropriada.
O desenvolvedor pode definir suas próprias ações através da extensão da classe Action (hotspot) presente no framework.
Executor: Contém os planos de ação que serão executados por o agente e pode trabalhar com o mecanismo de workflow.
Efetuador: Recebe dados dos outros componentes e encapsula estes em objetos semânticos para serem transmitidos no ambiente.
Toda publicação de um objeto semântico no ambiente requer um efetuador apropriado no agente.
Para que um agente possa atuar, é necessário que ele esteja situado num ambiente.
Em o SemantiCore, este ambiente é denominado domínio semântico.
Um domínio semântico requer um domínio Web para operar.
Como ilustrado na Figura 2.3, cada domínio semântico é composto por algumas entidades administrativas, como o Controlador de Domínio (Domain Controller) e o Gerente de Ambiente (Environment Manager).
O Controlador de Domínio é responsável por registrar os agentes no ambiente, por a recepção de agentes móveis vindos de outros domínios e também por a manutenção e execução de aspectos relacionados a segurança.
O Gerente de Ambiente representa uma ponte entre o domínio semântico do SemantiCore e os domínios Web convencionais.
Para permanecerem competitivas, as organizações devem ser capazes de criar, encontrar, capturar e compartilhar o conhecimento de forma eficiente e eficaz.
Isto requer, cada vez mais, tornar explícito o conhecimento organizacional, gravando- o de forma a facilitar sua distribuição e reusabilidade.
As organizações têm de responder rápida e eficazmente às constantes mudanças e a Gestão de Conhecimento apareceu como resposta a este desafio.
Gestão de Conhecimento (GC) pode ser entendida como o gerenciamento explícito e sistemático do conhecimento vital e seus processos associados de criação, organização, difusão, uso e exploração.
De forma mais simplificada, GC é o processo de converter conhecimento vindo de fontes disponíveis para a organização e conectar pessoas com este conhecimento.
Para Stader e Macintosh, GC pode ser definida como a identificação e análise dos recursos de conhecimento disponíveis e requeridos e também dos recursos relatados em processos.
Esta definição de GC implica que é necessário para a organização:
Ser capaz de identificar e representar seus recursos de conhecimento.
Compartilhar e reusar estes recursos de conhecimento para diferentes aplicações e usuários, o que implica ter o conhecimento disponível onde ele é necessário dentro de a organização.
Criar uma cultura que encoraje o compartilhamento e reuso de conhecimento.
De a mesma forma que nas organizações empresariais, uma sociedade de agentes é constituída por indivíduos (agentes) que necessitam explicitar e compartilhar o conhecimento adquirido durante a execução de suas tarefas, criando assim uma memória organizacional.
De este modo, um SMA é visto como uma organização que tende a se beneficiar com a coleta e classificação do conhecimento disponível entre seus agentes.
Em este contexto, o desafio das organizações, de software ou não, é aprender a converter o conhecimento de seus colaboradores em conhecimento organizacional, ou seja, explicitar o conhecimento dentro de a organização.
É necessário o desenvolvimento de métodos que auxiliem as organizações a encontrar, selecionar, organizar, disseminar e transferir informações importantes.
Um processo de Gestão de Conhecimento (Knowledge Management Process) serve como um controlador dos recursos de conhecimento da organização, auxiliando a encontrar, organizar e compartilhar o conhecimento.
Ele é representado por uma seqüência de atividades através de a qual o conhecimento organizacional é conduzido, da captura até o compartilhamento propriamente dito.
O processo de GC deve ser encaixado em todo o projeto, processo, comunidade ou rede da organização.
Com o objetivo de estabelecer um processo de GC para ser usado como guia no decorrer de a pesquisa, em foi feita uma análise de propostas de processos de GC encontradas na literatura, cujos resultados estão apresentados na Tabela 2.1.
De acordo com a Tabela 2.1, a maioria das sete propostas começa com a atividade &quot;criar «ou &quot;capturar&quot;;
Apenas o modelo de Kucza inicia com a identificação do conhecimento -- atividade que não aparece em nenhuma fase dos outros modelos.
A segunda fase pertence à organização, onde o conhecimento é mapeado, refinado e encapsulado ­ novamente o modelo de Kucza diferencia- se nesta fase, pois já parte para o compartilhamento do conhecimento.
Em a fase três, são usados termos diferentes nas propostas, mas todas, exceto a de Lee e Lee, indicam algum mecanismo de armazenamento/ formalização do conhecimento.
Também, embora as propostas tragam uma nomenclatura diferente na fase quatro, quase todas implementam o compartilhamento do conhecimento na organização.
Quatro das sete propostas incluem uma quinta fase para apresentação, aplicação ou uso/ reuso de conhecimento.
Apenas a proposta de Despres e Chauvel inclui uma sexta fase que representa a evolução do conhecimento.
A última linha da Tabela 2.1 (denominada &quot;síntese&quot;) apresenta o termo que aparece com maior freqüência em cada uma das fases (muitas vezes aparecem sinônimos do termo), de acordo com as propostas de processo analisadas.
Este será o fluxo de atividades que representará um processo de GC no decorrer deste trabalho.
Raciocínio baseado em casos (RBC) é uma técnica de Ia que modela aspectos da cognição humana para resolver problemas especializados.
Sistemas de RBC imitam o ato humano de recordar um episódio prévio para resolver um determinado problema devido a forte semelhança entre eles.
Em o processo de recordar uma situação semelhante quando comparado a uma nova, sistemas de RBC simulam o raciocínio analógico (RIESBECK e O ato de relembrar um episódio anterior é simulado num sistema de RBC por meio de a comparação de um novo problema com um conjunto de casos do mesmo tipo (base de casos).
A comparação entre os casos é feita através da avaliação de similaridade entre o novo episódio com os já contidos na base de casos, sendo que somente os casos mais similares são recuperados.
Para completar o ato de relembrar, há uma fase de seleção onde é determinado qual o caso mais útil.
São quatro as etapas principais no desenvolvimento de um sistema de RBC:
Recuperar, reutilizar, revisar e reter.
Autores como Aamodt e Plaza referem- se a estas etapas como o ciclo do RBC.
A Figura 2.4 ilustra as quatro principais etapas de um sistema de RBC citadas.
Essas etapas podem ser descritas da seguinte maneira:
Recuperar: Busca de um ou mais casos de acordo com as similaridades entre a situação atual (caso de entrada) e cada um dos casos da base (casos candidatos).
Reutilizar: Utilização da informação e do conhecimento contidos nos casos recuperados (pode ser apenas um) para resolver o caso de entrada.
Revisar: Avaliação da solução proposta.
Reter: Armazenamento do caso de entrada juntamente com sua solução revisada na base de casos.
Esta etapa representa a característica de aprendizagem de um sistema RBC.
Em a literatura, RBC tem sido apontado como um método apropriado para suportar GC e seus processos.
As principais razões para esta indicação são:
As similaridades existentes entre os processos de RBC e os processos de GC e;
Similaridades heurísticas, visto que a metodologia utilizada em RBC é baseada na forma do raciocínio humano, que por sua vez é freqüentemente utilizada em processos de GC.
O conceito de Web Semântica foi introduzido no meio científico em meados de 2001 por Tim Berners-Lee, James Hendler e Ora Lassila.
A Web Semântica é uma iniciativa que busca a definição de formatos padrão para exprimir informações numa forma processável por a máquina.
A idéia básica é criar formas de explicitar o relacionamento de conceitos de vários domínios de conhecimento, permitindo que máquinas possam trabalhar sobre estes conceitos, relacionando- os e inferindo novos conceitos.
A distribuição de tarefas é essencial para a Web Semântica, o que remete ao estudo de sistemas distribuídos ou agentes de software.
Em a Web Semântica, agentes de software são usados como entidades capazes de consumir automaticamente conteúdos publicados.
Em a literatura são encontrados diversos trabalhos que citam a contribuição e uso de agentes de software na Web Semântica, como, e trabalhos que visam apoiar o desenvolvimento de aplicações deste tipo, como.
A motivação para o uso de ontologias é a representação semântica de um domínio específico.
As ontologias não apresentam sempre a mesma estrutura, mas existem características e componentes básicos comuns em grande parte de elas.
Os componentes básicos de uma ontologia são as classes (organizadas numa taxonomia), as relações (representam o tipo de interação entre os conceitos de um domínio), os axiomas (usados para modelar sentenças sempre verdadeiras) e as instâncias (utilizadas para representar elementos específicos, ou seja, os próprios dados) (GRUBER, 1996;
NOY e MCGUINNESS, 2001).
O uso de ontologias está também associado a GC.
Segundo Maedche, o vínculo entre GC e ontologias está na estruturação dos processos do conhecimento, que estão interconectados de forma bastante flexível.
Usando- se ontologias, a informação passa a ser armazenada como uma informação semântica integrada, gerando aos usuários visões que tornam fácil o acesso ao conhecimento.
Já em Weber e Kaplan, tem- se que a associação entre GC e ontologias se dá devido a o propósito de GC, que compreende suportar a representação de conhecimento além de seu compartilhamento e aquisição.
Também, segundo estes autores, o uso de ontologias pode auxiliar na resolução de dois desafios encontrados no desenvolvimento de sistemas baseados em conhecimento:
O alto custo de aquisição de conhecimento e a falta de conhecimento de senso comum.
A o decidir- se por a utilização de ontologias, alguns aspectos devem ser observados.
Um desses aspectos refere- se à criação da ontologia.
Sempre que possível, devese utilizar uma ontologia já existente para um determinado domínio.
Existem, na Web, repositórios especializados em armazenar ontologias definidas por grupos de especialistas.
Uma vez que já exista uma ontologia semelhante na área de interesse, o trabalho a ser realizado passa a ser estender a ontologia, acrescentando os conceitos e relações pertinentes ao domínio em questão.
O uso de ferramentas para a criação de ontologias também deve ser observado.
Outro aspecto diz respeito ao modo de representação da ontologia.
Existem, atualmente, várias formas de representar as ontologias por meio de linguagem de marcação.
Essas linguagens objetivam, principalmente, representar as informações através da descrição formal de um conjunto de termos sobre um domínio específico.
De acordo com Antoniou e Harmelen, as mais importantes linguagens de descrição de ontologias disponíveis são:
XML -- eXtensible Markup Language:
Provê uma sintaxe superficial para documentos estruturados e tem restrições quanto a representação do significado dos documentos.
RDF -- Resource Description Framework:
É um modelo de dados com semântica simples para descrever objetos (recursos) e relacionamentos entre eles.
RDF Schema: É uma linguagem de descrição de vocabulários para descrever propriedades e classes de recursos RDF.
OWL -- Ontology Web Language:
Utiliza lógica descritiva para a explicitação de conhecimento.
Permite descrever propriedades e classes, assim como relações entre as classes (como disjointness), cardinalidade (como &quot;exatamente um&quot;), igualdade, características das propriedades (como simetria) e classes enumeráveis.
Para os objetivos deste trabalho, serão verificadas mais detalhadamente duas das linguagens citadas:
RDF e OWL (sendo este último recomendado por a W3C como linguagem para manipulação de ontologias) (W3C, 2006 b).
O RDF é um modelo de dados básico, do tipo entidade-relacionamento, para escrever declarações sobre objetos Web (recursos).
Seus conceitos fundamentais, conforme ilustrado na Figura 2.5, são:
Recurso (Resource):
Qualquer coisa sobre o que se possa falar.
Todo recurso tem uma URI (Universal Resource Identifier) associada.
Uma URI pode ser uma URL (Unified Resource Locator ou endereço Web) ou qualquer outro tipo de identificador único.
Propriedade (Property):
Tipo especial de recurso;
As propriedades descrevem relações entre os recursos e também são identificadas por Uris.
Declaração (Statement):
É uma tripla do tipo (sujeito, predicado, objeto) consistindo de um recurso, uma propriedade e um valor.
Valores podem ser recursos ou literais.
A Figura 2.6 mostra um exemplo de grafo e seu código RDF correspondente.
O código inicia com a declaração do prólogo e nas linhas 2, 3 e 4 são definidos os namespaces4.
Uma vez especificados os namespaces, pode- se utilizar seus descritores de forma não-ambígua ao longo de o documento (na linha 6, por exemplo, é utilizado o prefixo ex para descrever informações do editor referentes ao namespace definido na linha 4).
RDF é genérico e, portanto, não faz associações sobre nenhum domínio de aplicação em particular.
Para especificar a semântica do domínio usa- se RDF Schema ou Um namespace define um vocabulário controlado que identifica um conjunto de conceitos de forma única para que não haja ambigüidade na sua interpretação.
RDFS. Segundo Daconta, RDFS é um conjunto simples de classes e propriedades RDF para definição de novos vocabulários RDF.
Os elementos básicos de um RDFS são:
Classes (Class):
Definem tipos de objetos.
Assim como em linguagens orientadas a objetos, uma classe é definida como um grupo de coisas com características comuns.
Em RDFS é possível estabelecer relações de hierarquia (através da propriedade &quot;is a subclass of&quot;) e herança entre as classes.
Propriedades (property):
São definidas globalmente, ou seja, não são encapsuladas como atributos nas definições das classes.
Existem propriedades para definir relações (como &quot;rdfs_ SubClassOf&quot;) e para definir restrições de propriedades (como &quot;rdfs_ Range «e &quot;rdfs_ Domain&quot;).
RDF e RDFS permitem a representação de alguns conhecimentos ontológicos, mas possuem várias limitações.
De acordo com Antoniou e Harmelen, algumas das limitações dessas linguagens são:
Propriedades de escopo local:
&quot;rdfs_ Range «define o alcance de uma propriedade para todas as classes.
Em RDFS não é possível declarar restrições de alcance para aplicar somente em algumas classes.
Restrições de cardinalidade:
Restrições do tipo &quot;apenas um «ou &quot;exatamente dois «não podem ser representadas em RDFS.
Características especiais de propriedades:
Em RDFS também não é possível indicar se uma propriedade é transitiva, única ou inversa de outra propriedade, por exemplo.
OWL é uma linguagem de marcação baseada em XML e RDF para a definição e a instanciação de ontologias processáveis computacionalmente.
Pode ser usada para representar o significado de termos num vocabulário e as relações entre esses termos A linguagem OWL se subdivide em 3 sublinguagens:
OWL Lite: Permite fazer a classificação hierárquica dos termos relacionados ao domínio e restrições simples.
OWL Dl: Estende a linguagem OWL Lite e permite fazer restrições de cardinalidade diferentes de 0 ou 1.
Em OWL Dl todas as conclusões são garantidamente computacionais e todas as computações terminam num tempo finito.
OWL Full: Suporte total para a liberdade máxima do RDF, sem garantias computacionais e com possibilidade de processamento em tempo infinito.
Um documento OWL é composto de indivíduos, classes e propriedades, onde Indivíduos:
São também conhecidos como instâncias;
Representam objetos de um domínio específico.
Classes: São conjuntos que contêm indivíduos com características semelhantes.
São descritas através de formalismos que retratam precisamente os requisitos para uma determinada sociedade de classes.
Propriedades: São relações binárias entre indivíduos.
Em OWL, propriedades podem ter propriedades inversas (por exemplo, a propriedade &quot;tem_ partes «é inversa da propriedade &quot;é_ sub_ Parte&quot;_ De&quot;) além de possuir características como transitividade e simetria.
Há dois tipos de propriedades:
A Figura 2.7 mostra um fragmento de código OWL onde é definida a estrutura de uma classe chamada Wine.
Em ela podemos identificar uma propriedade chamada madeFromGrape que tem restrição de cardinalidade mínima igual a 1.
A partir de uma ontologia é possível recuperar conhecimento, de acordo com sua semântica, através do uso de um motor de inferência.
Por meio de as regras de inferência, podem- se derivar novos fatos baseados em fatos existentes, ou seja, inferem- se novas informações.
Uma das ferramentas existentes para o auxílio computacional ao processo de inferência é o Jena, projeto open-source desenvolvido por o Hp Labs Semantic Web Programme, que é um framework para construção de aplicações voltadas à Web Semântica que fornece um ambiente de programação para OWL (e outras linguagens) e inclui um motor de inferência baseado em regras.
Por meio de o Jena é possível não só manipular, consultar e persistir arquivos OWL, mas também criar novos motores de inferência ou mesmo estender os motores já existentes.
As seções anteriores apresentaram as tecnologias básicas utilizadas na construção do framework proposto.
Inicialmente, as definições de agente e SMA apresentadas esclarecem as características fundamentais destas entidades, fornecendo indícios para a criação do modelo de arquitetura.
O fato do agente atuar de acordo com objetivos, por exemplo, indica que o agente está relacionado a um elemento &quot;objetivo «e que este elemento, por sua vez, deve estar relacionado a um conjunto de ações que, quando executadas, permitem que o objetivo seja atingido.
Já o estudo das plataformas disponíveis para desenvolvimento de SMAs, além de possibilitar a verificação da ausência de suporte nativo à organização do conhecimento dos agentes, permitiu o levantamento de características básicas da estrutura dos agentes desenvolvidos, ajudando no posterior mapeamento do framework proposto.
Para a representação semântica do conhecimento, foram apresentadas as ontologias.
Em o framework proposto, ontologias são usadas na representação do conhecimento disponível no agente, para transmitir e solicitar conhecimentos, e para a descrição dos objetivos.
Por último, o estudo e conceituação de aspectos relacionados a GC deram o embasamento teórico necessário para o mapeamento de um processo de GC numa arquitura de software.
As atividades do processo de GC sintetizado, por exemplo, foram mapeadas como procedimentos na arquitetura proposta.
Aspectos da técnica de RBC também foram incorporados ao modelo, como é o caso do uso de uma base de conhecimento composta por diversas entidades de conhecimento que encapsulam todo o conhecimento necessário para que seja atingido determinado objetivo -- entidades que serão referenciadas no decorrer de o texto como objetos de conhecimento.
Sistemas multiagentes geralmente são considerados complexos em relação a sua estrutura e funcionalidade.
Em muitas aplicações, até mesmo naquelas em que o ambiente parece extremamente simples, é difícil ou mesmo impossível, determinar corretamente, em tempo de projeto, os possíveis comportamentos e atividades realizados por os SMAs.
Para fazer este tipo de previsão, seria necessário ter conhecimento, por exemplo, de quais os requisitos do ambiente que poderiam aparecer no sistema em tempo de execução e também de como os agentes disponíveis no sistema iriam interagir para atender esses requisitos.
Este tipo de problema remete- nos a questões relacionadas ao aprendizado (ou aquisição de novos conhecimentos) e, se o agente for capaz de aprender, ele deve ser capaz, também, de representar o conhecimento adquirido para que ele possa ser reusado ou até mesmo distribuído para outros agentes.
Para que os agentes possam aprender com a sua experiência, incorporando fatos e conceitos, é necessário que as plataformas para desenvolvimento de SMAs ofereçam formas de representação e estruturação do conhecimento, permitindo aos agentes efetuar transformações sobre estas estruturas.
Porém, através da descrição das plataformas disponíveis para o desenvolvimento de SMAs pôde- se observar a falta de suporte nativo à definição interna dos agentes, principalmente em relação a a criação e organização do conhecimento.
Assim, este trabalho objetiva contribuir para o avanço da tecnologia de agentes, permitindo o gerenciamento do conhecimento disponível em agentes de software, através do mapeamento dos elementos envolvidos num processo de GC para um modelo de arquitetura de software.
Com o objetivo de apresentar o estado da arte em gerenciamento de conhecimento de sistemas, a seguir serão apresentados alguns trabalhos relacionados ao aqui proposto.
Em a literatura foram encontradas várias arquiteturas de software para GC corporativa, como, que têm como objetivo expandir o alcance e potencializar a velocidade de transferência do conhecimento.
Porém, não foram encontradas arquiteturas que utilizam, de forma completa e integrada, um processo de GC com o objetivo de gerir o conhecimento interno do sistema, fato que é a motivação para a proposta deste trabalho.
Assim, a seguir serão detalhadas algumas propostas de abordagens que contemplam ao menos uma das atividades do processo de GC sintetizado ou que demonstram o uso de tecnologias como RBC e ontologias aplicadas a GC ou SMAs.
A o final do capítulo, na Seção 3.3, é mostrada uma tabela comparativa entre as abordagens descritas, identificando de que modo são tratadas as atividades do processo em cada trabalho.
Rybinski e Ryzko apresentam um trabalho sobre o compartilhamento de conhecimento em SMAs.
Em este trabalho, como será detalhado a seguir, pode- se identificar aspectos de duas das atividades do processo de GC sintetizado:
A atividade capturar e a atividade distribuir.
Em o artigo são descritos aspectos referentes à arquitetura dos agentes e à arquitetura do SMA.
Em relação a a arquitetura dos agentes, cujo sistema lógico é definido por os autores como &quot;um sistema de raciocínio padrão baseado no conhecimento local e extensível através do conhecimento de agentes externos», são descritos três aspectos:
A arquitetura da base de dados, a classificação de fatos e regras e o processo de raciocínio.
A base de dados é composta por um conjunto de fatos sobre o mundo, por regras que representam o conhecimento do domínio e por restrições semânticas.
Já o conhecimento interno do agente é dividido em dois tipos de conhecimento:
De domínio e de ambiente.
O conhecimento de domínio contém todos os fatos e regras sobre o domínio em o qual o agente opera.
O conhecimento de ambiente, por sua vez, contém informações do ambiente em que o agente está trabalhando (é nesse tipo de conhecimento, por exemplo, que estão armazenadas informações sobre quais os outros agentes que atuam no ambiente).
Para o processo de raciocínio, todos os agentes possuem um mecanismo que permite inferir novos fatos e também invalidar sentenças lógicas consideradas falsas com uma lógica pré-definida.
Como é possível que um agente não contenha conhecimento suficiente para raciocinar acerca de ele mesmo, há um mecanismo global de solicitações a partir de o qual são aplicadas questões aos outros membros da comunidade.
Em relação a a arquitetura do SMA, são descritos dois aspectos:
Interação e raciocínio.
Quanto a a interação, que é feita em diferentes níveis, um agente só compartilha conhecimento depois de receber informações sobre a organização do sistema e sobre os estados e objetivos dos outros agentes.
Também, apenas são compartilhadas informações com os agentes mais confiáveis (cada agente classifica os outros membros da comunidade de acordo com níveis de confiança -- confiável, honesto e outros).
Quando um agente necessita de algum conhecimento, ele deve executar uma seqüência de passos.
Primeiro, deve ser verificado o conhecimento disponível na base de dados local.
Conhecimento classificado como honesto ou outro só deve ser usado caso não seja encontrado nenhum conhecimento nativo ou confiável que atenda a solicitação (o conhecimento também é classificado em níveis, que são:
Nativo, confiável, honesto e outros).
Se não for encontrado nenhum conhecimento compatível na base de dados, o agente deve requisitar conhecimento para os outros agentes do sistema.
Agentes considerados confiáveis devem ser notificados primeiro, seguidos por os honestos e outros.
Em o artigo é proposta ainda uma abordagem para diminuir o número de interações entre os agentes.
Essa abordagem consiste na verificação das mensagens enviadas por os membros da comunidade a fim de identificar quais de eles estão aptos a responder uma determinada solicitação.
A solicitação é enviada somente para os membros considerados aptos.
Embora no trabalho descrito sejam considerados vários aspectos referentes a captura e distribuição de conhecimento em SMAs, alguns pontos ficam nebulosos.
Um desses pontos diz respeito ao mecanismo para seleção de conhecimento.
Questões do tipo &quot;Como é escolhida a solução mais apropriada (melhor solução)?»
e &quot;Quando um conhecimento é considerado compatível com uma necessidade?»
não são tratadas no artigo.
Também, como as solicitações são executadas localmente (o agente que recebe a solicitação responde com uma ou mais possíveis soluções), não há referência à transferência de conhecimento entre os agentes, o que permitiria que a solução fosse adquirida por o próprio agente solicitante.
Em relação a as contribuições dadas por o trabalho descrito ao aqui proposto, destaca- se o processo de captura de conhecimento.
De maneira similar à descrita no artigo, no framework proposto, através da implementação de alguns dos pontos de flexibilidade, podem ser verificados aspectos referentes à confiança na seleção de um objeto de conhecimento para aplicação e também no envio de mensagens de solicitação de conhecimento.
Weber e Wu, em, descrevem uma arquitetura para projetar sistemas computacionais inteligentes (Computational Intelligence Systems -- CIS) que inclui um framework para GC cujas metodologias base são raciocínio baseado em casos e distribuição monitorada (monitored distribution).
De acordo com os autores, este framework permite que o sistema aprenda a partir de suas próprias experiências podendo assim evoluir.
Para avaliar o seu próprio desempenho, o sistema utiliza métricas de avaliação de execução.
A arquitetura do framework para GC descrita no artigo é composta por dois módulos principais, sendo que ambos os módulos consistem de um recipiente de bases de casos e de quatro processos de GC, denominados creator, distributor, reuser e understander.
A Figura 3.1 apresenta a arquitetura proposta.
O módulo superior é projetado para descrever experiências de execução do CIS (execuções terminadas) na base de casos principal (MCB ­ Main Case Base).
O módulo inferior ou módulo das lições aprendidas (lessons-learned) descreve lições aplicáveis no sistema (experiências úteis para tarefas individuais) na base de lições aprendidas (LLB ­ Lessons-learned Base).
O módulo superior possui ainda, como pode ser visualizado na Figura 3.1, bases de casos individuais (ICB ­ Individual Case Bases).
Essas bases são adicionadas se, para uma mesma saída, o CIS oferece várias opções de métodos (cada ICB armazena uma variante de cada método).
Também, há os engenheiros de conhecimento (KE ­ Knowledge Engineers) que verificam (validam) o conhecimento criado e organizado por o sistema.
Os quatro processos de GC que compõem os módulos principais do framework para GC são descritos da seguinte forma:
Creator: É o processo responsável por a aquisição de dados para popular as bases de casos.
Em as MCBs e ICBs são coletados os dados referentes a entradas, parâmetros usados e produzidos durante a execução e saídas do Understander:
Refere- se a todos os métodos desenvolvidos para preparar os dados adquiridos por o processo Creator.
Distributor: É o processo responsável por recuperar conhecimento relevante e aplicável a todas as necessidades de conhecimento do CIS.
A recuperação de conhecimento é feita através de parâmetros de similaridade definidos no processo Understander.
Reuser: Este processo dispara comandos contidos no conhecimento recuperado por o processo Distributor.
Também, é neste processo que são acionadas as necessidades de adaptação do conhecimento recuperado.
A integração do framework num CIS é feita de acordo com o ciclo de vida do framework.
São três os estágios do ciclo:
Infância, adolescência e maturidade.
Em os primeiros dois estágios, há um controle total dos engenheiros de conhecimento.
Em a infância, métodos e processos são testados e as primeiras experiências são armazenadas;
Em a adolescência o sistema começa a tomar decisões;
Por último, no estágio maduro, há pouca interferência humana e, se o sistema necessitar de alguma manutenção, métodos próprios de manutenção irão determinar e sinalizar a sua necessidade.
De acordo com os autores, acredita- se que este framework possa ser utilizável em outros tipos de sistemas computacionais, mas não há qualquer experimento que comprove sua aplicação em outros ambientes.
Em Weber e Wu são encontrados aspectos de grande parte das atividades do processo de GC sintetizado.
O processo Creator, por exemplo, está relacionado com a atividade capturar/ criar do processo de GC guia.
Já o processo Understander poderia ser mapeado na atividade organizar.
Porém, embora sejam citadas várias questões envolvendo as atividades do processo, muitas de elas estão descritas de forma superficial, o que dificulta o entendimento de que tipo de tecnologia ou método é de fato utilizado.
Por exemplo, após o conhecimento ser adquirido, sabe- se que ele passa por uma preparação no processo Understander, mas não se sabe qual o tipo de representação de conhecimento utilizado.
A definição das métricas de manutenção e dos parâmetros de similaridade (que indicam a similaridade entre um caso candidato e o caso de entrada) também não é apresentada.
O trabalho descrito, mesmo não tratando especificamente de GC em agentes de software, traz algumas contribuições para o trabalho que está sendo aqui proposto.
Como contribuição conceitual, destaca- se a idéia de evolução a partir de o conhecimento adquirido (com o uso de métricas de avaliação de desempenho, os agentes podem analisar suas execuções e sinalizar a necessidade de um conhecimento mais adequado, que tende a atender de forma mais satisfatória os seus objetivos).
Entre as principais diferenças entre o trabalho aqui proposto e o apresentado por Weber e Wu, está o tipo de conhecimento ou o conteúdo dos casos armazenados.
Em o trabalho descrito são armazenados, principalmente, aspectos de configuração do CIS (entradas, parâmetros usados e produzidos) e as saídas geradas.
Em o framework aqui proposto, a idéia é armazenar nos objetos de conhecimento todo o conhecimento necessário para atingir determinado objetivo, o que inclui, por exemplo, o código das ações que deverão ser executadas para que o objetivo possa ser satisfeito.
Pesquisadores da área de Inteligência Artificial estão adotando ontologias como um formalismo de representação de conhecimento compreensível para prover raciocínio de senso comum no suporte a tarefas como aquisição e reuso de conhecimento.
Em a literatura há vários trabalhos que utilizam ontologias para o fim citado, como.
Fernandes e co-autores, em, apresentam uma abordagem baseada em ontologias para organizar, compartilhar e consultar objetos de conhecimento na Web.
O sistema proposto fornece um modelo de dados que auxilia os usuários a descrever seus objetos de conhecimento pessoais (como exemplo de objetos de conhecimento tem- se «oql.
Pdf &quot;e «www.
Google. Com», que correspondem, respectivamente, a um arquivo e a um endereço Web), que podem ser mais tarde compartilhados com outros usuários.
A busca por objetos de conhecimento é feita a partir de consultas nos meta-dados que descrevem o objeto, como será descrito a seguir.
Para integrar os objetos de conhecimento dos usuários, o sistema foi projetado de acordo com duas perspectivas:
A arquitetura física, que especifica os componentes do sistema e a sua integração;
E a arquitetura lógica, que organiza os objetos do sistema em três visões lógicas.
Os componentes do sistema são distribuídos dentro de dois módulos, o local e o do servidor.
Conforme indicado na Figura 3.2, no módulo local há uma ferramenta para a criação de uma taxonomia de domínio que é usada para descrever e classificar os objetos de conhecimento.
A definição de uma taxonomia local dá aos usuários uma forma personalizada de descrever seus objetos.
Já o suporte a definição de meta-dados possibilita a descrição, a organização e o relato de documentos e links, promovendo interoperabilidade e auxiliando nos processos de consulta e recuperação de conhecimento.
Uma vez que os objetos de conhecimento do usuário estão classificados e descritos utilizando a taxonomia local, eles podem ser publicados no módulo servidor, que pode ser visto como um repositório de meta-dados.
Assim, os objetos ficam aptos para serem compartilhados entre os usuários.
O módulo servidor hospeda, além de os meta-dados dos objetos, uma ontologia global que integra diferentes taxonomias através de um vocabulário comum.
A arquitetura lógica é estruturada de acordo com três camadas:
Interna, de dados e semântica.
A distribuição em camadas pode ser vista na Figura 3.3.
A camada interna corresponde à representação física dos objetos de conhecimento.
A camada de dados está relacionada aos meta-dados dos objetos de conhecimento, expressados em RDF.
Por último, a camada semântica permite ao usuário criar uma ontologia personalizada para classificar os objetos de uma maneira mais flexível.
Segundo os autores, com o uso de ontologias, diferentemente de sistemas com diretórios de arquivos tradicionais, os objetos podem ser classificados em diferentes categorias, o que torna mais fácil o processo de organização.
Também, é possível estabelecer relacionamentos entre diferentes categorias, o que pode ser explorado por mecanismos de busca.
Segundo os autores, a interoperabilidade do sistema é suportada por a integração de várias ontologias, onde as classes das ontologias pessoais dos usuários são mapeadas na ontologia global, que funciona como um vocabulário compartilhado.
O processo de mapeamento é um-a-um, ou seja, para cada conceito da ontologia local deve ser identificado um conceito correspondente na ontologia global.
Com este mapeamento, quando um usuário submete uma consulta usando seu vocabulário personalizado, o sistema irá retornar não apenas os objetos classificados na sua categoria local, mas todos os objetos relacionados ao conceito identificado na ontologia global.
Por exemplo, quando um usuário faz uma consulta com o vocabulário &quot;Db «são retornados todos os objetos relacionados com o conceito &quot;Database «da ontologia global (&quot;Db «está mapeado como &quot;Database&quot;).
Em Davies É descrito o OntoShare.
OntoShare é um ambiente Web de compartilhamento de conhecimento baseado em ontologias para comunidades de prática5.
Em o OntoShare, os interesses dos usuários são armazenados em perfis de usuários.
Comunidades de prática são grupos dentro (ou através de) organizações que compartilham um conjunto comum de informações.
Um perfil de usuário contém um conjunto de tópicos ou conceitos ontológicos (classes declaradas em RDFS) onde o usuário declara seus interesses.
Na medida em que os usuários contribuem com informações para a comunidade, são criados novos recursos de conhecimento anotados com meta-dados.
Recursos de conhecimento podem conter, por exemplo, uma nota (comentário) do usuário, uma página Web ou informações copiadas de outras aplicações ou do próprio computador do usuário.
O OntoShare é usado para armazenar, recuperar, sumarizar e notificar usuários sobre determinadas informações compartilhadas por algum usuário da comunidade.
O compartilhamento é feito através de um cliente Java, a partir de o qual o usuário pode inserir meta-dados para a nova informação disponibilizada.
A princípio, o próprio sistema sugere um conjunto de conceitos que podem estar relacionados ao conteúdo submetido.
O usuário pode então aceitar as recomendações do sistema ou modificar- las sugerindo alternativas ou conceitos adicionais que estão associados ao conteúdo.
Depois da inserção dos meta-dados, o OntoShare cria um resumo do novo conteúdo para comparar com os perfis de interesse dos usuários da comunidade.
Toda vez que é identificada uma alta similaridade entre os termos do novo conteúdo (ou documento submetido) e algum perfil de usuário, o OntoShare gera uma notificação indicando a localização do novo conteúdo, quem o está compartilhando e quais foram os meta-dados adicionados.
Em o perfil do usuário que compartilhou o novo conteúdo, também é verificada a existência dos conceitos relevantes inseridos nos meta-dados do conteúdo.
Caso seja encontrado nos meta-dados algum conceito não cadastrado nos interesses do usuário, o OntoShare sugere ao usuário que este conceito seja adicionado à seu perfil.
Esta característica é apresentada como uma capacidade de aprendizado do OntoShare.
Para a descrição dos conteúdos é utilizada uma outra ontologia.
Em esta ontologia há informações sobre palavras-chave associadas, o resumo do documento, seu título, a anotação fornecida por o usuário, sua URL, o responsável por sua submissão e a data de armazenamento.
A descrição dos trabalhos de Fernandes E Davies Permite a identificação de possíveis usos de ontologias para auxiliar a Gestão de Conhecimento.
Ontologias possibilitam, como pôde ser visto, a criação de um vocabulário compartilhado, o uso de buscas baseadas em semântica, a atribuição de meta-dados aos recursos de conhecimento, entre outros.
Muito embora os trabalhos citados não estejam relacionados ao gerenciamento de conhecimento em sistemas computacionais, vários aspectos relacionados ao uso de ontologias para descrever e consultar os objetos de conhecimento serão utilizados no trabalho aqui proposto.
Em relação a a busca baseada em semântica, por exemplo, da mesma forma que o descrito nos trabalhos, a busca por objetos de conhecimento para atender a uma determinada consulta será feita sobre informações presentes na estrutura ontológica que descreve o objeto.
Em o presente trabalho, cada objeto de conhecimento está associado a uma ontologia -- que descreve os conceitos do domínio ao qual se aplica o conhecimento contido no objeto -- e as consultas (ou requisições de conhecimento) são também expressas em estruturas ontológicas.
Salienta- se, no entanto, que os aspectos utilizados dos trabalhos citados não estão relacionados, de maneira alguma, ao conteúdo dos objetos de conhecimento.
Em os trabalhos descritos, os objetos de conhecimento têm referência a um documento ou link, já no aqui proposto, eles são uma agregação de vários itens que permitem que um agente alcance determinado objetivo.
Assim, entre as principais diferenças entre os trabalhos descritos e o aqui proposto, destacam- se:
Conteúdo dos objetos de conhecimento:
Em os trabalhos descritos, como há o compartilhamento de conhecimento entre indivíduos, os objetos de conhecimento são constituídos de documentos ou links Existência de uma taxonomia local:
Em Fernandes Cada usuário está relacionado a uma taxonomia local a partir de a qual são retirados os meta-dados que descrevem todos os seus objetos de conhecimento.
Em o trabalho aqui proposto, cada objeto de conhecimento está associado a sua própria ontologia e não há nenhuma relação explícita entre os diferentes objetos de conhecimento de um mesmo agente.
Em a literatura foram encontrados alguns estudos que utilizam a técnica de raciocínio baseado em casos em SMAs, principalmente com o objetivo de possibilitar o aprendizado (ou aquisição de novos conhecimentos) de agentes de software (Plaza e Ontanón, 2003;
Plaza, 2005).
Devido a a alta similaridade e o fácil mapeamento entre os passos/ etapas da técnica de raciocínio baseado em casos e os processos de GC, a seguir serão descritos, brevemente, alguns dos estudos identificados.
Em Plaza e Ontanón é apresentada uma abordagem para SMAs onde os agentes são capazes de resolver problemas e aprender através de RBC.
Em este estudo, cada agente possui sua própria base de casos e há protocolos de interação para possibilitar que os agentes colaborem entre si, compartilhando diferentes casos.
Já em Plaza, é apresenta a técnica CoopCA, que é uma técnica de adaptação construtiva em SMAs para reuso de casos.
Desta vez, a construção dos casos é feita de forma colaborativa entre os agentes do sistema (o processo de adaptação é considerado, por o autor, aberto e distribuído), pois todos os agentes podem sugerir possíveis componentes para adicionar ao caso.
Também, há estudos que utilizam a técnica de RBC para formalizar o conhecimento adquirido com o monitoramento das ações do usuário, gerando assim novos casos para popular a base de casos.
Em Al-- Sakran, por exemplo, é proposta uma arquitetura que permite aos usuários coletar, compartilhar, distribuir e reusar objetos de aprendizado vindos de bases de conhecimento heterogêneas.
Em este estudo, a técnica de RBC faz uso de experiências passadas de outros estudantes, recuperadas a partir de a base de casos, para resolver as novas questões que surgem.
Independente da meta, a tarefa que os sistemas de RBC executam é a comparação entre um novo caso alvo e os casos armazenados na base de casos.
Esta é a essência da interpretação:
Identificar o que é relevante ao avaliar a similaridade e ordenar os resultados.
É essa característica que torna as aplicações baseadas em RBC apropriadas para a automatização de processos de GC em sistemas inteligentes.
Como pode ser visto na descrição dos trabalhos na subseção anterior, a técnica de RBC é utilizada em agentes de software principalmente no sentido de permitir a adaptação e a aprendizagem dessas entidades.
Isso é justificado, pois, de acordo com Aamodt e Plaza, é mais fácil aprender a partir de a experiência na resolução de um problema concreto do que generalizar a partir de ela.
De qualquer forma, independentemente da necessidade ou não de adaptar os casos para o uso numa determinada situação, o objetivo geral da técnica de RBC é o suporte aos processos de armazenamento e recuperação de conhecimento.
Em se tratando de armazenamento de conhecimento, têm- se o problema do tipo de representação dos casos.
Este problema refere- se, fundamentalmente, a que tipos de informações devem ser armazenadas num caso, qual a estrutura apropriada para descrever o conteúdo de um caso e como organizar e indexar a memória de casos para uma efetiva recuperação e reutilização.
De entre os trabalhos descritos, apenas um faz referência ao tipo de representação de casos utilizado:
Em os casos são representados através de uma lista de atributos valorados, que um dos tipos de representação mais comum utilizado para representar casos em RBC.
Em o trabalho aqui proposto, vários aspectos da técnica de RBC são considerados.
De entre esses aspectos destaca- se a existência de uma base de conhecimento composta por objetos de conhecimento (que poderiam ser considerados casos), a avaliação da similaridade entre os objetos para a utilização numa determinada necessidade, a representação dos objetos de acordo com um tipo definido de representação e o armazenamento de novos casos como resultado de uma lição aprendida (processo similar ao descrito em -- a execução dos agentes é monitorada para a aquisição de novos conhecimentos).&amp;&amp;&amp;
Como apresentado nas seções anteriores, diversas são as abordagens propostas para dar apoio aos processos de GC, cada qual com suas contribuições e limitações.
Desta forma, se torna conveniente a combinação de diferentes abordagens, como, por exemplo, a técnica de raciocínio baseado em casos e as ontologias.
A Tabela 3.1 apresenta um comparativo com as principais características das abordagens descritas.
Em a tabela são destacados os seguintes aspectos:
Suporte às atividades de processo de GC utilizado como guia:
Verificação de quais atividades são cobertas, de forma parcial ou integral, por a abordagem proposta.
Tipo de representação de conhecimento:
O conhecimento capturado deve ser convertido para uma linguagem de representação de conhecimento, para mais tarde ser recuperado e distribuído.
Assim, neste item é verificado qual o tipo de representação de conhecimento sugerido por a abordagem.
Conteúdo dos recursos de conhecimento:
Verificação de quais tipos de conteúdos que são indexados por os recursos de conhecimento sugeridos por a abordagem.
Algoritmo para verificação da similaridade:
Indica como o conhecimento disponível no sistema é recuperado quando é recebida uma solicitação ou consulta.
Admitindo- se a natureza subjetiva de alguns dos itens identificados, como a cobertura das atividades do processo de GC, procurou- se verificar, nas abordagens apresentadas, indicativos de tecnologias ou mecanismos que servissem como meio para prover os aspectos requeridos, ou seja, a existência de características que indiquem a preocupação com tais fatores.
Em a Tabela 3.1, não há referência ao quarto item descrito (algoritmo para verificação de similaridade), porque, embora a maioria das abordagens cite a verificação da similaridade no momento da distribuição do conhecimento, não há qualquer indicativo de que tipo de algoritmo é utilizado para essa verificação ao longo de a descrição dos trabalhos.
Como pode ser observado na Tabela 3.1, nenhuma das abordagens provê suporte a todos os aspectos considerados.
A abordagem mais abrangente, em se tratando das atividades do processo de GC, é a que trata de GC em sistemas computacionais inteligentes.
No entanto, essa abordagem não é aplicada ou ao menos contextualizada em agentes de software.
Em este contexto, identifica- se uma carência de pesquisas que trabalhem com GC em agentes de software, considerando as características próprias dessas entidades.
Tendo em vista a necessidade de organização do conhecimento de agentes de software e a carência de pesquisas na área, neste trabalho está sendo proposto um framework cujo principal objetivo é permitir aos agentes formalizar o conhecimento disponível e também transmitir esse conhecimento para que ele possa ser reusado.
A arquitetura proposta conta com procedimentos para o mapeamento de cada uma das atividades do processo de GC sintetizado, ou seja, procedimentos para criar, organizar, armazenar, distribuir, capturar e aplicar os objetos de conhecimento.
Em o framework, um objeto de conhecimento é uma entidade que possui todos os elementos requeridos para resolver determinado problema, definição similar a &quot;knowledge source «dada em.
Todas as regras e fatos de um agente podem estar relacionados a um ou mais objetos de conhecimento.
Os agentes podem usar esses objetos para realizar suas tarefas ou para gerar novos conhecimentos.
Em este trabalho, o termo conhecimento, da mesma forma que em Kucza, refere- se à &quot;informação em ação», isto é, informação aplicada para um propósito.
A apresentação do framework será feita em três diferentes níveis.
Em o primeiro nível, serão apresentados aspectos referentes às atividades do processo de GC sintetizado.
A análise das atividades, além de permitir a verificação da uniformidade do fluxo apresentado inicialmente e a identificação de outros aspectos de um processo (como entradas e saídas), visa esclarecer os requisitos necessários para a aplicação de um processo de GC no contexto de uma arquitetura de software.
Em o segundo nível, é descrito o modelo conceitual do framework e o seu mapeamento teórico sobre duas plataformas, o Jade e o SemantiCore.
Já no terceiro nível (que será apresentado no Capítulo 5), é fornecida uma descrição completa, em termos de implementação, do framework proposto já integrado ao SemantiCore.
Imaginando- se o framework proposto como uma camada ou componente a ser integrado no agente, muitas vezes, visando acomodar os diferentes estilos arquiteturais de um agente, serão encontradas no texto referências às outras partes ou componentes do agente.
Durante a verificação da aplicabilidade do processo de GC sintetizado numa arquitetura de software, verificou- se a necessidade de duas mudanças no processo.
A primeira mudança refere- se à separação da atividade capturar/ criar em duas atividades, onde:
Atividade capturar:
Atividade criar:
Refere- se à solicitação de encapsulamento ou organização do conhecimento novo disponível no agente.
A segunda mudança diz respeito à criação de três fluxos distintos de atividades.
Essa divisão é justificada por a verificação de que, por exemplo, nem todo o conhecimento armazenado deve ser posteriormente distribuído, pois a solicitação de conhecimento não está associada, em primeira instância, ao armazenamento do conhecimento, mas sim a uma necessidade de conhecimento recebida.
A Figura 4.1 mostra as atividades dispostas nos três fluxos, onde:
O Fluxo 1 é o responsável por possibilitar a criação de novos conhecimentos (estruturados em objetos de conhecimento);
O Fluxo 2 permite que haja compartilhamento de conhecimento entre diferentes agentes;
E o Fluxo 3 sinaliza uma necessidade de conhecimento do agente, aplicando e armazenando o conhecimento mais similar recebido (a similaridade é verificada em relação a necessidade de conhecimento sinalizada).
Salienta- se que, tanto o Fluxo 1 quanto o Fluxo 3 terminam com a execução da atividade armazenar, pois ambos envolvem a aquisição de novos conhecimentos, seja por a experiência ou por o recebimento de conhecimento externo ao agente.
Também, no Fluxo 3 não é necessária a organização do conhecimento recebido, visto que o conhecimento compartilhado já está estruturado como um objeto de conhecimento.
A seguir serão apresentados aspectos relacionados a cada uma das atividades do processo.
A idéia é identificar as pré-condições (ou eventos) que desencadeiam a execução de cada atividade, as pós-condições, que são os resultados atingidos com o término da atividade, e também os tipos de dependência para a execução da atividade.
Há dois tipos de dependência:
Interna e externa.
Se a dependência for interna, significa que a atividade é disparada por o recebimento de algum tipo de sinalização ou solicitação do agente onde o framework está integrado.
Já a dependência externa é caracterizada por o recebimento de mensagens por o ambiente, ou seja, por solicitações de outros agentes do sistema.
Fluxo 1: Criar Organizar Fluxo 2: Toda vez que é recebida uma indicação de que há conhecimento novo disponível no agente é iniciada a atividade criar.
É através dessa atividade que é verificada a disponibilidade de informações para que haja, de fato, a criação de um novo objeto de conhecimento.
Essa atividade tem como características:
Entrada: Indicação de conhecimento novo disponível.
Saída: Dados para a criação do objeto de conhecimento disponíveis.
Dependência: Interna, visto que a indicação de conhecimento novo disponível vem de algum componente do agente.
A atividade organizar é responsável por encapsular o conhecimento disponível num objeto de conhecimento.
Também, é nesta atividade que são definidas as restrições de acesso ao objeto.
Essa atividade tem como características:
Entrada: Dados para criação do objeto de conhecimento.
Saída: Objeto de conhecimento.
Dependência: Não há (o disparo desta atividade é feito ao final da atividade criar).
Em a atividade armazenar, o objeto de conhecimento deve ser registrado e armazenado na base local de conhecimento.
Essa atividade tem como características:
Entrada: Objeto de conhecimento.
Saída: Objeto de conhecimento armazenado.
Dependência: Não há (o disparo desta atividade é feito ao final das atividades organizar e aplicar).
A Figura 4.2 mostra, através de uma representação esquemática, o que acontece cada vez que é iniciado o Fluxo 1.
Como pode ser observado na figura, a execução inicia com a chegada de um mensagem indicando a detecção de um novo conhecimento no agente.
Essa mensagem é processada por a atividade criar, que então verifica as informações necessárias para a criação do novo conhecimento.
De posse das informações recuperadas, é criado um novo objeto de conhecimento (KO ­ Knowledge Object) na atividade organizar.
Por último, o novo objeto é armazenado na base de conhecimento (através da atividade armazenar).
Quando um agente envia uma solicitação de conhecimento, todos os agentes que recebem a solicitação verificam suas bases locais de conhecimento em busca de objetos de conhecimento para atender a solicitação.
Se existe algum objeto compatível, depois de verificadas as restrições de compartilhamento, é feito o envio do objeto ao agente solicitante.
Esse é o papel da atividade distribuir.
Essa atividade tem como características:
Entrada: Solicitação de conhecimento.
Saída: Objeto (s) de conhecimento enviado (s) ou não há objeto compatível com a solicitação.
Dependência: Externa, visto que a solicitação de conhecimento vem de outro agente.
Em a Figura 4.3 são apresentados, de forma esquemática, alguns aspectos da execução do Fluxo 2.
Conforme indicado na figura, a atividade distribuir inicia com a chegada de uma solicitação de conhecimento.
Através das informações contidas nessa solicitação (estruturadas numa ontologia) são verificados os objetos mais similares disponíveis.
Se forem encontrados objetos compatíveis com a solicitação, como é o caso do cenário ilustrado, é enviada uma mensagem de &quot;entrega «de conhecimento ao agente solicitante.
Caso não sejam encontrados objetos compatíveis com uma solicitação, não é enviada qualquer mensagem.
A não compatibilidade é registrada quando nenhum dos objetos disponíveis tem um grau de similaridade maior ou igual ao limiar mínimo estabelecido.
O agente pode, também, optar por não compartilhar conhecimento com determinados agentes ou com todos os agentes do sistema.
Em este caso, mesmo tendo conhecimento compatível disponível, não serão enviadas mensagens de &quot;entrega «de conhecimento.
Fluxo 3 ­ Aquisição e aplicação de novos conhecimentos Quando é percebida alguma necessidade de conhecimento no agente, o Fluxo 3 deve ser executado para que seja localizado e aplicado o conhecimento necessário.
Através da atividade capturar, as informações referentes à necessidade de conhecimento são encapsuladas e enviadas por o ambiente.
É ainda nessa atividade que o conhecimento recebido é selecionado.
Essa atividade tem como características:
Entrada: Indicação de necessidade de conhecimento.
Saída: Objeto de conhecimento compatível encontrado, ou não existe objeto de conhecimento compatível com a solicitação.
Dependência: Interna, já que a indicação de conhecimento faltante vem de outra parte do agente.
A atividade aplicar é responsável por ativar (ou &quot;carregar&quot;) os itens do objeto de conhecimento selecionado na atividade capturar.
Para a ativação dos itens de um objeto de conhecimento, é necessária a verificação da compatibilidade com o conhecimento já ativo no agente.
Essa atividade tem como características:
Entrada: Objeto de conhecimento.
Saída: Objeto compatível e carregado, ou objeto incompatível.
Dependência: Não há (esta atividade é disparada por a atividade capturar).
Para que um agente de software dê início a um processo de aquisição de novos conhecimentos ele deve ser capaz de identificar, primeiramente, o conhecimento faltante ou ineficiente.
Conhecimento ineficiente, neste caso, refere- se àquele conhecimento que, ao ser utilizado para atingir determinado objetivo, possibilita que o objetivo seja atingido parcialmente ou de maneira pouco satisfatória.
Para a verificação de conhecimento ineficiente, o framework proposto guarda registros de execução e, a partir de uma análise desses registros, pode ser também disparada a execução do Fluxo 3 (esse mecanismo será melhor explicado na próxima seção).
A Figura 4.4 traz um esquema ilustrativo do que acontece cada vez que é iniciado o Fluxo 3, disparado através da identificação de um conhecimento faltante no agente.
A Figura 4.5 apresenta a modelo conceitual da arquitetura do framework.
Observando- se a figura, podem- se destacar dois aspectos quanto a o domínio de aplicação em o qual o framework proposto pode ser utilizado.
Primeiro, o framework objetiva tratar aplicações que trabalham com conceitos de Web Semântica e ontologias.
Em o modelo conceitual, isso pode ser observado, por exemplo, no atributo ontology da classe KOGoal (o tipo do atributo é object para permitir o uso de diferentes Apis para trabalhar com ontologias).
Também, tanto o formato para representação do conteúdo de mensagens quanto o formato para a representação do próprio objeto de conhecimento remetem ao uso de ontologias, o que pode ser observado no modelo, respectivamente, no atributo contentSchema da classe KnowledgeOrganizer e no atributo schema da classe KnowledgeObject.
O segundo aspecto diz respeito ao modelo de arquitetura do agente.
Em o framework proposto, trabalha- se com agentes cujos objetivos (representados em ontologias) são atingidos por a execução de um conjunto de ações, sendo que essas ações são vistas como processos de computação, ou, em outras palavras, como um conjunto de eventos produzidos e consumidos computacionalmente.
Esse tipo de modelo de ações é apresentado por Ferber em A classe KnowledgeOrganizer (Organizador de Conhecimento) representa o núcleo ou classe principal da arquitetura proposta.
É nessa classe que estão os principais métodos que representam as atividades do processo de GC sintetizado.
Cada KnowledgeOrganizer possui os seguintes atributos:
Cada mensagem contém um tipo (&quot;requestKnowledge «ou &quot;deliverKnowledge&quot;), um identificador (toda mensagem de solicitação tem um identificador único) e o conhecimento requisitado ou compartilhado.
Em a Figura 4.6 tem- se o código OWL do formato do conteúdo das mensagens enviadas por o framework.
&quot;local», que indica a verificação apenas na base de conhecimento local;
&quot;Librarian «6, que é o agente que representa a base central de conhecimento (tem interfaces próprias para a inserção de objetos de conhecimento e não possui nenhum objetivo associado);
Ou com a identificação de qualquer outro agente (nome do agente e seu domínio).
Caso a lista esteja vazia, considera- se, como padrão, o envio para todos os agentes do domínio ao qual o agente solicitante está inserido.
A classe KnowledgeOrganizer está associada ainda a outras cinco classes, que são:
KnowledgeBase, ExecutionHistory, Criterion, ChangePolicy e SelectionPolicy.
A base de conhecimento local (KnowledgeBase) nada mais é do que uma agregação de objetos de conhecimento (KnowledgeObject).
É nessa classe que está o método responsável por a atividade armazenar do processo de GC.
O histórico de execução (classe ExecutionHistory) é uma agregação de registros de execução, representados por a classe ExecutionRecord.
Cada registro de execução tem referência a um objeto de conhecimento (atributo evaluatedObject), ao resultado da execução desse objeto (atributo classification) e aos dados que permitiram atribuir esse resultado (armazenados na tabela context).
O resultado da execução indica se o objetivo associado ao objeto de conhecimento foi alcançado de maneira muito satisfatória, de maneira regular, insatisfatória ou não foi atingido.
Os critérios para atribuir essa classificação estão associados com o próprio objetivo do objeto de conhecimento (classe KOGoal), como será descrito no decorrer de o texto.
Como pode ser observado na Figura 4.5, há duas associações entre as classes KnowledgeOrganizer e Criterion (um dos pontos de flexibilidade do framework proposto).
Os aspectos da base central de conhecimento serão melhor descritos na Seção 5.2.4.
Ambas representam os critérios usados para verificar a similaridade entre os objetos de conhecimento disponíveis e uma determinada solicitação/ necessidade.
Os critérios indexados em deliverCriterion são usados para avaliar a similaridade entre os objetos de conhecimento armazenados na base de conhecimento local e uma solicitação de conhecimento recebida (atividade distribuir).
Já os critérios contidos em loadCriterion são usados para avaliar os objetos de conhecimento recebidos depois de terminado o tempo de espera de uma determinada solicitação (atividade capturar).
Cada critério, além de um nome, possui os atributos descrição e peso (que representa a importância do critério na avaliação do objeto) e pode estar associado a uma lista de critérios (associação recursiva subCriterionList), formando uma hierarquia de critérios.
Para selecionar um ou mais objetos de conhecimento para distribuição ou aplicação devem ser implementadas políticas de seleção (SelectionPolicy).
A classe KnowledgeOrganizer tem duas associações com a classe SelectionPolicy:
DeliverPolicy e loadPolicy.
Em deliverPolicy é indexada a política de distribuição de conhecimento.
Como exemplos de política de distribuição citam- se:
Somente o objeto com maior pontuação será enviado;
Todos os objetos com pontuação maior que um determinado valor serão enviados, etc..
Já em loadPolicy está indexada a política de seleção de objetos de conhecimento para aplicação.
Como exemplos de política de aplicação citam- se:
Aplicar o objeto com a maior similaridade, aplicar o objeto com a maior similaridade e o menor risco, onde risco refere- se à aplicabilidade do objeto e é medido de acordo com a abrangência do conhecimento contido no objeto, entre outros.
Com os registros de execução presentes no histórico de execução podem- se desenvolver políticas para a solicitação de conhecimento novo para atender a um determinado objetivo, o que está representado no modelo por a associação entre KnowledgeOrganizer e ChangePolicy.
A política de troca (ChangePolicy) está altamente relacionada ao tipo de dados utilizado para classificar o resultado das execuções.
Se o resultado da execução for classificado numa escala numérica, por exemplo, pode- se implementar uma política que indique a necessidade de novos conhecimentos a cada 5 execuções de um determinado objeto com classificação menor do que 3 (a nota três, representa, neste caso, uma classificação pouco satisfatória).
Cada vez que é armazenado um novo registro de execução, deve ser verificada a política de troca.
Um objeto de conhecimento (KnowledgeObject), como já mencionado, encapsula todo o conhecimento necessário para que um agente possa executar ações de forma a atingir um objetivo.
A estrutura dos objetos de conhecimento, assim como a dos casos da técnica de RBC, possui duas partes básicas, que são:
A descrição do problema, que nos objetos de conhecimento é feita através da ontologia contida no item KOGoal;
A descrição da solução, que é feita através dos outros itens contidos no objeto.
O conhecimento encapsulado num objeto de conhecimento deve estar vinculado aos diferentes elementos que compõem o agente ao qual o framework está integrado.
Como cada plataforma estabelece uma arquitetura interna diferente para os seus agentes, cada objeto de conhecimento é composto de uma série de itens (KOItem) que são pontos de flexibilidade do framework.
Cada KOItem possui dois atributos:
Element, que representa o elemento da estrutura do agente;
E elementSchema, que é uma estrutura ontológica com todas as informações necessárias para se recriar o item num outro contexto (outro agente).
Em o momento da transferência de conhecimento, a estrutura ontológica (elementSchema) é instanciada com as informações capturadas no item indexado por o atributo element e apenas o modelo com as instâncias é transmitido.
Cada objeto de conhecimento possui, no entanto, três itens padrão, que são:
GoalITEM, DescriptorITEM e RestrictionITEM.
DescriptorITEM e RestrictionITEM são itens informativos.
Eles trazem informações sobre o objeto de conhecimento (essas informações podem ser consideradas meta-dados e estão representadas no modelo por os atributos da classe Descriptor) e também sobre suas restrições de compartilhamento (que devem ser verificadas na atividade distribuir do processo de GC).
Para a seleção dos meta-dados foi utilizado o material desenvolvido por a iniciativa Dublin Core Metadata7, que é uma organização que se dedica a promover a adoção de padrões de meta-dados interoperáveis para a descrição de recursos.
As restrições de compartilhamento do objeto, representadas no modelo por a classe Restriction¸ são também um ponto de flexibilidade da arquitetura.
O item GoalITEM, por sua vez, tem como elemento o objetivo geral do objeto de conhecimento, o KOGoal.
Em o KOGoal, mais especificamente no seu atributo ontology, é indicado para qual tipo de problema que o conhecimento encapsulado no objeto está voltado.
É através da ontologia indexada por ontology que são feitas as verificações de similaridade entre o objeto e as solicitações recebidas.
KOGoal também está associado a uma ou mais sentenças (classe Sentence), através de as quais é feita a avaliação da execução do objeto de conhecimento.
Para fazer essa avaliação, KOGoal está associado à classe Criterion, que, por ser um ponto de flexibilidade do sistema, permite que as sentenças e os dados resultantes da execução (presentes na tabela context) sejam avaliados e comparados das mais diferentes formas.
Cada sentença possui três atributos:
Subject, que representa o nome de uma variável que deve estar contida na tabela context;
Operator, que indica o tipo de operador utilizado (pode ser um operador relacional ou de igualdade);
E (3) value, que é o valor requerido para a variável.
A classe KnowledgeObject possui ainda dois atributos, um identificador (id) e um schema.
O schema (cujo tipo deve ser algum objeto que represente uma ontologia) é utilizado para representar o objeto de conhecimento no momento de seu compartilhamento.
Para exemplificar os demais possíveis itens de um objeto de conhecimento para agentes de software, foi feita uma análise na literatura e nas especificações das plataformas para desenvolvimento de SMAs disponíveis, a fim de identificar um conjunto de aspectos freqüentemente encontrados nessas entidades.
Como resultado deste estudo, os seguintes aspectos8 foram identificados:
Ações: É através de ações que se pode alterar o estado do agente ou do ambiente em o qual o agente está inserido.
Regras: É a partir de regras que o agente processa os fatos recebidos e toma decisões.
Sensores: É através dos sensores que os agentes percebem o ambiente (eventos que ocorrem no ambiente).
Cada sensor reconhece um tipo de padrão que deve ser verificado toda vez que um evento ocorre no ambiente.
Fatos: São recursos publicados no ambiente ou que fazem referência à estrutura interna do agente.
Os fatos servem direta ou indiretamente para a tomada de decisões.
Efetuadores (Effectors):
É através dos efetuadores que o agente age sobre o ambiente, podendo assim interagir com os outros agentes do sistema.
A integração do framework proposto sobre plataformas de desenvolvimento de SMAs se dá através do mapeamento e implementação dos pontos de flexibilidade dependentes das estruturas da plataforma, o que será mostrado na próxima seção.
O mapeamento do framework numa plataforma para o desenvolvimento de SMAs é feito em duas grandes atividades:
Verificação dos canais de comunicação possíveis entre o framework e os demais componentes do agente;
Identificação e Acredita- se que, mesmo que não haja algum desses itens explicitamente na plataforma, possivelmente há elementos com uma semântica semelhante.
A seguir, para demonstrar a integração do framework em plataformas para o desenvolvimento de SMAs, será mostrado o mapeamento sobre duas plataformas.
Para a integração do framework proposto em agentes Jade, faz- se necessário a criação de um novo atributo na classe jade.
Core. Agent (todo agente Jade é uma classe que herda da classe jade.
Core. Agent) para conter uma referência a classe principal do framework proposto, a KnowledgeOrganizer.
A configuração dos parâmetros do framework pode ser feita inicializações do agente.
Em esse método podem ser especificadas, por exemplo, as políticas de troca e de seleção, os critérios para a avaliação dos objetos de conhecimento e também pode ser feito o cadastramento de objetos de conhecimento na base de conhecimento do agente.
Em o Jade, as tarefas executadas por um agente são representadas por comportamentos implementados como objetos de uma subclasse de agente execute uma tarefa definida por um objeto de comportamento.
A classe que herda de comportamento e sua remoção do pool de comportamentos.
Agentes Jade, no entanto, não possuem nenhum conjunto de objetivos representados semanticamente (através de ontologias).
A execução de suas tarefas está representação semântica do que é realizado num determinado comportamento.
Assim, para integrar o framework proposto em agentes Jade, ao invés de uma lista de behaviours, os agentes devem estar relacionados a uma lista de objetivos que, além de uma associação com um behaviour que permita sua execução, devem possuir um atributo do tipo ontologia para representar o conhecimento manipulado no behaviour.
A criação da lista de objetivos e sua associação com os behaviours deve ser implementada para que se possa fazer a integração.
Também, para que seja iniciado o processo de aquisição de novos conhecimentos para determinado objetivo, o framework deve ser notificado quando não houver nenhum behaviour associado ao objetivo que deve ser executado, ou seja, um método para a notificação do framework deve ser implementado na classe que representa os objetivos do agente.
O paradigma de comunicação adotado por o Jade é a passagem de mensagens assíncronas.
Cada agente tem uma fila de mensagens.
Quando uma mensagem enviada entra na fila de um agente, o mesmo é notificado, mas o processo de tratamento da mensagem é de responsabilidade do programador.
Assim, para que o framework receba as mensagens com as requisições de conhecimento vindas de outros agentes, ele deve ser notificado a cada nova mensagem que chega na fila de mensagens, para que, se necessário, seja iniciado o processo de distribuição de conhecimento.
Para diminuir o número de mensagens verificadas no framework, pode- se utilizar templates para retirar mensagens específicas da fila de mensagens do agente (esses templates são implementados no Jade como instâncias da classe jade.
Lang. Acl.
MessageTemplate). Para o envio de mensagens no Jade, é necessário preencher os campos de um KnowledgeOrganizer do framework proposto terá uma referência ao agente (seu &quot;proprietário&quot;), o envio de mensagens de requisição ou de distribuição de conhecimento também será feito através da criação de um objeto ACLMessage (com o conhecimento Em o Jade, cada objeto de conhecimento será composto por dois tipos de itens (além de os default do framework):
BehaviourITEM e RuleITEM.
O BehaviourITEM terá como elemento um objeto da classe Behaviour, que deve conter todas as ações necessárias para que o agente atinja o objetivo do objeto de conhecimento ao qual está associado.
Cada objeto de conhecimento deve possuir apenas um elemento do tipo do BehaviourITEM (o que não impede que o behaviour indexado por o atributo element possua outros &quot;sub-behaviours&quot;).
Esta restrição de cardinalidade está relacionada à aplicação do objeto de conhecimento.
Em o momento em que o objeto for aplicado, o behaviour contido nos itens do objeto será associado ao objetivo do agente com conhecimento faltante e, por definição, cada objetivo deve estar associado a apenas um behaviour por vez.
O item RuleITEM terá como elemento as regras utilizadas por o agente para raciocinar sobre os fatos do mundo.
O Jade é integrado ao JESS -- Java Expert System Shell, que é uma ferramenta baseada em regras para raciocínio simbólico.
Para a criação dos objetos que representam as ontologias utilizadas no framework sugere- se o uso da classe Ontology, que é uma classe do próprio Jade utilizada para a criação de vocabulários compartilhados entre os agentes.
Em o SemantiCore, o framework proposto será integrado como um novo componente, chamado componente Organizador de Conhecimento ou Organizador.
A ligação entre os componentes do SemantiCore 2006 (ou caminho de dados) é um ponto de flexibilidade da arquitetura, o que facilita a integração.
Como pode ser visto na Figura 4.7, que mostra a comunicação entre os componentes, o Organizador se comunicará com o componente sensorial (de onde virão as mensagens recebidas por o ambiente), com o decisório (de onde virão mensagens de solicitação de conhecimento do próprio agente), com o efetuador (para solicitar o envio de mensagens por o ambiente) e com o executor (de onde virão as notificações de término de execução).
Os agentes no SemantiCore, assim como o descrito na Seção 2.3.4.1, possuem uma estrutura orientada a componentes e, em cada um dos componentes pode- se identificar uma entidade ou parte principal, que caracteriza o seu funcionamento.
O componente sensorial, por exemplo, é caracterizado por o seu conjunto de sensores, através de os quais os agentes percebem o ambiente.
Já o componente decisório, armazena uma série de fatos e de regras de inferência para a tomada de decisão.
O componente executor, por sua vez, é caracterizado por as ações que encapsula.
Por último, o componente efetuador é composto por efetuadores, que representam cada um dos tipos possíveis de mensagens transmitidas por o ambiente.
Para representar todos esses elementos, devem ser criados, respectivamente, cinco tipos de itens no objeto de conhecimento:
SensorITEM, RuleITEM, ActionPlanITEM, FactITEM e EffectorITEM.
As linhas tracejadas na Figura 4.7 indicam os componentes que o Organizador manipulará para aplicar um novo objeto de conhecimento ou, em outras palavras, para carregar os itens do objeto de conhecimento.
SemantiCore Cada objeto de conhecimento pode estar associado a apenas um item que tenha como elemento um plano de ação.
Essa restrição, assim como explicado na seção anterior, está envolvida com a aplicação do objeto de conhecimento (no SemantiCore, o item que ficará relacionado com o objetivo do agente é o plano de ação).
Em o Capítulo 7 serão feitas mais considerações sobre essa restrição.
O objetivo do objeto de conhecimento ficará no próprio Organizador, que deverá verificar o resultado de execução do objeto (se satisfatória ou não) através dos critérios associados ao seu objetivo.
A coleta de dados para a realização desta avaliação é feita verificando- se o conteúdo das variáveis do plano de ação ao final de sua execução.
Para a definição e o uso de ontologias no SemantiCore será usado o framework Jena.
Em o SemantiCore, embora o mecanismo decisório seja um ponto de flexibilidade da arquitetura, já há uma integração nativa com o Jena, o que possibilita o uso de máquinas de inferência neste componente e a criação ou manipulação de ontologias nos demais componentes do agente.
Este capítulo apresentou os aspectos gerais do modelo de arquitetura para Gestão de Conhecimento desenvolvido e aplicado nesta dissertação.
Em a descrição, procurouse destacar os aspectos conceituais da arquitetura proposta, como a aplicação de cada atividade do processo de GC sintetizado numa arquitetura de software.
Também, foram salientadas questões referentes à integração do framework proposto em plataformas para o desenvolvimento de SMAs, onde foi apresentado um breve estudo sobre a integração da arquitetura no Jade e no SemantiCore.
Em a Tabela 4.1, tem- se um resumo com os principais aspectos que devem ser observados para a integração do framework.
Como pode ser observado na tabela, devem ser verificadas questões referentes à comunicação, aos itens dos objetos de conhecimento, aos objetivos do agente e às ferramentas para criação e edição de ontologias.
Para cada aspecto apresentado na tabela, há uma descrição indicando a implementação esperada.
Por exemplo, para o recebimento de mensagens do ambiente, acredita- se que serão criados canais de comunicação entre o agente e o framework.
Em o próximo capítulo serão detalhados os aspectos referentes à implementação do framework e à sua integração ao SemantiCore.
A implementação de todos os aspectos ilustrados na Tabela 4.1 será apresentada de forma dispersa ao longo de o todo o capítulo.
Para que o framework seja notificado das mensagens de solicitação e de distribuição de conhecimento recebidas por o agente através do ambiente, deve ser criado um canal de comunicação entre o agente e o framework.
Envio de mensagens Para que o framework possa enviar mensagens de solicitação e de distribuição de conhecimento, ele deve ter acesso às estruturas utilizadas nas mensagens da arquitetura e também aos métodos que permitem que as mensagens sejam enviadas por o ambiente.
Identificação dos itens Identificação dos aspectos da arquitetura do agente que devem compor um objeto de conhecimento.
Para tanto, deve- se verificar quais são os elementos necessários para a execução de um objetivo do agente.
Criação da estrutura ontológica dos itens Compreende o levantamento das informações necessárias para a recriação dos elementos do agente indexados nos itens do objeto de conhecimento.
Essas informações devem estar explicitadas numa estrutura ontológica.
Carga e remoção dos itens Durante a aplicação de um objeto de conhecimento, cada um de seus itens deve ser carregado no agente.
Para tanto, após a recriação da classe que representa o item, devem existir métodos que indiquem como o item é relacionado à arquitetura do agente.
A remoção indica que, assim como os itens podem ser carregados no agente, deve ser possível remover- los quando o objeto de conhecimento não se demonstrar mais útil.
Em o framework, acredita- se que o agente possui uma série de objetivos (que são representados através de ontologias) e que esses objetivos estão associados a algum elemento da arquitetura dos agentes que permita a sua execução.
Caso não haja este elemento na arquitetura, ele deve ser criado.
Identificação do elemento que deve ser relacionado ao objetivo Compreende a identificação do elemento que ficará associado aos objetivos do agente (caso isto já não esteja definido na arquitetura).
É através da execução deste elemento que o objetivo é satisfeito.
Indicação de conhecimento faltante Para que o framework seja notificado sobre a falta de conhecimento no agente, o agente deve ser capaz de perceber uma necessidade de conhecimento e sinalizar- la ao framework.
Para tanto, sugere- se que seja verificada a existência ou não da associação dos objetivos com os elementos para as suas execuções.
Caso não haja a associação quando o objetivo for iniciado, o framework deve ser notificado.
Aviso de término da execução Ontologia Descrição Criação de uma estrutura para representar os objetivos Objeto de Conhecimento Comunicação Aspecto a ser verificado Para que seja computada a classificação da execução do objetivo, o framework deve ser notificado ao término da execução do elemento associado ao objetivo do agente.
Essa notificação deve conter o contexto final da execução do elemento, através de o qual será realizada a verificação da classificação.
API para criação de ontologias Para a criação e edição das ontologias, deve ser utilizada alguma API para a manipulação de ontologias.
Em o framework, há uma integração nativa com o Jena.
Em este capítulo, a arquitetura será detalhada em termos de sua implementação.
Para o detalhamento, procurou- se seguir a mesma estrutura de apresentação do modelo conceitual (Capítulo 4), visando uma melhor identificação entre a parte conceitual e a parte prática.
A implementação do framework foi feita tendo- se como base o SemantiCore, ou seja, durante a implementação do framework já foram considerados e implementados os aspectos de integração com esta plataforma de desenvolvimento de SMAs.
O aproveitamento de toda a infra-estrutura existente no SemantiCore teve como objetivo a diminuição do tempo de implementação.
Para a manipulação e criação de ontologias, como já citado, foi utilizada a API do Jena.
Durante a implementação procurou- se observar todos os aspectos com constantes modificações para que eles pudessem ser implementados em estruturas flexíveis e expansíveis.
Este é o caso dos critérios de verificação, que podem ser usados tanto para avaliar a similaridade entre as solicitações de conhecimento recebidas e os objetos de conhecimento disponíveis quanto para avaliar a classificação da execução de um objeto.
Quanto a o escopo da implementação, neste primeiro momento estão sendo implementados apenas os aspectos referentes a dois dos fluxos do processo de GC:
O Fluxo 2, que trata do compartilhamento do conhecimento;
E o Fluxo 3, que considera a aquisição e aplicação de novos conhecimentos.
O Fluxo 1, que envolve a criação e representação de novos conhecimentos, está sendo executado apenas de forma manual, ou seja, a criação dos objetos de conhecimento é feita por o desenvolvedor no momento da configuração do agente.
As razões para a delimitação do escopo da implementação estão relacionadas às dificuldades em se identificar conhecimento novo no agente e também na incerteza quanto a a relevância e reusabilidade do conhecimento novo identificado.
Esses aspectos serão melhor discutidos no Por último, acredita- se que algumas reformulações da versão inicial serão necessárias para o aperfeiçoamento tanto do desempenho quanto de outras questões identificadas a partir de a primeira versão.
É improvável que se possa chegar a uma arquitetura ideal em flexibilidade e desempenho que combine várias tecnologias na sua primeira versão.
Para facilitar o entendimento, os aspectos da implementação serão apresentados através de quatro seções:
Aspectos gerais, onde serão descritas as principais classes que constituem o framework e também seus métodos;
Itens do objeto de conhecimento, onde será apresentado cada item que compõe um objeto de conhecimento no SemantiCore, salientado- se questões referentes a serialização e a recriação, a partir de as ontologias, dos elementos indexados;
Adaptações requeridas no SemantiCore, onde serão explorados os códigos acrescentados a algumas classes do SemantiCore;
Base de conhecimento global, onde serão explicitados os aspectos referentes à criação desse elemento da arquitetura.
Como pode ser visto na Figura 5.1, a classe KnowledgeOrganizerComponent encapsula as funções necessárias para a busca, a distribuição e a aplicação de conhecimento (objetos de conhecimento).
Essas funções são acionadas de acordo com as necessidades do agente ou com o recebimento de requisições de outros agentes.
As necessidades de exemplo, considere que um agente, para atingir determinado objetivo, precisa adquirir conhecimento sobre vender livros.
Esta necessidade será indicada ao framework que então da venda de produtos.
Após o recebimento dos objetos de conhecimento e da seleção de um Cada vez que é recebida uma solicitação de conhecimento do agente ao qual o framework está integrado é criado um objeto do tipo KnowledgeRequest.
Cada KnowledgeRequest possui quatro atributos, que são:
Id, que é o identificador gerado para a requisição (deve ser um identificador único);
StartTime, que informa o horário em que foi solicitado o conhecimento (necessário para a verificação do tempo de espera);
As solicitações de conhecimento do agente são gerenciadas por a thread RequestVerifier.
Enquanto há solicitações de conhecimento pendentes na lista de solicitações (requestList) é verificado o tempo decorrido de cada solicitação (através do método uma mensagem cujo tipo é &quot;deliverKnowledge», essa mensagem é encaminhada ao objeto de distribuição de conhecimento em RequestVerifier, primeiro é verificado o identificador da solicitação ao qual o conhecimento distribuído está relacionado.
Se a solicitação ainda está pendente (não acabou o tempo de espera), a mensagem é adicionada à lista de conhecimentos recebidos da solicitação.
Em o momento que termina o tempo de espera para uma solicitação, é método é verificado todo o conhecimento recebido para a solicitação (com o uso dos critérios de aplicação) e é selecionado um objeto para o carregamento, de acordo com a política de aplicação referenciada na classe KnowledgeOrganizerComponent.
Já as solicitações de conhecimento de outros agentes são processadas no recebida uma solicitação, cujo conhecimento requerido é estruturado na forma de uma ontologia, é feita uma verificação de similaridade entre a solicitação e todos os objetos de conhecimento disponíveis na base de conhecimento.
Como resultado desta verificação tem- se uma lista de objetos da classe Measure (que possui uma referência ao objeto de conhecimento política de seleção para distribuição (deliverPolicy) relacionada classe ponto de flexibilidade da arquitetura e deve retornar uma lista com os objetos aptos para o uso, neste caso, aptos para o envio ao agente solicitante.
Em a base de conhecimento local, que possui uma lista com os objetos de conhecimento disponíveis no agente, estão os métodos para o armazenamento e a remoção de objetos de conhecimento.
Esses métodos são invocados, normalmente, por métodos da classe KnowledgeOrganizerComponent ou na inicialização do agente, onde podem ser adicionados objetos na base.
O framework estrutura o conhecimento de um agente na forma de objetos de conhecimento.
Cada objeto de conhecimento possui um nome, uma estrutura ontológica usada no seu compartilhamento (atributo schema da classe KnowledgeObject) e uma série de itens (classe KOITEM).
A ontologia9 contida no schema da classe KnowledgeObject, assim como mostra a Figura 4.6, possui duas classes OWL, KnowledgeObject e KOItem.
Essas classes se relacionam através da object property hasItems.
Cada KOItem possui outras duas propriedades:
ItemClass, que é uma datatype property cujo valor é uma string;
E element, que é uma object property cujo alvo pode ser de qualquer tipo (como pode ser visto na figura, tem- se como alvo uma owlClass genérica).
Quando o objeto de conhecimento é serializado para ser transmitido, cada um de seus itens é também serializado e as ontologias resultantes destes processos são adicionadas a ontologia do objeto de conhecimento.
A integração entre os indivíduos das ontologias vindas dos itens e os presentes na ontologia do objeto de conhecimento é feita por a object property element (owlClass KOITEM) que, devido a os itens serem pontos de flexibilidade da arquitetura, pode ser de qualquer tipo.
Exemplos da criação de objetos de A ontologia está representada em notação UML, conforme o especificado em.
Avaliar a eficiência do conhecimento utilizado em determinada tarefa indica que o sistema deve monitorar o seu próprio desempenho e ser capaz de aprender com isso.
Em este sentido, o framework possui um histórico de execução (ExecutionHistory) composto por vários registros de execução.
A capacidade de monitorar seu desempenho, de acordo com Weber e Wu, pode garantir longos períodos de execução ao sistema sem a necessidade de manutenção.
Cada vez que é sinalizado o término da execução de um objetivo do agente (término do plano de ação associado ao objetivo) no método de KnowledgeOrganizerComponent, deve ser verificado se há algum objeto de conhecimento ativo no agente (lista loadedKOs) relacionado ao objetivo finalizado.
Caso afirmativo, é método, além de a indicação do objeto de conhecimento cuja execução foi finalizada, deve ser indicado o contexto referente a o final da execução do plano.
O palavra contexto vem da arquitetura do SemantiCore e indica uma lista de variáveis e seus respectivos valores.
Em o SemantiCore, as variáveis do contexto e os seus valores podem tanto ser adicionados no momento da criação do plano de ação quanto em tempo de execução (por exemplo, dentro de o recuperadas e modificadas por qualquer ação do plano.
A partir de as informações contidas no contexto, pode- se classificar a execução ExecutionHistory.
Essa classificação é feita de acordo com as sentenças de verificação associadas à classe KOGoal, que está no GoalITEM do objeto de conhecimento.
As sentenças contêm o nome da variável, um operador(&quot;\&gt;», &quot;$ &quot;) e um valor.
A comparação dos valores contidos na tabela de contexto com os requeridos por as sentenças associadas ao objetivo do objeto de conhecimento é feita através de algum critério, que deve ser implementado por o desenvolvedor (os critérios são pontos de flexibilidade da arquitetura).
Por exemplo, se um objetivo tem uma sentença do tipo e, ao término da execução do plano de ação o contexto do plano possui o valor &quot;40 «para a variável &quot;preço», isso indica que a sentença foi satisfeita, visto que o preço ficou abaixo de o nível máximo (classe Criterion).
Para padronizar esse valor, pode ser usado um objeto da classe Converter, que converte uma medida de entrada em algum outro valor (por exemplo, um valor 70, que indica uma porcentagem de 70% de satisfação, pode ser convertido, numa escala lingüística, para o valor &quot;bom&quot;).
Depois de computada a classificação da execução de um objeto de conhecimento, é criado um novo registro de execução e inicia- se o processo de avaliação de seu histórico de execução.
Em esse processo, todos os registros de execução do objeto finalizado de flexibilidade da arquitetura.
Dentro deste método deve ser avaliado o histórico de execução para verificar a necessidade de substituição do conhecimento.
Como resultado desta avaliação é retornado o valor verdadeiro, que dispara o processo de captura de novos conhecimentos, ou falso, que não dispara nenhuma ação.
A Tabela 5.1 apresenta todos os possíveis eventos que são sinalizados ao framework (através do método de sua classe principal KnowledgeOrganizerComponent) e quais as ações que eles acarretam (método que é disparado com a chegada de cada evento).
Um objeto de conhecimento é uma agregação de itens, representados por a classe KOITEM no modelo.
Cada KOITEM possui quatro métodos não implementados dois primeiros métodos estão relacionados com o compartilhamento do objeto de conhecimento, onde cada item deve poder ser serializado para transferência e também ser Cada DataDescriptor contém uma ontologia com as instâncias do item serializado e uma representa o objeto de conhecimento.
Como na ontologia que representa o item podem- se ter várias classes e, conseqüentemente, várias instâncias de classes diferentes, tornou- se necessário indicar qual o elemento &quot;base «ou principal da ontologia de dados, de onde se podem derivar os demais relacionamentos.
SemanticAgent, que representa o &quot;proprietário «do framework.
Em o SemantiCore, todos os agentes do sistema herdam as propriedades desta classe e através de seus métodos é possível acessar qualquer um dos componentes do agente, o que é necessário na carga de alguns dos itens do objeto de conhecimento.
Todo objeto de conhecimento, independentemente da plataforma de integração, possui três itens padrão (GoalITEM, RestrictionITEM e DescriptorITEM), como já mencionado no capítulo anterior.
Todos esses itens possuem os quatro métodos abstratos visto que não são aplicados, e consequentemente não precisam ser removidos, em nenhum elemento do agente em que o framework está integrado.
O tratamento destes itens é feito no próprio framework e eles permanecem ligados apenas ao objeto de conhecimento de o qual fazem parte.
O GoalITEM, que contém como elemento a ontologia que define o conhecimento armazenado no objeto de conhecimento, possui o elementSchema apresentado na Figura 5.3.
Como pode ser visualizado na figura, há três classes OWL:
GoalITEM, Criterion e Sentence.
Em a classe OWL GoalITEM, há uma datatype property denominada hasOntology cujo valor alvo é uma string.
É nesta propriedade que é inserida a ontologia indexada no atributo element da classe GoalITEM.
A ontologia do objetivo é inserida nesta do objeto de conhecimento (para não misturar os conceitos do objetivo com os dos itens do objeto de conhecimento).
A classe OWL Sentence é bastante similar à classe Sentence do modelo, onde os atributos se tornaram datatype properties.
A classe OWL Criterion, no entanto, além de os atributos necessários para a recriação dos critérios (name e weight) e de sua descrição (description), possui duas outras datatype properties:
CriterionClass e code.
Em criterionClass é armazenado o nome da classe que implementa o critério.
Porém, se a classe não estiver disponível para instanciação, pode- se pegar o código contido na datatype property code para a recriação da classe que implementa o critério associado ao objetivo.
Em o momento da serialização do item GoalITEM é criado um novo indivíduo da classe OWL GoalITEM que é então relacionado a um indivíduo da classe OWL Criterion e a tantos indivíduos da classe OWL Sentence quantos forem os elementos da lista verificationSentence contida na classe KOGoal do modelo.
O item RestrictionITEM, por ser um item que contém um elemento que necessita ser implementado (o método verifyRestriction da classe Restriction é um ponto de flexibilidade da arquitetura) possui na sua estrutura ontológica apenas o nome da restrição, o nome da classe que a implementa e o código da classe (para o caso da classe não estar recebida que, após ser analisada por o código inserido por o desenvolvedor, deve retornar um valor verdadeiro ou falso, onde verdadeiro indica que o objeto pode ser compartilhado e falso indica que não pode.&amp;&amp;&amp;
A ontologia desenvolvida para descrever as informações deste item pode ser visualizada na Figura 5.4.
O item DescriptorITEM, por sua vez, tem como elemento um objeto da classe Descriptor, que traz várias informações (meta-dados) sobre o objeto de conhecimento ao qual está associado.
Estas informações podem ser utilizadas, por exemplo, nos critérios para aplicação do objeto.
Como exemplo deste uso, cita- se a verificação do estado do objeto (um objeto de conhecimento acabado, dependendo do caso, deve ter prioridade na aplicação sobre um objeto em construção).
A estrutura ontológica para este item apresenta todos os atributos da classe Descriptor na forma de datatype properties.
Itens do objeto de conhecimento específicos do SemantiCore Antes de descrever os aspectos de implementação dos itens que compõem um objeto de conhecimento no SemantiCore é necessário entender a semântica atribuída aos fatos (classe semanticore.
Agent. Kernel.
Information. Fact), visto que muitos dos itens do objeto estão associados à classe FactITEM (que tem como elemento um objeto Fact).
Os fatos são recursos (onde recurso representa qualquer entidade especificada numa ontologia) que são publicados no ambiente ou que fazem referência à estrutura interna do agente como, por exemplo, a exclusão de um plano de ação.
Em o SemantiCore, os fatos são usados como padrão de seleção de mensagens nos sensores, como pré e pós-condição das ações, e contribuem direta ou indiretamente para a tomada de decisão do agente.
A classe Fact possui três especializações, ComposedFact, SimpleFact e FunctionBasedFact, conforme ilustrado na Figura 5.5 (a).
Os fatos compostos são formados por fatos simples ou compostos ou por fatos baseados em funções, ligados por um operador lógico.
Os fatos simples possuem três atributos (subject, predicate e object) que representam os três elementos de uma declaração RDF (statement RDF).
Já os fatos baseados em função representam os fatos que dependem de uma avaliação de outros fatos para serem gerados.
Esses fatos são usados, principalmente, nas regras de inferência.
Com eles, pode- se verificar, por exemplo, se X e Y, ambos recursos RDF e literais do tipo inteiro, são iguais (&quot;equal (X, Y)&quot;) ou se X é menor que &quot;Y( «lessThan (X, Y)&quot;).
Para armazenar de forma semântica as informações necessárias para a criação dos fatos (sejam fatos simples, compostos ou baseados em função) foi definida a estrutura ontológica ilustrada na Figura 5.5 (b).
Note que os diagramas mostrados na figura são bastante semelhantes, o que é justificado por a fácil geração de uma representação em OWL a partir de um esquema UML.
Cada vez que é solicitada a serialização de um objeto do tipo FactITEM, a ontologia ilustrada na Figura 5.5 (b) é instanciada com as informações retiradas do elemento Fact indexado no atributo element de FactITEM.
A Figura 5.6 mostra um trecho de código OWL com as informações retiradas do fato baseado em função (&quot;lessThan (X, Y)&quot;).
Em esta ontologia, como pode ser visto na figura, os argumentos do referido fato são armazenados por posição do argumento na chamada da função.
Isso foi necessário, pois a ordem dos argumentos pode alterar o resultado de alguns tipos de função e, embora os valores sejam inseridos na ontologia na mesma ordem em que estão na chamada do método, isto não garante a leitura seqüencial para a recriação da lista de argumentos.
Como os fatos podem estar associados a outros fatos (um objeto ComposedFact possui dois atributos do tipo Fact), foram criados dois métodos recursivos FactITEM contido no objeto de conhecimento deverá estar relacionado a algum outro item do objeto, estes processos são realizados juntamente com o elemento ao qual o fato está associado.
Um objeto de conhecimento no SemantiCore pode conter, além de o item já descrito e os default do framework, outros quatro itens, que são:
SensorITEM, EffectorITEM, RuleITEM e ActionPlanITEM.
Cada um desses itens está relacionado a um dos componentes básicos da estrutura do agente no SemantiCore, como será descrito a seguir.
SensorITEM tem como elemento um objeto da classe semanticore.
Agent. Sensorial.
Sensor e está relacionado, portanto, ao componente sensorial do agente.
Cada SensorITEM indica um tipo de sensor que deve ser instanciado no agente para que ele perceba um determinado conjunto de eventos do ambiente.
Todo sensor possui dois tipos de padrão de verificação nas mensagens:
O padrão de cabeçalho (headerPattern) e o padrão de conteúdo (contentPattern).
Como os eventos (ou mensagens) disparados no ambiente estão estruturados na forma de ontologias, os padrões do sensor estão associados à classe Fact (semanticore.
Agent. Kernel.
Information. Fact).
Para a geração da representação ontológica dos sensores são capturados os seguintes aspectos:
Nome do sensor, nome da classe para instanciação (os sensores são pontos de flexibilidade do SemantiCore) e os padrões de cabeçalho e conteúdo.
Quando um objeto de conhecimento é aplicado, o sensor recriado é adicionado à lista de sensores do componente sensorial.
De maneira similar, quando o objeto de conhecimento deve ser removido, todos os sensores contidos em seus itens devem ser removidos da lista de sensores.
O EffectorITEM tem uma implementação bastante similar ao SensorITEM.
Seu elemento, no entanto, remete ao componente efetuador do agente (possui como elemento um objeto da classe semanticore.
Agent. Effector).
Cada EffectorITEM indica um efetuador que deve ser adicionado ao agente para que possam ser enviados diferentes tipos de mensagens por o ambiente.
Para a representação ontológica deste item, são capturados apenas o nome do efetuador e a classe que o implementa (os efetuadores também são pontos de flexibilidade da arquitetura do SemantiCore).
Embora os efetuadores e sensores sejam elementos que podem ser criados por os desenvolvedores na arquitetura do SemantiCore, algumas implementações destes itens já são disponibilizadas junto com a plataforma.
Como um mesmo sensor ou efetuador pode ser utilizado em diferentes aplicações, acredita- se que suas classes estarão disponíveis na plataforma para instanciação.
Isso indica que, quando uma classe não é localizada para a instanciação no agente receptor do conhecimento, o objeto de conhecimento que contém o item é considerado incompatível.
Esse problema pode ser resolvido, no entanto, com a implementação de alguma política para que, nesses casos, seja solicitada a classe faltante ao agente que compartilhou o conhecimento.
O item RuleITEM, por sua vez, contém um elemento do tipo Rule (semanticore.
Agent. Kernel.
Information. Rule).
A classe Rule representa as regras explicitadas em função de o conhecimento de domínio que servem de entrada para o mecanismo decisório do agente.
As regras possuem, além de um nome, dois atributos do tipo Fact (semanticore.
Agent. Kernel.
Information. Fact):
Cause, que representa fatos ocorridos;
E consequence, que representa as conseqüências que a ocorrência de cada fato provoca.
Em o momento da aplicação de algum objeto de conhecimento as regras devem ser carregadas na máquina de inferência do componente decisório do agente.
Por último, o ActionPlanITEM tem como elemento um objeto da classe semanticore.
Agent. Execution.
Model. ActionPlan.
Como já comentado na Seção 4.3.2, cada objeto de conhecimento deve conter apenas um desses itens.
Em o SemantiCore, cada objeto da classe ActionPlan possui os seguintes elementos:
Um identificador (nome) do tipo string.
Um conjunto de ações.
Um contexto de execução (variáveis e valores) que é compartilhado com todas as ações contidas no plano.
Cada ação contida no plano de ação um objeto da classe semanticore.
Agent. Execution.
Model. Action, que possui um método abstrato chamado exec, onde deve ser inserido o código que o agente irá de fato executar para a resolução de um problema.
Em todos os itens do objeto de conhecimento específicos do SemantiCore, as ações são as únicas que possuem um atributo para a inserção do código fonte na ontologia de representação do elemento (atributo code).
Isso se dá porque as classes com os códigos das ações geralmente não são visíveis a todos os agentes do sistema, visto que freqüentemente são criadas localmente e não são disponibilizadas na plataforma para instanciação.
As ações são específicas do domínio do problema e, no caso, do objeto de conhecimento ao qual estão associadas.
Como atributos, toda ação possui um nome, uma pré e uma pós-condição (objetos do tipo Fact).
A existência de pré e pós-condição indicam que é necessária a ocorrência de um fato para disparar uma ação e também que o término de uma ação implica na criação de um fato novo.
Quando um objeto de conhecimento é aplicado, o plano de ação contido em seus itens deve ser relacionado ao objetivo do agente que disparou o processo de captura de conhecimento.
Quando é feita essa associação, o plano de ação é adicionado à lista de planos do componente executor do agente.
Em a remoção do ActionPlanITEM o plano deve ser removido tanto do componente executor quanto do objetivo ao qual está relacionado.
Em a Figura 5.7 estão representadas as ontologias criadas para os quatro últimos itens descritos.
como se pode observar na figura, para descrever as variáveis adicionadas ao contexto do plano de ação, foi criada uma owlClass Variable, que contém duas datatype properties:
Name e value.
Para cada variável presente no contexto do plano, é criado um novo indivíduo da classe Variable.
Note que a propriedade value não possui um tipo de dados definido como alvo.
Isso se dá porque as variáveis podem conter diferentes tipos de dados em seus valores.
Para que o framework pudesse ser notificado de alguns eventos ocorridos dentro de o agente ou recebidos através do ambiente, foi necessário acrescentar trechos de código em classes específicas do SemantiCore, o que será descrito a seguir.
Conforme o apresentado na Seção 5.2.1 e sintetizado na Tabela 5.1, são quatro os tipos de mensagens recebidas por o framework através do agente ao qual ele está integrado.
Para receber as mensagens internas de requisição de conhecimento, foram feitas algumas alteração na classe que representa o objetivo do agente no SemantiCore, a classe semanticore.
Domain. Model.
Goal. Em o SemantiCore, cada agente possui uma lista de objetivos e cada objetivo, por sua vez, está relacionado com um plano de ação (classe semanticore.
Agent. Execution.
Model. ActionPlan).
Toda vez que um objetivo é iniciado (seja por o recebimento de fatos do ambiente ou por solicitação do usuário) o seu plano de ação é inserido na fila de planos para execução do componente executor.
Porém, considerando- se que com o framework proposto o agente será capaz de procurar conhecimento para atingir determinado objetivo, foi criado mais um construtor na classe Goal, que permite que um objetivo seja criado sem ter, necessariamente, um plano de ação associado para a sua execução.
De essa forma, quando é iniciado um objetivo sem plano de ação associado, o framework é notificado para localizar o conhecimento necessário, tendo- se como base a ontologia contida no atributo ontology de Goal (atributo com uma ontologia que traz a descrição semântica do objetivo).
As indicações de término de execução dos planos de ação são sinalizadas ao framework por o componente executor do agente.
Toda vez que um plano sai da lista de planos em execução o componente Organizador de Conhecimento deve ser notificado.
Em esta notificação, além de o identificador do plano, é enviado o seu contexto final de execução.
Já as requisições de conhecimento externas e as respostas a solicitações de conhecimento chegam até o framework através do componente sensorial.
Para que sejam captadas as mensagens de solicitação e distribuição de conhecimento postadas no ambiente, foi criado o OrganizerSensor (subclasse de semanticore.
Agent. Sensorial.
Sensor). Através deste sensor, as mensagens cujos conteúdos contenham como tipo as strings &quot;requestKnowlede «ou &quot;deliverKnowledge «são encaminhadas ao framework para processamento.
Por último, para que o framework possa enviar mensagens por o ambiente, basta criar um objeto do tipo SemanticMessage (semanticore.
Domain. Model.
SemanticMessage) e solicitar ao componente efetuador que transmita essa mensagem (através do método SemantiCore.
Para armazenar o conhecimento homologado do sistema, onde conhecimento homologado significa o conhecimento que já foi verificado e validado por especialistas do domínio, sugere- se a criação de uma base central de conhecimento, representada por um agente da plataforma ­ o agente Bibliotecário (Librarian).
O agente Bibliotecário, assim como os demais agentes do sistema, deverá estar integrado ao framework proposto.
Seus objetos de conhecimento, no entanto, nunca serão adquiridos por sua própria experiência, visto que ele não deverá ter nenhum objetivo relacionado além de o compartilhamento de conhecimento.
O conhecimento recuperado a partir deste agente, por ser homologado, pode ser considerado mais &quot;confiável», tendo preferência no momento da seleção de conhecimento para a aplicação (essa preferência deve ser indicada na política para seleção de objetos de conhecimento para aplicação -- loadPolicy).
Também, pode- se restringir a busca por conhecimento apenas ao Bibliotecário (indicando o seu nome na lista de destinatários ­ addresseeList), o que filtra o conhecimento recebido para determinada solicitação.
Por ser um agente da plataforma, o Bibliotecário deve ser carregado juntamente com os agentes que representam os demais serviços da plataforma (como controle de mensagens e yellow pages).
Porém, isso não indica que ele deva ter uma estrutura diferenciada dos outros agentes do sistema, mas apenas que ele possui uma função especial.
A princípio, não devem ser criadas restrições de acesso para os objetos de conhecimento deste agente, visto que todos devem ser de domínio público.
Para a inclusão e o armazenamento de novos objetos de conhecimento em tempo de execução, sugere- se a criação de interfaces para a criação de objetos de conhecimento no Bibliotecário.
Posteriormente, pretende-se definir políticas para a validação do conhecimento adquirido por os agentes durante suas execuções.
Para isso, seria necessário algum tipo de mecanismo no Bibliotecário para a verificação e homologação do conhecimento recebido.
Este capítulo destacou aspectos referentes à implementação da arquitetura proposta, descrevendo os padrões e as ferramentas utilizadas no seu desenvolvimento bem como o ambiente de implementação e teste.
Foram apresentadas as principais classes do protótipo, com suas características e funcionalidades.
Também, foram ressaltados os aspectos referentes aos itens do objeto de conhecimento e à criação das estruturas ontológicas para as suas descrições.
Em o próximo capítulo será apresentado o desenvolvimento de uma aplicação, visando demonstrar a viabilidade e os ganhos alcançados com a arquitetura proposta.
O framework proposto oferece uma série de facilitadores para organizar o conhecimento de agentes de software, permitindo a recuperação e o compartilhamento de conhecimento nestas entidades.
Para ilustrar algumas dessas funcionalidades, este capítulo apresenta o desenvolvimento de uma aplicação que compreende uma solução parcial para o exemplo descrito por Berners-Lee e co-autores em.
A implementação do exemplo foi feita em linguagem Java (J2SDK), no ambiente de desenvolvimento integrado Eclipse10.
Já para a criação e edição das ontologias utilizou- se o framework Jena (versão 2.4).
Em o exemplo de Berners-Lee e co-autores, agentes interagem entre si de forma a agendar sessões de fisioterapia para um paciente.
Assim, o sistema inclui desde a entrada de dados, onde deve ser informado, por exemplo, o nome do paciente, passando por a recuperação do tratamento prescrito e por a análise das clínicas disponíveis.
A implementação dos pontos de flexibilidade do SemantiCore, cuja arquitetura é utilizada como base para a criação dos agentes do sistema, não foi necessária, visto que as implementações disponibilizadas junto com a plataforma se demonstraram suficientes.
Assim, foi necessário apenas indicar, na configuração dos agentes, as implementações que seriam utilizadas.
Para o mecanismo decisório, utilizou- se o InferenceEngine que, com o apoio do Jena, controla o disparo de objetivos e ações do agente, através de regras que definem suas pré-condições (fatos necessários para o início do objetivo ou ação).
Para captar as mensagens enviadas através do ambiente, utilizou- se a classe OWLSensor, que verifica mensagens com conteúdo em OWL.
O GenericEffector foi utilizado para permitir o envio de mensagens com diferentes conteúdos através do ambiente.
Por último, o SimpleExecutionEngine foi utilizado para controlar a execução das ações de um plano.
Este capítulo está organizado da seguinte forma:
Inicialmente, será apresentada a implementação dos pontos de flexibilidade do framework dependentes da aplicação, como os critérios de seleção e as políticas de troca e distribuição de conhecimento.
Em seguida, é descrito o exemplo de Berners-Lee e co-autores e vários aspectos do sistema desenvolvido são apresentados, como a criação dos agentes e dos objetos de conhecimento.
Para a apresentação, foram salientados os aspectos funcionais do problema e a definição das ontologias (tanto dos objetivos dos agentes quanto dos objetos de conhecimento).
No decorrer de o texto, no entanto, são apresentados alguns trechos de código fonte para auxiliar na ilustração de questões referentes à implementação.
Para a implementação dos critérios de distribuição de conhecimento foram utilizadas algumas características para a seleção de ontologias apresentadas por Tello e Gómez-Pérez em.
Em Tello e Gómez-Pérez é apresentado o OntoMetric, que é um método para a escolha e comparação de ontologias baseado numa taxonomia com 160 características chamado framework multinível de características.
Em o framework multinível de características, tem- se no primeiro nível da taxonomia cinco fatores:
Conteúdo da ontologia e organização de seus conteúdos;
Linguagem de implementação da ontologia;
Metodologia de desenvolvimento;
Ferramenta utilizada para a construção e edição da ontologia;
E custo da ontologia no projeto.
A princípio, apenas o fator conteúdo será considerado na avaliação dos objetivos pertencentes aos objetos de conhecimento, visto que todos os objetivos são formalizados em OWL, não há uma metodologia de desenvolvimento específica e não há custos associados à obtenção dos objetos de conhecimento, pois mesmo para os objetos restritos que não são de domínio público é prevista a possibilidade de compra.
Em o fator conteúdo, além de as informações relacionadas à ontologia (metadados), são citadas várias características utilizadas para medir a adequação de um ontologia candidata em relação a uma ontologia base.
Essas características são agrupadas sob alguns dos principais elementos de uma ontologia, como conceitos, relacionamentos, relações taxonômicas e axiomas.
Em se tratando dos conceitos da ontologia, características como presença de conceitos essenciais11, conceitos essenciais em níveis superiores da taxonomia e o número de conceitos da ontologia são indicados.
Já nas características para os relacionamentos contidas na ontologia, há questões como verificação da existência dos relacionamentos (ou propriedades) essenciais e verificação das características destes relacionamentos (como domínio e alvo).
Em as características quanto a a taxonomia de conceitos tem- se a verificação da profundidade máxima na hierarquia e também a média de filhos por conceito.
Por último, nas características referentes aos axiomas, é verificado, por exemplo, se os axiomas são usáveis para responder as perguntas a partir de deduções e também se eles são úteis para a verificação da consistência da ontologia.
O OntoMetric é um processo manual e subjetivo (dependente do ponto de vista do avaliador) de comparação entre ontologias.
Através de uma hierarquia de critérios ponderados, os indivíduos indicam uma pontuação (através de uma escala lingüística) aos nodos folha e essa pontuação vai se propagando até os níveis superiores da hierarquia, onde é atribuída a medida de idoneidade da ontologia candidata as necessidades do projeto.
Em o caso deste trabalho, é atribuída a medida de idoneidade de um objeto de conhecimento as necessidades expressas numa solicitação de conhecimento.
Para compor os critérios de distribuição de conhecimento foi utilizado apenas um subconjunto das características relacionadas ao fator conteúdo do OntoMetric.
Como havia muitas características subjetivas que envolviam, principalmente, o processamento de linguagem natural (para verificar, por exemplo, se os conceitos estavam bem descritos e se essa descrição estava de acordo com os atributos apresentados) a escolha dos critérios foi feita de forma a possibilitar suas avaliações automáticas (sem a interferência humana).
Em a Tabela das ontologias e duas referentes aos seus relacionamentos.
Conceitos essenciais são os conceitos que estão na ontologia de entrada para a verificação.
A presença ou não desses aspectos seria medida.
De maneira geral, a medida atribuída para cada critério é um valor percentual que indica a taxa de elementos da ontologia base que estão presentes na ontologia candidata.
Em a verificação dos conceitos essenciais, por exemplo, dado que uma ontologia candidata possui 6 dos 8 conceitos de uma ontologia base, considera- se que ela possui 75% dos conceitos essenciais.
Se desses 6 conceitos idênticos apenas 3 estão dispostos no mesmo nível da taxonomia da ontologia base, diz- se que 50% dos conceitos essenciais presentes na ontologia candidata estão no mesmo nível da taxonomia que na ontologia base ou, em outras palavras, a ontologia candidata possui 50% de conceitos essenciais em níveis similares da taxonomia.
Em a aplicação, as porcentagens atribuídas aos critérios foram convertidas numa escala numérica com valores de 1 a 5 (através da criação de uma subclasse de Converter), onde cada valor retornado está associado a um grau de adequação numa escala lingüística (coluna &quot;Grau de adequação «da Tabela 6.2).
Uma ontologia candidata que contenha 75% dos conceitos essenciais de uma ontologia de solicitação, por exemplo, possuirá um grau de adequação &quot;alto «no critério &quot;Presença de conceitos essenciais», sendo que o valor retornado será &quot;4».
A seguir, tem- se o código fonte desenvolvido para o critério C1.
1 e também um trecho de código com a instanciação e aplicação no framework de alguns dos critérios apresentados (ilustrando a instanciação do hotspot Criterion).
A ligação entre os critérios e o framework é realizada através do método setDeliverCriterion, que pertence à classe KnowledgeOrganizerComponent (&quot;organizer», no código, representa um objeto dessa classe).*
100)/ countBase);
Criterion Criterion Criterion Criterion dos objetos que representam os critérios c1.
AddSubCriterion; Além de as características utilizadas nos critérios de distribuição (relacionadas a conceitos e relacionamentos das ontologias), nos critérios de aplicação há mais um elemento a ser considerado:
O risco relacionado à não aplicabilidade do objeto.
Em este trabalho, o risco de não aplicabilidade refere- se, principalmente, à abrangência do conhecimento encapsulado no objeto de conhecimento em relação a a necessidade do agente.
Por exemplo, tem- se um objeto de conhecimento cujo objetivo possui todos os conceitos da ontologia de solicitação (dez conceitos), o que indica um grau muito alto de adequação ao critério C1.
1. Porém, na ontologia de OC1, além de os conceitos idênticos aos da ontologia da solicitação, há mais quinze conceitos, o que indica que muitos outros conhecimentos estão encapsulados no objeto.
Quanto maior o número de elementos extras na ontologia do objeto, maior é a probabilidade do conhecimento não ser aplicável à necessidade do agente, visto que muitos outros elementos não relacionados ao problema serão carregados no agente, dificultando a execução de seu objetivo.
Há casos onde o conhecimento adicional não impacta na execução do objetivo, porém, há também casos em que este conhecimento pode impossibilitar a execução, principalmente por falta de dados.
Para exemplificar um caso onde a falta de dados influência na execução do objetivo, suponhamos a seguinte situação:
Um determinado agente, AG1, possui um objetivo que envolve a compra de passagens.
Em a ontologia deste objetivo existem os conceitos &quot;Compra», Passagem e &quot;Cidade», como ilustrado na Figura 6.2 (a).
Em um determinado momento, o agente é notificado da necessidade de compra de uma passagem de Porto Alegre a Curitiba (como indicado na Figura 6.2 (b), que mostra os dados para a execução do objetivo).
Depois de solicitar conhecimento para o objetivo descrito, AG1 seleciona um objeto de conhecimento para aplicação cujo objetivo está ilustrado na Figura 6.3.
Como pode ser visto na Figura 6.3, o objetivo do objeto de conhecimento selecionado possui uma classe adicional:
A &quot;EmpresaTransporte».
Se os dados dessa classe forem obrigatórios para a execução de qualquer ação relacionada ao objeto de conhecimento (por exemplo, pode existir uma ação em que dados da empresa de transporte sejam necessários para a verificação da disponibilidade de passagens), não será possível utilizar esse objeto para o objetivo descrito, visto que faltarão dados para a execução.
O cálculo do risco associado ao objeto é feito considerando- se a porcentagem de elementos extras de seu objetivo (em relação a a solicitação de conhecimento).
A porcentagem calculada indica a taxa de elementos não equivalentes da ontologia candidata de acordo com o seu total de elementos.
Em o exemplo ilustrado anteriormente, cuja ontologia do objeto de conhecimento possuía 25 conceitos e desses conceitos 15 não estavam na ontologia de solicitação, tem- se um percentual de 60% de conceitos extras, o que indica um risco de grau médio, como pode ser visto na Tabela 6.3, que apresenta o risco de aplicabilidade de um objeto de conhecimento através do uso de um conversor para o qual, quanto maior a porcentagem atribuída, menor é o valor de retorno.
Como pode ser visto na Figura 6.4, que traz a hierarquia de critérios para a aplicação, os critérios para a verificação de conceitos e propriedades extras são subcritérios, respectivamente, dos critérios &quot;C1( «Quanto a conceitos&quot;) e &quot;C2( «Quanto a propriedades&quot;).
Em os critérios de aplicação foram utilizados dois tipos de conversores:
Conversor crescente (Tabela 6.2) para o qual, quanto maior o valor de entrada (porcentagem calculada nos critérios) maior é o valor final atribuído;
conversor decrescente onde, quanto maior o valor de entrada, menor é o valor de retorno.
Em os critérios C1.
1, C1.
2, C2.
1 e C2.
2 é utilizado o conversor crescente, visto que, quanto mais elementos semelhantes existirem entre as ontologias, maior deve ser a pontuação final do objeto.
Já nos critérios de verificação de risco, é utilizado o conversor decrescente onde, quanto maior a incidência de elementos divergentes, menor é o valor de retorno, o que diminui a nota final do objeto.
Para classificar a execução dos objetos de conhecimento foi criada a SimpleGoalCriterion, que é subclasse de Criterion.
Todos os objetivos dos objetos de conhecimento estão associados a essa classe para a verificação da execução.
Em o método evaluate (herdado de Criterion) é verificado o número de sentenças verdadeiras de acordo com o contexto do final da execução do plano.
As sentenças são os objetos da classe Sentence associados ao objetivo do objeto de conhecimento (classe KOGoal).
Com o número de sentenças verdadeiras é verificada a porcentagem de sentenças satisfeitas.
A porcentagem recuperada, da mesma forma que nos critérios para distribuição e aplicação de conhecimento (apresentados na seção anterior), é transformada para um valor de uma escala numérica com o uso de um conversor crescente (Tabela 6.2) o que indica que, quanto maior a porcentagem atribuída, melhor (mais favorável) é o resultado da execução.
Sendo que a classificação da execução dos objetos de conhecimento é feita numa escala numérica com valores de 1 a 5, para a avaliação do histórico de execução de um objeto de conhecimento definiu- se a seguinte política de troca:
A cada 5 execuções de um mesmo objeto de conhecimento com classificação menor ou igual a 3, deve ser feita a substituição do conhecimento vigente.
Para implementar essa política de troca foi criada uma nova classe, a MaxOccurPolicy, que é subclasse de ChangePolicy.
Em o seu método checkHistory, onde se tem como entrada uma lista com todas as avaliações para um determinado objeto de conhecimento, é feito um somatório das execuções com classificação com valor menor ou igual a 3.
Se o resultado do somatório for igual a 5 é retornado o valor verdadeiro, que significa que será iniciado o processo de captura de novos conhecimentos para o objetivo do agente em o qual o objeto de conhecimento está relacionado.
Caso contrário, é retornado o valor falso, que não dispara nenhuma ação.
Para a distribuição de conhecimento, considerou- se apenas o envio do objeto mais compatível (com maior pontuação), de acordo com a solicitação recebida, para o agente solicitante.
Porém, há duas exceções:
Se nenhum dos objetos disponíveis localmente possui uma pontuação maior ou igual a 3 (grau de adequação médio), não serão enviados objetos de conhecimento como resposta à solicitação;
E caso haja empate na primeira posição, todos os objetos com maior pontuação são enviados.
O agente que representa a base de conhecimento central, no entanto, possui uma política de distribuição um pouco diferente:
Já na política de aplicação de conhecimento, seleciona- se o objeto de conhecimento com maior pontuação recebido, independentemente do seu valor de adequação.
Caso haja incompatibilidade na aplicação de qualquer item do objeto de conhecimento selecionado, remove- se este objeto da lista de objetos recebidos e o método selectKObjects (da classe SelectionPolicy) é novamente executado.
Esse processo é executado até que se possa aplicar de fato um objeto de conhecimento (carregar todos os seus itens) ou que a lista de objetos recebidos esteja vazia.
Em este último caso, considera- se que não há conhecimento compatível no sistema para a solicitação efetuada e o objetivo do agente não será executado.
Para demonstrar a viabilidade e o uso de algumas características do framework, a seguir serão apresentados alguns aspectos da implementação do exemplo apresentado por Berners-Lee e co-autores.
Para um melhor entendimento, o texto foi dividido em quatro seções, onde são apresentados, respectivamente, a descrição do problema, os agentes criados, os objetos de conhecimento disponíveis e a solução parcial proposta.
Pete e Lucy (dois irmãos) precisam agendar um tratamento médico (sessões de fisioterapia) para a mãe, que será chamada de Marie ao longo de o exemplo.
Tanto Pete quanto Lucy possuem agentes pessoais (personal &quot;Semantic Web agents&quot;) aos quais atribuem diversas tarefas.
A interação para o agendamento das sessões de Marie inicia quando Lucy atribui a seu agente pessoal a tarefa de arranjar automaticamente as sessões de fisioterapia.
O agente de Lucy executa, então, várias tarefas:
Recupera informações do tratamento prescrito com o agente do médico de Marie, procura clínicas capazes de executar o tratamento necessário;
Seleciona as melhores clínicas considerando a cobertura do plano de saúde de Marie (se a clínica está cadastrada junto ao plano de saúde), o posicionamento da clínica num ranking (só deverão ser selecionadas clínicas com pontuação &quot;excelente «ou &quot;muito bom&quot;) e a distância da casa de Marie até a clínica (a clínica deve estar num raio de 20 milhas);
Por último, é apresentado um plano com os horários das consultas e as informações de transporte.
Feito isso, o agente de Lucy entra em contato com o agente de Pete para expor o plano proposto e verificar se ele é satisfatório.
Pete, no entanto, rejeita o plano devido a a localização da clínica indicada e o horário das sessões (para levar a mãe às sessões, Pete necessitaria dirigir na hora do rush) e solicita a seu agente que desenvolva um plano diferente que se ajuste melhor a sua agenda, considerando a localização e o horário.
Depois de instantes, o agente de Pete apresenta um novo plano com uma clínica com melhor localização e horários ­ mas há duas advertências:
Pete deve reagendar um compromisso marcado como &quot;baixa importância «(o que não é um problema para Pete);
E a clínica selecionada não consta na lista de &quot;Fisioterapia «do plano de saúde (mas o agente indica que o tipo de serviço e a ligação da clínica com o plano de saúde foram seguramente verificados por outros meios).
Lucy aceita o novo plano sugerido.
A solução proposta para o exemplo descrito conta com nove diferentes agentes no SemantiCore.
O AgLucy é o agente pessoal de Lucy e possui uma série de objetivos, sendo que um de eles é denominado &quot;SelecionarClinicas», através de o qual o agente pode encontrar uma clínica apropriada para a realização de um tratamento prescrito por um médico a um paciente.
Para a execução deste objetivo, é necessário informar ao agente o nome do paciente, o nome do médico onde deve ser recuperado o tratamento, o nome do plano de saúde (caso seja necessário restringir a busca por clínicas associadas a um plano de saúde), as coordenadas do endereço do paciente e a distância máxima da casa do paciente à clínica selecionada (caso haja essa restrição).
A Figura 6.5 ilustra, em notação UML, a ontologia deste objetivo do agente.
O AgPete, por sua vez, representa o agente pessoal de Pete.
Ele também possui, entre os seus objetivos, o objetivo &quot;SelecionarClinicas».
O AgDrLee, é o agente que representa o médico de Marie.
Para prover informações sobre os tratamentos prescritos, AgDrLee possui um objetivo denominado &quot;InformarTratamento», que é disparado cada vez que chega uma solicitação de informações de tratamento de um determinado paciente.
Os dados dos tratamentos dos pacientes são armazenados localmente através de instâncias da estrutura ontológica que representa o tratamento prescrito (ilustrada na Figura 6.6).
Cada instância desta ontologia representa as informações do tratamento de um determinado paciente.
O objetivo &quot;InformarTratamento «é disparado com a chegada dos seguintes fatos:
Como pode ser visto nos fatos, &quot;InformarTratamento «só é disparado quando for recebida uma mensagem onde o conteúdo contenha um indivíduo&quot;?
M &quot;cujo tipo indivíduo da classe Paciente( «ns:
Paciente&quot;) com um nome associado (variável&quot;?
Nome&quot;). O &quot;ns «de «ns:
Tipo «refere- se a uma indicação do namespace12 da ontologia através de um prefixo.
O namespace define um vocabulário controlado que identifica um conjunto de conceitos de forma única.
Quando um objetivo do agente inicia sua execução, seu plano de ação é automaticamente carregado no componente executor.
O objetivo &quot;RecuperarTratamento «está associado a um plano de ação que contém apenas uma ação, a &quot;EnviarTratamento».
Em esta ação, é verificado o tratamento existente para o paciente cujo nome disparou a execução do objetivo e é enviada uma resposta com todas as informações do tratamento ao agente solicitante.
A seguir está o código inserido no método setup de AgDrLee (subclasse de semanticore.
Domain. Model.
SemanticAgent do SemantiCore) para a criação dos fatos que compõem a pré-condição, do plano de ação e das ações do objetivo &quot;RecuperarTratamento».
AgPlanoSaude representa o agente do plano de saúde de Marie no sistema e possui uma lista de especialidades médicas (como fisioterapia, cirurgia geral, obstetrícia, entre outros) onde, para cada especialidade há uma série de clínicas e médicos associados.
Com a chegada de uma solicitação de clínicas para uma determinada especialidade (contidas nas palavras-chave do tratamento), é acionado o objetivo &quot;BuscarClinicas «que, ao ser executado (execução do plano de ação associado), recupera todas as clínicas disponíveis na especialidade solicitada e as envia ao agente solicitante.
Para ser disparado o objetivo &quot;BuscarClinicas», o seguinte conjunto de fatos deve ser recebido por AgPlanoSaude:
Em AgPlanoSaude, as informações de cada clínica estão explicitadas dentro de uma estrutura ontológica, que deve ser uma instância da ontologia representada na Figura 6.7.
Em o momento do envio das informações das clínicas, toda a ontologia de dados da clínica selecionada (ou clínicas selecionadas) é enviada.
O AgAvaliador possui um ranking com a classificação de clínicas e serviços.
Cada vez que é recebida uma lista com um ou mais prestadores de serviços, AgAvaliador verifica a classificação dos prestadores de serviços recebidos e as envia para o agente solicitante.
Para tanto, ele possui um objetivo denominado &quot;VerificarClassificação «que inicia sempre que é recebida uma mensagem cujo conteúdo contenha um indivíduo com uma propriedade &quot;tipo «com o valor &quot;VerificarClassificacao».
AgAnne é um agente adicional (que não está especificado na descrição do problema) que foi criado para exemplificar o mecanismo de busca de conhecimentos do framework.
Ele representa a secretária de um médico e possui um bom conhecimento de como agendar consultas e tratamentos.
Ainda para exemplificar as funcionalidades do framework, foram criados quatro agentes que representam quatro diferentes clínicas, cada qual com suas especialidades.
Esses agentes são chamados de AgClinica1, AgClinica2, AgClinica3 e AgClinica4.
Todo agente que representa uma clínica possui um objetivo denominado &quot;OferecerServicos», que é inicializado sempre que é recebida a solicitação de um serviço de algum agente do sistema.
Caso a clínica ofereça o serviço solicitado, é enviada uma notificação ao agente solicitante.
Por fim, foi criado o agente Librarian que, como especificado na Seção 5.2.4, representa a base de conhecimento central do framework.
Esse agente não possui nenhum objetivo associado, visto que irá apenas compartilhar objetos de conhecimento.
Foram criados, ao todo, quatro objetos de conhecimento no sistema.
Três desses objetos estão disponíveis no agente Librarian e são de domínio público (não possuem restrições associadas).
O quarto objeto de conhecimento (&quot;KO-4&quot;) pertence ao agente AgAnne.
O objeto de conhecimento &quot;KO-1 «encapsula o conhecimento necessário para a compra e venda de passagens.
Já o objeto &quot;KO-2 «encapsula o conhecimento para o agendamento de tratamentos e consultas, sem a verificação do plano de saúde do paciente ou sua localização.
O objeto &quot;KO-3», também envolve o agendamento de tratamentos, dessa vez, considerando o plano de saúde do paciente e sua localização.
Por último, o objeto &quot;KO-4 «encapsula um conhecimento diferenciado para o agendamento de tratamentos, onde as solicitações são feitas diretamente aos agentes que representam as clínicas.
Como cada clínica, ao responder uma solicitação de serviço, indica os planos de saúde aceitos, existem regras para a verificação da cobertura do plano de saúde em &quot;KO-4».
Os objetivos dos quatro objetos de conhecimento são mostrados nas figuras 6.8, 6.9, 6.10 e 6.11 (a descrição completa de todos os itens dos objetos de conhecimento criados é feita no Apêndice A).
O objetivo de &quot;KO-1 «possui as seguintes sentenças para a verificação da execução (objetos da classe Sentence):
&quot;Sentence Subject Operator Value «&quot;duracaoF «&quot;custoF «&quot;dpF «&quot;mtF «&quot;custoF «&quot;duracaoMax «&quot;custoMax «&quot;dataPartida «&quot;meioTransporte «&quot;custoMax&quot;/ 2 Em as sentenças de &quot;KO-1 «tanto os sujeitos (subject) quanto os valores (value) são variáveis que devem ser recuperadas no contexto de execução do plano finalizado.
As variáveis presentes no campo value armazenam as informações ou fatos responsáveis por a inicialização do objetivo e devem estar acessíveis, portanto, para a verificação de sua execução.
Os objetivos de &quot;KO-2», &quot;KO-3 «e &quot;KO-4 «possuem apenas uma sentença de verificação associada.
De acordo com esta sentença (escrita abaixo), o objetivo é satisfeito se o número de clínicas sugeridas para o usuário for maior que zero, ou seja, se pelo menos uma clínica for encontrada.
&quot;Sentence Subject «&quot;numClinicas «Operator Value Em o código escrito a seguir, tem- se um trecho da implementação de AgAnne e da criação dos itens de seu objeto de conhecimento, o &quot;KO-4».
KnowledgeOrganizerComponent organizer $= new KnowledgeOrganizerComponent (this, &quot;organizer&quot;);
OntModel selecionarClinicas $= ModelFactory.
CreateOntologyModel (OntModelSpec.
OWL_ MEM, null);
Sensor sensor $= new OWLSensor (&quot;sensorKO-4», new SimpleFact(&quot;?
Id», KnowledgeObject ko4.
AddItem (new ko4.
AddItem (new objeto de conhecimento GoalITEM (goal));
SensorITEM (sensor));
Organizer. KnowledgeBase.
StoreKnowledge (ko4);
A seguir, será descrita uma proposta inicial de implementação para o exemplo apresentado por Berners-Lee e co-autores, considerando- se, principalmente, aspectos referentes à busca, compartilhamento e aplicação de objetos de conhecimento.
O uso de diferentes objetos de conhecimento permite que AgPete, por exemplo, seja melhor sucedido O desenvolvimento desta aplicação visa apenas exemplificar as funcionalidades do framework desenvolvido e não propor uma solução completa para o exemplo apresentado por Berners-Lee.
Em este contexto, não foram verificados, nesta primeira implementação, aspectos referentes à disponibilidade de horários nas agendas de Lucy e Pete, ou seja, apenas são propostas as melhores clínicas para o tratamento de Marie, mas os horários não são agendados automaticamente.
Como já mencionado, a execução inicia quando Lucy solicita a AgLucy o início da execução do objetivo &quot;SelecionarClinicas», tendo- se como base os seguintes fatos (dados de entrada para a execução do objetivo):
Note que, inicialmente, é criado um indivíduo da classe «ns:
Paciente &quot;cuja similar, nas linhas 3 a 6 são criados indivíduos da classe «ns:
Medico &quot;e «ns:
PlanoSaude», com seus respectivos nomes.
Em as demais linhas são indicadas a localização de Marie e a distância máxima permitida entre a localização de Marie e a localização da clínica selecionada.
Para demonstrar o mecanismo de busca de conhecimento do framework, definiu- se que AgLucy não possui, a priori, o conhecimento necessário para atingir o objetivo &quot;SelecionarClinicas», ou seja, o objetivo não está relacionado a nenhum plano de ação.
Também, AgLucy possui uma política de solicitação de conhecimento restrita, onde o conhecimento faltante é procurado apenas na base local de conhecimento e no agente Librarian (na lista de destinatários de mensagens de solicitação ­ addresseeList -- consta apenas &quot;local «e &quot;Librarian&quot;).
Depois de fazer solicitação de conhecimento para objetivo &quot;SelecionarClinicas», AgLucy recebe do agente Librarian dois objetos de conhecimento:
&quot;KO-2 «e &quot;KO-3».
Ambos os objetos receberam pontuação maior que 3 na verificação dos critérios de distribuição de Librarian e, devido a sua política de distribuição (envio de todos os objetos com pontuação maior que 3), foram enviados como resposta a AgLucy.
Em a Tabela 6.4 está ilustrado o número total de conceitos e propriedades da solicitação enviada e também dos objetos de conhecimento disponíveis em Librarian (dados utilizados na computação da porcentagem).
Já a Tabela 6.5 ilustra a pontuação atribuída a cada critério para os objetos de conhecimento &quot;KO-2 «e &quot;KO-3».
As pontuações de &quot;KO-1 «não estão representadas na tabela, porque o conhecimento encapsulado neste objeto não tem qualquer relação com o conhecimento solicitado (não há nem conceitos nem propriedades semelhantes).
Em este caso, todos os critérios são avaliados com um grau de adequação &quot;muito baixo «e a nota final atribuída ao objeto é &quot;1».
Tabela 6.5: Pontuação atribuída aos objetos por os critérios de distribuição em Librarian Critérios Grau Grau Como pode ser visto na Tabela 6.6, &quot;KO-3», mesmo possuindo um número considerável de elementos extras (o que diminui sua pontuação final devido a o risco de não aplicabilidade), ainda possui um grau de adequação maior que &quot;KO-2 «quando pontuado através dos critérios de aplicação de AgLucy.
&quot;KO-3 «foi, portanto, o objeto selecionado para aplicação.
Depois de aplicar &quot;KO-3», AgLucy executou as seguintes ações encadeadas (contidas no plano de ação associado a &quot;KO-3&quot;):
Adquirir prescrição médica:
É através desta ação que o agente do usuário entra em contato com o agente do médico para recuperar o tratamento prescrito.
Em o exemplo, AgLucy entra em contato com AgDrLee para recuperar o tratamento de Marie.
Recuperar lista de serviços do plano de saúde:
Com base nas informações adquiridas a partir de o tratamento prescrito, é solicitado ao agente que representa o plano de saúde do paciente (AgPlanoSaude) uma lista com as serviços disponíveis (que atendam as especialidades informadas no tratamento).
A indicação de busca por serviços e não especificamente por clínicas se dá porque &quot;KO-3 «não trabalha apenas com a recuperação de informações de clínicas, mas informações de farmácias, médicos e clínicas.
Recuperar qualificação:
É através desta atividade que as informações dos serviços disponíveis no plano de saúde são encaminhadas ao agente AgAvaliador para serem avaliadas.
AgAvaliador retorna uma lista com os prestadores de serviços juntamente com as suas qualificações (excelente, muito bom, regular, ruim, muito ruim).
Calcular distância:
Com base nas informações de localização do prestador de serviço recuperado e na endereço do paciente (já disponível no agente) é calculada a distância da casa do paciente à clínica.
Selecionar clínicas candidatas:
De posse da lista de prestadores de serviços, de suas qualificações e da distância até casa de paciente, são selecionados os melhores serviços para o tratamento.
De acordo com a descrição do exemplo, para um serviço (no caso uma clínica) ser selecionado, ele deve estar localizado a uma distância menor que 20 milhas da casa do paciente e sua qualificação deve ser &quot;excelente «ou &quot;muito bom».
Como os serviços são recuperados diretamente do plano de saúde, não é necessário refazer a verificação da cobertura do plano.
Depois de selecionadas as clínicas, o usuário é notificado para que faça a aceitação do plano.
Lucy, sem ter nenhuma objeção às clínicas selecionadas, solicita que AgLucy envie a lista a AgPete para que Pete tome conhecimento do plano.
Como foram encontradas clínicas para a execução do tratamento, a sentença para a classificação da execução do objetivo &quot;SelecionarClinicas «(apresentada na Seção 6.2.3) foi satisfeita, o que resulta numa classificação de execução com valor &quot;5 «(100% das sentenças foram satisfeitas).
Conforme a descrição do problema, Pete não fica satisfeito com a lista recuperada por AgLucy e solicita que AgPete refaça a busca.
AgPete, da mesma forma que AgLucy, possui o objetivo &quot;SelecionarClinicas «sem nenhum conhecimento associado.
AgPete, no entanto, possui uma política de busca de conhecimento diferente de AgLucy:
Suas solicitações de conhecimento são enviadas para todos os agentes registrados na plataforma.
Assim, como resposta a sua solicitação, AgPete recebe do agente Librarian os objetos de conhecimento &quot;KO-2 «e &quot;KO-3», de AgLucy o objeto de conhecimento &quot;KO-3 «e de AgAnne, o objeto &quot;KO-4».
Como o conhecimento solicitado por AgPete é idêntico ao solicitado por AgLucy, os objetos de conhecimento disponíveis em Librarian terão a mesma pontuação apresentada na Tabela 6.5 para a solicitação de AgPete.
A pontuação atribuída a &quot;KO-3», em AgLucy, também é idêntica à pontuação dada por Librarian, visto que ambos possuem os mesmos critérios para distribuição de conhecimento.
Já em AgAnne, o objeto de conhecimento &quot;KO-4 «é avaliado conforme o indicado na Tabela 6.7.
A o avaliar os quatro objetos de conhecimento recebidos, AgPete seleciona o objeto &quot;KO-4», que alcança a maior pontuação com o uso dos critérios de aplicação, como pode ser visto na Tabela 6.8.
Observe que &quot;KO-4», mesmo tendo uma pontuação menor que &quot;KO-3 «na distribuição (avaliado com os critérios de distribuição), possui um menor risco de não aplicabilidade, o que acaba aumentando o sua pontuação na avaliação para a aplicação.
Com o uso de &quot;KO-4», a recuperação da lista de clínicas não é feita com base na cobertura do plano de saúde (como era em &quot;KO-3», que foi utilizado por AgLucy), mas sim através de solicitações de serviços a todos os agentes do sistema, como pode ser visto na descrição das ações de seu plano de ação associado:
Adquirir prescrição médica:
De a mesma forma que em &quot;KO-3», é através desta ação que o agente do usuário entra em contato com o agente do médico para recuperar o tratamento prescrito para o paciente.
Solicitar serviços:
Recuperar qualificação:
De a mesma forma que &quot;KO-3», é através desta atividade que as informações das clínicas recuperadas são encaminhadas ao agente AgAvaliador para serem avaliadas.
Calcular distância:
Também, de forma idêntica que em &quot;KO-3», através desta ação é calculada a distância entre a clínica e a casa do paciente.
Selecionar clínicas:
De posse da lista de clínicas, de suas qualificações e da distância da casa do paciente, são selecionadas as melhores clínicas para o tratamento.
Para uma clínica ser selecionada, conforme a descrição do problema, ela deve estar a uma distância menor que 20 milhas da casa do paciente, sua qualificação deve ser &quot;excelente «ou &quot;muito bom «e deve ter cobertura do plano de saúde do paciente.
Depois de selecionadas as clínicas, é solicitada a aceitação do plano.
AgPete, utilizando o objeto de conhecimento &quot;KO-4 «identificou uma clínica a mais de o que AgLucy, isto porque AgPlanoSaude, quando consultado por AgLucy, verificou apenas as clínicas presentes na especialidade &quot;Fisioterapia «e a &quot;Clinica2», erroneamente, encontra- se apenas na lista de &quot;Centros médicos», mesmo dispondo de serviços de fisioterapia.
De acordo com a descrição do problema, Pete fica satisfeito com a nova lista de clínicas encontradas por o seu agente e aceita a indicação de &quot;Clinica2 «para o tratamento de sua mãe.
Selecionada a clínica, ainda é necessário agendar as sessões de fisioterapia, o que poderia ser feito automaticamente com o uso de outros objetos de conhecimento.
O exemplo de aplicação descrito neste capítulo procurou mostrar, em linhas gerais, as primitivas do framework proposto e a forma de usar- las na definição dos objetos de conhecimento e na criação dos agentes.
Como pôde ser visto ao longo de o capítulo, o uso do framework, uma vez implementados os pontos de flexibilidade, não traz um aumento significativo de trabalho aos desenvolvedores, salvo as questões referentes à divisão do conhecimento em objetos de conhecimento e à definição de uma ontologia para representar o conhecimento encapsulado, aspectos esses que poderiam ser considerados complexos não do ponto de vista de desenvolvimento, mas de entendimento do problema.
Com o uso do framework é possível indicar uma série de objetivos aos agentes durante suas inicializações sem necessariamente definir como que esses objetivos serão executados (como no objetivo &quot;SelecionarClinicas&quot;).
Em o momento que um determinado objetivo for de fato executado, o conhecimento necessário é então localizado e carregado automaticamente.
Como o conhecimento recuperado muitas vezes tende a ser apenas similar ao conhecimento solicitado, pode haver incompatibilidade entre o conhecimento recuperado e o objetivo do agente, o que piora a classificação da execução.
Porém, se isso ocorrer, o conhecimento carregado será substituído por outro conhecimento, através do uso do histórico de execução.
O uso de objetos de conhecimento pode permitir, de fato, um melhor aproveitamento do conhecimento existente, visto que um mesmo objeto pode ser utilizado por vários agentes e em várias situações.
Também, a existência de pontos de flexibilidade para a avaliação e seleção dos objetos de conhecimento possibilita que eles sejam avaliados e selecionados de acordo com os mais diferentes fatores.
Durante a descrição do exemplo, não foram salientadas as questões referentes ao histórico de execução e a política de troca, devido a não aplicabilidade destes conceitos no exemplo utilizado.
Posteriormente, pretende-se desenvolver uma aplicação mais abrangente, com mais agentes interagindo e negociando a fim de atingir seus objetivos.
Considerando- se a importância da GC para prover um ambiente em que exista compartilhamento de conhecimento com suporte ao armazenamento e recuperação de informações, o presente trabalho apresentou o desenvolvimento de um framework para a organização do conhecimento de agentes de software que possibilita, entre outras coisas, o reuso do conhecimento existente, visto que o conhecimento pode ser compartilhado entre os agentes e utilizado em diferentes situações e contextos, e a substituição do conhecimento ineficiente, através da análise do histórico de execução.&amp;&amp;&amp;
Para a apresentação, o trabalho foi estruturado dentro de três fases distintas.
Em a primeira fase, foram esclarecidos aspectos das tecnologias relacionadas ao trabalho e também foi feito um levantamento na literatura sobre abordagens relacionadas à organização do conhecimento de agentes de software, a fim de identificar trabalhos relacionados.
A segunda fase foi caracterizada por a descrição de aspectos, tanto conceituais quanto de implementação, do framework proposto.
Em a terceira e última fase, o desenvolvimento de uma aplicação foi apresentado.
Para iniciar a apresentação dos aspectos conceituais do framework, foi descrito o processo de GC utilizado como guia, esclarecendo as características envolvidas com cada uma de suas atividades.
A capacidade de adquirir novos conhecimentos, por exemplo, sugere que os agentes podem identificar uma necessidade de conhecimento, representar essa necessidade de forma que seja compreendida por os outros agentes do sistema, e selecionar e aplicar o conhecimento mais similar recebido.
Já para que haja distribuição de conhecimento, os agentes devem ser capazes de receber uma solicitação de conhecimento, verificar qual o conhecimento disponível mais similar à solicitação recebida e enviar o conhecimento selecionado ao agente solicitante.
A estruturação do conhecimento disponível nos agentes foi feita através dos objetos de conhecimento.
Para a representação tanto dos objetos de conhecimento quanto das mensagens para compartilhamento de conhecimento, foram utilizadas ontologias.
De acordo com Staab e co-autores, &quot;ontologias constituem o meio para juntar todos os subprocessos de conhecimento (criação, captura, recuperação, acesso, e uso de conhecimento) «(STAAB, Para a definição de alguns aspectos do framework, trabalhou- se com a idéia de que os agentes possuem objetivos e que esses objetivos, por sua vez, devem estar relacionados a um conjunto de ações ou comportamentos que permitam que o agente execute tarefas a fim de atingir o objetivo especificado.
Em o momento da aplicação de um objeto de conhecimento, considerou- se que o conhecimento contido no objeto cobria totalmente o objetivo do agente ao qual ele estava sendo relacionado, ou seja, executando- se as ações contidas no objeto de conhecimento poderia- se- atingir o objetivo especificado.
De essa forma, um objetivo do agente está relacionado a apenas um objeto de conhecimento por vez.
No entanto, outras abordagens poderiam ser implementadas imaginando- se, por exemplo, que para o alcance de um objetivo pode ser necessário o conhecimento de diferentes objetos de conhecimento, sendo que cada objeto contribuiria parcialmente para a execução.
Algumas vezes, mesmo com o objetivo do objeto de conhecimento altamente similar ao objetivo do agente, pode haver incompatibilidade entre eles.
Isso ocorre, principalmente, quando o conhecimento presente no objeto de conhecimento é mais abrangente do que o especificado no objetivo do agente.
Em estes casos, alguns itens do objeto de conhecimento podem ter sua execução bloqueada ou paralisada por falta de dados.
Adaptar os itens do objeto de conhecimento ao objetivo do agente está fora de o escopo deste trabalho.
O modelo conceitual proposto, juntamente com a implementação das primitivas do framework, constitui a principal contribuição deste trabalho, auxiliando na formalização e no compartilhamento de conhecimento em agentes de software.
Em uma visão mais detalhada, as contribuições deste trabalho são:
Identificação de aspectos da implantação de um processo de GC numa arquitetura de agentes.
Definição de um modelo conceitual para o uso de um processo de GC em arquiteturas de agentes.
Implementação das primitivas do framework, o que possibilita sua integração a plataformas de desenvolvimento de SMAs e o desenvolvimento de aplicações para validar o modelo proposto.
Apresentação do desenvolvimento de aplicações, o que visa guiar os projetistas na definição e implementação dos pontos de flexibilidade do framework.
A não implementação do fluxo de criação e representação de novos conhecimentos, se deu principalmente por os desafios envolvidos com a criação e validação automatizada de novos conhecimentos.
Avaliar se um conhecimento é mais útil que os já existentes não é uma tarefa trivial, visto que os resultados da aplicação ou do uso de determinado conhecimento estão fortemente relacionados com o contexto em o qual o agente ou indivíduo está inserido no momento da execução da tarefa.
Assim, trabalhos futuros centram- se em estudar, principalmente, questões relacionadas com a aquisição e organização de novos conhecimentos em agentes, considerando- se seus contextos de execução e também suas experiências passadas (histórico de execução).
Outros trabalhos futuros seriam a definição e implementação de um estudo de caso mais abrangente, a exploração do mapeamento do framework sobre outras plataformas para o desenvolvimento de SMAs e a definição de um método para orientar os desenvolvedores na criação de agentes e de objetos de conhecimento de acordo com as primitivas do framework proposto.
