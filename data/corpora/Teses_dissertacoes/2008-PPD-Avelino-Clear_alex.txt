Com a evolução das metodologias de desenvolvimento de software, novos desafios vão surgindo junto com este avanço.
Um dos desafios fica a cargo de como garantir a qualidade do software desenvolvido.
Diversos pesquisadores desenvolvem continuamente diversas abordagens de teste de software para acompanhar esta evolução.
Uma das abordagens que visa prover o aumento da qualidade é através de testes de software baseados em modelos.
Existem diversas formas de realização de testes de software baseados em modelos, garantindo um amplo leque de possibilidades.
Uma forma de integrar estas possibilidades é através da aplicação dos conceitos de linha de produtos de software.
Este trabalho propõe a realização de uma arquitetura de linha de produtos de software para integrar as diferentes técnicas de testes baseados em modelos.
Palavras-chave: Teste baseado em modelos, UML, Linha de produtos de software, Arquiteturas de software, Programação baseada em componentes.
A etapa de testes é vital no processo de desenvolvimento de software, onde busca identificar potenciais defeitos de software que podem resultar em perda de recursos financeiros, propriedades, clientes ou vidas.
Teste é uma atividade essencial em Engenharia de Software.
Em termos simples, é a observação da execução de um sistema de software para validar se a execução comporta- se como o esperado e identificar potenciais defeitos.
Testes são amplamente usados na indústria para medida de qualidade:
Sem dúvida, ao examinar diretamente o software em execução, são providas informações realísticas do seu comportamento, entretanto é necessário utilizar outras técnicas de análise complementares.
Através da aparente simplicidade ao checar um exemplo em execução, testes englobam uma variedade de atividades, técnicas e atores, possuindo muitos desafios complexos.
Certamente, com a complexidade, pervasividade e criticalidade do crescimento incessante dos softwares, garantir que os softwares comportam- se de acordo com os níveis desejáveis de qualidade torna- se mais crucial, sendo fator do aumento da dificuldade e do custo de desenvolvimento.
Estudos estimam que os testes podem consumir cinqüenta por cento, ou até mais, do custo de desenvolvimento.
Teste de software é um termo genérico que engloba um vasto espectro de diferentes atividades, desde o teste de uma pequena parte do código realizado por o desenvolvedor até a validação do usuário de um complexo sistema de informação.
Em vários estágios, os casos de teste podem ser planejados em direção a diferentes objetivos, como expor o tangenciamento dos requisitos do usuário, estimar a conformidade de uma especificação padrão, avaliar a robustez para condições de cargas estressantes ou para entradas maliciosas ou medir determinados atributos, tais como desempenho ou usabilidade, ou estimar a confiabilidade operacional, entre outros.
Além disso, a atividade de teste pode ser portada de acordo com um procedimento informal e ad hoc, ou formal controlado (exigindo um planejamento e documentação rigorosos).
Como uma conseqüência desta variedade de foco e escopo (conforme citado anteriormente), existe uma multiplicidade de significados para o termo &quot;teste de software», gerando muitos desafios peculiares de pesquisas.
Para organizar os desafios numa visão unificada, é apresentada uma classificação de problemas comuns para os muitos significados sobre teste de software.
O primeiro conceito seria qual é o denominador comum, se ele existir, entre todas as possíveis &quot;faces «de teste diferentes.
Um denominador comum pode ser a visão muito abstrata que, dado uma parte de software (não importa qual seja sua tipologia, tamanho e domínio) o teste sempre consiste da observação de uma amostra de execuções, dando um veredito através desta observação.
Iniciando dessa visão muito generalista, pode- se então concretizar diferentes instâncias, por a distinção de aspectos específicos que podem caracterizar a amostra de observações, tais como:
Porque se constroem as observações (onde a preocupação é com o objetivo do teste);
Quais amostras devem ser observadas, e como escolher- las;
Quão grande é uma amostra;
O que é executado (pode- se observar a execução ou do sistema como um todo ou no ciclo de vida, que será efetuada a observação.
Estas questões provêm uma caracterização de um esquema muito simples e intuitivo de atividades de testes de software, que podem ajudar na organização de um plano para os desafios das pesquisas.
A automação de testes de software pode reduzir drasticamente o esforço requerido para as atividades de teste.
Através da automação, os testes podem ser realizados em minutos ao invés de demorarem horas para serem executados manualmente, podendo alcançar uma diminuição de esforço em mais de 80%.
Algumas organizações podem não reduzir gastos ou esforços diretamente, mas a automação dos testes permite produzir softwares de melhor qualidade mais rapidamente do que seria possível através de testes manuais.
Um regime maduro de automação de testes permite ao &quot;toque de um botão «que testes sejam realizados durante toda a noite, período onde a infra-estrutura normalmente estaria sem uso.
Testes automatizados permitem até a menor alteração no sistema ser completamente re-testada com um mínimo de esforço, eliminando tarefas consideradas repetitivas e desgastantes.
Uma solução de automação de testes é através da geração de casos de testes a partir de modelos, conhecida como testes baseados em modelos.
Existem diferentes técnicas de testes baseados em modelos para diferentes tipos de teste, onde estas técnicas compartilham algumas características em comum (tais como a necessidade de possuir um modelo do sistema em teste, a simulação da execução deste modelo) e apresentam outras características específicas (como o algoritmo de geração dos casos de teste).
Esta caracterização se enquadra perfeitamente na metodologia de desenvolvimento de software conhecida como linha de produtos de software.
O tradicional modo de desenvolvimento de software é desenvolver sistemas isolados, ou seja, desenvolver cada sistema individualmente.
Para linha de produtos de software, a metodologia de desenvolvimento é ampliada para considerar uma família de sistemas de software.
Esta abordagem envolve analisar as características que são comuns a todos os membros da família e as que são específicas a cada elemento da família.
Sendo assim, este trabalho pretende propor uma arquitetura de linha de produtos de testes de software baseados em modelos, organizando as diferentes características de forma a facilitar a construção de ferramentas de testes baseados em modelos.
Em o Capítulo 2 é apresentado uma revisão da literatura sobre testes de software, introduzindo assim o tema em questão.
Em o Capítulo 3 é exibida uma revisão da literatura sobre testes de software baseados em modelos, apresentado as diferentes abordagens sobre o tema.
Em o Capítulo 4 é apresentada uma revisão da literatura sobre linha de produtos de software, exibindo os conceitos a serem empregados na proposta deste trabalho.
Em o Capítulo 5 é apresentada a proposta deste trabalho, assim como um estudo de caso.
Por fim, no Capítulo 6 são realizadas as considerações finais e descritos os trabalhos futuros a serem realizados.
Teste é uma atividade desempenhada para avaliar a qualidade do produto, e para aprimorar o produto identificando defeitos e problemas.
Esta definição descreve superficialmente os objetivos de teste.
Em maiores detalhes, teste de software consiste na verificação dinâmica do comportamento de um software num conjunto finito de casos de teste, convenientemente selecionados a partir de um domínio normalmente infinito, tomando como base o comportamento esperado do software.
Em a definição acima, as palavras em negrito são chaves para identificar o conhecimento relacionado ao teste de software.
Sendo elas:
Dinâmica, onde este termo significa que o teste implica na execução do software com entrada de dados.
Para ser preciso, o dado de entrada sozinho não é sempre suficiente para determinar um teste, pois um sistema pode apresentar um comportamento diferente para uma mesma entrada, dependendo do estado do sistema (sendo o sistema não-determinístico).
Em este caso, o termo &quot;entrada «significa também incluir uma especificação de um estado, quando for necessária tal especificação.
Finita, pois mesmo em programas simples, teoricamente tantos são os casos de testes possíveis que testes exaustivos poderiam requerer meses ou anos para serem executados.
Devido a esta situação, o domínio pode ser considerado infinito.
Desta forma é conveniente definir o conjunto de casos de testes baseado nos recursos disponíveis para sua execução (como cronograma, equipamentos, entre outros).
Selecionados, onde as muitas técnicas de teste diferem essencialmente em como selecionar os conjunto de teste.
Como identificar o critério de seleção mais adequado em determinadas condições é um problema altamente complexo.
Esperado, pois o comportamento observado do resultado da execução de um programa pode ser comparado com as expectativas do usuário (validação), com a especificação (verificação), ou finalmente com o comportamento antecipado por requisitos implícitos ou expectativas razoáveis (aceitação).
A definição superficial de testes de software (citada inicialmente) apresenta teste como uma atividade focada em identificar defeitos.
Um defeito ocorre quando o serviço entregue por o sistema não corresponde ao serviço especificado, normalmente apresentando um resultado incorreto, implicando que o serviço esperado seja descrito por uma especificação ou um conjunto de requisitos.
Um erro é parte do estado do sistema que é responsável por conduzir- lo para um defeito.
Uma falha é a causa identificada ou hipotetizada de um erro, também conhecida como bug.
Desta forma, um defeito ocorre devido a um erro produzido por uma falha.
Teste não é visto como uma atividade que inicia somente depois que a fase de codificação foi completada, com a proposta limitada em detectar defeitos.
Teste de software é visto como uma atividade que deve cobrir todo o processo de desenvolvimento e manutenção, sendo parte importante da construção de um produto.
Sendo assim, o planejamento dos testes deve começar nos estágios iniciais do processo de requisitos, os planos de teste devem ser sistematicamente e continuamente desenvolvidos e, se possível, refinados à medida que o desenvolvimento do software evolui.
O fluxo do processo de desenvolvimento de software pode ser sumarizado em sete passos, ilustrados na Figura 1: O programa precisa estar traduzido num conjunto de requisitos.
Estes são os objetivos para o produto.
Os requisitos são traduzidos em objetivos específicos através de estimativa de viabilidade e custo, resolvendo requisitos conflitantes e estabilizando prioridades.
Os objetivos são traduzidos numa especificação de produto precisa, visualizando o produto como uma caixa preta e considerando somente sua interface e as interações com o usuário final.
No caso de um sistema, este passo particiona o sistema em programas individuais, componentes, ou subsistemas, e define suas interfaces.
Componentes, por a estrutura hierárquica dos componentes e por a interface entre os componentes.
Dada a premissa que os sete passos do ciclo de desenvolvimento envolvem comunicação, compreensão e tradução da informação, e a premissa que muitos erros de software originam de colapsos na manipulação das informações, existem três abordagens complementares para prevenir e/ ou detectar esses erros.
Primeiro, pode- se introduzir mais precisão num processo de desenvolvimento para prevenir muitos dos erros.
Segundo, pode- se introduzir, no fim de cada passo, uma etapa de verificação em separado para localizar quantos erros forem possíveis antes de prosseguir para o próximo passo.
Esta abordagem é ilustrada na Figura 2.
A terceira abordagem é orientar processos de testes distintos voltados a processos de desenvolvimento distintos.
Ou seja, focar cada processo de teste num passo de tradução em particular, então focando numa classe particular de erros.
Esta abordagem é ilustrada na Figura 3.
Este ciclo de teste foi estruturado para modelar o ciclo de desenvolvimento.
Em outras palavras, estabilizar uma correspondência de um para um entre o processo de desenvolvimento e teste.
Por exemplo, a proposta de um teste unitário é procurar discrepâncias entre o componente e sua especificação de interface.
A proposta de um teste funcional é verificar se um programa não faz nada mais que sua especificação externa.
A proposta de um teste de sistema é verificar se um produto está inconsistente com os objetivos originais.
A sequência do processo de teste da Figura 3 não implica necessariamente numa seqüência temporal.
Por exemplo, o teste de sistema não é definido como &quot;uma parte do teste a ser executada depois do teste funcional», mas sim como um tipo de teste focado numa classe distinta de erros, podendo ser parcialmente sobreposta no tempo com outras etapas do processo de teste.
A seguir, serão discutidas os processos de testes unitário, funcional, de sistema, de aceitação e de instalação apresentados na Figura 3.
Teste unitário é o processo de teste em o qual se tem acesso ao código do programa.
Este teste é conhecido também como teste de caixa branca.
Este teste busca localizar falhas no código do programa.
Existem dois tipos de testes unitários:
Testes estáticos e dinâmicos.
Teste unitário estático é o processo de, cuidadosamente e metodicamente, revisar o código procurando por falhas sem executar o software.
Este processo é conhecido também como análise estrutural.
O objetivo de aplicar um teste de caixa branca estático é localizar falhas o mais cedo possível e localizar falhas que seriam difíceis isolar nas outras fases de teste.
Teste unitário dinâmico é o processo de testar um programa em execução e, durante a execução, examinar o código e como o código é executado.
O teste unitário dinâmico não limita- se somente ao que o código faz.
Também pode diretamente testar em baixo nível, os métodos, funções, procedimentos, subrotinas ou bibliotecas, pode acessar variáveis do programa e informação sobre o estado do software para determinar se os testes estão fazendo o que foi planejado para ser feito, pode forçar o software a realizar coisas que seriam difíceis de serem testadas normalmente e pode medir quanto do código e qual parte do código é testado quando os testes são executados, permitindo o ajuste dos testes para remover casos de testes redundantes ou adicionar etapas de forma a tornar o teste mais robusto.&amp;&amp;&amp;
Teste de integração é o processo que visa detectar deficiências no relacionamento entre os componentes do sistema.
Este relacionamento é realizado de algumas formas, tais como a substituição gradual de cada conexão entre dois componentes, uma integração de forma cruzada, onde cada componente é integrado com o seu componente adjacente na arquitetura e esta integração é testada, a integração entre os componentes na forma bottom-up, ou seja, partindo da integração dos componentes básicos até a integração dos módulos compostos por estes componentes básicos, a integração na forma top-down, partindo da integração dos módulos na forma mais alto-nível até a integração entre os componentes básicos, e por fim a integração conhecida como &quot;big bang «onde é testada a integração quando todos os componentes estão conectados.&amp;&amp;&amp;
Teste funcional é um processo de tentativa para localizar discrepâncias entre o programa e as especificações externas.
Uma especificação externa é uma descrição precisa do comportamento do programa do ponto de vista do usuário final.
Para prover um teste funcional, as especificações são analisadas para derivarem um conjunto de casos de testes.
Exceto quando utilizado em pequenos programas, o teste funcional é uma atividade conhecida como caixa preta, ou seja, se confia que um processo de teste unitário anterior alcançou um critério de cobertura lógica aceitável.
Teste de sistema não é o processo de testar as funções do sistema completo, porque isso seria redundante com o processo de teste funcional.
O teste de sistema tem um objetivo particular:
Comparar o sistema com os seus objetivos originais.
Dada esta proposta, surgem duas implicações:
O teste de sistema não é limitado para sistemas.
Se o produto é um programa, o teste de sistema é o processo de tentar demonstrar como o programa, como um todo, não preenche os seus objetivos.
Teste de sistema, por definição, é impossível de ser realizado, caso não exista um conjunto de objetivos claramente definidos e limitados para o produto.
A o procurar por discrepâncias entre o programa e os seus objetivos, foca- se nos erros de tradução gerados durante o processo de definição das especificações externas.
Isto torna o teste de sistema um processo de teste vital, pois em termos de o produto, o número e a severidade dos erros encontrados são descobertos durante esta fase do ciclo de desenvolvimento.
Isto implica também que, diferente do teste funcional, as especificações externas não podem ser usadas como base para derivar os casos de teste de sistema, pois subverteria a proposta do teste.
De a mesma forma, somente o documento de requisitos não pode ser usado para formular casos de teste, ao menos que, por definição, contenha descrições precisas das interfaces externas do programa.
Resolve- se este dilema usando a documentação do usuário, definindo o teste de sistema por a análise dos requisitos e formulando os casos de teste por a análise da documentação do usuário.
Dado o enunciado dos requisitos, não há metodologia identificável que renda um conjunto de casos de teste, exceto o vago, mas usual, guia de escrita de casos de teste para tentar mostrar que o programa é inconsistente com cada sentença dos enunciados dos objetivos.
Então, uma abordagem diferente para o projeto de casos de teste pode ser realizada da seguinte maneira:
Ao invés de descrever uma metodologia, categorias distintas de casos de testes de sistema são discutidas.
Devido a a ausência de uma metodologia, o teste de sistema requer uma quantidade substancial de criatividade, inteligência e experiência.
A seguir são discutidas as categorias de testes de sistemas utilizados neste trabalho.
Uma visão mais completa sobre o tema é apresentado em:
Teste de Segurança Devido a o fato da sociedade apresentar interesse por a privacidade, muitos sistemas possuem objetivos específicos de segurança.
O teste de segurança é o processo de tentar desenvolver casos de testes que contestem as verificações de segurança.
Por exemplo, pode- se tentar formular casos de teste que esquivem o mecanismo de proteção de memória de um sistema operacional.
Pode- se tentar contestar um mecanismo de segurança de dados de um sistema de gerência de banco de dados.
Outro caminho para planejar os casos de testes é estudar conhecidos problemas de segurança em sistemas similares e gerar os casos de testes que tentem demonstrar problemas similares no sistema o qual se deseja testar.
Por exemplo, fontes publicadas em revistas, salas de bate-papo, ou notícias freqüentemente exibem bugs conhecidos em sistemas operacionais ou outros sistemas de software.
Teste de Desempenho Muitos sistemas têm objetivos específicos de desempenho ou eficiência, declarando estas propriedades como tempos de resposta e taxas de transferência dentro de certas condições de cargas de trabalho e configuração.
Novamente, como a proposta de um teste de sistema é demonstrar que o programa não alcança os seus objetivos, os casos de teste devem ser projetados para mostrar que o sistema não satisfaz os objetivos de desempenho.
Retornando ao modelo de desenvolvimento exibido na Figura 3, pode ser visto que o teste de aceitação é o processo de comparar os requisitos iniciais e a necessidade do usuário final.
Este é um tipo incomum de teste onde é realizado normalmente por o comprador do sistema ou por o usuário final, e normalmente não é considerado responsabilidade da organização que desenvolve o software.
No caso de um desenvolvimento de software contratado, a organização contratante (usuário) realiza o teste de aceitação comparando a operacionalidade do programa com o contrato original.
Como é o caso para outros tipos de teste, a melhor maneira de realizar o teste é projetar- lo de forma que mostre que o programa não cumpre o contrato.
Se o teste falhar, o programa é aceito.
O último teste exibido na Figura 3 é o teste de implantação.
Sua posição na Figura 3 é um tanto rara, pois todos os outros testes estão vinculados a uma fase específica do processo de desenvolvimento.
Este é um tipo raro de teste porque sua proposta não é localizar erros de software, mas localizar erros que ocorreram durante o processo de implantação.
Muitos eventos ocorrem quando se implanta um sistema de software, por exemplo, os usuários necessitam selecionar uma variedade de opções, os arquivos e bibliotecas precisam ser alocados e carregados, uma configuração de hardware válida precisa estar presente e os programas podem necessitar de conectividade para conectarem- se com outros programas.
Para garantir a qualidade de um software, diversas visões sobre o tema testes de software emergem.
Estas visões exigem da equipe de teste um esforço substancial para cobrir todas as possíveis formas de testar um sistema.
Em o capítulo seguinte, será apresentada uma revisão da literatura sobre uma forma de simplificar e diminuir os esforço da atividade de teste, forma esta denomindada testes de software baseados em modelos.
Modelos são usados para entender, especificar e desenvolver sistemas em muitas disciplinas.
De as pesquisas de DNA até o desenvolvimento do mais recente avião de guerra, modelos são usados para promover o entendimento e prover um framework reusável para o desenvolvimento de produtos.
Em o processo de engenharia de software, modelos são aceitos como parte da abordagem de análise e projeto orientado a objetos.
Artigos e livros têm sido escritos sobre a aplicação de modelos para o desenvolvimento de testes e análise de confiabilidade nas últimas duas décadas.
Modelar tem um significado muito econômico, pois tem como objetivo capturar conhecimento sobre um sistema e então reusar este conhecimento enquanto o sistema cresce.
Para uma equipe de teste, este conhecimento é como ouro, pois qual a porcentagem de uma tarefa de um engenheiro de teste é gasta tentando entender o que o sistema em teste deveria fazer?
Uma vez que esta informação é compreendida, como a informação é preservada para o próximo engenheiro, a próxima versão, ou ordem de alteração?
Com sorte estará no plano de testes, mas tipicamente codificado num script de teste.
Por a construção de um modelo que define o comportamento desejado do sistema, uma equipe agora tem um mecanismo para uma análise estruturada do sistema, pois os cenários de teste são descritos como uma seqüência de ações para o sistema (sendo especificados no modelo), com as respostas esperadas do sistema sendo também especificadas.
A cobertura dos testes e os planos de teste são facilmente entendidos e desenvolvidos, além de os recursos disponíveis e a cobertura que pode ser entregue são estimados com uma maior segurança.
O maior benefício está no reuso, pois todo este trabalho não é perdido.
O próximo ciclo de testes pode começar onde o atual ciclo parou.
Se o produto apresenta a necessidade de novas funcionalidades, tais funcionalidades podem ser incrementalmente adicionadas ao modelo.
Se a qualidade deve ser aperfeiçoada, o modelo pode ser refinado e a quantidade e qualidade dos testes aumentará.
Se há novas pessoas na equipe, estas pessoas podem rapidamente compreender o projeto, bastando apenas revisar o modelo do projeto.
De forma simplificada, um modelo de software é uma descrição da estrutura e do comportamento do software.
Para um modelo poder ser utilizado por equipes de testadores e por múltiplas tarefas de teste, o modelo necessita ser entendido por além de os que dominam o conhecimento sobre para que supostamente o software é desenvolvido, devendo ser escrito numa forma de fácil entendimento.
É preferível, geralmente, que o modelo seja tão formal quanto prático.
Através dessas propriedades, o modelo torna- se uma descrição compartilhável, reusável e precisa do sistema em teste.
Existem numerosos tipos de modelos, e cada um descreve aspectos diferentes do comportamento do software.
Por exemplo, fluxo de controle, fluxo de dados, e gráficos de dependência do programa expressam como a implementação comporta- se através da representação da estrutura do código-fonte.
Redes de Petri e máquinas de estados, por outro lado, são usadas para descrever os comportamentos externos conhecidos como caixa preta, ou seja, testes onde a estrutura do código-fonte não é considerada.
A seguir, serão descritos alguns tipos de modelos utilizados em testes de software.
Considere o seguinte cenário de teste:
Um testador aplica uma entrada e então avalia o resultado.
O testador então seleciona outra entrada, dependendo do resultado anterior, e outra vez reavalia o próximo conjunto de possíveis entradas.
Em um dado instante, um testador tem um conjunto específico de entradas para escolher.
Este conjunto de entradas varia dependendo do &quot;estado «exato do programa.
Esta característica faz o modelo baseado em estados uma ótima opção para teste de software:
Software está sempre num estado específico e o estado corrente de uma aplicação governa que conjunto de entradas os testadores podem selecionar.
Máquinas de Estados Finitos são aplicáveis para qualquer modelo que esteja perfeitamente descrito com um número finito de estados específicos.
Máquinas de Estados Finitos é uma teoria da computação madura e estável, pois modelos de máquinas de Estados Finitos têm sido usados no projeto e teste de componentes de hardware há muito tempo e é considerada uma prática padrão hoje em dia.
O modelo Máquina de Estados Finitos é uma opção quando os testadores possuem o fardo de construir seqüências de entrada para suprir os dados de teste.
Máquinas de estados (grafos dirigidos) é um modelo ideal para descrever seqüências de entrada.
Isto, combinado com uma abundância de algoritmos para percorrer grafos, torna a geração de testes menos onerosa que o teste manual.
Por outro lado, softwares complexos implicam em grandes máquinas de estados, que não são triviais para construir e prover manutenção.
Em a definição de Máquina de Estados Finitos (FSM -- Finite State Machine), uma FSM é uma 5-tupla (I, S, T, F, L), onde I é o alfabeto de entrada, S é o conjunto finito de estados, T S × I é a função que determina que uma transição ocorre quando uma entrada I é aplicada num estado S, F S é o conjunto de estados finais e L S é o estado inicial.
Outra definição apresenta uma Máquina de Estados Finitos como uma 6-tupla (S, I, A, R, T), onde S é o conjunto finito de estados, I S, é conjunto de estados iniciais, A é o alfabeto finito de símbolos de entrada e R é o conjunto de possíveis saídas ou respostas.
O conjunto S × é conhecida como Máquina de Estados Finitos com entradas e saídas.
A relação de transição descreve como a máquina reage ao receber entrada a A quando s S, assumindo que (s, a).
Interpreta- se (s, a)/ como:
O símbolo de entrada não pode ser aceito no determinado estado.
Quando T (s, a) $= (s', r), o sistema move- se para o novo estado s'e responde como saída r.
Se T não é uma função, mas mais exatamente uma relação que associa cada par de estado de entrada com um conjunto não vazio de pares de estados de saida, é dito que o autômato finito é não determinístico, e é interpretado como o conjunto de possíveis respostas para um estímulo de entrada num certo estado.
O modelo de Estados Finitos pode ser representado como um grafo, também chamado diagrama de transição entre estados, com nodos representando estados, arcos representando transições, e arcos com nomes representando entradas causando as transições.
Normalmente, os estados finais e o inicial recebem uma marcação especial.
A máquina de estados pode também ser representada como uma matriz, chamada matriz de transições entre estados.
Existem duas formas usuais de matrizes de transições entre estados que são ilustrados nas Tabelas 1 e 2, no exemplo &quot;Interruptor de lâmpadas «apresentado a seguir, junto com o correspondente diagrama de transição entre estados.
Exemplo Considere um simulador hipotético de interruptor de lâmpadas simples.
As lâmpadas podem estar ligadas ou desligadas sendo alternadas através de uma entrada.
A intensidade da luz pode ser ajustada usando duas entradas para diminuir ou aumentar a intensidade.
Existem três níveis de intensidade de luz:
Fraca, normal e brilhante.
Se as lâmpadas estão brilhantes, ao aumentar a intensidade não deverá afetar a intensidade.
O caso é similar para a lâmpada estar fraca e tentar diminuir a intensidade.
O simulador inicia com as lâmpadas apagadas.
Finalmente, quando as lâmpadas estão ligadas, a intensidade é normal por padrão, não levando em consideração a intensidade da luz quando a lâmpada foi desligada anteriormente.
O simulador pode estar em somente um dos quatro estados distintos a qualquer tempo:
As lâmpadas estarem desligadas, com a iluminação fraca, normal ou brilhante.
Uma maneira para modelar isto é usando uma Máquina de Estados Finitos que é definida a seguir:
Tabela 2 ­ Outro formato de matriz de transições entre estados.
Desligada fraca normal brilhante normal a intensidade\&gt; desligada desligada normal brilhante a intensidade\&gt; fraca normal Em a Figura 4 é apresentada a máquina de estados equivalente em forma de um grafo dirigido.
Em esta etapa do trabalho é apresentada uma rápida revisão sobre UML, onde não serão abordados todos os artefatos existentes, somente os interessantes para o teste baseado em modelos.
Trabalhos como, apresentam o uso de modelos de teste baseados em UML.
Modelo de Caso de Uso Os casos de uso são normalmente aplicados na fase inicial de análise para definir que serviços (ou &quot;casos de uso&quot;) o sistema irá prover.
Um simples exemplo é exibido na Figura 5 (extraída de), indicando que um ator do tipo X está envolvido num caso de uso, descrevendo alguma funcionalidade S4 do sujeito y:
Y. O responsável por a modelagem apresenta a descrição da funcionalidade numa prosa estruturada.
Desta forma, o caso de uso S4 poderia ser algo como:
Atores: X;
Pré-condições: Y precisa estar pronto;
Caso Normal:
X enviará a Y um sinal m1 e então Y retornará um sinal m4;
Casos Excepcionais:
Nenhum. A descrição dos casos de uso são normalmente usados por os responsáveis em definir os comportamentos em termos mais precisos.
Modelo de Atividades Modelos de atividades são usados para descrever comportamentos em altos ou baixos níveis de abstração.
Tipicamente, numa modelagem de alto nível, os diagramas de atividades são freqüentemente usados, e também em projetos de implementações muito detalhados ou nos efeitos comportamentais das transições de máquinas de estados.
A Figura 6 (extraída de) exibe um diagrama de atividades muito simples.
Similar à Máquina de Estados Finitos, este diagrama possui nodos inicial e final, representando o início e o fim do comportamento por o círculo preenchido e por o círculo preenchido inscrito em outro círculo, respectivamente.
Os símbolos com nomes Retorna 1 e Retorna 1 são símbolos de atividades onde o nome refere- se a alguma atividade a ser realizada.
O nodo em forma de losango significa um símbolo de decisão, e os colchetes significam as situações a serem verificadas.
Uma cadeia de Markov é um processo estocástico caracterizado por estados formadores de um espaço de estados discretos (ou seja, contáveis ou contavelmente infinitos).
Um cada variável aleatória Xt é indexada por o parâmetro t T, sendo este parâmetro normalmente o tempo, se T R+ $ [ 0,).
O conjunto de todos os valores possíveis de Xt (para cada t T) é conhecido como o espaço de estados do processo estocástico.
Se o espaço temporal é também discreto, então a cadeia de Markov é chamada de Cadeia de Markov em tempo discreto.
Caso o espaço temporal seja contínuo (incontável), a cadeia de Markov é chamada de Cadeia de Markov em tempo contínuo.
A cadeia de Markov é um processo estocástico onde seu comportamento dinâmico é tal que é que os estados anteriores são irrelevantes para a predição dos estados seguintes, desde que o estado atual seja conhecido.
Uma maneira simples de visualizar um tipo específico de cadeia de Markov é através de uma Máquina de Estados Finitos.
Se você está no estado y no tempo n, então a probabilidade de que você se mova para o estado x no tempo n+ 1 não depende de n, e somente depende do estado atual y em que você está.
Assim em qualquer tempo n, uma cadeia de Markov finita pode ser caracterizada por uma matriz de probabilidades cujo elemento (x, y) é dado por P e é independente do tempo n..
Estes tipos de cadeia de Markov finitas e discretas podem também ser descritas por meio de um grafo dirigido, onde cada aresta é rotulada com a probabilidade de transição de um estado a outro sendo estes estados representados como os nós conectados por as arestas.
Desta forma, existe uma probabilidade de 25% para a transição do estado &quot;0 «para o estado &quot;1 «e uma probabilidade de 75% para continuar no estado &quot;0».·
t4 $= e p5· $ .
É dito que p é uma posição origem se· p $= e uma posição destino se p· $ .
Transições origem e destino são similarmente definidas.
A operação de uma Rede de Petri é realizada da seguinte forma:
A marca µ habilita a transição t se p· t:
µ (p) 1.
Quando µ habilita t e t dispara, a marca é alterada.
Sendo µ a nova marca obtida por o disparo de t..
A marca µ satisfaz:
A notação µ -- µ é usada para expressar que ao disparar t em µ resulta numa nova marca µ.
Como um exemplo, as transições habilitadas na Figura 8 são t2, t3 e t4.
A transição t1 não é habilitada, devido a µ2 $= 0 e p2· t1.
Exemplos de disparos entre as transições podem ser vistos na Figura 9.
Uma modelagem de uma Rede de Petri é apresentada a seguir.
Considerando uma rede de computadores em a qual usuários podem enviar arquivos para imprimir num servidor de impressoras central.
As requisições de impressão são armazenadas numa fila de impressão, que é lida por o servidor de impressão.
O servidor pode utilizar duas impressoras:
LP1 e LP2.
Cada uma das duas impressoras pode processar somente um serviço de impressão por vez.
Quando o servidor começa a processar uma requisição, ele espera alguma impressora tornar- se disponível ou seleciona uma das impressoras e espera a impressora tornar- se disponível.
Quando a impressora selecionada está disponível, a requisição é enviada à impressora.
Finalmente, o servidor notifica o usuário quando o serviço de impressão está completo.
Assume- se que o servidor de impressão processa, no máximo, duas requisições ao mesmo tempo.
Em alguns problemas é interessante possuir múltiplos arcos entre uma posição e uma transição.
Situações como esta é necessário modelar numa Rede de Petri generalizada, introduzindo uma função peso.
Tal função atribui a cada arco um peso diferente, como exemplificado na Figura 11.
Com isso, a estrutura de uma Rede de Petri torna- se uma quádrupla N $= (P, T, F, W), onde P é o conjunto de posições, T é o conjunto de transições, F (P × T) (T × P) é o conjunto de arcos entre as transições e W:
F N\ 0 é a função peso.
As Redes de Petri provaram ser extremamente útil para o estudo de propriedades qualitativas ou lógicas de sistemas, exibindo comportamentos concorrentes e assíncronos.
Porém, algumas situações exigem um atraso entre a transição entre os estados, assim como os pesos das transições simularem situações aleatórias.
Sendo assim, em 1982, Michael K. Molloy propôs inserir na Rede de Petri características estocásticas, tornando a Rede de Petri isomórfica aos processos Markovianos homogêneos.
Após, em 1984, Aljmore Marsan, Balbo e Conte estenderam as Redes de Petri estocásticas para Redes de Petri estocásticas generalizadas (GSPN), onde uma transição possui a possibilidade de sofrer um atraso no disparo, podendo este atraso características determinísticas ou estocásticas, bastando inserir pesos nas transições com valores probabilísticos.
Com isso a Rede de Petri assume as características determinísticas/ não determinísticas/ híbridas e temporais/ não temporais.
Desta forma, uma Rede de Petri pode então simular características como desempenho e dependência.
Teste baseado em modelos é definido como a automação do projeto de testes de caixa preta.
A diferença do teste de caixa preta usual é que ao invés de escrever manualmente os casos de teste baseado na documentação de requisitos, cria- se um modelo do comportamento do sistema em teste, modelo este que captura alguns dos requisitos.
Então uma ferramenta de testes baseada em modelos é utilizada para gerar automaticamente os testes para este sistema em teste.
O processo de teste baseado em modelos pode ser dividido em cinco passos principais, como mostrado na Figura 12: Modelar o SUT e/ ou seu ambiente.
Gerar testes abstratos a partir de o modelo.
Concretizar os testes abstratos para tornar- los executáveis.
Executar os testes no SUT.
Analisar os resultados dos testes.
Os dois primeiros passos diferenciam o teste baseado em modelos dos outros tipos de teste.
Em ferramentas online de testes baseados em modelos, do passo 2 até o passo 4, são unidos num único passo, já em testes baseados em modelos de forma offline, são normalmente separados.
Mas para critério de entendimento, é interessante explicar esses passos separadamente.
O primeiro passo de testes baseados em modelos é escrever um modelo abstrato do sistema que se deseja testar.
Denomina- se modelo abstrato porque deveria ser muito menor e simples que o sistema em teste.
O modelo deveria focar somente nos aspectos chave que se deseja testar e deveria omitir muitos dos detalhes do sistema.
Durante a criação do modelo, pode- se também incluir anotações com identificadores de requisitos para documentar claramente o relacionamento entre os requisitos informais e o modelo formal.
Após a escrita do modelo, é conveniente usar ferramentas para verificar se o modelo está consistente e possui o comportamento desejado.
O segundo passo é a geração de testes abstratos a partir de o modelo.
Deve- se definir alguns critérios de seleção de testes, para definir quais testes deseja- se gerar a partir de o modelo, pois são normalmente um número infinito de testes possíveis.
O resultado principal deste paso é um conjunto de testes abstratos, os quais são seqüências de operações a partir de o modelo.
Como o modelo apresenta uma visão simplificada do SUT, os testes abstratos são carentes de alguns dos detalhes necessários do sistema em teste e não são diretamente executáveis.
Muitas ferramentas de testes baseados em modelos também produzem uma matriz de rastreabilidade de requisitos ou vários outros relatórios de cobertura como saídas adicionais deste passo.
A matriz de rastreabilidade de requisitos traça a conexão entre os requisitos funcionais e os casos de testes gerados.
Os relatórios de cobertura fornecem algumas indicações de quão bem o conjunto de testes gerados exercitam todos os comportamentos do modelo.
Estes relatórios apresentam dados sobre a cobertura do modelo, não sobre o sistema em teste, pois ainda não foram executados os testes neste sistema.
O terceiro passo transforma os testes abstratos em testes concretos executáveis.
Esta transformação pode ser realizada utilizando uma ferramenta de transformação que utilizam vários templates e mapeamentos para traduzir cada teste abstrato num script de teste executável, ou escrevendo um código que realiza esta tarefa.
O quarto passo é executar os testes concretos no sistema em teste.
Com o teste online, os testes serão executados como foram produzidos, então a ferramenta de testes baseados em modelos gerenciará o processo de execução de testes e gravará os resultados.
Com o teste offline, já se possui o conjunto de scripts concretos de testes gerados em alguma linguagem, então podese continuar utilizando a ferramenta de execução de testes, executar- los regularmente e gravar os resultados.
O quinto passo é analisar os resultados da execução do teste e aplicar as ações corretivas.
Para cada teste que reportar um erro, deve- se determinar a falha que causou este erro.
Esta falha pode ser devido a uma falha na geração do caso de teste ou no modelo ou talvez nos documentos de requisitos.
Alguns trabalhos propõem a realização de testes baseados em modelos, por exemplo, testes funcionais a partir de máquinas de Estados Finitos estendidas, testes de desempenho a partir de modelos UML de atividades, testes de integração a partir de diagramas UML de estados (StateChart Diagrams).
Outro trabalho analisa setenta e oito artigos sobre testes baseados em modelos, sendo quarenta e sete de eles baseados em modelos UML.
Como este último trabalho apresenta, grande parte das metodologias de testes baseados em modelos utilizam UML para a descrição dos modelos.
Em testes baseados em modelos as características dos modelos podem ser classificadas como determinísticas, não-determinísticas, temporizadas, não-temporizadas, discretas, híbridas e contínuas.
Tal classificação pode ser vista como uma linha de produtos, pois as metodologias são agrupadas conforme suas principais características.
Em o capítulo seguinte será apresentado os conceitos sobre linha de produtos de software, conceitos necessários para a integração de testes de software baseados em modelos e linha de produtos de software, sendo esta integração o objetivo deste trabalho.
O sonho de um reuso de software massivo é tão antigo quanto a própria Engenharia de Software.
Foram realizadas várias tentativas ou iniciativas de reusar software, mas o sucesso alcançado foi muito baixo.
Estas iniciativas de reuso foram principalmente baseadas numa abordagem focada num reuso de pequena escala e ad hoc, sendo tipicamente em nível de código.
O conceito de focar num domínio específico como uma base para desenvolver artefatos reusáveis foi somente introduzido no início da década de 80, sendo focado este contexto quase exclusivamente no desenvolvimento num único domínio, baseado em ferramentas de geração automatizada de software.
O conceito de linha de produtos de software foi introduzido no início da década de 90.
Uma das primeiras contribuições foi a descrição da análise de domínio orientada a feature, conhecida como método Foda (Feature-oriented Domain Analysis).
Em esta mesma época, diversas empresas começaram a demonstrar um interesse por o tema.
Por exemplo, a empresa Philips apresentou o método de montagem em blocos.
Existem diferentes motivos que levaram as empresas a investirem na abordagem de linha de produtos de software, desde diminuição dos custos e tempo de desenvolvimento a um aumento da qualidade e da confiabilidade.
Esta diminuição de custo e tempo de desenvolvimento está relacionada com o suporte ao reuso em larga escala durante o ciclo de desenvolvimento de software.
Comparada às abordagens tradicionais de reuso, a economia pode ser de até Para alcançar esta economia, é necessário inicialmente um investimento extra, pois a abordagem de linha de produtos exige a construção de artefatos reusáveis, uma mudança cultural na organização, etc..
Existem diferentes estratégias para realizar este investimento, desde a abordagem conhecida como big-bang até uma estratégia incremental.
Como mostra a Figura 13 (extraída de), o investimento começa a apresentar resultados a partir de o terceiro produto da linha.
Outra vantagem da linha de produtos está na interface com o usuário.
Ao invés de desenvolver uma interface para cada sistema, na linha de produtos todos os sistemas compartilham de uma interface similar, provendo uma maior usabilidade.
Em alguns casos, a demanda deste tipo de vantagem é a base para a introdução da abordagem de linha de produtos no desenvolvimento de sistemas.
Uma linha de produtos pode ser resumida como um conjunto de features, onde algumas features são comuns a todos os produtos da linha e algumas features podem variar de um produto para outro.
Uma feature é vista como uma abstração, podendo ser um requisito, uma funcionalidade, uma parte do produto, enfim, qualquer característica de um produto.
Por exemplo, numa linha de produtos de automóveis, uma feature pode ser um pneu, uma determinada potência do motor, uma determinada pressão num parafuso, enfim, qualquer característica relacionada ao produto em diferentes níveis de abstração.
Uma linha de produtos é abordada de duas maneiras, do ponto de vista de um produto específico e da linha como um todo.
A abordagem que se foca na linha como um todo é conhecida como engenharia de domínio e a que foca exclusivamente no produto é chamada de engenharia da aplicação.
A engenharia de domínio é o processo da linha de produtos de software em o qual as características comuns e variáveis são definidas e concretizadas.
A engenharia da aplicação é o processo da linha de produtos de software em o qual os produtos da linha são montados através do reuso de artefatos do domínio e da exploração da variabilidade da linha de produtos.
A engenharia de domínio é composta por todo tipo de artefatos da linha (requisitos, projeto, implementação, testes, etc.).
A variabilidade da linha de produtos define o que pode variar na linha, ou seja, quais features a linha de produtos oferece.
Esta variabilidade ocorre através da introdução de pontos de variabilidade, ou seja, locais onde é controlada a escolha de uma determinada feature num produto, definindo restrições e dependências entre as features.
Para obter um melhor entendimento da variabilidade da linha de produtos é interessante projetar alguma forma de modelagem.
Uma maneira de modelar as features e a variabilidade da linha de produtos é através do modelo de features provido por o método Foda.
O modelo de features aborda os conceitos e as propriedades de estruturas comuns e variáveis no domínio de interesse através de um modelo em árvore.
Um modelo de features do método Foda consiste de um diagrama de features, exibindo a decomposição hierárquica das features com relacionamentos obrigatórios, alternativos e opcionais.
Este método pode consistir também de uma descrição de cada feature, além de regras de composição onde são indicadas quais combinações de features são válidas e quais não são, além de uma lógica para selecionar ou não uma feature.
A Figura 14 ilustra um exemplo de modelo de features para uma linha de montagem de automóveis.
Outros métodos para modelar features incluem o método FORM (Feature Oriented Reuse Method), o método FeatuRSEB (Feature Reuse--Driven Software Engineering Business), e a notação de Jan Bosch, sendo que todas estes métodos são baseados principalmente no método Foda.
A arquitetura é uma parte fundamental de qualquer sistema de software não trivial.
Resumidamente, a arquitetura limita o escopo das funcionalidades que o sistema pode manipular, determinando a qualidade dos atributos do sistema.
Uma arquitetura comum é essencial para um conjunto de produtos poder compartilhar eficientemente grande parte de sua implementação.
Alguns pontos são importantes numa visão mais aprofundada de arquitetura de software.
Primeiramente, a arquitetura define os elementos de software.
A arquitetura engloba as informações de como os elementos arquiteturais se relacionam, ou seja, significa que a arquitetura omite certas informações sobre os elementos que não pertencem às suas interações.
Logo, uma arquitetura é praticamente uma abstração de um sistema que suprime os detalhes de elementos que não afetam como tais elementos usam, são usados, se relacionam ou interagem com outros elementos.
Os elementos interagem entre si através de interfaces que particionam um elemento em partes públicas e privadas.
A arquitetura se concentra no lado público da divisão.
Detalhes privados (como os que se preocupam somente com a implementação interna) não são considerados detalhes arquiteturais.
Em segundo lugar, a definição de arquitetura torna claro que os sistemas abrangem mais que uma estrutura e que nenhuma estrutura pode declarar- se como a arquitetura.
Por exemplo, a maioria dos projetos complexos são particionados em unidades de implementação, sendo que estas unidades adquirem responsabilidades específicas e são freqüentemente a base para que uma equipe de desenvolvimento possa atuar.
Este tipo de elemento engloba programas e dados que os programas em outras unidades de implementação irão chamar ou acessar, sendo que estes programas e dados são privados.
Em um grande projeto, estes elementos provavelmente serão subdivididos e repassados para equipes específicas.
Este é o tipo de estrutura que é freqüentemente usado para descrever um sistema, pois foca em como as funcionalidades do sistema são divididas para que as equipes possam atuar.
Outras estruturas são muito mais focadas em como os elementos interagem entre si em tempo de execução para que uma função do sistema seja executada.
Supondo que o sistema deve ser implementado como um conjunto de processos sendo executados em paralelo.
Os processos que existirão em tempo de execução, as várias unidades de implementação que são amarradas seqüencialmente para formar cada processo e a relação de sincronização entre os processos formam outro tipo de estrutura freqüentemente usada para descrever um sistema.
Nenhuma dessas estruturas sozinhas são a arquitetura do sistema, embora todas as estruturas possuam informações arquiteturais.
A arquitetura consiste destas estruturas, além de muitas outras.
Em terceiro lugar, a definição de arquitetura implica que todo sistema possua uma arquitetura, visto que todo o sistema pode ser representado como elementos e a relação entre estes elementos.
Embora todo sistema possua uma arquitetura, isto não significa que esta arquitetura seja conhecida por todos os envolvidos no sistema.
Talvez todas as pessoas envolvidas no sistema tenham se desligado do projeto, a documentação tenha sido perdida (ou talvez nunca produzida) e o código fonte não tenha sido entregue junto com o sistema.
Isto diferência a arquitetura de um sistema com a representação da arquitetura.
A arquitetura pode existir independente de sua descrição ou especificação, ressaltando assim a importância da documentação.
Por fim, o comportamento de cada elemento é parte da arquitetura a medida que o comportamento pode ser observado por o ponto de vista de um outro elemento.
Sendo assim, este comportamento precisa ser projetado tendo em vista o sistema como um todo, logo este com-portamento é parte da arquitetura do sistema.
Quando uma linha de produtos de software compartilha a mesma arquitetura, esta arquitetura é conhecida como arquitetura de referência.
A arquitetura de referência descreve uma arquitetura genérica que provê uma solução para uma variedade de produtos da linha, contendo a variabilidade de features que são oferecidas para instanciar um determinado produto, embora nem todas as features sejam visíveis em nível arquitetural.
A arquitetura é essencialmente importante na linha de produtos, pois uma arquitetura de referência simplifica o compartilhamento de artefatos entre diferentes produtos, tais como modelos, documentação, código, entre outros.
Os artefatos reusáveis são criados baseados na arquitetura de referência, fazendo com que os engenheiros possam presumir as situações onde os artefatos, que estão sendo criados ou desenvolvidos, serão utilizados.
Desta forma, a criação de artefatos apresenta uma redução de complexidade e conseqüentemente, de custos.
Os elementos da arquitetura são compostos por componentes, onde um componente é definido como uma parte de um código com funcionalidades bem definidas e que pode ser conectado a outros componentes através de sua interface.
A tecnologia de componentes possibilita que os desenvolvedores componham uma aplicação em partes fracamente acopladas, ou seja, os componentes podem ser desenvolvidos, compilados, conectados e carregados separadamente.
Somente em tempo de execução os componentes serão combinados num sistema funcional.
Com isso os desenvolvedores podem focar em na complexidade de um componente em particular, tornando o componente uma caixa preta.
Sendo assim, um componente é compostos por sua implementação interna e sua interface, como ilustrado na Figura 15.
Através do uso de componentes, a arquitetura de referência precisa implementar todas as possíveis variabilidades expostas no modelo de features, sendo que em alto-nível, exites três técnicas para prover a variabilidade na arquitetura:
Adaptação, substituição e extensão.
Em a técnica de adaptação, existe uma única implementação disponível para um certo componente, mas existem diferentes interfaces para ajustar o comportamento deste componente.
Esta interface pode possuir a forma de um arquivo de configuração, de parametrização ou caminhos para o código-fonte do componente para nomear as opções.
Em a técnica de substituição, são disponíveis várias implementações de um componente.
Cada implementação adere a especificação do componente como descrito na arquitetura.
Em a engenharia de aplicação, uma das implementações disponíveis é escolhida, ou uma implementação específica ao produto é desenvolvida através da adaptação, seguindo as especificações da arquitetura.
O projeto AMPLE avaliou as três principais ferramentas existentes que possibilitam a concretização de uma linha de produtos de software, sendo elas a pure:
Variants, Gears e fmp2rsm.
Pure: Variants é uma ferramenta comercial que provê uma representação explícita para os conjuntos de variantes de componentes (sendo estes conjuntos partes dos modelos da família de produtos) e de features.
Os modelos da família são criados a partir de artefatos concretos (normalmente arquivos), da declaração de relacionamentos entre os artefatos e associando as implementações existentes aos componentes.
O relacionamento entre as features e os componentes é descrito através de restrições baseadas em lógica e através de tabelas.
Os modelos de descrição das variantes são definidos para representar um conjunto de modelos de configuração e de transformação das variantes.
Cada variante possui um modelo de descrição de variante associado.
As transformações ocorrem através da substituição de fragmentos de arquivos que representam os artefatos.
Gears é uma ferramenta comercial que permite a definição de features, de pontos de variabilidade e de produtos através da seleção de variantes.
Um artefato na ferramenta Gears é um grupo de vários formatos de arquivos relacionados com dados de manutenção, testes e do código-fonte, provendo uma noção de pontos de variabilidade que representam partes de artefatos que podem ser configurados de acordo com as features existentes.
A ferramenta Gears provê uma linguagem de propósito geral para definir como diferentes features podem modificar um artefato.
Esta linguagem basicamente busca testar a relação entre as features e os artefatos.
Já as features são definidas através de uma linguagem que busca caracterizar conjuntos de features que são simultaneamente aplicáveis no produto ou são mutualmente exclusivas.
A ferramenta fmp2rsm é uma implementação de templates de modelos baseados em features para as ferramentas de modelagem IBM Rational Software Modeler e IBM Rational Software Architect.
A fmp2rsm integra o plugin de modelagem de features (fmp) com o Rational Software Modeler, habilitando a modelagem de linha de produtos em UML e a derivação automática de produtos.
O fmp é um plugin para a Ide Eclipse desenvolvido para editar e configurar modelos de features.
A fmp2rsm provê uma representação explícita para os conjuntos de famílias de modelos.
Uma família de modelos é representada por um modelo de features e um modelo de templates.
O modelo de features define as restrições das features, já o modelo de templates contém a união de todas as instâncias de templates existentes para gerar a linha de produtos.
A família de modelos responde ao conjunto de instâncias de templates.
A ferramenta fmp2rsm é de uso livre, mas somente funciona em conjunto com as ferramentas comerciais Rational Software Modeler e Rational Software Architect.
A abordagem de linha de produtos de software tenta prover um reuso massivo em todo o ciclo de desenvolvimento do software, mas este reuso não é alcançado de forma simples.
Este reuso é alcançado através de um esforço substancial de todos os envolvidos no desenvolvimento da linha, provendo a longo prazo um retorno atraente.
As ferramentas atuais para estruturar uma linha de produtos são comerciais ou vinculadas a alguma dependência comercial, provendo barreiras na sua utilização.
Em o capítulo a seguir será descrita a arquitetura de linha de produtos proposta para o desenvolvimento de ferramentas de testes baseados em modelos, linha esta embasada nos capítulos apresentados até o momento.
Atualmente existem uma série de abordagens diferentes para a realização de testes baseados em modelos.
Cada uma dessas abordagens apresenta um nível de complexidade para transformar esta abordagem numa ferramenta concreta para derivar os casos de teste.
Em o momento em que procura- se desenvolver estas ferramentas de forma a suprir as necessidades de diferentes fases do processo de teste, várias características de uma determinada abordagem é encontrada em outras abordagens.
A o desenvolver estas ferramentas individualmente, estas características em comum são implementadas novamente para cada ferramenta, gerando um retrabalho desnecessário.
Uma solução para reduzir o retrabalho é através do projeto de uma arquitetura de linha de produtos de software, onde após um estudo das diferentes abordagens de testes baseados em modelos, as características comuns destas abordagens são agrupadas, provendo um reuso destas características de forma a evitar o retrabalho.
Após o estudo das diferentes abordagens de testes baseados em modelos apresentados em, concluiu- se que as abordagens se resumem num manipulador do modelo do sistema em teste, um modelo comportamental que simula o comportamento deste modelo de entrada e por fim um gerador de casos de teste, responsável por executar esse modelo simulado e desta execução extrair as informações para a montagem dos casos de teste.
Este gerador pode ser visto de duas maneiras:
Como um gerador de casos de teste e como um gerador de scripts de teste.
Em o gerador de casos de testes são abordadas as características em nível conceitual, enquanto no gerador de scripts de teste são abordadas as características tecnológicas dos casos de teste.
A Figura 17 exibe o modelo de features elaborado baseado nesse estudo.
Este modelo de features é composto de quatro categorias:
Modelo de entrada, modelo comportamental, gerador de casos de teste e gerador de scripts de teste.
Em o modelo de entrada são inseridas as features responsáveis por extrair e fornecer as informações providas por os modelos utilizados para representar o sistema em teste.
Em o modelo comportamental, são providas duas features:
Rede de Petri estocástica generalizada e uma Máquina de Estados Finitos com entradas e saídas.
Em o decorrer deste capítulo será apresentado o motivo da existência dessas features.
Em os geradores de casos de teste e scripts são inseridas as features responsáveis por a geração de casos de teste e scripts para os diferentes tipos de testes que irão compor a linha de produtos concreta, respectivamente.
Para garantir um critério de cobertura relevante para a representação da simulação do comportamento das abordagens, a categoria 2 provê duas possibilidades:
Uma Máquina de Estados Finitos com entradas e saídas e uma Rede de Petri estocástica generalizada, cobrindo assim características determinísticas (FSM), estocásticas, híbridas e temporais (GSPN).
A categoria do manipulador do modelo de entrada é responsável por carregar o modelo de entrada e extrair as informações dos elementos deste modelo, provendo para a categoria de simulação comportamental (categoria 2) as informações necessárias para a sua criação.
A categoria de simulação do modelo comportamental é encarregada de simular a execução do modelo de entrada juntamente com as informações contidas neste modelo de entrada relevantes para o determinado tipo de teste a ser realizado.
Ou seja, se o teste a ser realizado é um teste de desempenho, por exemplo, o modelo de entrada deve descrever os passos a serem realizados no teste, assim como as características deste teste, tais como dados temporais, restrições, etc..
A categoria de geração de casos de teste visa absorver as informações providas por as categoria 2 e 3 e aplicar algoritmos de geração de casos de teste, assim como estruturar estes casos de teste de forma legível e inteligível.
A categoria de geração de scripts de teste tem o mesmo objetivo da categoria de geração de casos de teste, mas apresenta também a adequação à tecnologia a ser utilizada para a automação dos testes.
Ou seja, adequar as informações providas por a simulação do modelo comportamental e por a aplicação de algoritmos de geração de scripts de teste ao formato que a tecnologia, onde este scripts vão ser executados, exige.
Por fim, a categoria 3 é formada por conectores, responsáveis por interligar as demais categoria da arquitetura.
Estes conectores são divididos em dois grupos, os conectores responsáveis pois este conector é encarregado de extrair da categoria 1 as informações pertinentes ao tipo de teste a ser realizado e fornecer estas informações à categoria 2, além de prover o acesso da categoria 2 aos conectores do grupo B, que são encarregados de realizar a execução da simulação comportamental e fornecer as informações extraídas da simulação às categorias 4 e 5.
Cabe ressaltar que esta arquitetura de referência é uma arquitetura genérica, onde a especialização desta arquitetura é realizada através das informações providas por o modelo de features da linha de produtos a ser concretizada.
Para a instanciação de um produto em particular, é necessário selecionar quais elementos destas categorias são necessários para compor este produto, determinados por as informações contidas no modelo de features da linha de produtos.
Para uma situação inicial, onde objetiva- se a criação de uma linha de produtos de testes baseados em modelos, deve- se seguir o seguinte workflow:·
Realizar a engenharia de domínio;·
Realizar a engenharia de aplicação;·
Criar o modelo de features de cada produto;·
Criar o modelo de features da linha de produtos;·
Para cada feature, inserir na respectiva categoria da arquitetura de referência um componente responsável por concretizar esta feature;·
Para cada relacionamento entre features, criar os conectores da categoria 3 da arquitetura de referência responsáveis por concretizar este relacionamento;
Para instanciar um produto da linha deve- se:·
De posse do modelo de features do produto, do modelo de features da linha e da arquitetura de referência, verificar quais são os componentes da arquitetura que concretizam as features escolhidas para compor o produto;·
Verificar na categoria 3 da arquitetura de referência quais conectores realizam e respeitam os relacionamentos entre as features escolhidas para compor o produto;·
Gerar o produto, isto é, instanciar os conectores e os componentes relativos as features escolhidas, formando assim a ferramenta de testes baseados em modelos;
Para a seleção das features é interessante observar uma possível ordem temporal, de acordo com os seguintes passos:·
Selecionar primeiramente as features do modelo comportamental, desta forma definindo o modo de manipulação dos testes, se de forma estocástica ou determinística;·
Selecionar as features relativas a geração de scripts de casos de teste, definindo assim o tipo de teste a ser realizado e quais tipos de teste estão de acordo com o modelo comportamental escolhido;·
Selecionar os modelo de entrada que respeitam as restrições impostas por as features anteriores.
De posse destas informações, é possível instanciar um produto da linha de uma forma inicial.
Mas à medida que novas features necessitam ser inseridas na linha de produtos, alguns critérios precisam ser analisados.
A inserção de novas features, basicamente seguem dois princípios:
A inserção de um novo tipo de teste de software baseado em modelos e a inserção de uma nova feature nos tipos de testes já existentes na linha de produtos.
Para a inserção de um novo tipo de teste, inicialmente deve- se analisar qual a natureza deste teste, se é estocástica ou determinística.
De posse desta informação, verifica- se se as atuais features de modelos comportamentais (Rede de Petri EstocásticaGeneralizada e Máquina de Estados Finitos) são capazes de realizar o que este novo tipo de teste se propõe a fazer.
Em caso afirmativo, aplica- se o reuso destas features, caso contrário, uma nova feature é inserida no modelo de features e um novo componente é inserido na categoria 3 da arquitetura de referência.
De posse das informações de como os modelos de entrada serão manipulados, é necessário determinar quais serão estes modelos de entrada.
Se estes modelos já existem na linha de produtos, é aplicado o reuso, caso contrário deve- se inserir estas features na categoria de modelos de entrada, assim como concretizar estas features com componentes na categoria 1 da arquitetura de referência.
Em sequida, deve- se inserir as features relativas a geração dos casos de teste e de scripts deste novo tipo de teste no modelo de features e concretizar- las nas categorias 4 e 5 da arquitetura de referência, visto que, como é um novo tipo de teste, dificimente existirá na atual linha de produtos, não cabendo aqui a possibilidade de reuso.
Por fim, são definidos os relacionamentos entre as features deste novo tipo de teste e das demais features existentes, concretizando na categoria 3 da arquitetura de referência os conectores responsáveis por realizar estes relacionamentos.
Para a inserção de uma nova feature nos tipos de teste já existentes na linha de produtos, é interessante verificar se alguma feature não realiza a função que esta nova feature se propõe a realizar.
Em caso negativo, deve- se verificar o impacto desta nova feature na linha de produtos, ou seja, em quais relacionamentos entre features, restrições, etc., a adição desta nova feature impacta.
Após esta análise, a nova feature é inserida no modelo de features, a sua concretização é inserida na arquitetura de referência e os relacionamentos impactados no modelo de features são ajustados, assim como os conectores da categoria 3 da arquitetura de referência.
Em a seção seguinte será apresentado um estudo de caso de uma linha de produtos concreta, a qual possui uma arquitetura de referência composta por a arquitetura aqui proposta e por as informações oferecidas por o modelo de features deste estudo de caso específico.
Para um melhor entendimento da linha de produtos proposta, foi realizado um estudo de caso de uma linha de produtos para três tipos de abordagens de testes baseados em modelos:
Teste funcional, teste de desempenho e teste de segurança.
Estes tipos de teste não foram escolhidos ao acaso, fazem parte, assim como o tema deste trabalho, a um projeto de pesquisa do Centro de Pesquisa em Computação Aplicada da Pontifícia Universidade Católica do Rio Grande do Sul em colaboração com a empresa Hewlett--Packard.
O teste de desempenho baseado em modelos visa auxiliar na configuração de realocação de recursos em ambientes virtualizados com SLA, o teste de segurança procura auxiliar na geração de testes com requisitos nãofuncionais e o teste funcional busca ampliar o critério de cobertura dos testes, assim como automatizar a geração dos casos e scripts de teste.
Todos as abordagens aqui descritas utilizam UML como modelo de entrada.
Para a execução de scripts, foram definidas as ferramentas Hp Quick Test Professional e Apache JMeter, para testes funcionais e de desempenho, respectivamente.
Para a execução de scripts de testes de segurança não foi identificada nenhuma ferramenta, sendo então gerados somente os casos de teste.
Após a realização da engenharia de domínio, ou seja, o estudo das necessidades comuns entre os produtos da linha, foi desenvolvido o modelo de features da linha de produtos, apresentado na Figura 19.
Em as seções 5.1.1, 5.1.2 e 5.1.3 serão apresentados os produtos da linha individualmente, definindo o porquê da existência das features apresentadas neste modelo de referência.
Baseado nas exigências dos produtos existentes nesta linha, exigências estas apresentadas nas Seções 5.1.1, 5.1.2 e 5.1.3, e na arquitetura base exibida na Figura 18, foi definida uma arquitetura de referência, exibida na Figura 20.
A Figura 21 exibe o diagrama de classes da linha de produtos implementada neste estudo de caso.*
Cria um novo estado na FSM.*
@ param name nome do estado.*
@ param data informação a ser anexada ao estado.
This. Data.
Put (name, data);*
Cria uma nova transição*@ param source estado origem*@ param target estado destino*@ param targetProbability probabilidade de acessar o estado destino.
Generalizada. A ferramenta de teste funcional baseado em modelos UML foi desenvolvida baseada na abordagem descrita em, onde o objetivo é gerar casos de teste e scripts de teste através das informações existentes no modelo de atividades do sistema em teste.
Somente as informações existentes no modelo original do sistema em teste não é suficiente para a derivação de casos de teste funcionais, sendo necessário complementar o diagrama com as informações relevantes.
Estas informações são incluídas no modelo através de estereótipos e marcações.
Cada atividade do modelo de atividades recebe um estereótipo que identifica o teste funcional (identificado por e recebe marcações que indicam qual a ação do usuário no sistema a ser testado (identificada por FTAction) e qual o resultado esperado desta ação (identificado por FTExpec-tedResult).
A partir de estas informações extras, cada atividade do diagrama possui uma ação de entrada (FTAction) e uma informação de saída (FTExpectedResult), sendo necessário agora um método para derivar casos de teste a partir deste modelo de entrada.
O método UIO (Unique Input/ Output) é um método para a geração de um conjunto de seqüências de entrada para testar uma Máquina de Estados Finitos com entradas e saídas.
Para a geração destas seqüências, este método utiliza- se de seqüências UIO.
As seqüências UIO são utilizadas para verificar se a Máquina de Estados Finitos está num determinado estado em particular.
Sendo assim, cada estado da Máquina de Estados Finitos poderá possuir uma seqüência UIO distinta.
Desta forma, como definido em, «Para cada transição de um estado si para sj, fs (si,), com algum, é definida uma seqüência que conduz do estado inicial a si, aplica- se o símbolo de entrada e, em seguida, aplica- se a seqüência UIO do estado que deveria ser atingido.
Sendo assim, cada seqüência é da forma P (si)· U IO (sj), sendo que P (si) é uma seqüência que leva a Máquina de Estados Finitos do estado inicial ao estado si e U IO (sj) é uma seqüência para sj».
Para aplicar este algoritmo de geração de casos de teste, o modelo de atividades é convertido numa Máquina de Estados Finitos com entradas e saídas, onde os estados são as atividades, o alfabeto de entrada é formado por os conteúdos da marcação FTAction, o alfabeto de saída é formado por os conteúdos da marcação FTExpectedResult e o estado inicial e final são os mesmos do modelo de atividades.
Esta Máquina de Estados Finitos segue o modelo de Mealy, ou seja, as entradas e saídas são vinculadas às transições e não aos estados.
Para a geração de scripts de teste, o mesmo algoritmo é empregado, sendo estes scripts gerados para serem executados na engine de teste Hp Quick Test Professional, sendo assim necessária uma formatação dos scripts de acordo com o padrão da engine.
Baseado nestas informações, foi realizada a engenharia de aplicação, ou seja, o estudo das generalizações e especializações do produto, resultando no modelo de features exibido na Figura 24.
Com base neste modelo de features, a arquitetura resultante da engenharia de aplicação é apresentada na Figura 25.
Esta arquitetura, fruto da arquitetura de referência e dos modelos de features da linha de produtos e da aplicação, provê dois subprodutos, uma ferramenta de derivação de casos de testes funcionais baseados em modelos UML ou uma ferramenta de derivação de casos de testes e scripts de testes funcionais baseados em modelos UML, dependendo da seleção da feature opcional de geração de scripts, conforme o modelo de features da Figura 24.
Desta forma, o componente conector CB da categoria 3 é responsável por a feature opcional, pois a presença deste conector provê o acesso ao gerador de casos de teste (representado na Figura 25 por o componente denominado Funcional) e ao gerador de scripts de teste para o Quick Test Professional (representado na Figura 25 por o componente denominado QTP).
Caso a feature opcional não seja selecionada para compor o produto, o componente conector CE fica responsável por a conexão com a categoria de geração de casos de teste.
Maiores informações sobre o funcionamento da abordagem de testes funcionais baseados em modelos UML utilizada como exemplo neste trabalho podem ser obtidas em.
A ferramenta de testes de segurança baseados em modelos UML foi baseada nos trabalhos apresentados em e, onde o objetivo é derivar casos de teste de segurança baseado nas especificações de segurança inseridos nos modelos de caso de uso de atividades do sistema sob teste, sendo este sistema composto por páginas web.
Estas especificações são definidas nos modelos através de estereótipos que identificam diferentes estratégias de ataques à segurança do sistema.
Cada estereótipo é composto de marcações que apresentam as informações necessárias para caracterizar cada tipo de ataque, tais como o endereço web a ser acessado, o limite de usuários simultâneos que o sistema deve suportar, o tamanho máximo de caracteres que um determinado campo de preenchimento de informações do sistema deve suportar, etc..
Como todos os diferentes tipos de ataques especificados devem ser traduzidos em casos de teste, o método de geração de casos de testes utilizado nesta abordagem é o mesmo da ferramenta de teste funcional, ou seja, o método UIO.
Como este método é aplicado em máquinas de Estados Finitos com entradas e saídas, é necessário extrair as informações pertinentes ao teste de segurança dos modelos de atividades e caso de uso, gerando uma Máquina de Estados Finitos (FSM) com entradas e saídas equivalente.
O comportamento desta FSM é então simulado e nesta simulação é aplicado o método UIO.
Através das entradas aplicadas nesta FSM e nas respectivas saídas são gerados os casos de teste.
Diferente da ferramenta apresentada anteriormente, esta ferramenta não possui uma engine de teste, não sendo possível, até este momento, a geração de scripts de teste.
Baseado na análise dos requisitos desta abordagem, foi especificado o modelo de features apresentado na Figura 26.
Através deste modelo de features e dos requisitos da abordagem foi definida a arquitetura para a ferramenta, sendo exibida na Figura 27.
Como esta arquitetura é parte da arquitetura de referência, ela é dividida em categorias:
A categoria do modelo de entrada composta por os manipuladores dos modelos de caso de uso e atividades, a categoria da simulação comportamental do modelo de entrada, sendo neste caso uma Máquina de Estados Finitos com entradas e saídas (representada na Figura 27 como FSM), geradores de casos de teste de segurança (4), responsáveis por aplicar o método UIO e organizar os casos de teste de forma legível e inteligível e os conectores responsáveis por unir estas categorias.
Como não foram encontradas engines de teste de segurança, não existem componentes responsáveis por gerar scripts de teste (categoria 5).
Maiores informações sobre o funcionamento da abordagem de testes de segurança baseados em modelos UML utilizada como exemplo neste trabalho podem ser obtidas em e.
A ferramenta de testes de desempenho baseados em modelos UML foi baseado nos trabalhos apresentados em, e, onde o objetivo é derivar casos de teste de desempenho baseado nas especificações de desempenho apresentadas nos modelos de atividades e caso de uso do sistema sob teste.
Esta abordagem necessita de um comportamento estocástico e temporizado, com o objetivo de simular o comportamento de um usuário atuando no sistema.
Para prover este comportamento, a abordagem utiliza uma Rede de Petri Estocástica Generalizada (GSPN), criada a partir de as informações extraídas dos modelos UML exigidos.
Após a construção desta GSPN, é realizada a simulação deste modelo comportamental, onde os caminhos a serem percorridos por as fichas na GSPN são definidos de acordo com as probabilidades definidas nos modelos UML para o acesso a cada transição.
Durante o percurso destas fichas por a GSPN, são definidos de forma aleatória os tempos que uma determinada ficha espera para passar para a posição seguinte, simulando o comportamento de um usuário acessando o sistema, ou seja, tempos relativos ao preenchimento de um formulário, clicar num botão, etc..
Através das informações extraídas dos modelos UML e providas por a simulação da GSPN, são derivados os casos de teste, assim como os scripts de teste, sendo estes scripts organizados no formato exigido por a engine de teste de desempenho Apache JMeter.
Um detalhe a ser considerado neste modelo de features é a feature opcional gerador de scripts, fazendo com que a arquitetura proveja as duas opções, possuir um gerador de casos de teste e um gerador de scripts, ou somente o gerador de casos de teste.
Através deste modelo de features e dos requisitos da abordagem foi definida a arquitetura para a ferramenta, sendo exibida na Figura 29.
Como esta arquitetura faz parte da arquitetura de referência, ela é dividida em categorias:
A categoria do modelo de entrada composta por os manipuladores dos modelos de caso de uso e atividades, a categoria da simulação comportamental do modelo de entrada, sendo neste caso uma Rede de Petri Estocástica Generalizada, gerador de casos de teste de desempenho, responsável por extrair as informações providas por a categoria 2 e organizar os casos de teste de forma legível e inteligível, gerador de scripts de teste, responsável por extrair as informações providas por a categoria 2 e organizar os scripts no formato exigido por a ferramenta Apache JMeter e a categoria de conectores, responsável por interligar as demais categorias.&amp;&amp;&amp;
O conector descrito como Ca na Figura 29 é o conector responsável por a feature opcional exibida na Figura 28, sendo encarregado de prover os geradores de casos de teste e de scripts.
Maiores informações sobre o funcionamento da abordagem de testes de desempenho baseados em modelos UML utilizada como exemplo neste trabalho podem ser obtidas em e.
Para concretizar a arquitetura proposta, foi desenvolvida uma ferramenta de geração automatizada da linha de produtos.
Esta ferramenta baseia- se no modelo de features dos produtos específicos e no modelo de features da linha de produtos como um todo.
Cada feature é mapeado para a implementação de um componente, conforme apresentado no início deste capítulo.
Como exibe a Figura 30, as features são divididas em quatro categorias:
Modelo de entrada, modelo comportamental, gerador de casos de teste e gerador de scripts de teste, equivalendo respectivamente às categorias 1, 2, 4 e 5 da arquitetura de referência exibida na Figura 18.
A categoria 3 da arquitetura de referência é representada na ferramenta através de relacionamentos entre as features, onde cada relacionamento entre as features das categorias 1 e 2 é concretizado através de um conector, assim como o relacionamento entre as categorias 2, 4 e 5.
A Figura 31 exemplifica o relacionamento entre as features da Figura 19 Atividades, Caso de uso, e FSM através do componente descrito como ActivityUseCaseFSMConnector e entre as features FSM e Segurança através do componente descrito como FSMSecurityConnector.
A partir de as diferentes relações entre as features, a ferramenta possibilita ou não a seleção de uma determinada feature para compor um determinado produto.
Passada esta etapa de seleção, a ferramenta exige a inserção de uma denominação do produto a ser criado, proporcionando assim a geração do produto.
Esta geração é proporcionada através de templates, onde são inseridos o nome do produto e os componentes que o constituem.
Após é executada a ferramenta Apache Ant, responsável por gerar um arquivo executável deste produto.
A ferramenta Apache Ant exige um arquivo de configuração onde são especificadas as bibliotecas necessárias para compor o produto, qual a classe principal do produto, onde o produto deve ser salvo, entre outros requisitos de configuração.
Este arquivo fica localizado na pasta do projeto, sendo necessário que este arquivo possua o nome de build.
Xml. A Figura 32 ilustra o arquivo build.
Xml configurado para compor este estudo de caso.
Este arquivo build.
Xml define características como o nome do projeto (indicado através da marcação name $= ModelBasedTesting), a criação de uma pasta temporária onde o projeto será organizado para a compilação (indicada por dir $= &quot;classes&quot;/\&gt;), a instrução que o compilador java deve executar para compilar o projeto (indicado por a marcação\&gt;), qual o arquivo principal do produto a ser gerado (indicado por a marcação name $= &quot;Main-Class «value $= «Main.&amp;&amp;&amp;
Main&quot;/\&gt;), entre outras características.
A Figura 33 ilusta um exemplo de produto de teste funcional baseado em modelos UML gerado por a ferramenta.
Como pode ser analisado nos exemplos de produtos providos por o estudo de caso, a arquitetura de referência exibida na Figura 20 busca prover o reuso dos componentes arquiteturais, facilitando assim o desenvolvimento de novas técnicas de testes baseados em modelos.
De acordo com os produtos individuais apresentados, todos compartilham o uso do componente da categoria 1 denominado Atividades e dois dos produtos compartilham o uso do componente denominado CasodeUso.
Dois dos produtos compartilham também o componente da categoria 2 denominado FSM, sendo os demais componentes das categorias 2, 4 e 5 utilizados de forma individual, devido a as exigências de cada tipo de teste.
Caso haja o interesse de inserir outra abordagem do mesmo tipo de teste já existente na linha de produtos, basta apenas o desenvolvimento dos conectores próprios para esta nova abordagem, inserindo nestes conectores as exigências impostas por a abordagem, como por exemplo quais informações devem ser extraídas dos modelos de entrada.
Caso o interesse seja em que a linha de produtos proveja outro tipo de teste, deverão ser implementados, além de os conectores, os devidos geradores de casos e scripts de teste, inserindo estes componentes na arquitetura de referência.
Desta forma, estes geradores poderão ser reusados para o desenvolvimento de outras abordagens do mesmo tipo de teste.
Este estudo de caso foi ao encontro ao apresentado em, onde uma linha de produtos começa a apresentar lucros normalmente a partir de uma linha com três produtos.
Inicialmente, a abordagem de linha de produtos exige um grande esforço, visto que cada produto deve ser projetado tendo em vista a generalisação e o reuso, pois a elaboração visa que outros produtos utilizem os elementos desenvolvidos para este primeiro produto.
A experiência deste estudo de caso mostrou que a medida que outros produtos vão sendo inseridos na linha, estes produtos vão reusando os elementos já desenvolvidos anteriormente, tornando cada vez mais simples a inserção destes novos produtos na linha.
A partir de uma visão, que se torna cada vez mais complexa, do desenvolvimento de software focado na qualidade, diversos pesquisadores trabalham em técnicas para facilitar o processo de teste de software.
Uma das abordagens propostas para a simplificação do processo de testes é através do uso dos modelos do sistema sob teste, para proporcionar informações sobre como este teste deve ser realizado, provendo assim uma oportunidade de automatização da geração de casos de teste.
Esta abordagem é conhecida como testes baseados em modelos.
Devido a grande quantidade de visões sobre o que deve ser testado no sistema sob teste, diversas abordagens de testes baseados em modelos surgem diariamente.
Embora as abordagens apresentem características diferentes, alguns requisitos básicos são comuns nos diferentes tipos de teste de software.
Em este trabalho foi proposto uma aglutinação dos requisitos comuns das abordagens de teste baseados em modelos através de uma arquitetura de linha de produtos de software, proporcionando assim o reuso dos elementos arquiteturais comuns destas abordagens, facilitando a implementação de ferramentas, diminuindo o tempo de desenvolvimento e aumentando a qualidade destas ferramentas, sendo estas vantagens providas por os conceitos de linha de produtos de software.
Para alcançar uma maior compreensão do domínio do problema, foi realizado um estudo de caso, sendo este estudo um projeto do Centro de Pesquisa em Computação Aplicada da Pontifícia Universidade Católica do Rio Grande do Sul em cooperação com a empresa HewlettPackard.
Este estudo de caso foi realizado através de uma linha de produtos composta por três abordagens de teste de software baseados em modelos UML.
A partir de a análise individual destas abordagens, junto com o estudo das demais abordagens de testes baseados em modelos existentes na literatura, foi desenvolvida a arquitetura de linha de produtos de testes de software baseados em modelos UML.
Através desta arquitetura de referência, cada ferramenta de teste foi desenvolvida, focando sempre no reuso de software.
Como trabalhos futuros, pretende-se inserir outras abordagens de teste, como por exemplo testes em arquiteturas orientadas a serviços.
Pretende-se também tornar esta arquitetura dinâmica, através da descrição da arquitetura numa linguagem de descrição de arquitetura (ADL -- Architecture Description Language) assim como utilizar os benefícios da programação orientada a aspectos para classificar os diferentes produtos da linha em nível de código, podendo assim expandir a quantidade de produtos da linha de forma clara e simples.
