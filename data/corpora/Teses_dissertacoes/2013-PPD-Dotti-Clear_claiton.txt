A possibilidade de geração de contraexemplos e testemunhas é um dos principais atrativos da técnica de Verificação de Modelos.
Os contraexemplos são uma boa fonte para depuração do sistema, pois são gerados quando uma especificação é refutada por o modelo.
Já as testemunhas ratificam a satisfação de uma especificação por o modelo através de uma execução do sistema.
Esta dissertação de Mestrado é parte de um projeto de construção de um verificador de modelos para modelos descritos em Redes de Autômatos Estocásticos e trata da implementação da geração de contraexemplos e testemunhas para a ferramenta.
Palavras-Chave: Contraexemplos, testesmunhas, Redes de Autômatos Estocásticos, Verificação de Modelos.
Trabalho parcialmente suportado por os projetos FAPERGS PqG 1014867 e CNPq 560036/2010-8 &quot;Verificação de Modelos Descritos em Redes de Autômatos Estocásticos».
Um sistema está correto quando ele implementa o serviço definido como sua função.
Sistemas baseados em software são utilizados para controlar os mais diversos tipos de serviços, desde o computador de bordo de um automóvel até o controlador de voo de uma aeronave, onde por exemplo, falhas não são admitidas, uma vez que podem provocar a perda de inúmeras vidas humanas.
A demanda por sistemas cada vez mais complexos e robustos torna importante a verificação da correção destes sistemas, uma vez que, como mencionado, a falha de um software pode levar a perdas não só de ordem financeira, mas também humana.
Porém, garantir que um sistema esteja correto não é uma tarefa fácil.
Conforme Clarke, mais tempo é gasto na verificação do que na construção de projetos de hardware e sistemas complexos.
Tendo em vista a necessidade de verificar a correção de sistemas e garantir sua confiabilidade, no decorrer de os últimos anos, importantes técnicas de verificação foram desenvolvidas.
Entre elas, a técnica de verificação de modelos mostra- se atrativa por permitir a geração de contraexemplos e testemunhas como saídas para o usuário.
A técnica possui como entrada o sistema que será verificado, descrito por algum formalismo na forma de um sistema de transição de estados e a especificação que será avaliada, descrita em lógica temporal.
Quando o resultado da verificação é falso, ou seja, o modelo não atende à especificação avaliada, o verificador de modelos gera para o usuário um contraexemplo, que nada mais é do que uma sequência de estados e transições que mostra um trace de execução onde o sistema refuta aquela especificação.
Por outro lado, quando o resultado da verificação é verdadeiro, ou seja, o sistema atende à especificação avaliada, o verificador pode gerar uma testemunha, isto é, uma sequência de estados e transições que mostra um trace de execução onde o sistema satisfaz a especificação avaliada.
Segundo Clarke e Veith, muitas pessoas usam a verificação de modelos em razão de a característica de geração de contraexemplos, pois eles têm um grande valor para depuração do sistema.
Em relação a os formalismos utilizados para modelagem de sistemas, Redes de Autômatos Estocásticos, SAN (Stochastic Automata Networks, em inglês) mostra- se atraente, pois, é um formalismo adequado para modelagem de sistemas e focado principalmente em avaliação de desempenho.
SAN tem sido utilizada para modelar diferentes tipos de sistemas, como:
Programas paralelos mestre/ escravo, rede wireless adhoc, linha de produção, equipes de desenvolvimento de software, entre outros.
Um diferencial de SAN perante outros formalismos markovianos usados para descrição de modelos de sistemas, reside no fato do formalismo suportar o conceito de funções, que avaliam o estado global de uma rede de autômatos.
O uso de funções pode descrever dependências entre autômatos e permite a descrição de comportamentos complexos de uma forma compacta.
SAN, ao contrário de outros formalismos, não possui uma ferramenta que dê suporte à verificação de seus modelos.
Como exemplos de formalismos que possuem um verificador é possível citar:
Cadeias de Markov com o PRISM, Redes de Petri com o SMART e Álgebra de Processos com o FDR (Failures Divergence Refinement).
Uma ferramenta de suporte à verificação de modelos contribui, através da geração de contraexemplos, para detecção e então correção de erros por os modeladores.
Este conjunto de fatores, ou seja, a importância de verificar a correção de sistemas, os atrativos da técnica de verificação de modelos, aliados ao fato de SAN não possuir uma ferramenta que verifique os diversos modelos já descritos com o formalismo, tornam relevantes os esforços em construir um verificador de modelos para SAN.
O trabalho apresentado ao longo de esta dissertação está inserido dentro de o projeto de construção de um verificador de modelos para o formalismo de Redes de Autômatos Estocásticos, verificador que recebeu o nome de SAN Model Checker, e tem como objetivo implementar a geração de contraexemplos e testemunhas para a ferramenta.
Ao longo de o texto são apresentados ao leitor, além de os conceitos de compreensão necessária para o entendimento do trabalho, os primeiros resultados obtidos no sentido de construir um verificador para SAN, bem como a estratégia e algoritmos desenvolvidos que possibilitaram a implementação do recurso de contraexemplos e testemunhas para a ferramenta.
A bateria de testes utilizada para analisar e demonstrar o comportamento do algoritmo de geração de contraexemplos e testemunhas compreendeu a definição de um conjunto de 48 especificações, descritas em lógica temporal ramificada (Computation Tree Logic, em inglês).
Algumas das especificações criadas possuem sentido semântico para os problemas apresentados, outras contudo, foram criadas apenas com o propósito de demonstrar o funcionamento do algoritmo implementado.
Com a intenção de verificar a coerência dos resultados alcançados, as saídas geradas por o SAN Model Checker para 18 das especificações criadas foram comparadas às saídas geradas por o NuSMV Model Checker para os mesmos modelos e especificações.
Em este ponto, torna- se importante ressaltar que o SAN Model Checker, diferentemente do NuSMV, não faz uso de técnicas para geração de contraexemplos e testemunhas que gerem o resultado mais curto possível, no que se refere ao tamanho do trace de execução apresentado.
Por fim, o foco e motivação do trabalho que será apresentado no decorrer de esta dissertação é a geração de contraexemplos e testemunhas para o verificador de modelos descritos em Redes de Autômatos Estocásticos.
O trabalho é organizado da seguinte forma:
O Capítulo 2 apresenta conceitos sobre Redes de Autômatos Estocásticos, verificação de modelos, lógicas temporais e contraexemplos e testemunhas, necessários para a condução deste trabalho.
O Capítulo 3 apresenta a arquitetura do verificador de modelos descritos em Redes de Autômatos Estocásticos.
O Capítulo 4 detalha a estratégia utilizada e os algoritmos desenvolvidos para implementação do recurso de contraexemplos e testemunhas na ferramenta.
O Capítulo 5 mostra os experimentos realizados para demonstrar o funcionamento da ferramenta e a comparação dos resultados gerados por ela com os resultados gerados por o NuSMV Model Checker.
O Capítulo 6 faz as considerações finais do trabalho realizado e trata de trabalhos futuros viabilizados com o trabalho apresentado.
O trabalho também é composto por três apêndices, que são os modelos SAN em formato de texto utilizados ao longo de a dissertação e nos experimentos realizados.
Este capítulo é dedicado ao estudo de conceitos necessários para o entendimento e desenvolvimento do trabalho.
Em a Seção 2.1, o formalismo de Redes de Autômatos Estocásticos é apresentado, seguido por três exemplos de modelos utilizados ao longo de a dissertação.
A Seção 2.2 trata da técnica de verificação de modelos, utilizada para verificar a correção de sistemas.
A técnica possui como entrada um sistema descrito por um formalismo, por exemplo, Redes de Autômatos Estocásticos, na forma de um sistema de transição de estados e uma especificação, descrita em lógica temporal.
A Seção 2.3 introduz conceitos sobre lógica temporal, para então apresentar a lógica temporal ramificada (Computation Tree Logic -- CTL, em inglês) e sua forma existencial normal (Existential Normal Form -- ENF, em inglês).
A Seção 2.4 apresenta os conceitos de contraexemplos e testemunhas para fórmulas CTL.
Além disso, a seção também aborda conceitos de contraexemplos e testemunhas em árvore e contraexemplos e testemunhas para fórmulas CTL em ENF.
Em a Seção 2.5 são apresentados dois trabalhos relacionados a este:
Implementing a CTL Model Checker Checking de Clarke.
Redes de Autômatos Estocásticos ou em inglês Stochastic Automata Networks, SAN, é um formalismo para modelagem de sistemas com grande espaço de estados.
Com SAN é possível modelar um sistema em vários subsistemas que interagem ocasionalmente.
Um modelo SAN é descrito por um conjunto de autômatos, cada qual com um conjunto de estados e transições.
As transições num autômato são associadas a eventos, locais ou sincronizantes, que disparam a transição.
Os eventos locais alteram o estado de um autômato e permitem aos autômatos ter comportamentos paralelos.
Já os eventos sincronizantes alteram o estado de dois ou mais autômatos simultaneamente.
Eles proporcionam interação entre os autômatos por o fato de existir sincronismo no disparo das transições.
Autômatos Um autômato é um modelo matemático de um sistema, com entradas e saídas discretas.
O sistema pode se encontrar em qualquer um dos estados que compõem esse sistema.
A Figura 2.1 modela um sistema através de três autômatos.
Cada autômato possui três estados:
Thinking, Left e Right.
O estado individual de cada autômato representa o seu estado local.
A transição entre os estados de cada autômato pode ser local ou sincronizante.
O estado global ou espaço de estado produto de uma Rede de Autômatos Estocásticos é dado por a combinação dos estados locais de cada autômato pertencente à rede.
Transições Locais As transições locais alteram o estado de um autômato, ou seja, alteram o espaço de estado produto do sistema através da mudança do estado de um autômato.
Essas transições permitem aos autômatos ter um comportamento paralelo.
Em a Figura 2.1 todos os eventos são locais.
É importante salientar que apesar de os eventos locais serem independentes, eles são disparados um de cada vez, visto que a escala de tempo contínuo, dois ou mais eventos não ocorrem ao mesmo tempo.
Transições Sincronizantes As transições sincronizantes alteram o estado de dois ou mais autômatos simultaneamente.
De a mesma forma que transições locais, elas alteram o espaço de estado produto do sistema.
As transições sincronizadas proporcionam interação entre os autômatos por o fato de existir sincronismo no disparo das transições.
Em o exemplo da Figura 2.2 os eventos tx5, g1, 2, g2, 3, g3, 4, g4, 5 e g5, 6 são sincronizantes.
Taxas e Probabilidades Funcionais As taxas e probabilidades funcionais representam outra forma de representar interação entre os autômatos numa rede e representam também a característica que difere SAN de outros formalismos como Redes de Petri e Cadeias de Markov.
As taxas funcionais permitem o disparo ou não de um evento dependendo do estado de outro (s) autômato (s) referenciados (s) na função.
Em a Figura 2.1, o evento t_ r_ 1 possui uma taxa funcional f4 e só ocorrerá se o estado do filósofo dois (Fil2) é Thinking.
Para o melhor entendimento de SAN, abaixo são brevemente descritos alguns modelos utilizados ao longo deste trabalho.
Jantar dos Filósofos A Figura 2.1 ilustra o modelo SAN para o clássico problema do Jantar dos Filósofos para três filósofos.
Os filósofos estão dispostos numa mesa que possui o número de garfos e pratos igual ao número de filósofos sentados à ela.
Eles podem estar num dos três estados possíveis, que são:
Thinking, Right ou Left.
Para comer, um filósofo precisa de dois garfos, dessa forma, quando um filósofo está comendo, seus dois vizinhos não podem comer.
Em o modelo representado por a Figura 2.1 quando um filósofo destro está com fome ele pega o garfo da direita, se for canhoto ele pega o da esquerda;
Representado na figura por as transições Thinking para Right, para filósofos destros e Thinking para Left para o filósofo canhoto.
Para passar para o estado comendo os filósofos precisam pegar o segundo garfo.
Essa mudança de estado para os filósofos destros é representada por a transição Right para Left e para o filósofo canhoto, por a transição Left para Right.
Após comer, os filósofos voltam ao estado Thinking, representado na figura por as transições Left para Thinking, para filósofos destros e Right para Thinking para o filósofo canhoto.
Em o modelo representado por a Figura 2.1, apenas o último filósofo (Fil2) é canhoto.
As funções st e nb são utilizadas respectivamente para consultar o estado de um autômato e o número de autômatos num determinado estado.
O exemplo da Figura 2.1 utiliza apenas eventos locais.
As transições rotuladas por os eventos l_ t _0, l_ t_ 1 e r_ t_ 2 são locais e não dependem do estado de algum outro autômato na rede.
Por outro lado, todas as demais transições dependem da disponibilidade de um garfo e portanto são rotuladas com eventos que possuem dependências funcionais, por exemplo o evento t_ r _0 que possui a taxa funcional f1 e somente ocorrerá se o estado do filósofo 1 for diferente de Lef t..
A Figura 2.2 ilustra um modelo para cálculo de vazão líquida de dados de uma rede wireless adhoc com seis nodos.
Em o modelo três diferentes tipos de autômatos foram definidos:
Linha de Produção A Figura 2.3 apresenta o modelo SAN equivalente a um modelo de rede de filas de uma linha de produção com três estações, apresentado em.
Em este modelo SAN cada estação Mi e seu buffer Bi é modelada como um autômato, chamado Mi.
A primeira estação M1 não é modelada pois é considerado que esta estação nunca deixa de enviar trabalho para a estação M2 com taxa µ1.
O número de estados de cada autômato é dado por a combinação da ocupação do buffer (ni) e o estado (si) para a estação i, dessa forma, considerando que a estação M2 tem um buffer B2 $= 1 e a estação M3 tem um buffer B3 $= 1, o número de estados de cada autômato é respectivamente:
E. Se si $= 0, a estação i está vazia e ociosa, ou seja, ela não está trabalhando.
Se si $= 1, a estação i está ocupada e pode estar ou não trabalhando, dependendo se está bloqueada ou não.
Se si $= 2, a estação i está ocupada e está bloqueando a estação anterior e pode ou não estar trabalhando, dependendo se está bloqueada ou não.
Por exemplo, se s3 $= 2 a estação três está trabalhando e bloqueando a segunda estação.
O evento local r1, 2 com taxa µ1 representa a chegada de um trabalho da estação M1 para M2.
O evento local r3, x é a saída da estação M3 enquanto que o evento sincronizante r2, 3 é a (b) (u) passagem de trabalho entre as estações M2 e M3.
Os eventos r2, 3 e r3, x representam a relação (b) entre as estações M2 and M3, ou seja, a estação M3 está ocupada e bloqueando a estação M2 (r2, 3) (u) ou ela completa seu trabalho e desbloqueia M2 (r3, x).
Maiores detalhes sobre os modelos podem ser encontrados em.
Verificação de Modelos Verificação de Modelos, em inglês Model Checking, é uma técnica utilizada para verificar a correção de sistemas.
Em esta abordagem o sistema a ser verificado é modelado como um sistema de transição de estados finito e as especificações são expressas em lógica temporal, tema da próxima seção.
Conforme Clarke, o problema de Model Checking pode ser definido como:
Seja M um modelo do sistema, isto é, um grafo de transição de estados e f uma especificação descrita em lógica temporal, encontre todos os estados s de M tal que M, s| $= f..
Através da exploração de todo o espaço estado do sistema de transição de estados é possível verificar se a fórmula é satisfeita.
Em seu artigo em comemoração ao aniversário de Model Checking, Edmund Clarke lista algumas vantagens da técnica:
Sem provas.
O usuário do verificador não precisa construir provas.
Em princípio, é necessário apenas entrar com a descrição do sistema a ser verificado e a especificação a ser avaliada.
A verificação é automática.
A lógica temporal pode facilmente especificar várias das propriedades que são necessárias quando se trata de sistemas concorrentes.
Contraexemplos. Se uma especificação não é satisfeita, o Model Checker irá retornar um contraexemplo, ou seja, um caminho (sequências de estados e transições) que mostra a razão por a qual uma especificação não é satisfeita.
Também é possível a geração de uma testemunha para quando uma especificação é atendida, isto é, um caminho que ratifica a satisfação da fórmula por o modelo.
A Figura 2.4 mostra um típico sistema de verificação de modelos (Model Checker) onde o verificador de modelos possui como entrada o modelo que será verificado e a especificação ou fórmula que será avaliada sobre o modelo.
Como saída o verificador pode prover um contraexemplo ou uma testemunha, dependendo do resultado da verificação como falso ou verdadeiro ou, ainda, o modelo pode ser não tratável por o verificador.
Isso ocorre em virtude de o problema de explosão do espaço de estados, comum em sistemas que possuem muitos componentes que interagem entre si.
Lógicas Temporais As lógicas temporais são utilizadas para descrever a ordem relativa de eventos de um sistema.
Elas podem descrever como o sistema se comporta ao longo de o tempo ou que configurações ele toma ao longo de o tempo de execução.
Em Model Checking, as especificações descritas em lógica temporal são verificadas contra o modelo do sistema.
Como dito na seção anterior, o modelo do sistema pode ser visto como um grafo de transição de estados.
Cada estado no grafo é definido por um conjunto de proposições que são verdadeiras naquele estado.
De esse modo, uma fórmula pode ser verdadeira para alguns estados e falsa para outros, numa mesma execução.
Lamport argumentou que as propriedades que podem ser impostas sobre os modelos encontram- se basicamente em duas categorias:
Safety e liveness.
Safety: Esse tipo de propriedade tipicamente é caracterizada como &quot;algo ruim nunca acontece».
Um sistema satisfaz tal propriedade se não realiza alguma tarefa proibida.
Por exemplo, o verificador jamais proverá ao usuário uma testemunha quando o usuário solicitar um contraexemplo.
Liveness: Esse tipo de propriedade é caracterizada por &quot;algo bom acontecerá».
Para satisfazer essa propriedade o sistema realizará alguma atividade esperada.
Por exemplo, o verificador proverá ao usuário uma testemunha, quando o usuário solicitar uma testemunha.
As lógicas temporais oferecem diferentes pontos de visão em relação a a estrutura de tempo em que o sistema muda:
Linear: A lógica temporal linear (LTL -- Linear Temporal Logic) assume o tempo como uma sequência de execuções do sistema onde cada possível caminho de computação é considerado separadamente, levando em consideração apenas uma sequência de execução.
Ramificada: A lógica temporal ramificada considera vários caminhos alternativos a partir de um ponto dado, e todos os caminhos de computação são considerados simultaneamente.
Dentro de o grupo de lógicas temporais ramificadas estão a CTL (Computation Tree Logic) e a CTL*, que é um superconjunto de LTL e CTL.
Não fazem parte do escopo deste projeto a especificação de fórmulas em LTL ou CTL*.
Maiores detalhes sobre estas lógicas temporais são encontrados em.
Conforme Baier e Katoen, CTL tem uma sintaxe de dois estágios, classificados como fórmula de estado e fórmula de caminho.
As fórmulas de estado são afirmações sobre os estados do modelo.
Já as fórmulas de caminho expressam propriedades sobre ramos de computação.
Fórmulas CTL de estado são formadas de acordo com a seguinte gramática:
Onde a AP (conjunto de proposições atômicas) e é uma fórmula de caminho.
Fórmulas CTL de caminho são formadas de acordo com a seguinte gramática:
Os operadores temporais e não aparecem na gramática da CTL pois, conforme Baier e Katoen eles podem ser derivados com o operador, conforme:
A Figura 2.5 mostra algumas fórmulas CTL e seu significado numa árvore de execução do sistema.
Para entendimento, considere um sistema de transição de estados T S $= (S, I, R, L) sobre um conjunto de proposições atômicas AP onde:
De esse modo, interpretamos as fórmulas apresentadas na Figura 2.5 da seguinte forma:
Preto -- a partir de s existe algum s com R (s, s) tal que T S, s| $= preto ou seja, algum próximo estado satisfaz preto;
Preto -- todo estado s tal que R (s, s) há T S, s| $= preto ou seja, todos próximos estados satisfazem preto;
T S, sj| $= cinza, incluindo o estado inicial s, ou seja, existe um caminho ao longo de o qual cinza é satisfeito até que um estado preto seja alcançado, desse modo o caminho satisfaz a fórmula cinza preto;
Os quantificadores de caminho podem ser representados por letras, a saber:
­ o quantificador existencial pode ser representado por a letra E. De a mesma forma, os operadores temporais também podem ser representados nas fórmulas por letras, conforme os exemplos abaixo:
CTL -- Forma Existencial Normal A lei de dualidade para quantificadores de caminho mostra que fórmulas quantificadas universalmente podem ser tratadas e representadas por fórmulas equivalentes quantificadas existencialmente.
A Forma Existencial Normal (Existential Normal Form -- ENF) não usa o quantificador universal e define as fórmulas em CTL usando os operadores básicos:,
e. Conforme Baier e Katoen, as fórmulas CTL em ENF são formadas de acordo com a seguinte gramática:
Para o quantificador universal ser eliminado são necessárias transformações de acordo com as equivalências:
O algoritmo implementado no verificador de modelos SAN, apresentado neste trabalho, aceita como entrada uma fórmula CTL, que pode estar ou não na forma ENF, contudo, um parser é utilizado para converter a fórmula CTL de entrada para uma fórmula ENF equivalente.
O fato do algoritmo implementado computar somente fórmulas CTL em ENF reduz o escopo de fórmulas CTL que devem ser consideradas por a ferramenta.
Esse fato não representa uma limitação em relação a a capacidade de representação de uma fórmula em CTL, uma vez que, conforme Baier e Katoen, os demais operadores CTL podem ser derivados utilizando somente a forma ENF.
Contraexemplos e testemunhas Uma das mais importantes vantagens de Model Checking sobre outras técnicas é a possibilidade da geração de contraexemplos para o caso de uma fórmula ser refutada.
Edmund Clarke afirma que esta possibilidade tem valor inestimável para depuração de sistemas complexos e que muitas pessoas usam Model Checking em razão de esta característica.
Quando um modelo sendo validado atende à uma especificação descrita em lógica temporal, o verificador de modelos gera uma resposta positiva, indicando ao usuário que o modelo atende à especificação.
Em este caso, o verificador pode gerar, ainda, uma testemunha, isto é, uma execução que mostra que a especificação é atendida por o modelo.
Caso o resultado da verificação seja falso, ou seja, o modelo não atende à especificação avaliada, o verificador gera um contraexemplo, isto é, uma execução que mostra o porquê daquela especificação não ser atendida no modelo.
Uma questão importante e que deve ser levada em consideração, é a de que para CTL a geração de contraexemplos para fórmulas em ENF é mais complicada, devido a o quantificador existencial.
Para uma fórmula quantificada universalmente, um contraexemplo seria uma sequência modelo que satisfazem.
O contraexemplo para esta situação é todo o espaço de estados do modelo, o que torna inviável sua apresentação.
O mesmo é verdade para a geração de testemunhas para fórmulas quantificadas universalmente, isto é, a testemunha teria de garantir que todas as execuções dentro de o modelo satisfazem.
De esse modo, contraexemplos são gerados para fórmulas quantificadas universalmente, enquanto que testemunhas são geradas para fórmulas quantificadas existencialmente.
A Tabela A seguir são apresentados os conceitos de contraexemplos e testemunhas para fórmulas CTL.
Serão consideradas as fórmulas, e, onde e representam outras fórmulas CTL ou proposições atômicas aninhadas, pois, a partir destes operadores temporais outros podem ser derivados, conforme abordado por a Seção 2.3.
Para entendimento considere o sistema de transição de estados T S $= (S, I, R, L) apresentado na mesma seção (2.3).
Contraexemplo: Um contraexemplo para $= é um par de estados (s, s') com s I e s'S tal que s'| $= e R (s, s).
A Figura 2.6 ilustra o contraexemplo para o operador Next, os círculos branco e cinza representam respectivamente os estados s e s.
Testemunha: Uma testemunha para $= é um par de estados (s, s') com s I e s'S tal que s'| $= e R (s, s).
A Figura 2.7 representa uma testemunha do operador Next, onde o estado s representado por o círculo cinza satisfaz.
Contraexemplo: Um contraexemplo para $= é um fragmento de caminho que indica:
Para o primeiro caso, o contraexemplo é um caminho como ilustrado por a Figura 2.8.
Note que no exemplo, todos os estados satisfazem¬ e ao longo de o caminho um ciclo é detectado, ou seja, o contraexemplo é um caminho que satisfaz(¬) com o formato:
Onde sn $= sr, evidenciando um ciclo.
Para o segundo caso, o contraexemplo é um caminho que satisfaz(¬) com formato:
Com sn A Figura 2.9 ilustra o contraexemplo com este formato.
O contraexemplo parte de um estado que satisfaz¬ e percorre estados com a mesma característica até que um estado que satisfaça¬ seja alcançado.
Testemunha: Uma testemunha para a fórmula $= é um fragmento de caminho com sn| $= e si| $= para 0 i\ n As testemunhas podem ser determinadas por uma busca para trás iniciando no conjunto de estados.
A Figura 2.10 ilustra uma testemunha para o operador.
A testemunha parte de um estado que satisfaz, percorrendo estados com a mesma característica até que um estado que satisfaça seja alcançado.
Operador Always () tal que si| $= para 0 i n e sn| $ .
Contraexemplos podem ser determinados por uma busca para trás, iniciando nos estados¬.
A Figura 2.11 ilustra um contraexemplo para o operador.
O contraexemplo é um caminho com estados que satisfazem terminando com um estado que não satisfaz.
Testemunha: Uma testemunha para mesma fórmula consiste num caminho que satisfaz no formato:
Com sn $= sr, evidenciando assim um ciclo.
As testemunhas podem ser obtidas através da busca por um ciclo simples no dígrafo G $= (S, E) onde o conjunto de arestas E é obtido das transições que emanam dos estados, isto é, E $= (s, s)| R (s, s) s| $ .
A Figura 2.12 ilustra uma testemunha para este caso, onde um ciclo é detectado no segundo e quarto estados.
Como exemplo considere a Figura 2.13, que representa o grafo de transição de estados do modelo do Jantar dos Filósofos, apresentado por a Figura 2.1.
Em esta figura, a letra T representa o estado Thinking, a letra R, o estado Right e a letra L o estado Left.
Os filósofos aparecem na seguinte ordem:
Fil2, Fil1 e Fil0.
Agora, considere as seguintes fórmulas CTL:
EFEG (estado do filósofo um $= Right) e EF (estado do filósofo zero $= Left).
A primeira fórmula afirma que existe um caminho no grafo de execução que leva a um ciclo (representado por o operador EG) onde o filósoso 1 permanece no estado Right.
A Figura 2.14 mostra a testemunha para esta fórmula.
Já a segunda fórmula afirma que existe no futuro um caminho que levará a um estado onde o filósofo zero está comendo.
Uma testemunha para esta fórmula é apresentada por a Figura 2.15.
Contraexemplos e Testemunhas em árvore Os conceitos apresentados acima tratam de contraexemplos e testemunhas lineares ou trace contraexemplos e testemunhas.
A maioria dos verificadores de modelos, incluindo o NuSMV, geram resultados em formato de trace para especificações CTL.
Contudo, considere o exemplo¬ x¬ y retirado de.
Um contraexemplo para esta fórmula tem de descrever dois traces, um finito que leve a um estado satisfazendo x e outro em que há um caminho infinito ao longo de o qual y é sempre verdade.
Isto significa que o contraexemplo tem de ser um modelo para x y.
Outro exemplo mais complicado é dado por fórmulas como x onde um contraexemplo tem de provar que existe um caminho ao longo de o qual um estado¬ x pode ser alcançado num passo.
Os exemplos acima demostram que trace contraexemplos não são completos para fórmulas quantificadas universalmente.
Clarke e Veith afirmam que a adequação de trace contraexemplos foi um ponto cego por anos, mas que começou a ser considerado por.
Ainda conforme Clarke e Veith, trace contraexemplos estão intimamente relacionados ao fragmento linear da CTL, ou seja, CTL LTL.
A geração de contraexemplos e testemunhas no formato de árvore não faz parte do escopo deste trabalho, portanto, a ferramenta irá gerar como resultado apenas contraexemplos e testemunhas lineares.
Contraexemplos para fórmulas na Forma Existencial Normal -- ENF Conforme citado na Seção 2.3, o algoritmo implementado na ferramenta apresentada neste trabalho considera apenas fórmulas CTL na Forma Existencial Normal (ENF).
Isso delimita o escopo da ferramenta a buscas por testemunhas dentro de o modelo, visto que apenas testemunhas podem ser obtidas a partir de fórmulas quantificadas existencialmente.
De essa forma, é necessário fazer a manipulação da árvore sintática que representa a fórmula ENF equivalente à fórmula quantificada universalmente, para que a testemunha que deverá ser encontrada equivalha a um contraexemplo da fórmula original, quantificada universalmente.
Para tanto, é realizada a negação da fórmula em ENF que é equivalente a fórmula original, chegando aos resultados apresentados na Tabela 2.2.
A coluna Fórmula original apresenta a fórmula quantificada universalmente.
A coluna ENF equivalente mostra a fórmula em ENF equivalente à fórmula original.
Já a coluna Contraexemplo mostra o formato que a testemunha deve ter para representar um contraexemplo da fórmula original.
Em o trabalho intitulado Implementing a CTL Model Checker[ 21], Heljanko apresenta um algoritmo não recursivo para verificação de modelos.
A principal contribuição do autor no trabalho, foi a criação de um algoritmo para model checking com complexidade de tempo e uso de memória iguais ou menores do que os algoritmos ALMC (The Local Model Checking Algorithm) e EMC (Extended Model Checking), utilizados como base para o desenvolvimento.
A estratégia utilizada por o autor foi a de armazenar os valores verdade de cada subfórmula para cada estado do modelo.
Para tanto, foi definida uma ordem de avaliação para fórmulas CTL.
Conforme o exemplo dado por o autor, a ordem parcial para a fórmula (p (q¬ p) é a mostrada por a figura 2.16.
As setas indicam a dependência entre as subfórmulas e os valores ao lado, a ordem total entre elas.
O algoritmo armazena numa matriz L, onde s é um estado que pertence ao conjunto de estados S do modelo e i é o índice de uma subfórmula que compõe a fórmula de nível maior, o valor verdade de cada subfórmula para cada estado.
Conforme Heljanko, o algoritmo tem uma estrutura similar aos algoritmos ALMC e EMC diferenciando- se por o fato de possuir o recurso de contraexemplos e testemunhas e por a maneira como faz a verificação do operador until.
Baseado na definição deste operador, o algoritmo marca ou não estados, dependendo do valor verdade da subfórmula da esquerda e da direita em cada estado.
A Tabela 2.3 mostra como é realizada a rotulação dos estados para o caso da fórmula 1 2.
A coluna Rótulo para fórmula representa o valor verdade para a fórmula 1 2 num determinado estado.
A coluna Rótulo lado esquerdo representa o valor verdade de 1 para o estado, a coluna Rótulo lado direito o valor verdade de 2, enquanto que a coluna Marcado indica se o algoritmo já definiu o valor verdade da fórmula de nível maior para aquele estado.
Como podemos observar, existe apenas um caso em que o algoritmo não pode determinar o valor verdade da fórmula.
Este caso é aquele em que o lado esquerdo da fórmula com operador until é verdade e seu lado direito é falso.
Para este caso, o algoritmo precisa avaliar um estado posterior a fim de determinar o valor verdade da fórmula.
Tendo o espaço de estados rotulado, a construção de uma testemunha para a fórmula torna- se simples.
O algoritmo realiza uma busca em profundidade no modelo, caminhando por estados que satisfaçam 1 até que um estado que satisfaça 2 seja encontrado.
À medida que o caminhamento é realizado, os estados percorridos são armazenados numa lista, que ao final conterá a testemunha para a fórmula.
Por fim, o artigo apresenta considerações sobre a construção de contraexemplos e testemunhas para fórmulas CTL*, pois, segundo os autores, muitas propriedades sobre projetos de protocolos e circuitos não podem ser expressadas por a CTL, nesses casos, faz- se o uso da CTL extendida, isto O SAN Model Checker, assim como o NuSMV, realiza a verificação simbólica de fórmulas CTL, o verificador faz uso de diagramas de decisão multivalorados (Multivalued Desicion Diagrams -- MDD, em inglês) para codificar o espaço de estados atingível e os estados que satisfazem a fórmula avaliada.&amp;&amp;&amp;
Recomenda- se a leitura dos trabalhos de Sales e Plateau e Sales para maiores detalhes sobre o funcionamento dos diagramas de decisão multivalorados.
Diferentemente do NuSMV, que também utiliza algoritmos simbólicos para a geração de contraexemplos, o SAN Model Checker utiliza algoritmos de busca em profundidade no modelo, empregando uma estratégia semelhente à aplicada por Heljanko para realizar a geração de contraexemplos e testemunhas como saída para o usuário.
A estratégia utilizada para a geração dos resultados é apresentada no Este capítulo descreve a arquitetura do Verificador de Modelos Descritos em Redes de Autômatos Estocásticos (SAN Model Checker).
Cabe ressaltar que o conteúdo apresentado neste capítulo é uma contribuição conjunta entre o autor desta dissertação e os alunos de mestrado Eli Maruani e Lucas Oleksinski.
Os primeiros resultados alcançados na implementação da ferramenta foram publicados em e.
A arquitetura apresentada por a Figura 3.1 é dessa forma, base para o desenvolvimento da arquitetura que será apresentada no Capítulo 4, onde alterações foram feitas com intenção de agregar à ferramenta o recurso de contraexemplos e testemunhas.
A implementação do Verificador é baseada no algoritmo de satisfação de fórmulas CTL (Computation Tree Logic) em ENF (Existential Normal Form) apresentado por Baier e Katoen.
Diagramas de Decisão Multivalorados (Multivalued Decision Diagrams -- MDD) são utilizados para a codificação do espaço de estados atingível (Reachable Space State -- RSS).
MDD's são estruturas de dados representadas por um grafo acíclico direcionado utilizados para armazenar informações de maneira eficiente e sem redundâncias.
A Figura 3.1 mostra a arquitetura do verificador implementado.
Modelo SAN -- Modelo SAN que será verificado.
Estado Inicial -- um ou mais estados iniciais devem ser definidos na função de partial reachability.
Esta função é o ponto de partida para a geração do RSS.
Proposições Atômicas -- proposições atômicas são afirmações sobre o modelo que são avaliadas como verdadeiras ou falsas para cada estado global atingível no modelo.
Uma expressão atômica para SAN é uma expressão SAN sem operadores temporais.
Propriedade CTL -- qualquer propriedade em CTL onde as proposições atômicas são expressões de SAN.
Compilador -- o compilador gera o descritor markoviano, isto é, um conjunto de tensores que quando operados por álgebra tensorial permitem a obtenção de todos os estados da Cadeia de Markov.
As operações soma tensorial e produto tensorial reproduzem a interação e como os diferentes autômatos sincronizam os eventos.
Geração do Espaço de Estados Atingível (RSS) -- o descrito Markoviano é utilizado como um sistema de transição de estados.
Dado um estado inicial, o gerador RSS verifica nos tensores, se há um evento que possa ser disparado.
Caso isso seja possível, um sucessor é alcançado, computado junto ao RSS e codificado via MDD.
Esta é a mesma técnica empregada no SAN Lite- Solver.
Analisador CTL -- este módulo manipula uma fórmula CTL e a armazena numa árvore sintática.
Conversor ENF -- o objetivo do módulo de conversão para ENF é criar uma árvore sintática da fórmula em ENF.
Para tanto ele manipula a árvore sintática da CTL gerando uma árvore sintática em ENF usando regras de equivalência descritas em.
Algoritmo de Satisfação (SAT) -- este algoritmo realiza a verificação da fórmula de entrada no modelo.
A implementação é baseada no algoritmo de Baier e Katoen apresentado por o Algoritmo 1.
Note que o algoritmo de satisfação de fórmulas considera apenas os operadores básicos de caminho de fórmulas CTL em ENF, ou seja, e.
O operador não é considerado, pois, uma fórmula no formato pode ser convertida para uma fórmula equivalente com operador, (true).
Entrada: Sistema de transição finito Ts com conjunto de estados S e fórmula em ENF sub-fórmulas de 1 início caso selecione true faça retorna S;
S: Espaço de estados atingíveis (RSS) P ost (s):
Estados posteriores (sucessores) de um estado s L:
S=2  AP:
Associa a cada s S o conjunto de proposições atômicas L (s) satisfeitas em s O algoritmo possui como entrada um sistema finito de transição de estados Ts com um conjunto de estados S e a fórmula que será verificada.
A saída do algoritmo varia de acordo com o tipo de fórmula de entrada:
True -- retorna o conjunto de estados atingível do modelo (RSS).
A -- retorna o conjunto de estados onde a proposição a é verdadeira. --
retorna a interseção entre os conjuntos de estados que satisfazem 1 e 2.¬ --
retorna a diferença entre o conjunto de estados atingível S e o conjunto de estados que satisfaz. --
inicialmente calcula o menor ponto-fixo, isto é, o conjunto T de estados que satisfazem 2 para depois adicionar a este conjunto os estados que satisfazem 1 e que possuem posteriores que satisfaçam 2, para então retornar o conjunto T. -- inicialmente calcula o maior ponto-fixo, isto é, o conjunto T de estados que satisfazem para depois remover deste conjunto aqueles estados que não possuem posteriores que satisfaçam, para então retornar o conjunto T. O algoritmo de satisfação de fórmulas implementado no SAN Model Checker trata apenas fórmulas CTL em ENF.
De esse modo, ele recebe como entrada uma especificação f já devidamente tratada por o Conversor ENF que é semanticamente equivalente a especificação f dada como entrada no Verificador (ver Capítulo anterior).
Essa característica delimita o escopo da ferramenta a buscas por testemunhas para as especificações avaliadas no modelo.
Destaca- se que, para a geração de um contraexemplo para uma especificação, se faz necessário tratar- la, antes de enviar- la para o algoritmo de satisfação de fórmulas, de forma que a testemunha que será gerada equivalha a um contraexemplo da fórmula original dada como entrada na ferramenta.
Para tanto, quando o usuário faz a solicitação de um contraexemplo, a especificação f tratada por o Conversor ENF é negada gerando uma nova especificação f que é equivalente a um contraexemplo para a especificação original f (ver Tabela 2.2 da Seção 2.4 para alguns exemplos deste tratamento).
A estratégia adotada na geração de contraexemplos e testemunhas foi norteada por o trabalho de Keijo Heljanko, brevemente apresentado na Seção 2.5 desta dissertação, que utiliza o espaço de estados rotulado com o valor verdade de cada (sub) fórmula para o algoritmo de cálculo de testemunhas.
Essa estratégia simplifica a busca por uma testemunha, pois, o cálculo de ela resume- se a caminhar linearmente a partir de um estado inicial válido escolhendo o próximo estado da testemunha conforme o rótulo do estado atual.
O SAN Model Checker limita- se à geração de contraexemplos e testemunhas lineares, ou seja, traces de execução do modelo, de acordo com os conceitos de contraexemplos e testemunhas para os operadores temporais CTL apresentados por Baier e Katoen.
Sendo assim, resultados em formato de árvore (ver Contraexemplos e Testemunhas em árvore da Seção 2.4) não são gerados por o verificador.
Quando a ferramenta identifica um resultado em formato de árvore, ela apenas mostra o estado a partir de o qual o resultado torna- se ramificado, marcando a (sub) fórmula válida naquele estado.
Para agregar ao verificador o recurso de geração de contraexemplos e testemunhas foram realizadas algumas modificações na arquitetura da ferramenta apresentada por a Figura 3.1 do Capítulo 3.
A Figura 4.1 apresenta a arquitetura construída para permitir a geração de contraexemplos e testemunhas.
Em a figura, os itens com linha pontilhada representam as alterações feitas (contribuição deste trabalho) na arquitetura da ferramenta que possibilitaram a geração de contraexemplos e testemunhas como saída para o usuário.
As modificações realizadas acresceram à arquitetura os itens descritos a seguir:
Contraexemplo ou testemunha -- opção feita por o usuário para o resultado gerado por a ferramenta ao verificar uma propriedade.
Ele poderá optar por a geração de um contraexemplo ou uma testemunha.
Tratador ENF -- este método pode modificar a fórmula ENF de acordo com a saída solicitada por o usuário.
Caso o usuário opte por um contraexemplo, este método negará a fórmula ENF antes de enviar- la para o SAT.
Caso o usuário opte por uma testemunha, nenhuma alteração é feita na fórmula ENF.
RSS Rotulado com (sub) fórmulas -- ao término do algoritmo de satisfação (SAT), os índices que codificam no MDD os estados que satisfazem a fórmula CTL e as subfórmulas que a compõem são armazenados na lista Labels (ver Algoritmo 2).
Verificador de estado inicial -- este método realiza a interseção entre o conjunto de estados iniciais do modelo e o conjunto de estados que satisfazem a fórmula, desse modo se há algum estado inicial que satisfaça a fórmula este é armazenado na lista trace e torna- se o ponto de partida para construção da testemunha.
Caso contrário, ou seja, caso não haja algum estado inicial do modelo que satisfaça a fórmula, o programa é encerrado e uma mensagem é mostrada ao usuário.
O Algoritmo 3 mostra o pseudo-código desta rotina.
Estado inicial (s) -- um dos estados iniciais encontrados por o Verificador de estado inicial que satisfaz a fórmula e que está armazenado na lista trace.
Gerador de testemunha -- método que monta, a partir de um estado inicial que satisfaz a fórmula, o trace que representa a testemunha para a fórmula.
Testemunha que pode ter valor semântico de um contraexemplo.
Detalhes em Contraexemplos para Fórmulas na Forma Existencial Normal -- ENF da Seção 2.4.
O Algoritmo 4 mostra o pseudo-código desta rotina.
Testemunha -- trace gerado como saída para o usuário.
Além de as alterações na arquitetura, modificações foram feitas na função de rotulação de estados.
Inicialmente ela rotulava apenas as proposições atômicas utilizadas na fórmula CTL que é avaliada.
Contudo, como o formalismo SAN não possui uma descrição explícita de o (s) estado (s) inicial (is) do modelo, a rotina passou a rotular também os estados que satisfazem a partial reachability dos modelos.
De a perspectiva deste trabalho, estes passaram a ser considerados os estados iniciais.
Para empregar uma abordagem semelhante a usada por Heljanko, o algoritmo de satisfação de fórmulas CTL em ENF apresentado por o Algoritmo 1 foi alterado, dando origem ao Algoritmo 2.
A alteração realizada trata da inclusão da lista Labels no algoritmo.
Esta lista armazena em ordem os valores que codificam no MDD os estados que satisfazem cada subfórmula que compõe a fórmula CTL avaliada, confome descrito abaixo:
A -- neste caso a lista Labels armazena o valor que codifica os estados rotulados com a proposição atômica a (linha 7);
1 2: Calcula- se recursivamente Sat e Sat (2) que adicionarão estes rótulos à lista Labels e logo após, na linha 11, acontece a interseção entre o conjunto de estados que satisfaz 1 e o conjunto de estados que satisfaz 2.
O valor que codifica os estados resultantes desta interseção também é armazenado em Labels, na linha 12;·¬:
Para a fórmulas negadas, a lista Labels armazena os valores que codificam os estados que satisfazem a diferença entre o espaço de estados S e o conjunto de estados que satisfaz.
Esta diferença é calculada por o SAT na linha 16 e o valor que codifica os estados resultantes desta diferença são armazenados em Labels, linha 17;:
Para fórmulas com o operador temporal, a lista Labels armazena o valor que codifica os estados que satisfazem, linha 22, este conjunto de estados é calculado por o algoritmo SAT na linha anterior;:
Calcula- se recursivamente Sat (2) (linha 26) e Sat (1) (linha 27), adicionando estes rótulos à lista.
Logo após, o SAT calcula o conjunto de estados que satisfaz 1 2 adicionando à lista o valor que codifica os estados que estão nesse conjunto, linha 31.:
Para este caso a lista Labels armazena o valor que codifica os estados que satisfazem, linha 40.
De essa forma, a lista Labels, ao final do algoritmo de satisfação, guarda o espaço de estados rotulado com cada subfórmula que compõe a fórmula CTL avaliada.
Katoen Entrada: Sistema de transição finito Ts com conjunto de estados S, fórmula em ENF, lista Labels vazia início caso selecione true faça retorna S;
Faça retorna T;
S: Espaço de estados atingíveis (RSS) P ost (s):
Estados posteriores (sucessores) de um estado s L (s):
Conjunto de labels, ou seja, proposições atômicas que são satisfeitas num estado s f:
Subfórmula que compõe a fórmula O Algoritmo 3 representa o Verificador de Estado Inicial.
Ele é responsável por verificar se existe um estado inicial do modelo que satisfaça a fórmula avaliada e por inserir este estado na lista trace.
Este método tem como entrada o sistema de transição de estados T S, o conjunto I de estados iniciais, a especificação e a lista Labels.
Em a linha 4 é feita a interseção entre o conjunto de estados iniciais e o conjunto de estados que satisfazem a fórmula, recuperados por assim, a construção de uma testemunha para a especificação avaliada.
Algoritmo 3: IniciaTrace (T S, I, Fórmula, Labels) Entrada:
Sistema de transição de estados Ts, conjunto de estados iniciais I, fórmula, Labels Saída:
Trace com o estado inicial que compõe a testemunha Dados:
Trace Dados:
MDD T 1 início/* interseção entre o conjunto de estados iniciais I e o seja Ts $= (S, I, R, L) seja s T trace.
Insere (s);
A construção da testemunha é realizada através do caminhamento em pré-ordem na árvore sintática que representa a fórmula avaliada, ou seja, visita a raiz, o filho da esquerda e então o filho da direita.
Conforme abordado na Seção 2.4, cada tipo de operador de caminho possui um formato de testemunha específico, dessa forma, eles são tratados por o Gerador de Testemunha, Algoritmo 4, da seguinte forma:¬ --
para este caso o algoritmo faz uma chamada recursiva para a fórmula. --
para montar uma testemunha para a fórmula o gerador de testemunha tem de encontrar um sucessor do último estado s armazenado na lista trace, pois este estado armanezado na lista já satisfaz (linha 2, ou seja, $ ), que satisfaça.
Para tanto, o algoritmo armaneza no conjunto T os estados sucessores de s, linha 4 do algoritmo.
Logo após, na linha 5, o algoritmo faz a interseção entre o conjunto de estados T e o conjunto de que pertence ao conjunto T.
Em seguida, o estado encontrado é inserido na lista trace, linha a fórmula. --
para fórmulas compostas por o operador, o algoritmo separa inicialmente em conjuntos diferentes os estados que satisfazem:
1 2, 1 e 2.
Em a linha 23, o conjunto P recebe o conjunto de estados codificados por Labels.
Em a linha 24, o conjunto K recebe o valor que codifica os estados resultantes interseção entre o conjunto de estados codificados por Labels (2) e o conjunto P.
Em a linha 25, o conjunto R recebe o valor que codifica os estados resultantes da interseção entre o conjunto de estados codificados por Labels e o estado P, dessa forma, ambos os conjuntos guardam somente aqueles estados que satisfazem 2 e 1 e que também estejam no conjunto de estados que satisfaz 1 2.
Isso se faz necessário para garantir que o algoritmo irá considerar, na construção da testemunha, apenas aqueles estados que realmente possam levar à construção de um resultado.
Logo após, na linha 26, o último estado armazenado na lista trace é recuperado e armazenado na variável s.
A partir dai, começa a construção da testemunha para a fórmula.
O algoritmo verifica se o estado recuperado da lista trace pertence ao conjunto de estados codificados por Labels, linha 27.
Em caso positivo, o algoritmo guarda em T o conjunto de sucessores deste estado, linha 29.
O algoritmo faz a interseção entre o conjunto T de estados e o conjunto de estados codificados por Labels (2) a fim de verificar se um destes estados armazenados em T está no conjunto de estados codificados por Labels (2), linhas 30 e 31.
Em caso positivo, um destes estados encontrados é recuperado e armazenado na lista trace, linha 33.
O algoritmo encerra a execução, pois uma testemunha já foi encontrada.
Em caso negativo, caso o estado não tenha sucessores no conjunto Labels (2), o algoritmo faz a interseção entre o conjunto T e o conjunto codificado por Labels (1) para recuperar um sucessor que esteja no conjunto codificado por Labels e que não tenha sido inserido em trace, linha 36, 37 e 38, respectivamente.
Isso evita que ciclos sejam percorridos na construção da testemunha para o operador.
O algoritmo vai percorrendo os estados que estão em Labels até que um estado que esteja em Labels (2) seja alcançado, dessa forma uma testemunha de 1 2 é encontrada. --
para construir uma testemunha para uma fórmula composta por o operador, o gerador fórmula, o algoritmo armazena no conjunto T os estados sucessores ao último estado s da lista trace que estejam no conjunto de estados codificados por Labels (), linha 13.
Logo após, um destes estados encontrados é inserido na lista trace, linha 15.
As computações da linha 12 à 15 são repetidas até que um ciclo seja detectado, caracterizando assim a testemunha para o operador.
Após o término destas computações, o método mountTrace é chamado recursivamente para a fórmula.
Algoritmo 4: MountTrace (formula, Labels, Ts, trace) Entrada:
Fórmula, Labels -- conjunto de rótulos das subfórmulas de, Sistema de transição de estados Ts, trace lista com os estados que compõe a testemunha Saída:
Um trace de execução do modelo que representa a testemunha para fórmula avaliada Dados:
Aut_ st s;
Dados: MDD T, P, K, R, Q;
Início caso selecione faça seja s um estado de T trace.
Insere (s);
A ferramenta suporta a geração de testemunhas lineares.
Considerando- se isso, durante a implementação, foram identificados pontos de parada, ou seja, situações em que o resultado a ser gerado deixava de ter formato de trace de execução e passava a ter formato de uma árvore de execução do sistema ou ainda situações em que o resultado de retorno é o espaço de estados inteiro do modelo o que é inviável para apresentação.
A seguir são relacionados os pontos de parada identificados durante a implementação:
Fórmulas aninhadas com formato, ou seja, com o operador Globally como operador mais externo forçam que a partir de cada estado que satisfaz a fórmula exista um caminho que satisfaça a fórmula interna.
Este tipo de fórmula possui um formato de testemunha, com vários ramos, não suportado por a ferramenta.
De esse modo, o tratamento dado a ela é o de construir o trace com os estados que satisfaçam, sem abrir outros caminhos que satisfaçam a fórmula, e apenas marcando que os estados do trace satisfazem.
As características apresentas por os itens 1 e 2 ratificam o fato de que contraexemplos são gerados para fórmulas quantificadas universalmente, enquanto que testemunhas são geradas para fórmulas quantificadas existencialmente.
Para as situações supracitadas o trace gerado é incompleto, ou seja, mostra parte da satisfação ou refutação da fórmula.
O fato de ser incompleto é informado ao usuário.
A implementação do Algoritmo 4 agrega ao que foi apresentado, controles para a geração de resultados lineares, evitando assim a geração de resultados ramificados, gerados nas situações identificadas e apresentadas por os itens 1 ao 4.
Os controles memorizam ao longo de a recursão de mountTrace se a (sub) fórmula em tratamento:
Ao longo de a condução do trabalho, os formatos de especificações que levam a resultados ramificados foram identificados dentro de os pontos de parada supracitados.
De essa forma, com estes controles o algoritmo cobre e trata os casos em que uma testemunha para uma especificação avaliada deixa de ter formato de resultado linear e passa a ter formato de resultado em árvore.
A Figura 4.2 mostra o diagrama de atividades para a geração de uma testemunha no Verificador de Modelos.
O diagrama mostra a interação entre as rotinas do verificador de modelos até a geração do resultado.
A execução é baseada em três personagens:
O usuário, a interface do sistema e o sistema.
O fluxo de atividade começa quando o usuário fornece ao sistema os parâmetros necessários à execução do programa.
Essas informações são:
O modelo SAN que será verificado, a especificação descrita por uma fórmula em CTL que será avaliada, além de o tipo de saída que o usuário deseja obter (um contraexemplo ou uma testemunha).
Caso o número de parâmetros informado seja menor do que o necessário, uma mensagem é exibida por a interface ao usuário, que por sua vez pode reenviar as informações ou cancelar a execução do programa.
Passada a etapa de verificação das informações fornecidas, chega a vez do compilador, de posse do que foi informado, ser executado.
Conforme descrito no Capítulo 3, ele é responsável por gerar o descritor Markoviano, utilizado por o Gerador RSS (Gerador do Espaço de Estados Atingível) do modelo, etapa posterior.
A execução do Analisador CTL, responsável por gerar a árvore sintática da fórmula CTL é realizada logo após o Gerador RSS.
A árvore sintática gerada nesta etapa é utilizada por o Conversor ENF, responsável por gerar a árvore sintática da fórmula CTL em ENF.
Entre essas duas etapas é executada a rotina de Rotulação de Estados, responsável por a rotulação do espaço de estados com as proposições atômicas verdadeiras em cada estado atingível do modelo.
A partir de aí, o Tratator ENF é executado, levando em consideração o tipo de resultado solicitado por o usuário.
Caso o usuário opte por um contraexemplo a fórmula CTL em ENF tem de ser manipulada para que o resultado gerado equivalha a um contraexemplo da fórmula CTL dada como parâmetro para o sistema.
Caso o usuário opte por uma testemunha, nenhuma mudança é feita e a fórmula é enviada para a etapa posterior.
A etapa seguinte consiste na execução do algoritmo de satisfação de fórmulas, SAT.
A saída desta rotina é o conjunto de estados que satisfaz a fórmula e a lista Labels, preenchida com os estados que satisfazem as (sub) fórmulas de.
A próxima rotina a ser executada é o Verificador de Estado Inicial.
A partir de o conjunto de estados que satisfazem a fórmula e do conjunto de estados iniciais do modelo, esta rotina verifica se há algum estado inicial que satisfaça a fórmula.
Em caso positivo, o estado encontrado será o ponto de partida na construção da testemunha, etapa seguinte.
Caso não exista um estado inicial, antes de encerrar o programa, uma mensagem é exibida ao usuário avisando que não há estados iniciais que satisfaçam a fórmula e que por isso uma testemunha não pode ser montada.
O Gerador de Testemunha constrói então, a testemunha para a fórmula avaliada, respeitando os pontos de parada e abordadens adotadas para a geração dos resultados, descritas anteriormente neste capítulo.
Note que a testemunha gerada por a ferramenta pode não ser completa.
Para os casos em que ela não é completa, antes de gravar a testemunha em arquivo, o sistema mostra uma das seguintes mensagens ao usuário:
Testemunha em formato de árvore -- a mensagem Testemunha em formato de árvore, o estado exibido faz parte da testemunha é exibida quando o item 1 ou 2 dos pontos de parada ocorrer.
O resultado da solicitação é todo o espaço de estados do modelo, ou seja, a árvore de execução do sistema.
Em esses casos apenas o estado inicial do modelo é exibido, se este satisfizer a fórmula avaliada.
Testemunha incompleta -- a mensagem A testemunha/ contraexemplo mostra parte da satisfação/ refutação da fórmula é exibida quando:
­ Uma a negação do operador existencial aparecer numa subfórmula da fórmula CTL verificada.
Em esse caso somente um estado que satisfaz a subfórmula é exibido.
Após exibir a mensagem o sistema imprime em arquivo a testemunha encontrada para a fórmula.
Para analisar e demonstrar o comportamento da abordagem adotada para geração de contraexemplos e testemunhas, foram conduzidos testes com os modelos SAN apresentados ao longo de esta dissertação.
Modelos de diferentes tamanhos foram gerados a fim de verificar o comportamento do algoritmo.
Para o modelo do Jantar dos Filósofos foram utilizados modelos com três, cinco e 14 filósofos.
Para o modelo da Linha de Produção foram feitos testes com modelos de três e nove estações.
O modelo de cálculo de vazão líquida de dados de uma rede wireless adhoc foi testado com modelos de dez, 13 e 15 nodos.
Ao todo, 48 propriedades em CTL foram executadas com os três modelos, destas 41 para o modelo Jantar dos Filósofos, quatro para o modelo adhoc e três para o modelo de Linha de Produção.
Algumas de elas têm sentido semântico, como propriedades para verificar starvation e liveness por exemplo;
Outras foram criadas apenas para verificar se o algoritmo apresentava o comportamento esperado dentro de a estratégia e características da implementação descritas no Capítulo 4.
Com a intenção de verificar a coerência das saídas geradas por o SAN Model Checker, os resultados de 18 propriedades foram comparados às saídas geradas por o verificador de modelos NuSMV.
A escolha destas 18 propriedades de entre as 48 testadas, justicase por o fato destas conterem um número maior de operadores temporais e conectivos lógicos na sua composição, representando assim o melhor conjunto de fórmulas, de entre as definidas, para testar o algoritmo implementado.
Comparar as saídas do verificador de modelos em SAN com as do NuSMV foi possível pois, dentro de o projeto de construção de um verificador para modelos descritos em SAN, existe um trabalho em paralelo focado na tradução de modelos SAN para a linguagem do NuSMV Model Checker.
De essa forma, estas 18 propriedades foram avaliadas em modelos iguais em ambos os verificadores.
De estas 18 propriedades, seis apresentaram o mesmo resultado, dando um forte indício da coerência da implementação da geração de contraexemplos e testemunhas para o SAN Model Checker.
Em algumas situações, as propriedades avaliadas apresentaram resultados similares e em alguns casos, resultados diferentes, decorrentes da estratégia adotada ao longo deste trabalho.
São apresentados neste capítulo, por questões de adequação ao espaço disponível, os resultados obtidos com as propriedades testadas em modelos pequenos, isto é, para o modelo do Jantar dos Filósofos são apresentados os resultados obtidos com o modelo de três filósofos;
Para o modelo adhoc, são mostrados os resultados obtidos com o modelo de dez nodos e para o modelo de Linha de Produção, são apresentados resultados para o modelo de três estações.
Os modelos maiores foram utilizados para verificar até que tamanho a ferramenta conseguiu verificar modelos fazendo uso do hardware disponível.
Para realizar os experimentos foi alocada uma máquina do LAD1 (Laboratório de Alto Desempenho da Pontifícia Universidade Católica do Rio Grande do Sul).
A configuração da máquina é a que segue:
DellPowerEdge R610 com dois processadores Intel Xeon Quad-core E5520 2.27 GHz Hyper--treading e 16 GB de memória.
Sistema Operacional Ubuntu (versão servidor) Linux 10.04 de 64 bits.
A seguir são apresentadas as especificações avaliadas em cada um dos modelos apresentados ao longo de a dissertação.
A Seção 5.2 mostra os resultados gerados por os dois verificadores.
Propriedades CTL para SAN Propriedades CTL para modelos SAN são expressões que definem comportamentos desejados sobre um modelo.
As expressões SAN são utilizadas para definir o conjunto de proposições atômicas que compõem uma propriedade.
A seguir, são listadas as propriedades definidas para cada modelo utilizado ao longo de a dissertação.
Propriedades CTL para o Jantar dos Filósofos Para os problema do Jantar dos Filósofos, 11 propriedades foram definidas.
As proposições atômicas definidas para expressar os comportamentos desejados para as propriedades descritas são:
Onde: I representa o índice do filósofo e N o número de filósofos do modelo.
A proposição atômica F ili T hinking denota que o filósofo i está no estado Thinking.
A proposição atômica F ili Right denota que o filósofo i está no estado Right.
Já a proposição atômica F ili Lef t denota que o filósofo i está no estado Left e, por fim, a proposição alguemCome denota algum dos filósofos está comendo, isto é, os filósofos destros podem estar no estado Left ou o filósofo canhoto no estado Right.
Com estas proposições atômicas, foram definidas as seguintes fórmulas CTL:
F il0 $= Right Esta propriedade denota que existe um futuro caminho em que o filósofo zero sempre fica com fome, ou seja, no estado Right.
Esta propriedade denota um comportamento de starvation para o filósofo zero, uma vez que o estado Left nunca é alcançado.
A propriedade foi criada para testar a funcionalidade do algoritmo, pois, a sua conversão para ENF resulta na fórmula:)) e que possuir o maior número de operadores temporais) para montar a testemunha.
Em esse caso, o algoritmo montará um caminho com o ramo direito da conjunção.
F il1 $= Right Esta propriedade verifica se em todos os caminhos de execução do modelo o filósofo 1 fica sempre com fome, ou seja, no seu estado Right.
Esta propriedade também demonstra um comportamento de starvation, contudo ela é um subconjunto da propriedade que representaria starvation para o Fil1, pois, fixa que o filósofo 0 esteja no estado Thinking até que um estado que satisfaça Fil1 no estado com fome (Right) seja alcançado.
F il0 $= T hinking¬ F il1 $= Right Para o caso desta propriedade, foi solicitada a geração de um contraexemplo.
Para tanto, as manipulações necessárias são realizadas, resultando na fórmula temporal:
F il0 $= T hinking.
De essa forma, a execução deste teste visa mostrar o comportamento do algoritmo quando encontra um na fórmula, bem como o comportamento da geração para operadores temporais aninhados, visto que, de acordo com a estratégia adotada o trace será montado com o ramo direito da conjunção, que possui maior número de operadores temporais.
F il0 $= T hinking) (true F il1 $= Right) Em a propriedade acima, o algoritmo terá de escolher novamente entre um dos ramos da conjunção, contudo, nesse caso, como os dois ramos possuem o menos número de operadores temporais, o trace será montado com o ramo esquerdo, visto que essa foi a estratégia definida.
F il2 $= Right A propriedade define que para todo o caminho globalmente, a partir de qualquer estado todos seus sucessores alcancem, num passo, um estado em que o Fil2 está no estado Right.
Este caso visa mostrar o comportamento do algoritmo para busca de contraexemplos de fórmulas aninhadas compostas por o quantificador universal.
A propriedade acima tem intenção de verificar o comportamento do algoritmo para fórmulas com operadores temporais aninhados que também possuem disjunção e implicação de proposições atômicas.
Esta fórmula diz que se o filósofo 0, Fil0, está no estado Thinking ou Right isso implica em que a partir de aquele estado todos os caminhos levem a um caminho futuro em que o estado Left do filósofo um, Fil1, é alcançado.
Propriedade criada para demonstrar o comportamento do algoritmo ao aninhar- se os operadores de caminho e com uma implicação entre eles. (
alguemCome) A propriedade procura se existe um caminho onde um dos filósofos come, isto é, se algum dos filósofos destros alcança o estado Left ou o filósofo canhoto o estado Right.
F il0 $= Lef t Esta propriedade denota que existe um caminho futuro em o qual existe um estado em que o filósofo zero está no estado Left.
Propriedades CTL para o modelo de rede adhoc Para o modelo de rede adhoc quatro propriedades foram escritas para verificar o envio e recebimento de pacotes através da rede.
As proposições atômicas utilizadas nas propriedades são:
Com estas proposições as seguintes propriedades foram definidas:
Esta propriedade verifica se existe um caminho no modelo adhoc onde globalmente, para todos os estados, toda transmissão resulta numa recepção futura por parte de o último nodo da rede.
Esta propriedade verifica se existe um caminho onde uma recepção por parte de o último nodo do modelo não acontece até que uma transmissão por o primeiro nodo ocorra.
Propriedade criada para demonstrar o comportamento do algoritmo ao aninhar os operadores e.
Ela denota que existe um caminho que globalmente a partir de qualquer estado existe um futuro caminho em que o nodo cinco estará no estado T. Esta propriedade diz que não existe um caminho em que globalmente, a partir de qualquer estado, exista um outro caminho em que toda transmissão por parte de o primeiro nodo, resulta numa recepção futura do último nodo.
Propriedades CTL para o modelo de Linha de Produção Para o modelo de linha de produção foram definidas as proposições atômicas abaixo:
Tendo estas proposições definidas, as seguintes propriedades CTL foram descritas: (true EstaçãoN Bloqueada) Esta propriedade denota que há um caminho em o qual a última estação está bloqueada.
Esta propriedade apresenta um comportamento de liveness, pois denota que, em todos os futuros caminhos, a partir de um estado de bloqueio da última estação, ela será desbloqueada.
De essa forma, a última estação não ficará infinitamente num estado de bloqueio. (
EstaçãoN Bloqueada EstaçãoN Desbloqueada) Propriedade com semântica semelhante a anterior, contudo denota apenas que existe futuro caminho a partir de um estado de bloqueio da última estação em que ela será desbloqueada.
Resultados Esta seção apresenta os resultados obtidos por o SAN Model Checker e NuSMV Model Checker ao procurar por testemunhas ou contraexemplos para as propriedades definidas na Seção tipo de saída solicitada (contraexemplo ou testemunha), logo depois o resultado gerado por o SAN Model Checker, para então o resultado obtido com o NuSMV Model Checker.
Os nomes de estados e autômatos apresentados nesta seção estão de acordo com a maneira em que foram descritos os modelos SAN (consultar apêndices deste volume).
Portanto, para o modelo do Jantar dos Filósofos, os resultados referenciam os filósofos como Pi, onde i representa o número do filósofo considerado.
Para os resultados do modelo adhoc, os nodos pertencentes a rede são referenciados como M Ni onde i representa o número do nodo na rede, e os estados são exibidos como:
I para Idle, T para T ransmiting e R para Receiving.
Para o modelo de Linha de Produção, as estações são referenciadas como Mi, onde i é o número da estação, e o estado de bloqueio de elas é representado por o estado 1, 2.
Propriedade 5.1, resultado gerado:
Testemunha A propriedade 5.1 exibe um comportamento de starvation do filósofo zero.
Os traces gerados por o SAN Model Checker e NuSMV Model Checker, Figuras 5.1 e 5.2 respectivamente, mostram que ambos os verificadores chegaram a mesma resposta.
A disposição dos filósofos no resultado gerado por o SAN Model Checker é a mesma de declaração de eles no modelo SAN, ou seja, Filósofo dois (Fil2), Filósofo um (Fil1) e Filósofo zero.
Ao lado de cada estado que faz parte do trace, o SAN Model Checker exibe a subfórmula satisfeita por aquele estado e o evento disparado que causa a transição para o estado da linha posterior.
Note que, para a geração no NuSMV Model Checker, a especificação teve de ser negada), pois o verificador gera somente contraexemplos.
De essa forma, para buscar uma testemunha de uma fórmula quantificada existencialmente, a mesma tem de ser negada para que o NuSMV Model Checker gere um contraexemplo da fórmula, o que semanticamente equivale à testemunha da fórmula existencial sem a negação.
A saída gerada por o NuSMV também foi alterada no que diz respeito aos estados locais exibidos como resultado.
O verificador tem como padrão exibir somente o (s) autômato (s) que muda (m) de estado durante a transição.
Em a saída editada também são exibidos os autômatos cujos estados locais não mudaram durante a transição.
A testemunha gerada por os verificadores começa no estado global Thinking -- Thinking e vai até o estado Thinking -- Right, linha 11, onde um ciclo é detectado, pois o estado já tinha sido visitado na linha oito, satisfazendo dessa maneira a fórmula interna F il0 $= Right.
Propriedade 5.2, resultado gerado:
Contraexemplo Esta propriedade testa o funcionamento do algoritmo, pois, a sua conversão para ENF resulta na fórmula:)) e faz com que o algoritmo, ao chegar na conjunção, tenha de escolher entre o ramo que possui maior número de operadores temporais.
O resultado obtido por o SAN Model Checker (Figura 5.3) apresenta, como contraexemplo, uma sequência de dez estados, começando por o estado inicial Thinking--Thinking-Thinking e percorrendo estados que satisfazem true até que um estado que satisfaz (F il0 $= Lef t¬ (F il1 $= Lef t F il2 $= Right) é alcançado.
A partir de aí, o algoritmo escolhe para qual dos dois ramos irá construir o resultado.
Para este caso, o ramo da direita¬) é o escolhido.
O algoritmo então encontra um ciclo, pois o estado T hinking -- T hinking se repete nas linhas 7 e 13, respectivamente, dentro de o conjunto de estados que satifaz a subfórmula¬), caracterizando o resultado esperado para fórmulas com o operador.
O resultado obtido por o NuSMV (Figura 5.4), mostra um contraexemplo com seis estados, que inicia no mesmo estado inicial Thinking--Thinking-Thinking e termina com um ciclo detectado no estado Thinking--Thinking-Left.
Propriedade 5.3, resultado gerado:
Contraexemplo Esta propriedade verifica se em todos os caminhos de execução do modelo o filósofo um fica sempre com fome, ou seja, no seu estado Right.
O contraexemplo para esta propriedade tem de mostrar um caminho onde Fil1 vai para um estado diferente de Right.
O resultado obtido por o SAN Model Checker, Figura 5.5 mostra um contraexemplo com dois estados, aonde um estado onde o estado de Fil1 é diferente de Right, ou seja, não é verdade que para todos os caminhos Fil1 fica no estado Right.
O resultado obtido por o NuSMV, Figura 5.6 mostra apenas um estado inicial ThinkingThinking--Thinking como contraexemplo para a propriedade.
Essa diferença de resultado nos contraexemplos gerados por os verifcadores justifica- se por diferenças na implementação de contraexemplos e testemunhas para fórmulas CTL no SAN Model Checker.
Note que, durante a geração de um contraexemplo, se um dos estados iniciais não satisfaz a fórmula avaliada, este por si só, já representa um contraexemplo.
Esta é a razão por a qual o NuSMV Model Checker exibe um contraexemplo de um estado apenas.
Contudo, é importante ressaltar que, o resultado gerado por o SAN Model Checker, com um estado além de aquele que já viola a especificação avaliada, está correto.
Considerando que o algoritmo implementado restringe- se à buscas por testemunhas (uma vez que ele computa fórmulas CTL em ENF) e que por essa razão somente conjuntos de estados que satisfazem a fórmula são considerados durante a construção do resultado, não ocorrerá em resultados similares a este, uma situação em que o algoritmo exiba um estado posterior ao estado inicial, que viole o próprio contraexemplo.
De essa forma, o estado a mais, exibido por o SAN Model Checker, não acarreta na violação do próprio resultado.
Propriedade 5.4, resultado gerado:
Testemunha Esta propriedade também apresenta um comportamento de starvation, contudo ela é considerada um subconjunto da propriedade que representaria starvation do Fil1, pois esta propriedade fixa que o Fil0 esteja no estado Thinking até que um ciclo onde Fil1 esteja em Right seja detectado.
Para esta propriedade ambos os verificadores chegaram à mesma resposta.
A testemunha para esta propriedade possui cinco estados, iniciando por Thinking--Thinking-Thinking até que um ciclo no estado Thinking--Right-Thinking é detectado.
Propriedade 5.5, resultado gerado:
Contraexemplo Para montar um contraexemplo para a propriedade 5.5 o algoritmo implementado no SAN Model Checker teve de fazer a escolha entre os dois ramos que podem ser usados para a construção do resultado.
A Figura 5.9 mostra que a ferramenta optou por construir o resultado utilizando o ramo da direita, isto é,.
O resultado obtido com o NuSMV, Figura 5.10, mostra um contraexemplo menor, composto por dois estados, o estado inicial e um segundo estado onde o filósofo zero está no estado Thinking.
Propriedade 5.6, resultado gerado:
Testemunha Para montar a testemunha para a propriedade 5.6 o SAN Model Checker novamente teve de escolher entre os ramos que podem ser usados para gerar o resultado.
Em este caso em específico, como os dois ramos possuem o mesmo número de operadores temporais o algoritmo irá optar por montar a testemunha utilizando o ramo esquerdo da conjunção.
O resultado gerado por o NuSMV, Figura 5.12, mostra que o verificador optou por gerar a testemunha utilizando o ramo direito da conjunção.
Propriedade 5.7, resultado gerado:
Contraexemplo Os contraexemplos obtidos para a propriedade 5.7 por ambos os verificadores foi semelhantes.
Tanto o SAN Model Checker quanto o NuSMV mostraram caminhos que alcançaram um estado em que o filósofo dois, Fil2, tem seu estado local diferente de Right.
Propriedade 5.8, resultado gerado:
Contraexemplo Os contraexemplos gerados por os verificadores para a propriedade 5.8 foram semelhantes para esta propriedade.
A diferença está no fato de que o resultado gerado por o SAN Model Checker tem um estado a mais e de que o ciclo foi detectado em estados diferentes por os verificadores.
Enquanto o SAN Model Checker encontrou um ciclo em T hinking hinking, estado que se repete nas linhas sete e dez, o NuSMV chegou à mesma resposta, detectando um ciclo no estado T hinking -- T hinking estados 1.1 e 1.4 da Figura 5.16, respectivamente.
Propriedade 5.9, resultado gerado:
Contraexemplo Esta propriedade demonstra o comportamento do algoritmo ao tratar fórmulas com operadores temporais aninhados onde existe uma implicação entre eles.
A conversão desta fórmula para ENF resulta em:)¬ F il1 $= Lef t).
O resultado gerado por o SAN Model Checker mostra uma sequência de estados que começa por o estado inicial T hinking hinking e termina no estado T hinking hinking -- Lef t que satisfaz a propriedade ao lado direito do operador.
O algoritmo não continua percorrendo a árvore que representa a propriedade, pois, ele encontra na sequência propriedades negadas, que geram um resultado em árvore, não suportado por a ferramenta.
O NuSMV mostra um contraexemplo menor, de três passos, começando por o estado T hinking -- T hinking até que um estado T hinking -- Lef t é alcançado.
Propriedade 5.10, resultado gerado:
Testemunha A propriedade procura se existe um caminho onde um dos filósofos come, isto é, se algum dos filósofos destros alcança o estado Left ou o filósofo canhoto o estado Right.
As Figuras 5.19 e 5.20 mostram os resultados obtidos por o SAN Model Checker e NuSMV respectivamente.
Para esta propriedade ambos os verificadores proveram o mesmo resultado que mostra um caminho onde o filósofo dois, Fil2, alcança o estado Right.
Propriedade 5.11, resultado gerado:
Testemunha A propriedade 5.11 define que existe um caminho futuro onde é alcançado um estado que possui como sucessor um estado onde o Filósofo zero, Fil0, está no seu estado Left.
Propriedade 5.12, resultado gerado:
Testemunha A propriedade 5.12 verifica se existe um futuro caminho onde globalmente, a partir de cada estado que compõe o caminho, exista um outro caminho onde uma transmissão de um pacote por parte de o primeiro nodo da rede, implica que exista um caminho futuro onde o último nodo recebe o que foi transmitido.
Como a propriedade possui uma fórmula mais externa composta por o operador o algoritmo cria uma testemunha usando os estados que compõem a fórmula com o operador sem criar traces para a fórmula interna.
O resultado gerado por o SAN Model Checker (Figura 5.23), mostra uma testemunha com 33 estados onde um ciclo é encontrado nos estados que estão nas linhas 21 e 39 respectivamente.
O resultado gerado por o NuSMV (Figura 5.24), mostra uma testemunha com 19 estados, onde um ciclo foi detectado no estado onde todos os nodos estão em I, estados 1.1 e 1.19 respectivamente.
Propriedade 5.13, resultado gerado:
Testemunha O resultado gerado por ambos os verificadores, Figura 5.25 e 5.26 foi o mesmo, uma testemunha contendo dois estados.
A propriedade verifica se existe um caminho onde uma recepção por parte de o último nodo não acontece até que um envio tenha sido feito por o primeiro nodo.
Propriedade 5.14, resultado gerado:
Testemunha A propriedade 5.14 verifica se existe um caminho em que no futuro globalmente, a partir de cada estado, exista um caminho que levará a um estado em que o nodo M N5 transmite um pacote.
De acordo com a estratégia adotada para fórmulas que possuem o operador como operador mais externo, o Gerador de Testemunhas irá gerar um resultado com os estados que satisfazem a fórmula composta por o operador, sem abrir para cada um destes estados caminhos que satisfaçam a fórmula interna (true M N5 $= T).
O resultado gerado por o SAN Model Checker Figura 5.27, mostra uma testemunha com 33 estados, com um ciclo sendo detectado em I -- R -- I -- R -- I -- I -- I, estado que se repete nas linhas 21 e 39.
Já o resultado gerado por o NuSMV Figura 5.28, mostra uma testemunha com 19 estados e um ciclo detectado nos estados 1.1 e 1.19.
Propriedade 5.15, resultado gerado:
Contraexemplo A propriedade 5.15 especifica que não existe um futuro caminho onde globalmente, a partir de cada estado que compõe o caminho, exista um outro caminho onde uma transmissão de um pacote por parte de o primeiro nodo da rede implique na existência de um caminho futuro onde o último nodo recebe o que foi transmitido.
Como a propriedade possui uma fórmula mais externa composta por o operador o contraexemplo gerado por o SAN Model Checker é um trace que percorre os estados que compõem a fórmula com o operador sem criar outros traces para a fórmula interna.
O resultado gerado por o SAN Model Checker, Figura 5.29 mostra uma testemunha com 33 estados onde um ciclo é detecado nos estados que estão nas linhas 21 e 39 respectivamente.
O resultado gerado por o NuSMV Figura 5.30, mostra uma testemunha com 19 estados, onde um ciclo foi detectado no estado onde todos os nodos estão em I, estados 1.1 e 1.19 respectivamente.
Propriedade 5.16, resultado gerado:
Testemunha A propriedade 5.16 verifica se existe um caminho futuro onde a última estação esteja bloqueada seja alcançado.
Propriedade 5.17, resultado gerado:
Testemunha A propriedade 5.17 apresenta o comportamento de liveness da última estação.
O resultado gerado por o SAN Model Checker (Figura 5.33), mostra uma testemunha de dois estados, onde a partir de um estado de bloqueio um outro estado em que a última estação é desbloqueada é alcançado.
A testemunha gerada por o NuSMV (Figura 5.34), contém um estado inicial, em o qual a última estação está desbloqueada, comprovando assim que existe um estado atendendo à especificação 5.17.
Este tipo de resultado com apenas um estado é o mesmo obtido na propriedade 5.3.
Isto mostra que o NuSMV gera contraexemplos ou testemunhas com apenas um estado, desde que o estado que satisfaz ou refuta a fórmula seja um estado inicial do modelo.
Propriedade 5.18, resultado gerado:
Contraexemplo A propriedade 5.18 apresenta semântica semelhante a propriedade anterior, contudo exige que exista algum caminho onde a partir de um estado de bloqueio a última estação seja desbloqueada.
Demais propriedades testadas no SAN Model Checker Para ampliar o número de fórmulas CTL avaliadas por o SAN Model Checker e verificar mensagens de saída que podem ser exibidas por a ferramenta ao usuário, mais algumas propriedades CTL foram definidas.
Elas foram criadas através da combinação de operadores temporais e fórmulas compostas por os quantificadores universal e existencial.
A Tabela 5.1 mostra os resultados obtidos para estas propriedades avaliadas sobre o modelo do Jantar dos Filósofos.
Para cada uma de elas, foi solicitada a geração de uma testemunha e um contraexemplo.
A Tabela 5.1 mostra que, em alguns casos, a ferramenta encontrou uma testemunha incompleta, ou seja, situações em que o resultado gerado mostra parte da satisfação ou refutação da fórmula.
Para outros casos, o verificador identificou um resultado em árvore, não suportado por a ferramenta, e nestes casos mostrou apenas o estado inicial que satisfaz ou refuta a fórmula;
Situações em que o verificador não encontrou um estado inicial que satisfizesse a fórmula, nesse caso uma testemunha ou contraexemplo não foi gerado, representado por o símbolo × e situações onde um resultado completo, isto é, que mostra toda a satisfação ou refutação da fórmula, foi encontrado, representado por o símbolo.
F il0 $= T hinking F il0 $= T hinking F il0 $= T hinking F il0 $= T hinking F il0 $= T hinking F il0 $= T hinking F il0 $= T hinking F il0 $= T hinking temporais avaliados na Ferramenta Testemunha Contraexemplo Em árvore Em árvore Em árvore Em árvore Em árvore Em árvore Testemunha incompleta Em árvore Testemunha incompleta Testemunha incompleta Em árvore Em árvore Testemunha incompleta Em árvore Testemunha incompleta Em árvore Testemunha incompleta Em árvore Conforme a Tabela 5.1 mostra, em cinco resultados, o SAN Model Checker chegou a um resultado que explicava, por completo, a refutação de uma especificação por o modelo.&amp;&amp;&amp;
Em as demais propriedades testadas, o verificador chegou a resultados em árvore, incompletos ou, ainda, não houve saída para o usuário, uma vez que, não existiam estados iniciais do modelo que fizessem parte do resultado.
Para estes casos, o verificador exibe uma mensagem ao usuário, informando o tipo de resultado (incompleto ou em árvore) gerada, ou ainda, de que não foi possível gerar- lo.
Tempo e memória Esta seção mostra o tempo e memória utilizados para gerar os resultados apresentados por a Seção 5.2.
A Tabela 5.2 mostra essas informações da seguinte forma:
A coluna Propriedade mostra a qual propriedade as informações de tempo e memória se referem;
A coluna Verificação mostra os o tempo (em segundos) e memória (em megabytes) necessários para a verificação da especificação no modelo SAN.
Torna- se importante destacar que a coluna Tempo sob o campo Verificação mostra o tempo total incluindo todos os processos envolvidos na verificação (geração do espaço de estados atingível, transformação de uma fórmula CTL em ENF e eventualmente o tratamento de ela, para o caso da geração de um contraexemplo, função de rotulação de estados e cálculo do conjunto de satisfação de fórmulas -- SAT).
A coluna Memória sob o campo Verificação mostra a memória necessária para armazenar no formato de diagrama de decisão multivalorado (MDD) o conjunto de estados que satisfazem a fórmula avaliada.
As colunas Tempo e Memória sob o campo Contraexemplo/ testemunha mostram o tempo e memória utilizados para a geração de um contraexemplo ou de uma testemunha.
A Tabela 5.3 mostra o consumo de tempo e memória verificados para as propriedades apresentadas na Tabela 5.1.
O trabalho apresentado ao longo de esta dissertação está inserido dentro de o projeto de construção de um verificador de modelos para o formalismo de Redes de Autômatos Estocásticos, verificador que recebeu o nome de SAN Model Checker, e teve como objetivo implementar a geração de contraexemplos e testemunhas para a ferramenta.
Para informações sobre os demais trabalhos que compõem o projeto, recomenda- se a leitura do relatório técnico do aluno de mestrado Alberto Wondraceck e a dissertação de mestrado de Lucas Oleksinski.
Salienta- se que, além destes trabalhos, o aluno de mestrado Eli Maruani contribuiu no projeto de pesquisa.
Um verificador de modelos pode simplesmente informar ao usuário se um modelo atende ou não a uma especificação avaliada.
Contudo, a implementação de contraexemplos e testemunhas num verificador torna- se relevante quando considerado o valor que um contraexemplo tem para depuração do sistema.
O modelador, após a avaliação de uma especificação por o verificador, de posse do contraexemplo gerado por a ferramenta, pode localizar com maior facilidade o erro que levou o modelo a refutar a especificação avaliada.
O Verificador também pode gerar uma testemunha, este resultado ratifica que o modelo atende a uma especificação.
A estratégia implementada para a geração dos resultados foi a de armazenar os valores que codificam os estados que satisfazem cada subfórmula da fórmula avaliada à medida que o algoritmo de satisfação de fórmulas CTL é executado.
Como consequência dessa abordagem, a geração dos resultados é feita após o término do algoritmo de satisfação de fórmulas.
Essa abordagem é semelhante à empregada por Keijo Heljanko.
Conforme abordado no Capítulo 2, contraexemplos são gerados para fórmulas quantificadas universalmente, enquanto que testemunhas são geradas para fórmulas quantificadas existencialmente.
Apesar disso, a opção tomada foi a de dar liberdade para o usuário escolher o tipo de saída que deseja obter, isto é, o usuário pode entrar com uma especificação quantificada existencialmente e solicitar um contraexemplo ou ainda entrar com uma especificação quantificada universalmente e solicitar uma testemunha.
Cabe à ferramenta tratar adequadamente estas situações.
É importante colocar que, apesar de existir um cuidado em implementar da melhor forma possível a geração de contraexemplos e testemunhas, a busca por uma implementação que resultasse no melhor desempenho que se pudesse obter no que se refere a tempo de geração de resultados e consumo de memória esteve, desde o começo, fora de o escopo deste trabalho, que se deteve à geração de resultados coerentes com os conceitos de contraexemplos e testemunhas descritos na literatura de Model Checking.
Contudo, destaca- se que os resultados de tempo e memória obtidos para a geração dos resultados mostraram- se satisfatórios, uma vez que pouca memória e tempo foram despendidos por a ferramenta durante o cálculo do contraexemplo ou testemunha.
Mesmo que para uma mesma especificação possa existir mais de um contraexemplo ou testemunha e que por esse motivo chegar a uma mesma resposta em ambos os verificadores seria difícil, os resultados obtidos por o SAN Model Checker foram comparados aos resultados gerados por o NuSMV Model Checker.
Esta comparação mostrou que em seis propriedades ambos os verificadores chegaram à mesma resposta, dando um forte indício do funcionamento correto da implementação realizada neste trabalho.
Em outros resultados o NuSMV exibiu contraexemplos e testemunhas de apenas um estado, enquanto que os resultados gerados por o SAN Model Checker possuem no mínimo dois estados, quando os resultados não são em formato de árvore, como visto no Capítulo 5.
A contribuição desta dissertação está no fato de que o SAN Model Checker, implementado ao longo de o mestrado, agora conta com o recurso de geração de contraexemplos e testemunhas para o usuário, além de que a lacuna de inexistência de um verificador para Redes de Autômatos Estocásticos ter sido preenchida por a ferramenta.
Durante a implementação, questões sobre a forma de gerar os resultados surgiram e elas podem guiar trabalhos futuros quanto a a geração de contraexemplos e testemunhas, na intenção de aprimorar a técnica empregada ou, ainda, criar uma alternativa a ela.
Por exemplo, a estratégia adotada para geração de contraexemplos e testemunhas foi a de gerar os resultados após a execução do algoritmo de satisfação de fórmulas CTL.
Contudo, conforme Clarke isto não é necessário, e a geração pode ser realizada ao mesmo tempo em que o algoritmo de satisfação de fórmulas é executado.
Diante de isso, fica em aberto a possibilidade de implementar uma estratégia que faça uso dessa possibilidade.
Outras possibilidades consideradas são as de empregar técnicas diferentes para geração nos trabalhos desenvolvidos em paralelo no projeto.
A saber:
Uma abordagem que faça uso de processamento paralelo e distribuído para a geração de contraexemplos e testemunhas e que poderia ser utilizada em conjunto com o trabalho apresentado em.
Como também uma estratégia para a geração de contraexemplos e testemunhas que seja adequada ao trabalho de implementação da saturação no verificador, trabalho atualmente em desenvolvimento no projeto.
A implementação realizada neste trabalho gera contraexemplos e testemunhas lineares, ou seja, traces de execução do sistema.
De esse modo, também consta no conjunto de trabalhos futuros a geração de contraexemplos e testemunhas em formato de árvore, visto que, esse tipo de resultado abrange um maior número de especificações em CTL, e gera um resultado mais completo para a satisfação ou refutação da propriedade avaliada, quando ela tem formato em árvore.
Dito isto, esta dissertação representa os primeiros passos na criação do verificador de modelos descritos em SAN, além de criar a base e lançar possibilidades de trabalhos futuros para a geração de contraexemplos e testemunhas para ferramenta.
