O objetivo deste trabalho é fornecer uma ferramenta para simulação visual de SAN.
O formalismo SAN, através da ferramenta PEPS, utiliza soluções numéricas para calcular erros de avaliações condicionais ou comportamento não esperado de sistemas modelados através deste formalismo.
Estas soluções numéricas são a base para os formalismos estruturados na medida em que fornecem resultados numéricos por meio de relações matemáticas.
Complementar a eficiência de soluções numéricas com a simulação visual é bastante interessante, pois adiciona informações mais detalhadas sobre o modelo o que facilita que usuários acadêmicos iniciantes ou pesquisadores tenham um maior entendimento da aplicabilidade do formalismo estruturado.
Esta dissertação descreve uma ferramenta para modelagem e simulação visual de SAN que em sua estrutura define um esquema de armazenamento compacto para a matriz de transição da cadeia de Markov e usa a álgebra tensorial para lidar com as multiplicações de vetores de base da matriz.
Esta ferramenta permitirá aos usuários acadêmicos ou entusiastas do formalismo SAN manipular modelos sem a preocupação de um domínio profundo dos conceitos deste formalismo estruturado.
Palavras-chave: Redes de Autômatos Estocásticos;
Soluções Numéricas; Simulação Visual.
A complexidade no desenvolvimento de sistemas computacionais é um dos fatores preponderantes para o avanço das modelagens de sistemas utilizando formalismos estruturados.
De fato, desenvolver sistemas têm se tornado bastante oneroso em relação a a custos operacionais, o que faz com que o uso de formalismos para avaliação de desempenho de sistemas seja largamente utilizado.
Para tal, formalismos baseados em métodos analíticos como Redes de Petri, Álgebra de Processos Estocásticos e Redes de Autômatos Estocásticos[ FER98a, FER98b, PLA85, PLA91] estão sendo utilizados na modelagem de sistemas como sistemas distribuídos, redes de computadores, garantia de qualidade no desenvolvimento de softwares, etc..
As Redes de Autômatos Estocásticos (SAN) é um formalismo para a descrição e a avaliação de processos estocásticos baseados em métodos analíticos.
O princípio básico da modelagem de SAN é a construção de sistemas como um conjunto de subsistemas que interagem entre si.
Cada subsistema é modelado por um autômato e a interação entre autômatos é modelado por regras de transições relacionando os estados dos autômatos.
Métodos analíticos podem ser aplicados para garantia de qualidade no desenvolvimento de um software, bem como ser utilizados na busca de soluções exatas ou muito aproximadas de um resultado desejado, pois permitem descrever também situações do mundo real com um nível de abstração maior do que a simulação, gerando modelos puramente matemáticos.
Em este tipo de modelo, o funcionamento do sistema real é reduzido a relações matemáticas.
Desenvolver métodos analíticos normalmente exige maior abstração de aspectos da realidade, se comparado a modelos de simulação Uma característica a ser observada num modelo SAN é o comportamento dos autômatos.
A avaliação do desempenho e a análise do comportamento de uma SAN se dá por a verificação dos estados, que ao serem atingidos, representam processos realizados por o sistema modelado.
Estados sucessores e predecessores indicam, no espaço de estados de uma SAN, a trajetória e evolução dos padrões comportamentais do sistema modelado.
Por ser baseado em cadeias de Markov, no formalismo SAN a representação dos estados globais pode se tornar inviável devido a o problema da explosão de espaços de estados, o que consistirá em elevado consumo de memória para representar os diferentes estados aplicáveis de um modelo.
Para que seja possível o estudo do comportamento de sistemas grandes e complexos a fim de minimizar a explosão de espaço de estados, para alguns sistemas modelados nem sempre se pode evitar grandes espaços de estados, deve- se realizar uma modelagem levando- se em conta apenas a porção atingível do modelo (Reachable State Space -- RSS) do espaço de estados produto (Product State Space-PSS).
Em estudos iniciais o espaço de estados produto era armazenado num vetor ou lista de estados, onde, e propuseram maneiras eficientes para descrever o espaço de estados atingíveis de modelos grandes e complexos para o formalismo SPN (Stochastic Petri Nets).
Estas proposições se basearam na estrutura de dados chamada Diagramas de Decisão Multivalorados (Multi-valued Decision Diagram -- MDD), esta estrutura foi utilizada devido a o fato de ser compacta e eficaz para as operações comuns como inserções e buscas.
O espaço de estados produto é a combinação dos estados individuais de cada autômato.
De entre os estados que compõem este espaço, existem estados atingíveis e podem existir inatingíveis no âmbito global do sistema (dadas as transições que podem ser disparadas a partir de cada estado global).
A obtenção do espaço de estados atingíveis pode se dar através de rotinas de percurso na cadeia de Markov que permeia o modelo estruturado, e seu armazenamento pode se dar através de um vetor de estados ou estruturas mais complexas como Diagramas de Decisão Multivalorados (ou outras técnicas de armazenamento).
Estudos referentes à aplicação de MDD em SAN demonstram os benefícios na geração do espaço de estados atingíveis pois poderá haver uma diminuição do problema de explosão do espaço de estados nos modelos SAN através da eliminação dos estados redundantes, dependendo das estruturas de dados usadas na solução, sem que haja uma alteração na representação do espaço de estados.
A análise e estudo de sistemas complexos exigem um processamento robusto de dados e interpretação das informações fornecidas.
Desenvolver sistemas com grandes quantidades de variáveis tem se tornado bastante custoso, o que pode inviabilizar a produção de software para atender as necessidades destes sistemas.
Uma maneira de reduzir custos operacionais é utilizar a simulação de sistemas.
O uso de simulação nas áreas de conhecimento ligadas ao desenvolvimento computacional (software e hardware) vem a facilitar o controle da complexidade comumente encontrada na implementação destas aplicações possibilitando uma maior produtividade.
Buscando uma maior aproximação da realidade e da interpretação dos dados dos sistemas analisados, foram realizados diversos estudos a fim de encontrar maneiras de se compreender estes dados com eficiência utilizando métodos analíticos, bem como a utilização de ambientes gráficos e de animação para o ensejo da simulação de sistemas.
Simulação de Sistemas Em as sub-seções a seguir serão apresentados, resumidamente, conceitos de simulação de sistemas através de simulação visual e soluções numéricas.
Ambientes de simulação visual oferecem recursos interativos para uma melhor observação dos resultados intermediários como, por exemplo, a evolução comportamental do modelo e variáveis.
Em este contexto, os resultados de soluções numéricas poderão ser avaliados com uma maior aproximação da realidade do sistema modelado, uma vez que os resultados numéricos retornam índices quantitivos de desempenho.
Soluções numéricas aliadas à simulação visual facilitam a avaliação de sistemas complexos proporcionando o aumento da produtividade no desenvolvimento de sistemas enfatizando a construção do modelo através de recursos gráficos oferecendo ao usuário mecanismos para que este possa compreender e melhorar o sistema em estudo, ao passo que apenas o uso de simulação visual, por ser baseada num modelo de sistema executável, só permite uma avaliação rápida e superficial da qualidade do projeto.
A simulação faz uma abordagem e tratamento de sistemas dinâmicos, ou seja, o tratamento de sistemas ou objetos cujo comportamento é descrito num modelo, onde o tempo define a evolução do estado destes sistemas.
Quando a simulação é interativa visual, é possível acompanhar e controlar esta evolução.
A simulação de modelos SAN, por exemplo, pode ser realizada representando os grafos contidos neste formalismo e assim analisar o comportamento tal qual o formalismo modela.
O controle, por o usuário, possibilita a execução dos eventos respeitando, inclusive, a dependência das taxas funcionais pertencentes ao modelo representado.
Para a perfeita aplicação do conceito de Simulação Visual Interativa são necessários quatro requisitos básicos, são eles:
Intervenção, possibilidade de interação com o modelo;
Inspeção, acesso a dados durante o experimento;
Especificação, requisito que especifica os parâmetros do modelo, tempo e variáveis necessárias para a execução do modelo;
Visualização, representação gráfica do comportamento do modelo e relacionamento de interesse.
A Análise e Modelagem de Simulação é o processo de criação e experimentos com modelos matemáticos de um sistema real (sistema físico).
A simulação é utilizada para visualizar comportamentos, para identificar problemas de sistemas reais, melhorar o desempenho de sistemas e utilizar recursos computacionais para avaliar um modelo numericamente, e por seguinte os dados são obtidos ordenadamente para estimar as verdadeiras características desejadas do modelo.
A simplicidade de alguns sistemas permite que sejam utilizados métodos matemáticos para se obter informações exatas através de soluções analíticas.
Entretanto, alguns modelos são bastante complexos para permitir o uso de soluções analíticas, para estes modelos deve- se aplicar a simulação baseada em soluções numéricas.
Atualmente, diversas áreas aplicam os conceitos da simulação tais como:
Projeto e análise de sistemas, protocolos de redes ou definição dos requisitos de hardware, re-engenharia de processos de negócios, etc..
Objetivos O objetivo principal deste trabalho é apresentar uma ferramenta gráfica para simular visualmente o formalismo SAN, bem como propor algoritmos para obtenção de estados sucessores e predecessores em modelos SAN.
Outro objetivo deste trabalho é apresentar uma estrutura de dados, a ser utilizada na ferramenta proposta, para representação de modelos SAN a fim de permitir que outras ferramentas possam utilizar uma SAN modelada na ferramenta.
Além de obter os estados atingíveis por meio de algoritmos de soluções numéricas, o software a ser proposto deverá integrar- se às ferramentas PEPS e GTAexpress a fim de utilizar as soluções numéricas disponíveis nestas ferramentas.
Estrutura dos Capítulos deste Trabalho Este trabalho está organizado como descrito a seguir:
Capítulo 2 apresenta os trabalhos relacionados que utilizam ferramentas de simulação visual e interface textual aplicando formalismos.
O uma breve introdução de MDD.
Em os Capítulo 5 e 6, principais focos desta dissertação, é apresentada a contribuição científica na forma de algoritmo para obtenção de estados sucessores e predecessores e estrutura de dados para representação de modelos SAN, bem como é apresentada a ferramenta de simulação visual de Redes de Autômatos Estocásticos.
Em o Capítulo 7 é realizado um fechamento e são apresentados os trabalhos futuros.
Os apêndices A e B expõem um tutorial de uso da ferramenta e uma introdução as ferramentas que suportaram o desenvolvimento da ferramenta proposta neste trabalho.
Este capítulo apresenta algumas ferramentas que visam simular formalismos tais como PEPA, SPN e SAN, sendo feita uma breve introdução nas características de cada ferramenta.
PEPAnets é uma extensão de PEPA permitindo que os componentes sejam usados como objetos de uma Rede de Petri Estocástica Colorida.
Um componente de PEPA tem estados locais que podem executar ações sincronizadas, individualmente ou em cooperação com um outro componente.
Estas atividades definem uma interface análoga à interface composta por os métodos que podem ser invocados num objeto.
Devido a as limitações na natureza da informação sincronizada (distribuídos exponencialmente com retardos aleatórios) significa dizer que um modelo PEPA define uma Cadeia de Markov de Tempo--Contínuo (CTMC).
PEPA Workbench O propósito do PEPA Workbench é checar se o modelo PEPA é bem-formado, e gerar o processo Markoviano correspondente.
Este workbench detecta falhas como deadlocks e cooperações que não envolvem participantes ativos.
Em essência, o processo de translação do workbench aceita um modelo PEPA como entrada e produz uma matriz contendo o processo de Markov codificando um determinado modelo.
Um exemplo deste relacionamento é demonstrado na Figura 2.1.
Em este exemplo é demonstrado que o modelo PEPA terá dois componentes independentes que executará em paralelo, e não cooperantes.
Cada componente é iniciado no estado P1, e cada tem um estado significando que a matriz geradora para o processo de Markov correspondente terá quatro dimensões.
Em caso de exemplos mais complexos e maiores, devido a esta complexidade de construir uma matriz do processo de Markov sem uso de software específico torna- se uma atividade inviável e errônea, desde que a matriz seja uma representação não estruturada do sistema desprovido de nomes, e somente contendo índices.
GreatSPN O GreatSPN é um software para modelagem, validação, avaliação de performance de sistemas distribuídos usando Redes de Petri Generalizadas e suas extensões coloridas:
Stochastic Well--formed Nets.
A ferramenta fornece um framework amigável para experimentos com redes de Petri temporizadas baseadas em técnicas de modelagem.
Ela implementa algoritmos de análise eficientes para permitir seu uso em aplicações bastante complexas, não apenas em aplicações mais simples.
As principais funcionalidades do GreatSPN são:
Permitir visualizar representações gráficas das propriedades estruturais;
A definição de sincronização e especificações estocásticas, parâmetros, e medidas de desempenho;
Simulação com interação gráfica de sincronização e modelos estocásticos;
Geração de gráficos de atingibilidade;
Solução Markoviana para estados-constantes assim como avaliação transitória de desempenho explorando eficiência, técnicas numéricas para matrizes esparsas;
Módulos de simulação para interação de eventos que em cooperação com a interface gráfica fornece simulação com interação, com animação gráfica do modelo e movimento de símbolos, com passo- a- passo, e progressão de tempo para frente e para trás, reprogramação arbitrária de eventos;
De entre outras características.
O PEPS é uma ferramenta composta por módulos que fazem a descrição, compilação e solução de modelos SAN.
Implementado com uma interface textual (Figura 3.3) usando a linguagem de programação C+ podendo ser usando em qualquer plataforma de sistemas operacionais, sendo que suas versões foram testadas apenas para plataformas Linux e Solaris.
Algumas características da ferramenta são;
Descrição textual compacta de modelos SAN de tempo contínuo;
Solução estacionária de modelos usando métodos Arnoldi, GMRES e Potência Iterativa;
Otimização númerica sobre dependências funcionais, pré-computação diagonal, pré-condicionamento e álgebra de agregação de autômatos;
Avaliação de resultados;
Agregação semântica de SAN com réplicas;
Solução numérica usando vetores de probabilidades com o tamanho do espaço de estados atingíveis;
Fornecer ao usuário uma seleção de métodos de solução iterativa para calcular vetor de probabilidades transitória e estacionária e uma série de soluções numéricas;
Inspecionar estruturas de dados como o espaço de estados atingíveis, o vetor de probabilidade estacionária (e comparar dois de eles) e o descritor SAN;
E· Resultados de saída e os arquivos de estrutura de dados:
Os resultados, os vetores de probabilidade, SAN descritor, formato HBF do descritor compatível com o software Marca.
A ferramenta PEPS implementa dois conjuntos de métodos para solução analítica de modelos SAN.
O primeiro conjunto trabalha com o formato Kronecker e o segundo conjunto trabalha com o formato esparso (HBF).
O formato Kronecker que utiliza o método shuffle e cuja idéia básica é multiplicar o vetor de probabilidades com o conjunto de matrizes que compõem o Descritor Markoviano.
De fato, cada pequena matriz multiplica uma parte do vetor.
A soma de todas as multiplicações das pequenas matrizes é uma multiplicação completa do vetor-descritor.
Este método de multiplicação foi implementado em duas versões.
A primeira trabalha com vetor extendido (com o tamanho global do espaço de estado).
O segundo trabalha com vetor esparso (somente o tamanho do espaço de estados atingíveis).
Para o formato HBF, foi implementado uma multiplicação do gerador de vetor infinitesimal usando uma representação de matriz esparsa para o gerador infinitesimal.
O formalismo SAN foi proposto por Plateau e o objetivo básico é representar um sistema por meio de uma coleção de sub-sistemas com um comportamento independente (transições locais) e interdependências ocasionais (taxas funcionais e eventos sincronizantes) sob os pressupostos das Cadeias de Markov.
Cada sub-sistema é descrito como um autômato estocástico, conforme a Figura 3.1.
Este formalismo é uma forma compacta de descrever realidades complexas, otimizando ainda a busca de soluções estacionárias, utilizando- se das noções de estado e de transições entre estados para representação dos eventos, assim como as Cadeias de Markov.
Os eventos em SAN podem estar associados a um único autômato, ou a vários ao mesmo tempo, ocorrendo de acordo com taxas específicas.
Dá- se o nome de estado local ao estado individual de cada autômato e estado global como sendo a combinação de todos os estados locais de cada autômato componente da SAN.
De essa forma, o formalismo de redes de autômatos estocásticos é particularmente interessante para a modelagem de sistemas distribuídos, em os quais as unidades de processamento não interagem entre si a todo instante.
Um autômato é um modelo matemático de um sistema com entradas e saídas discretas.
O formalismo de redes de autômatos estocásticos pode ser utilizado tanto para modelos em escala de tempo discreto quanto para modelos em escala de tempo contínuo.
O termo estocástico é devido a o fato de que o tempo é tratado como uma variável aleatória, que na escala de tempo contínua obedece a uma distribuição exponencial.
Autômatos Estocásticos Uma SAN é uma coleção de componentes chamados de autômatos estocásticos.
Os Autômatos estocásticos representam um modelo matemático de um sistema que possui entradas e saídas discretas.
O sistema pode se encontrar em qualquer um de entre o número finito dos estados do sistema ou das configurações internas.
O estado interno em que o sistema se encontra sumariza as informações sobre entradas anteriores e indica o que é necessário para determinar o comportamento do sistema para as entradas seguintes.
Partindo desta definição pode- se descrever um autômato estocástico como um conjunto finito de estados e um conjunto finito de transições entre esses estados.
A Figura 3.1 é uma representação gráfica de um modelo de Redes de Autômatos Estocásticos com dois autômatos:
A e A.
As sub-seções 3.1.1 e 3.1.2 são fortemente baseadas nas pesquisas de Brigitte Plateau e &quot;William J. Stewart -- Stochastic Automata Network», e fornecerão subsídios para que algumas regras sejam estabelecidas a fim de auxiliar no desenvolvimento dos algoritmos necessários para a criação da aplicação objeto de estudo desta dissertação.
Considerando o caso de um sistema que pode ser modelado por dois autômatos estocásticos complementamente independentes, cada qual pode ser representado por uma Cadeia de Markov à escala de Tempo Contínuo (CTMC).
Assume- se que o primeiro autômato, denotado por A, tenha n1 estados e matriz de transições de probabilidades estocásticas dado por P 1 Rn1 ×n1.
Similarmente, denota- se A como o segundo autômato;
N2, o número de estados em sua representação De fato, a matriz de transição de probabilidades estocásticas do sistema bi-dimensional é dado por o produto tensorial das matrizes P 1 e P 2.
Se, em vez de ser representado por duas cadeias de Markov de tempo-discreto, os autômatos estocásticos forem caracterizados por Cadeias de Markov de tempo-contínuo com gerador infinitesimal, Q e Q, respectivamente, o gerador infinitesimal do sistema bi-dimensional é dado por a soma tensorial das matrizes de Q e Q.
Continuando com o exemplo, seja i (t) a probabilidade de que o primeiro autômato está no estado i no tempo t e j (t) a probabilidade do segundo autômato está no estado j, no tempo t..
Então a probabilidade que, no tempo t, o primeiro está no estado i e o segundo está no estado j é simplesmente o produto i (t) x j (t).
Além disso, a distribuição das probabilidades de todo o sistema (bi-dimensional) é dado por o produto tensorial dos dois vetores de probabilidades individuais, Rn1 e Rn2, resumido em:
Maiores detalhes sobre produto de tensores pode ser visto em.
Há basicamente duas maneiras em que os autômatos estocásticos interagem entre si:
A taxa com que uma transição pode ocorrer num autômato pode ser uma função do estado de outro autômato.
Estas transições são chamadas de transições funcionais;
Uma transição num autômato pode forçar uma transição para ocorrer num ou mais autômatos, chamadas de transições sincronizadas, estas transições são disparadas por eventos sincronizantes, de fato, um único evento sincronizante irá, geralmente, causar o disparo de múltiplas transições sincronizantes.
Transições sincronizantes também podem ser funcionais.
Os elementos da matriz que representam qualquer autômato estocástico são todos constantes, i.
e, números reais não negativos, ou funções do espaço de estados globais para número não negativos.
Taxas de transição que dependem somente dos estados do próprio autômato, e não dos estados de um outro autômato qualquer, são para todos os efeitos, taxas de transições constantes.
Uma transição sincronizante tanto pode ser funcional como constante.
Em um determinado autômato, transições que não são sincronizantes são ditas transições locais.
Se um dado estado de um autômato estocástico contém transições funcionais, as taxas destas transições devem ser avaliadas de acordo com as suas fórmulas definidas e o estado global atual dos autômatos inseridos na função.
Em certos exemplos pode ser vantajoso avaliar estas taxas funcionais uma única vez e armazenar os valores obtidos num array que pode ser recuperado como e quando eles forem necessários.
Em outros casos, talvez seja melhor deixar- los em sua forma original e reavaliar a fórmula a cada vez.
Se a taxa de transição for constante ou funcional, é importante observar que somente o estado local do autômato é afetado se estiver num evento local.
Portanto, todas as informações relativas às taxas de transições, constantes e funcionais, podem ser manipuladas dentro desse autômato (assumindo apenas que esse autômato tem um conhecimento do estado global do sistema).
Estados Locais e Globais Os estados de uma SAN sintetizam a informação referente a as entradas passadas que serão necessárias para determinar o comportamento do sistema para entradas posteriores.
O estado local é o estado individual de cada autômato do modelo SAN que combinado com estados locais de outros autômatos forma o estado global.
A Figura 3.1 modela um sistema através de dois autômatos, onde o autômato A possui três estados, 1 e 2), o segundo autômato (A (2)) possui dois estados e 1).
Em este modelo, os eventos e1, e2, e3 e e5 são eventos locais e o e4 é sincronizante, sendo que o evento e5 contém uma taxa funcional f que define uma interação entre os autômatos.
O conceito de taxa funcional será detalhado na Seção 3.4.
Os estados globais de uma rede de autômatos estocásticos são definidos como a combinação de todos os estados locais de cada autômato.
Estes estados são classificados ainda quanto a sua atingibilidade.
Quando todos os autômatos de uma rede encontram- se em estados locais que, em conjunto, correspondem a uma situação fisicamente possível, diz- se tratar de um estado global atingível.
No entanto, é comum a situação em que dois ou mais estados locais, embora estejam individualmente corretos, no seu conjunto correspondam a uma situação irreal do sistema físico que se está modelando.
A Figura 3.2 apresenta uma cadeia de Markov equivalente à SAN modelada na Figura 3.1.
Em este autômato cada estado é a combinação de uma dupla de estados locais de cada autômato.
Por exemplo, quando a SAN representada na Figura 3.1 encontra- se no estado 2 do autômato A e no estado 0 do autômato A, esta situação equivale ao estado global 2 0 do autômato modelado na Figura 3.2, f representa a taxa funcional relacionada ao evento e5.
Transições Locais e Sincronizantes As transições são construções que indicam a possibilidade de mudança entre um estado e outro.
No entanto, cada transição necessita ter ao menos um evento associado a ela para que essa possa ser disparada.
As transições locais de um autômato alteram o estado global por a mudança de estado em apenas um autômato, enquanto as transições sincronizantes alteram o estado global por a mudança de estado em dois ou mais autômatos simultaneamente.
As transições locais permitem que os autômatos tenham comportamento paralelos através de eventos locais, mudando somente o estado local do autômato em que ocorreram e não sofrem interferências por parte de os estados dos outros autômatos.
Mesmo os eventos sendo independentes, eles são disparados um de cada vez.
As transições sincronizadas permitem que seja representado sincronismo no disparo de transição entre os autômatos, constituindo eventos sincronizantes entre os mesmos.
Esta característica a torna um pouco mais sofisticada, pois podem trocar o estado de dois ou mais autômatos simultaneamente.
Taxas Funcionais e Probabilidades Funcionais Além de os eventos sincronizantes, taxas e probabilidades funcionais são utilizadas para representar possíveis interações entre autômatos sem alterar o estado de todos os autômatos envolvidos.
Em este caso, as taxas funcionais modificam apenas o estado do autômato a qual esta pertence e não os estados dos autômatos aos quais ela depende, ou seja, o evento pode ser dependente do estado local de outro autômato para ser disparado como evento sincronizante.
Deve- se ressaltar que essas taxas podem ser definidas por funções que são avaliadas conforme os estados atuais do modelo SAN.
Estas funções levam em consideração os estados atuais dos autômatos de um modelo variando seu valor conforme os estados em que se encontram os autômatos envolvidos na função.
Em o autômato A da Figura 3.1, usa- se uma função para definirmos a taxa de transição do evento local e5.
A taxa do evento e5 não é uma taxa constante, mas sim uma taxa funcional f descrita por a notação SAN.
A interpretação da função pode ser visualizada com a avaliação de uma expressão não tipificada de linguagem de programação (e.
g, linguagem Java).
Cada comparação é avaliada para valor 1 (verdadeiro) e valor 0 (falso).
Definindo- se a função f como segue abaixo, temos então três taxas de transições distintas dependendo do estado em que se encontra o modelo.
Como pode- se observar na definição da função f, a taxa de ocorrência da transição do estado para o estado 1 é igual a 1 esteja no estado 0), e igual a 2 esteja no estado 2), e a transição não ocorrerá caso o autômato A (1) esteja no estado 1.
As probabilidades de cada evento podem ser expressas por funções tal qual as taxas de ocorrência.
A definição de funções usadas para expressar as probabilidades funcionais são exatamente iguais as funções usadas para definir as taxas de ocorrência e permite associar a um evento diferentes valores.
Em a Figura 3.1, pode- se observar o uso de probabilidades para as transições entre os estados 2 e 0 com probabilidade 2, e 2 e 1 com probabilidade 1.
Estas probabilidades definem uma provável escolha.
Assim, quando houver a ocorrência do evento e4, o autômato A cujo estado atual seja o 2 transitará para o estado 0 com a probabilidade 2 ou para o estado 1 com probabilidade 1, a soma das taxas de probabilidades deve ser igual a 1.
Segundo, as Funções de Atingibilidade e Integração são outros dois tipos utilizados em SAN.
As expressões que definem estas funções são descritas da mesma forma que as taxas e probabilidades funcionais.
Entretanto, esses dois tipos de funções desempenham papéis diferenciados conforme descrição a seguir.
Função de Atingibilidade:
Devido a a representação em SAN ser de forma modular e o autômato global (equivalente à cadeia de Markov) se constituído por a combinação de todos os autômatos do modelo, é necessário especificar uma função que determina os estados atingíveis do autômato global de um modelo em SAN.
A definição de quais estados podem ser atingíveis (ou alcançáveis) num modelo em SAN é dada por a função de atingibilidade.
Essa função é definida usando- se as mesmas regras adotadas para a definição de taxas e probabilidade funcionais.
Ainda segundo, a noção de função de atingibilidade fica mais clara ao se imaginar, por exemplo, um modelo de compartilhamento de recursos, onde se tem N clientes disputando R recursos.
Este sistema pode ser modelado em SAN usando um autômato com dois estados para cada cliente.
O estado 0 representa que o recurso não esta sendo utilizado por o cliente i, enquanto o estado 1 representa que o recurso está em uso por o cliente i.
É fácil imaginar que, se o número R de recursos for menor do que o número N de clientes, o estado global que representa todos os clientes utilizando um recurso não poder ser atingido, pois este estado não corresponde a realidade do modelo.
Os estados que possuem tal característica são chamados de estados inatingíveis e devem ser eliminados do modelo através da função de atingibilidade, pois a probabilidade do modelo encontrar- se em algum destes estados é igual a zero.
A função de atingibilidade correta para o modelo de compartilhamento de recurso descrito é a seguinte:
Funções de Integração:
Define- se para a obtenção de resultados numéricos sobre o modelo em SAN.
As funções de integração avaliam qual a probabilidade do modelo em SAN encontrar- se num determinado estado.
Segundo, pode- se compor funções de integração que levem em conta a probabilidade do modelo se encontrar num conjunto de estados, podendo assim obter índices de desempenho e confiabilidade do modelo.
Essas funções de integração são avaliadas sobre o vetor de probabilidade que contém a probabilidade do modelo se encontrar em cada um dos estados pertencentes a ele.
Um exemplo de Funções de integração, tendo em mente o modelo de compartilhamento de recursos exposto anteriormente é dado por a função u, onde se quer descobrir a probabilidade do autômato A não estar utilizando o recurso, i.
e, encontrar- se no estado 0.
Em SAN todas as funções são modeladas da mesma forma, a forma de como são empregadas é que as diferenciam.
Modelagem de SAN na Ferramenta PEPS Esta seção descreverá o uso da ferramenta PEPS 2007 para a implementação de exemplos de modelagem SAN e para tal será necessário a apresentação dos módulos que compõem este pacote de software.
Este software é composto por alguns módulos que implementam os passos para a resolução do modelo.
Os módulos são agrupados em três fases:
Descrição, compilação e solução.
A fase de descrição é composta por os módulos de interface.
O módulo de estrutura dos dados compõe a fase de compilação e a fase de solução se preocupa com a solução dos modelos.
Todas as informações acerca de a ferramenta PEPS 2007 foram extraídas de e do manual de instruções da própria ferramenta1.
O módulo de interface textual para descrever modelos mantém a característica chave do formalismo SAN:
Ser modular.
O PEPS 2007 incorpora uma abordagem baseada em grafos que é próximo a os modelos semânticos.
Em esta abordagem cada autômato é representado por um grafo, em que os nodos são os estados e os arcos representam transições por a ocorrência de eventos.
Esta descrição textual foi mantida simples, extensível e flexível.
É bastante simples, porque há poucas palavras reservadas, o suficiente para delimitar os diferentes níveis de modularidade;
Extensível porque a definição do modelo SAN é executado hierarquicamente;
Flexível porque a inclusão de estruturas de replicação permite a reutilização de autômatos idênticos, e a construção de autômatos repetindo blocos de estado com o mesmo comportamento.
A descrição da SAN é composta por 5 blocos, conforme a Figura 3.3 que são facilmente localizados com os seus delimitadores2 (em negrito).
As outras palavras reservadas do PEPS, linguagem de entrada, são indicadas com a fonte itálica.
Os símbolos&quot;\&gt; «indicam informação mandatória O primeiro bloco, identificadores (identifiers), contêm todas as declaracões dos parâmetros:
Valores numéricos, funções, ou conjuntos de índices (domínios) a ser usado por a replica na definição Os valores numéricos e funções são definidas de acordo com a sintaxe da linguagem C. Em geral, as expressões são similares as expressões matemáticas com lógicas e operadores aritméticos.
Os argumentos destas expressões podem ser números constantes, identificadores de autômatos ou identificadores de estados.
Em este último caso, as expressões são funções definidas no espaço de estados do modelo SAN.
Por exemplo, «o número de autômatos no estado n0 (que dado um resultado inteiro) pode ser expresso como nb n0.
Uma função que retorna o valor 4 se dois autômatos (A1 e 1 Este manual pode ser encontrado em www-id. Imag.
Fr/ Logiciels /peps/palavra delimitadores é usada para indicar símbolos necessários, tendo uma posição fixa no arquivo.
A2 stA1! $= stA2) 4.
Operadores de comparação retornam o valor &quot;1 «para o resultado verdadeiro ou o valor &quot;0 «para o resultado falso.
Como pode- se observar na declaracão de identificadores, de acordo com a Figura 3.3, é possível declarar quantos forem necessários e a sua definição é a seguinte:
&quot;id_ name\&gt; «É um identificador de expressão que começa com uma letra e é seguida por uma sequência de letra ou números.
O comprimento máximo de uma expressão é 128 caracteres;
&quot;dom_ name\&gt; «É um identificador de domínio.
É um conjunto de índices.
Um domínio pode ser por um intervalo», por um lista «&quot;ou por lista de intervalos».
Identificadores podem ser usados para definir um intervalo», onde ID1 e ID2 são identificadores com valores constantes.
Em todos os casos, o domínio deve respeitar uma ordem crescente de valores;
&quot;exp\&gt; «É um número real ou uma expressão matemática.
Um número real tem um dos seguintes formatos:
Um número inteiro, tal como &quot;12345&quot;;
Um número real com ponto flutuante, tal como &quot;12345,6789&quot;;
Um número real com mantissa e exponente, tal como &quot;12345E(ou e)+(ou «ou &quot;12345.6789 e+ 100».
Conjuntos de índices são usados para definir números de eventos, autômatos ou estados que podem ser descritos como replicações.
Um grupo de autômatos replicados de A com o conjunto em índices define o conjunto contendo os autômatos A;
A; A;
A; A;
A; E A. O bloco de eventos define cada evento do modelo dado:
Seu tipo (local ou sincronizando);
Seu nome (um identificador);
Seu índice (uma constante ou função previamente definida no bloco de identificadores).
Adicionalmente, eventos podem ser replicados usando os conjuntos de índices (domínios).
Esta facilidade pode ser usada quando eventos com os mesmos índices aparecem num conjunto de autômatos.
Formato do bloco events events loc evt_ name\&gt; (rate\&gt;) syn evt_ name\&gt; (rate\&gt;)· &quot;loc «define o tipo de evento como um evento local;
&quot;syn «define o tipo do evento como evento sincronizado;
&quot;evt_ name\&gt; «o identificador do evento inicia com uma letra e é seguida por uma sequência de letras ou números.
O tamanho máximo de um identificador é de 128 caracteres.»
é um conjunto de índices.
O replication_ domain deve ter um identificador definido no bloco de identificadores.
Um evento pode ser replicado em até três níveis.
Cada nível é definido por replication_ domain.
Por exemplo, um evento replicado em dois níveis é definido como;
&quot;rate\&gt; define a taxa dos eventos.
Deve ser um identificador de expressão declarado no bloco de identificadores.
O bloco de reachability é uma função definindo o espaço de estados atingíveis do modelo SAN.
Usualmente, é uma função Boolean, retornando um valor diferente de zero para os estados de S, conjunto completo dos estados de um autômato, que pertence a S, espaço de estados produto de um modelo SAN.
Um modelo onde todos os estados são atingíveis tem a função de atingibilidade definida como qualquer constante diferente de zero, e.
g, o valor 1.
Opcionalmente, a função de atingibilidade parcial pode ser definida por a adição da palavra reservada &quot;partial».
Em este caso, somente um subconjunto de S é definido, e o total de S será computado por a ferramenta PEPS Em este bloco são definidas as funções usadas para computar os índices de desempenho do modelo.
Os resultados dado por o PEPS 2007 são os valores integrais dessas funções com a distribuição estacionária do modelo.
Este bloco é opcional.
Formato do bloco results results· res_ name\&gt; é um simples identificador;
Em esta seção serão apresentados dois exemplos para ilustrar a capacidade da modelagem e a eficácia computacional da ferramenta PEPS 2007.
Para cada exemplo, um modelo SAN genérico é descrito.
Um Modelo de Compartilhamento de Recursos O primeiro exemplo é um modelo tradicional de compartilhamento de recursos, onde N processos distintos compartilham uma certa quantidade (R) de recursos distintos.
Cada um destes processos alternam entre um estado de dormência e utilização do recurso.
Quando um processo deseja mover do estado de dormência para o estado de utilização encontra o processo R já utilizando os recursos, então o processo falha ao acessar o recurso e retorna ao estado adormecido.
Note que quando R $= 1, este modelo reduz ao problema de exclusão mútua usual.
Analogamente, quando R $= N todos os processos são independentes e não há nenhuma restrição em acessar os recursos.
Indica- se i para ser a taxa em que processo i acorda do estado adormecido desejando usar o recurso, e µi, a taxa em que este mesmo processo libera o recurso.
Em a representação SAN (Figura 3.4), cada processo é modelado por um autômato com dois estados A (i), e os dois estados são dormindo e usando.
Indica- se stA para denotar o estado atual do automato A.
Será também introduzida a função f $= (stA (i) $= usando) R i $= 1 onde (b) é uma função inteira que terá o valor 1 se o Boolean b é verdadeiro, e o valor 0 caso contrário.
Portanto, esta função f terá o valor 1 quando acesso ao recurso é permitido e terá valor 0, caso contrário.
A Figura 3.4 fornece uma ilustração gráfica deste modelo.
Em esta representação cada autômato A tem dois eventos locais.
Gi que corresponde ao i-ésimo, com taxa i f;
Ri que corresponde ao i-ésimo processo liberando um recurso, com taxa µi.
A representação textual (arquivo.
San) descrevendo este modelo é:
Identifiers quantidade de recursos mu1 $= lambda1* (nb usando R); (
nb usando R);
Mu3 taxa para deixar um recurso para o processo 3 lambda3 $= lambda3* (nb usando R); (
nb usando R);
Events loc (f2) loc loc G3 (f3) loc loc G4 (f4) loc network rs1 (continuous) aut A1 stt (usando) stt usando te o (dormindo) R1 aut A2 stt (usando) stt usando te o (dormindo) R2 aut A3 stt (usando) stt usando te o (dormindo) R3 aut A4 stt (usando) stt usando te o (dormindo) R4 results probabilidade para todos os recursos que estão sendo utilizados full probabilidade para todos os recursos que estão sendo disponíveis empty probabilidade que o primeiro processo usa o recurso use1 número médio de recursos ocupados average Não será possível usar replicadores para definir todos os quatro autômatos deste exemplo.&amp;&amp;&amp;
De fato, o uso de replicadores somente é possível se todos os autômatos são idênticos, que não é o caso aqui desde que cada autômato tenha eventos diferentes (com taxas diferentes).
Primeiro Servidor Disponível (FAS) Em este segundo exemplo será considerado uma fila com chegadas exponenciais comuns e um servido por o primeiro servidor disponível, i.
e se C1 está disponível, o cliente é servido por ele, caso contrario se C2 está disponível o cliente é servido por ele, e assim por diante.
Este comportamento de fila não é monotônico, então, até pode- se determinar, onde não há nenhuma solução à formaproduto para este modelo.
O modelo SAN descrevendo esta fila é apresentado na Figura 3.5.
A técnica básica para modelar esta fila é considerar cada servidor com um autômato com dois estados (estados ocupado e livre).
A chegada em cada servidor é expressa por um evento local (chamado Li) com uma taxa funcional que é diferente de zero e igual a, se todos servidores precedentes estão ocupados, e zero caso contrário.
Em um dado momento, somente um servidor, o primeiro disponível, tem uma taxa de chegada diferente de zero.
O fim do serviço de cada servidor é simplesmente um evento local (Di) com taxa constante µi.
O formato textual na ferramenta PEPS 2007 para este modelo é o seguinte:
Identifiers lambda L2 (f2) D2 (mu2) loc loc L3 (f3) D3 (mu3) loc L4 (f4) loc D4 (mu4) network fas (continuous) aut C1 stt livre te o (ocupado) L1 stt ocupado te o (livre) D1 aut C2 stt livre te o (ocupado) L2 stt ocupado te o (livre) D2 aut C3 stt livre te o (ocupado) L3 stt ocupado te o (livre) D3 aut C4 stt livre te o (ocupado) L4 stt ocupado te o (livre) D4 results Este capítulo apresenta uma breve introdução sobre uma estrutura de dados conhecida como MDD que pode representar funções de entrada e saída multi-valorada.&amp;&amp;&amp;
O MDD é uma generalização da estrutura de BDD (Diagramas de Decisão Binária).
Um BDD é um grafo acíclico direto, que surgiu como uma estrutura de dados alternativa, utilizada em Stochastic Petri Nets (SPN), onde se armazena apenas as partes atingíveis de um modelo SPN, utilizando valores binários em seus nodos, estes valores são 0 e 1.
Diferentemente, o MDD pode armazenar em seus nodos, valores inteiros quaisquer, não se restringindo a valores binários.
Um MDD é a representação de uma árvore de decisão como o BDD, onde sub-árvores são agregadas.
Mais precisamente, MDD é uma árvore de decisões reduzida que não contêm qualquer nó em redundância, neste contexto um nó não é único, se é uma réplica de um outro nó, e redundante, se todos os seus nós filhos são idênticos.
Através de variáveis de ordenação, estes dois requisitos confirmam que MDDs fornecem uma representação canônica de funções de inteiros.
Segundo, na Figura 4.1 nós não terminais são representados por círculos e nós terminais subconjunto representado por um N-nível MDD se e somente se o caminho por o MDD, iniciando no nó de nível N, seguindo abaixo a indicação x, alcance o nó terminal 1.
Arcos e nós pontilhados são caminhos que direcionam somente para o nó terminal 0.
A seguir serão apresentadas algumas propriedades pertinentes à MDD:
Nós são organizados em N+ 1 níveis;
O nível N tem somente um único nó não-terminal (a raiz), considerando que os níveis de N -- 1 tem um ou mais nós não-terminais;
O Nível 0 tem dois nós terminais:
0 e 1;·
Um nó não-terminal p no nível l contém nl arcos apontando para os nós no nível l -- 1.
Um· Não existem nós que sejam duplicados.
Dois nós p não-terminal distintos e q no nível l são duplicatas se x (l) S (l), p $= q..
Formalmente, no MDD M é uma tupla (V;
R; E;
Var; DV;
Forma um grafo direcionado acíclico com r como origem e 1 como o direcionador para todos os os nós com um índice variável tal que var $= n+ 1 e D é uma identificação Du, v em todas as arestas (u, v) chamado de edge domain das arestas.
Utilizando Diagramas de Decisão Multivalorada em SAN A explosão do espaço de estados do formalismo estruturado SAN é uma realidade por o fato deste formalismo ser baseado em Cadeias de Markov que mesmo para sistemas menos complexos pode vir a ter uma explosão no conjunto de estados.
A estruturação do formalismo SAN permitiu diminuir esta explosão de estados em modelagens baseadas em Cadeias de Markov, porém, como dito anteriormente, ainda ocorre a explosão de estados na modelagem de sistemas reais.
A atual forma de geração e armazenamento do espaço de estados atingíveis para o formalismo SAN utiliza uma abordagem baseada em Vetor de Booleanos.
Cada possível estado do modelo requer uma posição que o represente nesse vetor.
Se um estado é determinado como atingível, a posição correspondente do vetor é assinalada como verdadeiro, caso contrário é assinalada como falso.
Portanto, o consumo de memória para este procedimento é considerado custoso em relação a representação de sistemas grandes e de alta complexidade.
Aplicar o MDD em SAN emerge como uma alternativa interessante para diminuir os problemas de explosão de espaço de estados, na medida em que o MDD armazenará somente o conjunto de espaços atingíveis de uma SAN.
O formalismo SAN tem a característica de ser modular, tornando fácil assumir que cada estado do modelo SAN seja inserido num nível da estrutura do MDD.
A Figura 4.3 apresenta um modelo MDD com uma provável estruturação do modelo SAN com 4 autômatos da Figura 4.2.
Em a Figura 4.3, o MDD disponibiliza os autômatos de maneira que a sua disposição seja feita do nó raiz até os nós terminais da estrutura.
Em sua estrutura, o MDD não representa os estados inatingíveis.
Esta afirmação de que os estados não atingíveis não são representados na porção de espaço de estado é verdadeira, mas não para todos os modelos.
Nem todos os modelos tem alguma redução do espaço de estados.
Por exemplo, há modelos (como o modelo ASP -- Alternate Service Pattern) em que o espaço de estados produto (PSS) é o mesmo que o espaço de estados atingíveis (RSS).
Logo, neste caso, não há redução alguma do espaço de estados.
Mas sim, em outros casos, o RSS de um modelo é menor (e às vezes, muito menor) do que o PSS do modelo.
Desta forma, têm- se uma melhor eficiência no armazenamento de um dado conjunto de estados.
Exemplo de Obtenção de Estados Atingíveis Através do Uso de MDD Em esta seção será apresentado um exemplo que demonstrará o uso das ferramentas PEPS e o algoritmo RSS- Finder, que aplica as técnicas de MDD, para efeitos de comparação de resultados de ambas as ferramentas.
O objetivo é verificar se os resultados apresentados são efetivamente os mesmos.
O primeiro exemplo, Figura 4.4, é um modelo de compartilhamento de recursos tradicional, conforme descrito na seção 3.5.6, onde N $= 4 e R $= 2.
Para este modelo serão obtidos os estados atingíveis, apresentados na Tabela 4.1, utilizando a ferramenta PEPS em sua configuração mais básica baseada no método de potência.
Segundo a ferramenta, 11 dos 16 possíveis estados globais são atingíveis.
A Tabela 4.1 aponta quais os estados globais atingíveis do modelo referente a a Figura 4.4, EG representa estes estados.
Como pode- se observar na tabela, cada coluna corresponde a um autômato e as linhas representam os estados globais.
É possível observar ainda que as linhas correspondentes a posição 7, 11, 13, 14 e 15 não foram apresentados na tabela por serem estados globais inatingíveis.
Para todos os efeitos estas linhas tracejadas serão sempre omitidas, uma vez que o algoritmo apenas manipula em suas listas os estados atingíveis.
A Figura 4.6 é uma apresentação da árvore com os que estes são os estados atingíveis do modelo.
Comparando estes resultados com os dados apresentados na Tabela 4.1 percebe- se que são exatamente os mesmos.
Desta forma, o uso de MDD garante, para alguns modelos, a redução do espaço de estados como demonstrado na Figura 4.6.
A utilização de MDD em SAN surgiu como uma técnica que viabiliza a obtenção dos estados atingíveis que aproveita a vantagem da estrutura modular do formalismo SAN, que também permite representar a matriz de taxa de transição de CTMC por meio de uma soma de produtos generalizados Kronecker.
Em este capítulo será apresentada uma abordagem dos algoritmos para cálculos de estados sucessores e predecessores que serão aplicados na ferramenta de simulação visual para o formalismo SAN baseada em eventos, onde extrai- se o conjunto de eventos para este modelo e constrói- se a função de transição para representar as mudanças de estados possíveis.
Em a seção 5.2 é descrito o processo de estruturação de dados para a representação de modelos SAN na linguagem XML.
Algoritmo para Obtenção de Estados Sucessores e Predecessores matrizes quadradas, de ordem ni.
Estas matrizes que compõem o Descritor Markoviano1 permite a identificação das transições entre os estados através de tensores.
Baseado neste conceito pode- se representar o conjunto dos eventos locais e sincronizantes numa matriz de transição2, representando o espaço de estados que é obtido por o produto cartesiano da dimensão de todos os autômatos^.
No caso de o modelo da Figura de uma SAN, definido como espaço de estados produto S^ é 3 x 2 $= 6.
Ressalta- se que o foco deste trabalho é o desenvolvimento de uma aplicação para simulação visual de SAN com algoritmos embutidos para o cálculo de eventos sucessores bem como os predecessores.
Portanto, não faz parte do escopo a apresentação do conceito detalhado do Descritor Markoviano e seus tensores, maiores detalhes em.
A próxima seção faz uma abordagem simplificada de como representar autômatos em matrizes.
Para representar o conjunto de eventos locais, $= e1, e2, e3, e5 do modelo, referente a Figura quadrada de ordem n igual à quantidade de estados do autômato onde os eventos locais ocorrem.
No caso de os eventos e1, e2, e3, e5, será representado, como a seguir, uma matriz quadrada de ordem 3 para o autômato A e ordem 2 para o autômato A.
Ml e3 Ml e5 De acordo com a definição do Descritor Markoviano em devese representar os eventos locais identificando- os no autômato e a partir destes construir o tensor 1 Uma representação algébrica para modelos SAN.
Uma vez construído o tensor local, será identificado o conjunto de eventos sincronizantes, para os autômatos A da Figura 3.1 há apenas o evento $= e4, e construído os tensores das transições sincronizadas que representam a ocorrência dos eventos sincronizantes em cada autômato.
Desta forma, tem- se os tensores das transições sincronizantes Me+ correspondentes aos autômatos A.
Me+ $= 0 e4 Note que o autômato A quando transposto para suas respectivas matrizes pode- se verificar que a taxa de ocorrência vai estar contida em apenas uma das matrizes e as demais apenas indicarão a ocorrência, pois realizará- se- um produto entre as matrizes e a taxa assim não é modificada.
A partir de esta estruturação das matrizes será apresentado o algoritmo para a obtenção dos estados sucessores e predecessores (antecessores).
Tomando a matriz de transições M como referência será definido que as transições entre os estados serão representadas por a posição i, j, sendo que i representa uma linha da matriz e j uma coluna.
Os elementos de uma posição i, j representam a taxa para sair do estado representado por a linha i e ir para o estado representado por a coluna j:
Saber quais são os sucessores significa percorrer uma linha da matriz;
Saber quais são os predecessores significa percorrer uma coluna desta matriz.
Para a obtenção dos estados sucessores e predecessores deve- se verificar e identificar os estados globais a partir de a execução dos autômatos pertencentes a uma SAN, listando os estados através de uma varredura no espaço de estados de um autômato.
A identificação dos estados sucessores se dá basicamente por a observação das seguintes características:
Um estado x é sucessor de um estado y quando existe uma transição com taxa não nula que pode ocorrer no estado y e leva ao estado x;
Analogamente, um estado y é predecessor de um estado x quando existe uma transição com taxa não nula que pode ocorrer no estado y e leva ao estado x.
O conjunto de estados sucessores indica os estados para onde se pode ir, e o conjunto de estados predecessores indicam os estados para onde se pode partir num modelo SAN.
A seguir temos uma transcrição dos autômatos da Figura 5.1 para matrizes de transição tanto para auxiliar na descoberta dos estados sucessores, apresentados na Tabela 5.1, quanto para estados predecessores, apresentados na Tabela 5.2.
Tabela 5.2: Matriz de transição transposta, da Tabela 5.1, para estados predecessores Como pôde- se observar foi realizado a transcrição do modelo SAN da Figura 5.1 para matrizes de transição, da Tabelas 5.1 e 5.2.
Estas matrizes tem as respectivas linhas e colunas de acordo com a quantidade de estados de cada autômato do modelo fornecido.
A descoberta dos estados sucessores, conjunto não vazio dos estados y, tais que possua uma transição do estado x para algum estado y, se dá por a verificação das linhas e colunas da matriz de transições, como se pode observar na Tabela 5.1.
E a descoberta dos estados predecessores, conjunto não vazio dos estados x, tais que possua uma transição do estado y para algum estado x, será feita por a verificação das colunas e linhas da matriz de transição, para este caso é importante observar que realizando a transposição da matriz representada na Tabela 5.1, demonstrada na Tabela 5.2, o procedimento de descoberta dos estados predecessores será tal qual para o conjunto de estados sucessores.
Exemplificando: Para saber qual o estado sucessor do estado atual de um autômato deve- se percorrer, na matriz quadrada obtida, cada linha e coluna e então identificar se há eventos.
Caso haja eventos, é a indicação de que a transição do estado representado por a linha leva ao estado representado por a coluna por o disparo do evento encontrado de acordo com a taxa do evento, se a taxa do evento for constante.
Caso o evento contenha uma taxa funcional é preciso avaliar a função para verificar se o resultado da função não é nula, se não for nula então o evento pode ser disparado.
O evento e1 encontrado na intersecção da linha 0 com a coluna 1 do autômato A quando disparado determina que o estado 1 deste autômato será o sucessor do estado 0.
Considerando que o espaço de estados produto S estados globais~ e sincronizantes são todos do conjunto).
Considerando ainda que SAN contém transições que associam os estados entre si, uma função de transição de um autômato A permite o disparo de eventos de acordo com a avaliação das taxas vinculadas aos eventos.
A aplicação da função de transição (s (l), e1) é dada por um evento e1 operando sobre cada estado local s (l) em~ deve verificar todos os autômatos envolvidos, indicando que um evento e está habilitado (ou^ para cada autômato A na rede.
Um evento desabilitado) considerando cada estado local s (l) S é dito disparável no estado local s (l) se há uma transição identificada com e de s (l) no autômato i.
Se e é um evento sincronizante e disparável num estado local, isto não implica que ele é, no momento, disparável no estado global.
A ocorrência dos eventos muda o estado global~ s para outro estado global~ r, a função de transição determina a permanência no mesmo estado global caso não haja a ocorrência de um dado evento.
A seguir serão descritas as definições informais, cujo objetivo é demonstrar algumas características para a estruturação de funções a serem aplicadas em modelos SAN para a obtenção de estados sucessores e predecessores.
Definição 1: A função de obtenção de estados sucessores e predecessores (s (l), e) retorna um novo estado local resultando do evento e disparando sobre o estado local s (l).
O novo estado local retornado pode ser o mesmo s (l), se e não o atinge, se caso não atingir a função deverá retornar 0.
Definição 2: Um evento e é dito estar habilitado no estado global~ s S,^ Analogamente, um evento é dito estar desabilitado no estado~ (s (l), e) $= r, onde s $= r, e r S. Definição 3: É a lista de eventos que se encontra na posição (Ms (l), j) da matriz.
Definição 4: Ms (l), j representa o (i, j) ésimo elemento da matriz, sendo i o autômato, s (l) é a linha que corresponde ao estado de onde foi disparado um determinado evento e j a coluna da matriz.
Definição 5: O (e) é conjunto dos autômatos afetados por o evento e.
Considerando que um evento e é disparável no estado global~ s se e somente se para todos os autômatos envolvidos por o evento e, o conjunto de estados sucessores (s) para o evento e não são vazios (i, (s (l), e) $ ).
Uma aplicação da função de obtenção de estados sucessores e predecessores no produto do espaço^ PSS, formados por os estados atuais da rede, deve resultar no conjunto de estados S, sucessores ou predecessores, se e somente se r não for vazio e a função de sucessão/ predecessão (s (l), e) $= r (l).
A aplicação da função (s (l), e) atribuída ao evento e1, do autômato apresentado na Figura 5.2, indicará qual o estado sucessor para cada estado global~ s S determinando qual será o comportamento do sistema prevendo se o estado atual terá o seu estado sucessor ativado.
Considerando o estado local s (l) do autômato A (i).
A aplicação da função resulta no estado r (l) significando que o evento está habilitado para o estado local s (l).
Se a aplicação da função resulta vazio, consequentemente o evento e é desabilitado para este estado local s (l).
Analogamente, dado um estado global~ visualizada genericamente como (s (l), e) $ ~ r se e está habilitado para~ s, ou (s (l), e) $ ~ s se ep está desabilitado para~ s.
Algoritmo para Obtenção dos Estados Sucessores O Algoritmo 5.1 mostra o procedimento de obtenção de estado sucessor, de acordo com as proposições tratadas nas seções anteriores, pressupondo a realização de um disparo de evento, onde o autômato e o estado são informados por o usuário e o autômato pertecente à s (conjunto dos estados sucessores) é analisado para disparar um evento ep e verificar os estados sucessores através da execução da função de sucessão, considerando o exemplo na Figura 5.2.
O fato de uma SAN ser constituída de autômatos compostos por estados que por sua vez possuem transições com eventos locais ou sincronizantes e considerando o fato de haver dependências entre eles por meio de as taxas funcionais que determina a ocorrência dos eventos.
O atendimento a estas características garantirá uma simulação coerente do disparo de eventos implicando num tratamento mais elaborado por parte de o algoritmo.
Para a explicitação do algoritmo proposto será utilizado a SAN apresentada na Figura 5.2, para que se tenha um melhor entendimento das funções pertecentes ao Algoritmo 5.1.
Inicialmente, o algoritmo deve realizar uma varredura nas matrizes de transições que representam os autômatos da SAN, a Tabela 5.3 apresenta estas matrizes referente a a Figura 5.2, para que assim seja realizada uma verificação das linhas e colunas (linhas 4 e 6) e então descobrir, por meio de o estado atual, s (l), fornecido por o usuário, quais eventos podem ser disparados.
O estado atual de um autômato é representado na tabela de transição por uma das linhas existentes na matriz.
A cada vez que é encontrado um ou mais eventos em o (i, j) ésimo elemento da matriz, a lista de eventos é atualizada, processo realizado na linha 8.
Esta lista será verificada para a avaliar se o evento desta lista se encontra inserido na lista de eventos analisados, enquanto a lista não for propósito de pegar cada evento contido em para verificar se o mesmo já foi analisado.
Em a linha 11 é verificado se o evento pertence a lista de eventos analisados, uma vez analisado o evento é ignorado para os demais autômatos, e ainda é realizada uma avaliação para identificar se o evento tem taxa funcional para que seja realizados os cálculos necessários para o disparo do evento, as taxas funcionais exigem um tratamento especial no algoritmo por o fato de ser necessário uma avaliação léxica e sintática em sua estrutura.
De acordo com a Figura 5.2, o modelo apresenta dois autômatos com 2 e 3 estados, respectivamente, com taxa funcional definida para o evento e1.
Com a identificação da taxa funcional o algoritmo realizará a solução da função estabelecida, no caso de o exemplo fornecido, será feita uma varredura na lista de autômatos verificando se o autômato A se encontra no estado 0 ou se o autômato A se encontra no estado 2.
Caso se encontre num dos 2 estados no autômato A da rede, será calculada a expressão matemática.
Finalmente, a taxa funcional será analisada para verificar se o resultado é diferente de zero e assim permitir ou não o disparo do evento com a taxa funcional.
Note que se não houver taxa funcional e o evento for local, o mesmo será disparado imediatamente.
Para os eventos sincronizantes presentes na rede será realizado uma varredura na lista de autômatos (linha 26) e verificar se todos os estados de onde se origina a transição são os estados atuais, e assim realizar o disparo destes eventos.
Por fim, caso seja realizado o disparo do evento a lista de estados sucessores será atualizada assim como a lista de eventos analisados e em seguida retornado os estados sucessores.
Algoritmo 5.1: Procedimento de obtenção de estados sucessores (s) for i $= 0 to N -- 1 do for j $= 0 to ncolunai -- 1 do, j addList (M (l)), j/)| (i $= min (O (e)) then rs dispara false Tx fe (s) Tx e dispara true r j for l O (e) do dispara false break s add (r) add (e) Exemplo de Uso do Algoritmo para Obtenção dos Estados Sucessores A seguir, é demonstrado a obtenção dos estados sucessores através do disparo de transições dos estados locais atuais (estado atualmente posicionado ou selecionado) nos autômatos do modelo.&amp;&amp;&amp;
Para isto, deve- se criar a matriz de transição do respectivo modelo (Figura 5.2), a Tabela 5.3 repre- senta esta matriz.
Os eventos locais serão disparados através da função, gerando os respectivos estados sucessores.
Dado que o estado local atual do autômato A seja o estado 1 e o estado local atual para o autômato A seja o estado 0, conforme indicado na Figura 5.3 em destaque tracejado, se houver disparo das respectivas transições será retornado os seguintes estados:,
1), em destaque pontilhado na figura.
Note que o disparo das transições é simultâneo por ser tratar de um evento sincronizante, e2.
Algoritmo para Obtenção dos Estados Predecessores Todos os procedimentos para se obter os estados predecessores de uma Rede de Autômatos de Estocásticos é bastante semelhante aos procedimentos de obtenção de estados sucessores, exceto por o fato de se ter uma matriz de transição transposta.
O Algoritmo 5.1 mostra o procedimento de obtenção do estado sucessor, para que se obtenha os estados predecessores deve- se realizar os procedimentos citados na seção 5.1.1, ou seja, encontrar a matriz transposta da matriz de ordem n que representa a Rede de Autômatos Estocásticos e assim com a aplicação do Algoritmo 5.2 sobre a matriz transposta será obtido os estados predecessores.
Para um estado ser predecessor de outro através de um evento com taxa ou probabilidade funcional é necessário que a taxa (e eventualmente a probabilidade) tenham valores não nulos considerando o estado de origem (o candidato a predecessor).
Exemplo de Uso do Algoritmo para Obtenção dos Estados Predecessores A seguir, é demonstrado a obtenção dos estados predecessores através do disparo de transições dos estados locais atuais (estado atualmente posicionado ou selecionado) nos autômatos do modelo.
Para isto, deve- se criar a matriz de transição transposta do respectivo modelo (Figura 5.2), a Tabela respectivos estados predecessores.
Tomando a Figura 5.4 como exemplo, será aplicado o algoritmo 5.2 para descobrir quais os estados predecessores do estados locais atuais dos autômatos.
Dado que o estado local atual do autômato A seja o estado 1 e o estado local atual para o autômato A seja o estado 2, conforme indicado na Figura 5.4 em destaque pontilhado, se houver disparo dos eventos e1 e e3, e estes disparos aplicados na matriz transposta da Tabela 5.4, serão retornados, respectivamente, os seguintes estados:,
2) e (1 (1), 1 (2)).
Em este caso, dado a ocorrência destes dois eventos têm- se o estado predecessor, 1), conforme mostrado em destaque tracejado na Figura 5.4.
Considerações Observando os aspectos estruturais dos modelos SAN, percebe- se os estados globais e o efeito dos eventos sobre eles.
A obtenção dos estados sucessores e predecessores é um passo importante para se avaliar o comportamento de sistemas, e estes estados indicam um possível comportamento esperado em parte do sistema modelado.
Estrutura de Dados Baseada em XML para Representação da SAN Em este capítulo será apresentado a estrutura de dados que representará um modelo descrito no formalismo SAN.
Esta estrutura de dados tem como finalidade facilitar uma eventual transação entre aplicações que se utilizam do formalismo estruturado SAN.
Para representar num formato estruturado um modelo baseado em SAN será utilizado a XML (eXtended Markup Language).
O XML é um formato para a criação de documentos com dados organizados de forma hierárquica.
É um conjunto de regras para a codificação de documentos em forma estruturada e legível por máquina.
Projetado para enfatizar a simplicidade, generalidade e usabilidade nas transações de informações entre aplicações dentro e fora de a Internet.
Maiores detalhes sobre como se estrutura um arquivo no formato XML pode ser encontrado em.
Por ser uma formato de dados textual, a XML permite a SAN representar os autômatos do modelo de forma prática.
Para representar a SAN num formato XML primeiro é necessário definir a estrutura hierárquica que implicará em definir qual tag será a principal, bem como definir o corpo da estrutura do modelo SAN em XML com suas respectivas tags.
O tópico a seguir define a estrutura básica desta representação.
A Figura 5.5 apresenta uma SAN com 2 autômatos que servirá como base para exemplicar a transposição de um modelo SAN para o padrão de arquivos XML.
A estrutura do arquivo XML será composto por as seguintes blocos de informações:
San: Define o bloco principal (raiz) incluindo a estruturação que o sistema terá, aqui teremos todas as propriedades de um modelo SAN, como por exemplo estados, transições e taxas.
Uma SAN poderá conter n estados e transições;
States: São os estados que a SAN possui.
Em este bloco será descrito o posicionamento gráfico de cada estado, deverá conter um bloco interno que descreverá as posições referente a cada estado;
Transitions: O conjunto de transições definidos nos estados de uma SAN;
Rates: Correspondem as taxas definidas para cada transição;
Events: Define os eventos de cada transição disponível no modelo.
X, y:
Define os posicionamento de cada estado, no editor gráfico, disponível no modelo.
A seguir, têm- se um exemplo do arquivo XML para a SAN apresentada na Figura 5.5.
Observa- se que para um modelo descrito em XML estar sintaticamente correto, existem bibliotecas que validam o arquivo a partir de um esquema (XML Schema Definition, ou XSD) predefinido.
Uma vantagem de se usar XML para descrever uma SAN é a possibilidade de validar arquivos sintaticamente.
O uso da XML garantirá uma melhor integração com outras ferramentas, por ser uma linguagem padronizada de transação de dados entre aplicações, que por ventura venham a utilizar modelos SAN para medidas de desempenho.
A ferramenta VisualSAN deverá ter em sua implementação a aplicação do XML como meio de realizar transações entre pacotes de software.
Estas transações poderão ser de simples envio de dados até mesmo a estrutura completa de SAN.
Este capítulo apresenta a estruturação da ferramenta para apoio a modelagem de sistemas por meio de o formalismo estruturado SAN.
Esta estrutura foi definida para aplicação do algoritmo proposto no Capítulo 5 que é um dos objetivos deste trabalho além de a integração com algoritmos para avaliação de modelos SAN por meios de métodos analíticos, GTAExpress, e o algoritmo baseado em MDD para obtenção de estados atingíveis com redução de espaço de estados, RSS- Finder.
O termo RSS- Finder é apenas uma referência à técnica apresentada no Capítulo 4.
A Figura 6.1 apresenta a estrutura e identifica as relações dos módulos que fazem parte da ferramenta.
A figura apresenta, ainda, que a estrutura é composta por módulos de edição dos autômatos SAN, edição de funções, móduto de integração com software que fornecem os algoritmos baseados em soluções numéricas, GTAExpress e RSS- Finder, e o editor auxiliar.
O editor auxiliar servirá para complementar o modelo SAN para ser utilizado por as ferramentas GTAExpress e RSS- Finder.
Ainda é possível observar na Figura 6.1 que o usuário manipulará os módulos que interagem diretamente com o ambiente de simulação SAN.
Em o módulo editor de SAN o usuário pode interagir para criar redes de autômatos estocásticos.
Em o módulo editor de funções, o usuário informará as taxas constantes ou funcionais e no editor auxiliar o usuário poderá inserir informações que complementam o arquivo».
San», este utilizado por as ferramentas GTAExpress e RSS- Finder.
Para o desenvolvimento da ferramenta VisualSAN foram necessárias adaptações bastante abrangentes na ferramenta JFlap tais como:
Permitir a modelagem de vários autômatos, de acordo com a concepção do formalismo SAN, por meio de a inserção de vetores, inclusão de algoritmos de análise léxica, sintática e semântica baseados na ferramenta JavaCC, inclusão de interatividade utilizando controles para simular as tabelas de eventos e suas taxas e a disponibilização dos algoritmos definidos no Capítulo 5.
Objetivos da Ferramenta Projetar e implementar sistemas complexos implica em resolver problemas como a interação de processos com comportamentos inesperado ou que não interajam entre si a todo instante.
Desenvolver sistemas com estas características pode ser tão propenso a erros e custosos que se torna interessante fazer uso de ferramentas que permitam simular o comportamento de sistemas reais.
Pensando nisto, este trabalho tem como objetivo disponibilizar uma ferramenta que dê suporte a modelagem visando a avaliação do desempenho e a verificação do comportamento de sistemas.
O uso de ferramenta para modelagem auxilia no desenvolvimento de projetos, pois habilitam projetos específicos a serem testados e aperfeiçoados de modo a proporcionar o máximo de desempenho e ao mesmo tempo proporcionar a eliminação de problemas inerentes ao projeto, tais como taxas funcionais mal formadas, modelos SAN mal formados, ou seja que não atendam as definições estabelecidas no formalismo SAN, e possíveis estados absorventes.
Adicionado ao benefícios da interatividade que a simulação visual propõe, esta ferramenta terá um propósito educacional permitindo que acadêmicos possam aplicar os conceitos do formalismo SAN em pesquisas que necessitem de auxílio na avaliação dinâmica de modelos SAN, bem como analisar os comportamentos do sistema em estudo.
Visão Geral O objetivo deste projeto é produzir um ambiente que contenha:
Uma interface gráfica para executar modelos SAN utilizando a linguagem JAVA;
Um simulador que permita a representação de grafos tais como os fornecidos por o formalismo estruturado SAN e que execute alguma funcionalidade e características básicas de avaliação de desempenho;
Interação com a ferramenta PEPS2007 por meio de o software GTAExpress.
Interação com o algoritmo para obtenção de estados atingíveis RSS- Finder.
Esta ferramenta é um software experimental com funcionalidades para manipular modelos baseados no formalismo SAN.
Este pacote gráfico poderá ser utilizado principalmente como uma forma de auxiliar na aprendizagem dos conceitos básicos de Redes de Autômatos Estocásticos.
Arquitetura A arquitetura deste software é baseada no pacote JFLAP e JavaCC.
O JFLAP é um software para pesquisas com linguagens formais com tópicos que incluem autômatos finitos não-determinísticos, autômatos de pilha não-determinísticos, máquinas de Turing (multi-tape), vários tipos de gramáticas, parsers.
Além de construir e testar para estas finalidades citadas, o JFLAP permite experimentos que podem utilizar conversões entre os tópicos citados, como por exemplo converter um modelo de autômatos finitos não-determinísticos para autômatos finitos determinísticos e deste para expressões regulares ou gramática regular.
O JavaCC auxilia na criação de compiladores para linguagens simples, gerando um analisador sintático.
Este programa aceita como entrada uma gramática e transforma- a num programa Java capaz de analisar um arquivo e dizer se satisfaz ou não as regras especificadas em sua gramática.
O JavaCC é um produto de propriedade da Sun Microsystems e liberado sob a licença Berkeley Software Distribution (BSD).
As características inerentes à modelagem de sistemas baseada em SAN foram incorporadas à ferramenta de maneira que as regras básicas definidas por o formalismo como manutenção de N autômatos (incluindo estados e transições), inserções de taxa funcionais, controle de execução das transições do tipo para frente e para trás e apresentação de resultados baseados nos métodos analíticos disponíveis na ferramenta PEPS2007.
As principais funcionalidades do pacote de software VisualSAN são:
Visualizar representações gráficas das propriedades estruturais;
Simulação, com interação gráfica, de sincronização;
Soluções numéricas baseadas em tensores através da integração com o GTAExpress;
Utilizar métodos mais avançados para soluções estacionárias e transitórias baseados em algoritmos esparsos e Split fornecidos por o GTAExpress;
Módulos de simulação para interação de eventos que em cooperação com a interface gráfica fornece simulação com interatividade e com animação gráfica do modelo, com passo- a- passo, e progressão de tempo para frente e para trás;
Apresentação de estado atingíveis por meio de MDD (será utilizado algoritmo (RSS- Finder) disponível em).
Processos estocásticos de um sistema podem ser representados por meio de derivações gráficas do formalismo SAN.
Um sistema é modelado em SAN através de componentes que representam a sua estrutura interna.
A interação destes componentes, que por a própria definição da SAN são multidimensionais, determina o comportamento do sistema como um todo ou define o comportamento de apenas um objeto da coleção.
Segundo, cada comportamento dos componentes é definido por a coleção de variáveis necessárias para descrever um sistema, estas variáveis correspondem ao estado do mesmo em certo instante de tempo.
A característica multi-dimensional possibilita que o sistema seja analisado granularmente, ou seja, o comportamento do sistema poderá ser avaliado individualmente, porém o comportamento geral também pode ser avaliado uma vez que ele é afetado por o comportamento individual dos sub-sistemas.
A interface com o usuário é composta por os editores de SAN e de funções que serão utilizados para a modelagem de sistemas e criação de taxas funcionais respectivamente.
A simplificidade da interface da ferramenta torna a interação com o usuário direta, ou seja, o usário influenciará na estruturação de modelos SAN.
Editor de SAN O editor de SAN permite o usuário criar modelos baseados no formalismo estruturado SAN.
O editor têm em sua composição objetos que representam os autômatos e sua estrutura interna:
Estados, eventos e transições.
Os autômatos que representam sistemas ou subsistemas, os estados representando processos ou subsistemas no autômato e as transições, atreladas com os eventos, que representam a mobilidade de um estado para outro no modelo.
Este editor, cuja interface é bastante simples, apresentado na Figura 6.2 possibilita a nomeação dos autômatos, estados e os eventos.
Esta nomeação associa os objetos da rede com as características de sistemas reais.
Em o editor está incluso funcionalidades para persistir o modelo em formato».
San», deletar objetos da modelagem, edição, alteração de nomes (rótulos) e reposicionamento de objetos no editor.
Em o processo de criação dos autômatos, no editor, há restrições que garantem um modelo bem formado de SAN.
Isto é, a SAN não será simulada se um dos estados não tem transição associada se conectando a ele ou partindo de ele para outro estado.
A execução do procedimento de simulação visual desta ferramenta será baseada no algoritmo proposto no Capítulo 5.
Este algoritmo é composto por várias rotinas, de entre elas estão as rotinas de criação das matrizes de transição (que utiliza o modelo projetado no editor), de verificação de eventos locais e sincronizantes que influenciam diretamente na simulação, de simulação (redesenho) dos objetos no editor para indicar mudanças de estados e de verificação das taxas funcionais.
Em a seção seguinte, será abordado o funcionamento do sistema por meio de as taxas funcionais.
Editor de Taxas Funcionais O editor de taxas funcionais, Figura 6.3 tem como objetivo receber do usuário informações sobre a composição das taxas funcionais da modelagem.
A partir de esta informação o sistema processará a taxa realizando um desmembramento, se necessário, para calcular as expressões contidas, como neste exemplo:
F1 $ +. Este cálculo se baseia nas definições pré-estabelecidas por o software PEPS2007, e para que a transição dependente da taxa funcional seja disparada o resultado da expressão deve ser 1;
o valor 0 impede o disparo da transicão dependente da taxa funcional associada.
As taxas funcionais informadas serão avaliadas para garantir que as mesmas sejam bem formadas.
A seguir o exemplo dado será descrito detalhadamente, bem como a sua execução.
A avaliação da taxa funcional, como dito anteriormente, deverá ser realizada com o auxílio da ferramenta JavaCC.
Este pacote de software, desenvolvido para estudo de compiladores, tem em seus mecanismos internos analisadores que avaliam uma expressão quanto a sua sintaxe e quanto a sua estrutura léxica.
Para o exemplo citado, será avaliado a primeira expressão que, segundo a definição da ferramenta PEPS2007, verificará se o autômato A se encontra no estado 0, denotado por a instrução st.
Caso seja verdadeiro, então será retornado 1, do contrário será retornado o valor 0 como resultado da expressão.
Esta avaliação ainda realiza um cálculo aritmético da expressão onde a mesma utiliza o resultado da avalição lógica para então multiplicála por a taxa constante 11, bem como por a taxa 12, e finalmente somando os resultados da multiplicação para assim, se o valor for diferente de 0, disparar o evento vinculado a esta taxa funcional.
Análise e implementação da Ferramenta Em esta seção é descrito o processo de desenvolvimento do simulador VisualSAN.
Foi escolhida a linguagem Java tm, por ser Orientada a Objetos, facilitando a representação de objetos que visam se comportar tal qual a realidade.
Ademais, a orientação a objetos é muito utilizada por a notória capacidade de modelar objetos com propriedades de herança e encapsulamento.
A ferramenta VisualSAN, apresentada na Figura 6.4 foi desenvolvida para experimentos, especificamente, com o formalismo SAN.
Este pacote fornece um ambiente desenvolvido utilizando a API 2D da linguagem JAVA.
Este ambiente disponibiliza um editor de autômatos que contém as seguintes características funcionais:
Componente que adiciona autômatos ao modelo no editor;
Função que permite inserir elementos que representam estados possibilitando a definição de rótulos e o posicionamento livre no editor;
Função para inserção de transições entre os estados, é livre a inclusão de n transições entre os estados;
Gerar da tabela de eventos a matriz de transição para cada autômato manipulado no editor;
Comando para determinar a execução da simulação do modelo.
Para o correto funcionamento da simulação proposta por a ferramenta é necessário que, a partir de a criação dos autômato no editor, sejam criadas as matrizes de transição, trabalhadas no Capítulo 5.
Estas matrizes terão uma representação muito importante, pois será através de elas que haverá a manipulação dos autômatos cujos disparos dos eventos habilitarão as interações entre os componentes (estados, eventos e transições com ou sem taxa funcional).
Em as Seções 3.1, 5.1.2 e 5.1.3 foram apresentadas as regras básicas de funcionamento de modelos de sistemas baseados em SAN e a estruturação do algoritmo.
Este software teve o conceito estrutural e funcional baseado nestas regras estabelecidas.
Para a avaliação das taxas funcionais, relacionadas aos eventos participantes dos autômatos do modelo, foi necessário o desenvolvimento de um compilador simples que fosse capaz de avaliar expressões algébricas, expressões lógicas e de realizar avaliação sintática para averiguar se a taxa funcional é válida, para tal foi utilizado o software JavaCC que possibilitou ao editor as capacidades de avalições lógicas, matemáticas e sintáticas.
Modelagem de SAN -- Exemplificando Modelos na Ferramenta O uso da ferramenta VisualSAN é bastante simples, recursos para inserção de autômatos, estados e transições estão disponíveis através de componentes gráficos que são sugestivos quanto a a sua funcionalidade.
Em as próximas subseções serão propostos exemplos com e sem taxa funcional, assim serão explorados as funcionalidades da ferramenta.
É importante destacar que os exemplos são meramente hipotéticos.
A Figura 6.5 apresenta uma modelagem de SAN com dois autômatos com 3 e 2 estados respectivamente.
As Figuras 6.6, 6.7 e 6.8 apresentam a execução dos autômatos.
Como pode- se observar é apresentado nas figuras os estados atuais e os estados sucessores, que formam respectivamente, os estados globais atuais (combinação dos estados atuais) e sucessores.
Por uma questão de melhor visualização as Figuras 6.6, 6.7 e 6.8 apresentam apenas os autômatos sendo executados.
Em a Figura 6.6 podemos notar que ao ser executada, por ser a primeira execução, o sistema apresenta os estados iniciais como sendo os estados 0 (do primeiro autômato) e 0 (2) (do segundo autômato) identificados com um círculo duplo e os estados sucessores identificados com um círculo pontilhado.
A Figura 6.7 apresenta um mudança de estados globais de 0, 0 para os estados globais 1, 0, através da mudança do estado local de 0 para o estado 1, e os respectivos estados sucessores 2 e 1.
Sempre que há mudança de estados haverá uma alteração na formação dos estados globais.
Para o evento sincronizante e4 dos autômatos apresentados na Figura 6.8, cujas transições interligam os estados 1 e 2 e os estados 1 e 0, quando executado levam aos estados sucessores 1 e 0, o próximo estado global, indicados por o estado com círculo pontilhado.
O uso de taxas funcionais em modelagem SAN define uma interdependência entre os autômatos.
Em a ferramenta proposta, as taxas funcionais são incluídas nos eventos locais e/ ou sincronizantes.
A Figura 6.9 foi modelada para exemplificação de eventos sincronizantes e evento com taxa funcional e2, demonstrada na Figura.
Como explicitado na sub-seção 6.3.1 as taxas funcionais foram implementadas na ferramenta VisualSAN com o uso do pacote de software JavaCC.
Conforme a Figura 6.10 foi editado na tabela de eventos o campo Rate referente a as taxas dos dizer que o autômato identificado como &quot;IO «deverá estar com o estado &quot;off «selecionado como o estado atual (em destaque com círculo duplo) para que a transição associada ao evento e2 possa ser disparada.
Caso o estado &quot;off «do autômato &quot;IO «seja o atual a taxa funcional será avaliada e tendo como resultado o valor 1, indicando que a condição imposta por a taxa foi satisfeita o que poderá causar o disparo do evento e2 mudando o estado global atual (error, off) para o estado global sucessor (off, on), conforme a Figura 6.11.
Em a Figura 6.9 pode- se verificar que o sistema apresenta também os estados predecessores do estado atual, estados circulado com linha tracejado, &quot;off «do autômato MEM e o estado &quot;on «do autômato IO.
Os estados sucessores dos estados atuais &quot;off «e &quot;on «não estão sendo identificados na Figura 6.11 em consequência de:
De acordo com a taxa definida para e2 o autômato IO deve estar com o estado &quot;off «como sendo o estado atual, o fato do autômato IO ter apenas dois estados impede do sistema identificar o estado &quot;off «como sendo o estado sucessor, o processo do algoritmo determina a escolha para que este estado seja identificado com sendo o estado predecessor.
Exemplo de Obtenção dos Estados Atingíveis por meio de MDD O exemplo citado nesta seção tem como objetivo apresentar o uso da ferramenta para modelagem de SAN e consequente obtenção dos estados atingíveis.
A Figura 6.12 ilustra uma modelagem referente a o exemplo citado no Capítulo 2 seção 3.5.6 cujo sistema representa um FAS.
Esta modelagem faz uso de taxas funcionais definidas através do editor de taxas funcionais representado na Figura As taxas inseridas, visualizadas na Figura 6.13, neste modelo para o evento g1 é 5, para o evento r1 é 6, para o evento g2 é 5, para o evento r2 é 5, para o evento g3 é 3) 5 e para o evento r4 é 3, sendo que todos os eventos são locais.
Ambiente de Desenvolvimento O pacote de software VisualSAN utilizou a linguagem JAVA em sua versão 1.6.0.20 em ambiente Linux/ Ubuntu versão 10.10 codinome the Maverick Meerkat.
O computador utilizado para produzilo tinha a seguinte configuração:
Quad core Intel-i7 64 bits -- Centrino, 6 GB de RAM.
Mesmo sendo desenvolvido utilizando ambiente Linux este software por ser desenvolvido com a linguagem JAVA poderá ser utilizado em qualquer sistema operacional que permita a instalação do JAVA e que execute a versão do Java acima citada.
Considerações Esta ferramenta foi desenvolvida com o propósito de comprovar o funcionamento dos algoritmos propostos no Capítulo 5 deste trabalho e ainda fornecer uma ferramenta capaz de simular modelos SAN calculando estados sucessores e predecessores.
Os estados sucessores e predecessores, num primeiro momento, apenas são identificados na SAN modelada através de círculos pontilhados e tracejados, respectivamente.
Devido a a complexidade em aliar os algoritmos a representação gráfica em 2 D, para que a mesma fosse capaz de simular visualmente os elementos de uma SAN, foi utilizado a linguagem Java para o desenvolvimento do ambiente de edição dos autômatos.
Em esta linguagem foram desenvolvidas todas as funcionalidades baseadas nos algoritmos para cálculo dos estados sucessores e predecessores, além de os próprios algoritmos para controlar o processamento das imagens que representam os autômatos.
Ainda foram necessários o uso de ferramentas de terceiros para o desenho dos autômatos, cálculo das taxas funcionais e para o cálculo dos estados atingíveis.
Estas ferramentas e os componentes do editor de autômatos serão comentadas nos apêndices deste trabalho.
Este trabalho apresentou, no Capítulo 5, as definições dos algoritmos para descobertas de estados sucessores e predecessores, a definição da estrutura de dados que representará uma SAN no formato XML e a ferramenta VisualSAN.
Cabe ressaltar, que as integrações entre a ferramenta proposta neste trabalho com as ferramentas GTAexpress e o PEPS ainda não foram concluídas pois há a necessidade de fazer novas adaptações, tais como:
Aprimorar o aplicativo para estruturação arquivo».
San «para que o software PEPS possa utilizar- lo e a integração com o software para a obtenção dos estados atingíveis dos antecessores e predecessores.
Em trabalhos futuros será feito um aperfeiçoamento da ferramenta para adequação das necessidades citadas anteriormente, bem como inclusão de alguma funcionalidade ainda não identificada.
Também foi apresentado neste trabalho o desenvolvimento de algoritmos para a obtenção de estados sucessores e predecessores, nota- se que para a obtenção destes estados foi necessário abordar procedimentos que permitissem o disparo de transições, verificação de estados locais e estados globais.
Em cada estado global alguns eventos são habilitados, mudando o estado global.
Entretanto, nem todos os eventos podem ocorrer a partir de um dado estado global.
Podemos notar que no algoritmo implementado é disponibilizado funções que não necessariamente são utilizadas em soluções para implementações de modelos SAN atuais.
Os estados sucessores e predecessores são fundamentais para a simulação gráfica de modelos SAN, pois permitem validar se um modelo é bem formado através da ocorrência dos eventos dos autômatos pertecentes à Rede de Autômato Estocásticos.
Nota- se, que com a simulação da execução do algoritmo é possível prever os estados de todos os autômatos envolvidos, o que viabiliza a resolução de modelos, segundo os critérios do formalismo SAN.
Este algoritmo foi base para o desenvolvimento da aplicação gráfica, descrita no Capítulo 7, que será utilizada para simulação e permitirá observar o comportamento de sistemas reais.
Algumas dificuldades foram encontradas ao longo de o desenvolvimento deste trabalho.
A criação do ambiente para se desenhar os autômatos foi superado com o uso da ferramenta JFLAP, embora houve outras dificuldades na adaptação para se manipular uma rede de autômatos.
O algoritmo para avaliação das taxas funcionais foi outro problema bastante difícil a ser resolvido pois o formato das expressões exigidas por o formalismo possui características bastante peculiares.
Para facilitar o desenvolvimento de analisadores léxicos foi utilizado o pacote de software JAVACC, as adaptações para o uso desta ferramenta também foi bastante trabalhosa devido a as características específicas do formalismo SAN.
Contribuição Este trabalho contribui para a comunidade acadêmica no sentido de fornecer uma ferramenta que implemente uma simulação visual com o uso de algoritmos para o cálculo de estados sucessores e predecessores.
A utilização desta ferramenta por os acadêmicos proporcionará para os leigos uma melhor aprendizagem do formalismo SAN e para os usuários mais avançados uma possibilidade de simulação de sistemas com recursos da SAN, tais como:
Uso de taxas funcionais, eventos sincronizados e simulação para trás (backward) e para frente (forward) (para visão geral do comportamento do modelo).
Trabalhos Futuros Dentro de a especificidade deste trabalho, o desenvolvimento de algoritmo para obtenção de es-tados sucessores/ predecessores e a simulação visual de modelos SAN, foi possível identificar alguns trabalhos futuros.
A seguir são descritos, sumariamente, estes trabalhos:
Software para conversão de modelos SAN para modelos baseados em Redes de Petri, que permite modelar sistemas paralelos, concorrentes, assíncronos e não-determinísticos.
Este software deverá permitir a simulação visual de modelos desenvolvidos em SAN e convertidos para redes de Petri;
Integrar na ferramenta o conceito de simulação por meio de modelos matemáticos de maneira que seja possível exercitar o modelo numericamente, inserindo entradas e avaliando o comportamento do sistema modelado;
Implementar o conceito Model-- Checking para verificação de modelos onde se possa verificar de maneira automática a validade e propriedades acerca de o comportamento de sistemas reativos· Desenvolver pacote de software que realize a conversão de modelos SAN simulados na ferramenta VisualSAN para modelos representados em MDD.
