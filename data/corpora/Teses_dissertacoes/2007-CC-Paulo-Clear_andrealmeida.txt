Esse trabalho apresenta método para a construção de SAN, a partir de informações extraídas de diagramas UML concebidos sob a abordagem do Processo Unificado.
Em ele foi formalizado umframework para a transcrição de diagramas de estado UML, utilizados para a descrição comportamental de um sistema, para uma estrutura equivalente em SAN.
Essa SAN é utilizada como um modelo de uso do sistema, de onde é possível a extração de casos de teste de software, conforme verificado em estudo anteriores.
Foi proposta a geração dos modelos sob duas óticas:
A primeira focada nas funcionalidades disponibilizadas aos usuários do sistema, e a segunda analisando o sistema como um todo.
Para essa última, foi especificado um método de simplificação da SAN, viabilizando assim a sua análise na ferramenta PEPS2003.
Baseado no framework descrito, foi implementado um protótipo para a construção automática de SAN, a partir de arquivos gerados por o Rational Rose, arquivos esses contendo informações sobre os diagramas UML utilizados na descrição do sistema.
O trabalho também descreve um estudo de caso, onde são aplicadas as técnicas descritas.
Palavras-chave: Redes de Autômatos Estocásticos;
Soluções Numéricas; Simulação Exata.
Em esse capítulo introdutório é apresentado, em linhas gerais, um resumo sobre o contexto onde se insere o produto dessa pesquisa, o objetivo almejado com esse trabalho e a estrutura utilizada na sua construção.
Com o aumento do tamanho e da complexidade dos sistemas de software, técnicas de modelagem relacionadas à abstração e a decomposição do sistema têm se mostrado muito importantes.
Essas técnicas possibilitam uma visão antecipada do software a ser desenvolvido, permitindo assim uma análise e avaliação prévias, antes mesmo desse modelo ser implementado.
Devido a isso, o emprego de modelos é sugerido em metodologias que rejam o processo de desenvolvimento de um sistema de software, visando a organização das atividades para obtenção de alta qualidade e baixo custo.
Em esse contexto, a UML (Unified Modeling Language) é a linguagem-padrão utilizada para a elaboração da estrutura de projetos de software, sendo adequada para a modelagem de sistemas De entre as metodologias empregadas no desenvolvimento de sistemas de software, destaca- se o Processo Unificado.
Esse processo utiliza iterações para evitar o impacto de mudanças no projeto, auxiliando assim o gerenciamento de mudanças, e que concentrem esforços nos pontos críticos do sistema, o mais cedo possível.
Uma das etapas que compõem o Processo Unificado é a fase de testes.
Segundo, a definição dos casos de teste demanda uma importante etapa de todo o processo de desenvolvimento do software.
O aumento da eficiência na obtenção desses casos de teste e o alcance da cobertura dos mesmos possibilitam o aumento na qualidade e produtividade, reduzindo assim o custo e o tempo de desenvolvimento.
Sendo assim, a utilização de técnicas que, agregadas ao processo de desenvolvimento, auxiliem na geração de casos de teste de forma automática, são de grande valia e têm sido alvo de várias pesquisas, conforme será visto no decorrer desse trabalho.
De entre as técnicas pesquisadas, algumas utilizam métodos estatísticos para a análise e como base para a construção de casos de teste.
Em esse contexto, Walton e Poore (em) e Whittaker (em) descrevem em seus estudos a utilização de Cadeias de Markov (MC) na geração de casos de teste de software.
Limitações referentes ao espaço total de estados gerados, podendo não oferecer uma precisão necessária para a descrição de sistemas complexos, torna desvantajosa a utilização de Cadeias de Markov.
As Redes de Autômatos Estocásticos (SAN) introduzem um formalismo baseado em MC com grande poder de resolução, além de apresentar mecanismos de suporte à modelagem de sincronismo e paralelismo.
A grande diferença e principal vantagem de SAN em relação a MC é a modularização, propiciando uma forma eficiente de armazenamento dos dados, mantendo as características de modelagem das MC, com a vantagem de amenizar problemas como o da explosão do espaço de estados.
Em esse contexto, pesquisas foram efetuadas com o intuito de integrar a análise viabilizada com SAN sobre as técnicas de modelagem de software e geração de casos de teste.
Em seu estudo, Farina relatou a viabilidade da utilização de SAN na representação de modelos de uso, tendo como alvo a geração de testes de software.
Em, Bertolini destacou as vantagens da utilização de casos de teste gerados a partir de modelos SAN, principalmente no que se refere ao ganho obtido na análise de cobertura dos testes gerados.
Ainda, Neuwald concentrou esforços na consolidação de um método para construção de SAN a partir de modelos UML.
O presente trabalho tem por objetivo propor a integração do formalismo SAN ao Processo Unificado, visando assim o auxílio da geração automática de casos de teste de software, tomando como base os diagramas e outros artefatos disponibilizados durante a aplicação do referido processo.
De entre os objetivos alcançados com a presente pesquisa, podemos destacar:
A consolidação de um framework para a transcrição de diagramas de estados UML para uma estrutura equivalente em SAN, diagramas esses construídos através da metodologia do Processo Unificado;
A construção de um protótipo para a elaboração automática de SAN, a partir de informações extraídas dos modelos gerados no Processo Unificado.
Essas informações foram extraídas de arquivos XML gerados a partir de a modelagem do sistema, modelagem essa efetuada no Rational Rose.
A formalização das possíveis análises disponibilizadas através da aplicação da técnica descrita, bem como um método de simplificação de SAN que agiliza à análise do modelo, mantendo as informações necessárias para construção de casos de teste.
Uma demonstração do método proposto através da elaboração de um estudo de caso, com o qual procurou- se evidenciar os detalhes de especificação necessários, a tradução dos modelos especificados e uma eventual simplificação dos modelos SAN.
Durante o trabalho serão salientadas as limitações não amparadas na presente pesquisa, tais como:
Os níveis dos testes gerados por o método apresentado, sugerindo a possibilidade de agregação de outros diagramas UML para a construção de casos de testes;
As limitações impostas por o Rational Rose ao não disponibilizar alguns elementos dos diagramas de estados;
A necessidade de inclusão de mecanismos para o tratamento de eventuais condições de guarda existentes em transições dos diagramas de estados;
E a necessidade da interação manual com o framework de geração de casos de teste.
Algumas possíveis soluções para essas são propostas como trabalhos futuros.
Esse trabalho é dividido em sete capítulos.
O Capítulo 2 retoma o referencial teórico com os conceitos necessários para a compreensão do restante do trabalho.
Em o Capítulo 3 é apresentado o estado da arte sobre teste de software, formas de geração e métodos empregados na sua construção.
O método proposto para a construção de SAN, a partir de informações disponibilizadas por a metodologia do Processo Unificado, é descrito no Capítulo 4.
O Capítulo 5 descreve os detalhes do protótipo proposto para esse trabalho, utilizado para construir SAN, seguindo o método proposto.
Um estudo de caso é apresentado no capítulo 6 como um exemplo de aplicação do método proposto, sendo ainda discutidos os resultados obtidos.
Por fim, as conclusões feitas nesses estudo, bem como algumas sugestões para incrementar o trabalho feito, são expostas no capítulo 7.
Esse capítulo retoma o referencial teórico necessário para a compreensão do restante do trabalho, bem como as definições necessárias para a compor a base para as definições que são propostas nesse trabalho.
Segundo, o Processo Unificado de Desenvolvimento de Software (UP) é o conjunto de atividades necessárias para a elaboração de uma sistema de software a partir de requisitos do usuário.
O sistema é construído a partir de componentes de software interconectados via interfaces muito bem definidas.
O processo unificado utiliza a UML no preparo dos artefatos do sistema.
Os aspectos que distinguem o processo unificado são capturados em três conceitos chave:
Direcionado a casos de uso;
Centrado na arquitetura;
Iterativo e incremental.
Cada um desses princípios será abordado em detalhes no decorrer de essa seção.
Um sistema de software é concebido com o intuito de atender ao usuário, sendo esse uma pessoa ou alguma entidade (outro sistema, por exemplo) que interage com o sistema em questão.
Um caso de uso é uma descrição de um comportamento do sistema que pode retornar um determinado valor ao usuário.
Casos de uso capturam requisitos funcionais, e a junção desses resulta no modelo de casos de uso, que descreve a funcionalidade completa do sistema.
Os casos de uso direcionam o processo de desenvolvimento, já que baseados no modelo de casos de uso, os analistas criam uma série de modelos para o projeto e a implementação do sistema.
Os responsáveis por os testes realizam seu trabalho com o propósito de garantir que os componentes do modelo de implementação cumpram corretamente os objetivos estabelecidos nos casos de uso.
Desta forma, os casos de uso não somente iniciam o processo de desenvolvimento, mas também mantém a integridade com as demais fases do processo.
Os casos de uso são especificados, projetados e servem de base para a construção dos casos de teste.
O conceito de arquitetura de software incorpora os aspectos estáticos e dinâmicos mais importantes do sistema.
A arquitetura é influenciada por muitos fatores, tais como a plataforma de software sobre a qual o sistema vai rodar (sistema operacional, sistema gerenciador de banco de dados, protocolos para comunicação em rede, etc), blocos de construção reutilizáveis (por exemplo, um framework para construção de interface gráfica com o usuário), considerações sobre distribuição e requisitos não funcionais (performance, confiabilidade, etc).
Ela representa uma visão do projeto como um todo, em a qual as características mais importantes são colocadas em destaque.
Define- se como produto os artefatos de desenvolvimento, tais como modelos, códigos, documentação e planos de trabalho.
Um produto possui uma função e uma forma, e nenhum desses elementos sozinho é suficiente.
Em esse caso, a função corresponde aos casos de uso e a forma à arquitetura.
Os casos de uso devem, quando construídos, adequar- se à arquitetura.
Por outro lado, a arquitetura deve fornecer espaço para a construção de todos os casos de uso necessários.
O desenvolvimento de um software é uma tarefa que pode se estender por meses.
É conveniente dividir o trabalho em pedaços menores ou miniprojetos.
Cada miniprojeto é uma iteração (passos num fluxo de trabalho) que resulta num incremento (relacionado ao crescimento do software).
Cada iteração envolve um ciclo completo de desenvolvimento, que correspondem a uma versão executável de um produto e resultam num incremento no software.
Um incremento não é necessariamente a adição do código executável correspondente aos casos de uso que pertencem à iteração em andamento.
Especialmente nas primeiras fases do ciclo de desenvolvimento, os desenvolvedores podem substituir um projeto superficial por um mais detalhado ou sofisticado.
Em fases avançadas os incrementos são tipicamente aditivos.
Em cada iteração, os desenvolvedores identificam e especificam os casos de uso relevantes, criam um projeto utilizando a arquitetura escolhida como guia, implementam o projeto em componentes e verificam se esses componentes satisfazem os casos de uso.
Se uma iteração atinge seus objetivos, o desenvolvimento prossegue com a próxima iteração, caso contrário, os desenvolvedores devem rever suas decisões e tentar uma nova abordagem.
Foi definido em apud que um modelo iterativo de desenvolvimento de software pode ser representado por uma escada do tipo espiral, onde cada ciclo corresponde a uma iteração e cada degrau pode ser interpretado como um incremento.
Essa representação é apresentada na Figura 2.2 (adaptada de).
Os três conceitos apresentados são igualmente importantes, e a remoção de um de eles poderia reduzir o valor do processo unificado.
O processo unificado consiste da repetição de uma série de ciclos durante a vida de um sistema, como mostrado na Figura 2.3.
Cada ciclo é concluído com uma versão do produto pronta para distribuição.
Essa versão é um conjunto relativamente completo e consistente de artefatos, possivelmente incluindo manuais e um módulo executável do sistema, que podem ser distribuídos para usuários internos ou externos.
Cada ciclo consiste de quatro fases:
Concepção, elaboração, construção e transição.
Cada fase é também subdividida em iterações, como discutido anteriormente.
A Figura 2.4 mostra um ciclo, descrevendo ainda suas fases e iterações.
O Produto Cada ciclo resulta na entrega de uma nova versão do sistema, e cada entrega é um produto pronto para a utilização.
O produto final inclui artefatos de interesse do usuário (tais como manuais e código fonte incorporado em componentes que podem ser compilados e executados), artefatos que interessem a pessoas que irão trabalhar no produto (requisitos, casos de uso, especificações não funcionais e casos de teste), incluindo também modelos da arquitetura.
De essa forma, os elementos mencionados permitem especificar, projetar, implementar, testar e utilizar o sistema.
Mesmo que componentes executáveis sejam os artefatos mais importantes do ponto de vista dos usuários, sozinhos eles não são suficientes.
Isso é devido a a evolução de sistemas operacionais, sistemas de bancos de dados e máquinas.
Ainda, os próprios requisitos podem ser alterados à medida que compreendermos melhor a missão do sistema.
Para executar um novo ciclo eficientemente, os desenvolvedores precisam de todas as representações do produto:
Um modelo de casos de uso, contendo todos dos casos de uso e seus relacionamentos com os usuários.
Um modelo de análise, que tem dois propósitos:
Refinar os casos de uso em mais detalhes e fazer uma alocação inicial do comportamento do sistema a um conjunto de objetos.
Um modelo de projeto que define a estrutura estática do sistema em termos de subsistemas, classes e interfaces, e a realização dos casos de uso como sendo colaborações entre subsistemas, classes e interfaces.
Um modelo de implantação que define os nós físicos dos computadores e o mapeamento entre os componentes e esses nós.
Um modelo de implementação, incluindo componentes (código fonte) e o mapeamento entre classes e componentes.
Um modelo de teste, o qual descreve os casos de teste que serão usados para verificar os casos de uso.
Uma representação da arquitetura.
O sistema pode ter também um modelo de domínio ou um modelo de negócios que descreva o contexto em o qual ele está inserido.
Os modelos do processo unificado e suas relações com o modelo de casos de uso, estão representados na Figura 2.5.
Todos esses modelos estão relacionados e juntos representam o sistema como um todo.
Elementos num modelo têm uma ligação com elementos de outro modelo.
Por exemplo, um caso de uso pode estar relacionado à sua realização no modelo de projeto e a um caso de teste no modelo de teste.
Essas ligações entre os elementos definem um trace, o que facilita a compreensão e a modificação.
Fases num Ciclo.
Um ciclo está dividido em quatro fases, cada qual podendo ser subdividida em iterações e conseq üentes incrementos, como mostrado na Figura 2.6.
O final de uma fase é marcado por um ponto de verificação (milestone), onde cada um define a disponibilidade de um conjunto de artefatos que formalizam o sistema, tais como modelos e outros documentos.
Os pontos de verificação servem a diversos propósitos, de entre eles:
Como base para tomada de decisão, monitoração do progresso do trabalho, a observação do tempo e esforço gastos em cada fase.
A Figura 2.6 lista na coluna à esquerda os workflows que devem ser realizados em cada fase (requisitos, análise e projeto, implementação e testes).
As curvas representam uma aproximação do esforço despendido com os workflows em cada fase.
A seguir é feita uma breve descrição sobre cada uma das fases:
Concepção: Durante essa fase são definidos os objetivos do sistema, e como eles contemplam as necessidades do usuário.
É definida também uma possível arquitetura para esse sistema.
Ainda é efetuado um planejamento e mensurado um custo para o desenvolvimento do produto.
Um modelo de casos de uso simplificado, que contenha os casos de uso mais críticos, podem ajudar na definição dos objetivos do sistema.
Em esta fase a arquitetura é experimental, tipicamente apenas um esboço contendo os subsistemas fundamentais.
Os riscos mais importantes são identificados e priorizados nessa fase.
Elaboração: Aqui, a maioria dos casos de uso do produto são especificadas em detalhes e a arquitetura do sistema é projetada.
A arquitetura é representada considerando todos os modelos do sistema.
Durante esta fase, os casos de uso mais críticos são realizados.
Em o final da fase de elaboração, o gerente do projeto têm condições de planejar as atividades e estimar os recursos necessários para a conclusão do projeto.
Em esse ponto, a arquitetura e os planos devem se mostrar estáveis o suficiente e os riscos sob controle, visando o comprometimento com o desenvolvimento do trabalho como um todo.
Construção: Durante essa fase o produto é efetivamente construído.
Apesar de a possível estabilidade da arquitetura do sistema, os desenvolvedores podem descobrir maneiras melhores de estruturar- lo, podendo ainda sugerir pequenas mudanças.
A o final desta fase, o produto deve conter todos os casos de uso previstos para essa versão.
Entretanto, é possível que ele não esteja totalmente livre de defeitos, os quais podem ser detectados e corrigidos durante a fase de transição.
Transição: A fase de transição cobre o período onde uma versão produto é disponibilizado aos usuários.
Essa versão é utilizada por um pequeno grupo de usuários experientes que relatam defeitos e deficiências.
Os desenvolvedores efetuam as correções e incorporam algumas das melhorias sugeridas.
Essa fase envolve atividades como treinamento de clientes, fornecimento de assistência on-line e correção de defeitos encontrados depois da distribuição.
A equipe de manutenção freqüentemente divide os defeitos em duas categorias:
Testes de software são amplamente utilizados e aceitos para a validação e aceitação de um sistema de software, e podem ser considerados como uma revisão completa da especificação, do projeto e da implementação desse sistema.
Inicialmente, os casos de teste devem sempre estar centrados nos requisitos e na especificação e não baseado no código, o que significa que os testes devem sempre visar a conformidade do produto final de acordo com os documentos de requisitos ou especificação.
Caso de teste é um conjunto de condições sobre as quais será determinado se um requisito de uma aplicação é parcialmente ou totalmente satisfeito.
Como veremos no próximo capítulo, diversos autores sustentam em suas pesquisas a utilização da UML para a elaboração de casos de teste, uma vez que essa linguagem é utilizada para especificar e modelar adequadamente um sistema computacional de uma forma gráfica e textual.
Existem várias maneiras de efetuar um teste de software.
Há técnicas que foram bastante utilizadas em sistemas desenvolvidos em linguagens estruturadas que ainda hoje tem grande valia para os sistemas orientados à objeto.
Apesar de os paradigmas de desenvolvimento serem completamente diferentes, o objetivo principal destas técnicas continua a ser o mesmo:
Encontrar falhas no software.
Os métodos mais conhecidos são a caixa-branca e a caixa-preta.
Esses métodos se complementam e devem ser aplicados em conjunto a fim de garantir um teste de boa qualidade.
A seguir estão descritas essas duas estratégias.
Caixa-Branca Em essa estratégia a estrutura interna do programa é examinada, produzindo testes a partir de o estudo da lógica do programa.
Isso é feito através da análise do código fonte e da elaboração de casos de teste que cubram todos os caminhos de fluxo possíveis do programa, permitindo assim que todo o software seja testado.
Caixa-Preta Essa categoria de teste de software encara o sistema a ser testado como uma função que mapeia um conjunto de valores de entrada num conjunto de valores de saída, sem se preocupar com a forma como esse mapeamento foi implementado.
Testes caixa-preta baseiam- se exclusivamente na especificação de requisitos para determinar que tipo de saídas são esperadas para um determinado conjunto de entradas.
As diferentes categorias de teste de software possibilitam a detecção de falhas no sistema sob diferentes perspectivas.
Em determinadas situações, devido a a existência de poucos cenários ou à baixa criticidade do sistema, certas categorias de teste podem ser planejadas em conjunto.
A seguir são descritas as categorias mais utilizadas:
Teste de Unidade:
Os testes de unidade (ou testes unitários) têm por objetivo testar pequenas partes ou unidades do sistema, tais como métodos ou pequenos trechos de código.
Teste de Componente:
O universo alvo desse tipo de teste seria um pouco maior que o teste unitário, testando o componente como um todo, mas ainda não considerando a iteração com as outras partes do sistema.
Teste de Integração:
São os testes que buscam falhas provenientes da integração dos componentes do sistema, geralmente relacionadas ao envio e recebimento de dados.
Teste de Sistema:
Em esse tipo de teste a busca de falhas é feita através da utilização do sistema, tal como seria feita por o usuário final.
Teste de Aceitação:
Geralmente são realizados por um restrito grupo de usuários finais do sistema, através de simulação de operações de rotina do sistema, buscando verificar se o comportamento do mesmo está de acordo com a especificação.
As técnicas de análise de cobertura de código está entre as primeiras técnicas utilizadas para sistematizar os testes de software.
Esse tema foi tratado inicialmente por Miller e Maloney.
A partir de então, diferentes autores iniciaram suas pesquisas, onde surgiram variações para técnicas de análise de cobertura, algumas sendo mesclas de diferentes abordagens.
As principais técnicas desenvolvidas foram as seguintes:
Statement coverage:
Em essa verificação, é avaliado se cada sentença de execução é encontrada.
A vantagem dessa abordagem é que esse pode ser aplicada diretamente ao código do objeto, não sendo necessário o processamento do código fonte.
Por ser insensível a torna- se desvantajoso.
Essa técnica também é conhecida line coverage, segment coverage, ou basic block coverage.
Decision coverage:
Em essa abordagem são verificadas se as expressões booleanas testadas conhecida como branch coverage, basis path coverage ou decision-decision- path testing apud, essa técnica possui a vantagem de tratar as estruturas de controle não amparadas na statement coverage.
Sua desvantagem está em ignorar trechos necessitem testada. (
Condition coverage):
Essa técnica trata cada sub-expressão booleana separadamente, avaliando- as independentemente uma das outras.
A sua desvantagem está em não poder assegurar que todos os caminhos possíveis, oriundos de sentenças condicionais.
Para melhor ilustrar essa abordagem, é apresentada a Figura 2.7 (extraída e adaptada de).
Suponhamos que o seguinte trecho de código seja testado com os seguintes casos de teste, cobrindo assim os respectivos caminhos:
Apesar desses casos de teste cobrirem todos os caminhos, as seqüências acd e abe não são executadas.
Logo, esses caminhos não são testados e eventuais falhas nesses trechos não são executadas.
Path coverage:
Essa técnica avalia se cada um dos possíveis caminhos num função pode ser percorrido.
Um caminho é uma seqüência única de ramificações desde a entrada da função até a sua saída.
Em essa abordagem, também conhecida como predicate coverage, os caminhos acd e abe da Figura 2.7 são testados.
Existem outras técnicas, derivadas das descritas anteriormente.
Elas serão aqui relacionadas num caráter apenas informativo, não sendo detalhadas as suas características (maiores detalhes em):
Function coverage, call coverage, linear code sequence and jump coverage, data flow coverage, object code branch coverage, loop coverage, race coverage, relational operator coverage, weak mutation coverage, table coverage, etc..
Redes de Autômatos Estocásticos (SAN) é um formalismo, baseado em Cadeias de Markov, para modelagem de sistemas.
Foi proposto na tese de doutorado de Brigitte Plateau, em 1984.
A idéia principal do formalismo SAN é modelar um sistema em vários subsistemas chamados de autômatos, que podem ou não interagir entre si.
SAN é um formalismo para modelagem de sistemas complexos e com grande espaço de estados.
A grande diferença e principal vantagem de SAN em relação a MC é a modularização, pois propicia uma forma eficiente de armazenamento dos dados do sistema, mantendo as características de modelagem das MC, com a vantagem de amenizar problemas como o da explosão do espaço de estados.
As próximas subseções apresentam alguns conceitos básicos necessários para a elucidação do formalismo SAN.
Um autômato é um modelo matemático de um sistema, com entradas e saídas discretas.
O sistema pode estar em qualquer um de entre um número finito de estados ou configurações internas.
Esses estados sintetizam as informações relativas às entradas anteriores e informam ainda os possíveis comportamentos do sistema diante de as entradas seguintes.
A denominação de estocásticos atribuída a esses autômatos é atribuído ao fato do tempo ser tratado como uma variável aleatória, e essa obedece uma distribuição exponencial na escala de tempo contínua, ou geométrica no caso de escala de tempo discreta.
Os estados de um modelo SAN podem ser observados através de dois aspectos:
Local (referese ao estado individual de cada autômato pertencente ao modelo) e global (considera a combinação dos estados locais de todos os autômatos do modelo).
Intuitivamente, a mudança do estado local de qualquer autômato do modelo altera o estado global do sistema.
A Figura 2.8 exemplifica uma SAN com seus estados locais, mostrando também os estados globais equivalentes.
A SAN representada na Figura 2.8 possui um autômato de 2 estados locais e outro de 3 estados locais.
O número de estados globais equivalentes a este exemplo é o número de estados igual ao produtório do número de estados locais de todos os autômatos da SAN.
Para o nosso exemplo, tem- se 2 × 3 $= 6 estados globais.
O estado global 01 corresponde a situação em que o autômato A1 encontra- se no estado 0 e o autômato A2 no estado 1.
Essa analogia é adotada para os demais estados globais equivalentes.
Vale ressaltar que o autômato equivalente da Figura 2.8 tem fim meramente elucidatório, uma vez que a solução dessa SAN pode ser obtida independentemente para cada um dos seus subsistemas, pois só há transições locais, e nenhuma interação entre os dois autômatos.
Evento é a entidade do modelo responsável por a ocorrência de uma transição, mudando assim o estado global do modelo.
Um ou mais eventos podem estar associados a uma transição e esta é disparada através da ocorrência de qualquer um dos eventos a ela associada.
Em o formalismo SAN podem ser modelados dois tipos de eventos:
Locais (são aqueles que modificam o estado local de um único autômato sem interferir no estado local dos demais autômatos do modelo) e sincronizantes (eventos que disparam transições em mais de um autômato, modificando assim os estados locais dos autômatos envolvidos).
Como visto anteriormente, todo evento num modelo SAN deve ter associado a si uma taxa de ocorrência e uma probabilidade de ocorrência1, mas essa última é abstraída caso sua taxa seja igual a 1.
Tanto a taxa de ocorrência como a probabilidade de ocorrência podem ser definidas como valores constantes ou valores funcionais.
Quando as taxas e probabilidades são definidas como valores funcionais, essas são ditas taxas funcionais e probabilidades funcionais.
Em esses casos, os valores assumidos por estas taxas e probabilidades dependem dos estados locais dos demais autômatos do modelo.
As taxas e probabilidades funcionais proporcionam uma segunda possibilidade de interação entre autômatos nos modelos SAN (a outra possibilidade é a utilização de eventos sincronizantes2, como visto anteriormente).
As funções associadas com as taxas e probabilidades permitem atribuir a um mesmo evento diferentes valores conforme o estado global do sistema.
O autômato A da Figura 2.10 apresenta uma transição local funcional, que depende do estado interno do autômato A. Essa função f3 é dada por:
Isto significa que a transição do estado 0 para o estado 1 ocorre com uma taxa de ocorrência* 1, caso o autômato A esteja no estado 0, ocorre com uma taxa* 2, caso o autômato A esteja no estado 2, e não ocorre caso o autômato A esteja no estado 1.
A Figura 2.10 também apresenta mostra o autômato equivalente para essa SAN.
Devido a a representação em SAN ser de forma modular e o autômato global (equivalente à MC) ser composto por a combinação de todos os autômatos do modelo, se faz necessária a especificação de uma função que defina quais são os estados atingíveis deste autômato global que representam a SAN.
A definição de quais destes estados podem ser atingidos ou alcançados em SAN é dada por a função de atingibilidade.
Ela é definida usando as mesmas regras adotadas para a definição de taxas e probabilidades funcionais.
Vamos tomar como exemplo a SAN descrita na Figura 2.11, que apresenta 2 autômatos, 4 eventos locais, um evento sincronizante e uma transição funcional.
Ela possui seus eventos e taxas de probabilidade descritos na tabela 2.2.
Assumindo que os estados 0 de A e 0 de A como atingíveis) podemos supor que, por exemplo, o autômato A não pode se encontrar no estado 1 se o autômato A estiver no estado 1, e vice-versa.
Para tanto, deve- se definir a seguinte função de atingibilidade:
Através da função de atingibilidade podemos construir o autômato equivalente), onde é possível visualizar os estados inatingíveis da SAN.
De essa forma, os estados globais atingíveis dessa SAN seriam:
00, 01, 02, 10 e 12, visto que o estado 11 nunca é atingido, partindo de qualquer outro estado.
A proposta das funções de integração é obter a probabilidade do modelo encontrar- se num determinado estado da SAN.
Essas funções podem ser definidas em qualquer modelo SAN.
Com isso, pode- se compor funções de integração que levem em conta a probabilidade do modelo se encontrar num conjunto de estados, podendo assim obter índices de desempenho e confiabilidade do modelo.
A avaliação dessas funções é realizada sobre o vetor de probabilidades que contém a probabilidade do modelo se encontrar em cada um de seus possíveis estados.
Por exemplo: Se considerando a SAN apresentada na Figura 2.11, a função de integração u que avaliaria a probabilidade do autômato A estar no estado 0, seria dada da seguinte forma:
Via de regra, todas as funções são modeladas em SAN da mesma forma.
O que as diferenciam é como elas são empregadas no modelo.
O próximo capítulo apresenta uma revisão sobre o estado da arte da geração de casos de teste, suas aplicações, eventuais limitações, destacando as informações que sustentam o presente trabalho, buscando assim evidenciar a aplicabilidade dessa pesquisa.
Esse capítulo apresenta uma revisão sobre alguns estudos relacionados a geração de casos de testes.
Com isso, busca- se destacar as aplicações das técnicas estudadas, as aplicações visadas por essas, salientar as eventuais limitações que cada abordagem pode possuir.
Como isso, almeja- se destacar as detalhes que sustentem a presente pesquisa, buscando dessa forma evidenciar a aplicabilidade do presente trabalho.
Vários estudos já foram efetuados sobre geração de casos de teste de software, enfatizando a sua aplicabilidade, analisando ainda a sua eficácia em comparação a outras técnicas convencionais.
A seguir são descritas algumas metodologias para a geração de casos de teste.
Diferentes abordagens sobre a fonte para a geração de casos de teste, bem como as técnicas para a geração desses teste, são alvo de vários estudos.
Em essa seção são apresentados algumas dessas pesquisas, salientando alguns detalhes e vantagens de cada abordagem.
Segundo a tese de mestrado de Zhang, testes randômicos são baseados no domínio de entrada e geralmente aplicado sobre o método da caixa preta.
Os testes são randomicamente selecionados de todo o domínio de entrada, não considerando qualquer informação sobre a estrutura ou especificação do programa.
Em esse trabalho foi citado o estudo de Girard e Rault (apud), os quais propuseram a utilização de testes randômicos como um valioso esquema para a geração de casos de teste de software, especialmente na etapa final do testes de software.
Testes randômicos provém uma maneira simples de gerar casos de teste sobre softwares que não apresentam uma análise profunda sobre a sua confiabilidade.
Com a esse tipo de teste é gerado um grande número de casos de teste, provendo assim uma maneira automática de geração da casos de teste.
Uma desvantagem do teste randômico é destacada nesse trabalho:
Como não utiliza qualquer informação sobre a especificação do software, somente algumas entradas são selecionadas, não sendo possível garantir se efetividade dessa seleção.
A emprego de MC para modelar a utilização de um software, e daí extrair informações para gerar casos de teste, foi sugerido (não inicialmente) por Whittaker e Poore em.
O estudo afirma que num teste estatístico, os eventos de interesse são seqüências de estímulos que representam uma execução do software.
Uma descrição estatística das seqüências é obtidas por a definição de variáveis randômicas que descrevem o perfil do conjunto total de seqüências usadas na verificação do software.
Ainda, um modelo estocástico é definido para guiar a geração de casos de teste e calcular as estatísticas de uso do software.
Em o referido trabalho são propostas duas fases de construção da MC.
Em a fase estrutural os estados e os arcos são definidos, e na fase estatística as probabilidades das transições são especificadas.
Em esse trabalho também foi referenciada a tese de mestrado de Sexton (apud), onde é mencionada a necessidade da seleção randômica dos casos de teste para estar de acordo com a distribuição de uso.
Em sua pesquisa, Avritzer descreve uma nova técnica de teste denominada Deterministic Markov State Testing, relatando também a sua aplicação.
Essa é uma técnica para a geração e execução de casos de teste para um software de telecomunicação, baseado no seu perfil operacional, onde esse é usado para construir uma cadeia de Markov que representa o comportamento desse software.
De entre as vantagens apresentadas por essa método, estão a provisão de informações precisas sobre estados do software para a análise em testes de carga, e por o gerenciamento simples de execução distribuída de casos de teste.
Em outra pesquisa, Avritzer apresenta três algoritmos para a geração automática de casos de teste.
Apesar de essas técnicas terem sido desenvolvidas para o teste de software de telecomunicação, elas podem ser usadas em qualquer software que puder ser modelado que cadeias de Markov.
Whittaker e Thomason descrevem em como as falhas de software podem ser avaliadas analiticamente através de MC.
Whittaker descreve em seu trabalho um método para a seleção de casos de teste que possibilita uma alternativa de formalização de teste de software.
Isso seria feito através da criação de modelos estocásticos, por parte de os testadores, que descrevessem o comportamento do software em alternativa à geração de casos de teste tradicional.
Em esse artigo é afirmado que apesar de um modelo escolhido poder possuir um número qualquer de processos estocásticos, MC foram usadas pois mostram ser confiáveis e possibilitam um feedback analítico.
O trabalho não define as métricas utilizadas para extração das probabilidades de ocorrência dos eventos, sugerindo que isso pode ser extraído de uma análise de comportamento dos usuários.
Ainda, o exemplo utilizado segue um processo de construção informal, baseado em ações do usuário e meramente ilustrativo.
Em os testes baseados em modelos, esses provém a informação primária para o desenvolvimento de test suites, checando ainda a implementação do sistema.
Gross relata em seu relatório o encaixe perfeito da utilização dos diagramas UML para a geração de casos de teste.
Em esse trabalho são apresentadas, superficialmente, as definições dos diagramas UML e como cada um de eles pode auxiliar na geração de casos de teste.
A o final é discutido os perfis de teste que a UML proporciona, podendo ser regido por aspectos estruturais ou comportamentais.
Em são descritos métodos para geração de casos de teste, baseados na análise comportamental de casos de uso, especificados em três notações diferentes oferecida por a UML.
Uma breve descrição sobre esses diagramas, bem como a sua pertinência para a geração de casos de teste, é feita a seguir:
Diagramas de Atividade:
Interpretam os casos de uso como processos ramificados e são recomendados por alguns autores para a formalização de casos de uso.
Porém esses diagramas apresentam duas desvantagens:
Eles modelam apenas o fluxo de controle do programa e não suportam a distinção entre os comportamentos normais e anormais que a análise dos casos de uso beneficia.
Diagramas de Interação:
Esses diagramas1 podem ser usados para formalizar separadamente os cenários contidos nos casos de uso.
Sendo que um caso de uso é uma coleção hierárquica de cenários, esses devem ser formalizados separadamente em diagramas de interação e então serem agrupados novamente em único diagrama de estados.
Diagramas de Estado:
Especificam o comportamento do sistema em reação aos eventos ocasionados por os atores.
Em contraste com os diagramas de interação, diagramas de estado visualizam múltiplos cenários, como no caso de cenários hierárquicos descritos por os casos de uso.
Como mencionado, os diagramas citados são baseados nas especificações realizadas nos casos de uso.
A seguir será descrita a estrutura de especificação de casos de uso utilizada como foco desse trabalho.
Existem estruturas para a especificação dos casos de uso que auxiliam a construção dos diagramas UML que auxiliam na análise comportamental do sistema.
A estrutura do caso de uso citada no processo unificado é baseada no template criado por Alistair Cockburn.
A Tabela 3.1 descreve essa estrutura A granularidade da especificação do cenário define futuramente a granularidade do teste, ou seja, um passo do cenário que descreve um estímulo será transformado numa entrada atômica de teste, e um passo do cenário descrevendo uma resposta representará uma resposta atômica observável.
Partindo da estrutura especificada anteriormente, é possível construir um diagrama de estados que modele o comportamento do caso de uso.
Em foram descritos métodos para construção de diagramas de estado a partir de a estrutura de especificação de casos de uso proposta por Cockburn, que mapeiam o comportamento do caso de uso da seguinte forma:
Cenário de Sucesso Principal:
As mensagens enviadas por o sistema serão tratadas como ações dos estados.
Cada mensagem enviada por um ator é denotada como um evento.
Cenário de Sucesso Principal Descreve como o caso de uso pode atingir a meta com a enumeração de estímulos e respostas alternadas do sistema, iniciando com o estimulo disparado por o caso de uso.
Variações Cursos alternativos da ações que mantém o caso de uso dentro de seus padrões normais.
A especificação das variações é feita através referenciando o respectivo passo do cenário de sucesso principal, sendo esse refinado com um ou mais passos alternativos.
Extensões Um cenário de resposta a uma circunstância excepcional (um dado de entrada inválido, por exemplo).
Esta especificação adota o mesmo formalismo descrito para as variações.
Casos de Uso Incluídos Lista de outros casos de uso utilizados por este (usualmente estes são referenciados por arcos nos diagramas de caso de uso).
Variações: São alternativas de execução de um passo no caso de uso, modelados através de múltiplos caminhos conectando dois estados (estados intermediários podem ser necessários para modelar variações mais complexas).
Extensões: Acontece quando uma submeta (passo) falha, pois uma pré-condição não foi assegurada.
Isso é feito com a utilização de sub-estados do estado correspondente do cenário de sucesso principal.
Pré e Pós-condições Pré-condições descrevem as condições que asseguram previamente a execução do caso de uso.
Pós-condições são modeladas como restrições no ultimo estado representado no caso de uso.
Casos de usos subordinados:
UML define um mecanismo para a inclusão de um caso de uso como uma sub-função em outro caso de uso.
Os referidos trabalhos descrevem os mecanismos de extração do perfil de teste a partir de as informações contidas nos diagramas de caso de uso.
Os casos de teste são gerados a partir de uma determinada seqüência de estados de ações, levando em conta a probabilidade de ocorrência dessas ações.
Em seu trabalho, Abdurazik e Offutt apresentam um critério de teste baseado em diagramas de colaboração UML.
Segundo eles, o critério desenvolvido define testes que verificam aspectos estáticos e dinâmicos em níveis de especificação e de instância a partir de os diagramas de colaboração.
O paper também apresenta um algoritmo que auxilia o testator a rastrear os caminhos possíveis no diagrama.
Os diagramas de interação contém essencialmente a mesma informação, mas disposta de forma diferente.
Os diagramas de seqüência e de colaboração se equivalem e podem ser transcritos de um para o outro sem perda de informação.
Como visto anteriormente, a utilização de diagramas de interação para a geração de casos de teste não se mostra completa pois esses formalizam os cenários contidos nos casos de uso separadamente.
Seria apropriado reagrupar a coleção de cenários modelados por os diagramas de interação num único diagrama de estados.
Técnicas de cobertura de teste exercem um papel significante no aperfeiçoamento da qualidade dos sistemas de software.
A avaliação de cobertura de código consiste na identificação das partes do programa que não são atingidas numa ou mais execuções do programa.
Em esse sentido, a análise de cobertura de testes de software tem sido alvo de vários estudos, sendo citados alguns desses nessa seção.
Diversas ferramentas monitoramento e análise de cobertura de teste são disponibilizadas no mercado.
Gaffney demonstra em sua pesquisa que apesar de as informações fornecidas por uma ferramenta de cobertura ser útil e valiosa, elas não são suficientes em testes de fragmentos de código.
Essa afirmação baseia- se no critério de teste disponibilizado por as ferramenta, os quais podem não suportar a cobertura de determinadas nuances contidas no código do programas2.
Em sua survey, Yang apresenta um comparativo entre 17 ferramentas de teste baseadas em cobertura de teste.
Adicionalmente, essas ferramentas podem oferecer algumas outras funções, sendo três dessas utilizadas como método comparativo entre as mesmas:
A abrangência da cobertura, o critério de cobertura, e geração automática de casos de teste e customização de relatórios.
Agrawal apresentou numa técnica para encontrar um pequeno sub-conjunto de sentenças e decisões de um programa (também denominado como bloco), onde a cobertura desse sub-conjunto implique na cobertura do restante do programa.
Essa técnica é uma otimização de uma abordagem apresentada anteriormente por o autor em, onde são encontrados sub-conjuntos de nodos (blocos) de um gráfico de fluxo que satisfaçam a seguinte condição:
Um conjunto de testes que exercite todos os nodos de um sub-conjunto exercita todo os nodos do gráfico de fluxo.
Em sua otimização, Agrawal introduziu a idéia de um mega-bloco, sendo esse um conjunto de blocos básicos que contém múltiplos procedimentos, onde a cobertura de um bloco básico implica na cobertura de todos os blocos básicos similares.
Ainda é apresentada a definição de uma estrutura de dados denominada global dominator graph, onde são expostas as relações entre os mega-blocos.
Com essa estrutura, o testator precisaria apenas criar casos de teste que cobrissem os blocos básicos, implicando na cobertura do restante do programa através do mesmo conjunto de testes.
Os estudos efetuados por Agrawal serviram como base para a formalização de outras técnicas, mas todas trabalhando com a idéia de utilização de gráficos de fluxo, porém agregando novos métodos para a otimização da cobertura dos casos de teste gerados.
De entre essas técnicas, podemos citar o trabalho de Tikir e de Baudry.
Como citado anteriormente, um caso de teste exercita um determinado caminho modelado num caso de uso, não herdando e nem propagando erros.
Esse caminho (trajetória) é uma seqüência de passos (estado-transição- estado) no estado global de uma SAN.
Como numa SAN cada transição está associada a mais de um evento, porém cada evento corresponde a por o uma transição em MC.
Conforme formalizado em, um caso de teste é uma estrutura (S;
E), onde S $= S1;
S2; Sn+ 1 corresponde a um conjunto ordenado de estados globais (SAN) ou estados (MC) e E $= E1;
E2; EN corresponde a um conjunto de eventos (SAN) ou transições (MC).
Um test suite é definido como um conjunto de casos de teste.
Em esse trabalho vamos considerar T como um test suite composto por Mcasos de teste Ti, com i variando de 1 aM.
Como mencionado, uma determinada trajetória é composta por uma quantidade finita e conhecida de passos, e cada passo possui uma probabilidade de ocorrência p..
Essa probabilidade é a ocorrência de uma transição do i -- esimo estado para o i -- esimo+ 1, e é dada por:
K «i pk onde pk é a probabilidade do i -- esimo estado da solução estacionária (ou transiente) de um modelo, e?
K «i significa a possibilidade de ir para todos os k -- esimos estados sucessores do i -- esimo estado.
A probabilidade de um caso de teste é um produtório de todas as probabilidades dos passos pi do caso de teste, o qual corresponde uma trajetória T.
De essa forma, a probabilidade de um caso de teste PT é dada por:
Sendo que um test suite pode conter muitos casos de teste replicados, é necessário considerar apenas casos de teste distintos para avaliar a cobertura de um test suite.
O número de casos de teste distintos D pode ser menor ou igual ao número total de casos de teste M. Sendo assim, o percentual de cobertura C de umtest suite Ts é calculado por a soma da probabilidade de todos os casos distintos, ou seja:
A partir de um modelo podem ser gerados infinitos casos de teste, definindo assim como assintótico o cálculo de cobertura C de um test suite, uma vez que o índice de cobertura pode ser próximo mas nunca igual a 1.
A qualidade da geração dos casos de teste é verificada por o cálculo da Distância Euclidiana e do Discriminante de Kullback, efetuando assim a comparação de dois vetores:
O Vetor de Probabilidades e o Vetor de Freqüências dos Casos de Teste (vf).
O primeiro é obtido a partir de um test suite e contém apenas as probabilidades dos casos de teste distintos, portanto, sendo composto por D probabilidades e com cardinalidade dada por| v| $= D e D $= M. O vetor de freqüências também é composto por D probabilidades, porém agora são computados inclusive os casos de teste replicados do test suite.
Após a normalização, que é dada por a contagem dos casos de teste replicados sobre o total de casos de teste gerados, obtém- se o vetor de freqüência vf (i $= 1 Em o próximo capítulo será especificada a transcrição dos diagramas UML para uma estrutura equivalente descrita por o formalismo SAN.
Em esse capítulo são descritos os detalhes da transcrição dos diagramas UML que fornecem a base para a construção de uma rede de autômatos estocásticos, com a qual será possível fazer uma análise do modelo de uso, buscando a geração de casos de teste de software.
Baseado em trabalhos relacionados ao corrente estudo, pode- se afirmar que é possível compor um framework para a construção de SAN a partir de especificações de casos de uso, guiados por o template proposto por Cockburn.
Isso seria feito de maneira similar ao descrito em, porém o alvo seria a construção dos elementos de uma SAN e não de um diagrama de estados.
Quando o Analista de Requisitos conclui a atividade de detalhar um caso de uso, é possível extrair as informações necessárias para a construção da SAN que modele esse caso de uso, a partir de o template citado.
As atividades associadas ao workflow de requisitos proposto por o Processo Unificado são apresentadas na Figura 4.1, sendo destacada a atividade de descrição de casos de uso.
Sendo um dos objetivos desse trabalho a construção automática de arquivos.
San a partir de informações extraídas de artefatos produzidos de acordo com o Processo Unificado, é necessário um volume maior de informações que sustentem a construção da SAN.
Essas informações podem ser extraídas na fase de análise e projeto, conforme o workflow apresentado na Figura 4.2.
Com o estudo realizado para esse trabalho, é possível apresentar alternativas no processo de geração de casos de teste com a incorporação de SAN.
Essa alternativa é destacada na Figura 4.3, que apresenta as atividades sugeridas para um processo de desenvolvimento de software.
Os gráficos de uso são uma variação do diagrama de estados onde, de entre outras modificações, a estrutura hierárquica dos estados (estados aninhados) é substituída por uma estrutura plana, onde todos os estados possuem o mesmo nível hierárquico.
Para a obtenção do modelo de uso, a distribuição de probabilidade do uso esperado do software precisa ser determinada.
Detalhes sobre a construção dos diagramas e modelo de uso são descritos em.
De entre os diagramas que permitem a especificação comportamental dos casos de uso, optou- se por a utilização de diagramas de estado.
As razões que amparam essa decisão são:
Os diagramas de estados abrangem todos os possíveis cenários para um dado objeto e é apropriado para a transcrição direta de um modelo de uso.
De qualquer modo, o escopo resultante do modelo de uso será limitado por a classe correspondente, e ainda por o teste unitário.
Formam uma base compreensiva para a geração de código, sendo isomórfico ao programa, facilitando então a detecção de erros durante a análise do modelo dinâmico.
Ainda em combinação com a geração de código, diagramas de estados permitem a animação das transições de estado capturada durante a execução de um modelo, aproximando- se de testes do tipo caixa-branca.
Através da utilização de ferramentas específicas, diagramas de estados são a base para a automação de model checking, contanto que determinadas restrições possam ser definidas.
Portanto, o foco desse trabalho será a geração de SAN a partir de diagramas de estados da UML, buscando a geração de casos de teste de software.
Em as próximas seções é feita a especificação do framework para a transcrição de diagramas de estados UML para uma estrutura equivalente em SAN, bem como a possível análise proporcionada com a utilização de SAN na geração de casos de teste de software, viabilizando a alternativa sugerida na Figura 4.3.
Aqui serão descritos os termos e conceitos de um diagrama de estados contemplados na especificação da UML 2.
0, os elementos utilizados na sua construção, bem como suas propriedades, e para cada um de eles a estrutura equivalente em SAN, buscando assim fundamentar a transcrição de diagramas de estado para SAN, sem perda de informações necessárias para a geração de casos de teste de software.
Um diagrama de estados descreve uma máquina de estados, dando ênfase ao fluxo de controle de um estado para outro, especificando as seqüências de estados por os quais um objeto passa durante seu tempo de vida em resposta a eventos, juntamente com suas respostas a esses eventos.
São utilizados para modelar os aspectos dinâmicos de um sistema, classe ou casos de uso.
De essa forma, a modelagem de objetos reativos1, cujo comportamento é bem caracterizado por a sua resposta a eventos externamente ao seu contexto, se torna possível.
A descrição detalhada de cada um desses elementos, assim como o método de transcrição para um estrutura equivalente em SAN, será apresentada no decorrer de essa subseção.
Uma transição é um relacionamento entre dois estados2, indicando que o objeto do primeiro estado realizará certas ações e entrará no segundo estado quando um evento especificado ocorrer e as condições especificadas forem satisfeitas.
Sendo assim, uma transição é composta por um evento de ativação, uma condição de guarda e uma ação, ligando assim um estado de origem a um estado destino.
A sintaxe de uma transição é dada a seguir:
Tanto em diagramas de estado quanto em SAN, uma transição pode ter mais de um evento associado.
No entanto, podem existir situações, em diagramas de estado, onde a discriminação do evento de ativação pode ser suprimida.
Segundo a definição da UML 2.
0, podem existir três tipos de transições:
Local: Se uma transição ocorre entre estados internos de um estado composto, ela é dita local.
Externa: Sugere que a transição, caso seja disparada, tem com alvo (ou fonte) um estado externo ao estado composto, podendo o próprio estado composto ser esse alvo (autotransição).
Interna: É um caso especial onde uma transição, caso seja disparada, ocorre sem causar uma mudança de estado.
Ela pode ser modelada de forma que as transições ocorridas sejam explicitadas por um estado composto, através de transições locais.
Para modelar essas transições em SAN, partiremos do pressuposto que todas as transições internas serão modeladas como uma transição local, e que qualquer máquina de estados seja tratada como um estado composto, buscando assim atender às definições descritas.
Isso é feito da seguinte forma:
Essa condição garante a utilização de um caso de uso, como um caso de uso incluído.
Sendo assim, sempre que um caso de uso incluído fosse requerido, esse apontaria para o super-estado que o modela.
Como a ação executada por o disparo da transição não é utilizada na análise da SAN, ela é abstraída no instante de nomear a transição da SAN.
A Tabela 4.1 apresenta um resumo da notação utilizadas para descrever os tipos de transições disponibilizadas em diagramas de estados, as quais serão utilizadas nesse trabalho A seguir são descritos em detalhes os tipos de transições utilizadas na transcrição de diagramas de estados UML para SAN, bem como a transcrição propriamente dita, apresentando então a estrutura equivalente em SAN.
Transições locais As transições locais ocorrem internamente num estado composto.
Elas são tratadas como transições locais na SAN que modela esse estado composto.
Isso é ilustrado na Figura 4.4 2a definição de estado e suas variantes, são apresentados na subseção 4.2.2.
Para manter a estacionaridade do sistema, quando um estado final é atingido, essa transição é sincronizada com a transição externa que deixa esse estado composto.
Em a SAN, a transição que aponta para o estado final, na máquina de estados, aponta para o estado W (conforme descrito adiante) e em ele permanece até uma nova execução.
Transições externas As transições externas são modeladas com o auxílio de eventos sincronizantes em SAN.
Conforme será descrito nesse relatório, para efeitos de legibilidade e modularização, um estado composto sempre será modelado num autômato distinto, e toda a vez que uma transição tiver esse como alvo (ou fonte), sua modelagem em SAN será feita com o auxílio de eventos sincronizantes.
Para melhor elucidar essa idéia, um exemplo é apresentado na Figura 4.5.
Em ele é mostrado uma máquina de estados que possui um estado composto (E2).
Quando o estado E1 está apto a disparar uma transição para a E2, ativada por o evento ev0, um evento sincronizante na SAN modela essa transição.
O evento ev0 ativa a transição do estado E1 para E2 em A), simultaneamente.
Quando o autômato A (1) está em E2, a execução desse estado composto é modelado por o autômato A. Como será descrito adiante, uma transição que parte de um estado inicial não possui um evento de ativação (estado transiente).
Em SAN, a transição que parte de um estado inicial será sincronizada com o evento externo que ativa a execução do estado composto.
Em o exemplo da Figura 4.5, o evento ini) é sincronizado com o evento externo que ativa a execução damáquina de estados.
Esse evento externo não é mostrado no exemplo.
Sendo assim, a modelagem de uma transição externa para um estado composto em SAN, é feita com o sincronismo dessa transição externa com a transição que parte do estado inicial dessa estado composto.
Esse comportamento é exemplificado na Figura 4.5, através do evento ev0.
De forma similar, quando o autômato A dispara a transição do estado E22 para W, isso é feito com o auxílio de um evento sincronizante (ev3) que habilita a transição do estado E2 para E1 em A. Quando um estado composto é totalmente executado, o evento ev3 dispara a transição externa do estado E2 para E1.
A seguir são descritos em detalhes os diferentes tipos de estados disponíveis num diagrama de estados da UML, incluindo a descrição dos pseudo-estados, e o método utilizado para transcrever cada um desses numa estrutura equivalente em SAN.
Estado Simples (simple state) É a forma elementar de representação de um estado.
É aquele que não contém subestados, ou seja, não possui regiões ou sub-máquinas de estado.
A notação de um estado simples é feita por um retângulo com os cantos arredondados, podendo possuir seu nome escrito internamente ou numa aba localizada na parte superior do estado, conforme ilustrado na Figura 4.6.
Em a mesma figura, temos a representação gráfica desse estado em SAN.
Estado Inicial (initial state) Esse estado indica que o início da execução de uma região foi acionada.
Em SAN, um estado inicial será denotado como um estadoW.
Enquanto uma máquina de estados não é invocada, o autômato que modela essa máquina vai permanecer no estado W. Quando a execução dessa máquina de estados for habilitada, uma transição parte de W para o primeiro estado da máquina.
A transição que parte de um estado W possui um evento que é sincronizado com a transição externa (evento ini nesse exemplo) que habilita a execução da máquina de estados.
A Figura 4.7 não explicita esse evento externo.
Estado Final (final state) Um estado final modela o encerramento de uma máquina de estados, indicando que a execução da mesma foi completada.
Se uma máquina de estados está contida numa região, e todas as outras regiões desse mesmo estado também foram completadas (atingindo um estado final), significa que a máquina de estados foi encerrada, implicando no fim do contexto do objeto da máquina de estados.
A Figura 4.8 mostra um estado final, indicado como um círculo preenchido circunscrito.
Como pode ser observado na mesma, mais de uma transição pode ser dirigida para um estado final.
Não há a necessidade da utilização de um estado que modele um estado final em SAN.
Quando, no diagrama de estados, uma transição aponta para um estado final, o autômato que o modela possuirá um transição aponta para o estado W, tendo o seu evento sincronizado com o evento da transição externa que deixa essa máquina de estados.
Essa configuração pode ser observada na Figura 4.8.
Estado Composto (composite state) Um estado composto pode conter uma única região, contendo subestados disjuntos seqüencialmente ativos, ou ser decomposto em duas ou mais regiões ortogonais, cada uma possuindo subestados concorrentemente ativos.
Esse segundo tipo permite especificar duas ou mais máquinas de estados que são executadas em paralelo no contexto do objeto que as contém.
A Figura 4.9 mostra os possíveis arranjos de um estado composto (seqüencial (I) e composto (II)).
Em determinadas situações pode ser conveniente esconder a decomposição de um estado composto.
Esse é o caso onde um estado composto possui muitos estados aninhados, o que pode dificultar a legibilidade do diagrama.
Em esses casos é inserido um símbolo no canto inferior direito, indicando que esse é um estado composto ocultado.
Como explanado anteriormente, por motivos de legibilidade e modularização, todo o estado composto deve ser modelado num autômato distinto em SAN.
As estruturas de autômatos que modelam os estados compostos da Figura 4.9 são mostradas na Figura O autômato A modela um estado composto seqüencial.
Os eventos ini e ev2 são sincronizados com os eventos das transições que chegam e partem desse estado composto, respectivamente.
De maneira semelhante, os autômatos A e A modelam um estado composto concorrente.
De a mesma forma, os eventos ini e ev2 são sincronizados com os eventos das transições que chegam e partem desse estado composto, respectivamente, e também são sincronizados entre as diferentes regiões ortogonais desse estado.
Respeitando as definições de SAN, quando uma transição externa alcança o referido estado composto, os eventos ini das regiões ortogonais são disparados simultaneamente.
Finalmente, o estado composto só poderá habilitar uma transição externa quando todos os estados poderem disparar as transições para W. Para amparar o sincronismo necessário ao finalizar diferentes regiões ortogonais, estabelecese a seguinte condição:
A o nomearmos os eventos da SAN que apontam para W, não há necessidade de manter a coerência com os nomes dos eventos do diagrama de estados, uma vez que o evento que sincroniza o encerramento das regiões do estado composto deve ser o mesmo nome.
Como pode ser observado no exemplo anterior, os eventos que atingem os estados finais das regiões ortogonais podem possuir nomes diferentes, porém em SAN eles possuirão o mesmo nome) Sobre os estados compostos ocultados:
Como esses são utilizados para abstrair um estado composto, facilitando assim legibilidade, não apresentam nenhuma informação pertinente para a construção de uma estrutura equivalente em SAN.
Em esse caso, sugere- se a explicitação desse estado e que sua modelagem em SAN seja feita conforme descrito anteriormente.
Estado Sub--máquina (submachine state) Um estado do tipo sub-máquina contém a especificação da máquina de estados que é referenciada.
Esse estado é semanticamente equivalente a um estado composto, porém podem conter pontos de entrada e saída inseridos como alvo e fonte desse tipo de estado.
Esses pontos de entrada e saída são denotados na borda do estado sub-máquina, sendo essa desenhada como um estado normal, onde o nome do estado possui a seguinte sintaxe:
Um estado sub-máquina pode ser invocado diversas vezes, podendo cada uma dessas chamadas acessar um diferente estado da sub-máquina, sendo esse acesso efetuado através de distintos pontos de entrada.
A Figura 4.12 ilustra essa situação.
Ela modela um estado sub-máquina que pode ser acessada de diferentes formas e pode produzir diferentes eventos, de acordo com a sua execução.
Esse estado sub-máquina (SubmaquinaDeFalha) modela o tratamento de um determinado erro.
Em esse exemplo o estado pode ser acessado de acordo com a transição disparada para o mesmo.
Caso o erro gerado seja do tipo 1, ele será encaminhado por a transição erro1 $ , e seu tratamento será feito a partir de o estado inicial da máquina referenciada.
Caso o erro gerado seja do tipo 2, o acesso ao estado é feito por o ponto de entrada sub1, e o tratamento do erro é efetuado a partir estado T2 da sub-máquina.
Assim como um estado inicial, uma transição que parte de um ponto de entrada não possui um evento agregado.
De forma similar, se um determinado erro é tratado antes da execução completa damáquina de estados, a sub-máquina pode ser deixada através do ponto de saída subS.
Note que a uma condição de guarda verifica se o erro foi tratado no estado T2, habilitando a transição por o disparo do evento ev3, podendo então habilitar a transição externa (que executa resp2) a partir de subS.
Caso contrário, a sub-máquina é executada até seu estado final e a transição externa prevista nesse caso é disparada, executando resp1 nesse exemplo.
Para a modelagem de um estado do tipo sub-máquina em SAN, um estado W é utilizado como fonte de todas as transições iniciais da sub-máquina.
De essa forma, quando a subm áquina de estados não estiver sendo executada, a SAN que a modela permanecerá no estado W. Dependendo da forma de acesso à essa sub-máquina, o estado W habilitará uma determinada transição, sendo essa sincronizada com a transição externa que acessa essa sub-máquina.
Os eventos hI e hsub1 são sincronizados com os eventos externos que alcançam a subm áquina, sendo que suas respectivas taxas de ocorrência são funções que dependem dos eventos externos.
Os eventos ev2 e ev3 são sincronizadas com as transições externas que partem da subm áquina.
Esse eventos apontam para o estado W, e em ele ficam bloqueados até que a sub-máquina seja acessada novamente.
A semântica de cada pseudo-estado depende de como esse atributo é utilizado, sendo esses descritos a seguir.
Pseudo-estado inicial (initial pseudo state):
Representa um vértice padrão que inicia a transição para o primeiro estado de um estado composto.
Possui a mesma semântica que rege um estado inicial convencional, conforme descrito anteriormente.
Um pseudo-estado inicial é apresentado na Figura 4.14 como um fragmento de um estado composto.
Como descrito na definição de um estado inicial, a transição que parte de um pseudoestado inicial não possui evento agregado.
Em SAN esse evento é sincronizado com o evento externo que alcança o estado composto).
Um exemplo de aplicação desse tipo de estado é utilizado é apresentado na Figura H) é executado pela primeira vez, ou se na última execução desse estado composto o seu estado final foi atingido, não haverá histórico armazenado.
Em esses casos, o estado de histórico funcionará como um pseudo-estado inicial.
Quando o estado final for alcançado, o evento ev5 é ativado.
Se por algum motivo a execução do estado composto tiver que ser interrompida (para tratar alguma exceção, por exemplo) o estado estado interno em que se encontrava será armazenado e o evento ev4 será disparado.
Em a próxima vez que o estado composto for acessado, ele continuará a execução a partir de o estado armazenado no histórico.
Em SAN não existe uma estrutura que modele um estado de histórico superficial.
Em esse caso, sugere- se que a modelagem do estado composto que possui um estado de histórico possua mecanismos que possibilitem o acesso a um determinado estado, a partir de o estado W da SAN, e que de alguma forma essa transição seja guiada em função de o estado em que a SAN se encontrava anteriormente.
Para isso, a utilização de autômatos auxiliares pode ser necessária.
Estado de histórico profundo (deep history):
Similar ao estado de histórico superficial, porém esse permite lembrar o último estado ativo em qualquer nível de aninhamento, o que não é possível com o estado descrito anteriormente, o qual lembra somente o estado aninhado mais externo.
A Figura 4.16 mostra um exemplo de utilização de um estado de histórico profundo (H*).
A sistemática é a mesma empregada no estado de histórico superficial, porém são registrados inclusive os estados mais internos.
Em esse exemplo, caso o evento ev9 seja disparado enquanto a máquina de estados se encontre em E22, esse estado será armazenado.
Quando o estado E2 for acessado novamente, a execução da máquina de estado continuará a partir de E22.
Se o estado E2 alcançar seu estado final, o evento ev10 será disparado e nenhum estado será armazenado no histórico.
Segundo a definição de estados de histórico, podem existir vários desses incluídos em diferentes níveis de aninhamento de um mesmo estado composto.
Assim como num estado de histórico superficial, não existe uma estrutura que modele um estado de histórico profundo em SAN.
Em esse caso, sugere- se a mesma estrat égia apresentada anteriormente.
Conforme descrito na definição de uma sub-máquina, um ponto de entrada não possui um evento de ativação na transição que ele habilita.
Em SAN esse evento é sincronizado com o evento externo (evext) que alcança o estado composto (Figura 4.17 (II)).
Em esse caso é utilizado um estado W, e o evento que parte desse estado é sincronizado com o evento externo que atinge o ponto de entrada.
Assim como descrito na definição de estados do tipo sub-máquina, para modelar o comportamento de um ponto de saída em SAN, a transição que chega no ponto de saída (subS no diagrama de estados desse exemplo) apontam para um estado W da SAN, e em ele fica bloqueado até que a sub-máquina seja acessada novamente.
O evento que dispara essa transição é sincronizado com o evento externo que deixa a sub-máquina.
Junção (junction):
São vértices livres de semântica usados para juntar múltiplas transições.
Eles constroem uma nova transição através da união de diferentes transições oriundas de diferentes estados (merge), cada qual com uma diferente condição de guarda, ou separam uma transição em várias (branch), onde cada qual possui uma determinada condição de guarda.
Isso realiza uma ramificação condicional estática, onde uma transição é habilitada se todas as outras forem avaliadas como falsas.
É apresentado na Figura 4.19 um exemplo de junção.
Em SAN um comportamento equivalente é obtido com a inserção de um estado (J) que auxilia na modelagem dessa situação.
Isso pode ser observado na SAN exemplificada na figura acima.
Finalização (terminate):
Implica no fim da execução da máquina de estado, de acordo com o contexto do objeto.
A entrada nesse pseudo-estado é equivalente a uma chamada do tipo DestroyObjectAction.
Em SAN, não é necessaria a inserção de um estado especifico que modele uma finalização.
Em esse caso, a transição que atinge o ponto de saída será sincronizada com a transição que deixa a máquina de estados.
Para efeitos de modelagem, uma finalização num diagrama de estados tem a mesmo comportamento de um estado final em SAN.
Sendo assim, a transição que aponta para uma finalização num diagrama de estados passa apontar para o estado W em SAN.
Essa situação é exemplificada na Figura 4.21.
Fork: É uma notação opcional, utilizada para ramificar uma transição em várias, cada uma para diferentes regiões ortogonais de um estado composto.
As transições originadas no fork não contém guardas ou eventos de disparo.
Um exemplo dessa estrutura é apresentada na Figura 4.22.
Esse pseudo-estado modela o início simultâneo de duas regiões ortogonais de um estado composto.
Como visto anteriormente, isso pode ser modelado (e é sugerido) com a utilização de estados iniciais em cada região, conforme mostrado na Figura 4.22.
Em SAN, um fork é modelado com a utilização de eventos sincronizantes que asseguram a execução simultânea de cada uma das regiões, sendo que cada região é modelada por um autômato distinto.
Cada um desses autômatos possui um estado W em o qual cada um desses se encontra antes da execução da região que esse modela.
Essa estrutura é verificada na Figura 4.22.
Join: É utilizado para reunir diferentes transições originadas em regiões ortogonais de um estado composto.
As transições que originam o join não contém guardas ou eventos de disparo.
A Figura 4.23 mostra pseudo-estado do tipo join.
Em SAN, um join é modelado com a utilização de eventos sincronizantes que asseguram o fim simultâneo de cada uma das regiões, sendo que cada região é modelada por um autômato distinto.
Cada um desses autômatos possui um estado W, que também modela o início da maquina de estados, que é atingido por a transição que atinge o estado final de cada uma das regiões ortogonais.
Esse comportamento é visto na Figura 4.22.
Com a transcrição aqui formalizada pode- se traduzir um diagrama de estados da UML para uma estrutura equivalente em SAN.
Para melhor elucidar o método proposto, um estudo de caso é apresentado no Capítulo 6.
Não existe uma sistemática geral para a determinação das taxas de ocorrência de um evento derivado de um diagrama de estados.
Sugere- se nesse caso a avaliação da estrutura da SAN, da especificação fornecida, que os detalhes do comportamento do sistema seja discutido com o cliente, ou que as taxas sejam atribuídas segundo a avaliação de um histórico de comportamento do sistema (ou de sistemas similares).
Uma aproximação para a determinação sistemática de transições de probabilidade, usando funções objetivas de restrições derivadas da estrutura e uso do modelo de teste, é introduzido em.
Quanto mais fiel for essa avaliação maior será a qualidade do modelo de uso do sistema, que por sua vez infere na obtenção de casos de teste mais confiáveis.
A presença de condições de guarda em determinadas transições sugere a inclusão de uma estrutura que avalie a restrição, para então permitir (ou não) o disparo dessa transição.
Para melhor elucidar essa idéia, é apresentado na Figura 4.24 um trecho de um diagrama de estados que possui condições de guarda em suas transições:
Como pode ser observado na figura, a transição que possui a taxa funcional f1 somente será disparada se o autômato Aut cond se encontrar no estado T. De forma similar, o disparo da transição entre E1 e E2 só ocorrerá se o autômato Aut cond se encontrar em F. De posse da SAN que representa o modelo de uso do sistema, é possível efetuar uma análise comportamental do sistema como um todo, ou de uma parte específica do mesmo.
Essa análise é efetuada com a execução desse modelo na ferramenta PEPS2003, onde informações que possam auxiliar no planejamento do sistema, como alocação de recursos ou estimativa de tempo, podem ser extraídas.
Como os diagramas de estados são concebidos antes da fase de implementação e de testes, as informações extraídas na análise comportamental do sistema pode ser utilizada no auxílio de tomada de algumas decisões, dependendo do critério utilizado.
Por exemplo, na avaliação da SAN pode ser determinado qual o autômato com maior probabilidade de execução, indicando qual o setor do sistema que será executado com maior freqüência.
Se esse for um critério utilizado para à determinação da alocação de recursos, o analista pode determinar que os melhores programadores (ou testadores) sejam responsáveis por esse setor do sistema.
Como relatado anteriormente, a SAN gerada representa o modelo de uso do sistema, o que serve de base para a geração de casos de teste.
A análise do sistema é obtida com uma SAN que descreva o comportamento de todos os casos de uso do sistema, e a interação desses com os atores.
Sendo assim, somente os diagramas de estados não são suficientes para compor essa análise.
As informações sobre a interação dos atores com o sistema são obtidas no diagrama de casos do uso.
Essa idéia é apresentada na Figura 4.26.
Inicialmente, é necessário identificar os atores do sistema.
Com isso, busca- se os casos de uso principais, aqueles que possuem associação direta com um ator do sistema, indicando assim uma interação.
A interação entre um ator e seus casos de uso é modelada por um autômato que traduza essa associação, conforme representado na Figura 4.27.
Em essa análise, toda a associação entre um ator e um caso de uso (figura (I)) é desdobrada em duas transições no autômato que modela essa associação (figura (II)), e essas transições possuem eventos sincronizantes que habilitam as transições que iniciam e concluem a execução do autômato que modela o caso de uso.
Ou seja, o evento ev1 do autômato Aut Ator será sincronizado com o evento que parte do estadoWdo autômato que modela o caso de uso.
De forma similar, o evento ev2 será sincronizado com o evento que atinge o estado W do autômato que modela o caso de uso.
De os casos de uso principais (que possuem associação direta com um ator) busca- se os casos de uso incluídos e estendidos dos mesmos.
Com a determinação de todos os casos de uso do sistema, cada um será explodido num diagrama de estados que descreve o seu comportamento.
Com a especificação feita nas seções anteriores, a partir de cada um dos diagramas de estados será gerado um autômato equivalente.
Por fim, esses autômatos serão integrados com os autômatos que modelam a interação entre os atores e o sistema, sendo possível assim obter uma SAN que modele o comportamento do sistema como um todo.
Definiremos aqui como análise do componente a análise proporcionada por a SAN que modela o comportamento de um caso de uso que possui interação direta com um ator, bem como seu casos de uso subordinados, incluídos e estendidos.
Aqui, a interação entre o sistema e o ator não é analisada.
Apesar de não serem utilizados nos cálculos que a análise viabiliza, os atores devem ser identificados com o intuito de encontrar os casos de uso principais.
Cada caso de uso principal pode conter casos de uso subordinados, e o conjunto formado por esses irá compor uma SAN distinta, cada qual disponibilizando informações comportamentais de um componente do sistema.
Os autômatos dessa SAN são construídos por a transcrição dos diagramas de estados que modelam o comportamento de cada um dos casos de uso do componente.
Durante a concepção desse trabalho, verificou- se que o modelo SAN construído pode apresentar um número de autômatos (e de estados) que inviabiliza a sua análise na ferramenta PEPS2003.
Esse comportamento é observado na análise do sistema (apesar de certos componentes do sistema apresentarem um alto nível de complexidade), o que pode comprometer a análise pretendida.
De essa forma, ao se obter a SAN que modela o comportamento do sistema, deve- se avaliar o espaço total de estados gerado.
Isso é feito através do cálculo do produtório do número de estados do modelo SAN.
Por exemplo: Uma SAN que possui 5 autômatos, sendo que esses possuem 4, 3, 5, 3 e 5 estados, o espaço total de estados gerado será de 900 estados.
O histórico de utilização da ferramenta PEPS2003 alerta para a inviabilidade de se analisar sistemas com número total de estados superior a Sendo assim, ao final da construção da SAN deve- se avaliar se o número total de estados gerados não ultrapassa o limiar suportado por a ferramenta PEPS2003.
Caso isso aconteça, deve- se buscar uma SAN mais enxuta, com um número menor de autômatos e estados, mas que ainda possua informações que viabilizem a análise de cobertura do sistema.
Essa simplificação é obtida da seguinte forma:
É mantida a modelagem dos atores que interagem com o sistema.
Como a simplificação da SAN resultante será aplicada na análise do sistema, é necessário manter essa modelagem;
Serão mantidos os estados que influem diretamente na determinação do fluxo de dadosdDo componente.
Esses estados, que aqui serão denominados como estados-chave, são os seguintes:
Estado de espera (W):
A partir desse estado é modelado o início da execução de uma funcionalidade do sistema.
As transições que partem e chegam de um estado W possuem eventos sincronizantes, o que sugere a permanência desse estado num modelo simplificado.
Estado de espera/ sincronização (Ws):
Esses estados são utilizados para modelar um bloco de sincronização, o qual se forma entre um fork e um join.
Assim como num estadoW, as transições que partem e chegam num estado Ws possuem eventos sincronizantes, sendo então necessária a modelagem desse estado no novo modelo simplificado.
Estado de bifurcação:
São estados de onde partem mais de uma transição, cada qual com uma possível condição de guarda.
Como cada uma dessas possíveis transições inicia um trecho de código que precisa ser testado, pois compõe um caminho distinto dentro de o código.
Fica aqui definido que para toda a bifurcação presente num autômato, haverá um estado que irá compor a confluência dos trechos iniciados na bifurcação.
Essa confluência pode ocorrer, inclusive, no estado W. Estado de confluência:
É um estado que é atingido por mais de uma transição, determinando assim o fim de um trecho iniciado num bifurcação.
Estado que modela um caso de uso diferente:
As transições que chegam e partem desse tipo de estado possui eventos sincronizantes, os quais modelam o inicio e o fim da execução do autômato que modela o caso de uso diferente.
Essa situação sugere a manutenção desses estados no novo autômato em construção.
Primeiro nível de simplificação (N1):
Um trecho composto por estados seqüenciais, trecho esse iniciado após um estado-chave e que termina antes de um outro estado-chave, será substituído por um estado equivalente que representa o referido trecho.
Em outras palavras, uma seqüencia de estados que apareça entre dois estados-chave será substituído Por um estado equivalente.
Para melhor ilustrar essa idéia, é apresentada a Figura 4.29.
Essa figura exemplifica uma situação onde é aplicada uma simplificação de nível 1.
Em esse trecho de um autômato, o qual modela a execução de UC1, podem ser observados dois estados-chave:
W e E4 UC2 (um estado que modela um caso de uso diferente).
Todos os estados seqüenciais entre esses estados-chave, em negrito na figura, serão substituídos por um estado equivalente, modelado como E EQ1 na figura.
Como também pode ser observado, os eventos anteriores e posteriores a esse trecho seqüencial são mantidos na nova estrutura.
Quase todas as combinações de estados-chave poderão marcar o início e o fim de um trecho seqüencial, o qual será substituído por um estado equivalente.
Em a Tabela 4.4 são mostradas as possíveis combinações de estados-chaves que delimitam o início (primeiro coluna da tabela) e o fim (primeira linha da tabela) de um trecho seqüencial.
Como pode ser observado, a única combinação que não será composta é aquela que inicia um trecho seqüencial a partir de um estado W e termina antes de uma confluência.
Isso é devido a o fato de, a partir um estado W, uma confluência sempre é precedida de uma bifurcação, em algum instante.
Sendo assim, uma bifurcação sempre será encontrada antes de uma confluência, o que impede a composição de um trecho seqüencial entre um estado W e uma confluência.
A figura mostra o estado equivalente gerado na Figura 4.30.
Como foi explanado, uma nova transição é composta entre os estados-chave, sendo mantido o evento da transição que parte do estado equivalente (evento ev4, nesse exemplo).
Devido a a nova estrutura gerada, algumas alterações adicionais podem ser necessárias.
Em a realidade, num ultimo passo dessa simplificação, deve- se atentar para duas situações especiais, as quais precisam ser tratadas:
Auto-transição: A eliminação de um estado equivalente, sendo esse substituída por uma única transição.
Para melhor elucidar essa idéia, é apresentada a Figura 4.31.
Em a figura, o autômato Aut UC2 possui um estado equivalente que, ao ser eliminado na simplificação N2, produzirá uma auto-transição para o estado W, conforme pode ser observado na figura.
Em essa situação, não há necessidade de manutenção do autômato Aut UC2, sendo então possível eliminar- lo, assim como vislumbrado na figura.
Em esse novo arranjo, os eventos ev3 e ev4, que antes era sincronizados com o início e o fim da execução de Aut UC2, passam a ser eventos locais no Aut UC1.
Em essa nova estrutura, o teste de execução do autômato Aut UC2 passa a ser feito por o teste dos eventos ev3 e ev4.
Em esses testes pode ser verificado, por exemplo, se a funcionalidade descrita por UC2 é corretamente invocada, e que essa produz um determinado resultado.
Acredita- se que para um teste de sistema, essa abordagem seja suficiente, visto que testes mais refinados podem ser obtidos com autômatos construídos na análise de componente.
Várias transições entre dois estados:
Outra situação que deve ser observada é aquela onde a simplificação N2, através da substituição dos estados equivalentes por transições, pode gerar múltiplas transições entre dois estados.
Essa situação pode ser observada na Figura 4.32: A figura mostra dois estados equivalentes que são eliminados na simplificação N2, dando origem ao arranjo apresentado na figura, onde duas transições distintas entre W e E4 UC2 são originadas.
Essas duas transições devem ser substitu ídas por uma única, e essa deve conter os dois eventos que estavam associados às transições originais.
Para testar essa transição, deve ser verificado se a mesma é disparada por a ativação de qualquer um dos dois eventos.
Em outras palavras, um transição com mais de um evento deve possuir um teste para cada evento.
Seguindo os passos descritos, é possível construir uma SAN mais enxuta, mas que ainda apresenta as informações necessárias para a análise de cobertura de sistema como um todo.
Com a concepção da SAN que representa o modelo de uso do sistema, que reflete uma descrição formal do comportamento do software a ser desenvolvido, é possível gerar testes estatísticos de software, conforme proposto por Bertolini.
Para o seu trabalho foi aplicado o processo de teste estatístico utilizado por o Centro de Pesquisa em Teste de Software (CPTS) da PUCRS, onde um modelo formal do sistema, construído em MC ou SAN, é utilizado para gerar os casos de teste.
O CPTS desenvolveu um framework de automatização do processo de teste estatístico chamado State Based Test Generator (STAGE).
Sua arquitetura é organizada em três módulos:
STAGE-Model: É uma ferramenta que permite a modelagem de uma aplicação através da composição de um conjunto de estados e transições que remetam ao modelo comportamental da aplicação, sendo possível modelar o sistema em SAN, uma vez que a STAGE pode estar integrada a ferramenta PEPS2003.
Cada passo do caso de teste é composto por um estado global da SAN, juntamente com o evento que dispara a mudança de estado.
De as restrições de modelagem que a ferramenta impõe, a descrição comportamental do sistema (análise de sistema) composta a partir de os diagramas de estados não atribui um único estado para o início da execução do modelo, e STAGE necessita desse estado inicial.
Sugere- se aqui que a atribuição desse estado seja feita manualmente por a interface do STAGE.
Outras informações como entradas e saídas dos estados, não disponibilizada por a SAN, pode ser capturada na análise do diagrama de estados correspondente.
STAGE-Test: É responsável por gerar os casos de teste a partir de os dados fornecidos por a STAGEModel.
Como saída, a ferramenta disponibiliza uma test suite, a qual serve de base para a geração de scripts de execução automática de casos de teste.
STAGE-Script: Com as informações disponibilizadas nos outros módulos do STAGE, são compostos scripts de teste, os quais podem ser inseridos no aplicativo RobotJ da Rational como um novo projeto, com o intuito de testar a aplicação.
Eventualmente, a SAN gerada pode não atender todos os requisitos necessários para a sua execução no STAGE.
De qualquer forma, a adequação necessaria pode ser efetuada por a interface de edição do STAGE-Model, onde a definição do estado inicial e dos eventos do tipo mestre e escravo, requisitados por o STAGE.
Alternativamente, a geração de casos de teste de software pode ser dada por a execução de um caminho específico da SAN gerada, onde cada evento associado a uma transição deve ser testado.
Para tanto, para cada uma das transições da SAN global deve ser atribuída a ação correspondente, indicada na transição do diagrama de estados.
Em o próximo capítulo é descrita o método utilizado para a construção do protótipo para geração de um arquivo SAN, a partir de informações fornecidas por os diagramas construídos sob a abordagem o Processo Unificado, construídos através da ferramenta Rational Rose.
Esse capítulo descreve detalhes sobre a implementação do protótipo para a tradução dos diagramas UML gerados por a metodologia do Processo Unificado numa estrutura equivalente em SAN.
Essa descrição inicia com um apanhado geral sobre o contexto onde o protótipo vai atuar, sendo então especificado os detalhes da implementação do mesmo.
Buscando a validação das atividades de pesquisa propostas nesse trabalho, foi proposta a construção de um protótipo para a construção de um arquivo.
San a partir de um arquivo gerado por o Rational Rose, seguindo a metodologia do Processo unificado, visando a análise do modelo de uso de um software, para a posterior geração de casos de teste.
A IBM disponibiliza em seu site um plug-in para a tradução dos arquivos gerados por o Rose para uma estrutura XML (RoseXMLTools).
Esse plug-in foi utilizado nessa pesquisa, possibilitando então a conversão de um arquivo gerado por o Rose(*.
Mdl ou*.
Ptl) para uma estrutura XML equivalente, sendo esse utilizado para a construção da SAN.
Visando a padronização da modelagem, o contorno de eventuais dualidades e a viabilização da construção da SAN, o padrão de construção de diagrama de estados UML, descrito no capítulo anterior, deve ser adotado.
Conforme relatado anteriormente, a análise de sistemas complexos pode ocasionar uma explosão de espaço de estados na SAN gerada, o que inviabiliza a sua análise na ferramenta PEPS2003.
Sendo que essa explosão pode ser tratada, seguindo os passos descritos anteriormente, essa ação será efetuada num módulo diferente ao que traduz uma especificação UML para SAN.
Em outras palavras, o protótipo proposto será dividido em dois módulos:
Módulo* Tradução:
Em esse módulo ocorrerá a tradução do arquivo XML, sendo então construída uma SAN equivalente.
Módulo 2 -- Simplificação:
Caso a tradução efetuada noMódulo 1 resulte numa explosão do espaço de estados na SAN, a técnica de simplificação apresentada anteriormente deve ser aplicada.
Apesar de dispormos de toda a transcrição que traduz os elementos dos diagramas de estados da UML 2.
0 para uma estrutura equivalente em SAN, a Rational Rose não disponibiliza todos esses elementos.
De essa forma, serão descritos aqui esses elementos, bem como uma alternativa de modelagem que assegure a construção Pontos de entrada e saída numa sub-máquinas de estados:
Esses pseudo-estados não são disponibilizados por o Rational Rose.
Para obtermos uma estrutura equivalente, é necessário efetuar uma pequena alteração no diagrama de estados que esta sendo construído.
Uma opção para um ponto de entrada é a utilização de um estado auxiliar, e de ele será feita a transição desejada, dependendo da condição de guarda da transição que atinge a subm áquina.
Vale lembrar que apenas uma transição pode partir de um estado inicial, o que justifica a utilização de um estado auxiliar.
Para um ponto de saída, é sugerido que a transição que atingiria esse pseudo-estado aponte diretamente para o estado final da sub-máquina.
A transição que partirá do pseudo-estado, que será habilitada a partir de o alcance do estado final, dependerá do evento da transição que atinge o estado final.
Em outras palavras, os eventos das transições que atingem o estado final da sub-máquina serão utilizados como condição de guarda das transições que partem da sub-máquina.
Para melhor elucidar essa idéia, é apresentada a Figura 5.1.
TratamentoDeFalha: SubmaquinaDeFalha subS/ ev3/ ev1 evAUX1 evAUX2 TratamentoDeFalha:
SubmaquinaDeFalha. Em a nova configuração, as condições de guarda determinam qual a transição que vai apontar para o estado final (figura (II)), e o evento ocorrido nessa transição será utilizado como condição de guarda para a determinação de qual das duas transições será disparada por a sub-máquina.
De essa forma a sub-máquina continua sendo executada conforme a transição que a atinge e de acordo com a maneira como ela é finalizada.
Junção: Apesar de constar na especificação da UML 2.
0, o Rational Rose não disponibiliza pseudoestados do tipo junção.
Alternativamente, sugere- se que todas as transições que partem de uma junção sejam disparadas diretamente dos estados anteriores à junção, sendo assim possível suprimir esse pseudo-estado, apesar de o número de transições poder aumentar.
Essa configuração é mostrada na Figura 5.2.
A junção apresentada na Figura possui três transições (cada qual com uma condição de guarda específica) que são disparadas a partir de ela.
Com a supressão sugerida, essas transições serão disparadas de todos os estados anteriores à junção, ainda mantendo as condições de guarda especificadas anteriormente (Figura (II)).
Finalização: Por também não ser disponibilizado um pseudo estado de finalização, é sugerido aqui que todas as transições que apontam para uma finalização (indicando a destruição de um objeto, por exemplo) apontem para o estado final da máquina de estados.
Essa situação é exemplificada na Figura 5.3.
Ev1 ev2 3 ev6 ev7 ev4 ev1 ev3 ev2 En em En em Eventualmente, a utilização de um estado de finalização pode acarretar numa ação alternativa a que seria executada após o estado final, caso essa máquina de estados esteja agregada a uma outra.
Esse fluxo alternativo deve ser assegurado de maneira similar ao apresentado no item que especifica as alternativas aos pontos de entrada e saída de uma sub-máquina de estados.
Choice: Apesar de ser disponibilizado por o Rational Rose, sugere- se aqui que esse pseudo-estado (branch) seja suprimido no instante da construção do diagrama de estados, conforme apresentado na Figura 5.4.
Em essa nova estrutura, o fluxo de execução prossegue de acordo com as avaliações requisitadas nas condições de guarda.
A seguir são descritos os detalhes do XML que disponibilizam as informações necessárias para a construção da SAN.
Em a estrutura disponibilizada no arquivo XML gerado a partir de o Rational Rose, contendo as informações sobre os diagramas de estados do sistema, Sendo que um diagrama de estados é utilizado para descrição comportamental de caso de uso, esses diagramas serão nomeados de forma que indique qual o caso de uso que está representando.
Esses casos de uso possuirão identificadores padrão que os distinguirão dos demais.
Pra isso, um número de identificação do tipo UCn, onde n é o número total de casos de uso, irá compor o nome do caso de uso juntamente com a sua descrição textual (opcional).
Por exemplo: UC3 -- Verificar saldo.
Seguindo a especificação descrita no Capítulo 4, cada diagrama de estados modelado no RUP, que modela um determinado caso de uso, deve estar contido num super-estado.
Cada um desses diagramas de estado estará com ti num super-estado, sendo que esse será nomeado respeitando a seguinte sintaxe:
E UC1, E UC2, E UC3,...,
E UCn, onde n é o número total de casos de uso.
Todos os estados de um diagrama descrevem o comportamento determinado caso de uso, possuindo a identificação desse caso de uso em seu nome, da seguinte maneira:
E1 UCn, E2 UCn, fluxos alternativos ao fluxo principal de dados) e n é o número total de casos de uso.
Segundo o padrão de modelagem especificado, os eventuais fluxos alternativos são nomeados com UCn, onde é o número total de fluxos distintos que um estado pode seguir.
Caso alguns desses fluxos alternativos sejam compostos por mais de um estado, cada um desses é nomeado da seguinte forma:
Em 1 UCn, 2 UCn, Em t UCn, onde t é o numero total de estados que um determinado fluxo alternativo pode conter.
A especificação descrita aqui é utilizada para nomear estados de um diagrama de estados.
Logo, parte- se do princípio que essa especificação foi adotada na construção dos diagramas de estados, não sendo necessária qualquer modificação adicional para a construção dos estados da SAN, exceto por a inserção de estado auxiliares (W e Ws) no arquivo.
San, conforme descrito posteriormente.
Eventualmente, determinados estados de um diagrama pode conter o nome um caso de uso diferente do caso de uso que está sendo modelado.
Isso vai indicar a execução de um outro diagrama de estados.
Por exemplo, uma seqüência de estados do tipo inicial\&gt;?
E1 UC1? E2 UC2)?
E3 UC1)? De posse do arquivo XML com as informações sobre os diagramas de estado que descrevem o comportamento do sistema, sendo que esse arquivo seguiu a especificação descrita anteriormente, é possível construir o arquivo SAN para a análise do modelo de uso desse sistema, bem como a obtenção dos casos de teste para o mesmo.
Os diagramas de estados são possuem são identificados por a tag que a distingue dos demais objetos descritos.
Conforme formalizado anteriormente, cada diagrama de es81 tados que descreve um caso de uso está encapsulado num super-estado.
Sendo assim, percorrermos o arquivo XML, será encontrada uma estrutura que segue o seguinte formato:
Descreve um estado simples.
Em a sua estrutura, um estado simples possui atributos que descrevem a sua situação no contexto do diagrama, sendo os que interessam para os propósitos desse trabalho são:
Xmi. Id:
Número que identifica o estado corrente;
Name: Descreve o nome do estado corrente;
Outgoing: Informa o xmi.
Id do próximo objeto;
Incoming: Informa o xmi.
Id do objeto anterior· Descrevem os pseudo-estados que constituem o diagrama de estado.
Esses pseudo-estados são transientes, logo o sistema nunca permanece nesses.
Os atributos necessários para a nossa análise são:
Xmi. Id:
Número que identifica o pseudo-estado corrente;
Kind: Descreve o tipo do pseudo-estado corrente, sendo esses:
Initial: Descreve um estado inicial de uma maquina de estado.
Em esse tipo de pseudo-estado, não haverá incoming.
Fork: Descreve o disparo paralelo e sincronizado de varias transições.
Join: Descreve a sincronização de várias transições numa única.
Branch: Descreve uma escolha entre duas ou mais transições, de acordo com a condição de guarda associada a cada transição* outgoing:
Informa o xmi.
Id do próximo objeto;
Incoming: Informa o xmi.
Id do objeto anterior.
Os pseudo-estados não possuem nomes associados a si.
De qualquer forma essa informação não é necessária para a construção da SAN.
Indica o fim da execução de uma máquina de estados.
Em esse tipo de estado, não haverá outgoing.
Os xmi.
Id especificados em outgoing e incoming são usados na composição de uma transição, sendo que essa é composta com uma seqüência do tipo Id do estado/ pseudo-estado\&gt;?
Id da transição\&gt;?
Id do estado/ pseudo-estado\&gt;.
Outras informações das transições, como condição de guarda, ações ou nome dos eventos (esses serão compostos no instante da construção da SAN), não são necessárias para a construção da SAN.
O Rational Rose não possui um objeto que designe diretamente um fork ou um join.
Para isso, é disponibilizado um objeto denominado estado de sincronização (synchronization state) com o qual é possível compor estrutura do tipo fork e join.
Porém, ao traduzir um arquivo gerado por o Rose para uma estrutura XML, os identificadores fork e join são disponibilizados, como pode ser verificado no trecho abaixo:
Apesar de a UML não explicitar que para cada fork especificado num diagrama, deverá existir um join correspondente, nesse trabalho será adotada essa premissa.
Isso é necessário pois o disparo paralelo de transições precisa ocorrer em autômatos distintos, o que sugere a construção um novo autômato para cada uma das transições disparadas, na SAN que será construída.
De essa forma, também é necessário compor novos eventos sincronizantes em cada um dos autômatos construídos, de forma que a execução retorne para o autômato que disparou as transições paralelas, imediatamente após a execução do referido disparo.
Para melhor ilustrar essa idéia, é apresentada a Figura 5.5.
Essa foi a forma encontrada para tratar as regiões de sincronização, sendo que essas não são disponibilizadas por o Rational Rose.
Conforme explanado anteriormente, as análises almejadas por a transcrição dos diagramas de estados UML para SAN, requerem informações adicionais além de as fornecidas por os diagramas de estados, referentes à identificação dos casos de uso com os quais os atores interagem.
Essas informações são necessárias para integrar os casos de uso do sistema na composição da análise de sistema, e para a determinação de quais os casos de uso que irão compor cada uma das análises de componente.
Em o arquivo XML, a interação entre as entidades que compõem um diagrama de casos de uso é feita por uma estrutura denominada Association.
Essa estrutura (identificada por a tag é composta por dois objetos do diagrama de casos de uso, cada um especificado numa estrutura do tipo AssociationEnd.
Para encontrar os casos de uso que possuem interação direta com os atores, é necessário seguir alguns passos, conforme especificado na Figura 5.6.
A determinação dos atores e quais casos de uso que esses interagem é feita da seguinte forma:
Em o arquivo XML, são localizados os atores do sistema, os quais são identificados por a tag Em o arquivo XML, os atores estarão especificados da seguinte forma:
Para cada ator localizado, deve- se capturar o xmi.
Id do mesmo, estando esse especificado da seguinte forma:
A partir de o associationEnd que se refere ao ator, deve- se encontrar a outra extremidade da associação, a qual se refere ao caso de uso que interage diretamente com o ator.
Esse caso de uso é especificado no outro associationEnd que compõe a referida associação (identificada por a tag conforme pode ser observado na seguinte estrutura:
A o localizar o outro AssociationEnd da associação, deve- se capturar o xmi.
Id do mesmo, que será a identificação do caso de uso que interage com o ator1, conforme pode exemplifica a seguinte estrutura:
Com o xmi.
Id capturado, deve- se encontrar o caso de uso (identificado por a tag que é especificado com esse identificador, assim como descrito a seguir:
Tradução O Módulo 1 do protótipo proposto refere- se à transcrição dos diagramas de estados especificados no arquivo XML, para uma estrutura equivalente em SAN, disponibilizando essa para a análise do modelo de uso do sistema, bem como a construção de casos de teste do tipo Bertolini[ BFF+ 04, Ber05].
As Figuras 5.7 e 5.8 apresentam, respectivamente, os diagramas de classe modela a estrutura do Módulo 1 e o diagrama de seqüência da classe principal (UMLtoSAN).
Em o diagrama de seqüência apresentado na Figura 5.8 não mostra as trocas de mensagens entre as classe UMLtoSAN e SANStructure, pois essa ultima interage diretamente com a classe WriterSAN, sendo essa interação especificada no diagrama de seqüência que modela as chamadas efetuadas por a WriterSAN (esse e os outros diagramas de seqüências não são mostrados nesse trabalho).
A seguir é apresentada uma descrição geral sobre o funcionamento de cada uma das classes do sistema:
ParserXML: Efetua a leitura do arquivo XML e seleciona os dados necessários para a composição de uma estrutura com as informações necessárias para a construção da SAN.
StateStructure: Com a leitura feita por o ParserXML é construída uma estrutura com as seguintes informações;
SAN: Especifica o nome da SAN que agrega o autômato e, por conseqüência, o estado que está sendo analisado.
No caso de uma análise de componente, o nome da SAN será atribuído de acordo com o nome do arquivo XML, uma vez que essa análise compreende uma única SAN.
No caso de um análise de componente, será construída uma SAN para cada caso de uso que interage diretamente com um ator, bem como os casos de uso subordinados a esse.
O nome de cada uma dessas SAN será atribuído de acordo com o caso de uso que interage diretamente com o ator.
Sua nomeação segue a seguinte sintaxe:
SAN da SAN\&gt;.
Autômato: Os autômatos serão nomeados de acordo com o diagrama de estados (que possui o mesmo nome do caso de uso) que o mesmo modela.
Sendo assim, o referido autômato será nomeado de acordo com a seguinte sintaxe:
Aut do caso de uso\&gt;.
Estado 1: Esse é um estado, ou pseudo-estado, de onde parte uma transição.
No caso de os estados, o nome será o mesmo especificado no arquivo XML.
Para os pseudoestados, os nomes será atribuídos de acordo com o seu tipo, uma vez que esses não possuem nomes especificados no arquivo XML.
Sendo assim, o estado inicial de um diagrama de estado será nomeado comoW, e os forks e joins como WSn, onde n é o número de blocos de sincronização que constituem um mesmo diagrama de estados, sejam essas seqüenciais ou aninhados.
Um estado final nunca será especificado como «Estado 1 pois de ele nunca partirá uma transição.
Tipo do estado 1: O tipo de estado é determinado de acordo com a tag XML que o descreve, ou por as informações adicionais que especificam um pseudo-estado (kind).
Sendo assim, a Tabela 5.1 descreve os tipos dos estados e pseudo-estados, de acordo com a sua especificação:
Estado 2: Esse é um estado, ou pseudo-estado, que é atingido por uma transição.
A determinação do seu nome é feita da mesma forma conforme descrito para o &quot;Estado 1, exceto por a nomeação de um estado final como W. Um pseudo-estado inicial nunca será especificado como «Estado 2, uma vez que nenhuma transição atinge um pseudo-estado inicial.
Tipo do estado 2: O tipo do estado 2 é determinado da mesma forma especificado em o «Tipo do estado 1, adotando as mesmas regras de nomeação descritas na Tabela 5.1.
Evento: Descreve o nome do evento agregado à transição descrita.
Sua determinação será feita numa etapa posterior, durante a construção da SAN.
Tipo do evento:
O tipo do evento é determinado de acordo com o contexto onde a transição ocorre, conforme especificado adiante.
SANStructure: Organiza a informações necessárias para a construção da SAN, principalmente para a verificação dos eventos sincronizantes.
Caso a análise pretendida para esse software seja uma análise de sistema, a estrutura construída seria similar a observada na Tabela 5.2.
Suponhamos que o arquivo gerado por o Rational Rose tenha sido nomeado como Test..
Xml. Por motivos de simplificação e por a necessidade de classificarmos os estados que modelam a interação entre o ator e o sistema, quando o ator não estiver interagindo com o sistema, o autômato que o modela se encontrará num estado W do tipo initial.
Quando o ator estiver interagindo com o sistema por intermédio de um determinado caso de uso, o autômato estará no estado que identifica esse caso de uso, e esse será classificado como simple na estrutura que especifica as transições.
A estrutura gerada possui informações capturadas diretamente do arquivo XML.
Já as informações referentes aos eventos (nome e tipo) serão compostas a partir de as informações já coletadas, de acordo com os estados envolvidos em cada transição, e em qual o contexto que essa transição ocorre.
Para isso, a Tabela 5.3 foi construída para auxiliar na determinação dessas informações.
Utilizando regras, baseadas na Tabela 5.3, para a determinação do tipo de evento agregado a cada transição, é possível preencher a coluna EventType da Tabela 5.2.
O componente SANStructure será responsável por a verificação dos eventos sincronizantes, uma vez que um mesmo evento estará agregado a mais de uma transição, atribuindo a esses eventos nomes temporários, que serão redefinidos no instante do preenchimento da coluna Event.
Essa última coluna será composta por a nomeação dos eventos de forma seqüencial, obedecendo a sintaxe ev n, onde n é o número total de eventos da SAN.
Sendo assim, é possível compor a estrutura com as informações das transições que serão usadas para a construção da SAN, assim como exposto na Tabela 5.4: Com a SAN gerada, é possível efetuar análises sobre o modelo de uso do sistema, podendo assim servir como instrumento auxilio para o analista de software, no que se refere, por exemplo, tomada de decisões para alocação de recursos (desenvolvedores e testadores) e para estimativas para tempo de implementação.
Sendo que o exemplo aqui apresentado possui um objetivo meramente ilustrativo, ainda assim é possível obtermos algumas informações que pudessem auxiliar o analista de sistema na tomada de decisões.
Por exemplo: A determinação do estado do autômato que possua uma maior probabilidade de execução, devido as taxas de ocorrência, poderia ser um indicativo que esse setor do sistema é um ponto crítico, sendo necessário que o mesmo seja robusto e confiável, sendo que o analista possa alocar o melhores desenvolvedores e testadores para esse setor.
Sobre a geração de casos de teste de software, tendo posse de uma SAN que descreva o comportamento do sistema como um todo, ou de parte de ele, é possível gerar casos de teste conforme proposto por Bertolini.
As eventuais informações adicionais que não são disponibilizadas por a SAN podem ser inseridas manualmente na interface do STAGE-Model.
Uma inserção automática desses eventuais dados pode ser feita por a composição de um novo módulo ao protótipo, sendo isso proposto aqui como um trabalho futuro.
Apesar que já terem sido mencionadas, serão aqui ressaltadas algumas particularidades observadas (e esperadas) para a análise de sistema, proposta como produto do presente protótipo.
De entre elas, podemos destacar:
A interação dos atores com os casos são modelados por autômatos específicos.
Cada um de eles especifica a interação de um determinado ator os casos de uso com os quais esse ator interage;
Uma única SAN, nomeada conforme o nome do arquivo XML gerado por o Rational Rose, será concebida para a análise de sistema;
Um eventual caso de uso incluído que seja subordinados a mais de um caso de uso, possuir á apenas um autômato correspondente na análise de sistema, uma vez que uma única SAN modela o sistema inteiro;
Em os casos onde SAN gerada possua um número de autômatos e estado que inviabilizem a sua análise na ferramenta PEPS2003, a execução do módulo 2 do presente protótipo fará alterações na presente SAN, efetuando simplificação que possibilitem a sua posterior análise, sendo que essa simplificação não compromete a análise pretendida.
De entre as particularidades esperadas para a análise de componente, podemos destacar as seguintes:
Para cada componente, derivado de um caso de uso que interage com um ator do sistema, será concebida uma SAN específica para a análise do modelo de uso dessa funcionalidade do sistema.
Cada uma das SAN que modela uma determinada funcionalidade do sistema, funcionalidade essa disponibilizada para um ator, será nomeada de acordo com o caso de uso com o qual o ator interage.
Se um caso de uso incluído for subordinado a casos de uso que compõem SAN diferentes, o mesmo será modelado em cada uma dessas SAN.
Eventualmente, um componente pode possuir um numero de autômatos e estado que inviabilizam a sua análise na ferramenta PEPS2003.
Em esses casos, a utilização do módulo 2 do sistema será empregada.
Em o intuito de executar a simplificação da SAN gerada na análise de sistema, foi implementado um módulo de simplificação, sendo que a sua execução inicia após a composição da SAN na análise de sistema.
Para esse módulo, foi adicionada uma classe ao projeto UMLtoSAN, descrito anteriormente.
Essa nova classe, SANSimplifier, possui um método responsável por a substituição de um bloco seqüencial de estados por um estado equivalente, e um método responsável por excluir os estados equivalentes e tratar os casos especiais (auto-transição e múltiplas transições).
São capturados todos estados-chave nos autômatos da SAN, conforme descrito na seção A partir de cada estado-chave, é percorrido um possível caminho, guardando cada estado percorrido num array.
A o ser encontrado um novo estado chave, todos os estados e transições encontrados até então são substituídos por um estado equivalente.
São eliminados os estados equivalentes.
Para isso, é composta uma transição que liga os estados-chave que se encontram antes e depois do estado equivalente.
Essa nova transição possuirá o evento que, anteriormente, estava agregado à transição que partia do estado equivalente.
Isso significa que haverá um teste para esse evento, de forma que seja verificada a execução do evento imediatamente anterior a um estado-chave é executado.
Caso algum autômato gerado no passo 1 possua apenas um estado, e esse possua uma auto-transição, esse autômato é excluído.
Quando isso ocorrer, os eventos sincronizantes do outro autômato, aquele que determinava o início e o fim da execução do autômato excluído, serão definidos como eventos locais.
Caso algum autômato gerado no passo 1 possua múltiplas transições entre dois estados, são eliminadas essas transições, sendo então composta uma nova.
Essa nova transição possui os eventos que, anteriormente, estavam agregadas às transições eliminadas.
Após a execução desses métodos, a classe WriterSAN é executada novamente, compondo assim a nova SAN.
Para a execução do protótipo UMLtoSAN, o usuário deve dispor do arquivo XML gerado por o RoseXMLTools, arquivo esse que proverá os dados necessários para a construção da SAN.
Quando o arquivo UMLtoSAN.
Exe é executado, o usuário opta por a análise de sistema ou por a análise de componente.
Após a escolha da opção de análise, o usuário informa no nome do arquivo XML a ser analisado.
Esse passo é exemplificado na Figura 5.11, aonde é mostrada uma análise de componente.
A Figura 5.12 ilustra o protótipo em execução, mostrando na tela alguns resultados da análise do arquivo XML, os cálculos iniciais para a construção da SAN, bem como os passos dessa construção.
Como produto final, os arquivos.
San são gerados e disponibilizados no diretório de execução, para a posterior análise na ferramenta PEPS2003.
Em o próximo capítulo será apresentado um estudo de caso, sendo esse utilizado para exemplificar o método proposto nessa dissertação.
Será apresentada a descrição desse estudo de caso, juntamente com os diagramas e artefatos necessários para a composição da SAN.
Com intuito de verificar a eficácia da pesquisa efetuada, é proposto aqui um estudo de caso que englobe as terminologias descritas.
Em esse capítulo, serão especificados os detalhes do sistema de estudo proposto, bem como a modelagem e a transcrição dos diagramas gerados para uma estrutura equivalente em SAN.
O estudo de caso proposto nesse relatório refere- se a um sistema de controle e automação de um bar.
O referido sistema é responsável por gerenciar a venda de bebidas, o pagamento da contas e controle de estoque do estabelecimento.
A automação das atividades citadas é viabilizada por a utilização de cartões magnéticos, que substituem as tradicionais &quot;comandas».
A o chegar no estabelecimento, o cliente informa seu nome e CPF ao atendente, para eventual identificação em caso de perda ou extravio.
Esses dados são vinculados a um cartão magnético, sendo esse entregue ao cliente para a sua posterior utilização.
Para efetuar uma compra, o cliente solicita o produto e entrega o cartão ao atendente.
Em esse instante, o atendente passa o cartão na leitora e é verificado o status desse cartão, para certificar se esse cartão está apto para prosseguimento da operação de compra.
Um cartão está inapto para a compra nos casos em que um cliente estivesse tentando efetuar uma compra com um cartão que tivesse sido dado como perdido, ou em casos onde o consumo atingisse um determinado valor.
Esse último é utilizado de forma preventiva, impedindo que um cliente efetue compras acima de um valor considerado alto.
Caso esse valor seja atingido, é solicitado o pagamento desse valor para que o cartão fique apto novamente.
Caso o cartão esteja apto para compra, o atendente informa no termina qual o produto e a quantidade solicitada.
Em esse instante seria feita uma verificação no estoque sobre a disponibilidade do produto.
Sendo confirmada a disponibilidade, a quantidade solicitada é decrementada do estoque e o valor resultante dessa operação (valor unitário do produto multiplicado por a quantidade) seria vinculada ao cartão.
Ressalta- se aqui que a quantidade e valor operados sobre esse cartão fica armazenada numa base de dados, sendo que o cartão apenas vincula o cliente ao seu consumo, não possuindo qualquer informação sobre valores ou quantidades consumidas.
Para possibilitar o controle de consumo por parte de o cliente, o estabelecimento possui terminais para a verificação de valores.
Para a sua utilização, o cliente passa o cartão no terminal que logo após informa no visor o valor consumido vinculado a esse cartão.
Em essa operação também é efetuada a verificação do status do cartão, e caso o mesmo apresente alguma irregularidade, o terminal mostra uma mensagem para que o cliente dirija- se ao caixa para regularizar a situação do cartão.
O sistema possui um administrador responsável por cadastrar os produtos, juntamente com suas quantidades e valores unitários.
Em o instante do cadastramento, o administrador informa uma quantidade crítica de estoque de cada produto, e caso essa quantidade seja atingida, o administrador é informado para que efetue as providencias para a reposição do produto.
Para a modelagem do sistema descrito anteriormente, propõe- se a construção de três componentes que permitam a interação dos atores (Atendente, Cliente e Administrador) com o sistema.
O Atendente estará apto a receber o pagamento mediante aos cálculos requisitados e de acordo com a forma de pagamento, poderá inserir os dados do cliente na base de dados no intuito atribuir as informações sobre consumação (efetuada ao mesmo), poderá desabilitar um cartão dado como perdido e ainda estará apto a proceder um pedido efetuado por o cliente.
O cliente, por sua vez, pode interagir com o sistema ao consultar o saldo do valor consumido até um determinado instante.
Já o administrador irá cadastrar os produtos a serem disponibilizados aos clientes.
Essa visão geral do sistema pode ser melhor vislumbrada através do seguinte diagrama de casos de uso:
Cada um dos casos de uso apresentados nesse diagrama pode ser especificado através do template proposto por Cockburn, e desse é possível construir um diagrama de estados que formalize o comportamento do referido caso de uso.
De acordo com o diagrama de casos de uso descrito na seção anterior, é possível especificar cada um dos casos de uso, para então construir o diagrama de estados correspondente para cada desses.
Sendo assim, a seguir é feita essa especificação, sendo ainda UC1 -- Receber pagamento:
Esse caso de uso trata do recebimento do valor consumido do cliente por o atendente.
Para isso, o atendente deve receber o cartão que o cliente utilizou, e por a identificação do seu Id deve- se buscar os produtos, quantidades e valores totais consumidos.
A o ser feita a identificação do cartão, é avaliado se o mesmo não foi dado como perdido, o que pode ocasionar a retenção do cartão.
Caso nada seja constatado, o procedimento normal prossegue normalmente.
Duas variações podem ocorrer no instante da escolha da forma de pagamento (em dinheiro, cartão de crédito ou cartão de débito).
A descrição comportamental do caso de uso 1 é mostrada na Tabela 6.1.
Pagamento com cartão de débito (UC4 -- Pagar com cartão de débito) 4c -- cartão de crédito 4b1 -- Pagamento com cartão de crédito (UC5 -- Pagar com cartão de crédito) Casos de Uso Incluídos UC3 -- Calcular pagamento Para a descrição efetuada, é possível construir um diagrama de estados que modela o comportamento desse caso de uso.
Esse diagrama é mostrado na Figura 6.2, onde é possível observar que o fluxo de execução por os estados E3 UC3, E4a UC4 e E4c UC5 modelam a execução de outras máquinas de estados (E UC3, E UC4 e E UC5, respectivamente).
Os diagramas que modelam essas máquinas de estados serão apresentados adiante.
UC2 -- Consultar saldo:
Esse caso de uso descreva a utilização de um terminal de consulta saldo por parte de o atendente.
Em essa operação, o status do cartão também é avaliado antes de fornecer as informações desejadas.
Caso o cartão esteja apto para a operação, é feita uma consulta na base de dados para determinar o valor consumido por o cliente.
A descrição desse caso uso é mostrada na tabela 6.2.
Casos de Uso Incluídos UC12 -- Avaliar status do cartão Para esse descrição, o seguinte diagrama de estados é gerado (Figura 6.3):
Em esse diagrama, quando a máquina de estados estiver no estado E2 UC12, a máquina de estados EUC12 estará em execução.
UC3 -- Calcular pagamento:
Esse é um caso de uso incluído do caso de uso 1, que trata do recebimento do pagamento.
Em esse caso de uso são efetuadas as operações que calculam os valores consumidos por o cliente.
A Tabela 6.3 especifica o comportamento desse caso de uso.
Esse diagrama não possui estados que modelam a execução de outra máquina de estados.
UC4 -- Pagar com cartão de débito:
Como um caso de uso incluído do caso de uso 1, esse trata da operação de pagamento com o cartão de crédito.
Em o início do processamento dessa funcionalidade, o limite do cartão é consultado.
Caso o saldo disponível seja menor que a conta a ser paga, a operação será finalizada.
Caso contrário, o procedimento normal prossegue, conforme descrito na Tabela 6.4.
A Figura 6.5 mostra o diagrama de estados gerado a partir de a descrição do caso de uso 4.
Como o caso de uso que esse diagrama modela não possui casos de uso subordinados, seus estados tratam somente do comportamento do caso de uso 4.
UC5 -- Pagar com cartão de crédito:
Assim como nó item anterior, esse também é um caso de uso subordinado ao caso de uso 1, e trata do pagamento com cartão de crédito.
Além de a consulta do limite, é possível escolher as condições de pagamento.
A Tabela 6.5 apresenta os detalhes desse caso de uso 5.
O diagrama de estados que modela o caso de uso que trata do pagamento com cartão de crédito é exposto na Figura 6.6.
Assim como no ítem anterior, os estados desse diagrama modelam apenas a execuções referentes ao caso de uso 5.
UC6 -- Inserir dados do cliente:
A tarefa de inserção dos dados do cliente no sistema é atribuída ao caso de uso 6.
A execução dessa funcionalidade passa por a validação do CPF do cliente, tarefa que será executada por o caso de uso 7.
Caso o CPF do cliente seja inválido, a execução dessa funcionalidade não prossegue, sendo então finalizada.
Esse comportamento é descrito na Tabela 6.6.
O template que descreve o comportamento do caso de uso 5 habilita a construção do diagrama de estado que modela esse comportamento.
Sendo assim, o referido diagrama é mostrado na Figura 6.7.
Conforme dito aqui, a tarefa de validar o CPF informado por o cliente será executado num caso de uso subordinado.
De essa forma, quando a máquina de estados estiver em E3 UC7, a máquina de estados que modela a tarefa de verificação do CPF (EUC7) estará sendo executada.
UC7 -- Validar CPF:
Esse é o caso de uso que trata da validação do CPF, relatado no ítem anterior.
Essa funcionalidade é especificada na Tabela 6.7.
A Figura 6.8 exibe o diagrama de estados que representa o comportamento esperado para o caso de uso que trata da validação do CPF do cliente.
Como pode ser observado nesse diagrama de estados, os estados referenciam apenas os possíveis comportamentos do caso de uso 7.
UC8 -- Proceder pedido:
Em esse caso de uso são executados os procedimentos de processamento e entrega de um pedido feito por um cliente.
Como pode ser observado na Tabela 6.8, esse caso de uso possui duas extensões que indicam a execução de sub-funcionalidades necessárias para a tarefa de venda de um produto a um cliente.
A primeira refere- se à verificação do status do cartão utilizado na compra e a segunda à consulta de quantidade do produto no estoque, para a certificação de que o produto solicitado está disponível.
Em o diagrama de estados construído é possível visualizar os estados que modelam a execução das máquinas de estados EUC11 e ECU12.
Assim como em outros diagramas de estados, estados que possuem a identificação de um caso de uso diferente do que está sendo executado, indica a execução de outra máquina de estados.
UC9 -- Desabilitar cartão perdido:
Esse funcionalidade do sistema é executada quando um cliente informa ao atendente que o cartão ques estava utilizando foi perdido.
O atendente busca a identificação do cartão por o número do CPF do cliente, sendo então necessário validar o número informado (caso de uso incluído).
A o obter- se a identificação desse cartão, o mesmo ficará inapto para novas compras.
Mais detalhes sobre essa operação são apresentados na Tabela 6.9.
UC10 -- Cadastrar produto:
Esse tarefa é executada por o administrador, sendo essa responsável por o cadastramento de produtos no sistema, informando para os mesmos a quantidade disponível em estoque e a quantidade crítica de produto, que acarretará no envio de uma mensagem de alerta quando essa quantidade for atingida.
O comportamento desse caso de uso é especificado na Tabela 6.10.
O diagrama de estados descrito na Figura 6.11 pôde ser construído a partir de as informações fornecidas por a Tabela 6.10.
Por não possuir casos de uso subordinados, esse diagrama modela apenas o comportamento do caso de uso 10.
UC11 -- Consultar estoque:
Essa funcionalidade do sistema é acionada quando um atendente efetua um pedido solicitado por o cliente.
Durante a sua execução, ocasionalmente pode ser constatado que a quantidade disponível em estoque atingiu o ponto crítico, quantidade essa informada por o administrador no instante do cadastro do produto.
Essa situação é descrita na Tabela 6.11.
O envio de um alerta de quantidade, descrito por a extensão 4a da tabela, é executado em outra máquina de estados, enquanto a máquina de estados que modela UC11 permanecer no estado E4a UC13.
UC12 -- Avaliar status do cartão:
O status do cartão será avaliado no instante da consulta de um saldo consumido ou quando for efetuado um pedido de produto.
Essa avaliação executa duas operações em paralelo:
A primeira trata da impossibilidade do uso do cartão devido a uma perda informada anteriormente, e a segunda remete ao alcance de um valor limite de consumo (o que inabilita o consumo até que parte do valor consumido seja quitado).
Essa configuração é descrita na Tabela 6.12.
A execução paralela das consultas do status do cartão e do valor consumido são modelado com o uso de um fork, como pode ser observado na Figura 6.13.
Por não disponibilizar de regiões de sincronização, a modelagem dessas estruturas na ferramenta Rose da Rational deve ser composta por pares de forks e joins, ou seja, para cada fork especificado deve possuir um join que finalize a região de sincronização.
UC13 -- Enviar alerta de quantidade:
Essa funcionalidade do sistema será executada quando for detectado que a quantidade de um produto atingiu um nível crítico, sendo essa associada ao caso de uso que trata da consulta de estoque.
Como o caso de uso modelado por o diagrama de estados EUC13 não possui casos de uso subordinados, os estados modelam apenas o comportamento esperado para o caso de uso Com a especificação dos diagramas de estado que modelam o comportamento dos casos de uso de sistema, é possível aplicar o método descrito no capítulo anterior para construir a SAN equivalente para o sistema, ou para componentes do mesmo, conforme a análise desejada.
Conforme formalizado no capítulo anterior, a tradução dos diagramas de estados que descrevem o comportamento dos casos de uso do sistema pode disponibilizar uma análise para o sistema como um todo (contando aqui com a interação dos atores com o sistema) ou dos componentes do mesmo, sendo um componente uma funcionalidade disponibilizada para uma ator.
A seguir serão expostas a análises proporcionadas através do método proposto nesse trabalho, para os diagramas de estados construídos nesse estudo de caso.
Com os diagramas de estados que descrevem o comportamento esperado para o estudo de caso proposto, é possível construir uma única SAN que modele o comportamento geral do sistema, levando em conta a interação do mesmo com seus atores.
Para o estudo de caso proposto, a SAN resultante que modela esse comportamento é apresentada na Figura 6.15.
Com essa SAN é possível extrair casos de teste que sejam direcionados à validação do sistema como um todo, levando em conta a interação dos atores com todos os componentes do sistema.
Em esse instante da pesquisa foi verificado que apesar de a modelagem de um sistema inteiro em SAN ser possível, sua análise na ferramenta PEPS2003 seria inviável.
Apesar de o sistema proposto não ser complexo, a quantidade de autômatos e de estados obtida inviabiliza a análise do modelo de uso do sistema.
Para termos uma idéia, caso fôssemos modelar esse sistema em cadeias de Markov, o autômato resultante possuiria 1.274.019.840.000 estados.
Em esse ponto partiu- se para uma nova estratégia.
A análise dos casos de uso que possuem interação direta com um ator será feita conforme descrito até aqui, uma vez que a quantidade de autômatos e estados viabiliza a análise, podendo então ser fonte para testes de componente e integração, dependendo do nível de granularidade da especificação dos casos de uso.
Para a análise do sistema como um todo, é necessário um processo de simplificação dos autômatos.
Esse processo será descrito na próxima seção.
Para cada caso de uso relacionado diretamente com um ator, uma SAN deve ser construída, buscando assim modelar o comportamento do sistema quando o mesmo interage com um ator.
Em o sistema proposto, o atendente interage diretamente com quatro casos de uso, enquanto o cliente com um e o administrador com outro.
Sendo assim, nosso sistema pode ser modelado com seis SAN, sendo que casos de usos compartilhados são modelados em cada uma das SAN que utilizem- no.
Se por ventura mais de um ator compartilharem o mesmo caso de uso, não há necessidade da modelagem de uma SAN distinta para cada ator, uma vez que o caso de uso é o mesmo.
A Figura 6.16 modela a interação entre o caso de uso que trata do recebimento do pagamento com os seus casos de uso subordinados.
O atendente interage diretamente com esse caso de uso.
O componente do sistema que possibilita o cliente consultar o saldo dos produtos consumidos é modelado por a SAN descrita na Figura 6.17.
Essa SAN é composta por dois autômatos, cada um modelando um dos casos de uso que constituem esse componente.
A tarefa de inserção dos dados do cliente, efetuada por o atendente, é modelada por a SAN exposta na Figura 6.18.
Em ela pode ser observados dois autômatos, cada qual nomeado de acordo com o caso de uso que modela, sendo esses constituintes do componente que trata da inserção de dados.
A modelagem do componente responsável por desabilitar um cartão dado como perdido, tarefa também executada por o atendente, é mostrada na Figura 6.20.
Seguindo os passos descritos no capítulo anterior, é possível construir uma SAN mais enxuta, mas que ainda apresenta as informações necessárias para a análise de cobertura.
Com a execução do módulo 2, é possível obter uma nova SAN com menos autômatos e estados, porém mantendo as caracter ísticas que viabilizem a composição de testes de sistema.
Para ilustrar o passos da simplificação aplicados para o estudo de caso proposto nesse trabalho, é apresentada a Figura 6.22.
A figura mostra a SAN gerada a partir de a análise de sistema, sobre os diagramas de estados do estudo de caso, sendo destacados os estados e transições que serão substituídos por um estado equivalente.
A referida substituição é mostrada na figura, conforme previsto na simplificação N1, sendo mantidas as transições e eventos que atingem e partem do trecho seqüencial original.
A simplificação N2 é mostrada na figura, onde os estados equivalentes são substituídos por uma única transição entre os estados-chave dos autômatos.
Por fim é verificada a existência de autômatos que possuem apenas um estado, sendo que esse possua uma auto transição, e a existência de múltiplas transições entre dois estados.
Em essas situações, os autômatos com um único estado serão eliminados, e os eventos que sincronizavam a execução desse autômato serão substituídos por eventos locais.
Ainda, as múltiplas transições serão substituídas por uma única transição, sendo que essa passa a conter os eventos das transições originais.
O resultado dessas transformações são apresentadas na figura.
Com a aplicação das simplificações efetuadas na execução do módulo 2 do protótipo, uma nova SAN é concebida, sendo essa descrita na Figura 6.23, onde também são descritos os eventos, seus tipos e as taxas de ocorrência correspondentes.
O espaço total de espaços gerados nessa nova SAN é de 138.240 estados, o que torna viável a análise desse modelo na ferramenta PEPS2003.
Em o próximo capítulo são apresentadas as conclusões extraídas nesse trabalho, sendo retomado o contexto onde as soluções propostas são aplicadas.
Ainda serão expostas as limitações que a presente solução possui, sendo também sugeridas alternativas para essas limitações (trabalhos futuros).
O intuito do presente trabalho é agregar o formalismo SAN ao processo unificado de desenvolvimento de software, visando a geração de casos de teste.
A escolha da metodologia do processo unificado como base para a estruturação da presente proposta, deve- se a sua ampla utilização, por ser um processo que utiliza interações para evitar o impactos de mudanças, por ser dirigido a casos de uso, por utilizar os elementos da UML no preparo dos seus artefatos, e por definir os testes de software como uma importante fase do projeto.
De entre os estudos relacionados, alguns relatam emprego de diagramas de estados para descrever o comportamento do sistema, utilização essa sugerida no processo unificado.
A partir desses diagramas é possível compor o modelo de uso do sistema, sendo esse usado como base para a construção de casos de teste de software.
Outras técnicas utilizammétodos estatísticos para a análise, e também como base para a construção de casos de teste.
De entre essas técnicas, é descrita a utilização do perfil operacional do sistema, de onde são capturadas informações sobre probabilidade de uso e taxas de ocorrência, para a posterior construção de cadeias de Markov que representam o comportamento do software.
Apesar de as notórias vantagens apresentadas por o formalismo de cadeias de Markov, o mesmo pode apresentar limitações referentes ao espaço total de estados gerados, podendo não oferecer uma precisão necessária para a descrição de sistemas complexos.
Além disso, um modelo descrito por cadeias de Markov pode apresentar dificuldades para a legibilidade do sistema, sob a ótica de um observador humano.
O uso de SAN para a construção de casos de teste de software mostrou- se eficaz em estudos anteriores, principalmente no que tange o ganho obtido na análise de cobertura dos casos de teste construídos.
Além de propiciarem a modularização do modelo de uso do sistema, e por possibilitar a modelagem de sincronismo e paralelismo, a análise viabilizada por esse formalismo permite ainda fornecer informações que possam ser utilizadas como auxílio em tomadas de decisões, por exemplo.
Sendo assim, os diagramas de estados foram empregados como fonte de informações para a composição de autômatos constituintes de uma SAN.
De essa forma, foi formalizada a transcrição dos elementos dos diagramas de estados UML, para uma estrutura equivalente em SAN.
Para formalizar a tradução dos componentes de um diagrama de estados UML para um estrutura equivalente em SAN, foi desenvolvido um framework de transcrição.
Com essa estrutura, buscou- se detalhar a sintaxe dos elementos que constituem um diagrama de estados da UML 2.
0, o comportamento que esse elemento descreve, os detalhes da SAN que refletem esse comportamento, bem como a estrutura resultante da SAN.
Buscando obter agilidade na concepção de SAN, possibilitando assim a geração de casos de teste, foi construído um protótipo que traduz automaticamente os diagramas de estados UML, produzidos por a ferramenta Rational Rose, para uma estrutura equivalente em SAN.
O referido sistema utiliza como fonte arquivos XML, em os quais estão contidas as informações necessárias para a tradução.
A possibilidade de construção de SAN que, devido a o elevado número de autômatos e estados, sejam inviáveis para a análise na ferramenta PEPS2003, levou à composição de um módulo para simplificação das referidas SAN, onde as características comportamentais e a interação entre funcionalidades do sistema foram mantidas.
Tendo como meta demonstrar a referida tradução, foi proposto um estudo de caso, onde fosse possível utilizar os elementos constituintes de um diagrama de estados para a sua descrição comportamental.
Esse sistema foi especificado desde a descrição do seu domínio, passando por a especificação dos casos de uso, bem como por os diagramas de estados que descrevessem o seu comportamento, culminando na construção de SAN que representasse o modelo de uso do sistema.
Para esse exemplo, foi exposta a possibilidade da composição de modelos SAN que descrevam o comportamento do sistema como um todo (análise de sistema), onde a interação dos atores incorpora informações sobre a utilização do sistema.
Outra análise evidenciada é aquela onde cada funcionalidade do sistema, disponibilizada diretamente para um ator, possibilita a construção de uma SAN específica (análise de componente).
Sobre as limitações do presente estudo, verificou- se a ausência de determinados elementos dos diagramas de estados por parte de a ferramenta Rational Rose, sendo que esses são especificados na UML ser formalizada no framework descrito nesse trabalho.
Outra limitação refere- se aos tipos de casos de teste viabilizados, tendo como fonte de informações os diagramas de estados.
Logo, a eficácia dos teste gerados depende diretamente do nível de granularidade usado na especificação dos diagramas.
Ainda assim, não é assegurada a elaboração casos de testes que cubram todos os trechos do código, o que sugere a utilização de outros diagramas (ou outros artefatos) que forneçam tais informações.
No que se refere a possíveis trabalhos futuros, sugere- se a inclusão de um módulo que disponibilize automaticamente eventuais informações não contempladas na SAN, sendo essas necessárias para a construção dos casos de teste na ferramenta STAGE-Model, que atualmente são inseridas manualmente.
Sugere- se também a inclusão de mecanismos para o tratamento de eventuais condições de guarda existentes em transições dos diagramas de estados.
Isso seria feito através da inclusão de autômatos na SAN que modelem as possíveis restrições impostas por as condições de guarda, sendo que uma transição só seja habilitada mediante a avaliação do autômato que modela essas restrições (utilização de taxas funcionais).
Por fim, sugere- se ainda um estudo sobre a agregação de outros dia119 gramas da UML que possibilitem a construção de casos de teste mais refinados, incrementando assim a cobertura dos mesmos.
