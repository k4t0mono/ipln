Este trabalho disserta sobre o desenvolvimento de aplicações distribuídas envolvendo mobilidade de código, abordando aspectos relativos à especificação formal, simulação e geração de código.
Maior ênfase é dada ao mapeamento da linguagem de especificação formal adotada para código executável sobre uma plataforma de suporte à mobilidade de código.
O formalismo utilizado é uma forma restrita de Gramáticas de Grafos, chamada de Gramáticas de Grafos Baseada em Objetos (GGBO).
Em GGBO, sistemas são descritos por entidades e suas relações, sendo que cada entidade possui uma lista de regras que descrevem o seu comportamento.
A partir de um mapeamento prévio de entidades e regras de GGBO para um ambiente de simulação, foram realizadas modificações que permitiram executar os sistemas especificados num ambiente real, utilizando recursos de uma plataforma de suporte para tornar possível a movimentação de entidades.
O mapeamento usado para a geração de código a ser executado foi avaliado através da realização de testes e de uma aplicação exemplo.
Estudos de caso envolvendo redes ativas e um algoritmo de roteamento para redes ad hoc foram especificados em GGBO, tiveram seus comportamentos simulados e seus códigos gerados e executados num ambiente distribuído.
Contexto Com o contínuo crescimento das capacidades de comunicação e processamento, impulsionado por avanços tecnológicos e por o aparecimento da Internet, surgiram ambientes computacionais que se caracterizam por a grande distribuição geográfica, por a sua alta heterogeneidade e dinamismo, por a inexistência de controle global, por a ocorrência de falhas parciais e por a falta de segurança.
Dados o ambiente caracterizado e as necessidades atuais de usuários, os sistemas passaram a ser compostos por um conjunto de componentes que se comunicam e executam em máquinas diferentes.
Outra característica observada é a abertura de sistemas.
Por sistema aberto entende- se, no contexto deste trabalho, um sistema autônomo quanto a a sua execução, com ciclo de vida independente de outros sistemas (o que significa que ele pode não estar disponível em alguns momentos, caracterizando o seu dinamismo) e que possui capacidade de comunicação com os demais sistemas.
Essa capacidade de comunicação com sistemas sobre os quais ele não tem, a priori, informação alguma é que o define como aberto.
Em este trabalho, denomina- se um ambiente com as características citadas anteriormente, onde sistemas abertos coexistem, podendo interagir, como um ambiente aberto.
Caracterização de Sistemas Distribuídos com Código Móvel Em sistemas distribuídos tradicionais, normalmente, os componentes permanecem no mesmo nodo da rede por todo o seu ciclo de vida, sendo, portanto, componentes estáticos.
As interações entre estes componentes ocorrem através da troca de mensagens via rede, geralmente utilizando mecanismos tais como RPC (Remote Procedure Call) ou RMI (Remote Method Invocation).
Com o aumento da conectividade entre sistemas e seus componentes, conforme o contexto apresentado na Seção 1.1, alguns efeitos colaterais podem ser notados.
Um desses efeitos colaterais diz respeito ao aumento de tráfego na rede, devido a a intensa comunicação remota.
Além disso, as redes tornam- se cada vez maiores, trazendo o problema da escalabilidade de sistemas.
Ou seja, alguns sistemas que produzem bons resultados em pequenas redes, tornam- se não aplicáveis num ambiente de larga escala como a Internet.
O uso cada vez maior de computadores móveis também traz a necessidade do aumento de flexibilidade, a fim de que estes nodos dinâmicos possam ser suportados.
Os problemas expostos trazem algumas exigências quanto a a construção de sistemas distribuídos para suprir as necessidades atuais de usuários.
Algumas características que devem estar presentes num sistema distribuído atual, destacadas em, são:
A partir de os requisitos apresentados e da impossibilidade de sistemas que utilizam a abordagem Cliente-Servidor de suprirem tais requisitos, surgiram os sistemas distribuídos com código móvel (SDCM), que são sistemas abertos que envolvem o conceito de mobilidade de código, também chamados de aplicações móveis.
A tecnologia de mobilidade de código permite que trechos de código possam se mover entre nodos de uma rede.
Com isso, além de os sistemas terem componentes distribuídos, eles também podem conter componentes móveis, os quais podem executar em locais diferentes em cada momento.
Um outro conceito envolvendo mobilidade de código é o de agente móvel.
Um agente móvel é um componente móvel que possui, como principal característica, a sua autonomia.
Um agente móvel é autônomo quanto a sua execução e quanto a a tomada de decisão de quando e para onde se mover para cumprir as tarefas que lhe competem.
A mobilidade de código trouxe a possibilidade de diminuir- se o tráfego na rede causado por execuções remotas, como numa arquitetura Cliente-Servidor, por exemplo, onde um cliente faz requisições a um servidor, possivelmente remoto, que as processa e retorna o resultado a este cliente.
Em vez de isso, agora o cliente pode enviar um componente, que carrega todos os dados que devem ser processados para o local onde está o servidor.
Depois disso, toda a comunicação passa a ser realizada localmente, economizando o uso dos recursos de comunicação.
A possibilidade de mover- se o componente para o lugar onde está o recurso necessário a sua execução permite o aumento no compartilhamento de recursos disponíveis na rede, já que múltiplos componentes podem ser movidos para o mesmo local a fim de utilizar o mesmo recurso.
Componentes móveis fornecem a capacidade de processamento distribuído sobre a rede, além de a flexibilidade de configuração do sistema, visto que novos componentes podem ser movidos e incorporados a um nodo e, através de sua interface, passar a prover novos serviços.
Operações desconectadas também são viabilizadas por o uso de mobilidade de código.
De essa forma, pode- se enviar um componente para executar uma determinada tarefa num local remoto e desconectar da rede, recuperando- se o componente com o resultado da tarefa realizada tempos depois.
A partir de os benefícios do uso de mobilidade citados, as principais áreas de aplicação de SDCM são:
Controle e configuração dinâmica de dispositivos;
Gerência de redes;
Recuperação de informações distribuídas;
Serviços avançados de telecomunicações;
Gerência de workflow;
Comércio eletrônico;
E redes ativas.
Novos nichos de utilização para mobilidade de código vêm sendo pesquisados e outras possíveis aplicações deverão ser conhecidas mais adiante.
Todas as características advindas da abertura e distribuição dos sistemas, somadas às possibilidades fornecidas por a mobilidade de código, se, por um lado, tornaram os sistemas bastante flexíveis e poderosos, por outro lado, também tornaram bastante complexa a tarefa de desenvolver sistemas para tais ambientes.
Isto se deve, principalmente, à grande dificuldade de encontrar e corrigir erros em sistemas que possuem componentes que executam de forma distribuída e que podem modificar sua localização.
Devido a a carência de suporte ao desenvolvimento de SDCM, esforços e pesquisas têm sido feitos para fornecer tal suporte.
Um exemplo é o monitor descrito em e que busca, através da monitoração de componentes móveis que executam na rede, fornecer informações relevantes ao desenvolvedor para auxiliar- lo no processo de teste e depuração de seu sistema.
Existe ainda um ambiente de modelagem e simulação apresentado em, que emprega o uso de simulação para a depuração de sistemas.
Outros trabalhos seguem a abordagem de utilização de uma linguagem de especificação formal (LEF).
A utilização de uma LEF permite gerar- se uma descrição precisa de um sistema numa notação com sintaxe e semântica bem definidas.
Esta semântica associa um modelo matemático ao sistema que pode, então, ser analisado usando- se técnicas de verificação formal.
De essa forma, pode- se testar e provar, matematicamente, que um sistema possui certas características.
Entre os trabalhos que utilizam esta abordagem podem ser citados:
Mobile UNITY, que apresenta uma notação para descrição de componentes e uma linguagem para descrever a interação entre eles;
Ambit, em o qual é empregada a idéia de ambientes, onde um ambiente é um componente delimitado onde podem ocorrer computações;
MobiS, que é uma linguagem de especificação baseada em múltiplos espaços de tuplas;
E SCD, que utiliza uma variante de Redes de Petri para modelar sistemas.
Existem ainda linguagens de programação que se baseiam no formalismo de Cálculo-, o qual é um modelo de computação concorrente em que os componentes são processos e canais, sendo os últimos usados para comunicação entre processos.
Em este modelo, a localização de um processo é dada por a configuração de seus canais num dado instante de tempo.
A mudança nesta configuração determina a sua movimentação.
Uma outra abordagem utilizando uma LEF foi proposta em, como parte do projeto ForMOS (Métodos Formais para Código Móvel em Sistemas Abertos) 1, o qual envolve o desenvolvimento e adaptação de métodos e ferramentas de especificação, simulação, verificação e geração de código para SDCM.
Em a abordagem apresentada neste projeto, o formalismo de Gramáticas de Grafos é utilizado para a especificação de SDCM.
Este formalismo utiliza uma linguagem visual de especificação baseada em conceitos bastante simples e que, por ser formal, possibilita realizar- se a verificação de propriedades do sistema.
Este formalismo teve seus elementos básicos mapeados para entidades de um ambiente de simulação de Gramática de Grafos existente, o qual gera código para simulação de sistemas descritos nesse formalismo.
Ferramentas de verificação formal estão em estudo e deverão permitir a obtenção de Parcialmente financiado por o CNPq, ProTeM-Laboratórios e FAPERGS.
Este trabalho3 insere- se no ForMOS, onde a sua principal contribuição inclui a geração de código executável a partir de especificações feita na LEF.
Este código é gerado numa linguagem de programação para uma plataforma de suporte à mobilidade de código.
Portanto, o objetivo principal desta dissertação de mestrado, é a criação de uma forma de gerar código para SDCM a partir de uma especificação na LEF adotada no projeto ForMOS.
Como forma de atingir o objetivo principal, este trabalho também realizou outras contribuições para o projeto ForMOS.
Entre estas contribuições está o uso da LEF adotada no projeto, o que permitiu criticar esta linguagem e identificar algumas possibilidades de melhorias.
Também o uso do simulador de Gramáticas de Grafos utilizado no projeto gerou algumas contribuições.
Foi realizada, neste trabalho, uma extensão no simulador, a qual permite que especificações de SDCM possam ser mapeadas para código de simulação e, assim, torna- se possível realizar simulações para este tipo de sistema no ambiente existente.
Assim como ocorreu com a LEF, o uso do simulador possibilitou a identificação de deficiências do simulador e a ausência de algumas funcionalidades necessárias pôde ser percebida.
Com isso, foram realizadas melhorias no funcionamento do simulador e novas características foram adicionadas, tornando- o um ambiente mais propício à realização de simulações de especificações feitas na LEF do projeto, principalmente, para simulações de especificações de SDCM.
A realização de um estudo de caso, em o qual foram utilizadas as ferramentas desenvolvidas no projeto, permitiu não só gerar as contribuições acima relatadas, mas também avaliar o mapeamento da LEF para código executável.
Este estudo de caso visou abranger todas as ferramentas trabalhadas no projeto ForMOS, como forma de avaliar a sua utilização e de que forma elas contribuem para o desenvolvimento de sistemas que envolvem mobilidade de código.
Em este trabalho, código executável significa um código a ser executado num ambiente real.
Financiado por a Capes.
Este volume apresenta, no Capítulo 2, o referencial teórico, contemplando os assuntos mais importantes do trabalho:
Mobilidade de código e especificação formal.
Em o utilizado.
Em o Capítulo 5, trata- se sobre a questão da geração de código e todos os passos seguidos para gerar código para SDCM a partir de especificações formais na LEF adotada.
Este referencial teórico apresenta os dois principais assuntos envolvidos neste trabalho, que são mobilidade de código e especificação formal.
Cada um dos assuntos é apresentado abordando- se os principais conceitos e o suporte existente.
Mobilidade de Código Em esta seção serão apresentados os conceitos básicos envolvendo mobilidade de código.
Além disso, discute- se sobre as linguagens de programação e as plataformas de suporte a código móvel.
Conceitos Básicos Mobilidade de código pode ser definida como a capacidade de um componente de software de poder mover- se entre nodos de uma rede.
A mobilidade de código deriva da idéia de migração de processos, que diz respeito à transferência de processos de sistema operacional das máquinas em que estão executando para outras, com a intenção, em geral, de prover tolerância a falhas e balanceamento de carga.
A diferença entre migração de processos e mobilidade de código é que, na primeira, a movimentação de um componente (processo) é definida por o sistema operacional distribuído, ocorrendo transparentemente ao desenvolvedor da aplicação, enquanto que, na segunda, a movimentação é definida por o usuário, o qual determina o momento da movimentação e o destino da mesma.
Ou seja, com a mobilidade de código, não existe a transparência de movimentação presente na migração de processos.
Em, são propostas definições para discutir sobre mobilidade.
Algumas dessas definições são aqui utilizadas para apresentar conceitos pertinentes.
Assim, segundo a classificação proposta por, existem duas formas de mobilidade de código:
Mobilidade forte:
Quando um componente4 se move, é movido o seu código e seu estado de execução (valores de atributos internos, ponteiro de instruções, pilha de execução, etc), possibilitando que, ao chegar ao destino, a execução possa ser O termo componente, aqui usado, refere- se a uma estrutura de software que encapsula dados e um comportamento e que pode conter atividade interna (thread interna em execução).
Mobilidade fraca:
Quando o componente se move, é movido apenas o seu código e os valores de seus atributos internos.
Dados de inicialização podem acompanhar a movimentação (tal como um ponto de entrada no código, a partir de o qual o componente deve executar), mas não existe a movimentação do estado de execução.
Mecanismos que suportam mobilidade fraca fornecem a capacidade de mover- se um código entre nodos da rede, podendo- se realizar uma ligação dinâmica deste com um componente já existente no destino ou executar- lo como um novo componente.
Para o suporte à mobilidade forte, segundo, existem dois mecanismos:
Migração e clonagem remota.
Através do mecanismo de migração, quando se inicia o processo de movimentação, é realizada a suspensão da execução do componente que irá se mover.
Este, depois de suspensa a sua execução, é transmitido ao destino e sua execução é então retomada.
Já através do mecanismo de clonagem remota, não é realizada a movimentação do próprio componente.
Em vez de isso, quando se inicia o processo de movimentação, é criada uma cópia do componente no destino.
O estado de execução na origem é transmitido para a cópia criada e esta passa a executar como o componente original.
De essa forma, a cópia no destino assume o lugar do componente original.
Os mecanismos descritos acima podem ocorrer de forma proativa ou reativa.
Quando a movimentação é proativa, o momento e o destino da movimentação são determinados de forma autônoma por o próprio componente.
Em a movimentação reativa, o processo de movimentação do componente é disparado por outro componente, o qual possui o controle de movimentação do componente que se move.
Com o surgimento da tecnologia de código móvel, surgiram também três novos paradigmas de programação.
Tais paradigmas são apresentados em, sendo diferenciados de acordo com a localização dos componentes envolvidos antes e depois da execução de um serviço, o componente responsável por a execução do código e o local onde a computação realmente ocorre.
Os paradigmas identificados são os seguintes:·
Avaliação Remota:
Em o paradigma de Avaliação Remota, um componente C1 possui o código para realizar um serviço, mas não possui os recursos necessários, onde um recurso representa um elemento de dados passivo, como um arquivo ou uma impressora, um dispositivo de rede ou qualquer outro dispositivo físico.
Tais recursos estão num local remoto L2, onde um componente C2 está executando.
C1 então envia o código para o componente C2 para que este o execute usando os recursos locais.
A o final da execução, C2 retorna os resultados para C1;·
Código por Demanda:
Em o paradigma de Código por Demanda, um componente C1 possui os recursos de que precisa para executar um serviço no local L1 onde se encontra.
No entanto, C1 não possui o código para utilizar estes recursos.
Por isso, C1 interage com um componente C2, localizado num local L2, o qual possui o código necessário.
De essa forma, C1 requisita o código de C2, que o envia a C1.
A o receber o código requisitado, C1 pode então executar o serviço com os recursos locais;·
Agentes Móveis: Em o paradigma de Agentes Móveis, um componente C1, executando num local L1, possui o código para executar um serviço, mas os recursos necessários estão num local L2.
C1 então se move para L2 carregando com si o código para executar o serviço.
Após a movimentação, o componente C1, agora executando em L2, realiza o serviço com os recursos locais.
Como pode ser visto, o foco dos paradigmas de Avaliação Remota e Código por Demanda está na transferência de código entre componentes, enquanto que, no paradigma de Agentes Móveis, é o componente, juntamente com seu estado e o código necessário, que é transferido para o local onde estão os recursos.
A partir de o paradigma de Agentes Móveis, criou- se o conceito de agente móvel.
A denominação de agente móvel está associada ao fato de que este tipo de componente incorpora características de agentes.
Um agente é definido como uma entidade computacional que trabalha em favor de outras entidades de forma autônoma e que realiza ações proativas e/ ou reativas.
Portanto, um agente móvel possui tais características de agentes, com o acréscimo da sua capacidade de mobilidade.
Segundo a definição apresentada em, &quot;um agente móvel é um componente autocontido, responsável por a execução de uma atividade, que é capaz de, autonomamente, migrar através de uma rede».
Com isto, tem- se que um agente móvel é uma forma de código móvel com autonomia de execução e movimentação.
Um agente móvel possui, portanto, a capacidade de decidir quando e para onde se mover para cumprir a tarefa que lhe foi confiada, assumindo movimentação proativa.
Linguagens de Programação O desenvolvimento do conceito de mobilidade de código e o surgimento de aplicações que utilizam esta tecnologia foram, em grande parte, proporcionados por a existência de linguagens de programação que possuem mecanismos de suporte à movimentação de código.
Tais linguagens são diferenciadas de outras linguagens de programação por um conjunto de propriedades essenciais.
Estas propriedades definem uma base mínima para a construção de aplicações móveis.
Segundo, tais propriedades são as apresentadas a seguir.
Para suportar o trabalho com componentes que contêm código, a linguagem deve fornecer uma forma de identificação desses componentes, a fim de diferenciar um componente de outro.
Primitivas ou uma biblioteca de funções com as quais seja possível ao desenvolvedor expressar que um dado componente deve ser transmitido, também é um requisito importante.
Além disso, é necessário que a linguagem forneça suporte à execução de componentes recebidos dentro de o espaço de endereços do receptor.
Isto é, o componente recebido deve ser executado utilizando os recursos locais do receptor.
É também desejável que a linguagem forneça construções e abstrações que permitam a total manipulação de código dentro de a própria linguagem.
A heterogeneidade é uma característica de sistemas distribuídos e, portanto, deve ser considerada numa linguagem que deve suportar a transmissão de código entre diferentes nodos da rede, os quais podem estar executando sobre diferentes sistemas computacionais.
As linguagens devem, portanto, suportar a transmissão de componentes entre máquinas de diversas arquiteturas, de modo a permitir a construção de aplicações mais adaptadas às características dos ambientes atuais, tais como a Internet, onde uma grande variedade de hosts, executando sobre sistemas heterogêneos, coexistem e comunicam- se entre si.
Quanto a o desempenho, é desejável que a implementação da linguagem minimize, tanto quanto possível, os custos de espaço e tempo gastos no uso de componentes móveis.
Componentes móveis consomem tempo e espaço devido a o seu tamanho, tempo de transmissão, tempo necessário para converter- lo em sua forma executável, etc..
Estes custos devem ser baixos o suficiente para que o uso de mobilidade de código não deixe de ser vantajoso para a aplicação.
Ou seja, a implementação dos mecanismos de movimentação de componentes não deve tornar- se um fator de grande influência no desempenho geral da aplicação.
Caso contrário, torna- se prejudicial à aplicação a sua construção considerando componentes que se movem, sendo assim preferível construir- la usando outras técnicas mais tradicionais.
Outra característica que pode ser considerada é a segurança, já que um componente móvel transita entre diversos domínios.
Por isso, um cuidado especial deve ser tomado para fornecer proteção contra ameaças à segurança provenientes de aplicações móveis.
Algumas das medidas de segurança, segundo discutido em, são a garantia da integridade de dados privados, impedindo a sua modificação por componentes não autorizados, e garantia de autenticidade das identidades de entidades que se comunicam, assegurando que é possível confiar que os dados transmitidos são encaminhados ao seu destino correto.
Algumas das linguagens de programação que possuem suporte à criação e uso de componentes móveis são apresentadas em.
De entre as linguagens existentes, a mais utilizada é a linguagem Java, da Sun MicroSystems.
Por sua portabilidade e heterogeneidade, Java tem sido utilizada na construção de sistemas distribuídos e tem servido de base para a criação de plataformas de suporte à mobilidade de código.
Isto porque, seguindo a característica de portabilidade de Java, o código é interpretado em cada local em que é recebido, provendo a possibilidade de movimentação também entre máquinas heterogêneas.
Além disso, Java também possui mecanismos de serialização e desserialização de objetos, tornando possível a transmissão de código entre diferentes hosts.
Existem também mecanismos de suporte à ligação dinâmica de código, muito utilizados na execução das applets, que são aplicações Java que podem ser transmitidas juntamente com uma página Html para execução num local remoto.
Baseando- se nas linguagens de programação existentes com suporte à mobilidade de código, surgiram as plataformas de suporte à mobilidade (PSM).
Essas plataformas fornecem bibliotecas para as linguagens de programação em que são implementadas, provendo operações para movimentação de código.
Assim, as PSM implementam os mecanismos de movimentação na linguagem de programação que estendem e fornecem uma biblioteca de funções para a utilização desta implementação.
De essa forma, o desenvolvedor não se ocupa em implementar os mecanismos de movimentação, já providos por a PSM, e pode dedicar- se exclusivamente à aplicação que deve ser desenvolvida.
Segundo apresentado em, são requisitos básicos de uma plataforma de suporte à mobilidade prover as funções apresentadas a seguir.
Cada host que pretende receber componentes móveis deve prover um ambiente de execução para o mesmo, fornecido por uma plataforma.
A função mais básica de uma plataforma é fornecer serviços de movimentação de componentes.
A movimentação de um componente envolve suspender a sua execução, salvar seu estado e transmitir- lo a um local remoto.
A plataforma executando no local remoto deve, então, ser capaz de restaurar o estado do componente e reativar sua execução.
O estado de um componente inclui todos os seus dados internos, bem como o estado de execução de sua thread.
O estado de execução da thread é representado, num nível mais inferior, por seu contexto de execução e por sua pilha de execução.
Caso seja possível transmitirem- se estes dados juntamente com o componente, torna- se viável restaurar a sua execução no destino exatamente no ponto onde ela foi paralisada antes da movimentação.
Em a impossibilidade de capturar os dados neste nível mais baixo, uma alternativa é obter- se o estado de execução em nível de função, sendo que o código do componente deve prover alguma maneira de retomar o fluxo da execução no destino.
Isto pode ser feito através da definição de um ponto de entrada no código, que pode ser representado por a invocação de uma função do componente.
Com isso, ao chegar ao destino, esta função do componente é ativada.
Portanto, o desenvolvedor deve descrever nesta função qual comportamento deve ser seguido para a retomada da execução do componente.
Além de o estado de execução do componente, também deve ser provida uma forma de transferir o seu código.
Quanto a isso, existem três possibilidades:
O componente leva seu código com si ao se mover;
O código do componente encontra- se previamente instalado no local de destino;
Ou o componente ou o próprio local de destino possui uma referência a uma base de código de onde o local de destino pode obter o código necessário.
A primeira possibilidade é a mais desejável, já que possibilita que o componente execute em qualquer lugar onde haja uma plataforma que permita a sua execução.
Entretanto, exige o suporte à transferência real do código do componente juntamente com seu estado de execução.
A segunda possibilidade exige que o código seja pré-instalado em cada local por onde o componente possa passar, restringindo o domínio de atuação do componente.
A terceira e última possibilidade utiliza a idéia de código por demanda.
Ou seja, quando termina a movimentação dos dados do componente, o local de destino requisita de uma base de código o código necessário para a execução do componente recebido.
Esta opção supera um dos problemas da opção anterior, já que não é necessário ter o código instalado em todos os possíveis locais a serem visitados por um componente.
Em compensação, exige a existência de uma base de código que possa receber requisições de lugares (que são locais onde componentes podem executar) e exige que estes ou os componentes recebidos por estes possuam uma referência a uma base de código.
Além disso, problemas de falhas na base de código e escalabilidade de cada base de código devem ser considerados.
Também se exige a manutenção das bases de código para que possuam sempre os códigos corretos e atualizados.
Para isso, é necessário o estabelecimento de mecanismos de registro e identificação dos diversos códigos.
Cada entidade (componente ou lugar) num sistema deve ser identificada de uma forma a ser diferenciada de qualquer outra entidade.
Isto permite que componentes e lugares comuniquem- se entre si e que seja possível ao desenvolvedor acompanhar a execução de seus componentes.
Identificações também são úteis para determinar o destino de uma movimentação, tornando possível especificar a identificação do destino da movimentação ou, como ocorre em algumas plataformas, fornecer a identificação de um componente com qual seja necessário comunicar- se.
Em este último caso, o componente que se move é transferido para o local onde se encontra o componente com o qual ele deve interagir.
Outro mecanismo que deve ser fornecido por a plataforma e que utiliza a identificação única de componentes é a localização de componentes e lugares.
Assim, deve ser possível obter a localização de qualquer componente ou lugar dada a sua identificação, ao que se dá o nome de resolução de identificadores ou resolução de referências, no caso de as entidades serem identificadas por referências.
A resolução de referências fornece transparência de localização, já que não é necessário saber onde determinado componente está para que se possa interagir com ele.
Em algumas plataformas, as identificações ou referências são fornecidas com base no hostname e em números de portas, sendo identificações dependentes de localização.
Em estas plataformas, o nome do componente se modifica a cada movimentação, exigindo que sejam providos nomes com transparência de localização no nível de aplicação.
Tais plataformas usam um esquema de proxies locais.
Uma proxy é uma estrutura que possui a mesma interface do componente que ela referência e que encapsula a localização atual do componente.
Em este caso, todas as comunicações direcionadas ao componente são encaminhadas a sua proxy, a qual repassa as mensagens ao componente no seu local de execução atual.
A outra possibilidade de resolução de referências envolve o uso de nomes globais, independentes de localização.
Em plataformas que usam este tipo de resolução de referências, os nomes dos componentes não se modificam quando estes se movem.
Em este caso, devem ser providos servidores de nomes, os quais têm a função de mapear nomes simbólicos para a localização atual da entidade.
Além disso, cada componente, ao se mover, deve atualizar a informação de sua localização nos servidores onde esteja registrado.
Deve ser garantida a integridade dos dados e código de componentes trafegando na rede e a integridade dos lugares por onde os componentes passam e com os quais eles se comunicam.
Partes de um componente devem poder ser mantidas em sigilo, exigindo que haja mecanismos para selecionar quais porções do componente podem ser visualizadas e/ ou modificadas por outros componentes ou lugares.
Caso haja falhas na segurança, também deve haver uma forma de verificar que ocorreu alguma alteração nos dados ou no código do componente.
Mecanismos de criptografia podem ser utilizados para fornecer comunicação segura na transmissão de componentes através da rede.
Quando um componente requisita a sua transferência para um outro lugar, deve ser possível a este lugar verificar, com algum tipo de autenticação, a veracidade da identificação do componente, a fim de decidir receber- lo ou não e, caso o receba, quais direitos lhe serão dados quanto a sua execução no ambiente local.
Adicionalmente, podem ser fornecidos mecanismos para suportar alguma forma de contabilização de recursos utilizados por componentes móveis, tais como tempo de CPU, espaço de armazenamento, etc..
Isto possibilitaria que os componentes trafegassem com uma certa quantia de créditos que pudessem ser utilizados para &quot;pagar «por os recursos a serem utilizados.
Muitas das PSM existentes foram criadas sobre a linguagem Java.
Em geral, as bibliotecas construídas sobre Java suportam a resolução de referências utilizando o conceito de proxy para prover independência de localização.
A proxy possui, em sua estrutura, uma interface do componente (que, no caso de Java, é um objeto) que ela referência, e a informação da localização atual deste componente, permitindo que ela possa receber ativações de métodos do componente e, caso sejam válidas (sejam relativas a métodos constantes na interface pública do objeto Java), encaminhe- as ao componente em questão.
Voyager é uma das plataformas implementadas em Java, desenvolvida por a ObjectSpace, Inc..
Esta plataforma tem sido bastante utilizada na construção de aplicações móveis.
Voyager utiliza proxies para realizar a resolução de referências.
Assim, todo componente remoto em Voyager é referenciado por uma proxy.
Utilizando a resolução de referências da PSM, quando uma mensagem é enviada a um componente, esta é recebida por a proxy do componente.
Caso o componente de destino da mensagem esteja no mesmo local do componente que enviou a mensagem, a comunicação ocorre como uma mensagem Java comum (mensagem é enviada através de uma chamada local de método).
Se o componente que enviou a mensagem e o componente de destino estiverem em locais distintos, a mensagem é recebida por a proxy do destinatário e uma cópia dos argumentos da mensagem é serializada e enviada através da rede.
A o chegar a seu local de destino, os argumentos são desserializados e recebidos por o componente de destino, que realiza as ações necessárias.
A Figura 1 apresenta uma situação onde um componente localizado num local 1 gera uma mensagem para outro componente localizado num local 2.
Esta mensagem é recebida localmente por a proxy do componente de destino.
O argumento arg é serializado e a mensagem é repassada ao componente remoto.
Este desserializa o argumento e processa a mensagem.
O processamento da mensagem gera um valor de retorno que é serializado e passado por o componente para a proxy.
A proxy desserializa o valor de retorno e o repassa para o componente que gerou a mensagem.
Caso alguma exceção tivesse ocorrido no processamento da mensagem no destino, o aviso de ocorrência de exceção seria feito da mesma forma que ocorre com o valor de retorno.
Por esse esquema de resolução de referências, todo componente precisa possuir uma interface definida e todo componente que queira se comunicar com outro componente deve obter uma proxy local deste.
A plataforma Voyager suporta mobilidade fraca com movimentação através do mecanismo de clonagem remota, conforme classificação citada na Seção 2.1.1.
Isto significa que, ao mover- se, um componente tem uma cópia sua gerada no local de destino da movimentação, a qual possui o estado interno igual ao estado interno atual do componente original.
De essa forma, quando um componente se move, é criado um clone deste no destino e este clone é inicializado com o mesmo estado do componente original e, posteriormente à movimentação, o clone assume lugar deste.
Durante a movimentação de um componente, todas as mensagens encaminhadas a ele são suspensas.
O componente é serializado e copiado para o destino e, somente após a cópia tornar- se verdadeiramente o componente ao final da movimentação, as mensagens suspensas são processadas no novo local.
A movimentação de um componente causa a necessidade de alteração de suas referências.
Isto é feito através de um mecanismo chamado forwarder.
A o se mover, um componente deixa, no seu local de origem, uma informação de qual é o seu novo endereço.
Em a Figura 2, é apresentada uma situação onde um componente C1, localizado num lugar L1, comunica- se com um componente remoto C2, localizado em L2, através da proxy deste último.
Em a Figura 2.
A, a comunicação ocorre normalmente, com o envio da mensagem de C1 e seus argumentos para a proxy local, que repassa a mensagem para o componente C2 em L2.
Quando C2 se move para L3, é criado um forwarder em L2, contendo o novo local de C2.
Com isso, quando uma nova mensagem é enviada a C2, ela é encaminhada por a proxy a L2.
A o chegar em L2, a mensagem é recebida por o forwarder, gerando o retorno de uma exceção contendo o novo endereço de C2 (Figura 2.
B). A proxy então atualiza a sua referência a C2 para o lugar L3 e encaminha a mensagem ao seu destino (Figura 2.
C). A partir de aí, a comunicação ocorre como normalmente.
Voyager oferece duas possibilidades de componentes móveis:
Objetos móveis, que possuem movimentação reativa (têm sua movimentação disparada por outro componente, o qual controla sua movimentação), e agentes móveis, que possuem autonomia de movimentação, assumindo uma movimentação proativa.
Para restaurar o estado de um componente móvel após a sua movimentação, Voyager utiliza a definição de uma função que serve como ponto de entrada para a retomada da execução.
Assim, o desenvolvedor deve definir uma função a ser ativada quando a movimentação for finalizada.
Caso nenhuma função deste tipo seja definida, o componente passa a estar passivo após uma movimentação, esperando por uma ativação futura.
Voyager também fornece a opção de criar um gerente de segurança (Voyager Security Manager) com o qual é possível definir restrições quanto a a execução de certas operações de componentes.
Especificação Formal Em esta seção, são apresentados os conceitos básicos relativos à especificação formal.
A o final, é discutido, sucintamente, o uso de especificação formal para descrever sistemas distribuídos e SDCM.
Conceitos Básicos Uma especificação é uma descrição de alto nível (abstrata) do sistema a ser construído, a qual deve ser compacta, precisa e não ambígua.
Uma especificação formal é uma descrição de um sistema feita numa linguagem com sintaxe e semântica precisamente definidas;
Ou seja, definidas utilizando- se conceitos matemáticos.
Esta descrição é feita utilizando- se uma linguagem de especificação formal (LEF).
Dada uma especificação formal do sistema, pode- se provar a existência ou não de propriedades ou características neste sistema.
Esta prova é feita através de uma abordagem de verificação formal.
A verificação formal consiste em utilizarem- se técnicas matemáticas para assegurar- se que um sistema computacional apresenta algumas propriedades.
Mesmo que técnicas de verificação não sejam empregadas, a especificação formal do sistema ajuda no seu desenvolvimento por oferecer uma maneira não ambígua de descrevêlo.
Por descrição não ambígua, entenda- se uma descrição que é clara e precisa o suficiente, utilizando- se para isso de uma linguagem formal, para permitir apenas uma única interpretação do sistema descrito.
Esta interpretação única nem sempre é fornecida por descrições feitas em linguagem natural, onde diferentes interpretações podem gerar diferentes resultados.
Aplicações Pode-se dizer que a especificação formal de sistemas não possui uma aplicação específica.
Ela pode ser empregada na descrição de aplicações de controle de sistemas de produção ou para permitir a verificação formal de sistemas que envolvam algum risco caso não estejam corretos, tais como, sistemas para hospitais, usinas nucleares, experimentos químicos, entre outros.
Existem trabalhos que utilizam formalismos para desenvolvimento de microcódigos, como o do processador Motorola 68020, por exemplo.
Além disso, em é apresentada a utilização de verificação formal, a partir de a descrição do sistema numa LEF, para o desenvolvimento de software industrial.
Existe ainda a possibilidade de aplicação de especificação formal em sistemas de controle, como discutido em, entre outras.
O uso de especificação formal pretende prover sistemas de maior qualidade e maior confiabilidade, principalmente com o auxílio de ferramentas de verificação formal, sem, no entanto, aumentar os custos de desenvolvimento e, talvez, até diminuindo- os.
Apesar disso, existem argumentos contra a utilização de formalismos, alguns de eles discutidos em.
Um desses argumentos diz respeito às notações das LEF, as quais, na maioria das vezes, exigem familiaridade com conceitos matemáticos e lógica simbólica.
Isto cria a necessidade de treinamento de pessoal para trabalhar com estes formalismos, já que a maior parte dos desenvolvedores atualmente não possui conhecimentos sobre as LEF disponíveis.
LEF para Sistemas Distribuídos e SDCM A especificação de sistemas distribuídos requer técnicas que possam auxiliar no tratamento de seus problemas mais comuns, como acesso a recursos compartilhados, comunicação entre processos remotos e alocação, replicação e migração de componentes.
Existem hoje inúmeras LEF que podem ser utilizadas para a descrição de sistemas distribuídos, algumas de elas apresentadas em.
Entre as LEF existentes, SDL (Specification and Description Language) e CSP (Communicating Sequential Processes).
Além de essas, pode- se ainda utilizar Gramáticas de Grafos como um formalismo para descrever sistemas distribuídos.
Muitas LEF têm sido criadas com o intuito de serem utilizadas para descrever sistemas com mobilidade enquanto outras são extensões de linguagens anteriores, fornecendo uma forma de representação de mobilidade.
Algumas dessas linguagens serão apresentadas no Capítulo 8 como trabalhos relacionados.
A seguir é descrito o formalismo de Gramáticas de Grafos e suas principais características são apresentadas.
Gramáticas de Grafos é a base da LEF utilizada neste trabalho, a qual será discutida no Capítulo 3.
Para formalizar um problema, é desejável ter- se uma maneira natural e intuitiva de descrição.
Propriedades essenciais de sistemas complexos, como distribuição, paralelismo e comunicação devem ser consideradas.
O fato de serem formais e, ao mesmo tempo, intuitivas e de também poderem tratar com simplicidade aspectos de concorrência e distribuição de sistemas, faz de Gramáticas de Grafos um método promissor para o desenvolvimento de software confiável.
Gramáticas de Grafos são uma generalização de gramáticas de Chomsky, substituindo- se as strings por grafos.
Diferentemente do que ocorre nas regras em gramáticas de Chomsky, uma regra de grafos r:
L R não consiste somente dos grafos L (lado esquerdo) e R (lado direito), mas também de uma parte adicional:
Um mapeamento de vértices e arcos de L em vértices e arcos de R de maneira compatível.
Assim, se um arco eL for mapeado num arco eR, então o vértice origem de eL deve ser mapeado para o vértice origem de eR, ocorrendo o mesmo para o vértice destino.
Gramáticas de Grafos, segundo a abordagem algébrica, especificam um sistema em termos de estados (modelados por grafos) e mudanças de estados (modeladas por derivações).
A interpretação operacional de uma regra r:
L R, seguindo esta abordagem de especificação, é a seguinte:
Itens de L que não têm imagem em R são removidos;
Itens de L que são mapeados para R são preservados;
Itens de R que não têm uma pré-imagem em L são criados.
As entidades envolvidas num sistema são descritas através de um grafo de tipos, onde cada entidade é apresentada com seus atributos, as mensagens que pode processar e gerar e os relacionamentos que possui com outras entidades.
O comportamento da especificação é determinado por a aplicação de regras aos grafos representando o estado real do sistema, partindo- se de um grafo inicial, em o qual é representado o estado inicial do sistema.
Múltiplas regras podem ser aplicadas em paralelo se não houver conflito entre elas (duas ou mais regras não podem modificar um mesmo item).
A aplicação de uma regra a um grafo G é chamada de passo de derivação.
Um passo de derivação só é possível se existe uma ocorrência do lado esquerdo da regra no grafo G. Ou seja, uma regra é aplicada somente se o grafo presente no lado esquerdo desta regra ocorre atualmente no grafo G. A semântica de Gramáticas de Grafos pode ser definida como o conjunto de todas as computações que podem ser realizadas usando as regras da gramática, partindo- se do estado inicial do sistema.
A LEF proposta em baseia- se em Gramáticas de Grafos e é uma linguagem concebida para descrever SDCM.
Mais especificamente, esta LEF trabalha com Gramáticas de Grafos Baseadas em Objetos (GGBO), a qual é uma forma restrita de Gramáticas de Grafos.
Esta escolha tem a vantagem das especificações adquirirem um estilo baseado em objetos, que é bastante familiar à maioria dos desenvolvedores, tornando- as, por conseqüência, fáceis de construir e entender.
Isto também possibilita que elas sirvam como base para uma implementação, além de facilitar a análise da gramática.
Um sistema baseado em objetos (SBO) pode ser descrito como um sistema em o qual entidades autônomas chamadas objetos podem se comunicar e cooperar entre si através de mensagens.
Cada objeto possui seu estado interno e o comportamento de um objeto é descrito por as reações que ele assume ao receber mensagens.
Uma reação pode gerar a modificação do estado interno do objeto e/ ou o envio de mensagens a outros objetos.
Representando- se SBO com GGBO, as reações ao recebimento de uma mensagem são especificadas através de regras.
Toda regra em GGBO tem como condição, em seu lado esquerdo, a existência de uma mensagem a ser tratada.
A ocorrência do lado esquerdo de uma regra corresponde a encontrar a mensagem que dispara esta regra e verificar se os valores dos atributos lidos/ alterados por esta regra são os especificados no lado esquerdo da regra.
Assim, múltiplas regras podem ser executadas em paralelo, desde que seus lados esquerdos aconteçam.
Como forma de descrever um SBO através de Gramáticas de Grafos, as entidades deste devem ser apresentadas num grafo, chamado grafo modelo.
Em este grafo modelo são apresentadas as entidades e os relacionamentos que serão utilizados nas Gramáticas de Grafos.
Assim, objetos, mensagens e atributos são modelados como vértices, como mostra a Figura 3.
Uma mensagem deve ter como destino um objeto (arco direcionado, rotulado com te o), o qual possui atributos (arco atr).
Cada mensagem pode ter como argumentos objetos e/ ou atributos (arcos arg).
Em a Figura 4, é apresentado o grafo modelo de GGBO para SDCM.
Como forma de representar um SDCM através de GGBO, o grafo modelo apresentado na Figura 3 foi estendido para que fosse possível representar componentes móveis (component) e lugares (place), sendo estas as entidades básicas de um SDCM.
Lugares representam locais onde um componente pode executar.
Eles oferecem serviços básicos (comunicação, armazenamento e poder de processamento) e a possibilidade de acesso a outros componentes que possuam uma interface bem definida (ex..
Serviço de nomes, serviço de eventos, etc.).
Componentes móveis são componentes de software que podem se mover durante sua execução de um lugar para outro e utilizar os serviços oferecidos por o lugar aonde se encontram.
Um componente móvel possui estado interno, código e um conjunto de atributos (identificador, lugar de origem, etc.).
Mensagens podem ser enviadas de um componente móvel para outro, de um componente para o lugar onde está, de um lugar para os componentes que em ele estão ou de um lugar para outro.
Conforme apresentado no grafo modelo de GGBO para SDCM na Figura 4, o arco rotulado com is_ in informa o lugar em que um componente está, definindo que um componente está sempre em algum lugar.
Os arcos direcionados rotulados com to indicam o receptor de uma mensagem.
Uma mensagem deve possuir exatamente um receptor, apontado por a seta no fim do arco rotulado com to que parte da mensagem.
Os arcos não direcionados, conectados à mensagem, indicam os parâmetros da mesma (podendo ser componentes, lugares e/ ou atributos).
Os arcos não direcionados que partem de componentes e lugares representam seu estado interno, apontando seus atributos.
Os arcos e vértices são rotulados e possuem diferentes formas para que seja possível identificar- se o tipo de cada entidade.
Um lugar é representado por o símbolo com duas elipses concêntricas e um componente móvel, por uma elipse única.
Lugares e componentes móveis são especificados segundo o comportamento esperado para estas entidades.
Este comportamento define as regras que regulam a atividade de cada entidade.
Como citado na Seção 2.2.3.1, uma regra é especificada apresentando, do lado esquerdo, o subgrafo que deve estar presente no grafo do estado atual do sistema para que a mesma seja aplicada e, do lado direito, o grafo resultante da aplicação da regra.
A seta que indica a transição de estados é rotulada com o nome da regra a ser aplicada, a qual pode possuir uma condição de aplicação, como mostra a Figura 5.
De essa forma, uma regra tem um nome que a identifica (RuleName), um lado esquerdo, contendo um grafo L que determina o subgrafo que deve ser encontrado para que a regra seja aplicada, e um lado direito, contendo um grafo R que determina as alterações feitas no grafo L por a aplicação da regra.
Uma regra pode ainda conter uma condição (condition) de aplicação.
Esta condição apresenta- se como uma expressão lógica que envolve atributos da entidade à qual a regra pertence.
O resultado de uma aplicação de regra (passo de derivação) segue a semântica descrita na Seção 2.2.3.1.
Regras Básicas das Entidades de um SDCM Em este trabalho, considera- se que lugares e componentes móveis executam num ambiente onde se pressupõe:
A) a inexistência de falhas de comunicação;
B) a garantia da integridade referencial (referências a componentes que se movem continuam válidas após a sua movimentação);
C) a possibilidade de comunicação local e remota.
Com relação a o item A, apesar de o projeto ForMOS considerar ambientes abertos, onde falhas podem acontecer, este trabalho restringe- se ao caso de um ambiente sem falhas por questões de simplicidade.
A consideração de falhas merece um estudo posterior.
Já os itens B e C são assumidos por estas serem características encontradas em plataformas de suporte à mobilidade disponíveis.
Tendo- se lugares e componentes móveis, definidos conforme apresentado no início desse capítulo, e o ambiente descrito, foram definidas regras básicas que descrevem o comportamento padrão de lugares e componentes móveis dentro de o processo de movimentação.
Tais regras foram criadas seguindo as definições de GGBO e são divididas em quatro grupos:
Regras para criação e deleção, regras de comunicação, regras de lugares e regra de componentes móveis.
Cada grupo de regras é apresentado a seguir, sendo descrito, ao fim desta seção, como tais regras podem ser utilizadas.
Regras para Criação e Deleção de Entidades A criação e a deleção de entidades são estabelecidas através de esquemas de regras.
Esquemas de regras indicam configurações básicas que devem ocorrer nos lados esquerdo e direito de uma regra.
Elementos adicionais da regra são referentes à regra da aplicação específica.
A ocorrência da mensagem Msg1 do lado esquerdo do esquema de regra Creation se deve ao formalismo ser baseado em objetos e, por isso, toda computação ocorre a partir de o recebimento de uma mensagem.
Por o que é definido no esquema de regra, ao receber uma certa mensagem Msg1, um componente Comp1 pode criar outro componente Comp2.
Comp2 aparece em forma pontilhada porque se define que, ao ser criado, um componente não foi ainda inicializado.
Isto é, o componente ainda não possui os valores iniciais para seus atributos internos.
Antes de ser inicializado, o componente não pode tratar qualquer outra mensagem que não seja a mensagem de inicialização.
A inicialização do componente ocorre segundo o esquema de regra Init apresentado na Figura 7, através do recebimento de uma mensagem que contém os valores necessários para estabelecer o estado inicial do componente (mensagem representada por Msg2 na Figura 6).
Após receber a mensagem de inicialização, o componente pode então passar a tratar as demais mensagens encaminhadas a ele.
Isto é denotado com o componente passando a ser representado com linha contínua, significando que o componente foi inicializado e está ativo.
Deve- se dizer que se considera apenas a criação dinâmica de componentes móveis.
Em este trabalho, lugares são criados no início do sistema e permanecem constantes durante toda a execução.
Não se considera aqui a possibilidade de falha de um lugar.
Quanto a a deleção de uma entidade, ela ocorre sempre que uma entidade aparece no lado esquerdo da regra mas não está presente no lado direito, significando que a aplicação da regra causou a exclusão da entidade do sistema.
As regras de comunicação definem as formas de troca de mensagens entre entidades.
As regras de comunicação são descritas por esquemas de regras para passagem de mensagens.
Como dito anteriormente, em GGBO toda computação é resultado da passagem de mensagens.
Por isso, todas as regras construídas representam a transformação do grafo devido a o recebimento de uma mensagem.
A forma como uma entidade obtém uma referência para a entidade com a qual queira se comunicar não é indicada.
Este mecanismo deve ser definido por a aplicação.
As possibilidades são o armazenamento de uma referência num atributo interno da entidade ou a passagem de uma referência à entidade de origem como parâmetro de uma mensagem, permitindo que a entidade que recebe a mensagem possa retornar uma resposta.
A passagem de mensagens pode ocorrer entre componentes móveis, entre lugares e mensagens entre componentes móveis, onde um componente Comp1, ao receber uma mensagem Msg1, envia uma mensagem Msg2 ao componente Comp2.
Note- se que esta comunicação pode ocorrer local ou remotamente.
A Figura 9 apresenta o esquema de regra para comunicação entre lugares (CooperationRequest), o qual é idêntico ao esquema de regra de comunicação entre componentes móveis, apenas substituindo- se os componentes por lugares.
Em a Figura 10 é apresentado o esquema de regra ServiceRequest, representando a passagem de mensagens de um componente para um lugar.
Como pode ser visto, este esquema de regra impõe uma restrição para comunicação entre componentes e lugares:
O componente deve estar no lugar com o qual se comunica.
Ou seja, um componente só pode requisitar serviços ao lugar onde se encontra (através do envio de mensagens).
De essa forma, não existem mensagens remotas de componentes para lugares.
O esquema de regra de passagem de mensagens de um lugar para um componente pode ser visto na Figura 11.
Diferentemente do esquema de regra apresentado na Figura 10, o esquema de regra ServiceResponse não define nenhuma restrição para que um lugar envie mensagens para componentes localizados remotamente.
Portanto, define- se que lugares podem enviar mensagens para qualquer componente, local ou remoto.
Regras de Lugares As regras de lugares determinam o comportamento padrão de um lugar no processo de movimentação de componentes.
A passagem de mensagens entre entidades segue os esquemas de passagem de mensagens descritos na subseção anterior, com a adição dos elementos necessários à composição do cenário desejado.
Em a regra RequestMove, apresentada na Figura 12, um componente Comp1 requisita ao lugar Orig a sua movimentação para o lugar Dest.
Isto ocorre através do envio, por parte de o componente, de uma mensagem Move ao lugar Orig.
Tal mensagem leva, como parâmetros, o componente que pede a movimentação e o local de destino desta movimentação.
Além disso, pode acompanhar a mensagem a informação de alguns requisitos que devem ser atendidos para que a movimentação ocorra, tais como disponibilidade de recursos e possibilidade de fornecimento de determinados serviços no destino.
O uso destes requisitos é para consideração futura.
MoveReq to Dest A regra Move define que, ao receber uma mensagem de requisição de movimentação de um componente, o lugar de destino da movimentação verifica seu estado interno e confere se pode atender os requisitos necessários e receber o componente requisitante.
A partir de esta verificação, ele gera uma mensagem de resposta ao pedido de movimentação, encaminhada ao lugar de origem, informando se pode ou não receber o componente.
Quando chega uma resposta positiva do lugar de destino, o lugar de origem segue o comportamento apresentado na regra AcceptMove.
Assim, o lugar de origem realiza três operações:
Atualiza seu estado interno, para refletir a saída do componente;
Gera uma mensagem ao lugar de destino informando que o componente agora está localizado no novo lugar e, portanto, ele pode atualizar seu estado interno para refletir esta situação;
E gera uma mensagem ao componente para que este atualize seu atributo interno de localização, passando a referenciar o seu novo local.
O lugar de destino, ao receber a mensagem de aviso de inserção de componente do lugar de origem, tem a regra InsertComponent ativada, causando a atualização do seu estado interno com a inserção do componente movido.
A regra DenyMove apresenta o comportamento do lugar de origem quando a resposta a um pedido de movimentação de componente é negado por o lugar de destino.
Tendo sido negado o pedido, o lugar de origem envia uma mensagem ao componente que requisitou a movimentação informando- o de que não foi possível mover- lo.
Regra de Componentes Móveis A regra de componentes móveis é apresentada na Figura 17.
Esta é a única regra necessária para componentes móveis dentro de o processo de movimentação.
A regra ChangeLocation ocorre sempre que um pedido de movimentação é atendido e o local de origem realizou a regra AcceptMove.
A o receber a confirmação de sua movimentação, o componente atualiza seu atributo interno de localização para o seu novo lugar de execução.
Utilização das Regras Definidas As regras aqui definidas servem para serem utilizadas dentro de as especificações para SDCM.
Como pode ser notado, não existe, entre estas regras, nenhuma regra que gere a mensagem de Move que dispara a execução da regra RequestMove e nenhuma regra que seja disparada por as mensagens NoGo, gerada por a regra DenyMove, e Continue, gerada por a regra ChangeLocation.
Isto porque estas regras ausentes devem ser definidas por a aplicação móvel.
Desta forma, conforme pode ser visto no esquema apresentado na Figura 18, a aplicação deve possuir uma ou mais regras que iniciam o processo de movimentação, com o envio de uma mensagem de Move de um componente móvel para o seu lugar de origem.
Esta mensagem dispara o processo de movimentação, segundo as regras anteriormente definidas.
A resposta ao pedido de movimentação é obtida por a aplicação com a existência de uma regra que é disparada por o recebimento, por o componente, de uma mensagem de Continue e outra que é disparada por uma mensagem NoGo.
Isto é, do ponto de vista do especificador da aplicação, um pedido de movimentação pode ter sucesso, indicando que o componente foi movido para o destino desejado e recebeu uma mensagem de Continue para retomar sua execução, ou ter a movimentação negada por o destino, indicando que o componente permanece no local de origem.
Em este último caso, uma mensagem de NoGo é enviada ao componente, sendo que a aplicação deve prever o comportamento a ser assumido para tratar esta situação.
Com uso das regras descritas, a especificação da aplicação só envolve questões pertinentes à própria aplicação, participando da movimentação apenas na geração do pedido de movimentação e na obtenção e tratamento da resposta.
Exemplo de Especificação Para exemplificar o uso das regras básicas, será apresentado um exemplo de aplicação móvel especificada em GGBO.
Esta aplicação envolve quatro tipos de entidades:
MC consulta o information server (Is) local, perguntando qual o preço para product1.
Comparando os preços de cada local por onde passa, o MC armazena o melhor preço e o place onde ele foi encontrado.
Terminadas as visitas previstas, o MC retorna ao local onde está o customer e retorna para este os resultados de sua pesquisa.
Definido o cenário, o próximo passo é a especificação formal do sistema.
A especificação possui três partes:
O grafo de tipos, o grafo inicial e as regras das entidades.
O grafo de tipos, como descrito anteriormente, apresenta as entidades envolvidas no sistema e seus atributos.
O grafo de tipos desta aplicação é apresentado na Figura 19.
Location NextVisit comp Resp bloc price real to hostedIS to LocalIS locIS real comp to string to Next newLoc real price Cost?
Next newLoc Customer string to GetIS to Move dest comp location to prod Name location num Places real LocalIS locIS to bestPrice nextPlace string integer Customer GetIS comp Place Price location Continue real to Price price real pname string bprice real to Cost?
Os números utilizados nos grafos de tipos apresentados representam as entidades segundo o número colocado entre parênteses após o nome de cada entidade.
Assim, o número 1 representa uma referência a um Place, o número 2 representa uma referência a um Customer, o número 3 representa uma referência a um Is e o número 4 representa uma referência a um MC.
De essa forma, por exemplo, o atributo location de um MC armazena uma referência a um Place.
Estes número foram utilizados para simplificar os grafos de tipos.
Em o grafo de tipos da aplicação, cada entidade é apresentada com o seu próprio grafo de tipos, onde a entidade é apresentada no lado esquerdo com seus atributos.
Em o lado direito acima, são apresentadas as mensagens que podem ser recebidas por a entidade.
Cada mensagem aparece com seus parâmetros.
Em o lado direito abaixo, são mostradas as mensagens enviadas por a entidade, também apresentadas com os seus respectivos parâmetros, sendo indicadas as entidades de destino de cada mensagem.
De acordo com o grafo de tipos, um MC possui um atributo numPlaces que indica quantos lugares devem ser visitados e um atributo respCustomer, que define uma referência ao customer ao qual deve ser retornado o resultado do seu trabalho.
Além disso, ele possui atributos de controle de sua localização e de armazenamento dos valores de melhor preço e lugar onde este foi encontrado.
Um place possui um Is e a informação do próximo place.
Um Is possui as informações de nome de um produto e o preço para o mesmo.
Um costumer possui atributos para receber os resultados da pesquisa do MC e a informação de localização.
O grafo inicial para esta aplicação é apresentado na Figura 20.
Como descrito, no grafo inicial tem- se um customer, localizado num lugar P_ Orig que possui um MC que deve procurar o melhor preço para product1 em 3 places.
Cada place possui o seu Is, contendo o preço para product1, e a informação de qual o próximo place5.
A mensagem Next, enviada a MC define o início da execução do sistema.
A Figura 21 e a Figura 22 apresentam as regras para o MC.
O comportamento descrito por as regras apresentadas define que, partindo- se da mensagem Next inicial (conforme apresentado no grafo inicial), o MC realiza a regra MoveNext (Figura 22).
Apesar de haver outra regra que também trata a mesma mensagem (MoveBack, na Figura 22) a condição de execução (constante sob a seta de transição da regra) define que a primeira seja executada.
Executando a referida regra, o MC realiza um pedido de movimentação para o lugar recebido como parâmetro da mensagem.
Após o envio da mensagem Move, o comportamento seguido é o descrito na regras básicas de movimentação, apresentadas neste capítulo.
Assim, a próxima regra a ser executada é a regra que trata uma mensagem de Continue.
Novamente há duas regras que tratam a mesma mensagem.
Analogamente ao caso anterior, a condição de execução define qual tratará a mensagem.
Em o caso, a regra GetLocalIS.
Esta regra serve para que o MC obtenha uma referência ao Is local para poder consultar o preço oferecido.
As regras do place são apresentadas na Figura 23.
O comportamento do place ao receber a mensagem GetIS é apresentado na regra InformIS, retornando a referência pedida por o MC.
Recebida a referência pedida, o MC pode então realizar a consulta ao preço oferecido para o produto product1, conforme descrito na regra QueryPrice.
Note- se que, neste instante, o MC decrementa o número de places a visitar.
O comportamento do Is quando consultado é descrito na Figura 24.
InformPrice name $= pd pname comp pd pr product to Cost?
O Is retorna ao MC, conforme a regra InformPrice, o preço para product1 como parâmetro da mensagem Price.
Quando recebe a mensagem contendo o preço para product1, MC pode executar duas regras (apresentadas na Figura 22):
Proceed, se o preço recebido é maior ou igual ao melhor preço já encontrado;
Ou Proceed &amp; Update, caso o preço seja menor que o menor preço encontrado até então.
Se ocorrer o segundo caso, o MC atualiza seus atributos, armazenando o preço recebido como o melhor encontrado e o seu lugar atual como sendo o lugar que possui o melhor preço.
Tanto neste caso, como no caso de o preço não ser melhor que o encontrado anteriormente, o MC solicita ao place onde está a informação de qual é o próximo place (mensagem NextVisit), de modo que ele possa consultar o próximo lugar.
A o receber a mensagem de NextVisit, o place executa a regra NextPlace (Figura 23), enviando a referência ao próximo place na mensagem Next, a qual dispara novamente todo o processo descrito até agora.
A mudança ocorre quando todos os três places já foram visitados.
Em este momento, ao receber a mensagem de Next, o MC verifica que numPlaces tem o valor 0 e executa a regra MoveBack (Figura 22), retornando ao lugar de origem.
Terminada a movimentação e recebida a mensagem de Continue, o MC executa a regra ReturnResult (Figura 22), enviando os resultados de sua pesquisa para o customer.
Recebidos os resultados do MC, o customer executa a regra GetResp, descrita na Figura 25, alterando seus atributos internos.
Com isto, a execução da aplicação está completa e o customer possui a identificação do place que possui o menor preço para o produto product1.
Modelos de simulação podem ser bastante úteis como um meio de especificação e teste.
Um modelo de simulação é uma representação simplificada de um processo ou sistema que permite analisar- lo.
A principal vantagem é a possibilidade de validar uma estratégia de projeto, bem como os algoritmos a serem utilizados, antes mesmo de sua implementação.
Além disso, a existência de um modelo formal descrevendo o sistema torna as interdependências entre todos os seus componentes explícitas e claras.
O simulador desenvolvido no ambiente do projeto PLATUS permite a realização de simulações sobre modelos descritos utilizando GGBO, apresentando um mapeamento de GGBO para criar seus modelos de simulação.
Tal simulador representa uma ferramenta para testar a especificação de um sistema e, assim, identificarem- se erros durante o projeto do mesmo.
O grafo de tipos utilizado por o simulador é apresentado na Figura 26, retirada de.
Os vértices representam entidades, mensagens ou tipos abstratos de dados.
Entidades representam os objetos modelados.
Os elementos tmin e tmax são timestamps que representam atributos especiais de uma mensagem.
Estes timestamps são associados a cada mensagem e descrevem o intervalo de tempo em o qual uma mensagem deve ser tratada em termos de tempo mínimo e máximo6.
Tipos abstratos de dados (ADT) podem ser atributos de entidades ou parâmetros de mensagens.
O simulador conta com um kernel.
O kernel é uma entidade especial que gerência um relógio simulado que serve para sincronizar as demais entidades.
O kernel é responsável Em o momento, somente tmin está implementado no simulador, determinando a demora para a entrega da mensagem a seu destino.
Cada entidade executa como uma thread e possui uma lista de regras que descrevem o seu comportamento.
A o retirar uma mensagem do buffer, a entidade verifica, de entre as regras de sua lista, quais podem tratar aquela mensagem.
Esta seleção baseia- se, como definido em GGBO, na ocorrência do lado esquerdo da regra e numa possível condição associada à regra.
De o conjunto de regras habilitadas a tratar a mensagem recebida, uma é escolhida aleatoriamente, seguindo a mesma semântica de Gramáticas de Grafos.
A regra escolhida é executada por uma thread criada para este fim.
A o final da execução da regra, a thread é finalizada.
Caso uma mensagem recebida não possa ser tratada (condição de execução da regra que trata a mensagem não é satisfeita ou lado esquerdo da regra não ocorre no estado atual do sistema), ela é recolocada no buffer de mensagens e novas tentativas de tratar- la são feitas.
A implementação de uma entidade no simulador fornece a possibilidade de múltiplas regras de leitura de atributos executarem paralelamente.
Isto é, múltiplas threads são criadas para executar simultaneamente diferentes regras que lêem atributos.
Quando uma regra de escrita deve ser executada (regra que altera o valor de algum atributo da entidade), esta fica bloqueada até que todas as regras de leitura em execução terminem, a fim de evitar que ela altere os dados que estão sendo lidos por as demais regras.
Logo que não haja mais nenhuma regra de leitura executando, a regra de escrita é executada, bloqueando- se a execução de qualquer outra regra.
Assim, tem- se que regras de leitura executam concorrentemente e regras de escrita executam isoladamente.
Com isto, garante- se a geração de estados consistentes das entidades.
Para isto, as regras têm de ser marcadas como regras de leitura ou escrita.
A Figura 27 ilustra a execução de regras no simulador, apresentando um cenário onde executam 4 regras ao longo de o tempo.
O cenário da Figura 27 apresenta uma regra R1 de leitura que começa a executar num tempo t0.
Em o tempo t1, uma regra R2, também de leitura, começa a executar.
Como R2 é uma regra de leitura, ela pode executar ao mesmo tempo em que R1.
Em o tempo t2, uma regra R3 de escrita tenta executar mas, como existem regras de leitura executando, ela fica bloqueada até o tempo t4, quando ambas as regras de leitura que estavam em execução foram finalizadas.
Em o tempo t5, uma regra R4 de leitura tenta executar, mas fica bloqueada por haver uma regra de escrita (R3) em execução.
Somente no tempo t6 é que R4 passa a executar, quando R3 foi finalizada.
Deve se citar que, caso outra regra de leitura tentasse executar, por exemplo, no tempo t3, ela seria postergada até que a regra de escrita R3 fosse finalizada, visto que a execução de qualquer outra regra é bloqueada após uma regra de escrita ter sido selecionada para executar.
Isto impede a postergação indefinida da regra de escrita.
Deve- se dizer que, segundo GGBO, múltiplas regras poderiam executar simultaneamente, fossem elas de leitura ou de escrita,.
Isto porque todas regras consideram os valores do lado esquerdo da regra no instante de início de sua execução.
Em o momento, a semântica utilizada no simulador é a descrita anteriormente.
De essa forma, por enquanto, trabalha- se com um subconjunto das possibilidades de execuções simultâneas de regras permitidas por GGBO.
Esforços têm sido realizados para permitir que regras de leitura executem ao mesmo tempo em que regras de escrita, tal como define a semântica de Segundo estudos preliminares, uma possibilidade de permitir o conjunto total de paralelismo entre regras seria, para cada entidade, realizar a duplicação de seus atributos.
Assim, regras de leitura executariam lendo os atributos replicados e regras de escrita trabalhariam sobre os atributos originais da entidade.
A o final de um conjunto de regras disparadas, os resultados das atualizações das regras de escrita sobre os atributos da entidade seriam copiados para os atributos replicados.
Quando um novo conjunto de regras fosse ser executado, os atributos replicados já conteriam os valores atualizados.
Em esta abordagem, a fim de minimizar a quantidade de atributos replicados, poderia- se- incluir em cada regra a informação de quais atributos a regra altera.
De esse modo, apenas os atributos necessários em cada execução em paralelo seriam replicados.
Uma análise do impacto deste esquema no desempenho da entidade ainda não foi feita.
Ferramentas gráficas para auxiliar no uso do simulador estão em desenvolvimento.
Tais ferramentas deverão permitir a criação de entidades e modelos e a geração automática de código, através da conversão da representação gráfica para o conjunto de classes correspondentes.
Com isso, pretende-se que se possa criar graficamente os modelos em GGBO e, a partir destes, gerar código de simulação para os mesmos.
A geração de código a partir de uma LEF exige conhecimento sobre o formalismo e a linguagem de programação utilizados.
É preciso estudar como mapear as entidades presentes na LEF para uma representação coerente na linguagem de programação.
Ou seja, para que a geração de código seja válida, este mapeamento deve ser cuidadoso para que o código gerado reflita a especificação criada, garantindo- se, assim, as vantagens obtidas por se ter uma descrição formal do sistema.
Em relação a a geração de código para SDCM, também se considera a escolha de uma PSM.
Como visto na Seção 2.1.3, uma PSM fornece uma biblioteca de mecanismos de suporte à mobilidade de código que estende uma linguagem de programação.
A utilização de uma PSM torna mais fácil trabalhar- se com código móvel, mas, no caso de a geração de código, exige que também se tenha um bom conhecimento das abstrações e dos serviços por ela oferecidos.
A geração de código deve contemplar a criação de um código na linguagem de programação considerando o uso dos recursos fornecidos por a biblioteca da PSM, a fim de utilizar seus mecanismos de mobilidade de código.
O objetivo principal deste trabalho, como anteriormente citado, é permitir que, a partir de uma especificação formal de um SDCM, feita através da LEF descrita na Seção 3, gere- se código numa linguagem de programação para uma PSM.
Para atingir este objetivo, partiu- se do mapeamento que o simulador PLATUS usa para criar seus modelos de simulação.
Como citado no Capítulo 4, tais modelos são criados a partir de o mapeamento de uma especificação em GGBO para código em linguagem Java.
De essa forma, precisou- se adaptar o mapeamento existente para tornar possível a geração de código executável sobre uma PSM.
Esta adaptação foi realizada em 4 etapas distintas:
As etapas sucintamente apresentadas serão detalhadas nas seções seguintes.
Para ilustrar o código gerado em cada etapa e demonstrar os reflexos no código das modificações realizadas, serão utilizados os códigos gerados para a entidade MC da aplicação de exemplo apresentada na Seção 3.1.6.
O grafo de tipos da entidade MC é apresentado novamente na Figura 28.
Continue Price to string integer num Places real to bestPrice origin Next newLoc LocalIS locIS to prod Name real bestLoc comp resp Customer to GetIS to Move dest comp pname string bprice real to Cost?
Para exemplificar uma regra, será usada a regra MC_ R1 da referida entidade, cuja especificação é novamente apresentada na Figura 29.
Em esta regra, há o recebimento de uma mensagem de Continue por a entidade MC, a qual está localizada num lugar P_ A. A regra possui, como condição de execução, que o valor de numPlaces deve ser diferente de 0.
A aplicação da regra causa o consumo da mensagem Continue e a geração da mensagem GetIS e o seu envio para um lugar P_ A, tendo como parâmetro uma referência à entidade MC.
Geração de Código para Simulação Para a apresentação da geração de código para simulação, será discutido, inicialmente, o mapeamento de GGBO proposto no simulador PLATUS e, posteriormente, as modificações realizadas neste mapeamento no âmbito deste trabalho.
O simulador PLATUS foi concebido para a simulação de sistemas de produção e sistemas de tempo real.
O mapeamento criado para representar uma especificação em GGBO é composto por três partes, descritas a seguir.
O simulador PLATUS mapeia o comportamento básico de uma entidade de GGBO numa classe Java denominada Entity.
Em esta classe, encontram- se implementados os mecanismos de recebimento e tratamento de mensagens de uma entidade.
Toda entidade de aplicação deve estender Entity, incorporando este comportamento básico.
De essa forma, existe uma hierarquia entre as entidades de aplicação e a classe Entity, onde as primeiras estendem a segunda, assim como mostrado na Figura 30, com Entidade representando uma entidade de aplicação.
O código básico de uma entidade de aplicação é apresentado na Figura 31.
AddRule, this);
As partes marcadas em negrito na Figura 31 representam o que varia na definição de uma entidade.
Assim, a linha 1 apresenta o cabeçalho da classe que descreve a entidade, sendo que, como comentado, esta classe estende a classe Entity.
A seguir (linhas 3 a 5) são definidos os atributos da entidade, sendo fornecidos o tipo e o nome de cada atributo da entidade.
Definidos os atributos, vem o construtor da classe (linha 6).
O construtor de uma classe que descreve uma entidade de simulação recebe sempre uma instância do kernel como parâmetro.
De essa forma, a entidade sabe qual instância do kernel deve usar para comunicar- se com as demais entidades da aplicação.
Esta informação é armazenada num atributo da classe Entity.
O método init é usado para inicializar os atributos de uma entidade.
Para isso, recebe, como parâmetros, todos os valores iniciais dos atributos.
Estes valores são, então, atribuídos aos respectivos atributos.
Para permitir que os valores dos atributos sejam modificados ou lidos ao longo de a simulação da aplicação, atributo, respectivamente, assim como mostra o trecho entre as linhas 13 e 26 da Figura 31.
A última parte do código define o registro do conjunto de regras da entidade (linhas 27 a 32).
Uma regra é adicionada ao conjunto de regras da entidade recebendo um nome.
As regras são inicializadas com o nome da mensagem que dispara a regra, a instância do kernel usada na simulação (mesma recebida no construtor da entidade) e uma referência à entidade à qual a regra pertence.
Cada regra da aplicação é descrita por uma classe Java, a qual estende a classe Rule.
A classe Rule define os métodos básicos de uma regra.
Para uma regra, o código básico, mostrado na Figura 32, apresenta o método construtor, que recebe a identificação da regra, a referência à instância do kernel utilizada e a referência à entidade a qual a regra está associada (linhas 3 a 5).
O método answerMsg define qual o tipo da mensagem que a regra trata.
O retorno deste método é utilizado por a entidade para definir quais de suas regras são candidatas a tratar uma mensagem recebida.
Os métodos conditionOk e leftSideOccurs servem para definir condições e/ ou restrições para a execução da regra.
Com isso, no método conditionOk definem- se as condições associadas à regra, que são as condições colocadas sob a seta de transição na especificação da regra, que pode ser vista na Figura 29, no início desse capítulo.
Em o método leftSideOccurs podem ser definidas restrições de valores de atributos da entidade em questão para que a regra seja executada, de acordo com o que é apresentado no lado esquerdo da especificação da regra.
As condições testadas nos métodos conditionOk e leftSideOccurs podem considerar apenas os atributos da entidade à qual a regra está associada e os parâmetros da mensagem tratada por a regra.
Caso uma regra trate uma mensagem recebida por a entidade (retorno verdadeiro do método answerMsg) e todas as condições e restrições de execução da regra sejam atendidas (retornos verdadeiros dos métodos conditionOk e leftSideOccurs), então ela pode ser aplicada.
A aplicação de uma regra é definida no método apply (linhas 22 a 36).
Em este método, a mensagem recebida é tratada, podendo causar a alteração do estado interno da entidade (alteração dos valores de atributos) e o envio de novas mensagens a outras entidades.
A primeira providência na aplicação da regra é obter a entidade a que pertence a regra (linha 23).
Os valores dos parâmetros da mensagem a ser tratada são então obtidos (linhas 24 a 27).
A seguir, são realizadas eventuais alterações no estado interno da atributos.
Também pode ser realizada a criação de novas entidades.
A aplicação de uma regra pode gerar mensagens, conforme apresentado nas linhas 30 a 35 da Figura 32.
Cada parâmetro de uma mensagem a ser enviada é adicionado à lista de associado ao parâmetro.
As linhas 34 e 35 apresentam o comando de envio de mensagem.
O método utilizado para tanto é o sendMessage, que implementa um mecanismo de envio da mensagem ao kernel, o qual se encarregará de enviar- la ao destino especificado.
O método sendMessage recebe um timestamp associado à mensagem (o qual define o tempo de simulação do atraso na entrega da mensagem) e a própria mensagem, a qual contém a entidade que está enviando a mensagem, a entidade a que se destina a mensagem, o nome da mensagem e os seus parâmetros.
O último método de uma regra é o método writeOnAttrib (linha 37), usado para definir se a regra altera ou não atributos da entidade.
Ou seja, este método define se a regra é de escrita ou de leitura.
O valor do retorno deste método (true ou false) vai definir, segundo a semântica de concorrência implementada no simulador (vide Capítulo 4), quais regras podem ser executadas em paralelo.
Uma aplicação especificada em GGBO, para ser simulada no simulador PLATUS, deve possuir um programa principal, o qual descreve o estado inicial do sistema.
Em este programa principal são instanciadas as entidades da aplicação, é feita a sua inicialização e as mensagens iniciais da aplicação são geradas.
Isto é, o programa principal mapeia o grafo inicial do sistema.
O código básico de um programa principal de uma aplicação especificada em GGBO a ser simulada é apresentado na Figura 33.
O programa principal é definido numa classe Java que recebe o nome da aplicação.
Em o método principal desta classe (main) é descrito o estado inicial do sistema.
A linha 4 apresenta a instanciação do kernel a ser utilizado na simulação da aplicação.
Em a linha 5 está o comando para a definição do intervalo de avanço do relógio simulado.
Assim, de acordo com o valor colocado, o relógio avança 0,01 unidades do tempo simulado por vez.
A seguir vêm as instanciações das entidades da aplicação, com a passagem de uma referência à instância do kernel utilizada.
As entidades são, depois, inicializadas com os valores iniciais de seus atributos.
As entidades instanciadas devem ser adicionadas à lista de entidades servidas por o kernel, a fim de que possam trocar mensagens entre si.
A adição das entidades ocorre conforme apresentado nas linhas 12 a 14.
Uma mensagem inicial é definida através da criação da sua lista de parâmetros e do seu envio ao kernel conforme o comando da linha 19.
Múltiplas mensagens iniciais podem ser definidas.
O kernel é inicializado através do comando da linha 20, o que causa o início da simulação da aplicação.
Apesar de não existir ainda um tradutor implementado para mapear especificações em GGBO para código do simulador, segundo uma análise prévia, este mapeamento parece passível de ser realizado de forma automática.
Para realizar este mapeamento, devem ser cumpridas duas etapas:
1) mapeamento da especificação para estruturas de dados;
2) utilização das estruturas de dados para gerar o código de simulação.
Em foi proposta uma forma de realizar este mapeamento, sendo definidas estruturas de dados para comportar as informações pertinentes de uma especificação em GGBO.
Posteriormente, essas informações são utilizadas para gerar código de simulação.
Este mapeamento, no entanto, considera apenas um conjunto reduzido de especificações em GGBO e, portanto, a geração de código de simulação através desse mapeamento é dependente do tipo de aplicação.
Modificações realizadas Em este trabalho, o simulador foi estendido para a realização de simulações de SDCM.
Para isso, foram criadas duas entidades especiais, representando as duas entidades envolvidas num cenário de um SDCM:
A entidade Place, que representa um lugar, e a entidade MAgent, que representa um componente móvel, conforme as definições apresentadas no Capítulo 3.
De essa forma, essas duas entidades apresentam os atributos definidos para lugares e componentes móveis e as regras que definem seus comportamentos básicos, apresentadas na Seção 3.1.
A partir de as entidades criadas, criou- se um novo nível na hierarquia de entidades do simulador, conforme apresenta a Figura 34.
Segundo a hierarquia apresentada, Entity representa a entidade padrão do simulador, a qual é estendida por Place e MAgent.
A o construir sua aplicação, agora o usuário cria suas entidades (representadas por Entidade) estendendo Place ou MAgent.
Quando uma entidade da aplicação estende Place ou MAgent, ela incorpora o comportamento básico de uma entidade, como a capacidade de envio, recebimento e tratamento de mensagens, e o comportamento básico de um lugar ou um componente móvel.
De essa forma, a entidade da aplicação é descrita apenas com as características pertinentes ao âmbito da aplicação a qual pertence.
Em a etapa de simulação, entidades da aplicação poderiam ser criadas diretamente baseadas em Entity, as quais possuíssem seu comportamento descrito por as regras definidas para lugares e componentes móveis.
Assim, não seria necessário ter- se mais um nível na hierarquia para que fosse possível simularem- se aplicações envolvendo mobilidade.
O uso do nível em que estão Place e MAgent é necessário quando os mecanismos de movimentação da plataforma são utilizados.
Com isso, o uso de tais mecanismos é codificado dentro de estas entidades especiais, sem que seja preciso fazer- se o mesmo para cada entidade que representasse um lugar ou um componente móvel numa aplicação.
Esta hierarquia com três níveis é apresentada e utilizada desde a etapa de simulação para tornar mais simples o entendimento nas etapas seguintes.
As próximas etapas dizem respeito à geração de código executável, baseando- se no código gerado para simulação.
Deve- se dizer que é assumida, neste trabalho, a correção do mapeamento de uma especificação em GGBO para código do simulador, o que ainda não está provado formalmente, mas é indicado por a realização de testes.
Partindo- se desse pressuposto, argumenta- se aqui que o mapeamento criado para transformar o código de simulação em código executável foi realizado de forma a manter a semântica do simulador.
E o seu método de registro de regras.
Public class MC extends MAgent public ShoppingPlace bestLoc, origin;
O método answerMsg (linhas 4 a 6) define que esta regra trata a mensagem Continue.
O método conditionOk testa se a condição de execução da regra é satisfeita.
O método apply apresenta o resultado da aplicação da regra, que é a geração da mensagem GetIS, destinada ao lugar onde o MC se encontra, passando uma referência ao componente por parâmetro.
Já o método writeOnAttrib determina que esta é uma regra de leitura.
O método leftSideOccurs, nesta regra, não possui nenhuma restrição a ser testada e, portanto, apenas retorna o valor verdadeiro para o teste de condição.
A movimentação de uma entidade, na simulação, é representada por a alteração do valor de seu atributo de localização, significando que cada novo valor representa uma nova movimentação.
Isto é modelado com as regras apresentadas no Seção 3.1 para lugares e componentes móveis.
Em as seções seguintes, serão apresentadas as alterações realizadas para passar de código de simulação para código executável e de que forma argumenta- se a manutenção da semântica do código para simulação em cada etapa.
Geração de Código para Execução Local Como primeira etapa da geração de código para execução, realizou- se a retirada do kernel do simulador.
Como visto no Capítulo 4, o kernel é a entidade que controla o tempo de simulação e a comunicação entre as entidades.
A saída desta entidade centralizadora determinou que a troca de mensagens passasse a ser direta entre as entidades, sem a sua intervenção.
Outra característica que fica alterada é que o relógio simulado deixou de existir e passou- se a ter a execução regida por o tempo real.
Com isso, passou- se a desconsiderar o timestamp colocado nas mensagens, utilizado na simulação para determinar quais mensagens devem ser encaminhadas a seus destinos em cada instante do tempo simulado.
O timestamp da mensagem serve para representar a demora da mensagem para chegar na entidade de destino.
Com a introdução do tempo real, a semântica do código de simulação é preservada, visto que o tempo utilizado nas mensagens passou a ser definido por o tempo real gasto na transmissão da mensagem até o seu destino.
Para tornar possível a geração de código tanto para a simulação quanto para a execução local, realizaram- se alterações na estrutura das entidades e das regras.
Assim, o código mapeado permitia realizar- se uma simulação, intermediada por o kernel, ou a execução local, com a comunicação direta entre as entidades, sem interferência do kernel.
Ou seja, nesta etapa, uma simples alteração possibilitava utilizar o mesmo código da simulação para realizar- se uma execução local.
A escolha era definida por a existência ou não de um kernel.
A Figura 37 apresenta como ficou o código da entidade MC para uma execução local.
A principal mudança que pode ser notada é no método construtor, que não possui mais uma referência a uma instância de kernel, já que a comunicação entre entidades agora é direta.
Também devido a a saída do kernel, a outra mudança ocorre na inicialização das regras da entidade, onde também não é mais passada uma referência a um kernel.
Como acontece com o código da entidade, tudo o que envolvia o uso do kernel no código da regra é modificado.
Assim, o método de inicialização (linha 3) não recebe mais a referência ao kernel de simulação.
A outra modificação importante é no envio das mensagens geradas por a aplicação da regra.
As mensagens, antes enviadas para o kernel (como na linha 24 da Figura 36), agora são enviadas diretamente à entidade de destino através da invocação de seu método sendMessage.
Os parâmetros de uma mensagem também foram modificados.
Não é mais passada como parâmetro a identificação da entidade de destino da mensagem.
Isto porque, visto que a mensagem é enviada diretamente à entidade, essa informação, utilizada por o kernel para encaminhar a mensagem, não é mais necessária.
Como visto, as modificações do código de simulação para o código de execução local foram mínimas e o código de execução local obedece a um padrão que permite a automatização de sua geração, assim como para o código de simulação.
Geração de Código para Execução Distribuída A próxima etapa compreendeu permitir que as entidades, que executavam todas no mesmo lugar, passassem a poder executar de forma distribuída.
Esta transformação exigiu a utilização de suporte à distribuição, o qual foi fornecido por uma PSM.
A plataforma escolhida foi a Voyager, apresentada na Seção 2.1.3.
Com a introdução do uso da plataforma, a comunicação entre entidades passou a ser feita através de recursos fornecidos por o suporte utilizado, tal como chamadas remotas de métodos.
A escolha desta plataforma se deu em razão de que ela suporta um ambiente de acordo com as características relacionadas na Seção 3.1, fornecendo integridade referencial (se uma entidade se move, outras entidades que a referenciavam continuam com referências válidas) e comunicação remota e local confiáveis, dentro de o cenário assumido de inexistência de falhas.
Com isso, viabilizou- se a preservação da semântica do código de simulação, fornecendo- se o mesmo ambiente suportado no simulador, em o qual oferece- se comunicação confiável e integridade de referências.
A Figura 39 mostra o código gerado para a entidade MC para execução distribuída.
Para utilizar os recursos da plataforma, cada entidade deve possuir uma interface Java, onde são definidos os métodos públicos da entidade.
Ou seja, na interface da entidade definem- se quais métodos podem ser invocados remotamente.
Por isso, MC passou, nesta etapa, a implementar a interface IMC.
IMC estende a interface IMAgent, que é implementada por MAgent, que, por sua vez, estende a interface IEntity, implementada por Entity.
De essa forma, da mesma maneira que se tem uma hierarquia de entidades, tem- se também uma hierarquia das interfaces implementadas por estas entidades.
Como a comunicação entre entidades passa a ser suportada por a plataforma, uma referência a uma entidade é uma referência a uma proxy da entidade, conforme definida na Seção 2.1.3.2.
Assim atributos que referenciam outras entidades passam a ser do tipo da interface que estas entidades implementam.
De essa forma, o atributo respCustomer, que era do tipo Customer, passou a ser do tipo ICustomer (linha 7), que representa a interface da entidade Customer.
Logo, uma invocação de um método de Customer é feita através da sua proxy local, a qual possui a mesma interface que Customer.
A mesma mudança nos tipos dos atributos é visualizada no código das regras, como pode ser visto no código de MC_ R1 na Figura 40.
Além de a já citada modificação dos tipos dos atributos, outra modificação é que, visto que a comunicação ocorre através da interface das entidades, uma entidade precisa obter uma referência remota sua (proxy) para passar como parâmetro de uma mensagem.
Isto é obtido através do método getReference, implementado nas entidades Place e MAgent, o qual utiliza mecanismos da plataforma para obter uma proxy da entidade.
Para exemplificar o código gerado para mapear um grafo inicial de um sistema para execução distribuída (isto é, considerando os comandos da plataforma), a Figura 41 apresenta o código gerado para o grafo inicial apresentado anteriormente na Figura 20.
A linha 4 apresenta a inicialização da instância local da plataforma na porta 8000.
Entre as linhas 5 e 14 são feitas as inicializações das entidades do sistema.
Cada entidade é criada através do método Factory.
Create da plataforma, informado- se o local (endereço IP e porta) onde esta deve ser instanciada.
O retorno deste método é uma referência remota à entidade criada.
As linhas 15 a 24 apresentam os métodos de inicialização dos atributos de cada entidade.
Entre as linhas 25 e 27 encontra- se o código que descreve o envio da mensagem inicial para o grafo inicial representado (mensagem Next para a entidade MC).
Assim como na etapa anterior, as poucas diferenças entre o código de simulação para o código de execução distribuída permitem que se considere possível gerar- se automaticamente o código para executar sobre a plataforma.
Geração de Código para Execução com Mobilidade Tendo-se entidades distribuídas, pôde- se passar a implementar a idéia de que tais entidades pudessem se movimentar.
A capacidade de movimentação é suportada por a plataforma utilizada, provendo mecanismos tais como serialização de componentes e resolução de referências relativas a componentes móveis, como visto na Seção 2.1.3.4.
A fim de possibilitar a movimentação das entidades que estendem MAgent, foram feitas alterações na classe Entity.
Entity não executa mais como uma thread (isto é, não estende mais a classe Thread), como descrito no Capítulo 4, mas passa a possuir uma thread interna, ligada à entidade como um atributo transiente, a qual recebe as mensagens enviadas à entidade.
Isso foi necessário porque, sendo uma thread, não seria possível serializar- la e mover- la.
Como um atributo transiente, a thread é finalizada na origem e novamente instanciada quando a entidade chega ao destino.
Feita esta alteração, torna- se possível retomar o estado de execução da entidade após a sua movimentação.
A movimentação de uma entidade compreende os seguintes passos:
B) Salvar o estado de execução da entidade;
A transferência da entidade (passo 3) é feita através da invocação do mecanismo de mobilidade da plataforma, a qual fica responsável por garantir a transferência da entidade de um lugar a outro.
Este mecanismo é invocado a partir de a aplicação da regra Move, o que ocorre quando um Place recebe uma mensagem de MoveReq.
A Figura 42 destaca o trecho de código da regra Move onde é iniciado o processo de movimentação.
O comando da linha 5 representa o teste que pode ser utilizado para determinar se o lugar atende alguns requisitos para a movimentação, baseando- se no lugar de origem e no componente a ser movido.
Como tais requisitos serão definidos é um tema para estudos futuros.
Em a linha 7 é dado o comando que informa ao MAgent que ele deve se mover.
O método go recebe, como parâmetro, uma referência ao lugar de destino da movimentação.
A Figura 43 apresenta o código do método go.
Try Agent. Of (this).
MoveTo (place, &quot;atPlace&quot;);
O método go causa a parada da entidade através do método stopEntity (linha 5) e invoca o serviço de movimentação da plataforma de suporte (linha 6).
Portanto, o comando da linha 6 fornece a implementação real do passo 3 na movimentação da entidade.
O primeiro parâmetro indica o lugar de destino da movimentação, enquanto o segundo determina o método a ser executado logo que a entidade esteja relocada.
A indicação deste método serve como um ponto de reinicialização da execução da entidade.
A o final da movimentação, caso a movimentação tenha sido bem sucedida, o método indicado como parâmetro do comando de movimentação (linha 6 da Figura 43) é executado por o MAgent.
Este método é apresentado na Figura 44.
O método initialize (linha 3) define a implementação da reinicialização da entidade.
Com a resposta positiva do lugar de destino (recebida através da mensagem MvAnswer), o lugar de origem assume que o componente móvel foi relocado e envia as mensagens definidas na regra AcceptMove, informando ao lugar de destino para incluir o novo componente e, ao MAgent, para atualizar o seu atributo de localização.
O passo 2.
A, que refere- se ao salvamento dos valores dos atributos internos da entidade, também é suportado por a plataforma, a qual serializa os atributos da entidade na origem e os desserializa no destino.
Dados da entidade que não possuem a capacidade de serem transmitidos através da rede (não são serializáveis) são definidos como transientes e são novamente inicializados ao término da movimentação.
O passo 4 é implementado por a plataforma através do mecanismo de resolução de referências apresentado na Seção neste trabalho.
O passo 1 consiste em fazer cessar qualquer atividade interna da entidade.
Isto implica parar a thread interna da entidade, responsável por o recebimento de mensagens, e garantir que não há regras em execução.
Assim, quando se inicia um processo de movimentação, a thread interna é finalizada, impedindo que novas mensagens sejam processadas.
Finalizada a thread, antes da transferência da entidade, deve- se esperar que todas as regras em execução sejam finalizadas.
Tão logo isso ocorra, a entidade pode então ser movida.
A codificação desse passo foi incluída no código da entidade no método stopEntity, apresentado na Figura 45.
Este método é invocado dentro de o método que implementa a movimentação real da entidade, apresentado na Figura 43.
A primeira providência (linha 2) é modificar o status da entidade, definindo- a como inativa, o que impede que ela receba novas mensagens enquanto estiver se movimentando.
Tais mensagens entrarão no buffer da entidade quando esta estiver no local de destino da movimentação.
Após isso, é forçado o término do trabalho da thread interna.
O que ocorre é que a thread interna pode estar bloqueada, à espera de um aviso do buffer de que existe uma nova mensagem a ser tratada.
O comando da linha 3 força o desbloqueio da thread interna, caso esteja bloqueada esperando novas mensagens chegarem ao buffer.
Quando a thread recebe o sinal de desbloqueio, ela testa se existe uma mensagem nova a ser tratada e se a entidade ainda está recebendo mensagens (entidade está ativa).
Como a entidade não está mais ativa, a thread é finalizada.
A informação da finalização da thread interna é obtida com o código presente nas linhas 4 a 5.
O último passo é esperar que as regras em execução sejam finalizadas, o que é feito através do código descrito entre as linhas 6 e 11.
A reinicialização da entidade (passo 5), realizada após uma movimentação, compreende a reinicialização da thread interna da entidade, restabelecendo a sua capacidade de receber mensagens, e permitir que regras possam passar a executar, a fim de tratar mensagens pendentes e futuras mensagens.
O código de reinicialização da entidade é apresentado na Figura 46.
O método initialize também está incluído no código da entidade e é invocado sempre que uma movimentação é bem sucedida, dentro de o método atPlace, apresentado na Figura 44.
Os passos seguidos para reinicializar a entidade são modificar seu atributo de status para definir a entidade como ativa (linha 3), permitindo que ela volte a receber mensagens, e reinicializar a thread interna (linhas 4 e 5).
O passo 2.
B, neste trabalho, diz respeito a garantir que todas as mensagens enviadas a uma entidade são recebidas e processadas por ela, mesmo que ela se mova.
Isto é garantido por os mecanismos de parada e restauração das atividades da entidade que foram implementados (apresentados na Figura 45 e na Figura 46, respectivamente), em conjunto com um mecanismo de comunicação confiável, implementado para garantir que mensagens enviadas durante a movimentação da entidade sejam recebidas por ela.
Tal mecanismo deveria ser fornecido por a plataforma, mas, durante os testes realizados, ficou demonstrado que havia perdas de mensagens, o que exigiu a criação deste mecanismo dentro de o presente trabalho.
Conforme a implementação realizada, a regra de movimentação acontece isoladamente (ou seja, sem a concorrência com o processamento de outras regras) e as referências à entidade são mantidas válidas por a plataforma utilizada.
A o final da movimentação, a entidade passa a executar no novo local, a partir de o mesmo estado em que se encontrava no local anterior, processando a próxima mensagem do buffer.
De essa forma, mantém- se a semântica esperada na especificação.
Os códigos gerados para entidades e regras permanecem os mesmos que na etapa anterior (execução distribuída).
As mudanças realizadas restringiram- se às alterações na classe Entity, já citadas, e na implementação das regras de movimentação, onde a movimentação física da entidade é implementada através do uso dos recursos da plataforma em meio à execução das regras.
Com isso, a movimentação de uma entidade é representada por sua movimentação física, realizada através dos passos apresentados anteriormente, e por a alteração de seu atributo de localização.
Como resultado das etapas seguidas, chegou- se à geração de código para execução com mobilidade que, segundo discutido, mantém a semântica do código mapeado para o simulador PLATUS e que permite, segundo uma análise inicial, que tal código seja gerado automaticamente.
A geração automática de código é uma etapa considerada como um trabalho futuro.
O que se quer é que seja possível criar- se uma especificação em GGBO num editor e, a partir de essa especificação, gerar código para simulação no PLATUS e/ ou para execução sobre a plataforma Voyager.
Uma ressalva que deve ser feita é que também se cogita a possibilidade de realizar- se a geração de código para outras plataformas de suporte à mobilidade.
Considera- se que a adaptação do mapeamento aqui proposto para uma outra plataforma exigiria apenas a modificação na regra de lugar que ocasiona a movimentação do componente e na implementação do método que movimenta o componente, codificado na entidade MAgent.
Como forma de avaliar o trabalho desenvolvido, foi realizado um estudo de caso que envolvia um cenário mais complexo do que os testes desenvolvidos anteriormente.
O estudo de caso, a seguir descrito, envolveu conceitos de redes ativas e tinha como objetivo representar um cenário de redes ativas através de GGBO.
Os conceitos de redes ativas serão apresentados na seção seguinte, sendo descrito como eles foram representados em GGBO.
Cabe salientar que, visto que este estudo de caso visava avaliar o trabalho desenvolvido, todos os elementos envolvidos são entidades que se baseiam em Place ou em MAgent.
Quando é dito que uma entidade se baseia em outra se quer dizer que uma entidade incorpora o comportamento e os atributos da entidade em a qual ela se baseia.
O termo herança não pode se usado aqui uma vez que GGBO não apresenta uma forma de representação de hierarquia de herança entre entidades.
Redes Ativas Tradicionalmente, a função de uma rede é encaminhar pacotes de um nodo a outro.
O processamento dentro de a rede ocorre com a realização do roteamento de pacotes, a realização de algum tipo de controle de congestionamento e a implementação de esquemas de qualidade de serviço (QoS).
Sendo assim, as redes tradicionais não possuem a capacidade de processar dados submetidos por o usuário.
Isto é, todo o processamento ocorre de forma estática, através de instruções predefinidas na configuração dos dispositivos da rede.
Devido a esta característica de funcionalidade restrita de processamento, redes deste tipo são denominadas de redes passivas.
Em este tipo de rede, torna- se difícil a integração de novas tecnologias, visto que isto normalmente exige a troca de equipamentos ou a reconfiguração destes por a administração da rede.
Também fica dificultada a introdução de novos serviços sem modificações no modelo arquitetural já existente para a rede.
A fim de superar tais dificuldades e outras encontradas em redes convencionais, surgiu a idéia das chamadas redes ativas.
Redes ativas representam uma nova abordagem para a arquitetura de redes, sendo que elas são denominadas como ativas porque os roteadores podem, assim como os outros nodos da rede, realizar computações sobre os dados de usuário que passam por eles a partir de programas fornecidos por o próprio usuário.
Assim, os usuários podem, de certa forma, &quot;programar «a rede.
Em redes ativas é permitido, portanto, que programas sejam dinamicamente inseridos nos nodos da rede, a fim de configurar- los de acordo com as necessidades das aplicações que estão executando.
Para isso, existe a possibilidade de pacotes carregarem não apenas dados, mas também programas a serem executados nos nodos por que passarem.
Em uma rede ativa, torna- se muito tênue a diferença entre nodos internos da rede (roteadores, switches, etc.) e nodos de usuário, uma vez que ambos possuem a capacidade de realizar as mesmas computações.
Assim, o usuário pode, de certa maneira, considerar a rede como parte do seu próprio sistema, podendo adaptar- la para obter maior eficiência de suas aplicações.
Existem três abordagens para arquiteturas de redes ativas:
Pacotes ativos:
Nodos não armazenam código.
O código é transportado por os pacotes ativos (também chamados de cápsulas em algumas arquiteturas) que trafegam na rede.
Os nodos podem realizar computações com os códigos trazidos por os pacotes.
Alguns exemplos desta abordagem são o Smart Packets e o Active IP Option;
Nodos ativos:
Pacotes não carregam o código real, mas apenas alguns identificadores ou referências a funções predefinidas existentes nos nodos ativos.
Assim, os pacotes contêm a definição do tipo da função que será executada sobre os seus dados e fornecerem os parâmetros para a execução desta função.
O código real encontra- se nos nodos ativos, os quais executam a função necessária para tratar o pacote recebido.
Exemplos desta abordagem são as arquiteturas DAN e ANTS;
Pacotes e nodos ativos:
Esta abordagem é uma combinação das duas anteriores, onde os pacotes ativos carregam o código real e os nodos ativos possuem códigos mais complexos.
Assim, o usuário tem a possibilidade de utilizar tanto a abordagem de pacotes ativos como a de nodos ativos, além de poder utilizar- las em conjunto.
Como exemplos, podem ser citadas as arquiteturas SwitchWare e NetScript.
Em este trabalho, foi considerada, para a realização do estudo de caso, uma arquitetura baseada em redes ativas onde os seus elementos são nodos ativos, cápsulas, serviços, bases de código e servidores de nomes.
Esta arquitetura baseia- se na abordagem de nodos ativos.
Os nodos ativos possuem a capacidade de receber e enviar cápsulas de e para outros nodos.
Cada cápsula carrega dados e possui a informação de qual serviço é necessário para tratála.
Um serviço é um componente móvel que possui o código que define como tratar ou interagir com um tipo de cápsula, determinando o que fazer com os dados que ela carrega.
Assim, cada nodo possui uma lista de serviços disponíveis, determinando os tipos de cápsulas que ele pode tratar.
Nodos ativos podem requisitar novos serviços de uma base de código.
Uma base de código representa um componente que possui a lista de serviços disponíveis para a rede em que se encontra.
A base de código provê o envio de uma instância do serviço para os nodos ativos requisitantes.
A comunicação entre todos os elementos se faz através de referências remotas.
Para obter uma referência remota a um elemento, o elemento requisitante precisa possuir o nome que identifica o elemento procurado e enviar uma requisição de resolução de nome para um servidor de nomes.
O servidor de nomes é um elemento que possui uma lista de índices, onde cada índice possui uma referência associada a um nome de identificação de uma entidade.
Além de pedidos de resolução de nomes, o servidor de nomes também fornece os serviços de registro, remoção e alteração de referências.
O servidor de nomes é necessário uma vez que, em GGBO, não é possível ter- se uma lista de referências a entidades.
Por isso, cada índice do servidor de nomes é uma entidade que possui atributos para armazenar a referência a uma entidade e o nome associado àquela entidade.
Cada índice possui uma referência ao próximo índice da lista, o que permite o caminhamento dentro de a lista para buscar uma referência.
Mais detalhes sobre o servidor de nomes podem ser conhecidos em.
Especificação em GGBO de Redes Ativas O funcionamento padrão da arquitetura definida neste trabalho foi especificado em GGBO, determinando os atributos das entidades envolvidas e o comportamento básico de cada uma de elas.
Tais entidades são agora descritas através de seus grafos de tipos e suas regras.
Especificação de um Nodo Ativo Para representar um nodo ativo, foi criada a entidade ActiveNode (AN).
Esta entidade baseia- se na entidade Place, podendo, portanto, entre outras coisas, receber componentes móveis e oferecer serviços de movimentação de componentes.
O grafo de tipos para a entidade ActiveNode é apresentado na Figura 47 e na Figura 48.
A Figura 47 mostra a primeira parte do grafo de tipos, onde constam os atributos da entidade e as mensagens recebidas por ela.
A Figura 48 mostra as mensagens enviadas por a entidade ActiveNode.
Um AN é identificado por um nome (atributo host_ id), usado para a comunicação com outros nodos.
Cada AN possui uma referência a uma base de código (atributo code_ base) à qual pode requisitar instâncias de serviços de que necessite.
As identificações dos serviços já disponíveis num AN constam em sua lista de serviços (atributo services).
Um AN possui também uma referência a um servidor de nomes local (atributo local_ ns) usado para registrar referências aos serviços locais.
De essa forma, sempre que um serviço é requisitado por uma cápsula através de sua identificação, o AN verifica se o serviço consta em sua lista de serviços.
Caso ele conste, o AN faz um pedido de resolução de nome para o servido de nomes local, a fim de obter uma referência ao serviço procurado.
O servidor de nomes local também serve para armazenar as identificações dos nodos conhecidos por o AN, com os quais ele pode se comunicar.
Um AN contém ainda uma referência a um servidor de nomes global (atributo ns), o qual serve para registrar informações gerais sobre a rede, tais como as identificações de todos os nodos da rede e todos os serviços disponíveis.
O atributo inBroadCast serve para controlar a execução de broadcasts, como será visto mais adiante.
O tipo List é um tipo definido neste trabalho e representa uma lista que possui as seguintes operações:·
List add (item):
Adiciona item ao fim da lista e retorna a lista resultante;·
List addFirst (item):
Adiciona item no início da lista e retorna a lista resultante;·
List addListFirst (List):
Adiciona todos os elementos da lista recebida por parâmetro ao início da lista original e retorna a lista resultante;·
List addList (List):
Adiciona todos os elementos da lista recebida por parâmetro ao fim da lista original e retorna a lista resultante;·
List remove (item):
Remove item da lista e retorna a lista resultante;
Resultante; Um item é um valor cujo tipo pertence a um dos tipos básicos de Gramáticas de especificador, tal como List.
Deve- se ressaltar que tipos abstratos de dados em GGBO devem ser especificados usando especificação algébrica.
Em o âmbito deste trabalho, tipos abstratos serão, por uma questão de simplicidade, definidos de maneira informal.
É assumida, dessa forma, a correção das operações realizadas sobre tipos abstratos de dados aqui definidos.
Um AN possui três funções:
Enviar cápsulas em modo unicast (de um AN para outro), enviar cápsulas em modo broadcast (de um AN para todos os AN da rede) e prover serviços para tratar as cápsulas recebidas.
A função mais básica de um AN é o envio de cápsulas a outros AN, tal qual um nodo envia pacotes para outros nodos numa rede convencional.
Esta função é realizada através das regras SendMessage e GetReference, apresentadas na Figura 49 e na Figura 50, respectivamente.
Capsule A regra SendMessage representa o recebimento, por parte de o AN, de um pedido de encaminhamento de uma cápsula a um outro AN.
O pedido é recebido através da mensagem SendMsg.
Esta mensagem possui, como parâmetros, a identificação do AN de destino da cápsula e uma referência à cápsula que deve ser enviada.
De posse da identificação do destino da cápsula, o AN faz uma requisição ao servidor de nomes local (representado por a entidade Ns) para obter uma referência ao nodo de destino.
Esta requisição é feita através de uma mensagem Resolve, que leva, como parâmetros básicos, o tipo da operação (parâmetro type_ op), usado internamente por o Ns, uma referência à entidade requisitante (parâmetro obj_ req) e a identificação do nodo cuja referência é requisitada (parâmetro name).
Como GGBO é inerentemente paralela, representar computações seqüenciais não é natural.
Observe- se, por exemplo, a regra SendMessage na Figura 49.
O parâmetro type é usado para que, ao obter a resposta a uma requisição, o AN possa ter a informação de como utilizar a referência recebida, podendo realizar uma comunicação unicast, uma comunicação broadcast ou pode ainda encaminhar um serviço a outro nodo (valor 2).
No caso de a regra citada, o valor 0 do parâmetro type indica que a referência a ser obtida servirá para uma comunicação unicast.
Com isso, o parâmetro type não possui nenhuma utilidade para o destinatário da mensagem, mas serve apenas para armazenar uma informação que será útil posteriormente.
O parâmetro capsule serve para que a referência à cápsula que deve ser enviada não seja perdida ao término da regra.
De acordo com o formalismo utilizado, só há duas possibilidades de não se perder valores após uma aplicação de regra:
Repassando o valor como parâmetro de uma nova mensagem, de forma que ele retorne por outra mensagem para ser usado numa regra posterior da entidade, ou armazenando o valor num atributo da entidade.
Em a verdade, nenhuma das duas alternativas é muito agradável, haja vista que a primeira exige que se utilizem parâmetros de mensagens sem função alguma, enquanto que a segunda exige a criação de atributos que servem só como forma de armazenamento temporário de valores.
Em este caso, está sendo usado um parâmetro de uma mensagem para manter a referência.
O parâmetro an serve para a mesma finalidade, mas não é utilizado nesta regra, estando presente apenas por constar entre os parâmetros da mensagem Resolve.
A resposta à requisição feita ao Ns é tratada por a regra GetReference.
A mensagem Reference traz a referência requisitada, entre outros parâmetros, em os quais se inclui a referência à cápsula que deve ser enviada.
O AN, utilizando a referência ao nodo de destino como parâmetro.
Isto informa a cápsula de que ela deve mover- se para o AN indicado.
A função de envio de cápsulas em modo broadcast é realizada através do envio de múltiplas cápsulas em modo unicast.
A regra SendBroadCast trata o recebimento de um pedido de envio de broacast.
O pedido é feito através da mensagem SendBCast, que tem, como parâmetro, uma referência à cápsula que deve ser enviada.
O envio em modo broadcast compreende obter a lista de AN para os quais a cápsula deve ser enviada e, para cada AN de destino, obter uma referência ao destino, criar uma cópia da cápsula e enviar a cópia.
Por isso, a primeira ação do AN ao receber a mensagem SendBCast é requisitar ao Ns a lista de todos os AN conhecidos.
No caso de uma rede fixa, os AN conhecidos são aqueles com quem o AN tem ligação direta.
Já para uma rede móvel, onde os nodos não possuem conexões físicas uns com os outros, os AN conhecidos representam todos os nodos alcançáveis por os sinais enviados por o AN de origem.
A requisição dos AN conhecidos é feita através da mensagem GetAllRef, tendo uma referência à cápsula a ser enviada e uma referência ao AN requisitante como parâmetros.
A regra StartBroadCast (Figura 52) trata o recebimento da lista de AN conhecidos.
Caso a lista não esteja vazia (existe pelo menos um AN conhecido), o AN requisitante armazena em seu atributo names a lista de identificações recebidas e envia a si mesmo uma mensagem StartBCast, contendo a referência à cápsula como parâmetro.
O teste sobre o atributo inBroadCast serve para impedir que outro broadcast inicie e as informações do broadcast atual sejam sobrescritas.
Isto porque as referências aos destinos de um broadcast são armazenadas no atributo names e assim, caso outro broadcast seja iniciado, os dados contidos em names seriam perdidos.
Como especificado, um novo broadcast só acontecerá quando um broadcast inicial tenha terminado (valor de inBroadCast é false).
A mensagem StartBCast, tratada por a regra ResolveNextName (Figura 53), serve para iniciar o processo de envio em broadcast.
A o receber tal mensagem, o AN retira o primeiro elemento da lista e envia um pedido de obtenção de referência ao Ns.
Note- se que agora o parâmetro type da mensagem Resolve tem o valor 1, o que identifica que a resposta servirá para um broadcast.
Quando a resposta é retornada por o Ns, é executada a regra CloneCapsule (Figura 54).
Como já foi dito, para enviar uma cápsula em broadcast, é preciso criar uma cópia da cápsula para cada AN de destino.
Assim, o AN envia a mensagem Clone para a cápsula, requisitando que esta se autoduplique, e uma mensagem Next para si mesmo, contendo a referência à cápsula.
A mensagem Next é usada para representar a repetição do processo de envio da cápsula para um destino, como será visto logo adiante.
Quando a cápsula retorna a referência a sua duplicata, através da mensagem NewCapsule, a regra SendToNext (Figura enviando- a para o AN que havia sido retirado da lista.
A o receber a mensagem Next, o AN repete a processo visto até aqui.
De essa forma, ele retira o próximo AN da lista e requisita uma referência ao AN com o envio da mensagem Resolve ao Ns, conforme apresentado na Figura 56.
Quando a reposta do Ns é retornada, é novamente executa a regra CloneCapsule (Figura 54) e as regras subseqüentes.
Este processo se repete até que a lista de AN conhecidos esteja vazia.
Isto significa que a cápsula foi enviada a todos os AN conhecidos.
A regra EndBCast tem a função de mudar o valor do atributo inBroadCast para false (independentemente do valor atual desse atributo), indicando que um novo broadcast pode iniciar.
A função mais importante de um AN, que o diferência realmente de um nodo comum, é a instalação dinâmica de serviços.
Isto lhe dá a capacidade de agregar serviços sob demanda.
Assim, um AN pode iniciar possuindo apenas os serviços básicos e, de acordo com o necessário, pode requisitar e instalar os serviços de que precisar.
Como apresentado no grafo de tipos de um AN (vide Figura 47), cada nodo ativo possui a lista de serviços de que dispõe (atributo services).
Assim, quando um AN recebe uma cápsula e esta lhe informa de qual serviço necessita, sua primeira providência é verificar se ele possui o serviço pedido (serviço consta na lista).
Se o serviço não constar na lista de serviços disponíveis, o AN então verifica se já não gerou uma requisição pedindo o mesmo serviço.
O AN realiza esta verificação buscando a identificação do serviço procurado na lista de pedidos pendentes (atributo pending).
Caso o serviço também não tenha sido requisitado ainda, o AN gera então uma requisição para a base de código conhecida (CB) pedindo o serviço, conforme especificado na regra RequestService descrita na Figura 58.
Um pedido de requisição de serviço é feito através da mensagem ServiceReq.
Em esta mensagem constam a identificação do serviço requisitado, uma referência ao AN que está requisitando serviço e uma referência à cápsula que necessita do serviço.
Este último parâmetro serve para a manutenção da referência à cápsula, a fim de utilizar- la mais tarde, tal como já discutido anteriormente.
A o chegar ao AN, o serviço requisitado faz um pedido de instalação.
A instalação de um serviço compreende a inclusão de sua identificação na lista de serviços disponíveis do AN e o seu registro no servidor de nomes local.
Ao mesmo tempo em que realiza a instalação do serviço, o AN passa para a cápsula requisitante a referência ao serviço para que ela possa utilizar- lo através da mensagem Service.
O comportamento de um AN para a instalação de um serviço é descrito na regra ServiceInstallation na Figura 59.
A condição estabelecida na regra ServiceInstallation de que só são aceitas instalações de serviços previamente requisitados (ou seja, que constam na lista de requisições pendentes) é usada para impedir a instalação de serviços desnecessários ao nodo ou já instalados.
Assim que um serviço requisitado é recebido, ele é retirado da lista de requisições pendentes.
Se uma cápsula chegar ao AN e requisitar um serviço que já foi requisitado à base de código e que ainda não foi fornecido, o pedido do serviço será postergado, conforme a semântica de GGBO.
Assim, logo que o serviço seja instalado, ele passará a constar e na lista de serviços disponíveis e os pedidos serão tratados por a aplicação da regra FindService.
Como visto, o AN realiza uma função de intermediador entre cápsulas e serviços, provendo o necessário para que estes possam interagir.
Especificação de uma Cápsula Para representar uma cápsula foi criada a entidade Capsule.
Esta entidade foi definida segundo o grafo de tipos apresentado na Figura 62.
Uma cápsula realiza o papel de um pacote que trafega entre os nodos da rede.
De essa forma, ela possui sempre a informação de qual o nodo que originou a cápsula (atributo orig) e qual o nodo de destino (atributo dest).
Sendo que a entidade Capsule estende o comportamento da entidade MAgent, ela também possui a informação de sua localização corrente (atributo location).
O atributo restante (atributo req_ service) informa qual o tipo de serviço exigido por a cápsula e que deve ser provido por o AN que receber esta cápsula.
Cápsulas podem ser criadas dinamicamente, o que determina que sua especificação inclua uma regra que defina como ocorre a inicialização de uma cápsula recém criada.
A inicialização de uma cápsula criada dinamicamente é necessária para que ela possa receber os valores iniciais de seus atributos.
Como visto em 3.1.1, as regras de inicialização de entidades devem se basear no esquema de regra definido e apresentado na Figura 7.
Assim, o esquema de regra de inicialização de uma entidade é adaptado para representar a inicialização de uma cápsula, conforme apresentado na Figura 63.
A inicialização de uma cápsula compreende apenas a atribuição de valor inicial ao seu atributo que indica o serviço necessário para interagir com ela e a seu atributo de localização.
A função básica de uma cápsula é mover- se entre nodos da rede.
A movimentação de uma cápsula ocorre a partir de uma requisição do AN onde se encontra.
Um AN requisita a movimentação de uma cápsula através da mensagem Send, conforme ilustrado na regra GoToHost, apresentada na Figura 64.
A movimentação de uma cápsula é realizada conforme o estabelecido nas regras básicas de lugares e componentes móveis, descritas na Seção 3.1.
Isto significa que o processo de movimentação é iniciado por o envio da mensagem Move por a cápsula ao AN local.
Como também definido nas regras básicas, o final de uma movimentação determina o recebimento, por o componente móvel, de uma mensagem Continue (movimentação foi bem sucedida) ou NoGo (não foi possível mover o componente).
O tratamento de uma movimentação sem sucesso fica a cargo de o especificador da aplicação específica, não sendo, portanto, considerado aqui.
No caso de uma movimentação sem problemas, o comportamento a ser seguido por a cápsula é apresentado na Figura 65 na regra AskForService.
Logo que chega a um AN, a cápsula deve requisitar o serviço de que necessita.
Por isso, ela envia a mensagem GetService ao AN em que se encontra informando qual serviço deseja.
A referência ao serviço é retornada por o AN através da mensagem Service.
Esta mensagem é tratada de acordo com o estabelecido por a aplicação de a qual a cápsula e o serviço fazem parte.
Assim, definiu- se o esquema de regra SendToService (Figura 66) para representar a interação inicial entre uma cápsula e o serviço que a trata.
Este esquema de regra define que a cápsula deve enviar uma mensagem ao serviço passando sua referência, permitindo que cápsula e serviço possam interagir.
Além de a referência, a cápsula pode ainda passar dados que sejam necessários, conforme a aplicação necessite.
A partir de aí, a interação entre estas duas entidades ocorre conforme a aplicação específica.
Como visto na descrição do comportamento de um AN, para que seja feito o envio de cápsulas em modo broadcast, é necessário que elas sejam duplicadas.
Para isso, o esquema de regra CreateClone define como ocorre a duplicação de uma cápsula.
Este esquema de regra é apresentada na Figura 67.
A duplicação da cápsula determina a criação de uma nova cápsula e a sua inicialização com o mesmo estado interno da cápsula original.
Atributos de entidades que estendam Capsule também devem ser considerados quando for definida a regra de duplicação destas entidades particulares.
Especificação de um Serviço Um serviço é representado por a entidade Service.
Service assume o comportamento da entidade MAgent, uma vez que um serviço deve poder ser movido de uma base de código para um AN.
O grafo de tipos da entidade Service é apresentado na Figura 68.
Um serviço possui uma identificação (atributo service_ id) e, sendo um componente móvel, armazena também a informação de sua localização atual (atributo location).
O atributo capsule serve apenas para armazenamento temporário.
O uso desse atributo será visto mais adiante.
Como já apresentado quando de a descrição das especificações de nodos ativos e cápsulas, um serviço executa num AN e interage com as cápsulas que necessitarem deste serviço.
Assim como as cápsulas, serviços podem ser criados dinamicamente, já que novos serviços podem ser implantados na rede a qualquer momento.
A Figura 69 apresenta o esquema de regra de inicialização de um serviço.
Sendo um componente móvel, um serviço move- se através do comportamento descrito nas regras básicas da Seção 3.1.
O comando para a movimentação de um serviço é dado por uma base de código (CB).
Portanto, um serviço move- se sempre de uma base de código para um nodo ativo, onde deverá executar.
A movimentação do serviço é iniciada por o recebimento da mensagem SendService, segundo apresentado na regra GoService, a qual pode ser vista na Figura 70.
Move dest Em esta regra, o atributo capsule de um serviço é utilizado para armazenar a referência à cápsula que requisitou o serviço, a fim de não perder- la durante o processo de movimentação.
Assim, logo que a movimentação termina, o serviço pode recuperar a referência à cápsula de forma a encaminhar- la ao AN em que se encontra através da mensagem Install.
Esta mensagem informa o AN de que o serviço deseja ser instalado e aguarda a interação com a (s) cápsula (s) que o requisitaram.
A regra RequestInstallation apresenta o envio do pedido de instalação.
Como ocorre com as cápsulas, serviços também precisam ser duplicados.
Isto porque a base de código mantém os serviços originais e envia aos AN as réplicas.
A duplicação de um serviço ocorre conforme o esquema de regra apresentado na Figura 72.
A utilização de serviços na arquitetura proposta deverá ser melhor entendida quando for apresentada a especificação do algoritmo de Dynamic Source Routing, na Seção 7.2.
Especificação de uma Base de Código A base de código é uma entidade que se baseia na entidade MAgent e é a responsável por manter a lista de serviços disponíveis na rede.
O grafo de tipos da entidade CodeBase (CB), que representa uma base de código, é apresentado na Figura 73 e na Figura 74.
Uma base de código, como já dito, controla a lista de serviços que podem ser providos por os nodos da rede.
Esta lista mantém as identificações dos serviços disponíveis (atributo list_ of_ services).
Para obter a referência a um serviço cuja identificação consta nesta lista, a CB possui uma referência a um servidor de nomes local à CB (Ns) em o qual são registrados os serviços de toda a rede.
Como entidade controladora da lista de serviços, a CB pode receber requisições de adição de novos serviços, conforme apresenta a regra AddService ilustrada na Figura 75.
O registro de um serviço é feito através de sua identificação (service-id) e de sua referência (service_ agent), as quais são passadas ao Ns.
A identificação do serviço é também adicionada à lista de serviços da CB, significando que o novo serviço está agora disponível.
De posse da referência pedida, a CB, a fim de enviar o serviço ao AN que o requisitou, solicita ao serviço a sua duplicação, assim como pode ser visto na regra ServiceReference na Figura 77.
A regra MoveService apresenta o recebimento da referência à nova instância do serviço, a qual é, então, encaminhada ao AN requisitante.
Não foi especificado um comportamento a ser adotado quando a CB recebe um pedido de um serviço que não conste em sua lista.
Isto porque se assume que todas as cápsulas que trafegam na rede possuem um serviço previamente registrado por a CB.
Assim, os pedidos de serviços por os AN só ocorrerão em relação a serviços constantes na lista de serviços da CB.
Obviamente que num ambiente aberto não se pode ter essa garantia, uma vez que cápsulas podem transitar entre redes diversas.
Mas, por simplificação da especificação, tal questão não é tratada aqui, podendo fazer parte de um estudo futuro.
Um segundo estudo de caso desenvolvido apresentava um cenário de uma rede onde os nodos são nodos ativos (AN).
Ou seja, um cenário onde a rede era uma rede ativa tal como descrito no primeiro estudo de caso.
Assim, todo o trabalho nessa rede ocorre segundo a especificação de redes ativas apresentada na Seção 6.2.
Em esta rede, definida como uma rede fixa (nodos são interligados por conexões físicas) no cenário deste estudo de caso, cada AN está conectado a alguns AN da rede, com os quais pode se comunicar diretamente.
O encaminhamento de mensagens entre nodos da rede é feito segundo o algoritmo de roteamento Dynamic Source Routing (DSR), o qual é apresentado a seguir.
Algoritmo de Roteamento DSR O algoritmo de roteamento Dynamic Source Routing (DSR) foi idealizado para prover roteamento de mensagens entre nodos em redes ad hoc.
Uma rede ad hoc é um tipo de rede móvel (nodos não possuem conexão física entre si), onde os dispositivos computacionais são capazes de trocar informações diretamente entre si.
De essa forma, não existe a conexão dos nodos com uma estação base, a qual intermedia a comunicação entre nodos, tal como ocorre na comunicação entre telefones celulares.
Em uma rede ad hoc qualquer nodo pode ser trabalhar como um roteador, encaminhando pacotes recebidos de outros nodos para os seus nodos de destino.
O DSR é um algoritmo do tipo source routing, isto é, com roteamento na fonte.
Assim, o nodo origem deve, ao enviar o pacote, determinar todo o caminho a ser percorrido por este pacote.
O DSR não gera mensagens periódicas para atualização de informações de roteamento, como ocorre com outros algoritmos, o que significa economia de banda de rede e de energia da bateria dos dispositivos móveis.
Apesar disso, seu uso é aconselhável apenas em pequenas redes, com cinco a dez nodos.
O protocolo DSR é composto por dois mecanismos:
O mecanismo de Descoberta de Rotas e o mecanismo de Manutenção de Rotas.
Estes mecanismos são apresentados a seguir.
Descoberta de Rotas Descoberta de Rotas é o mecanismo por o qual um nodo de origem obtém, dinamicamente, uma rota a um nodo destino, para quem deseja enviar um pacote.
Este mecanismo é usado toda vez que o nodo de origem não conhece uma rota para o nodo de destino.
Todos os nodos possuem uma cache de rotas (Cr), em a qual ficam armazenadas as rotas conhecidas para outros nodos, podendo ser armazenadas várias rotas para um mesmo destino.
Assim, quando um nodo fonte F deseja enviar um pacote a um nodo destino D, ele verifica em sua cache se possui uma rota para D. Caso haja uma rota previamente conhecida para D, o pacote é encaminhado por esta rota.
Se não possuir uma rota, o nodo F inicia o processo de descoberta de rota, enviando um broadcast de um pacote de requisição de rota (PReq).
Em este pacote consta a identificação do nodo que originou a requisição, a identificação do nodo para o qual está sendo requisitada uma rota e uma lista de nodos por os quais a requisição passou, representando a rota da origem ao destino, a qual é inicializada com a inclusão da identificação do nodo originador.
Também é adicionado ao PReq um número único de identificação da requisição, gerado por o originador.
A lista de nodos visitados é inicializada com a identificação do nodo que originou o PReq.
Quando um nodo recebe um PReq, ele segue o seguinte algoritmo:
Se ele for o destino procurado, então:
Gera um pacote de reposta (PResp), contendo a lista de nodos do PReq recebido, mais a sua identificação, formando a rota completa da origem ao destino.
Este pacote é encaminhado ao originador, sendo enviado ao primeiro nodo rota.
A resposta ao originador pode ser encaminhada de três formas:
Através de uma rota para o originador presente na Cr;
Através da obtenção de uma rota por a realização de um novo processo de descoberta de rota;
Ou enviando a resposta por a rota contrária aquela constante na lista de nodos do PReq;
Caso não seja o destino procurado, então:
Se a identificação do nodo já estiver na lista de nodos do PReq recebido, o nodo ignora a requisição, já que já a havia recebido anteriormente;
Se não estiver na lista de nodos, o nodo verifica se possui, em sua Cr, uma rota para o destino procurado:
Se houver uma rota, gera um PResp para o originador, adicionando a rota de sua Cr à lista de nodos do PReq recebido;
Se não houver uma rota, adiciona- se à lista de nodos e gera um broadcast encaminhando o PReq aos seus vizinhos.
Cada nodo também possui uma lista de requisições recentes (LRR), contendo a identificação de todas as requisições recebidas recentemente.
Assim, ao receber uma requisição, o nodo verifica se já não havia recebido aquela mesma requisição.
Se isto tiver ocorrido, o nodo ignora a requisição, não a repassando adiante.
Isto impede que haja uma inundação de requisições na rede.
Quando um nodo recebe um PResp, ele age da seguinte forma:
Se for o destino da resposta, então:
Adiciona a rota formada por a lista de nodos constante na resposta a sua Cr e a utiliza para encaminhar o pacote de dados ao seu destino;
Caso não seja o destino, então:
Retira sua identificação da rota de retorno do PResp, adiciona a rota resultante (rota do nodo até o origem) a sua Cr e envia a resposta ao próximo nodo da lista.
Quando um nodo recebe um pacote de dados e verifica que é o destino, ele encaminha o pacote à aplicação devida.
Caso não seja o destino, o nodo encaminha o pacote ao próximo nodo da rota.
Para armazenar pacotes de dados que estejam esperando a descoberta de uma rota para serem enviadas, cada nodo também possui um buffer de pacotes.
Assim, logo que uma resposta de requisição de rota é recebida, o nodo retira do buffer todas as mensagens a serem enviadas aquele destino e as encaminha.
Tanto a Cr quanto a LRR possuem timers para controlar o tempo de validade de cada entrada.
De essa forma, cada rota aprendida deve ser descoberta novamente após um dado período de tempo.
Os pacotes no buffer de pacotes a serem enviados também possuem um timer, de forma a impedir que pacotes fiquem indefinidamente na espera.
Manutenção de Rotas Manutenção de Rotas é o mecanismo por o qual um nodo pode detectar se a topologia da rede mudou.
Isto significa que algumas rotas deixaram de ser válidas e/ ou novas rotas foram criadas.
Para realizar a manutenção de rotas, os pacotes de dados enviados entre dois nodos exigem confirmação por parte de o receptor.
Esta confirmação é feita com o envio de uma mensagem de acknowledgment.
Cada nodo, ao receber um pacote de dados para encaminhar adiante, coloca uma cópia do pacote num buffer de retransmissão.
Assim, caso não receba a confirmação do recebimento do pacote por o nodo receptor dentro de um intervalo de tempo, o nodo que enviou o pacote realiza a retransmissão do mesmo.
Se após um certo número de tentativas não houver resposta do receptor, o nodo gera um pacote de erro (PE), informando que um dado link não está ativo.
Quando um nodo recebe um PE, ele verifica em sua Cr todas as rotas que incluam aquele link e as remove.
Caso o nodo que recebeu o PE seja o nodo que originou o pacote, ele pode tentar enviar- lo por uma rota alternativa constante em sua Cr ou realizar novamente o processo de descoberta de rotas.
Como visto, os mecanismos de Descoberta de Rotas e de Manutenção de Rotas são utilizados por demanda.
Ou seja, só são iniciados quando necessário.
De essa maneira, reduz- se o tráfego na rede causado por mensagens de roteamento.
Exemplo de Realização do Algoritmo DSR Para ilustrar o funcionamento básico do algoritmo DSR, tome- se como exemplo a rede apresentada na Figura 79, onde as ligações entre os nodos representam conexões físicas, no caso de uma rede fixa, ou os nodos alcançáveis a partir de cada nodo no caso de uma rede móvel.
Em a situação de uma rede móvel, os nodos alcançáveis por um nodo são aqueles que estão dentro de a área de ação do sinal do equipamento utilizado por o nodo.
Suponha- se que o nodo A deseja enviar dados para o nodo E. Assim, o nodo A gera um broadcast para os seus nodos vizinhos (neste caso, os nodos B e C) da requisição de rota contendo uma lista de nodos visitados, inicializada com o próprio nodo A. A o chegar ao nodo B, este identifica que não é o nodo procurado e não possui uma rota para o nodo E. Logo, B gera um novo broadcast, o qual, dentro de a topologia desta rede, alcançará apenas o nodo A. Note-se que o nodo A ignorará a requisição recebida por identificar que tal requisição já passou por ele, visto que ele consta na lista de nodos da requisição gerada por B. Já a requisição que chega a C, é encaminhada adiante, com a adição de C à lista de nodos.
O nodo D age da mesma forma que C, encaminhando a requisição aos seus nodos vizinhos, até que a mensagem chegue no nodo E. Este processo é ilustrado na Figura 80.
Quando a requisição chega ao nodo E, este identifica que é o nodo procurado e gera uma resposta ao nodo A contendo a lista de nodos por que a requisição passou (rota de A até E).
Assume- se aqui que a resposta é encaminhada percorrendo a rota inversa (rota de E até A).
De essa forma, a resposta chega ao nodo A conforme apresentado na Figura 81.
Cabe salientar que, mesmo que a forma de encaminhamento da resposta fosse outra (através de um novo processo de descoberta de rotas, por exemplo), o comportamento dos nodos por onde a resposta passa é sempre mesmo.
Cada nodo por onde a resposta passa (D e C) aproveita a informação da rota inversa para adicionar uma rota para o nodo A em sua Cr..
Assim, o nodo D sabe que possui uma rota até A através de C e o nodo C sabe que possui um rota direta para A. De posse de uma rota para o nodo E, o nodo A encaminha os dados necessários através da rota obtida, assim como mostra a Figura 82.
Como dito na descrição do algoritmo DSR, o nodo A poderia manter mais de uma rota para E em sua Cr..
Isto possibilita que ocorram menos processos de descoberta de rotas na rede, uma vez que se uma rota falhar, os dados podem ser encaminhados por uma rota alternativa.
Especificação em GGBO do Algoritmo DSR São agora apresentadas as especificações das entidades envolvidas no algoritmo DSR já apresentado.
Cabem, antes disso, algumas considerações quanto a a especificação feita.
A primeira de elas é que os timers que controlam a validade das entradas das tabelas envolvidas no algoritmo (cache de rotas e lista de requisições recentes) não foram modelados.
Isto porque a questão do trabalho com tempo em GGBO foge ao escopo deste trabalho, dado que o importante é o trabalho com o formalismo de GGBO.
A segunda observação que deve ser feita é que também não foram modelados os buffers de mensagens, usados para armazenar pacotes a serem retransmitidos em caso de erro (Retransmission Buffer) e para armazenar pacotes que estão à espera da obtenção de exigiria a criação de listas cujos elementos seriam referências a entidades que representam os pacotes, o que não é permitido em GGBO.
Portanto, para modelar tais buffers teriam de ser criados servidores de nomes para armazenar referências.
Como o objetivo deste estudo de caso é, principalmente, avaliar o mapeamento para código de especificações em GGBO, preferiu- se, por simplicidade, não modelar os buffers citados.
A última observação a ser feita é que, segundo o ambiente que foi considerado para a especificação das regras básicas, não se considera a existência de falhas.
Portanto, assume- se que os pacotes chegam ao seu destino.
Com isso, a existência do pacote de erro (PE) e o comportamento necessário para tratar- lo não foram incluídos na especificação a ser apresentada.
De essa forma, a especificação do algoritmo DSR concentrou- se no que mais importava avaliar que era a movimentação de entidades e a comunicação entre elas, segundo as regras definidas.
A seguir são apresentadas as especificações da entidades envolvidas no algoritmo.
Conforme modelado, as entidades são o serviço DSR e as cápsulas RouteRequest, RouteReply e Packet.
O serviço DSR fornece o comportamento necessário para tratar as cápsulas do algoritmo DSR.
De essa forma, a especificação deste serviço determina a forma de execução do algoritmo no ambiente de redes ativas proposto.
A Figura 83 e a Figura 84 apresentam o grafo de tipos do serviço DSR.
O serviço de DSR possui a sua identificação (atributo service_ id), que compreende um nome que o identifica como sendo o serviço usado para executar o algoritmo DSR, e a identificação do nodo em que está executando (atributo host_ id).
O atributo id serve para gerar os identificadores únicos usados quando o serviço envia uma requisição para obter uma rota a um dado destino.
O seu uso será melhor esclarecido a seguir, na apresentação das regras do serviço DSR.
O atributo capsule serve para armazenamento temporário de uma cápsula de dados.
Onde aparecem parâmetros de mensagens do tipo Capsule, definese que tais parâmetros podem ser de qualquer um dos tipos que estendem o comportamento de Capsule.
O serviço DSR controla a cache de rotas do nodo (atributo route_ cache) e a lista de requisições recentes (atributo route_ requests).
Além disso, o serviço ainda mantém uma lista contendo as requisições enviadas e que estão a espera de resposta (atributo request_ list).
O tipo IndexedList, usado no grafo de tipos do serviço DSR, é um tipo definido neste trabalho e representa um lista indexada, onde cada item da lista é um par valor\&gt;.
Os valores da lista podem ser de um dos tipos básicos de Gramáticas de especificador, tal como o tipo List, já apresentado na Seção 6.2.1, ou mesmo do próprio tipo IndexedList.
Índices podem ser apenas dos tipos básicos.
As operações definidas para o tipo IndexedList são:·
IndexedList add (index, item):
Adiciona o par item\&gt; à lista e retorna a nova lista;·
IndexedList remove (index):
Remove o elemento da lista cujo índice é index e retorna a nova lista;
O serviço DSR é inicializado através da mensagem InitDSR, contendo a identificação do serviço e a identificação do nodo em que ele está executando, segundo apresentado na regra de mesmo nome, a qual pode ser vista na Figura 85.
O serviço DSR, assim como qualquer serviço, possui a capacidade de duplicar- se.
No caso de o serviço DSR, esta duplicação ocorre de acordo com a regra CloneDSR, apresentada na Figura 86.
A duplicação de um serviço é usada para poder prover instâncias deste serviço para todos os nodos da rede que precisarem tratar cápsulas que necessitam deste serviço.
A função básica do serviço DSR é encaminhar cápsulas de dados por rotas constantes na cache de rotas (Cr).
As cápsulas a serem enviados são recebidos por o serviço DSR através da mensagem Packet, a qual traz a identificação do nodo de destino da cápsula, a referência à cápsula a ser enviada e uma lista de nodos.
A lista de nodos define a rota a ser seguida por a cápsula.
Quando a cápsula está sendo originada, esta lista está vazia, o que determina que ainda não existe uma rota definida para a cápsula.
Cápsulas de dados são originadas por aplicações usem o algoritmo DSR para roteamento destas cápsulas.
Uma cápsula de dados a ser roteada segundo o algoritmo DSR deve estender o comportamento da cápsula Packet, a ser apresentada na Seção 7.2.4.
Quando o serviço DSR recebe uma cápsula de dados a ser enviada a outro nodo, ele verifica qual é o nodo de destino.
Se o nodo de destino for um nodo remoto (não o próprio nodo onde o serviço está) e a lista de nodos estiver vazia, o serviço identifica que é uma cápsula a ser enviada.
Para enviar a cápsula, o serviço verifica se já possui uma rota para o destino na sua Cr..
Possuindo uma rota, ele encaminha a cápsula para o primeiro nodo da rota e envia uma mensagem à cápsula para que ela atualize a informação de sua rota a ser seguida.
Este procedimento é descrito na regra SendPacket, apresentada na Figura 87.
Cada nodo que recebe a cápsula roteada, encaminha- a ao próximo nodo da rota, conforme a regra ForwardPacket, mostrada na Figura 88.
Quando a cápsula de dados chega ao destino, ela é tratada conforme a aplicação à qual pertence.
Para isso, o serviço DSR passa à cápsula de dados a referência ao nodo local (através da mensagem Start) e, a partir de aí, o comportamento é definido por a aplicação.
O recebimento de uma cápsula de dados por o nodo de destino é apresentada na regra GetPacket, na Figura 89.
No caso de não haver uma rota para o destino na Cr do nodo que quer enviar uma cápsula de dados, o serviço inicia o processo de descoberta de rotas, seguindo o estabelecido no algoritmo DSR, descrito na Seção 7.1.
Para isso, o serviço cria uma cápsula de RouteRequest.
A regra SendRequest é apresentada na Figura 90 e ilustra esta situação.
A cápsula de RouteRequest é inicializada com os dados necessários e com uma lista de nodos visitados.
Esta lista servirá para montar uma rota da origem ao destino e inicia contendo apenas a identificação do nodo de origem.
A cápsula de RouteRequest, que representa um pacote de requisição de rota, é enviada em broadcast.
O valor do atributo id do serviço DSR é adicionado, juntamente com a identificação do destino da cápsula, à lista request_ list do serviço DSR.
Isto serve para que seja possível, ao receber uma rota para o destino, identificar se a requisição foi mesmo feita por este nodo.
O valor de id é incrementado para que a próxima requisição possua um valor diferenciado.
A cápsula que deve ser enviada, e está à espera de uma rota, é armazenada no atributo capsule do serviço DSR.
Como dito nas observações no início da descrição desta especificação, não se considera o uso de buffers para armazenar cápsulas.
Assim, a especificação do algoritmo DSR contempla apenas o roteamento de uma cápsula por vez, a qual é armazenada no atributo capsule do serviço DSR.
A o receber uma cápsula RouteRequest, o serviço DSR do nodo, primeiramente, verifica se este nodo é o destino procurado.
Em este caso, é criada uma cápsula RouteReply a ser enviada ao nodo que requisitou a rota.
Esta cápsula carrega com si a rota do nodo origem até o destino, formada por a lista de nodos visitados por a cápsula RouteRequest mais o nodo destino.
Como discutido na apresentação do algoritmo DSR, o retorno a uma requisição de rota pode ocorrer de formas diferentes.
Em a especificação feita, determinou- se que o retorno da rota é feito seguindo- se a rota inversa.
Ou seja, a cápsula RouteReply é enviada através dos nodos constantes na lista de nodos visitados na ordem contrária, do nodo destino até o origem.
A criação da cápsula RouteReply e o envio desta para o primeiro nodo da rota inversa são descritos na regra TargetFound na Figura 91.
Se o serviço DSR identifica que o nodo onde ele está não é o destino de um RouteRequest recebido, a sua próxima atitude é procurar uma rota para o destino em sua Cr..
Se houver uma rota para o destino na Cr, o serviço DSR segue o mesmo procedimento da regra anterior, somente que a rota retornada é rota composta da lista de nodos visitados até então, mais a rota encontrada na Cr..
Isto porque a rota na Cr possui apenas a informação do caminho do nodo local até o nodo procurado e deve, portanto, ser completada com o caminho do nodo de origem até o nodo local.
De a mesma forma que antes, a resposta é enviada por a rota inversa.
Esta situação é representada na regra SendReply, mostra na Figura 92.
Antes de enviar uma rota que possua em sua Cr, o serviço DSR também precisa verificar se a identificação do nodo já consta na lista de nodos visitados.
Se ela já constar lá, significa que o nodo já havia recebido aquela requisição.
Se isto ocorre, então é executada a regra AlreadyInRoute, apresentada na Figura 93, que determina que a requisição seja ignorada.
Isto evita que haja uma proliferação indefinida de requisições na rede.
Outra verificação feita por o serviço DSR para saber se ele já havia recebido a mesma requisição antes é uma procura na sua lista de requisições recentes (LRR), representada por o atributo route_ requests.
Lá constam todas requisições recebidas por o serviço, com identificação de qual nodo originou a requisição e qual o nodo procurado.
Se já houver o registro de um requisição igual à requisição recebida na LRR, a requisição é ignorada, tal como mostra a regra RequestRepeated na Figura 94.
Em último caso, se o nodo não é o destino, não existe um rota para o destino na Cr, o nodo não consta na lista de nodos visitados e já não existe o registro da requisição recebida na LRR, o serviço DSR realiza o encaminhamento da requisição aos nodos conhecidos através do envio da cápsula RouteRequest em modo broadcast, conforme define a regra ForwardRequest na Figura 95.
O encaminhamento da requisição exige que a identificação do nodo local seja adicionada à lista de nodos visitados, causando a alteração da rota armazenada por a cápsula RouteRequest, e também a inclusão do registro do recebimento da requisição na LRR, a fim de evitar o encaminhamento de uma requisição repetida.
A retirada do registro da requisição da lista de requisições geradas por o nodo local serve para que não haja sobreposição de rotas.
Isto porque podem ser retornadas várias rotas para um mesmo destino.
Segundo o algoritmo DSR, todas as rotas retornadas poderiam ser armazenadas e, em caso de falha numa rota, poderia- se- tentar o envio por outras.
Como, nesta especificação, não se está considerando o caso de falha de rota, armazena- se apenas a primeira rota recebida, assumindo- se que esta rota apresenta o menor caminho do nodo origem ao destino.
Assim, demais rotas que cheguem como resposta devem ser ignoradas.
A regra IgnoreReply, na Figura 97, apresenta o tratamento de uma requisição já atendida.
Se o serviço DSR recebe uma cápsula RouteReply que não é destinada ao nodo local, ele realiza o encaminhamento desta para o próximo nodo de sua rota.
O encaminhamento da cápsula RouteReply ocorre conforme a regra ForwardReply, mostrada na Figura 98.
Aproveitando a informação de rota que a cápsula carrega, o serviço também armazena a rota do nodo local até o nodo de origem em sua Cr..
A cápsula RouteRequest representa um pacote de requisição de rota, contendo, basicamente, as mesmas informações contidas num pacote de requisição de rota usado no algoritmo DSR.
O grafo de tipos da cápsula RouteRequest é apresentado na Figura 99.
Uma cápsula RouteRequest carrega com si a identificação do nodo que originou a requisição (atributo req_ orig), a identificação da requisição (atributo req_ id) e a lista de nodos visitados (atributo route).
Sendo uma cápsula, ela também possui a informação do serviço necessário para tratar- la (atributo req_ service), uma referência ao nodo onde ela está (atributo location).
O atributo target identifica o nodo procurado.
A cápsula RouteRequest é inicializada através da mensagem InitReq, como mostra a regra InitRequest, na Figura 100.
A duplicação da cápsula RouteRequest é feita segundo a regra CloneRequest, apresentada na Figura 101.
A regra InformRequest descreve a interação entre a cápsula e o serviço DSR.
A cápsula, seguindo esquema de regra apresentado na Figura 66 na Seção 6.2.2, ao receber a mensagem Service, utiliza a referência ao serviço recebida para enviar uma mensagem a este.
A mensagem enviada é Request, contendo os dados necessários ao trabalho do serviço DSR.
Esta regra é apresentada na Figura 102.
A última regra da cápsula RouteRequest diz respeito à alteração do atributo que armazena a rota a ser seguida por a cápsula.
Esta alteração ocorre segundo a regra ChangeRoute, ilustrada na Figura 103.
A alteração da informação de rota da cápsula é usada para que o serviço DSR possa encaminhar a cápsula e retirar da lista de nodos os nodos já visitados.
Especificação da Cápsula de Resposta a uma Requisição de Rota A cápsula RouteReply representa um pacote de resposta a uma requisição de rota.
O grafo de tipos da cápsula RouteReply é apresentado na Figura 104.
Uma cápsula RouteReply contém a identificação do serviço necessário para tratar- la (atributo req_ service), a identificação da requisição à qual corresponde esta resposta (atributo req_ id), a rota encontrada para o destino (atributo route) e o destino da resposta (atributo target).
O atributo back_ route contém a rota a ser seguida por a cápsula até o nodo que requisitou a rota.
A inicialização de uma cápsula RouteReply ocorre conforme a regra InitReply e a sua duplicação é descrita por a regra CloneReply, apresentadas, respectivamente, na Figura 105 e na Figura 106.
O envio das informações da cápsula para o serviço DSR dos nodos por que ela passa é feita através da mensagem Reply.
Essa interação entre a cápsula e o serviço é feita segundo a regra InformReply, mostrada na Figura 107.
A alteração da rota a ser seguida por a cápsula é feita de acordo com a regra ChangeRoute, apresentada na Figura 108.
Note- se que a alteração, neste caso, é feita no atributo back_ route.
Isto porque ele é que contém a rota de retorno da resposta.
Especificação da Cápsula de Dados O pacote de dados é representado por a cápsula Packet, que é a cápsula de dados.
As cápsulas contendo dados da aplicação devem estender esta cápsula para poderem utilizar o algoritmo DSR.
Assim, o comportamento necessário para interagir com o serviço DSR está definido na cápsula Packet e a cápsula que a estende acrescenta o comportamento relativo à aplicação de a qual participa.
A Figura 109 apresenta o grafo de tipos da cápsula Packet.
Como cápsulas de outros tipos deverão estender a cápsula Packet, a inicialização e a duplicação desta cápsula são apresentadas como esquemas de regras.
O esquema de regra de inicialização de uma cápsula Packet é apresentado na Figura 110.
A Figura 111 apresenta o esquema de regra de duplicação de Packet.
A alteração da informação de rota da cápsula Packet é feita segundo a regra ChangeRoute, apresentada na Figura 112.
A o chegar a um nodo a cápsula Packet envia seus dados para o serviço DSR local segundo a regra InformPacket, apresentada na Figura 113.
As cápsulas de tipos que estendem a cápsula Packet devem prover uma regra que trate a mensagem Start.
Esta mensagem é enviada por o serviço DSR quando a cápsula chegou ao destino.
A regra a ser provida deve seguir o esquema de regra BackTo Application, apresentado na Figura 114.
A mensagem Start tem, como parâmetro, a referência ao nodo local e serve para identificar que a cápsula foi corretamente roteada e a aplicação pode continuar.
Código Gerado para o Cenário do Estudo de Caso A partir de as especificações de redes ativas (Seção 6.2) e do algoritmo DSR (Seção entidades e regras envolvidas.
Testes foram realizados sobre a arquitetura de redes ativas e, após considerar- se que as funções da rede ativa eram executadas corretamente, realizaramse testes com o algoritmo DSR executando sobre essa arquitetura.
Para realizar tais testes, foi criada uma topologia de rede de exemplo.
Em esta topologia, todos os nodos eram nodos ativos, de acordo com a arquitetura de redes ativas proposta.
A topologia envolvia 10 nodos, onde cada nodo possuía um servidor de nomes local.
Em o servidor de nomes local encontravam- se as identificações dos nodos conhecidos por o nodo local.
Esta topologia é ilustrada na Figura 115.
Além de os 10 nodos envolvidos na topologia apresentada, foi criado ainda um nodo N0, onde se localiza a base de código da rede.
Este nodo foi criado apenas para alojar a base de código, de forma a não participar da troca de mensagens envolvidas no algoritmo DSR.
Assim, este nodo serve para tratar exclusivamente de requisições para a base de código.
Também está presente nesse nodo o servidor de nome global, onde está a lista de todos os serviços disponíveis na rede.
No caso de essa rede, o único serviço disponível é o serviço DSR.
Uma instância desse serviço é criada, no início do sistema, no nodo N0.
Os demais nodos não possuem qualquer serviço executando quando iniciados.
Para os testes, criou- se uma cápsula de dados (cápsula Packet) a ser roteada a partir de o nodo N1.
Foram realizados os roteamentos para todos os demais nodos da rede.
A topologia concebida permitiu testarem- se as principais situações do algoritmo DSR, tal como recebimento de requisições repetidas, recebimento de múltiplas rotas para um mesmo destino, tratamento de respostas a requisições de rotas, encaminhamento de pacotes, entre outras.
Outro teste realizado envolveu a inicialização da cache de rotas de alguns nodos com algumas rotas iniciais.
Isto permitia testar se o nodo realmente encaminhava uma rota conhecida quando recebia uma requisição que pedia esta rota.
Os testes foram realizados, inicialmente, no simulador.
A realização de simulações permitiu a correção de erros de especificação.
Após isso, passou- se para a execução real, com todos os nodos executando numa mesma máquina.
O comportamento assumido por a aplicação na execução real mostrou- se coerente em relação a o comportamento que fora obtido na simulação.
Testes posteriores foram realizados com os nodos distribuídos em 4 máquinas diferentes e com múltiplas cápsulas sendo roteadas.
Os resultados corresponderam ao esperado, isto é, as cápsulas de dados foram corretamente roteadas e os nodos comportaram- se conforme o especificado e conforme o que havia ocorrido na simulação.
Conclusões sobre os Estudos de Caso A realização dos estudos de caso serviu para a avaliação do mapeamento criado e também para o teste do uso da LEF e do simulador.
No que diz respeito à LEF, tipos abstratos de dados devem ser definidos, para utilização em GGBO, através de especificação algébrica.
Por simplicidade e por a dificuldade que apresenta trabalhar- se com especificação algébrica para pessoas não acostumadas com tal linguagem, utilizou- se uma descrição informal de tipos abstratos de dados, assumindo- se a correção das operações realizadas sobre eles.
Posteriormente, este tipos devem ser formalmente descritos para poderem ser utilizados corretamente dentro de as especificações.
Ainda não foi estabelecida uma forma de representar a inicialização de tipos abstratos de dados.
Uma dificuldade encontrada em relação a a LEF foi a inexistência de uma forma de representação de hierarquia de herança de entidades.
Com isso, não é possível criarem- se entidades a partir de uma entidade previamente especificada.
Assim, deve- se repetir todas as definições necessárias dentro de a especificação de uma nova entidade, mesmo que ela possua atributos e regras já definidos em outra entidade.
Em este trabalho, como forma de tornar mais simples a especificação, estabeleceu- se uma forma de hierarquia, em que se definiu que entidades podiam &quot;basear- se «em outras entidades quando se desejasse agregar o comportamento destas últimas a um comportamento específico das primeiras.
Deve, portanto, ficar claro que isto foi um mecanismo adotado neste trabalho para simplificar a elaboração e a apresentação de entidades, mas que não existe hierarquia de herança de entidades em GGBO, sendo que uma especificação completa exigiria a repetição de definições comuns entre entidades.
A inclusão e uma forma de representação de hierarquia de herança de entidades em GGBO está em estudo dentro de o grupo do projeto ForMOS.
Além de os problemas citados, também se deve relembrar de uma questão discutida durante a explanação sobre a especificação dos estudos de caso que é a dificuldade em representar computações seqüenciais.
Isto leva à utilização de atributos ou de parâmetros de mensagens que servem tão somente para armazenar referências ou valores.
Além de o espaço de armazenamento gasto para guardar estes valores ou referências e do custo de sua transmissão, às vezes, em múltiplas mensagens até que sejam realmente utilizados, existe também o acréscimo de complexidade no entendimento da especificação devido a a poluição visual e por ferir regras de encapsulamento.
Considera- se a possibilidade da causa de tais problemas estar no uso incorreto da LEF, uma vez que se pode estar seqüencializando processamentos que poderiam ter sido especificados de forma a serem realizados paralelamente.
Pode- se, ainda, discutir- se a validade de utilização da LEF para o propósito que foi colocado em relação a o que ela oferece.
Apesar disso tudo, a LEF mostrou ser, de certa forma, intuitiva, mesmo que, por vezes, fique difícil o seu entendimento.
Ela fornece uma forma gráfica de representar o sistema, o que facilita o entendimento da especificação, além de ser baseada em objetos, o que adiciona à especificação conceitos bastante difundidos.
A representação de mobilidade é simples e a compreensão da evolução do sistema não exige muito tempo de estudo da linguagem.
Tem- se discutido formas de tornar especificações em GGBO mais claras, tais como a padronização do posicionamento de seus elementos.
Quanto a o simulador, ele provou ser bastante útil para o teste das especificações.
Diversos erros não identificados na etapa de especificação foram notados quando se realizaram simulações sobre a especificação resultante.
A correção destes erros tornou possível que, após mapear a especificação para código executável, o sistema executasse conforme o esperado e conforme o resultado da simulação.
Assim mesmo, avalia- se que melhorias podem ser realizadas no simulador para que este se torne uma ferramenta ainda mais valiosa.
Uma destas melhorias seria permitir a execução paralela de regras de escrita e leitura, o que ainda não é permitido por a implementação atual do simulador (vide entidade, segundo o que é definido em GGBO.
O comportamento do código executável demonstrou estar coerente com o comportamento do código simulado.
A arquitetura de redes ativas mostrou funcionar corretamente, bem como o algoritmo DSR.
Considera- se que este estudo de caso contribuiu com a proposta de uma arquitetura para redes ativas baseada no uso de componentes móveis, tirando proveito de suas potencialidades.
A implementação do algoritmo DSR sobre esta arquitetura tornou possível testar a coerência do código gerado para a arquitetura de redes ativas em relação a a especificação feita, bem como do próprio algoritmo DSR.
Também cabe ressaltar que se desconhece outra implementação do algoritmo DSR com o uso de mobilidade.
De essa forma, apesar de as restrições feitas em relação a a definição original do algoritmo, considera- se esta implementação como uma contribuição que demonstra mais uma área de aproveitamento das características de mobilidade de código.
Não é possível determinar, por agora, quais as vantagens e desvantagens do uso de mobilidade para algoritmos de roteamento, principalmente para redes ad hoc, mas isso abre a possibilidade de consideração dessa idéia.
Muitos têm sido os trabalhos na área de modelagem e especificação de sistemas que envolvem o uso de mobilidade de código.
Entre eles estão JAMES, Mobile UNITY, Cálculo-, Ambit, MobiS e SCD, os quais são apresentados a seguir.
A o final do capítulo, são feitos alguns comentários sobre os trabalhos apresentados.
JAMES (Java-Based Agent Modeling Environment for Simulation) é uma ferramenta voltada à realização de simulações de sistemas de Inteligência Artificial cujos componentes são agentes.
Em JAMES a simulação ocorre através da troca de mensagens entre entidades concorrentes e distribuídas.
É provido um ambiente de modelagem e simulação que foi criado tendo como principal foco o suporte a experimentos com programas de Inteligência Artificial, tais como agentes, os quais podem ser móveis.
Cálculo-O Cálculo- é um modelo de computação concorrente que tem.
Em CCS, têm- se processos que executam concorrentemente e comunicam- se através de canais estaticamente criados.
O Cálculo- acrescentou a isso a possibilidade de criação, deleção e alteração dinâmica de canais, permitindo que as configurações de canais entre processos possam mudar ao longo de o tempo.
Cálculo- baseia- se na noção de nomeação (naming).
Nomes são as entidades mais primitivas do Cálculo- e servem para a criação de processos, além de permitir sua localização e comunicação.
Assim, quando dois processos possuem o nome de um mesmo canal, eles podem se comunicar através deste canal.
A interação entre processos ocorre de forma síncrona, seguindo o modelo de comunicação rendezvous, em o qual tanto quem envia quanto quem recebe fica bloqueado até a comunicação ser finalizada.
Canais podem transmitir outros canais e também processos.
De essa forma, a idéia de mobilidade baseia- se na estruturação de processos com capacidade de serem transmitidos de um local para outro através de canais.
Quando um processo é movido a sua configuração de canais se modifica.
Com isso, a movimentação de um processo pode ser representada por a mudança na configuração de seus canais.
Existem hoje algumas linguagens que seguem a semântica de Cálculo-, tais como KLAIM, Pict e Nomadic Pict.
Estas linguagens incorporam a semântica do modelo de Cálculo-, provendo uma programação baseada em processos.
Mais sobre estas linguagens é apresentado em.
Mobile UNITY Mobile UNITY é baseada no modelo UNITY, proposto em, e provê uma notação para componentes e uma linguagem para expressar a interação entre esses componentes.
Cada componente é definido por um programa UNITY, o qual é composto por um conjunto de variáveis que formam seu estado, predicados iniciais relacionados ao seu estado e uma lista de comandos que alteram seu estado e definem o comportamento do componente.
Um sistema é descrito por um conjunto de componentes e as interações entre esses componentes.
Como todas as variáveis de um componente Mobile UNITY são consideradas locais a este componente, nenhuma comunicação pode ocorrer sem que haja uma definição de interação na Seção Interactions de um sistema, a qual serve para prover comunicação entre componentes.
Cada definição de interação apresenta como a interação ocorre (quais informações são trocadas) e apresenta condições de ocorrência da interação.
De essa forma, uma interação só ocorre quando a sua condição for satisfeita.
A linguagem de especificação de Mobile UNITY é textual e lembra a linguagem CSP.
A noção de localização é dada por um atributo do componente, sendo que a ocorrência de uma movimentação é descrita como uma alteração neste atributo.
Ambit Ambit possui a idéia de ambientes.
Um ambiente é um componente que possui uma delimitação física ou lógica e onde a computação ocorre.
A delimitação de um ambiente define o escopo de atuação do ambiente.
Exemplos de ambientes são um objeto (delimitado por o seu conteúdo) e um laptop (delimitado por seu console e portas de dados).
Ou seja, qualquer lugar que possa conter algum tipo de computação e possua uma delimitação definida, é definido como um ambiente.
A delimitação de um ambiente determina o que está dentro e o que está fora de o ambiente.
Um ambiente pode conter outros ambientes e cada ambiente possui um conjunto de agentes locais, que são as computações que executam dentro de o ambiente e, de alguma forma, controlam o ambiente, fazendo com que o ambiente se mova, por exemplo.
A o se mover, o ambiente move- se como um todo.
Além de ambientes, agentes também se movem.
Uma movimentação pressupõe a ultrapassagem das delimitações do ambiente onde se está e a entrada nas delimitações de um outro ambiente.
A interação entre componentes se dá quando os componentes comunicantes compartilham o mesmo ambiente, estando dentro de as mesmas delimitações.
A linguagem de especificação é textual e é chamada de Cálculo de Ambientes.
MobiS é uma linguagem de especificação baseada em múltiplos espaços de tuplas que estende a linguagem PoliS.
Especificações em MobiS são hierarquicamente estruturadas, denotadas por uma árvore de espaços aninhados que se modifica dinamicamente.
Espaços podem se mover, modificando sua posição na árvore.
Um espaço MobiS (representação de um sistema) pode conter tuplas ordinárias, que são seqüências ordenadas de valores, tuplas de programa, que representam códigos, e um espaço de tuplas.
Tuplas de programas podem modificar um espaço removendo e adicionando tuplas e outros espaços.
A área de atuação das modificações de uma tupla de programa se restringe ao espaço onde ela se encontra e ao espaço acima deste na árvore de espaços.
Uma tupla de programa é definida por uma regra que determina quais ações são tomadas.
Uma regra lê tuplas dentro de o seu escopo de atuação, realiza uma computação seqüencial e produz novas tuplas.
Segundo o formalismo, uma regra consiste de uma préativação, que define quais tuplas devem estar no escopo da regra para que ela seja aplicada, uma computação local, que define uma computação seqüencial que não altera o estado do espaço de tuplas, e uma pós-ativação, que define as tuplas produzidas por a regra dentro de o seu escopo de atuação.
Espaços podem se mover, levando com si toda a subárvore que está abaixo de ele.
Ou seja, todos os espaços que estão, dentro de a árvore do sistema, abaixo de o espaço que se move e ligados a ele (espaços ditos filhos), movem- se juntamente com o espaço pai.
A mobilidade é representada por o consumo e produção de espaços.
Como o escopo de atuação de uma regra é local ao espaço em que ela se encontra e ao espaço pai, a movimentação ocorre de forma &quot;passo- a- passo», movendo- se um espaço de um lugar na árvore para o nível mais acima, até que ele chegue ao topo da árvore e passe a ser movido para baixo, até chegar no local de destino de sua movimentação dentro de a árvore.
Em relação a a geração de código a partir de uma especificação formal, existe um trabalho descrito em que relata a idéia de realização de geração automática de código de uma especificação formal de agentes móveis.
Este trabalho utiliza uma variante de Redes de Petri para modelar o sistema, o qual é descrito por componentes especificados numa linguagem de descrição chamada Soft-Component Description (SCD) Language.
Esta linguagem permite a modelagem do comportamento de um componente por a definição de classes de componentes e possível composição de instâncias de componentes.
Esta linguagem é textual e o modelo descrito em SCD é mapeado para código de uma plataforma de suporte à mobilidade denominada JavaNet Agents (JNA).
Para este mapeamento, foi construído um compilador que gera código Java a partir de o modelo em SCD.
Este código é então encapsulado em agentes JNA.
É ainda realizada a simulação do sistema modelado através do uso de uma ferramenta de simulação e análise sobre Redes de Petri.
Comentários sobre os Trabalhos Relacionados Como visto, muitos trabalhos envolvem a utilização de métodos formais para descrever sistemas com componentes móveis e para criação de modelos de simulação, como o JAMES.
Apesar disso, poucos tratam da questão de geração de código a partir de as especificações feitas.
MobiS está em fase de integração com a modelagem UML, o que pode ser um caminho para a geração de código, aproveitando a proximidade de UML com a implementação de sistemas.
Além disso, as especificações são feitas de modo textual e com um conjunto de operadores lógicos e matemáticos, exigindo um certo conhecimento dos mesmos por o especificador.
Isto os torna pouco acessíveis e pouco utilizáveis por pessoal leigo no assunto.
Os trabalhos baseados em Cálculo- fornecem uma forma de mapeamento da semântica deste formalismo para uma linguagem de programação.
Uma possível dificuldade em trabalhar com estas linguagens seria realizar a programação baseada em processos, visto que, ultimamente, utiliza- se o paradigma de orientação a objetos.
SCD é o que possui maior proximidade com o trabalho descrito neste relatório, com as desvantagens da linguagem formal utilizada ser textual e pouco intuitiva.
Além disso, o código é portado para uma plataforma pouco difundida.
Até por isso, segundo os autores, pretende-se gerar código para a plataforma Aglets da IBM, que é bastante utilizada para o desenvolvimento de aplicações com código móvel.
O trabalho aqui apresentado visou a geração de código para uma linguagem de programação, a ser executado sobre uma plataforma de suporte à mobilidade, a partir de uma especificação formal.
Especificações formais feitas em GGBO foram mapeadas para código, o qual foi executado sobre a plataforma Voyager.
O mapeamento realizado baseouse no mapeamento prévio criado no ambiente do simulador PLATUS para gerar código para simulação de especificações em GGBO.
Com isso, tornou- se possível especificaremse sistemas, em especial SDCM, gerar- se código de simulação para estes sistemas, simulálos no ambiente PLATUS e, com poucas modificações, gerar- se código para executar sobre a plataforma Voyager.
A característica definida no projeto ForMOS, em o qual este trabalho se insere, de se trabalhar com especificação, simulação e geração de código tendo como base um formalismo único, fornece ao projeto uma abordagem diferenciada de outros trabalhos correlatos.
Tal abordagem facilita o trabalho de quem venha a utilizar as ferramentas resultantes do desenvolvimento deste projeto, visto que é preciso apenas conhecer- se o formalismo de GGBO uma vez que os mapeamentos para código de simulação e para execução real estão estabelecidos.
O futuro uso de técnicas de verificação sobre GGBO deverá ainda contribuir para o desenvolvimento de sistemas mais confiáveis, minimizando a ocorrência de erros.
Considera- se que o objetivo principal do trabalho foi alcançado, visto que se chegou a um mapeamento de GGBO para código que executa sobre uma plataforma.
A correção do mapeamento utilizado neste trabalho, o qual permite a geração de código a partir de especificações em GGBO, ainda não está formalmente provada.
Como dito anteriormente, assumiu- se aqui a correção do mapeamento criado para o simulador PLATUS.
Com isso, o que se fez foi buscar garantir que as características apresentadas por o ambiente de simulação fossem preservadas no código para execução real.
Embora ainda não provado formalmente, os testes realizados e o estudo de caso desenvolvido indicaram a coerência do código gerado em relação a o código de simulação.
Pôde- se constatar, através de testes de diversas situações e dos estudos de caso, que o código para execução real preserva, através dos mecanismos criados para a movimentação de entidades e para a comunicação entre entidades e das funcionalidades fornecidas por a plataforma utilizada, as características apresentadas na simulação.
Por conseqüência, pode- se considerar que, caso o código gerado para o simulador esteja correto em relação a a especificação em GGBO (o que ainda também exigirá uma prova formal), o código gerado por o mapeamento apresentado neste trabalho também estará correto.
Também deve- se dizer que, segundo observado durante a realização dos testes e dos estudos de caso, o código gerado e executado segue o mesmo comportamento definido na especificação em Durante o desenvolvimento deste trabalho, além de a contribuição com a geração de código para execução, também se contribuiu para o aperfeiçoamento da LEF e do simulador.
Usando a LEF e o simulador para o desenvolvimento dos testes do mapeamento e para a realização do estudo de caso foi possível verificar- se a sua utilidade e as suas vantagens e desvantagens.
Através dessa análise, identificaram- se problemas e deficiências na LEF utilizada e problemas em relação a o simulador puderam ser corrigidos ou possuem uma solução em estudo.
Todos os problemas identificados foram levados para discussão com o grupo do projeto e servirão para melhorar tanto a linguagem quanto o simulador e, conseqüentemente, melhorar o código gerado.
Acerca de a pesquisa desenvolvida no projeto ForMOS, visualizam- se alguns trabalhos futuros possíveis, além de as considerações já feitas na Seção 7.4 sobre a LEF e o simulador.
O primeiro de eles seria o desenvolvimento de um tradutor que realizaria a geração automática de código a partir de uma especificação em GGBO.
Acredita- se que seja possível gerar- se código de simulação automaticamente a partir de uma especificação em GGBO, visto que em já foi apresentado um trabalho nesse sentido.
Conforme discutido no Capítulo 5, considera- se que seria também possível gerar- se código de execução de forma automatizada.
Para a criação do tradutor faz- se necessária a implementação de um editor de especificações.
Em este editor seria possível criar, de maneira gráfica, especificações em GGBO.
As especificações criadas seriam armazenadas em estruturas de dados a partir de as quais o tradutor pudesse obter as informações necessárias para a geração de código.
Um protótipo desse editor está já em desenvolvimento.
Outro trabalho futuro poderia considerar a utilização de outras plataformas de suporte à mobilidade.
Isto possibilitaria a comprovação de que o mapeamento criado pode ser independente de plataforma e também criaria opções para o desenvolvimento de SDCM sobre outras plataformas que não a Voyager, talvez com melhor desempenho.
Também existe um possível trabalho quanto a a consideração de falhas.
Assim, poderiam ser representados modelos de falhas em lugares e em componentes móveis, incluindo o comportamento dinâmico de um ambiente aberto real.
Isto permitiria a criação de aplicações móveis tolerantes a falhas ou a especificação e simulação de mecanismos de detecção e tolerância de falhas.
