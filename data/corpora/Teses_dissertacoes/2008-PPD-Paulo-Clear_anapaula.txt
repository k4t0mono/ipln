Formalismos de modelagem são linguagens capazes de descrever sistemas de forma não ambígüa, permitindo a sua avaliação quantitativa.
Os formalismos conhecidos como estruturados permitem a representação sistemática de modelos grandes e complexos.
Entretanto, na prática, a modelagem de sistemas de tal porte pode apresentar o problema de explosão do espaço de estados.
Em geral, a modelagem de sistemas através de formalismos estruturados, com espaço de estados discreto, resulta num grande número de estados inatingíveis.
A geração e armazenamento dos estados não atingíveis é um ônus não desejado ao processo de modelagem.
Este trabalho apresenta um algoritmo capaz de gerar e armazenar somente o espaço de estados atingível (RSS) para o formalismo de Redes de Autômatos Estocásticos (SAN) utilizando Diagramas de Decisão Multi--Valorada (MDD).
A idéia principal é apresentar uma primeira versão desse algoritmo, a m de comprovar a sua viabilidade para o formalismo SAN.
Um formalismo de modelagem é uma linguagem alfanumérica ou gráca para representação de modelos.
Os formalismos de modelagem estocástica têm evoluído desde 1890, quando iniciaram os estudos sobre Cadeias de Markov.
Logo em seguida, no nal da década de 1950, Jackson iniciou os estudos sobre Redes de Fila de Espera, que foi complementado no nal dos anos 70 por Little, Basket, Chandy, Muntz e Palacios, e Reiser e Lavenberg.
Modelos são abstrações de um problema do mundo real.
Formalismos como Cadeias de Markov (MC) são denominados de formalismos não estruturados, por não apresentarem uma maneira modular de representar um modelo.
Conseqüentemente, formalismos não estruturados podem enfrentar diculdades para descrever modelos grandes e complexos.
Os formalismos conhecidos como estruturados surgiram com o intuito de amenizar tais restrições.
O formalismo de Redes de Petri (PN) foi introduzido no início de 1960 com a proposta de ser um formalismo capaz de descrever sistemas com espaço de estados discreto, representando realidades complexas através de modelos compactos.
O formalismo de Redes de Autômatos Estocásticos (SAN), proposto por Plateau nos meados de 1980, tem basicamente o mesmo objetivo.
No entanto, SAN permite a representação de um sistema como uma coleção de subsistemas tanto com comportamento independente, quanto com interdependência ocasional.
Com a existência de formalismos de modelagem capazes de representar sistemas grandes e complexos, emerge o problema da explosão do espaço de estados.
Basicamente, a explosão do espaço de estados consiste em elevado consumo de memória para representar os diferentes estados aplicáveis a realidade de um modelo.
Endereçar este problema começa a ser foco de estudo para vários formalismos como Redes de Petri e Redes de Autômatos Estocásticos.
Soluções computacionais existentes utilizam estruturas de dados de tamanho proporcional ao espaço de estados produto (PSS), a m de identicar posteriormente o espaço de estados atingível do modelo (RSS).
Essa abordagem assume que os estados não atingíveis do modelo também são armazenados, causando assim desnecessários gastos computacionais e de armazenamento.
Estudos aplicados ao formalismo de modelagem de Redes de Petri Estocásticas (SPN) demonstram que é possível descrever- se sistemas grandes e complexos de uma maneira compacta, levando- se em conta apenas a porção atingível do modelo (RSS).
Basicamente, Buchholz e Kemper, e Miner e Ciardo propuseram maneiras ecientes de descrever o espaço de estados atingível de modelos grandes e complexos para o formalismo de SPN, que anteriormente eram de difícil representação.
Para alguns casos, a estrutura de dados Diagramas de Decisão Multi--Valorada, conhecida como MDD, foi utilizada, devido a o fato de ser compacta e ecaz para as operações comuns como inserções e buscas.
O objetivo desse trabalho é adaptar o conceito de MDD aplicado em SPN para o formalismo de modelagem SAN.
A principal contribuição se fará por a descrição de um algoritmo capaz de encontrar e armazenar somente o espaço de estados atingíveis numa estrutura MDD.
Esta adaptação terá cuidado adicional com o uso de taxas constantes e funcionais apresentadas em eventos locais e sincronizantes, particularidade existente no formalismo de SAN.
Porém, convém salientar que esta primeira versão do algoritmo preocupa- se com a viabilização de uso de MDD para o formalismo de SAN, ainda não focando algumas questões de performance.
De fato, a análise da complexidade do algoritmo proposto é apresentada, a m de estabelecer- se uma idéia do desempenho que este apresentará, conforme as variáveis que inuenciam o sistema são aumentadas.
Obter- se a estrutura de MDD mais compacta possível que represente o modelo é um aspecto desejável.
Para tanto, o conceito de ordem dos autômatos na estrutura de MDD é também explorado por esse estudo.
Conclusões aqui apresentadas demonstram que a ordem com que os autômatos são dispostos no MDD inuência o número de nodos requeridos por a estrutura, bem como o número necessário de reduções (otimização).
Um comparativo do algoritmo atual para geração e armazenamento utilizado em SAN, Vetor de Booleanos, com a nova técnica que utiliza MDD é também apresentado.
O quesito consumo nal de memória é o alvo principal do comparativo estabelecido entre ambas as técnicas.
O PEPS, é a ferramenta atualmente utilizada para a resolução de sistemas descritos em SAN e candidata a integração do algoritmo aqui proposto.
Basicamente, a ferramenta PEPS possui 2 etapas distintas para obter a solução estacionária de um modelo SAN.
A primeira etapa consiste em preparar as informações do modelo para que, na segunda etapa, as probabilidades de permanência em cada estado global possam ser calculadas.
De essa forma, a obtenção dos estados atingíveis do modelo, tópico aqui em estudo, é realizada na primeira etapa da solução de um modelo SAN, a qual o consumo de memória durante o processo de geração não é um fator muito relevante.
Para o PEPS é importante que ao início da computação da segunda etapa, o consumo nal de memória seja otimizado.
Então, outras análises como consumo de memória durante o processo de geração (pico de memória) e consumo de CPU não são alvos de estudo desse trabalho.
O decorrer desse trabalho apresenta primeiramente uma breve descrição dos formalismos em estudo, que são SPN e SAN (Capítulo 2).
O Capítulo 3 resume o uso de MDD para o formalismo de SPN, baseado em trabalhos realizados por Miner e Ciardo.
Capítulo 4 apresenta o algoritmo capaz de gerar e armazenar o espaço de estados atingível utilizando MDD para o formalismo de SAN.
A avaliação da complexidade deste algoritmo é também apresentada neste técnica baseada em MDD é apresentado no Capítulo 5, através de exemplos de modelagem.
O estrutura de MDD.
E, nalmente o Capítulo 7 apresenta a conclusão desse trabalho ressaltando sua a principal colaboração assim como sugestões de futuros trabalhos a serem explorados.
Em este capítulo, apresenta- se um embasamento teórico a respeito de os formalismos utilizados como referência nesse estudo, compreendendo conceitos básicos sobre Redes de Petri (PN) e Redes de Autômatos Estocásticos (SAN).
Redes de Petri (PN -- Petri Nets) é um formalismo matemático baseado em grafos que tem o objetivo de descrever, modelar e analisar o comportamento de sistemas com espaço de estados discreto, sendo principalmente aplicáveis em sistemas concorrentes e assíncronos.
Este formalismo de modelagem tem sido amplamente utilizado em diversas áreas tais como protocolos de comunicação e rede, arquitetura de computadores, sistemas distribuídos, planejamento de manufaturas, vericação e síntese de circuitos digitais e quaisquer outros sistemas onde é possível fazer- se uma avaliação em alto nível do mesmo.
A estrutura de uma PN é composta por um conjunto de lugares denominados P, um conjunto de transições denominadas T e um conjunto de arcos direcionados formados por (P × T) e (T × P).
Os arcos direcionados conectam os lugares às transições e as transições aos lugares.
Além disso, o elemento denominado de marca, também chamado de token, é responsável por identicar as transições habilitadas a disparar.
As marcas disponíveis nos lugares do modelo são denominados de conjunto marcação, que é representado por o símbolo M.
A cada disparo de uma transição, um número denido de marcas é consumido de todos os seus lugares de entrada1 e um número denido de marcas é adicionado a todos os lugares de saída2.
Lugares predecessores que alimentam a transição t..
Lugares sucessores a transição t..
Formalmente, pode- se denominar uma Rede de Petri como uma quádrupla do tipo:
N é o conjunto de arcos entre lugares e transições ou entre transições e lugares devidamente ponderados.
Caso o peso de um arco seja diferente de zero, pode- se dizer por liberdade de linguagem que este arco existe.
M0 representa a marcação inicial, que é o conjunto de marcas disponíveis nos lugares antes do primeiro disparo de uma transição ocorrer.
Gracamente, os lugares são representados por círculos, as transições por barras e os arcos direcionados por setas.
As marcas são representadas por tokens dentro de os círculos.
Seja u um lugar qualquer conectado por uma transição t, se W (u, t)\&gt; 0, então existe um arco que parte de u e vai para t com peso W (u, t).
Seja v um lugar qualquer conectado por uma transição t, se W (t, v)\&gt; 0, então existe um arco que parte de t e vai para v com peso W (t, v).
Um lugar é uma entrada para uma transição se existe um arco direcionado do lugar para a transição em questão.
Uma entrada pode ser representada por a seguinte notação:
Analogamente, um lugar é uma saída de uma transição se existe um arco direcionado da transição para o lugar em questão.
Por sua vez, uma saída pode ser representada por a seguinte notação:
A Figura 1 tem como lugares de entrada da transição t1 apenas o lugar p1 enquanto que os lugares de saída são representados por p2 e p3.
Quando um arco possui peso p maior que zero, é necessário o consumo de p marcas para que a transição t dispare.
Em a verdade, para que t possa disparar é necessário um número de marcas no mínimo igual ao valor do peso do arco, em todos os lugares que são entrada para esta transição.
A execução de uma Rede de Petri acontece através do disparo de transições.
Para que um disparo ocorra, é necessário que uma transição esteja habilitada.
Para uma transição ser considerada habilitada é necessário que todos os lugares de entrada contenham um número de marcas no mínimo equivalente ao peso do arco em questão.
Uma vez que uma transição t esteja habilitada numa marcação M, um disparo pode ocorrer e uma nova marcação M'será atingida.
O disparo de uma transição t qualquer consome marcas dos lugares de entradas e gera marcas nos lugares de saída.
Formalmente, pode- se representar essa operação como:
Onde M é o novo conjunto de marcações após o disparo da transição t ser efetuada.
Uma seqüência de transições quaisquer é dita uma seqüência de disparos se a partir de uma marcação M1 atinge- se uma outra marcação Mk qualquer.
Uma marcação Mk é dita atingível se existe uma seqüência de disparos a partir de a marcação inicial M0 que leva até a mesma.
A árvore de atingibilidade de uma PN (Figura 2) representa o espaço de estados atingível como nodos da árvore, bem como todas as possíveis seqüências de disparos em forma de transições entre os nodos.
Uma Rede de Petri pode apresentar as propriedades de limitação e segurança.
Uma PN é dita k--limitada, ou apenas limitada, se para todos os estados atingíveis do modelo, todos os lugares da rede tem um limite k de marcas, sendo esse um valor nito.
Uma Rede de Petri é dita segura se o limite k desta for igual a 1.
Logo, tem- se no máximo uma marca em todos os lugares marcados da rede, em qualquer estado atingível.
O Algoritmo Symbolic Traversal Petri Net apresentado em, é responsável por gerar a árvore de atingibilidade de uma PN e armazenar- la numa estrutura de BDD.
Então, as combinações de caminhos armazenados na estrutura de BDD representam o espaço de estados atingível do modelo PN.
Um exemplo prático é exibido por a Figura 2.
Entretanto, este algoritmo tem como restrição a premissa de que a PN seja limitada e segura.
Em a verdade, existem extensões do Algoritmo Symbolic Traversal Petri Net para o caso de redes não seguras.
No entanto, por não ser objetivo de estudo desse trabalho, não será apresentado com mais detalhes.
O formalismo de Redes de Petri (PN) descreve somente a estrutura lógica de sistemas, pois tal modelagem não inclui conceitos de tempo.
Todavia, o conceito de tempo possui um papel importante na descrição do comportamento de muitos sistemas e por essa razão faz- se necessário de ser representado.
A inclusão do conceito de tempo no formalismo de Redes de Petri, que foi primeiramente introduzido por Noe e Nutt, Merlin e Farber e Zuberek, é conhecido como Redes de Petri Temporizadas (TPN).
Essa primeira abordagem atribui um tempo xo para o disparo das transições existentes, e devido a esse motivo tornou- se ineciente para representação de todas as realidades.
A atribuição de valores variáveis ao disparo das transições tornou- se necessário, pois esta permite a representação de um conjunto maior de realidades a qual o fator tempo variável é importante.
Então, iniciou- se os primeiros estudos sobre Redes de Petri Estocásticas (SPN), detalhadamente documentados em.
Redes de Petri Estocásticas (SPN) é o formalismo de modelagem de Redes de Petri acrescido da associação de um tempo distribuído exponencialmente para o disparo de cada transição da rede.
Em esse novo conceito, a modelagem e avaliação de sistemas envolvendo concorrência, nãodeterminismo e sincronização faz- se possível.
O formalismo de Redes de Autômatos Estocásticos (SAN) foi proposto por Plateau em 1985, e sua idéia básica é representar um sistema como uma coleção de subsistemas com comportamento independente e interdependência ocasional.
Cada subsistema é denido por um autômato estocástico e por transições entre os estados deste autômato, que são disparadas através de eventos a estas associadas.
Um autômato é um conjunto nito de estados juntamente com um conjunto nito de transições entre estes estados.
A denominação estocásticos atribuída aos autômatos neste formalismo deve- se ao fato de que o tempo é tratado como uma variável aleatória, que na escala de tempo contínua obedece uma distribuição exponencial.
As próximas subseções deste Capítulo apresentarão conceitos básicos referentes ao formalismo SAN, a m de demonstrar como esta abordagem é capaz de descrever sistemas atualmente ditos complexos.
O formalismo SAN utiliza- se das noções de estado e de transições entre os estados para representação dos eventos.
Existem transições que estão relacionadas a apenas um único autômato do modelo.
Porém, transições que estão relacionados ao mesmo tempo a vários autômatos do modelo também podem existir, ocorrendo de acordo com taxas especícas.
A próxima subseção explicará em detalhes os tipos de transições existentes em SAN.
O estado individual de cada autômato é chamado de estado local.
Já o estado global de uma SAN é denido como a combinação de todos os estados locais de cada autômato componente da As ligações existentes entre os estados de um autômato são denominadas de transições.
Associado as transições, existem eventos que determinam quando estas podem ocorrer.
As transições e seus respectivos eventos podem ser classicadas em diferentes tipos, conforme explicado a seguir.
Dois tipos de transições podem modicar o estado global de um modelo SAN:
Transições locais e transições sincronizantes.
Transições locais modicam o estado de apenas um autômato do modelo, e a estas estão associados eventos locais.
Transições sincronizantes modicam simultaneamente o estado de mais de um autômato do modelo, e a estas estão associados eventos sincronizantes.
Ambas transições locais e sincronizantes podem também ser chamadas de transições fun-cionais.
Isto ocorre por que associado ao disparo da transição, podem existir taxas não constantes que determinam o intervalo de disparo associado a esta.
Então, qualquer evento do modelo pode ter associado uma taxa constante (número real posi- tivo) ou uma taxa funcional avaliada por uma função.
Essa função depende do estado dos demais autômatos e resulta num número real positivo que determina se um determinado evento está ou não apto a disparar.
Diferentemente de transições associadas a taxas constantes, taxas funcionais impõem mudanças de estado unidirecionais nos autômatos do modelo.
Ou seja, taxas funcionais modicam apenas o estado do autômato a qual esta pertence e não os estados dos autômatos aos quais ela depende.
O algoritmo proposto no Capítulo 4, levará em conta essa importante premissa a m de determinar o conjunto de estados condição e conseqüência para gerar o RSS de um modelo SAN.
A estrutura de uma SAN compreende um conjunto de autômatos A;
Um conjunto de eventos E;
E uma função de atingibilidade F.
Formalmente, uma SAN é representada por uma tupla do tipo:
Onde: -- A é um conjunto de autômatos que compreende N autômatos nomeados A, onde i -- E é um conjunto de eventos composto por E eventos nomeados ej, onde j 4;
O espaço de estados produto (PSS) em SAN é denido como i $= 1 S, onde S é o conjunto de Em o decorrer deste trabalho, é adotada a notação referindo- se a um número no intervalo de i até j, inclusive, pertencendo ao conjunto dos números naturais;
E a notação referindo- se a um número pertencente ao intervalo i e j, inclusive, no conjunto dos números reais.
Em o contexto deste trabalho, usa- se a letra e para se identicar um evento, porém qualquer outra letra ou palavra poderia ser usada sem perda de generalidade.
A denição de quais estados podem ser atingíveis ou alcançados num modelo SAN é dada por a função de atingibilidade.
A função de atingibilidade F associa aos estados globais de P Ss o valor 1 se eles são atingíveis.
Caso contrário, esta associa o valor 0, marcando- os como inat-ingíveis.
Basicamente, a função de atingibilidade tem o intuito de eliminar os estados globais que não são atingíveis ao modelo, por não corresponderem com a realidade expressada por este.
Por exemplo, um modelo SAN que representa um sistema de compartilhamento de recursos, onde tem- se N clientes disputando R recursos.
É fácil de imaginar- se que se o número de recursos for menor que o número de clientes, o estado global que representa todos os clientes utilizando um recurso não poderá ser atingível.
RSS é um subconjunto de P Ss que compreende todos os estados x~, tais que F(~ x) $= 1, denominados de conjunto de estados atingível.
A Figura 4 é um exemplo de modelo SAN com dois autômatos, um evento sincronizante (e2) e quatro eventos locais.
Em este exemplo, a taxa do evento e1 não é constante e sim funcionalmente denida por a taxa fe1 descrita por a notação utilizada por a ferramenta PEPS.
A interpretação da função f dene o disparo da transição do estado 0 para o estado 1 com taxa se o autômato A está no estado 0, ou taxa se o autômato A está no estado 2.
Se o autômato A está no estado 1, a transição do estado 0 para 1 não ocorre (taxa igual a zero).
É importante observar que o uso de funções disponibiliza uma maneira compacta e exível de descrever comportamentos alternativos através do uso de um simples evento (local ou sincronizante).
Em a verdade, a tarefa de denição de uma função de atingibilidade para modelos criados em SAN talvez seja o aspecto menos encorajador para escolha do uso desse formalismo.
Caso a função de atingibilidade não seja denida, ainda assim é possível encontrar- se todos os estados atingíveis do modelo, porém todas as possibilidades precisam ser computadas, trazendo assim um ônus não desejado ao sistema.
Considerando o modelo exibido por a Figura 5, a função de atingibilidade deve obrigatoriamente excluir o estado global 1 1, e pode ser representada por:
Em SAN, o uso de expressões funcionais não está estritamente limitado a taxas de eventos.
Probabilidades de roteamento do modelo podem também ser expressadas por funções.
De fato, a possibilidade de uso de funções em SAN é considerado uma poderosa característica desse formalismo, uma vez que permite a descrição de sistemas complexos de uma forma compacta.
Além disso, o custo computacional para gerenciamento de taxas funcionais tem signicativamente decrescido com o desenvolvimento de soluções numéricas para modelos SAN (algoritmos para produtos tensoriais generalizados).
Este Capítulo apresentou um embasamento teórico a respeito de os formalismos estudados neste trabalho.
O formalismo de modelagem de Redes de Petri é o referencial de estudo para técnica de otimização do armazenamento do espaço de estados neste aplicada.
O formalismo de Redes de Autômatos Estocásticos é o alvo principal deste trabalho, uma vez que é foco de estudo para proposição de técnica similar para otimização do armazenamento do espaço de estados atingível.
Os próximos Capítulos irão apresentar em mais detalhes a técnica de otimização de espaço de estados existente para o formalismo de PN e a proposta de técnica similar para o formalismo de SAN.
Este capítulo apresenta a técnica utilizada como referência nesse trabalho, responsável por gerar o RSS para o formalismo de SPN e armazenar- lo numa estrutura de MDD.
Este estudo está baseado nos trabalhos propostos por Miner e Ciardo.
Dado o problema da explosão do espaço de estados existente nos formalismos de modelagem em geral, o estudo de técnicas alternativas, que não estejam associadas a necessidade de armazenamento de estruturas de dados de tamanho proporcional ao espaço de estados dos modelos, começam a ser foco de estudo.
Em SPN, a utilização de Diagramas de Decisão Binária (BDD) surge como uma estrutura de dados alternativa, capaz de armazenar apenas a porção atingível de um modelo.
Basicamente, um BDD consiste numa estrutura de dados que armazena apenas valores binários, tais como, em seus nodos.
A relação entre os nodos da estrutura é dada por ponteiros de encadeamento, que determinam os nodos vizinhos mais ao lado e abaixo respectivamente.
Devido a impossibilidade de armazenar- se valores diferentes de 0 e 1 em seus nodos, a estrutura de BDD, quando aplicada ao armazenamento de espaço de estados atingível em SPN, limita- se a representar somente Redes de Petri Limitadas e Seguras.
A estrutura de BDD é também chamada de grafo acíclico direto (DAG).
A Figura 6 representa o BDD equivalente a função f expressa por a Tabela 1.
Os arcos que partem do nodo (ou estado) raiz x1 para os nodos lhe&amp;lhes os mais a esquerda, representam o caminho a ser seguido quando o valor avaliado da função f para as variáveis x1, x2 ou x3 é 0 (falso).
Enquanto que os arcos que partem da raiz x1 para os nodos lhe&amp;lhes os mais a direita, representam a avaliação da função para o valor 1 (verdadeiro).
Partindo- se do nodo raiz, e seguindo- se os arcos até chegar- se aos nodos lhe&amp;lhes os existentes (de acordo com o valor atribuído para a variável xn em cada nível) é possível chegar- se ao valor 0 ou 1 avaliado por a função f, representado por os nodos terminais 0 e 1 da estrutura de BDD.
O estudo de BDD aplicado ao formalismo de Redes de Petri Estocástica teve o objetivo de aliviar o problema da explosão do espaço de estados para sistemas grandes e complexos, pois este almeja o armazenamento de apenas o RSS do modelo.
De fato, trabalhos posteriores apresentados por Miner e Ciardo, e inspirados nesse primeiro experimento realizado com a estrutura de BDD, propõem o uso de uma estrutura de dados mais poderosa, denominada de Diagramas de Decisão Multi--Valorada (MDD).
N). Analogamente a estrutura de BDD, os nodos da estrutura representam as variáveis do sistema enquanto que os arcos (ou linhas) representam os possíveis valores que estas podem assumir.
A grande diferença dá- se ao fato do MDD não estar limitado a armazenar apenas valores binários.
A Figura 7 exemplica uma estrutura MDD que representa a função mínimo entre três valores inteiros min (a, b, c).
Partindo- se do nodo raiz e seguindo os caminhos existentes representados por os arcos até os nodos terminais é possível determinar- se qual o valor mínimo entre a, b e c..
Por exemplo, quando a assume o valor 0, o arco com valor 0 liga a raiz a direto ao nodo terminal 0 (arco mais a esquerda), uma vez que não é necessário testar os demais valores de b e c..
Outro caminhamento existente assume que a tem o valor 2 (arco mais a direita), e b também possui o valor 2 (arco mais a direita de b), portanto ainda é preciso avaliar o valor de c..
Assumindo que o valor de c seja 0 (arco mais a esquerda) ou 1 (arco do meio), os valores mínimos são respectivamente 0 ou Portanto, a característica diferencial apresentada por a estrutura de MDD, permite que valores inteiros quaisquer sejam armazenados nos nodos da estrutura.
Este torna- a mais poderosa no âmbito de representação de espaço de estados para o formalismo de modelagem SPN.
A Seção a técnica aqui referenciada.
Conceitos de otimização são sempre importantes de serem mencionados e avaliados, uma vez que renam e melhoram técnicas em geral.
Otimizações de ordenação e redução, previamente abordadas para BDDs, são igualmente importantes para que uma estrutura de MDD atinja sua forma mais compacta possível.
Esta, é usualmente denominada de forma canônica.
É sabido que ambas estruturas de BDD e MDD só atingem a sua forma canônica, se estiverem propriamente ordenadas e reduzidas.
O processo de compactação ocorre através da aplicação das regras de redução mencionadas em sobre um modelo MDD já ordenado de acordo com algum critério estabelecido.
De fato, não existe um método conhecido para denir qual o melhor critério de ordem a ser aplicado.
Estudos realizados até então demonstram que a obtenção da melhor ordem (que torna a estrutura mais compacta ou com menor número de estados) é somente atingida através do teste de todas as possibilidades existentes.
O Capítulo 6 irá exercitar essa idéia em busca de uma heurística que determine o critério de ordem mais apropriado para o formalismo de SAN.
A estrutura de MDD ordenada e reduzida (estados redundantes são eliminados sem alterar a representação do espaço de estados) é denominada de Diagramas de Decisão Multi--Valorada Ordenado e Reduzido (ROMDD).
Todavia, no decorrer desse estudo a mesma será referenciada apenas como MDD, pois todas as estruturas aqui apresentadas estarão na sua forma canônica.
Em SPN, o critério de ordem é estabelecido sob um modelo previamente particionado de acordo com algum critério.
Em geral, o critério de partição é considerado uma tarefa independente, que deve ser resolvida a priori.
Segundo Miner e Ciardo, o estudo do critério de partição do modelo requer esforço adicional a denição do algoritmo de geração e armazenamento e deve ser tratado em escopo especíco, por apresentar um tema vasto para estudo e experimento.
De fato, o número de partições denidas para o modelo SPN representará o número de níveis da estrutura de MDD, inuenciando diretamente na compactação da estrutura (e não na corretude do algoritmo).
Ainda, a ordem em que os sub-modelos ou subsistemas são dispostos nos níveis da estrutura irá inuenciar no número de estados nal da estrutura de MDD.
A Seção 3.2 irá apresentar um exemplo de particionamento e ordenamento para um modelo SPN.
O Algoritmo 1, proposto em, demonstra como obter o MDD através da simulação do disparo das transições de uma SPN.
Este assume que o modelo SPN já foi particionado e ordenado de acordo com algum critério pré-estabelecido, não enfatizando dessa forma essas etapas.
O primeiro passo proposto por o Algoritmo 1 (linha 3) é o disparo de transições locais, uma vez que estas afetam apenas o subsistema local a qual pertencem.
As transições sincronizantes são então disparadas (linha 6) logo após, afetando simultaneamente mais de um subsistema.
Algorithm 1 MDDExplore until forever Basicamente, o algoritmo permanece num loop simulando o disparo de transições locais e sincronizantes até que o espaço de estados atingível (RSS) seja gerado e armazenado na estrutura de MDD.
Esta seção apresenta um exemplo de sistema utilizando modelagem em Redes de Petri Estocástica com a representação do espaço de estados atingível utilizando a estrutura de MDD.
A Figura 8 ilustra um sistema de compartilhamento de recursos.
Em esse modelo, existem N processos compartilhando R recursos.
Cada subsistema possui dois lugares:
Si que representa o estado Sleeping (ocioso) e Ui representando o estado Using (em uso).
Marcas existentes no lugar RS representam o número de recursos disponíveis, enquanto que marcas disponíveis em RU representam o número de recursos em utilização.
As transições tai e tri são sincronizantes entre os i-ésimos processos e os recursos.
A m de vericar se a ordem em que os subsistemas são representados na estrutura de dados inuência ou não o número de estados necessários, duas abordagens foram estudadas.
A primeira abordagem assume que o subsistema que controla os recursos disponíveis é a raiz da estrutura (Nível 5), seguido respectivamente por os Processos 4 (Nível 4), 3 (Nível 3), 2 (Nível 2) e 1.
A segunda abordagem assume que a raiz é iniciada por o Processo 1 (Nível 5), seguido respectivamente por os Processos 2 (Nível 4), 3 (Nível 3) e 4 (Nível 2) e nalmente o subsistema que controla os recursos disponíveis.
A Tabela 2 apresenta a codicação utilizada na criação da estrutura de MDD apresentada por as Figuras 9 e 10.
S1 $= 1 e U1 $= 0.
Porém, quando o Processo 1 está em uso, o valor da codicação é 1, ou seja S1 $= 0 e U1 $= 1.
Essa mesma codicação é utilizada para todos os demais Processos 2, 3, e 4.
A codicação 2 não é aplicável aos Processos, e é representada por n/ a, uma vez que necessita- se apenas de dois valores distintos para representar as possibilidades existentes.
A coluna Recurso necessita de três codicações distintas, expressas por os valores 0, 1 ou 2, que signicam respectivamente dois lugares disponíveis e zero em uso, um lugar disponível e um em uso e zero lugares disponíveis e dois em uso.
Para ambos os casos, duas guras de MDD representando o espaço de estados atingível são exibidas.
As Figuras 9 (a) e 10 (a) apresentam o MDD em fase inicial, sem a aplicação das regras de otimização, para respectivamente a primeira e segunda disposição (subsistema de controle de recursos é a raiz).
Já as Figuras 9 (b) e 10 (b) exibem o MDD em sua forma canônica para ambas.
Finalmente, a m de determinar- se o espaço de estados atingível expresso por as estruturas de MDDs das Figuras 9 e 10, basta partir- se do nodo raiz destas e seguir os caminhos expressos por os arcos existentes até atingir- se os nodos terminais.
A utilização da forma reduzida da estrutura, ilustrada por o desenho (b) de cada uma das Figuras MDDs mencionadas, é mais rápida e ecaz de ser utilizada, uma vez que esta não possui caminhos redundantes.
Este Capítulo referenciou conceitos importantes da técnica de armazenamento do espaço de estados que visa apenas a porção atingível do modelo para o formalismo de modelagem SPN.
Ainda, um pequeno histórico da evolução da técnica foi abordado, começando com a utilização de BDD e posteriormente partindo- se para uma estrutura de dados mais poderosa denominada de MDD.
Os próximos Capítulos irão utilizar o embasamento aqui adquirido a m de aplicar- se uma técnica análoga ao formalismo de SAN.
Apresenta- se nesse capítulo o algoritmo proposto para geração e armazenamento do espaço de estados atingível para o formalismo de modelagem SAN utilizando- se MDD.
Primeiramente, uma breve referência sobre a atual técnica utilizada em SAN é apresentada, seguida da nova técnica baseada em MDD.
A atual técnica de geração e armazenamento do espaço de estados atingível para o formalismo de SAN utiliza uma abordagem baseada num Vetor de Booleanos.
Cada possível estado do modelo requer uma posição que o represente nesse vetor.
Se um estado é determinado como atingível, a posição correspondente do vetor é assinalada como verdadeiro.
Caso contrário, a posição correspondente no vetor é assinalada como falso.
Atualmente, esta técnica está implementada na ferramenta PEPS, e mesmo requerendo apenas um bit para representar cada estado, resulta em gastos enormes de armazenamento de memória para modelos grandes e complexos.
A fórmula para cálculo do consumo de memória para um modelo SAN que utiliza a técnica Vetor de Booleanos é obtida através da divisão do espaço de estados produto por 8, uma vez que cada estado é representado por um bit apenas.
Esta é melhor detalhada no Capítulo seguinte 5, onde um comparativo entre ambas as técnicas Vetor de Booleanos e MDD é estabelecido.
Ainda, denir a função de atingibilidade associada a cada modelo SAN utilizando o método Vetor de Booleanos é, na maioria dos casos, um processo complexo, porém mandatório para tal abordagem.
A função de atingibilidade é responsável por guiar o algoritmo de geração durante a denição dos estados atingíveis do modelo, restringindo os estados não pertencentes a realidade por este representada.
A idéia de aplicar a estrutura de MDD em SAN surge como uma alternativa interessante para aliviar os problemas de explosão do espaço de estados encontrados na atual abordagem.
Analogamente ao que é hoje aplicado em SPN, chega- se a um primeira versão da técnica que utilizará MDD para armazenar o espaço de estados atingível em SAN.
As etapas de partição do modelo em subsistemas e ordenamento na estrutura de MDD é um pré-requisito para a técnica a ser aplicada, assim como fundamentado por a técnica estudada em SPN.
A característica de modularidade apresentada por o formalismo SAN torna essa divisão mais fácil.
Um critério simples de partição assume que cada autômato do modelo é um nível da estrutura de MDD.
Alternativamente, o modelo poderia ser particionado de uma forma distinta, assumindo mais de um autômato por nível por exemplo.
Todavia, esta alternativa não foi aqui estudada, mas de qualquer forma pode vir a ser explorada no futuro a m de vericar- se se esta traria algum benefício adicional a técnica.
De fato, os critérios de partição e ordem são variantes que podem inuenciar na otimização da estrutura de MDD, mas que não implicam na corretude da técnica aqui proposta.
Então, selecionado o critério de partição um autômato para cada nível da estrutura de MDD, a ordem em que os autômatos serão dispostos nos níveis da estrutura MDD é guiada por o identicador de cada autômato do modelo.
Por exemplo, considerando um modelo SAN composto por 4 autômatos respectivamente rotulados por os identicadores 1, 2, 3 e 4, a estrutura MDD que representa esse modelo possuirá 4 níveis distintos.
As ordens aqui estabelecidas são apenas dois possíveis exemplos, de entre muitas outras combinações existentes.
De fato, a ordem em que os autômatos são dispostos na estrutura de MDD é um fator muito importante de ser determinado a priori, uma vez que tal característica inuência diretamente na otimização da estrutura de MDD.
Em razão de isso, a Seção 6.1 apresenta diversos experimentos, onde a ordem dos autômatos na estrutura de MDD é variada, a m de que estabeleça- se uma heurística que sugira um bom critério de ordem.
Conclusões iniciais referenciadas no Capítulo 6 apontam as condições em que a estrutura de MDD torna- se mais otimizada (e igualmente ecaz).
Assim como fundamentado em SPN, o algoritmo de geração de espaço de estados atingível utilizando MDD em SAN, Algoritmo 2, baseia- se na simulação de disparo dos eventos locais e sincronizantes do modelo.
O disparo de eventos locais afeta apenas o subsistema a qual ele pertence, enquanto que o disparo de eventos sincronizantes afeta simultaneamente dois ou mais subsistemas do modelo.
O primeiro passo do Algoritmo 2 dene dois conjuntos de estruturas de MDDs, que respectivamente representam os estados condições (Cd (e)) e conseqüências (Cq (e)).
Os estados condições e conseqüências são gerados para cada evento do modelo, independentemente destes serem eventos sincronizantes ou locais.
Os estados condições d Cd (e) representam os estados que habilitam o evento e a ser disparado.
Os estados conseqüências q Cq (e) representam os estados atingidos depois que o evento e é disparado.
A tarefa de geração dos estados condições e conseqüências está explicada em detalhes por o Algoritmo 3.
Todavia, para um melhor entendimento do primeiro passo do algoritmo, os estados condições e conseqüências relativos ao modelo SAN apresentado por a Figura 4, estão denidos na Tabela 3 e ilustrados na Figura 14.
Assumindo- se que o modelo apresentado por a Figura 4 foi particionado em 2 sub-modelos tem- se um sub-modelo para cada autômato.
Ainda, o autômato A representa o nível 1 da estrutura de MDD, enquanto que o autômato A representa o nível 2.
Analisando a Tabela 3 e Figura 14 observamos que os estados condição e conseqüência são respectivamente denominados por dn e qn.
A variável n representa um valor inteiro seqüencial, conforme denido por o atual critério de partição.
A existência de estados condição e conseqüência num determinado nível das estruturas de MDDs iniciais está diretamente associada a existência do evento aos quais eles representam nos autômatos do modelo.
Em outras palavras, no caso de um evento aparecer em apenas um autômato do modelo, os estados condição e conseqüência irão existir apenas no nível de MDD associado ao autômato especíco.
Por exemplo, o evento e3 é local a A, e portanto os estados condição e conseqüência do mesmo, representados por d4 e q4 aparecem apenas no nível 2 da estrutura de MDD.
Em d4 e q4, o nível 1 está representado com um traço horizontal, que signica a não existência de estados condição e conseqüência para este nível da estrutura).
Além disso, caso um mesmo evento apareça mais de uma vez no mesmo autômato (existência de probabilidades), tal evento recebe diferentes identicadores dn e qn.
Por exemplo, o evento e2 aparece duas vezes no autômato A, em e2 (2) e e2 (1).
Para tanto, a transição e2 (2) é representado por o estados d2, q2, enquanto que e2 é representado por d3 e q3.
Em caso de eventos que representem taxas funcionais, os estados condição implicam na existência de estados alternativos para o disparo do evento.
Por exemplo, o conjunto d1 demonstra que o nível 2 da estrutura de MDD está condicionalmente associada a existência de 0 ou 2 na estrutura resultante de MDD, para que o evento e1 possa disparar, uma vez que a função associada a e1 assim o determina.
A segunda etapa do Algoritmo 2 (linha 2) é especicar o espaço de estados inicial para o conjunto RSS.
O RSS pode ser inicializado com o estado global inicial do modelo ou com um conjunto de estados inicial (estados já conhecidos como atingíveis), através do uso de uma função.
De fato, a principal funcionalidade do Algoritmo 2 consiste num loop que permanece testando os estados condição para todos os eventos, e modicando o conjunto RSS através da adição dos estados conseqüência na estrutura de MDD resultante, quando necessário.
A condição de parada do laço é vericada quando o conjunto RSS não é mais modicado e todos os eventos e tenham disparado no mínimo uma vez.
Formalmente, esta etapa do algoritmo verica se os estados condições d Cd (e) RSS para cada evento e do modelo.
Caso a condição seja satisfeita, todos os estados conseqüências q Cq (e) correspondentes ao evento e são adicionados no conjunto RSS (caso q O tratamento das taxas funcionais durante o loop principal é um fator importante abordado por o algoritmo, umas vez que é um diferencial para o formalismo de SAN.
A ação tomada para modicar- se a estrutura de MDD resultante difere se o evento em questão possui ou depende de uma taxa funcional.
Em tal situação, a seguinte característica é de fundamental importância quando um modelo utiliza taxas funcionais:
Taxas funcionais impõem mudanças de estado unidi- recionais nos autômatos do modelo.
Ou seja, taxas funcionais modicam apenas o estado a qual ela pertence e não o estado a qual ela depende.
Essa premissa está representada no Algoritmo 3 por as linhas 4 e 11 respectivamente, impondo mudanças na estrutura MDD resultante apenas para os estados pertencentes e descartando quaisquer modicações para os estados dependentes.
As Figuras de 15 a 25 representam passo a passo a obtenção da estrutura de MDD resultante para o modelo SAN exibido por a Figura 4.
O estado global utilizado é composto por os estados iniciais 0 0, conforme também demonstrado por a Figura 15 Passo 1.
Em particular, a Figura 15 também salienta o tratamento das taxas funcionais expressas por o algoritmo, uma vez que o conjunto d1 é disparado.
Em esse caso, a existência de 0 no nível 2 da estrutura de MDD inicial habilita o disparo de d1.
Já, a estrutura MDD resultante após o disparo de d1 tem alterado apenas o nível 1, uma vez que o nível 1 representa o autômato 1, a qual o evento e1 pertence.
Cabe salientar que do passo 1 ao passo 5, a estrutura MDD resultante se modica a cada nova iteração do algoritmo.
Porém, do passo 6 ao passo 11, todos os estados condição foram aptos a disparar, porém sem modicação nenhuma na estrutura MDD resultante.
Então, o passo 11 (Figura 25) atinge a condição de parada proposta por o algoritmo, uma vez que todos os estados Cd (e) foram disparados e nenhuma modicação nova foi imposta com a adição dos estados Cq (e).
O MDD representado por a Figura 26, já apresenta- se em sua forma canônica, pois após a aplicação das regras de redução, a estrutura permanece com o mesmo número de estados.
A aplicação das regras de redução do RSS como última etapa do algoritmo é ainda considerado um experimento inicial.
Futuros estudos podem avaliar se a inclusão da etapa de redução no laço principal do algoritmo traria benefícios adicionais ao algoritmo, como menor consumo de memória durante a geração.
Tal idéia pode vir a melhorar o desempenho do algoritmo, mas de qualquer forma, não foi explorada por este estudo.
Cabe salientar, que a inclusão das regras de redução durante o loop principal poderá representar um consumo maior de CPU também.
Portanto, uma avaliação de custo benefício faz- se se necessário, a m de determinar se o ganho de memória comparado ao aumento do consumo de CPU compensará ou não.
A análise da complexidade de um algoritmo refere- se ao tempo de execução que o mesmo apresenta para realização da tarefa proposta.
O Algoritmo 2 será aqui avaliado através da Notação O, que representa a maior grandeza que este poderá assumir durante a geração do espaço de estados atingível para SAN.
Basicamente, o Algoritmo 2 é composto de três grandes etapas a serem avaliadas.
A primeira parte é apresentada na linha 1, e refere- se a geração de estados Cd (e) e Cq (e), detalhadamente apresentada por o Algoritmo 3.
A segunda etapa importante a ser avaliada é o laço principal do Algoritmo 2, representado entre as linhas 3 e 13.
Por m, o laço de redução da estrutura de MDD, representado entre as linhas 14 e 17 do Algoritmo 2 também deve ser considerado.
Pode- se dizer que estes três grande passos representam as principais variáveis associadas a execução da tarefa de geração e armazenamento do espaço de estados atingível numa estrutura de MDD para o formalismo SAN.
Portanto, a idéia é chegar- se a uma fórmula matemática expressa por a equação 4.1 abaixo e que representa a grandeza de tais variáveis:
Onde x, y e z representam as variáveis associadas a cada uma das três etapas e que inuenciarão diretamente no desempenho do algoritmo.
A primeira parte, linha 1 do Algoritmo 2, refere- se ao Algoritmo 3.
Avaliando- se o mesmo, conclui- se que três sub-etapas são importantes e podem inuenciar no seu desempenho.
O co-mando for all evento e apresentado na linha 1, enumera todos os eventos existentes no autômato, portanto o número de eventos está diretamente associado a complexidade aqui avaliada.
A variável e representa este fator.
Além disso, o comando for i $= 1 to N, apresentado por a linha 2 também inuenciará diretamente na grandeza apresentada por o algoritmo.
Este fator será representado por a variável N, que representa propriamente o número de autômatos do sistema.
Finalmente, esta primeira etapa também está diretamente associada a complexidade de execução do conjunto de instruções representados por as linhas 3 a 16.
Em essa fase, os MDDs iniciais são construídos através da atribuição de estados habilitadores e estados conseqüência do modelo.
Então, a grandeza de ordem maior é aqui representada por o número máximo de estados de todos os autômatos do modelo.
Este aspecto será aqui representado por a variável µ.
Têm- se então a primeira parcela da fórmula matemática que representa a complexidade do algoritmo, conforme a equação 4.2: A segunda parcela a ser avaliada, diz respeito ao laço principal do Algoritmo 2, representado por as linhas de 3 a 13.
O comando for all Cd (e) Cq (e) referenciado na linha 6 testa todos os estados condição contra o RSS e aplica os estados conseqüência neste, caso necessário.
Conclui- se então que este passo está diretamente associado a maior grandeza das estruturas de MDD que representam Cd (e) Cq (e) respectivamente.
Em o pior caso, ambos MDDs terão o tamanho máximo do número de estados existentes nos autômatos do modelo.
Portanto, considerando que a variável µ refere- se ao número máximo de estados do modelo para cada um dos conjuntos Cd (e) Cq (e), têm- se (µ_ µ).
Ainda, o laço for all evento e (linha 5) é facilmente identicado como diretamente associado ao número de eventos do modelo.
Portanto, a variável e representa este aspecto.
De essa forma, chega- se a segunda parcela da fórmula matemática para complexidade do algoritmo, conforme representado em 4.3: O laço de redução da estrutura for i $= N to 2, referenciado por as linhas de 14 a 16 do Algoritmo 2, é responsável por identicar os nodos repetidos da estrutura de MDD resultante, eliminandoos através do redirecionamento dos ponteiros de encadeamento.
Os fatores relevantes nesse caso, são portanto o número máximo de autômatos, representado por a variável µ, que determina de fato o valor de N para o laço for i $= N to 2.
Ainda, o número máximo de eventos, inuência no tamanho das estruturas de MDD iniciais (Cd (e) Cq (e)) que foram adicionadas ao MDD resultante, representado por o conjunto RSS.
Então, a variável e está também diretamente associada e deve ser levada em conta, conforme explicitado por a terceira parcela da equação 4.4, que também representa a equação nal, ainda não reduzida:
Finalmente, é necessário reduzir- se as grandezas repetidas apresentadas por a equação 4.4, uma vez que as mesmas se sobrepõe, não sendo necessário considerar- las mais de uma vez.
A terceira parcela está embutida na primeira parcela da equação 4.4, e portanto pode ser eliminada.
Porém a primeira e segunda parcelas representam grandezas de ordens diferentes e devem ser mantidas.
Chega- se portanto a equação nal que representa a complexidade do algoritmo aqui estudado, representada por a equação 4.5: Considerações nais a respeito de a equação 4.5 salientam que em caso o número de estados ou número de autômatos dobrar, o tempo de execução do algoritmo poderá aumentar em no máximo 16 vezes, conforme equação 4.6 representada abaixo:
Um protótipo do Algoritmo 2 aqui apresentado foi implementado no âmbito do grupo PEG (Performance Evaluation Group) por um bolsista também engajado em estudos da mesma área de interesse.
A linguagem de programação C+ foi utilizada para a implementação deste.
De fato, referimos a este como um protótipo, pois a implementação do uso de funções, mecanismo existente em SAN, ainda não foi coberto, assim como questões referentes a performance.
A implementação deste primeiro protótipo visa a realização de testes a m de vericar a corretude do algoritmo aqui proposto, através de exemplos de modelagem apresentados nos próximos m de identicar possíveis áreas a serem melhoradas no algoritmo.
De fato é sabido através dos testes realizados para efeitos de comparação das técnicas MDD e Vetor de Booleanos (Capítulo 5) que a etapa de geração dos estados condição e conseqüência, primeira etapa imposta por o Algoritmo 2, pode ser melhorada, uma vez que demonstrou consumir bastante memória durante execução do algoritmo.
O Capítulo 7 referência uma possível alternativa para melhoria de tal etapa.
Este Capítulo apresentou o Algoritmo capaz de gerar e armazenar espaço de estados atingível para o formalismo de modelagem SAN.
Ainda, a análise da complexidade deste foi avaliada, com intuito de determinar quais as variáveis que inuenciam no tempo de execução requerido durante a realização da tarefa proposta.
Os próximos Capítulos irão utilizar o protótipo implementado para realização de testes de exemplos de modelagem, a m de que a corretude do algoritmo proposto seja comprovada.
Ainda, experimentos que determinam a inuência da ordem dos autômatos com a compactação da estrutura de MDD também serão apresentados.
Apresenta- se nesse capítulo um comparativo do gasto de memória para as técnicas MDD e Vetor de Booleanos.
Exemplos de modelagem são apresentados, estabelecendo- se conclusões relativas ao consumo nal de memória para ambas técnicas.
Esta seção apresenta diversos exemplos SAN modelados com MDD.
A idéia é ir aumentando o PSS de modelos SAN com RSS reduzidos, a m de estabelecer- se um comparativo entre as técnicas de MDD e Vetor de Booleanos com relação a o consumo nal de memória para armazenar- se os estados atingíveis.
De fato, a m de estabelecer- se um comparativo do gasto de memória para o uso de MDD e Vetor de Booleanos, primeiramente necessita- se entender como é calculado o consumo nal de memória para ambos.
No caso de o Vetor de Booleanos, para calcular- se o consumo nal de memória basta dividir- se o espaço de estados produto do modelo por 8 (lembrando- se que este consome apenas um bit para armazenar cada possível estado).
No caso de a técnica MDD, 2 bytes são utilizados para armazenar o valor de um nodo da estrutura, mais 2 ponteiros de encadeamento de 4 bytes cada, contabilizando um total de 10 bytes para armazenagem de cada nodo da estrutura de MDD.
A Figura 27 exibe a estrutura de um nodo MDD para facilitar o entendimento do cálculo de memória aqui referido.
Basicamente, cada nodo necessita armazenar um valor inteiro de 0 a N e o encadeamento com os nodos vizinhos ao lado e abaixo.
De essa forma, as fórmulas a seguir representam como calcular- se o consumo nal de memória para cada uma das técnicas:
Memoria_ Vetor_ Boleanos $= bytes Memoria_ MDD $= bytes Modelos SAN com e sem semântica, que variam o número de autômatos e o conjunto de eventos sincronizantes e locais são apresentados nessa subseção.
O modelo SAN 1 apresentado por a Figura 28 possui 4 autômatos, 6 eventos sincronizantes e 8 eventos locais.
O PSS do modelo é pequeno, apenas 81 estados e com 41 estados globais atingíveis (RSS).
A estrutura MDD gerada por a técnica está apresentada por a Figura 29 e apresenta um total de 17 nodos.
O modelo SAN 2 apresentado por a Figura 30 possui 5 autômatos, 7 eventos sincronizantes e apenas 1 evento local.
O PSS do modelo é um pouco maior, porém ainda considerado pequeno, 500 estados e 20 estados globais atingíveis (RSS).
A estrutura MDD gerada por a técnica está apresentada por a Figura 31 e possui 19 nodos.
Esse modelo SAN, possui uma interdependência aos pares, conforme explicado abaixo:·
autômato A e A possuem eventos sincronizantes s1 e s4;·
autômato A e A possuem eventos sincronizantes s2 e s5;·
autômato A e A possuem eventos sincronizantes s3 e s6;
O MDD resultante que representa o RSS do modelo é exibido por a Figura 33 e possui 18 nodos.
O modelo SAN 4 apresentado por a Figura 34 possui 7 autômatos, 14 eventos sincronizantes e apenas 1 evento local.
O PSS do modelo é bem maior comparado aos exemplos anteriores, técnica possui 46 nodos e está apresentada por a Figura 35.
Observando- se a Tabela 4 vericase que modelos SAN com PSS pequenos, mesmo apresentando um elevado número de estados inatingíveis, a técnica MDD não compensa.
Por exemplo, tomando- se o modelo SAN 3, que possui apenas 4% de estados atingíveis sob o percentual de todo o PSS, o consumo nal de memória da técnica MDD é ainda em torno de 50% maior.
Porém, considerando o modelo SAN 4, onde o PSS já é um pouco maior, e o número de estados atingíveis menor que 1%, a economia de memória utilizando- se MDD é de cerca de 97%.
O Gráco 36 também representa o comparativo de memória para os exemplos SAN mencionados acima.
Novamente, percebe- se que o uso de MDD para modelos SAN com espaço de estados pequeno não é eciente, mesmo o modelo possuindo um grande percentual de estados inatingíveis.
Continuando a coleta de dados para o estabelecimento do comparativo entre as técnicas, avalia- se a seguir o clássico modelo Jantar dos Filósofos.
Em particular, a avaliação deste modelo permite aumentar- se o número de lósofos a m de variar- se bastante os valores para PSS e O clássico modelo do Jantar dos Filósofos, amplamente citado na literatura SAN foi avaliado com valores de 3, 4, 5, 6, 7, 8, 9, 10, 11 e 12 lósofos.
A cada novo lósofo adicionado, 3 novos eventos sincronizantes mais um novo autômato são adicionados ao modelo, aumentando- se dessa forma as variáveis que trazem mais complexidade a esse modelo SAN.
O MDD resultante que representa o RSS do modelo é exibido por a Figura 38 e requer 30 nodos para armazenar o RSS.
A Tabela 5 apresenta o comparativo do gasto de memória para as técnicas de MDD e Vetor de Booleanos, para o modelo SAN com 3, 4, 5, 6, 7, 8, 9, 10, 11 e 12 lósofos.
Conforme o número de lósofos aumenta (conseqüente crescimento do PSS e diminuição do RSS), o método de MDD demonstra- se mais eciente, tendo um gasto de memória bem inferior comparado ao Vetor de Booleanos.
De fato, esse ganho dá- se principalmente por a característica do modelo em questão apresentar um grande número de estados inatingíveis aplicados a um espaço de estados produto consideravelmente elevado.
O Gráco 39 também representa o comparativo de memória para o exemplo dos lósofos com o consumo nal de memória ambos métodos.
Este demonstra a eciência do uso de MDD para o modelo SAN dos lósofos somente quando o modelo apresenta um PSS grande e um valor baixo de estados atingíveis.
Esta análise conclui que o ganho efetivo da técnica inicia- se com o número de lósofos maior ou igual a 6, que possui PSS com cerca de 46.656 estados ou mais.
A economia do consumo nal de memória para 6 lósofos está em torno de 50%.
Considerando o maior número de lósofos testado, que foi de 12, a economia do consumo nal de memória ca em 99%.
Figura 39 Comparação do Consumo de Memória para Modelo Jantar dos Filósofos O próximo modelo SAN apresentado é o modelo de Compartilhamento de Recursos.
Este modelo representa N processos compartilhando R recursos.
O modelo aqui avaliado possui 16 processos e número de recursos será variado de 2 a 6 exercitando- se assim diferentes valores de PSS e RSS.
O conjunto de autômatos que representam o modelo de Compartilhamento de Recursos é composto por um autômato para cada processo e outro autômato que controla o número de recursos.
O autômato que representa os processos possui 2 estados, que representam respectivamente Ocioso (Sleep) e Em U so (U sing).
O autômato que representa os recursos possui um estado para cada recurso compartilhado.
No caso de 2 recursos compartilhados, teremos 3 estados R0, R1, R2 que representam respectivamente 0 recursos em uso, 1 recurso em uso e 2 recursos em uso.
Eventos sincronizantes an entre os autômatos de processos e o autômato de recursos alocam recursos quando um processo passa do estado Ocioso para o estado Em U so.
Eventos sincronizantes rn liberam recursos em uso quando autômatos que representam os processos passam do estado Em U so para Ocioso.
A Figura 40 exibe o modelo SAN para o exemplo em estudo.
A Tabela 6 apresenta o comparativo do gasto de memória para as técnicas de MDD e Vetor de Booleanos, para o modelo de compartilhamento de recursos com 16 processos, variando- se o número de recursos para 2, 3, 4, 5, 6 recursos compartilhados.
Além disso, esta apresenta os valores de PSS e RSS e percentual de RSS sob PSS para todas as congurações testadas.
Conforme o número de recursos aumenta (conseqüente aumento do PSS e diminuição do RSS), o método de MDD demonstra- se mais eciente, tendo um gasto de memória sempre bem inferior comparado ao Vetor de Booleanos.
De fato, esse ganho dá- se principalmente por a característica do modelo em questão apresentar um grande número de estados inatingíveis aplicados a um espaço de estados produto grande, da mesma forma que o exemplo anterior dos lósofos.
O Gráco 41 também representa o comparativo para o exemplo do compartilhamento de recursos destacando o consumo nal de memória ambos métodos.
Este demonstra a eciência do uso de MDD para este modelo SAN para todos os valores de recursos testados.
O ganho máximo se dá para o número de recursos 6, a qual o método MDD obteve um ganho de 98% comparando- se o consumo nal de memória para ambos métodos.
Este capítulo apresentou uma série de modelos SAN avaliados por as técnicas de Vetor de Booleanos e MDD a o que diz respeito ao consumo nal de memória.
Avaliando os modelos apresentados, constatou- se que o ganho efetivo da técnica de MDD sob a técnica Vetor de Booleanos está associado a modelos SAN com um percentual muito baixo de estados atingíveis, juntamente com modelos que apresentem espaço de estados produto consideravelmente grande.
Vericou- se que apenas a existência de um elevado número de estados inatingíveis não constitui- se por si só característica indicativa para o uso da técnica de MDD.
De fato, a combinação de duas importantes características que são elevado percentual de estados inatingíveis e um elevado tamanho de PSS (varia de acordo com o modelo, mínimo de 7.776 estados) são prerrogativas determinantes para a escolha da técnica de MDD.
Os próximos Capítulos irão explorar como a variação de ordens dos autômatos na estrutura de MDD inuência a compactação desta.
Ainda o Capítulo nal traz as principais colaborações apresentadas por o presente trabalho assim como sugestões de trabalhos futuros.
Apresenta- se neste capítulo como a ordem de disposição dos autômatos nos níveis da estrutura de MDD pode inuenciar no número nal de nodos resultantes.
Para tanto, alguns modelos SAN foram testados e as conclusões são aqui apresentadas.
Para execução dos testes de ordem, foram escolhidos alguns modelos SAN, e testados com o Algoritmo 2 implementado.
Várias ordens existentes foram exploradas, a m de determinar- se uma heurística que aponte a estrutura MDD mais compacta possível que represente o RSS do modelo.
O resultado dos testes aponta que uma boa ordem para disposição dos autômatos na estrutura de MDD seria manter os autômatos que têm interdependência o mais perto possível nos níveis da estrutura.
Autômatos que possuem interdependência, são autômatos que possuem eventos sincronizantes ou dependências funcionais entre si.
Basicamente três modelos SAN foram testados e avaliados nas seguintes condições:
Para cada combinação de ordem proposta, avaliou- se o número de nodos antes da aplicação da etapa de redução (Núm.
Máximo), e o número de nodos após a aplicação da etapa das regras de redução (Algoritmo 2) (Núm.
Final). O objetivo desse teste é encontrar qual a combinação de ordem que resulta num MDD mais compacto (número nal de nodos menor) e com o menor número de reduções necessárias (Em um_ Final -- Em um_ Máximo).
O primeiro exemplo (Figura 32) descreve um modelo com 6 autômatos, sem taxas funcionais, 3 eventos locais e 6 eventos sincronizantes.
Um modelo SAN compacto, com um espaço de estados produto de 729 estados, porém com um RSS de apenas 80 estados.
Esse modelo SAN, possui uma interdependência aos pares, conforme explicado na seção anterior 5.1.
Avaliando o Número Final de nodos gerados (Tabela 7), vericase que as melhores ordens são aquelas em que a interdependência entre os pares de autômatos estão aproximadamente dispostas nos níveis da estrutura de MDD A, A A e A) (Número Final $= O segundo exemplo apresentado (Figura 42), descreve um modelo de 7 autômatos, sem taxas funcionais, 9 eventos locais e 4 eventos sincronizantes.
O espaço de estados produto do modelo contabiliza 512 estados, enquanto que o espaço de estados atingíveis RSS representa apenas 64 estados.
Conforme exibido na Figura 42, neste exemplo, o quinto autômato A possui interdependência individual com quatro autômatos do modelo A, A e A, enquanto que os dois últimos autômatos A e A possuem apenas eventos locais.
O terceiro e último exemplo avaliado é novamente o clássico modelo do Jantar dos Filósofos.
O modelo SAN desse exemplo (Figura 43) não possui nenhum evento sincronizante.
Porém, ele representa 7 lósofos, com 14 eventos locais e com taxas funcionais, mais 7 eventos locais com taxas constantes.
O espaço de estados produto é representado por 2187 estados, com apenas 408 estados atingíveis (RSS).
Esse modelo assume que o primeiro lósofo pega o garfo com a mão esquerda primeiramente, enquanto que os outros pegam o garfo com a mão direita.
Tal comportamento assimétrico é necessário para que o sistema não entre em deadlock.
Este modelo representa a restrição de uso do recurso garfo apenas com taxas funcionais.
Claramente, todos os autômatos do modelo possuem interdependência funcional com os seus dois vizinhos imediatos.
Este estudo apresentou um algoritmo para armazenamento do RSS para o formalismo SAN utilizando a estrutura de MDD.
No caso de o formalismo de SPN, a utilização da estrutura de MDD para armazenamento do RSS já demonstrou ser claramente viável e vantajosa.
Ferramentas SPN, que utilizam métodos baseados em estruturas de dados de tamanho proporcional ao espaço de estados, são capazes de representar modelos entre no máximo 104 e 106 número de estados.
O método baseado em MDD, demonstrou ser capaz de representar modelos com grandeza de 9.18 × 10626 e acredita- se que modelos ainda maiores são possíveis de ser representados.
O algoritmo aqui proposto para o formalismo de SAN demonstrou através de exemplos de modelagens ser igualmente viável.
Testes apresentados no Capítulo 4 demonstraram que o consumo de memória nal é bem inferior para modelos que possuem PSS maiores que 104 e com um vasto número de estados inatingíveis.
De fato, a economia nal de memória para o exemplo dos Filósofos com PSS em torno de 1010 foi superior a 99% e para o modelo de compartilhamento de recursos com PSS de 106 cou em torno de 98%.
Além disso, a obtenção do RSS do modelo SAN sem necessitar da geração do espaço de estados produto bem como a denição da função de atingibilidade do modelo, também pode ser considerado uma melhoria para o tratamento computacional desse formalismo.
A técnica MDD exige apenas que um conjunto de estados iniciais seja informado a priori.
O fato da ferramenta PEPS requerer uma quantidade elevada de memória disponível durante a avaliação da solução estacionária do modelo (segunda etapa da execução de um modelo SAN no PEPS que avalia as probabilidades de permanência nos estados globais), e não durante a fase de geração do espaço de estados atingível do modelo, levou este trabalho a não avaliação formal do consumo de memória utilizado durante a execução do algoritmo.
Os testes aplicados aos exemplos de modelagem focaram apenas o consumo nal de memória, pois é deste que a segunda etapa do PEPS inicia.
Porém, notou- se que o pico de memória gasto durante a execução do algoritmo proposto (Algoritmo 2) pareceu ser elevado.
Primeiras análises apontam como causas desse problema a etapa de geração de estados condição e conseqüência deste algoritmo.
Além disso, a realização de reduções da estrutura de MDD apenas após o laço principal deve ser reavaliada como opção para a redução do uso de memória durante a geração.
Ambos temas constituem possibilidades de trabalhos futuros de pesquisa e que não foram aqui exploradas por tratar- se de melhorias que não interferem na formalização da corretude da técnica MDD aqui proposta.
A etapa de geração dos estados condições e conseqüências, apresentado por o Algoritmo 3 propõe o armazenamento a priori de todos os estados (Cd (e)) e (Cq (e)) para todos os eventos do modelo.
Uma possível otimização seria armazenar os eventos sincronizantes numa estrutura que identique em quais autômatos estes ocorrem, bem como seus estados origem.
Essas informações são necessárias para determinação do conjunto (Cd (e)) e (Cq (e)) a posteriori.
Além disso, outra estrutura com as informações topológicas do modelo SAN, por exemplo número de autômatos, eventos locais, número de estados faz- se necessário.
De essa forma, durante a exploração do espaço atingível do modelo, ambas estruturas permitirão a geração dos conjuntos condição e conseqüência durante a análise, remediando assim o consumo excessivo de memória requerido por o seu atual armazenamento a priori.
A redução de nodos repetidos na estrutura de MDD, apresentado por o Algoritmo 2 também pode ser reavaliada visando melhorias de performance.
Uma idéia seria realizar ciclos de reduções durante o laço principal deste algoritmo, a m de vericar se o pico de memória diminuiria.
De fato, o modelo MDD para SPN explora tal premissa.
Todavia, a adição dos passos de redução no laço principal do Algoritmo 2, deve cuidadosamente avaliar se o ganho de memória comparado ao aumento do consumo de CPU será válido ou não.
A real eciência do algoritmo aqui proposto, com relação a quesitos de performance, não pode ainda ser avaliada completamente, pois a implementação de todas as funcionalidades formalmente propostas por o algoritmo ainda não estão disponíveis.
Especicamente, o tratamento direto de funções (taxas funcionais) proposto por o Algoritmo 3 ainda não foi implementado.
Os exemplos aqui apresentado com taxas funcionais, foram tratados de forma implícita, através da utilização da técnica de conversão dos autômatos com taxas funcionais para autômatos correspondentes sem o uso de taxas funcionais.
Cabe salientar que esta primeira versão do algoritmo tem como objetivo provar sua viabilidade e corretude de uso para o formalismo SAN, e tais prerrogativas foram comprovadas através dos exemplos de modelagens testados através do protótipo implementado.
O critério de ordem em que os autômatos são dispostos na estrutura de MDD é também um fator importante para otimização desta.
Este foi exercitado através de exemplos de modelagens apresentados no Capítulo 6.
Constatou- se que os autômatos que possuem interdependência entre si, como transições sincronizantes e taxas funcionais, devem ser dispostos o mais próximo possível nos níveis da estrutura de MDD, a m de representar- se o espaço de estados atingível de uma maneira mais compacta.
A complexidade do algoritmo proposto foi cuidadosamente avaliada e demonstrou que o tempo de execução deste está quadraticamente associado a duas importantes variáveis do sistema, que são tamanho do autômato e número total de eventos do modelo.
Através da Notação de maior grandeza O, provou- se que em caso o número de eventos e número de autômatos dobrar, o tempo de execução do algoritmo cará no máximo 16 vezes maior.
De entre demais tópicos de interesse, igualmente válidos a serem aprofundados, porém considerados melhorias a longo prazo, pode- se citar a integração do algoritmo proposto na ferramenta PEPS.
Todavia, seria interessante que as melhorias aqui elencadas sejam primeiramente integradas no protótipo existente do algoritmo.
Conseqüentemente, a proposta de inclusão do mesmo na ferramenta PEPS daria- se apenas após esta etapa de melhorias e consolidação da versão independente.
Conforme ressaltado, muito ainda precisa ser feito, mas acredita- se que esse estudo inicial seja uma promissora fonte de informação a respeito de técnicas de otimização do espaço de estados atingível para o formalismo de SAN, que quando consolidadas trarão inquestionáveis benefícios a implementação de realidades complexas utilizando- se o formalismo de SAN.
