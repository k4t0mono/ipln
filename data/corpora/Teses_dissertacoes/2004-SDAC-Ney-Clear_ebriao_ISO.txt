A reconfiguração de hardware apresenta- se como uma tecnologia promissora para aumentar a flexibilidade e o poder computacional de sistemas digitais complexos.
Já existem no mercado dispositivos comerciais de alta complexidade que habilitam a reconfiguração de hardware de forma dinâmica e parcial, ou seja, dispositivos VLSI cujo hardware pode ser parcialmente alterado em tempo de execução, enquanto o restante do dispositivo continua a operar normalmente.
Contudo, existe uma série de carências, sobretudo em ferramentas e fluxos de projeto, que inviabilizam hoje a utilização de reconfiguração parcial e dinâmica de dispositivos de hardware em larga escala.
A alteração de dispositivos reconfiguráveis pode ser dividida em duas classes principais:
Alterações incrementais, onde a lógica, as interfaces de entrada/ saída ou o roteamento de uma pequena porção do dispositivo é mudada, e a inserção e/ ou remoção dinâmica de módulos complexos, onde blocos inteiros de lógica e roteamento são alterados ou susbtituídos.
A primeira classe de alterações e considerada tecnologia dominada, sendo útil em aplicações restritas.
A segunda é mais complexa, de aplicação mais ampla e carece de suporte adequado.
A principal contribuição deste trabalho é a proposta de parte de uma infra-estrutura de suporte para o projeto e implementação de sistemas digitais reconfiguráveis complexos sobre dispositivos comerciais, Especificamente, propõe- se e implementa- se um método de geração de arquivos de configuração parciais que correspondem à implementação física de núcleos de propriedade intelectual arbitrariamente complexos.
A geração e realizada de tal forma a habilitar que estes núcleos possam ser inseridos ou removidos de um dispositivo reconfiguravel em tempo de execução, através de procedimentos mecânicos de reconfiguração parcial e dinamica.
O método foi desenvolvido a partir de adaptação e extensão de técnicas propostas por um fornecedor de dispositivos reconfiguráveis.
Como contribuição adicional, foi proposta e implementada uma ferramenta de software para automatizar parcialmente o complexo processo de aplicação do método, aumentando o nível de abstração em que um projetista de um sistema reconfigurãvel atua.
Um conjunto de estudos de caso de implementação de sistemas reconfiguráveis foi empregado para validar o método e seu emprego.
Palavras-chave: Reconfiguração parcial e dinâmica, Projeto Modular, Infra-estrutura de reconfiguração, interfaces de comunicação padronizadas, sistemas digitais reconfiguráveis, nú cleos de propriedade intelectual, reuso.
Durante o desenvolvimento e a execução de funções computacionais por um determinado sistema, deseja- se sempre alcançar o maximo desempenho das mesmas ao menor custo final.
Porém, a tarefa de atingir tais objetivos é complexa.
O custo final depende de características tais como:
Area de silício do projeto, potência dissipada por o sistema e tempo de projeto (custos de engenharia não recorrentes, em inglês NRE costs -- Non-Recurring Engineering costa).
A diminuição de todas estas figuras de mérito confiita diretamente com o desempenho do sistema.
Para diminuir o custo final de um sistema, o mais importante atualmente, é diminuir o tempo de projeto, embora outras figuras contribuam em maior ou menor grau, de acordo com o sistema e/ ou area de aplicação específica.
A dificuldade de reduzir tempo de projeto pode ser atenuada através de técnicas de reuso de projeto.
Para a obtenção de reuso, módulos devem ser genéricos.
Porém a generalidade seguidas vezes implica perda de desempenho para realizar tarefas específicas.
Duas formas de se obter generalidade são através de sistemas programáveis e sistemas reconfiguráveis.
Os primeiros possuem a propriedade de executar software (características dos GPPS (General PWFPOSE Proeessors), e os últimos alcançam generalidade ao permitir que o hardware seja alterado de forma dinâmica, apresentando a propriedade de reconfígurabilidade.
Um sistema que não possua nenhuma destas propriedades pode apresentar o maximo desempenho na execução de uma tarefa como no caso de ASICs (Application-Specific Integrated Circuits).
Por outro lado, é possível conceber sistemas mistos, ao mesmo tempo programáveis e reconfiguráveis.
Naturalmente estes levam a um grau de fiexibilidade maximo.
Exemplo de um tal sistema é descrito no Capítulo 6.
Alguns pesquisadores sugerem que sistemas reconfiguráveis podem apresentar uma série de vantagens sobre sistemas com estas características.
Segundo Hauck[ HAUQSL a computação reconfigurãvel possui potencial para se tornar um paradigma de propósito geral para o desenvolvimento de sistemas computacionais.
Um exemplo de tal paradigma hoje é aquele em que se emprega um microprocessador ou microcontrolador associado a software.
Hauck tambem afirma que a flexibilidade de poder inserir novas funções não apenas por a reprogramação de software, mas também por a reconfiguração do hardware pode resultar em maiores graus de flexibilidade para sistemas.
Shirazi Estimam que o uso da reconfigurabilidade pode constituir- se num paradigma intermediário entre ASICs e sistemas microprocessados, apresentando mais flexibilidade que os primeiros e mais desempenho que os últimos.
Segundo Vissers, a analise e a exploração de técnicas de reconfiguração dinâmica devem prover um grande passo no sentido de viabilizar plataformas de computação reconfigurável.
Ainda segundo este autor, esta viabilização se dá porque tais plataformas permitem atender a compromissos de espaço e tempo sem a necessidade de reescrever e/ ou ressintetizar algoritmos.
Um exemplo de dispositivos configuraveis/ reconfiguráveis são os FPGAs.
FPGAs (F zeldProgrammable Gate Array/s) são circuitos integrados compostos fundamentalmente por uma matriz de elementos lógicos configuraveis, interconexão configurável entre estes e blocos de entrada e saída configuráveis.
FPGAs podem ter parte de seu hardware especializado para executar funções específicas com alto desempenho (característica de ASICs).
O comportamento dos módulos funcionais num FPGA pode também ser alterado em diferentes momentos, dependendo da necessidade (característica de GPPs).
Memórias, FPGAs e microprocessadores são os três principais tipos de circuitos integrados de alto volume de produção usados como geradores de demanda de avanços tecnológicos em microeletrônica.
O crescente avanço da tecnologia de implementação dos circuitos integrados (Cls) permite o desenvolvimento de dispositivos cada vez mais densos.
Esta tecnologia de implementação viabiliza a construção de sistemas computacionais complexos integrados num único Cl o que é conhecido como SoC (System-on-Chip).
SoCs podem ser desenvolvidos combinando módulos tais como FPGAs, ASICs e GPPs num único Ci.
Um SoC é composto por um ou mais processadores, memórias, módulos dedicados de hardware para realização de funções específicas, módulos de software e mesmo sub-sistemas micro-eletromecãnicos, sub-sistemas ópticos e outros.
Diversos setores da indústria aproveitam o potencial da combinação de tais tecnologias heterogêneas no mesmo Ci.
Além de a heterogeneidade, outros fatores justificam o interesse por SoCs.
Entre estes, pode- se citar a redução do tamanho final do produto, a redução de potência dissipada, o aumento de desempenho potencial e a segurança de projeto.
A Figura um SoC, conforme considerado neste trabalho.
O modelo de SoC usado aqui pressupõe estes compostos basicamente por núcleos de propriedade intelectual (denominados aqui núcleos IP, IPs, ou simplesmente núcleos Núcleos IP são módulos de hardware complexos pre-caracterizados e pré-validados.
Estes devem ser reaproveitáveis, tornando viável desenvolver SoCs em tempo reduzido, gerando produtos que podem levar menos tempo para chegar ao mercado.
SoCs podem receber denominações alternativas quando implementados sobre FPGAs.
Termos como SoPC (System-on--Programmable Chip), SoRC (System-on--Reconjígurable Chip) e RSoC (Reconfígurable System-an-Chip) aparecem em abundância em publicações técnicas.
Um dos principais problemas enfrentados durante o projeto de SoCs é a definição de como seus IPs componentes se comunicam, Projetistas têm tradicionalmente adotado a abordagem de interconectar núcleos IP através de arquiteturas de barramento padronizadas[ BEROO, RIN99].
Porém, o uso destas pode limitar o reuso de IPs, pois estes devem possuir interface específica para a arquitetura de barramento escolhida.
Se núcleos IP são construídos com interface específica, dificilmente podem ser empregados no contexto de outras arquiteturas de barramento sem modificações, ou mesmo em ambientes onde a comunicação não emprega barramentos.
Outras limitações impostas por barramentos são a baixa escalabilidade e a seqüencialidade de acesso ao recurso de comunicação.
Uma abordagem alternativa de padronizar a comunicação é desenvolver núcleos com uma interface padrão, que não dependam do meio de interconexão escolhido.
Este pode ser uma arquitetura de barramento, padronizada ou não, ou mesmo uma interconexão mais complexa, tal como uma rede intra-chip[ ZEFOS, MOR03a].
Isto auxilia o projetista no desenvolvimento do seu núcleo, já que o mesmo pode concentrar- se no projeto do IP, e não na forma como este interage com o restante do sistema.
Em este caso, não é necessario dominar o protocolo de comunicação específico utilizado, nem os sinais que compõem a interface de cada núcleo que Venha a ser utilizado no projeto.
Tal abordagem e viabilizada, por exemplo, por a utilização de padrões tais como OCP (Open Core Protocol).
Quanto a adaptabilidade, quanto mais um núcleo é flexível e parametrizavel, mais este e reusável, porém menos otimizada cada uma de suas instâncias específicas o sera.
Existe um compromisso entre reusabilidade e otimalidade de núcleos, segundo criterios tais como area, consumo de potência e velocidade.
Um núcleo pode tornar- se um produto de sucesso se alcançar um bom compromisso entre flexibilidade e desempenho.
Quando se emprega reconfiguração, a dificuldade de se obter o compromisso ótimo entre otimalidade e reusabilidade pode ser reduzida.
Isto ocorre, pois um núcleo IP ao invés de ser parametrizavel, pode ser gerado em diversas versões.
Para cada utilização deste IP se escolhe a versão mais adequada, Ou seja, no contexto de SoCs, reconfiguração insere um grau de liberdade a mais no projeto e no uso deste.
Isto tende a melhorar a adaptabilidade do hardware ao cenario de uso, que pode assim, mesmo para uma aplicação específica, mudar dinamicamente, fazendo o SoC adaptarse a este novo cenario.
Conforme colocado anteriormente, reconfiguração dinamica e parcial de hardware é uma tecnologia com potencial para se tornar amplamente utilizada.
Esta em si é uma das principais motivações deste trabalho.
Para poder contribuir neste sentido, e necessario dominar a tecnologia de modelagem, projeto, validação e implementação de SDRs o que se apresenta como a segunda motivação do trabalho.
Um dos motivos por os quais SDRS podem se tornar mais amplamente utilizados é o fato de introduzirem graus de liberdade adicionais no projeto de sistemas computacionais.
Estes graus surgem a partir de a possibilidade de desenvolver sistemas cujo comportamento do hardware pode ser alterado dinamicamente, de forma similar ao que ocorre com software em sistemas programáveis.
A reconfigurabilidade pode contribuir para a economia de recursos.
Quando uma dada tarefa pode ser quebrada em várias fases, uma configuração diferente pode ser carregada para cada fase seqüencialmente operando de forma análoga a memória virtual em sistemas operacionais.
De essa forma, o tamanho do sistema pode ser menor que o necessário para implementar uma funcionalidade total, o que implica redução de custos e redução de area do dispositivo.
Assim, uma outra motivação para o presente trabalho é disponibilizar dados quantitativos sobre compromissos espaço-temporais na implementação de sistemas reconfiguráveis e sistemas programáveis.
Um exemplo de emprego de reconfigurabilidade ocorre em aplicações espaciais.
Alterações indesejadas na funcionalidade dispositivos eletrônicos no ambiente hostil do espaço provenientes de radiação podem acarretar erros severos na funcionalidade de tais dispositivos.
Reconfigurabilidade pode ser usada, por exemplo, para corrigir erros no circuito e tornas- lo tolerante a falhas Existem casos em que circuitos implementados em areas de silício danificadas por radiação são substituídos por equivalentes em outra área de um dispositivo.
Pode- se elaborar módulos de teste que verificam determinados circuitos e, se estes estão danificados, reconfiguram o FPGA.
Outras motivações são a economia de area numa aplicação espacial e atualizações remotas feitas no hardware que implementa uma aplicação espacial realizadas por a reconfiguração.
Fabricantes como a Xilinx e a Actel provêem FPGAs que podem ser usados em aplicações espaciais.
A os compromissos espaço-temporais citados antes, pode- se acrescentar como motivação a capacidade de SDRs em particular melhorarem a característica de tolerância a falhas de sistemas computacionais e, em geral, aumentarem a flexibilidade dos mesmos.
O objetivo principal deste trabalho é propôr parte de uma infra-estrutura de reconfiguração para desenvolvimento de sistemas dinamicamente e parcialmente reconfiguráveis usando interfaces de comunicação padronizadas.
Em particular buscou- se produzir um método completo de geração de arquivos de configuração parciais e demonstrar seu efetivo funcionamento em aplicações praticas.
Esta parte da infra-estrutura de reconfiguração habilita hoje o grupo local de pesquisa (GAPH -- Grupo de Apoio ao Projeto de Hardware) que sediou este trabalho a implementar sistemas parcial e dinamicamente reconfigurãveis.
Como objetivo secundário, é proposta e implementada uma ferramenta para incrementar a automatização do fluxo de projeto para desenvolvimento de sistemas dinamicamente reconfiguráveis.
O restante do presente volume está dividido em 6 capítulos.
De terminologia, uma avaliação sucinta de trabalhos anteriores em SDRs, uma discussão das formas de reconfiguração habilitadas por sistemas atuais e uma revisão de software de suporte proposto para reconfiguração parcial de sistemas.
Finalmente, o Capítulo 7 apresenta algumas conclusões e direções para trabalhos futuros.
Estado da Arte em SDRs Este Capítulo tem como objetivo situar o leitor no que se refere ao estado-da-arte em SDRs, requisitos para habilitar o projeto e a implementação de SDRs, e ferramentas para geração de arquivos de configuração para o desenvolvimento de SDRs.
Sistemas reconfigurãveis combinam o desempenho de hardware dedicado a graus de flexibilidade similares a componentes de software.
Sistemas programáveis estão limitados à arquitetura do microprocessador utilizado.
O uso de hardware reconfigurãvel permite adaptar arquiteturas as aplicações.
Para isto, funções de hardware podem ter suas características modificadas.
Para tanto, é necessário realizar configuração ou reoonfiguração, total ou parcial, Uma configuração num dispositivo ou sistema de hardware configurável é um conjunto de bits que deve ser carregado em posições de uma memória de controle para determinar as funções e a estrutura de hardware que se quer construir.
O termo configuração também pode ser usado para definir o processo descrito na última frase.
A configurabilidade pode ser vantajosa, pois o hardware pode ser alterado sem a necessidade de desenvolver um outro dispositivo que atende estas novas características.
Reconfiguração é o processo de alterar uma dada configuração de forma total ou parcial, mudando assim as funções desempenhadas por a estrutura do hardware.
De essa forma, a reconfiguração total é uma configuração onde a memória de controle do dispositivo reconfiguravel é inteiramente sobrescrita.
Reconfigaração parcial como o próprio nome diz, é o processo de configuração onde a memória de controle do dispositivo é alterada apenas parcialmente.
Segundo Sanchez, reconfigurações podem ser dinâmicas ou estáticas.
Se o sistema não necessita ter seu processamento interrompido (sem disrupção) para que uma reconfiguração seja realizada então ele é dito dinâmico, caso contrário, é dito estático.
Pode- se ainda classificar dispositivos reconfiguráveis de acordo com o tamanho do grão configurável, Entende- se por grão a menor unidade configurável de um dispositivo.
Modernamente, se as configurações se dão no nível de portas lógicas ou funções simples booleanas de poucas variaveis diz- se que o dispositivo e de grão pequeno.
Se estas se dão sobre unidades funcionais maiores, tais como ULAs, diz- se que o dispositivo possui grão médio.
Quando estas se dão em unidades de porte considerável, tais como um microprocessador, diz- se que o dispositivo e de grão grande.
Estrin, em trabalho publicado nos anos 60, propôs conceitos hoje considerados como precursores de sistemas de hardware reconfigurável.
O sistema de Estrin chamado Sistema Computador Reestruturável (Restructurable Computer System) baseia- se num repertório de funções armazenadas em hardware.
Se o programa a executar necessita uma determinada função, e esta se encontra no repertório, então a função é executada em hardware, aumentando o desempenho desta em relação a a mesma implementada em instruções nativas.
O sistema de Estrin é dividido basicamente em três partes:
Processador Central (Central Processor):
Este e um processador de propósito geral, o qual executa programas convencionais.
A implementação realizada usou o computador* Unidade Supervisora de Controle (Supervisory Control Unit):
Esta unidade faz análise de instruções que estão sendo executadas no processador central.
Se um determinado conjunto de instruções resulta num algoritmo &quot;Conhecido «por a unidade de controle supervisora, então este conjunto é executado por o Inventário de Estrutura Variável.
Inventário de Estrutura Variável (Variable Structure Inventory).
Este é um repertório de funções implementadas em hardware que se encontra comumente em algoritmos para resolução de diversos problemas matemáticos que consomem muito tempo de execução.
As seqüências de instruções equivalentes executadas no Inventário de Estrutura Variável têm melhor desempenho do que estas instruções executadas no processador central.
Quando uma instrução é executada nesta unidade, o processador central pode estar executando o seu fluxo normal em paralelo, obtendo ganhos de desempenho no que diz respeito ao processamento de dados.
Para modificar uma determinada função no Inventário de Estrutura Variável, é necessário habilitar um conjunto de transistores ou mudanças físicas na localização dos módulos (funções implementadas em hardware) e suas interconexões.
Para a construção de uma função razoalvelmente complexa, era necessário um esforço considerável para implementação da mesma.
Este foi um trabalho isolado.
Somente cerca de vinte anos mais tarde, surgiram os primeiros dispositivos configuraveis comerciais.
SDRs podem ser classificados, de acordo com o número de dispositivos que os compõe, em duas grandes classes:
Sistemas reconfiguráveis em nível de circuito integrado e sistemas reconfiguráveis em nível de placa.
Estes sistemas são discutidos nas próximas seções.
Em o escopo deste trabalho aborda- se apenas a reconfiguração em nível de circuito integrado usando como base o FPGA Virtex II da Xilinx.
Este tipo de reconfiguração parcial acontece sobre áreas de silício de um Ci.
A unidade fundamental para a reconiiguração parcial neste nível pode ser constituida por LUTs (alguns FPGAs são constituídos por esta unidade de reconfiguração).
FPGAs são por excelência sistemas deste tipo.
Entre estes, pode- se citar as famílias Xilinx XC6200, ATMEL AT40K e Xilinx Virtex Um exemplo de FPGAs que permite a técnica de reconfiguração parcial e o FPGA XC6200 da Xilinx.
Consiste numa matriz de 64 x 64 células rodeada por portas de entrada e saída.
Todas as celulas lógicas podem implementar qualquer função lógica combinacional de duas entradas.
Cada celula pode implementar um flip-flop do tipo D com o objetivo de implementar a função combinacional da célula.
As células têm um esquema de hierarquia de barramento.
Células são organizadas dentro de blocos de 4 x 4, 16 x 16, etc..
Um conjunto de barramentos rápidos estão associados ao tamanho do bloco.
Todos os registradores que estão contidos dentro de algum bloco podem ser acessados por uma interface de usuario.
Registradores são endereçados através de colunas via registrador de mapeamento.
A reconfiguração é parcial e dinamica realizada através de controle de armazenamento SRAM de seis transistores estáveis.
Esta memória SRAM pode ser mapeada dentro de um espaço de endereçamento de um processador hospedeiro e suporte lógico adicional é provido para permitir reconfiguração para todas as partes do dispositivo.
O FPGA XC6200 suporta hardware virtual em as quais os circuitos em execução podem ser armazenados.
Isto permite que recursos do FPGA podem ser utilizados por tarefas diferentes, e então os circuitos são restaurados num dado momento, com o mesmo estado interno dos seus registradores.
A Figura 2.1 mostra uma estrutura de interconexão entre as células que compõe o FPGA.
Os FPGAs da família AT40K da At Mel foram projetados para suportarem reconfiguração parcial e dinâmica.
Porém esta família de FPGAs da ATMEL suportam um máximo de 50 mil portas lógicas para implementação de projetos reconfiguráveis, ou seja, o tamanho do FPGA é pequeno comparado com o estado da arte em FPGAs de alta densidade, que excedem este valor de pelo menos duas ordens de grandeza.
Este FPGA utiliza uma memória de configuração para armazenamento do contexto.
Se novas funções são necessarias para a execução da aplicação, as porções antigas são sobrescritas conforme mostrado na Figura 2.2.
Mais recentemente, a Xilinx desenvolveu os FPGAs da família Virteac, Virtez II e Vírtez II Para o.
A memória de configuração da Virtex pode ser vista como uma matriz bidimensional de bits.
Estes bits são agrupados em quadros verticais de 1 bit de largura, e se estendem do topo a base do dispositivo.
Um quadro é a unidade mínima de configuração, ou seja, e a menor porção de memória de configuração que pode ser lida ou escrita.
Quadros são lidos e escritos seqüencialmente, com endereços crescentes para cada operação.
Como os quadros podem ser lidos e escritos individualmente, é possível reconfigurar parcialmente esses dispositivos através da modificação desses quadros no arquivo de configuração.
Além disso, a disposição regular de elementos configuráveis permite, em teoria, relocação e desfragmentação de módulos, que têm importância no que se refere no assunto de reconfiguração parcial e dinamica.
Os elementos configuraveis são CLBs (Configurable Logic Block), BRAMs, roteamento e multiplicadores.
A Figura 2.3 mostra um CLB do FPGA Virtex XCV300.
Em esta Figura, nota- se que cada CLB contém duas fatias (slices), que por sua vez contém duas LUTs cada, alem dos recursos de Carry e dois fiip-- flops.
Virtex, veja.
64 quadros_ l¡.
Uma das famílias mais recentes dos FPGAs da Xilmz é a Virtez II.
Os FPGAs desta família.
Permitem desenvolver circuitos de 500\&gt; 103 a 10000\&gt; 103 portas lógicas.
Em a Figura 2.5 pode- se ver que os IOBs programáveis fornecem uma interface entre os pinos externos e a lógica interna configurável.
Essa lógica interna inclui quatro elementos principais, os quais são organizados numa matriz regular:
Os CLBs fornecem elementos funcionais para lógicas combinacionais e síncronas, incluindo elementos básicos de armazenamento, Bujffers tri-states (TBUFs) são associados a cada CLB e dedicados diretamente a recursos de roteamento horizontal que podem ser segmentados.
Módulos de memória, chamados Block SelectRAM, fornecem elementos de armazena mento de 18 Kbits com verdadeiras RAMs de porta dupla.
Blocos Multiplicadores, compostos por multiplicadores de 18-bits x 18-bits.
Gerenciador de Clock Digital (DCM), módulos responsáveis por o sincronismo de relógio, com possibilidade de multiplicação e divisão de freqüência do relógio, e mudança de fase.
Todos os elementos programáveis, incluindo os recursos de roteamento, são controlados por valores armazenados em celulas de memória estática.
Esses valores são carregados em células de memórias durante a configuração e podem ser recarregados a qualquer momento para modificar a funcionalidade do elemento programável.
Como_ já foi citado, os IOBs são programáveis.
Eles podem ser vistos como um bloco de entrada com um registrador opcional, um bloco de saída com um registrador, um buffer tri-state, ou um bloco biclirecional com qualquer combinação de configurações de entradas e saídas.
Os IOBs são fornecidos no perímetro de cada dispositivo em grupos de dois ou de quatro.
Os blocos lógicos configuraveis (CLBs) da família Virtez II são compostos por quatro slices (ou fatias) e dois buffers trrstates.
Cada um dos slices são equivalentes e são compostos por dois geradores de funções (denominados de F e G) de quatro entradas, dois elementos de armazenamento e multiplexadores.
Tais geradores podem ser configurados como Look-UpTables (LUTs) de quatro entradas capazes de implementar qualquer função combinacional de quatro entradas, registradores de deslocamento de 16 bits ou memória SelectRAM de 16 bits.
Os multiplexadores que fazem parte de um slice e os geradores de funções na Vírtez II podem ser implementados como:
Multiplexador 4:1 num slice, multiplexador 8:1 em dois slices, multiplexador 16:1 num CLB (4 slices) e multiplexador 32:1 em CLBs.
Cada CLB contem dois dispositivos tri-state, cada um com seu próprio pino de controle e seu próprio pino de entrada, Cada um dos quatro slices tem acesso a dois tri-states através de conexões diretas.
A saída do tri-state é dirigida para recursos de roteamento horizontais usados para implementar barramentos tri-state.
Cada dispositivo Virtez II incorpora uma quantidade de blocos de memória SelectRAM de 18 Kbits, as quais são programáveis desde 16Kx1 bit até 512x36 bits, em varias larguras 14 Capítulo 2: Estado da Arte em SDRs e profundidades.
As SelectRAMs são de porta dupla, possuindo duas portas com clocks e controles síncronos independentes, as quais acessam uma área de armazenamento comum.
Os FPGAS da família Virtex II-Pro constituem uma extensão da família Virtex II.
A novidade desta família é conter processadores IBM PowerPC 405 embarcados.
Segundo os fabricantes, pela primeira vez os projetistas podem particionar e reparticionar seus sistemas entre hardware e software durante o ciclo de desenvolvimento de uma maneira mais fiexível, ou seja, não apenas no início do projeto.
O maior dispositivo desta família possui quatro processadores PowerPC embarcados.
Este tipo de reconfiguração é realizada em sistemas reconfiguráveis implementados sobre uma ou mais placas de circuito impresso contendo varios componentes como processadores, memórias, UARTs, barramentos e até mesmo vários FPGAs.
Tais sistemas podem ser caracterizados como grão fino, médio e grosso, inclusive pode haver casos em que estes sistemas reconfiguráveis utilizam FPGAs como unidades fundamentais de reconfiguração.
A seguir, serão mostrados alguns exemplos de arquiteturas reconfiguráveis que têm como característica a reconfiguração parcial em nivel de placa.
Splash 2.
O Splash 2 é uma arquitetura reconfigurável baseada em FPGAs.
Essa é constituída por 17 FPGAs 4010 da Xilinx, cada um acoplado a blocos de 512 Kb de memória e um hospedeiro SparcStation.
Dezesseis desses FPGAs são conectados num vetor, e também a uma rede crossbar que introduz uma flexibilidade maior que se fosse tratado como uma matriz linear.
O décimo sétimo FPGA é conectado a rede crossbar e se comporta como um hardware de distribuição dos dados que recebe do barramento SIMD (Single Instructíon Multiple Data).
Existe também uma interface de conexão ao hospedeiro (Interface Board) que contém um relógio de sistema programável e provê acesso ao DMA para a memória do hospedeiro atraves de dois FPGAs (XL e XR), os quais são usados para enviar e receber dados do hospedeiro ao Splash 2.
Um sistema de interconexão é usado para prover o acesso aos Splash 2 a interface de conexão ao hospedeiro.
A placa Splash2 é ligada ao resto do sistema por cinco barramentos.
Alem do barramento SIMD, usado para transferir dados do computador hospedeiro a placa, existem dois barramentos de extensão, um barramento da dados de saída e um barramento de configuração.
A arquitetura do SPLASH 2, bem como sua organização são mostradas na Figura 2.6.
Splash2 foi desenvolvido para incrementar certos aspectos do sistema Splash:
Escalabilidade, largura de banda para E/ S e programabilidade.
Tem conexões mais flexíveis que seu antecessor, apresenta rede crossbar.
Assim como seu antecessor, Splash2 sofre por a baixa velocidade de integração, mas tem a vantagem da reconfiguração parcial.
Esta propriedade é devida a possibilidade de reconfiguração da rede de interconexão, CHESS e uma arquitetura reconfigurável para aplicações multimídia, desenvolvidas no Hewlett Packard Laboratories em 1999.
A arquitetura do CHESS é constituída basicamente por um conjunto de ULAs (Unidade Lógica Aritmética) de 4 bits dispostas matricialmente e interconectadas (Figura 2.7).
Cada ULA utiliza como entrada dados provenientes da saída de uma outra ULA.
Bancos de memória externa podem ser conectados a arquitetura.
Um arranjo de 512 ULAs pode ser configurado num tempo de 40 ns.
CHESS oferece fiexibilidade no roteamento, escalabilidade e reconfiguração parcial/ dinâmica.
Amalgam A arquitetura Amalgam é um exemplo de arquitetura que utiliza FPGA como unidade mínima reconfiguravel.
Esta arquitetura foi desenvolvida na Universidade de Illinois em 2002.
Componentes como unidades de processamento programáveis e reconfiguráveis chamados clusters são integrados à arquitetura conectados a um barramento com um sistema de memória compartilhada.
A arquitetura Amalgam é constituída de quatro clusters programáveis (PClust) e quatro clusters reconfiguráveis (RClust) como mostrado na Figura 2.8.
Card). RClust é conectado a um banco de registradores, cada qual com portas de leitura e escrita, integrando os blocos lógicos, transparecendo ser um único sistema.
De acordo com Walstrom, cada RClust atua como um coprocessador para cada PClust.
O PClust contém um banco de dados de registradores, cache de instruções (I-Cache) e duas ULA's que executam um conjunto de instruções baseado no MIPS ISA.
Atualmente, existe uma carência no que diz respeito ao ferramenta] para desenvolvimento de sistemas dinamicamente reconfiguráveis.
Segundo McMillan, existem duas iniciativas que se destacam na tentativa de solucionar este problema.
A primeira de elas é provida por pesquisas acadêmicas, que propôe um conjunto de ferramentas de CAD baseada em JAVA que habilita o projeto e a implementação de sistemas dinamicamente reconfiguráveis, e ferramentas para modificação de bitstreams para implementar módulos de hardware reconfiguráveis.
A segunda iniciativa é provida por o setor industrial.
A equipe de desenvolvimento da empresa Xilinx (fabricante de FPGAs) disponibiliza tecnicas baseadas em fluxos de execução de ferramentas de síntese e implementação.
Além de isto, a equipe oferece classes em Java que provêem Apis (Application Programming Interface) para manipulação de arquivos de configuração (bitstream) do FPGA, de modo a tornas- los parcialmente reconfiguráveis.
Este método de reconfiguração baseado na técnica Small Bit Manipulation, descrita através da XAPP290, consiste em modificar apenas alguns quadros que constituem o FPGA.
A ideia central e gerar bitstreams parciais usando a diferença de um bitstream to tal e modificações feitas num arquivo que posteriormente e lido por a ferramenta geradora de bitstreams denominada BitGen.
A ferramenta de edição do FPGA (FPGA Editor) permite a modificação das funções contidas numa ou mais LUTs.
Dados de BRAMs (Block RAM) e pinos de I/ O também podem ser manipulados em nível de bits e modificados dinamicamente.
Isto é útil para aplicações reconfiguráveis que necessitam de pequenas alterações pontuais.
Porém esta técnica é extremamente penosa para desenvolvimento de arquivos de configuração que armazenam módulos de hardware.
Para a geração de bitstreams parciais que representam módulos inteiros de um dado projeto, a Xilinx recomenda o uso do fluxo do Projeto Modular apresentado no Capítulo 4.
Este método de reconfiguração consiste em reconfigurar parcialmente núcleos IP que podem ocupar os mais variados tamanhos no FPGA.
A Figura 2.10 mostra alguns núcleos IP conectados a uma interface de comunicação.
O objetivo é possibilitar que os núcleos IP possam ser inseridos e removidos (plug-and-play) dinamicamente sem afetar o resto do sistema.
A entrada para a execução deste método de reconfiguração é um sistema descrito em HDL, e a execução desse método gera arquivos de configurações totais e parciais, habilitando então a reconfiguração parcial e dinamica nesse sistema.
Porém existe uma carência de ferramentas para a execução de tal método.
Em a bibliografia, existem poucos fluxos e ferramentas para desenvolvimento de projetos dinamicamente reconfiguráveis.
Esses fluxos para habilitação da reconfiguração baseada em núcleos IP são descritos mais detalhadamente na Seção 3.1.
Como inconvenientes.
O uso de recursos adicionais do FPGA para prover comunicação entre os núcleos IP e problemas quanto a erros eventuais de roteamento do sistema, cujo usuario deve fazer o roteamento manualmente.
O presente trabalho enfoca a reconfiguração parcial em nível de Ci apenas.
Além de isto, pressupõe- se que o processo de reconfiguração é baseado em inserção/ remoção de IPs (Seção 2.3.2).
Para a realização de reconfiguração parcial em dispositivos reconfiguráveis, é possível iden tificar seis requisitos:
FPGAs que suportam reconfiguração parcial e dinâmica:
Atualmente dois fabricantes de FPGAs oferecem suporte para reconfiguração parcial e dinâmica:
Atmel e Xilinx.
Atmel produz os FPGAs das famílias AT40K e AT6000.
Estes FPGAs são inadequados para o desenvolvimento de SoCs, por causa de o seu tamanho reduzido em relação a o número de unidades fundamentais de reconfiguração (LUTs).
Por outro lado, os FPGAs da Xilinx disponibilizam as famílias Virtex, Virtex-II e Virtex-II Para o.
A unidade atômica de reconfiguração se chama quadro.
Este compreende numa seção vertical que se extende por todo o FPGA.
Um núcleo IP é fisicamente implementado nestes dispositivos da Xilinx como um conjunto de quadros consecutivos;
Ferramentas para determinar a forma e a posição do núcleo IP:
Restrições de posicionamento devem ser inseridas durante o projeto de SDRs para a definição do tamanho, formato e posição dos núcleos IP reconfiguráveis.
Ex: Floorplanner da Xilinx;
Suporte para geração de arquivos de reconfiguração parciais e configuração destes no FPGA:
Protocolos de reconfiguração parcial e total são distintos.
Características especiais devem estar presentes nas ferramentas e dispositivos usados para reconfigurar parcialmente os FPGAs;
Interface de Comunicação entre Núcleos IPs:
Em um projeto de SoC convencional, arquiteturas de barramento intra-chip padronizadas, tais como AMBA e CoreConnect podem ser usadas para prover comunicação entre os núcleos IPs.
Entretanto, estas arquiteturas não apresentarem características necessárias em SDRs, como isolamento de núcleos IPs durante a reconfiguração.
Para habilitar a inserção e remoção dinâmica de núcleos IPs dentro de o FPGA em operação, uma interface de comunicação para conexão e isolamento de núcleos em momentos distintos deve ser usada.
Esta interface deve prover funções diversas tais como arbitragem, comunicação entre módulos, virtualização dos pinos de entrada e saída e controle de configuração;
Virtualização dos pinos de entrada e saida:
Este conceito permite troca de dados entre o núcleo IP reconfiguravel e o meio externo sem alteração das características de pinagem do Ci;
Controle de reconfiguração dinâmica:
Métodos para controle ou execução do processo de reconfiguração dinâmica são um requisito imprescindível.
Estes métodos podem ser implementados em hardware, software ou ambos.
A geração de arquivos de configuração parciais apresenta- se como uma tarefa crucial para o desenvolvimento de SDRs.
Os fabricantes fornecem junto com seus dispositivos ambientes de CAD para desenvolvimento de sistemas que contem, muitas vezes, diversas ferramentas.
De entre estas, algumas se dedicam ã geração de arquivos de configuração parciais.
O fluxo de geração de arquivos parciais com ferramentas fornecidas por os fabricantes deve ser realizado, ainda hoje de forma manual.
Por isso, trata- se de um processo demorado e complexo, passível de erros, para projetos que necessitam de diversas configurações parciais.
Necessita- se, portanto, de ferramentas mais autornatizadas para o projeto de sistemas reconfiguráveis.
Em esta Seção, apresentam- se algumas ferramentas que tem por objetivo auxiliar projetistas na tarefa de gerar arquivos de configuração parciais.
JBits é um conjunto de classes Java que fornecem uma API que permite manipular o arquivo de configuração das famílias de FPGAs Virtex e Virtex-E da Xilinx.
Esta interface opera tanto em arquivos de configuração gerados por as ferramentas de projeto da Xilinx quanto em arquivos de configuração lidos do hardware (Readback).
Para que este conjunto de classes possa dar suporte à reconfiguração parcial e dinâmica, 3a ferramenta deve ser rapida e prover informações físicas detalhadas a respeito de a arquitetura do hardware, bem como elementos arquiteturais reconfiguráveis do dispositivo a ser configurado.
Isto permite que os circuito seja reconfigurado sem a necessidade de se refazer o posicionamento e o roteamento com ferramentas convencionais oferecidas por os fabricantes de FPGAs.
A Figura 2.11 ilustra o fluxo de projeto do JBits.
Em este fluxo, um compilador de Java le o programa descrito por o usuario com as classes para acesso ao FPGA.
O compilador também lê dados da biblioteca do conjunto de classes JBits.
O compilador gera um código executável que fornece o controle de configuração e dados para a lógica de reconfiguração do dispositivo.
Em este fluxo de projeto, o arquivo executável gerado por o compilador Java é somente um componente arbitrário do código Java compilado, Este executável permite desenvolver aplicações em software para acessar a aplicação reconfiguravel no dispositivo.
A informação de controle ou de dados pode ser compartilhada entre o computador hospedeiro e o FPGA.
Finalmente, o módulo mostrado na Figura 2.12- e, utiliza uma biblioteca de núcleos IP (conjunto de classes em JAVA) que podem ser adicionados ou removidos do dispositivo.
As limitações desta API devem- se ao fato que todos os recursos e manipulação destes devem ser explicitados manualmente no codigdfonte.
Devido a a necessidade desta especificação detalhada de todos os recursos do FPGA no código-fonte do software, o conjunto de classes JBits pode favorecer circuitos mais estruturados.
Circuitos não-estruturados (lógica aleatória, por exemplo) não são bem adaptados para uso com o Jbits.
Outra limitação é que o usuario deve estar bem familiarizado com a arquitetura-alvo, pois sem o conhecimento devido dos detalhes arquiteturais do dispositivo, pode danificar o FPGA.
JRTR é uma extensão da API JBits.
Esta interface provê um modelo de cache onde as modificações dos dados referentes a configuração são ajustadas, e somente os dados realmente necessários são escritos no FPGA ou lidos de ele.
Esta extensão resultou no suporte direto a reconfiguração parcial.
Este suporte utiliza uma combinação de técnicas de hardware e programas que permitem pequenas modificações no arquivo de configuração das Virtex de maneira direta, rápida e sem interrupção de operação.
A interface JBits é ainda utilizada para leitura e escrita de arquivos de configuração.
O JRTR ainda tem um parser para analise do arquivo de configuração e além disso, mantém a imagem dos dados e informações de acesso.
Linha_ Inicial, Coluna_ Final e Linha_ Final.
A área hachurada representa o módulo que será armazenado no arquivo de configuração parcial.
Há dois modos de operação definidos por os parâmetros do usuário.
Estes são descritos a seguir:
Slice: Em este modo, o usuãrio especifica um slice contendo uma ou mais colunas de CLBs (quadros).
A ferramenta gera o arquivo de configuração parcial com estes quadros na mesma posição que estes estavam situados do arquivo de configuração original;
Bloco: Em este modo, é possível definir uma area (bloco) abrangendo os quadros que cons tituem uma ou mais CLBs.
O usuario define em que posição do arquivo de configuração alvo será gravado este bloco, A ferramenta gera arquivo de configuração parcial, a partir de o arquivo de configuração original, contendo a area selecionada por o usuario (bloco).
Logo a seguir, colunas de CLBs denominadas slices do arquivo de configuração original são copiadas para o arquivo de configuração parcial alvo.
Se os parâmetros deiineni o modo de operação como o modo bloco então é feita a cópia do bloco no arquivo de configuração parcial alvo.
Depois disto, então é gerado o fim do arquivo onde algumas operações, entre elas, o calculo do CRC (Cyclic Redundancy Check), são realizadas.
A mesma equipe de pesquisadores que desenvolveram o PARBIT propôs o conceito de Dynamic Hardware Plugins (DHP).
DHPs permitem que múltiplas aplicações de hardware, ou plugins, sejam dinamicamente carregadas num único dispositivo e executem em paralelo.
Em suina, esta técnica pode ser utilzada para o desenvolvimento e implementação de SDRs.
Um problema enfrentado na geração de arquivos de configuração parciais por o PARBIT é controlar o processo de roteamento.
Por isso, é importante notar, em, a existência de uma colaboração direta com a empresa Xilinx, que adotou uma ferramenta de roteamento para que esta aceite a imposição de restrições que viabilizem a reconfiguração parcial de maneira automatizada.
Segundo Raghavan, JPG é uma ferramenta utilizada dentro de o fluxo de projeto da Xilinx necessária para gerar arquivos de configuração parciais.
JPG foi desenvolvida em Java, baseada na API JBits.
Para a geração dos mesmos, deve- se ter pelo menos um projeto base (arquivo de configuração total).
A Figura 2.16 ilustra o fluxo de projeto do JPG, A primeira fase do processo de projeto é a partição do projeto base em módulos menores.
Restrições iniciais Mapeamento Ileraçáo (se necessário) Arquivo de smçóes quer) Delimção de piamammxa -- Ammvos NGD Eugen pava gerar 7 Poslcionamenlo e arquivo de conliguracão roteamento lolzl Arquivos com o e NGD cum arquivos XDL da Arquivo ds cunligurzção renamema NCDZXDF total Arquivos XDL.
A segunda fase do projeto objetiva criar versões diferentes dos módulos que serão usados para a reconfiguração parcial.
São geradas plantas-baixas para cada um dos módulos parciais para fixação destes no instante da reconfiguração do dispositivo.
Ferramentas são necessarias para o mapeamento, posicionamento e roteamento dos módulos utilizando arquivos de restrições.
Neste passo, podem vir a ser necessárias várias iterações para se obter os resultados desejados.
A seguir, arquivos mapeados com formato interno da Xilinx são traduzidos para um arquivo ASCII o qual contém informações de recursos que implementam o projeto.
Então a ferramenta JPG é usada neste ponto para a geração de arquivos de configuração parciais.
Esta técnica de geração de arquivos de configuração parciais estabelece uma ligação direta entre o sistema de desenvolvimento da Xilinx e JBits, facilitando a tarefa de geração de arquivos parciais, dependendo, portanto, da API fornecida por a.
Xilinx. De acordo com Raghavan estabelece uma ligação entre o fluxo de projeto da Xilinx e a ferramenta J Bits.
Esta afirmação permite que os projetistas usem o fluxo convencional de projeto da Xilinx obtendo vantagem em algumas características de baixo nível oferecidas por o JBits.
Não é necessário a programação em Java para o uso de JBits e o conhecimento de detalhes arquiteturais do dispositivo alvo.
A principal desvantagem desta ferramenta é que o sistema de CAD (Computer Aided Design) da Xilinx não automatiza totalmente o Huxo, resultando num maior esforço de desenvolvimento de projetos reconfiguráveis para o projetista.
Outra desvantagem é que o suporte de dispositivos desta técnica depende dos dispositivos que o conjunto das classes JBits suporta.
As ferramentas aqui documentadas têm por objetivo trabalhar com o arquivo final do projeto de hardware (bitstream), Segundo Mõller[ MÕLLOSL existem dois formatos para o arquivo de configuração do dispositivo reconfiguravel:
ASCII e binário.
O formato ASCII (também denominado Rawbits) é voltado para o melhor entendimento sobre as especificidades arquiteturais e informações de configuração, Por outro lado, o formato binário tem a vantagem de ser cerca de oito vezes menor que o arquivo de configuração em formado ASCII.
Algumas ferramentas elaboradas por Mõller são baseadas no pacote de Apis JBits e são descritas a seguir.
BitProgrammer Consiste num pacote de ferramentas desenvolvida para acessar bitstreams a partir de uma maquina local ou remota.
Estes bitstreams devem estar no formato binário e podem ser parciais ou totais.
As ferramentas permitem visualizar valores que dizem respeito a especificidades do bitstream, procurar valores diferentes dos padrões, modificar valores internos das LUTs, executar a carga remota de um bitstream e localizar LUTs com uma lógica específica.
BitProgrammer foi desenvolvido fazendo o uso das classes oferecidas por o JBits.
Circuit Customizer É um cliente adicional que usa o pacote de ferramentas BitProgmmmer.
A sua principal vantagem é executar funcionalidades em maior nível de abstração as ferramentas contidas no pacote mencionado.
De este modo, a ferramenta CircuitCustomizer permite especificar a localização dos sinais de um projeto de hardware para a posterior Visualização e alteração dos valores a partir de uma pagina Html.
Desta forma o usuario final não precisa saber LUTs específicas, CLBs ou posições onde os parametros foram fixados para alterar parâmetros do sistema.
BitAnalyzer. É uma ferramenta para analise de arquivos de configuração totais e parciais em ASCII.
O arquivo de configuração é mostrado detalhadamente por a ferramenta.
Em este programa, é 28 Capítulo 2: Estado da Arte em SDRs possível escolher uma parte do arquivo de configuração total e gerar um arquivo de configuração parcial partindo de um protocolo de geração de arquivos parciais.
Pode- se localizar um ou mais bits das LUTs do arquivo de configuração e alterar seus respectivos valores.
Core Unifier Partindo do endereçamento de elementos em FPGAs da família Virtez, em conjunto com o conhecimento adquirido no desenvolvimento das ferramentas descritas previamente, definiu- se a criação de um software para manipulação de núcleos IPs.
A Figura 2.17 apresenta uma tela da interface gráfica da ferramenta em questão.
Esta ferramenta possui as seguintes características:
Permite a leitura de informações de configurações diretamente do bitstream;
Possibilita a união entre áreas de dois bitstreams diferentes (desde que não sejam so brepostas), para geração de um terceiro arquivo de configuração;
A ferramenta possui uma interface grafica para seleção de áreas específicas do FPGA;
Gtamlnnm um:
Essas, entre outras ferramentas desenvolvidas no grupo, habilitam a manipulação de arquivos de configuração totais e parciais.
O conjunto desenvolvido por Mõller manipula apenas arquivos de configuração gerados para dispositivos da família Virtex da Xilinx.
Algumas ferramentas de suporte para reconfiguração parcial e dinâmica foram apresentadas nesta Seção.
A Tabela 2.1 apresenta um resumo das características presentes em cada uma das ferramentas de suporte a reconfiguração parcial e dinamica.
A maioria destas ferramentas foram desenvolvidas usando como base o conjunto de classes J Bits, pois este habilita a manipulação de arquivos de configuração das famílias de FPGAs Virtex e Virtex-E conforme mostrado na Subsseção 2.5.1.
Porém, com o advento de novas famílias de FPGAs da Xilinx, o conjunto de classes JBits deve ser modificado para que este possa acessar especificidades arquiteturais des as novas famílias de dispositivos.
Ou seja, tais ferramentas são amplamente dependentes do conjunto de classes JBits.
Por outro lado, as ferramentas que não fazem o uso de JBits, como por exemplo as ferramentas PARBIT, CoreUnzfier, BitAnalyser e outras, devem ser modificadas, ou até mesmo reescritas para poderem ter acesso e alteração do conteúdo de componentes arquiteturais de uma nova família de FPGAs da Xilinx, fator que limita a portabilidade destas ferramentas para outras tecnologias.
No entanto, existe um método para reconfiguração parcial baseada em núcleos, como o fluxo do Projeto Modular, que prove acesso a todas as famílias de FPGAs da Xilinx.
Esta característica permite que uma ferramenta desenvolvida usando tal fluxo não precise ser reescrita para cada família de FPGAs, e também não é necessário o conhecimento de toda a arquitetura do FPGA, pois este fluxo manipula arquivos de configuração total e parcial num maior nível de abstração.
O Capítulo 4 detalha o fluxo do Projeto Modular.
Reconfiguração Baseada em Núcleos e Interconexão de Núcleos Palma propôs um barramento para interconectar núcleos IP reconfiguráveis possibilitando o desenvolvimento de sistemas dinamicamente reconfiguráveis.
Este barramento faz parte de um módulo denominado controlador, e é uma porção de hardware fixo no FPGA.
O controlador é responsavel por a comunicação com o mundo externo (pinos de entrada/ saída do dispositivo) e por a comunicação com os núcleos IP.
O dispositivo reconfiguravel deve ser inicialmente carregado apenas com o controlador localizado numa posição fixa do dispositivo reconfiguravel.
Os núcleos de propriedade intelectual são carregados sob demanda.
A comunicação entre o controlador e os demais núcleos IP é feita através de pinos virtuais.
Estes pinos são implementados atraves de bujfers tristate, A idéia inicial era utilizar bufers na fronteira entre o controlador e o núcleo IP, responsaveis por a conexão entre os mesmos.
Estes bufers fariam parte tanto da descrição do controlador quando de a descrição do núcleo IP.
Palma mostrou que esta abordagem não seria factível de implementação.
Em o momento da inserção do núcleo IP, recursos adicionais de lógica de um dado CLB que faria interface com o mesmo seria destruído.
Então foi criada uma abordagem que utiliza duas camadas de bujjfers, uma camada pertencendo ao controlador e outra pertencendo ao núcleo IP, como mostra a Figura 3.1.
A conexão de núcleos IP ao controlador é feita por uma linha comum de roteamento.
O fluxo de desenvolvimento proposto sofre com o problema relacionado à falta de suporte para restringir o roteamento.
Através de um software para visualização de elementos roteados e posicionados dentro de o FPGA, o roteamento é feito manualmente tornando pouco automatizado o fluxo proposto por Palma e, dependendo a complexidade do núcleo IP a ser conectado ao controlador, pode ser inviável desenvolver sistemas reconfiguráveis mais comple xos.
Estas limitações na arquitetura de roteamento dos bufers tristate impossibilitem o uso de barramentos com um número razoável de bits.
Segundo Palma, apenas um experimento usando barramento serial para transmissão de dados entre os núcleos IP foi factível de implementação.
Projeto Modular, originalmente, é utilizado para desenvolver projetos de forma distribuída.
Um projetista é responsavel por a manutenção e atualização do arquivo de nível hierárquico mais alto e os projetistas restantes são responsáveis por os módulos que compõem o projeto.
Estes são sintetizados separadamente.
Em o final do fluxo do Projeto Modular, todos os módulos são reunidos num único projeto junto ao módulo de maior nível hierárquico, resultando no projeto final pronto para ser configurado no FPGA, Este fluxo utiliza um conjunto de ferramentas do pacote ISE (Integrated Software Environment), usados para mapear, posicionar, rotear e gerar arquivos de configuração parciais e totais.
O Projeto Modular permite que um módulo seja modificado de forma independente, não afetando os demais módulos que compõe o projeto.
Os módulos e o arquivo de maior nível hierárquico são sintetizados separadamente.
De forma alternativa, é possível gerar módulos reconfiguráveis armazenados dentro de arquivos de configuração.
A partir de esta premissa, é possível configurar o FPGA com um arquivo de configuração total inicial e, logo após, configurar sucessivos arquivos de configuração parciais no FPGA, para a execução dinamicamente reconfiguravel.
A Figura 3.3 mostra uma visão geral das fases do fluxo do Projeto Modular.
Estas serão apresentadas de maneira mais aprofundada no Capítulo 4.
Com o uso do fluxo de Projeto Modular, o usuario não precisa se preocupar com vários detalhes inerentes a implementação do projeto.
O nível de abstração do fluxo esconde especificidades arquiteturais do usuario, permitindo que este se detenha mais no desenvolvimento do projeto no nível HDL e arquivos de restrições.
No entanto, existem diversas fases da execução do Projeto Modular efetuadas manualmente.
A codificação HDL também deve- se adequar em certas medidas às características impostas por o fluxo do Projeto Modular.
Ao contrário de o fluxo do barramento proposto por Palma, os núcleos reconfiguráveis são conectados ponto-a-ponto por as bus macros.
Não e necessário lógicas adicionais para controle do barramento.
Dentro de o escopo deste trabalho, adotou- se este fluxo do Projeto Modular para prover a reconfiguração parcial e dinâmica.
O incremento na eficiência provido por SDRs não é obtido sem custo Para transferência do arquivo de configuração do circuito de uma unidade de armazenamento que esteja situada fora de o FPGA para dentro de a memória de configuração, tempo e largura de banda da memória adicionais são necessarios.
Em alguns casos, este tempo extra pode reduzir e até mesmo eliminar o número de benefícios oferecidos de uma especialização de tempo de execução.
No entanto, a relação entre custo de reconfiguração e ganho em desempenho e economia de recursos pode compensar em muito o tempo de configuração.
Este é o principal objetivo de ser atingido durante o projeto de SDRs.
Um método que calcula o equilíbrio entre eficiência e custo de configuração foi proposto por Wirthlin e Hutchings para avaliar a utilização de SDRs.
Este método é baseado na métrica de densidade funcional.
A métrica de densidade funcional é definida nos termos de custo de implementação de uma lógica ern hardware.
O custo (C) é medido como o produto entre a área total requerida para implementar a lógica em hardware (A) e o tempo total de operação (T):
A variavel T inclui o tempo necessario para execução, controle, inicialização e transferência de dados.
Densidade Funcional (D) mede a vazão computacional (número de operações por segundo) de uma medida de hardware, e é definida como o inverso de C:
A métrica densidade funcional em 3.2 será utilizada para comparar circuitos modificados estaticarnente contra as alternativas em reconfiguração dinâmica.
O incremento na densidade funcional de alguns SDRs sobre as alternativas equivalentes estaticarnente reconfiguráveis (Ds) e computada como a diferença norrnalizada entre DT e D5, como segue:
A porcentagem de incremento é medida multiplicando a Equação 3.3 por 100.
A maior diferença entre SDRs e seus equivalentes estáticos é o custo adicional de reconfiguração.
Isto força a adição do tempo de configuração ao tempo total de operação de um SDR.
Para estes sistemas, o tempo total de operação T inclui o tempo total de execução (Te) e o tempo total de configuração (Tc):
Substituindo T em 3.2 é evidente que o tempo de configuração reduz a densidade funcional.
Contudo, apesar de o tempo de configuração absoluto ser um importante parametro, a relação entre o tempo de configuração e o tempo de execução é muito mais informativo.
A taxa de configuração:
T $= Te (3-6) Substituindo este tempo em 3.2 obtém- se a métrica de densidade funcional:
Como mostrado em 3.7, tempos longos de configuração podem ser tolerados se houver um tempo longo de execução correspondente (f pequeno).
Em o limite, se f tende a zero, a sobrecarga imposta por a configuração é irrelevante.
Tais sistemas aproximam- se da máxima densidade funcional provida por SDRs.
Este valor maximo (Dmm) é calculado ignorando- se o tempo de configuração:
Dm,: Lim D,:
1 f~\&gt; 0 ÁTe () Usando- se Dm», o limite superior do incremento (Imm) sobre um sistema estático pode ser encontrado.
Este parâmetro sugere o benefício maximo de um sistema SDR, e é uma boa indicação da relativa utilização de SDR para uma dada aplicação:
Wirthlin e Hutchings ao propôr essas métricas, sugerem que ao projetar SDRs, procura- se aumentar ao maximo o tempo de execução do sistema de cada configuração, para que se justifique o uso de SDR.
As interfaces de comunicação padrão podem ser classificadas em abordagem centrada no meio dc comunicação (bus-centric) e abordagem centrada na interface de comunicação (core centric).
Núcleos devem seguir o protocolo do meio de comunicação ou serem adaptados para poderem acessar o meio de comunicação.
A maioria das interfaces padrão centradas no meio de comunicação existentes são baseadas em arquiteturas de barramentos.
A Figura 3.4 mostra a desvantagem de modelos baseados nesta abordagem.
Existem varios sistemas de interfaces baseados em barramentos.
Alguns são descritos a seguir:
CoreConncct é uma interface de comunicação baseada na arquitetura de barramento desenvolvida por a IBM que provê integração e reutilização de núcleos IP em SoCs.
A IBM disponibiliza, além de as especificações do Core Connect, um conjunto de ferramentas, modelos HDL comportamentais dos elementos da arquitetura.
Wishbone e uma interface baseada na arquitetura de barramento desenvolvida por a SILICORE, que utiliza uma arquitetura mestre/ escravo.
Isto significa que os módulos com interfaces mestre iniciam transações de dados, e interfaces escravo respondem a essas transações.
Este barramento foi desenvolvido por a necessidade de uma solução boa e confiavel para integração dos núcleos IP em SoCs, por a necessidade de uma especificação de interface comum para facilitar as métodologias de projeto estruturadas para grandes equipes de projeto.
A arquitetura do Wishbone é análoga a um barramento de microcomputador, sendo que esta prove uma solução flexível para integração que pode ser facilmente adaptada a uma aplicação específica, provê uma variedade de ciclos de acesso ao barramento e de larguras de caminhos de dados para atender diferentes sistemas.
Wishbone também permite que os núcleos IP sejam projetados por varios fornecedores.
AMBA Advanced Microcontroller Bus Architecture é um padrão aberto desenvolvido por a ARM Corp, ou seja, uma especificação de barramento que define uma estratégia para interconexão e gerenciamento de blocos funcionais para o desenvolvimento de SoCs.
Finalmente, Avalon é uma arquitetura de barramento para integração de módulos no desenvolvimento de SoCs desenvolvida para FPGAS.
Também é uma interface que especifica conexões de entre componentes mestres e escravos, e temporização na comunicação entre os módulos.
Avalon suporta características como barramento para múltiplos mestres, entre outros.
Esta última característica provê flexibilidade na construção de SoCs e alta largura de banda para comunicação com os periféricos.
Vários componentes mestre podem realizar transações simultaneamente (não com o mesmo componente escravo).
Esta abordagem tem sido proposta para facilitar o desenvolvimento de núcleos IP, já que o projetista destes ira se concentrar somente no desenvolvimento do núcleo, e não em como este núcleo interage com o ambiente.
Assim, e possível integrar um núcleo a qualquer sistema com o mesmo protocolo sem a necessidade de alteração em termos de largura de banda, freqüência e sinais de interface deste núcleo.
A Figura 3.5 ilustra a abordagem centrada na interface de comunicação através de um exemplo de arquitetura.
Existem alguns protocolos de comunicação baseados no modelo disponíveis tais como:
38 Capítulo 3: Reconfiguração Baseada em Núcleos e Interconexão de Núcleos O Open Core Protocol (OCP) é um protocolo de comunicação, que provê interface de comunicação entre núcleos no desenvolvimento de SoCs.
OCP pode ser aplicado a qualquer tipo núcleo IP, inclusive barramentos.
Os núcleos IP são empacotados por o protocolo.
Desta forma, este protocolo é independente do sistema de interconexão adotado.
O uso deste protocolo de comunicação minimiza problemas de conectividade entre núcleos IP, possibilitando o reuso de um núcleo IP de um determinado projeto.
Desta forma, o uso do OCP torna mais simples e rentável a integração deste núcleo, tanto para o provedor quanto para o integrador do núcleo.
VSIA Virtual Socket Interface Alliance é um consórcio internacional de companhias dedicadas a acelerar a mudança de paradigmas de projeto de ASICs para SoCs.
Esta desenvolve padrões abertos para fazer a interface entre núcleos IP, tornando possível o projeto de SoCs.
Dentro de o escopo deste trabalho, abordou- se o padrão de comunicação OCP por a sua disponibilidade no grupo de estudo local e por ser um padrão com a documentação gratuita.
O OCP é um protocolo de comunicação que possui uma série de regras bem definidas, as quais provêem a integração de núcleos IP a um SoC, independente do sistema de interconexão adotado.
O uso deste protocolo de comunicação pode minimizar problemas de interconexão de núcleos IP, possibilitar a reutilização de um núcleo de um dado projeto, tornando mais simples e rentável a integração deste núcleo, tanto para o provedor quanto para o integrador do núcleo.
OCP define uma interface ponto-a-ponto entre duas entidades como núcleos IPs e módulos de interface de barramento (bus wrappers).
As entidades que usam o protocolo OCP agem como mestre e escravos, ou sejam iniciando requisições e respondes- la a elas, respectivamente.
As características do núcleo IP determinam se o núcleo necessita de um empacotamento mestre ou escravo, ou ambos.
A transferência de dados através deste sistema acontece da seguinte forma:
O iniciador do sistema (núcleo IP com módulo OCP mestre) envia um comando e disponibiliza dados ao módulo escravo do barramento.
Este módulo escravo atua como mestre do barramento, disparando um sinal de request dentro de o barramento do sistema.
O módulo OCP mestre recebe do módulo OCP escravo (mestre do barramento) o comando e os dados, enviando estes para o módulo OCP escravo do núcleo IP destino.
Além de o suporte a modelos de transferência de dados simples baseado em requisição e resposta, 0 OCP suporta modelos de transferência de dados de alto-desempenho baseados em multi-threads e pipeline.
Conjunto de sinais do OCP Os sinais do OCP são divididos em três grupos:
Sinais de Huxo de dados, sinais opcionais de controle e sinais de teste.
Os sinais de fluxo de dados são responsaveis por a troca de dados entre os núcleos (mestre e escravo).
Os sinais opcionais de controle tem o objetivo de transmitir informações de controle tais como:
Inicialização, interrupção, erro e identificação de núcleos;
Sinais para mudanças de controle e informação de estado entre um núcleo e o resto do sistema.
Finalmente, os sinais de teste servem para varredura e teste da interface de um núcleo IP.
Em este trabalho, o enfoque sera dado apenas para o conjunto de sinais básicos do OCP.
Para maiores informações, veja.
Todos os sinais do OCP são amostrados na borda de subida do relógio (clock).
Alguns sinais do OCP são configurados a partir de parâmetros, de entre estes citam- se o addr_ wdth e o data_ wdth.
Estes e outros parametros são descritos no decorrer de esta Seção.
De entre todos os sinais suportados por o protocolo, existe um conjunto de sinais denominados de sinais basicos.
Estes devem compor a interface de qualquer núcleo IP baseado no OCP.
Sinais de fluxo de dados Sinais básicos Em esta Seção são descritos os sinais básicos que devem compor a interface de um nucleo IP.
A Tabela 3.1 apresenta os sinais básicos do padrão OCP e suas respectivas funcionalidades.
Estes sinais são:
Clic: A borda de subida deste sinal sincroniza todos os sinais da interface;
MDAddr: Especifica o endereço em função de o núcleo com comportamento escravo dese jado.
A largura deste sinal pode ser configurada a partir de o parâmetro addr_ wdth;
MCmd: Indica o tipo de transferência que deve ser efetuada (leitura, escrita, entre outras).
Os comandos de codificação deste sinal são descritos na Tabela 372;*
MData: Este sinal transporta os dados do mestre para o escravo.
A largura deste sinal é configurada a partir de o parâmetro data_ wdth;
SCmdAccept: Quando o sinal esta no nível lógico alto, indica que o núcleo IP escravo aceita a requisição de transferência efetuada por o núcleo mestre;
SData: Este sinal transporta os dados do escravo para o mestre.
A largura deste sinal é configurada a partir de o parametro data_ wdth;
Os sinais de extensão simples permitem a adição de espaço de endereçamento, suporte ao modo rajada7 datahandshake (sinais de estabelecimento de comunicação entre dispositivos utilizados para assegurar a transferência de dados) e controle de fluxo de resposta.
Também melhoram a capacidade de transferência basica, introduzindo o conceito de threads.
Porém estes sinais não serão apresentados neste Capítulo.
Em o para o ocolo OCP, existem varios modos de transferência' Porém neste Capítulo, deu- se o enfoque principal para o protocolo de uma transferência simples de escrita e leitura de dados.
A Figura 3.7 apresenta um diagrama do protocolo de comunicação de uma transferência simples de escrita e leitura de dados.
A seqüência para a transferência segue os seguintes passos:
O mestre começa a fase de requisição quando ocorre a transição do sinal Mcmd do estado IDLE para WR.
Em o mesmo instante é apresentado um endereço valido no campo Maddr, e dado válido no campo Mdata.
Estes três sinais devem ser apresentados juntos, na mesma borda de subida do relógio.
O escravo, por sua vez, ativa o sinal de ScmdAccept no mesmo ciclo, permitindo a transferência sem latência;
Em esse instante, o escravo captura os valores referentes ao endereço, aos dados e utiliza estes internamente para efetuar a escrita.
Como o ScmdAccept esta ativo, isto indica término da fase de requisição;
O mestre inicia a fase de requisição de leitura (RDQ) atribuindo o comando de leitura RD, no sinal Mcmd.
Em este momento o mestre apresenta um endereço (Ag) no campo Maddr;
O escravo captura o valor do Maddr e utiliza este internamente para determinar que dado deve ser retornado' A fase de resposta começa quando o comando Sresp passa de NULL para DVA.
Em o mesmo instante o escravo apresenta o dado do campo Sdata.
Eum) ciclo de relógio;
Para validação do protocolo OCP, deve- se utilizar uma ferramenta chamada CoreCreator.
Esta ferramenta valida funcionalmente o projeto utilizando OCP através de simulação e da geração de tráfego de dados na entrada e saída do núcleo ou sistema a ser validado.
O núcleo pode gerar ou receber tráfego, dependendo de sua característica inicializador/ alvo (mestre/ escravo).
A Figura 3.8 mostra um exemplo de núcleo sendo validado por a ferramenta CoreCreator.
O bloco denominado de Qmaster simula o comportamento de um núcleo mestre, inicializando o sistema simulado e gerando trafego para o núcleo escravo referenciado por W_ mm para validação do mesmo.
Entre o núcleo a ser validado e o núcleo inicializador do sistema, existe um monitor que verifica e armazena informações referente a transferência de dados entre os núcleos.
Em a ferramenta CoTeCreatoT existe comandos para a execução de cada fase de certificação.
Estas são descritas abaixo:
Create Netlíst: Em esta fase são criados arquivos de configuração de núcleos para serem usados na simulação e síntese;
São descrições de hardware (testbenches) os quais tem a função de simular o comportamento de cada módulo a ser testado;
Prepare Simulation:
Em esta fase, arquivos de teste e arquivos STL (Sonics Transaction Language) são lidos e produzem um modelo comportamental mestre ou escravo do núcleo gerador de tráfego.
Este comportamento é descrito num arquivo que será usado na.
Run Simulation: Em esta fase, os arquivos gerados por a.
Fase anterior são usados na simulação.
A simulação gera resultados para análise e verificação do núcleo.
Relatórios são criados aqui com o intuito de verificação e eventuais analises comportamentais.
Analyze Results: O processamento dos resultados gerados na fase anterior é realizado.
Em este ponto, a ferramenta pode informar se o protocolo descrito em HDL é compatível ou não com o protocolo OCP.
O presente trabalho é parte de um ambiente proposto para desenvolvimento e implementação de sistemas dinamicamente reconfiguráveis denominado PADREH (Partial and Dynamic geração de sistemas complexos, conceitualmente maiores que o dispositivo alvo.
O sistema PADREH subdivide- se em três partes:
Módulo de captura e validação funcional de projeto;
Módulo de particionamento e escalonamento[ MARUÊL* Módulo de síntese física e parte da infra-estrutura de reconfiguração;
De acordo com a Figura 3.9, o módulo de captura e validação funcional do projeto responsabilizase por descrever, refinar e validar o sistema no nível transacional (TLM -- Transaction Level Modeling).
A descrição no nível RTL (Register Transfer-- level) é a entrada do módulo de particionamento e escalonamento.
Este módulo particiona o sistema de acordo com informações de comportamento do sistema e de características do SoC alvo da implementação.
O módulo de particionamento e escalonamento gera arquivos que descrevem o comportamento do sistema na forma de HDLs (Hardware Description Language) para o módulo de síntese física e parte da infra-estrutura de reconfiguração.
O módulo de síntese física e parte da infra-estrutura de reconflgaração executa as seguintes tarefas abaixo:
Gera arquivos de configurações totais e parciais de acordo com o particionamento;
Adiciona módulo controlador de configurações parametrizado de acordo com as caracteristicas do sistema;
Gera a implementação física de uma rede de interconexão entre os núcleos do sistema fornecido por o módulo de particionamento e escalonamento;
Gera arquivos de configuração totais e parciais;
O desenvolvimento do arcabouço PADREH proposto implica abordar temas tais como o particionamento de hardware;
O escalonamento de configurações para execução;
A geração de arquivos de configuração parciais e totais;
A configuração de dispositivos parcialmente reconfiguráveis;
A representação de informações a respeito de o cronograma de escalonamento e o gerenciamento da operação de configurações.
O presente trabalho propõe uma parte da infra-estrutura de reconfiguração que faz parte do módulo síntese fisica e parte da infra-estrutura de reconflgnração.
Sua finalidade é a geração de arquivos de configuração parciais e totais do projeto, utilizando métodos de interconexão de núcleos usando OCP.
Especwicaçào do srsrema no nwer Hansacranal (TLM) (s.
G systemcL_ Validação no niVeW transacronal (e g GTKWave etc) Relinamenlo e tradução Dsscrrçãa da srslsma_ nu nwsw RTL em HDL vandação Funcuonar (e g VHDL Vem «(eg AcrwsHDL ModeSrm) Particronamento Escamnamenlo de hardware espaçortempora!
Fluxo de Projeto Modular. Usando o Fluxo de Projeto Modular descrito em, é possível desenvolver projetos com reconfiguração parcial e dinamica.
Projeto Modular, ern seu objetivo inicial, e uma técnica utilizado para desenvolver projetos complexos de forma distribuída.
Um projetista é responsável por a manutenção e atualização do arquivo de nível hierárquico mais alto e os projetistas restantes são responsáveis por os módulos que compõem o projeto.
Projeto Modular permite que um módulo seja modificado de forma independente, não afetando os demais módulos que compõe o projeto.
Os módulos são sintetizados separadamente.
Em o final do Fluxo de Projeto Modular, todos os módulos são reunidos num único projeto junto ao módulo de maior nível hierárquico, resultando no projeto final pronto para ser prototipado.
Executando o Projeto Modular de forma alternativa, é possível desenvolver módulos reconfiguráveis sob forma de bitstreams parciais.
De este modo, e possível inicializar o FPGA com um bitstream e então fazer os sucessivos downloads de bitstreams parciais no FPGA.
Este fluxo foi usado para o desenvolvimento de sistemas dinamicamente reconfiguráveis no trabalho a partir de a disponibilidade de FPGAs Virtex II da Xilinx, uma das famílias de dispositivos que permite o uso dos bitstreams gerados por o Huxo.
Outra característica deste Huxo é a geração de bitstreams parciais dos módulos reconfiguráveis sem roteamento manual, caso algum sinal não seja roteado por a ferramenta de síntese fisica.
O Projeto Modular é dividido em três fases:
Fase do Orçamento Inicial:
Em esta fase, determina- se qual é a estrutura do arquivo de nível hierárquico mais alto do projeto.
Atribuições de restrições de area e temporização também são realizadas nesta fase;
Implementação dos Módulos Ativos: Cada módulo é sintetizado e implementado separa damente.
Esta fase gerará bitstreams parciais de cada módulo usado na reconfiguração;
Montagem Final: A terceira e última fase do Projeto Modular onde é (são) gerado (s) o (s) módulo (s) de maior nível hierárquico, une- se todos os outros módulos aquele e sintetiza- os num único projeto;
A síntese logica de todos os módulos e realizada individualmente e ocorre antes da execução da Fase do Orçamento Inicial do Fluxo de Projeto Modular.
Antes da execução do Fluxo de Projeto Modular, é necessário definir os módulos top e os módulos que constituem o projeto.
O módulo top (módulo de maior nível hierárquico) é apenas uma camada que une os módulos hierarquicamente inferiores.
Os módulos são apenas instanciados no módulo top e conectados diretamente ou usando bus macros.
Bus macro é um componente (macro) pré-definido e pré-roteado, fornecido por o fabricante, constituído por oito before tristate para assegurar a comunicação de 4 bits entre módulos fixos/ reconfiguráveis e reconfiguráveis/ reconfiguráveis possuindo a estrutura descrita na Figura 4.2.
A comunicação que a bus macro provê é ponto-a-ponto.
O principal objetivo da bas macro é prover uma forma de controlar a interface de comunicação entre dois módulos, a partir de qualquer um dos módulos.
De acordo com a Figura 4.2, uma bas macro tem 16 sinais de entrada e 4 sinais de saída.
Oito dos sinais de entrada controlam o componente.
Os demais são sinais que transportam informação entre os módulos.
A bas macro é dividida em dois grupos de sinais:
Sinais do laco esquerdo e do lado direito.
Quatro pinos de controle acionam quatro tristates numa bas 70).
Se um tristate do lado esquer o macro.
Todos os tristates são ativados em nível lógico da bus macro for acionado, obrigatoriamente o tristate do lado direito que está conectado na mesma linha de saída devera ser desativado.
Desta forma, evitam- se confiitos.
A Figura 4.3 ilustra uma conexão de dois módulos através de uma bas macro.
O módu o situado à esquerda da bas macro possui dois sinais, usados na comunicação com o módu o da direita, denominados Small e Sinal?
O Sinal. (
comunicação no sentido esquerda-direita) eo módulo da esquerda é conectado a um sinal chamado Sinal2_ vindo_ modulo.
Este sinal é conectado a uma das entradas da bus macro situada à esquerda (Li).
Nota- se que a entraca de controle (LT) referente a o sinal de entrada da bas macro recebe um valor de nível lógico baixo (GND) para habilitar incondicionalmente o tristate e possibilitar a passagem dos dados de um lado da bus macro para outro.
Este sinal propaga- se por a saída (O) que é conectaca ao sinal Sinalâ_ vindo_ BM.
Este por sua vez é ligado no módulo da direita por o Sinal.
Por outro lado, o Sinal] (comunicação direita-esquerda) do módulo da direita é conectado ao sinal denominado Sinal2_ vindo_ modulo.
Este sinal é conectado a uma das entradas da direita ca 50 Capítulo 4: Fluxo de Projeto Modular bus macro (Ri).
O sinal RT referente a a entrada (Ri) é posto no nível lógico zero (CND).
Então, o sinal de entrada da bas macro é propagado para a saída da mesma (O) que é conectada ao sinal Small_ vindo_ BM.
Este sinal, por sua vez, e ligado no módulo da direita por o Small.
Módulo Módulo Fixo/Reconligurável Bus Macho Reconfigurável SirwaIZJ/ wndcpmódulo GNU 2 2 GN «SinalLv/ wndcpmódulo Li HI Sinah Sinalz GN D1 1 GND GND T o í GND em:
Í a í vcc vcc í 2 2 í em:
As instâncias das bus macros devem ser declaradas no módulo top para conexão dos módulos que compõe o projeto.
Também deve- se usar atributos específicos da ferramenta de síntese usada para preservar sinais não utilizados das bus macros após a síntese.
Bafers e circuitos de sincronismo de relógio (DCM) devem ser instanciados no módulo top para redução do escorregamento de relogio, e também para que nos próximos passos do Projeto Modular a ferramenta de roteamento consiga fixar tal sinal no FPGA.
Finalmente, artifícios para criar sinais VCC e GND dentro de o FPGA através de LUTs instanciadas para fornecimento de energia para as bus macros são necessarios, pois não deve haver desperdício dos pinos de entrada e saída do FPGA.
Recomenda- se que os pinos de entrada e saída do FPGA não sejam utilizados para alimentação das bus macros.
De acordo com a XAPP29O, se um módulo esta localizado numa área onde não existe um determinado recurso do FPGA (pinos E/ S, reset, etc), e se este necessita conectar- se aos recursos localizados em outra area definida para fixar outro módulo, deve- se utilizar bus macros.
As Figuras 4.4 e 4.5 mostram uma situação que exige bus macro para comunicação de pinos E/ S com os módulos.
As Figuras 4.7 e 4.6 ilustram uma situação que exige bus macro para comunicação de pinos de módulos internos.
Am m, Ávea Recnnngmável Ave¡ me (g í-A-S í:
Para posicionar elementos arquiteturais do FPGA, os arquivos de restrições são editados, bem como as áreas onde estarão localizados os módulos.
Em o desenvolvimento de SDRs usando este fluxo, deve- se posicionar LUTs, DCMs e bus macros.
As últimas devem ser sempre posicionadas nos slices que estão localizados nas coordenadas horizontais múltiplas de 4 no dispositivo reconfiguravel.
O desrrespeito a esta restrição resulta em erros na ferramenta de posicionamento e roteamento.
Depois da síntese dos módulos, deve- se organizar os arquivos de síntese gerados em dire tórios, conforme recomendados na Figura 4.8 para a execução do Fluxo de Projeto Modularlsto deve ser realizado para que as ferramentas não sobreescrevam dados entre fases de processo, o que pode causar problemas na execução do fluxo como um todo.
Abaixo, é descrito cada diretório da Figura 4.8 recomendada por a Xilinx.
Pmjeto: Diretório que mantem todos os arquivos necessario para a execução do fluxo;
Depois que todos os módulos são sintetizados e organizados na estrutura de diretórios recomendada, então, é possível executar o Fluxo de Projeto Modular;
A execução do Fluxo de Projeto Modular requer diversas ferramentas executadas de forma seqüencialmente ou paralelamente.
Entre as ferramentas usadas na execução do Projeto Modular disponibilizadas por a Xilinx, as principais são:
NgdBuildzEsta ferramenta aceita como entrada arquivos EDIF, e como saída, gera arquivos de extensão NGO (arquivo intermediário que contém descrição lógica do projeto, arquivos de componentes pré-roteados (arquivos NMC (Netlist Macros)).
Esta ferramenta converte um arquivo netlist de acordo com o modelo e fabricante do dispositivo reconfigurãvel, reduzindo todos os componentes em primitivas internas no formato da Xilinx, incluindo macros.
A ferramenta acessa também bibliotecas apropriadas para cada componente e impondo restrições de acordo com o arquivo UCF.
São feitos também testes lógicos na estrutura dos componentes neste formato, e finalmente o arquivo NGD é escrito.
Esta ferramenta é executada em diferentes formas em cada etapa do Projeto Modular;
Floorplanner: Ferramenta que aceita como entrada um arquivo NGD para definição da planta-baixa, agrupando módulos por area e fixando num determinado local a partir de comandos do usuário os componentes primitivos da Xilinx;
Map: Programa que mapeia uma descrição lógica, tais como blocos lógicos e componentes.
Remove também lógica não usada, associa os Pads nos seus blocos lógicos de entrada e saída (I/ O) associados, mapeia a lógica dentro de os componentes (CLB, IOBs, etc).
Esta ferramenta aceita como entrada arquivos NMC e NGD e como saída gera arquivo de restrições físicas de extensão PCF (Physical Constraints File) e também gera um arquivo NCD (Native Circuit Description).
Este arquivo é uma representação física do projeto mapeado em termos de componentes fornecidos por as bibliotecas da Xilinx.
É gerado também um arquivo de extensão NGM, o qual contém informação do projeto físico produzido por o MAP;
Par (Place and Route):
O arquivo NCD criado por o MAP é a entrada do Par, junto com as restrições físicas (PCF).
Par realiza o roteamento e o posicionamento das linhas de conexão utilizando dois critérios basicos.
O primeiro de eles é baseado no custo.
São utilizadas varias tabelas de pesos e custos para estimar comprimento de conexões, restrições impostas por o PCF e recursos de roteamento disponíveis.
Outro critério é a temporização.
O roteamento e posicionamento são feitos seguindo a analise de restrições temporais.
O arquivo gerado por o Par é um NCD roteado e posicionado, pronto para ser utilizado por o gerador de bitstreams;
FPGA Editor: Ferramenta opcional utilizada para visualizar os componentes e o roteamento dentro de o FPGA.
Esta ferramenta permite também editar conteúdo dentro de LUTs e modificar o roteamento;
TRCE (Timmy Reporter (md Circuit Evaluator):
Gera relatórios utilizando como entrada o arquivo de restrições físicas e um NCD roteado e posicionado.
Estes relatórios contêm dados sobre verificação de temporização, usando restrições de tempo, e final mente verificação de violações de posicionamento;
Pim Create (Physically Implemented Modules Creator):
Pims são projetos ja roteados e posicionados.
PIMCreator automaticamente copia os arquivos NGO, NGM e NGD para diretórios apropriados para a execução do Projeto Modular, na preparação na fase de Montagem Final.
O utilitário também renomeia arquivos de acordo com necessidades do Projeto Modular;
BitGen: Produz Bitstreams para configuração de um dispositivo de configuração da Xilinx.
A entrada desta ferramenta é um arquivo NCD roteado e posicionado gerado por o Par.
Este tipo de arquivo contém todas as informações de configuração, que definem toda a lógica interna e interconexões, num dispositivo configurável específico.
O bitstream pode, através de uma ferramenta de download, ser enviado para o FPGA para configuração.
Bitstreams gerados podem ser totais ou parciais;
Como já foi mencionado anteriormente, determina- se nesta fase o arquivo top do projeto, bem como atribuições de restrições de área e temporização para cada módulo.
Cada módulo reconfiguravel do projeto será encapsulado por um módulo top.
A fase do Orçamento Inicial é aplicada em todos os módulos top.
Em esta fase são feitos: (
a) definição de pinagem e restrições de tempo; (
b) posicionamento de elementos para redução de atraso de clock, bus macros, e fontes de alimentação das mesmas; (
c) posicionamento dos módulos no FPGA (definição da planta-baixa).
A Figura 4.9 apresenta o fluxo de execução da fase de Orçamento Inicial.
A ferramenta NGDBuild é executada para gerar os arquivos necessários para as demais fases do Projeto Modular, posicionando toda a lógica do módulo top e agregando blocos que ainda não foram expandidos e que representam módulos.
A entrada desta ferramenta são os arquivo de restrições que é gerado inicialmente por o usuário.
Este arquivo é depois editado alternativamente por a ferramenta F loorplanner.
Arquivos NGD e NGO são gerados, porém apenas o último sera usado como entrada da próxima fase.
A ferramenta Floorplanner é executada nesta fase para definição da planta-baixa, fixando os locais onde os módulos serão roteados e posicionados nas próximas fases do Projeto Modular.
Os demais componentes (LUTs, bus macros, etc) também são fixados através desta ferramenta.
Em a fase da Implementação do Módulo Ativo, como a própria nomenclatura define, ocorre o posicionamento, mapeamento, roteamento e a geração dos bitstreams parciais que representam cada módulo (fixo ou reconfiguravel) do projeto.
Os bitstreams parciais gerados a partir de cada módulo reconfigurável podem ser configurados individualmente no FPGA depois da execução do Fluxo de Projeto Modular.
O fluxo desta fase é apresentada na Figura 4.11.
As entradas deste Huxo são as mesmas utilizadas por a fase do Orçamento Inicial.
Entretanto, usa- se mais um arquivo de entrada gerado na fase do Orçamento Inicial com extensão NGO.
NGDBuild gera um arquivo que será usado como entrada na ferramenta de mapeamento (MAP).
Esta gera restrições físicas e um arquivo NCD não roteado, que serão usados na ferramenta de posicionamento e roteamento (Par).
Finalmente, são gerados os bitstreams parciais e uma estrutura de diretórios chamada Pim (Physically Implemented Modules), onde serão armazenados arquivos necessarios para a execução da terceira e última fase do Projeto Modular.
Finalmente, na fase Montagem Final, todos os módulos implementados fisicamente que fazem parte do módulo top são agregados ao mesmo.
O posicionamento, mapeamento e roteamento são feitos de maneira unificada, anexando todos os módulos num único projeto.
O bitstream total do projeto final é criado nesta fase, pronto para ser prototipado.
O fluxo de execução desta fase é ilustrada na Figura 4.12.
Em os documentos providos por a Xilinx (e Development System Reference Guide), existem passos que são omitidos.
A síntese é incompletamente descrita na documentação.
Os arquivos de restrições de usuario (UCF) são fornecidos com pouquíssimas informações sobre como restringir o projeto.
A ferramenta Floorplanner, essencial para particionamento dos módulos no FPGA é pouco detalhada na documentação disponível.
A documentação não explica como são aplicadas e posicionadas as bus macros no projeto.
Muitos procedimentos foram criados a partir de extensa pesquisa, interação com o setor de suporte da Xilinx e procedimentos exaustivos de tentativa e erro.
A partir de estas precariedades sobre a falta de informação referente a execução do fluxo nos manuais da Xilinx, foram adicionados passos, que são parte da contribuição deste trabalho:
Aillmvos Mm x;
Í Avqmvo Amuwu m N60;
Uma em:
Síntese Lógica:
Foram adicionados alguns atributos de síntese lógica como restrições de sinais que não são usados (a síntese lógica removia tais sinais) e a não remoção de certos componentes que não eram usados, mas devem fazer parte do projeto.
Foi realizada também a síntese lógica do arquivo top definindo os sub-módulos que compõe este arquivo como caixas-preta.
Esta definição permite a geração de um arquivo netlist do top apenas com as conectividades com os sub-módulos, sem a lógica dos mesmos anexada ao arquivo.
Esta é uma restrição imposta por a execução do Huxo precariamente detalhada nos manuais;
Inclusão de tags no arquivo de restrição para permitir a reconfiguração parcial usando a ferramenta F loorplanner;
Adição de Componentes para Geração de VCC e GND:
Usados para alimentação das bus macros.
Ao invés de usar recursos externos do FPGA como os pinos de I/ O para alimentação das bus macros, foram usadas LUTs para a alimentação das mesmas.
Aqui foram adicionados comandos na síntese lógica para instância das LUTs e também foram incluídas no arquivo de restrições tags para posicionamento das LUTs no FPGA;
Inserção de variaveis de ambiente para solucionar erros na ferramenta de mapeamento:
Foram usados variaveis de ambiente para ajustar algumas opções na ferramenta para permissão do uso de certas características no projeto reconfiguravel;
Adição de DCMs:
Adição de componentes de gerenciamento de relógio para diminuir o escorregamento de relógio e permitir o funcionamento de circuitos seqüenciais reconfi guraveis;
Adição de LUTs para Alimentação do DCM:
Foram usadas LUT para alimentação do DCM para evitar erros de roteamento.
A Subsseção 4.3 abrange este assunto;
Posicionamento de componentes em locais estratégicos do dispositivo reconfiguravel que são conectados ao DCM para evitar erros de sincronização;
A execução das ferramentas mostradas nos manuais da Xilinx não funcionavam em certos estudos de caso.
O fluxo foi ajustado para executar qualquer estudo de caso, independente de suas características inerentes;
A informação contida neste Capítulo e um resumo de documentação bem mais extensa contida em relatório de pesquisa publicado.
Apesar de o Fluxo de Projeto Modular poder ser usado para conceber módulos reconfiguráveis sem a manipulação detalhada de informações físicas do projeto, o fluxo mostra- se pouco automatizado na execução de suas fases.
A falta de automatização pode resultar em inúmeros erros cometidos ao longo de a execução do fluxo como um todo.
Alem disso, o número de sinais que atravessa as bus macros é determinado por o número de tristates numa coluna inteira do FPGA.
O número de bits dos sinais que atravessam as bus macros deve ser menor ou igual ao número de tristates numa dada coluna do FPGA.
Este fator é limitante para a concepção de projetos integrados que são desenvolvidos através deste fluxo.
Também, hardware adicional deve ser inserido no projeto, como por exemplo DCMs (Digital Clock Manager) para diminuir escorregamento do relógio.
Em a fase de Montagem Final, encontrou- se problemas quanto a o roteamento e posiciona mento de sinais gerados por a síntese (Global Logic) oriundos de componentes geradores de alimentação (VCCs) que interconectam pinos do DCM.
A ferramenta de síntese também infere outros componentes que devem ser conectados no DCM.
Porem, esta conexão nem sempre foi bem-sucedida usando a ferramenta de posicionamento e roteamento.
O roteamento não é determinístico e quando o Huxo foi executado, ora a ferramenta de posicionamento e roteamento conseguia rotear estes sinais, ora não conseguia, gerando uma mensagem de erro.
A solução encontrada foi instanciar explicitamente no código todos os componentes e conectas- los através da descrição no código HDL.
Instanciou- se e fixou- se LUTs geradoras de constantes para conectas- las aos pinos do DCM.
O Apêndice B_ 1 detalha este procedimento.
De esta maneira, a ferramenta de posicionamento e roteamento consegue ser executado sem erros de roteamento e geração de Global Logic.
Outro problema que surgiu foram erros na geração da rede de relógio.
O projeto prototipado na placa podia ou não funcionar de acordo com o não determinismo da ferramenta de posicionamento e roteamento.
Isto aconteceu quando um módulo fixo foi agrupado no canto esquerdo do dispositivo.
Os DCMs usam bujfers para realimentação para que seja possível a diminuição do escorregamento de relógio.
O DCM que foi conectado ao módulo fixo estava localizado no canto esquerdo do FPGA.
Porem tais ÕUÊBTS ficam posicionados no centro do dispositivo onde se encontrava a area reconfigurável escolhida.
O sinal que ligava os dois componentes passava entre uma area fixa e uma reconfiguravel, e erros aconteciam no momento da reconfiguração parcial.
Então para solucionar este problema, foi instanciada uma bus macro para prover comunicação entre a area fixa e reconfigurável, como mostrado no Apêndice B2.
Desta forma o projeto funcionou corretamente no FPGA.
Finalmente, quando se desenvolve um projeto utilizando mais de uma area reconfiguravel, a complexidade do projeto aumenta quanto a aplicação de bus macros e uso de LUTs para alimentar as bus macros e pinos do DCM.
Uma solução para o desenvolvimento de projetos com esta característica seria posicionar varios componentes do projeto em posições estratégicas no FPGA de acordo com a complexidade do mesmo e também do número de areas reconfiguráveis.
Isto minimiza a quantidade de bus macros e LUTs.
Porém ainda não e o suficiente para ter uma redução de complexidade do projeto dentro de o FPGA de maneira significativa.
Quanto a projetos de duas ou mais areas reconfiguráveis, devem- se utilizar artifícios (multiplexadores) para interligar fios que passam em suas áreas reconfiguráveis, pois sem estes artifícios, problemas de condução do sinal aconteciam.
Isto acarretava em problemas no sis tema reconfiguravel implementado em duas ou mais areas reconfiguráveis.
Como foi mencionado anteriormente, o Projeto Modular permite o desenvolvimento de SDRs e de módulos parcialmente reconfiguráveis de maneira independente e simultânea com outros módulos.
No entanto, o desenvolvimento de tais sistemas, usando o Flu xo de Projeto Modular exige grande esforço, desde a codificação do projeto ate a fase de 62 Capítulo 4: Fluxo de Projeto Modular implementação, o que torna o projeto propenso a erros.
Observando o padrão do Fluxo de Projeto Modular, suas entradas e estruturas de diretório, foi desenvolvida a ferramenta apresentada na Figura 4.13, para automatizar o fluxo, da codificação até a geração dos bitstreams parciais e totais.
A ferramenta denominada MDLauncher (Modular Design Launcher), é capaz de executar praticamente todos os passos do fluxo.
O usuario apenas informa quais módulos são reconfiguráveis, e disponibiliza os arquivos de restrição para o usuario (UCF) com a planta-baixa definida.
MDLauncher gera scripts necessários para a criação de estrutura de diretórios, síntese e implementação que serão executados por a mesma.
Dentro de a ferramenta, pode- se escolher a ferramenta de síntese lógica (Leonardo Spectrum, XST, FPGA Express, etc).
MDLauncher foi desenvolvida usando linguagem de programação JAVA.
Esta ferramenta é importante para o desenvolvimento de SDRs por o fato de automatizar e eliminar o número de erros ocorridos na execução do fluxo.
Em esta ferramenta, é possível executar o fluxo para qualquer modelo da família Vírtex II.
Esta ferramenta foi desenvolvida para possibilitar a adição de outras ferramentas de síntese lógica como mencionado anteriormente.
Porém o nível de dependência tecnológica e alta, ou seja, esta ferramenta só pode ter utilidade para FPGAs da família Virtex II.
Existem passos que devem ser seguidos para a execução da ferramenta.
Estes são apre sentados a seguir:
Definição dos arquivos de configuração:
Primeiramente cria- se um projeto novo, e definem- se quais os arquivos de configuração a serem inseridos no projeto, tais como arquivo de bus macro, arquivo UCF com todas as restrições de posicionamento e área definidas e um arquivo de configuração para geração do bitstream total ou parcial;
Definição dos arquivos-fonte:
O usuario deverá inserir os arquivos de maior nível hierarquico (top, e os arquivos que implementam cada módulo fixo e reconfiguravel do sistema).
Estes arquivos são apresentados no software como uma árvore de diretórios.
A pasta módulos fixos armazenam os módulos de hardware comum a todos os arquivos top;
A pasta topwhd armazena o arquivo top que contém um módulo de hardware específico que esta contido nesse.
A pasta top].
Vhd armazena um arquivo top que contem um outro módulo de hardware específico.
Estes módulos específicos originarão no final da execução do fluxo os bitstreams parciais.
Em o final deste processo, automaticamente e gerada a estrutura de diretórios recomendada por a Xilinx semelhante àquela mostrada na Figura 4.8;
Generate Scripts -- geração de scripts e árvore de diretório:
Em este momento, os scripts indispensáveis serão criados para a execução da síntese lógica;
Sinthetize -- Síntese:
Todos os arquivos fonte são sintetizados logicamente por a ferramenta de síntese escolhida.
Atualmente, o programa suporta apenas a ferramenta Leonardo módulos reconfiguráveis e arquivos top);
Initial Badgeting -- Orçamento Inicial:
Execução da primeira fase do Projeto Modular, como detalhado neste Capítulo.
Gera arquivos intermediários com toda a estrutura do arquivo top descritas num formato da Xilinx com atribuições e restrições de temporiza ção e área;
Active Modules Implementation -- Implementação do Módulo Ativo:
Geração dos bitstre ams parciais;
Final Assembly -- Montagem Final:
Geração dos bitstreams totais e completos, pronto para serem prototipados;
Em esta ferramenta, ha opções que podem ser configuradas como modelo do FPGA, diretório onde estão localizadas as ferramentas de síntese física, implementação e geração de bitstreams, diretório onde está localizada a ferramenta de síntese lógica e diretório onde serão armazenados todos os arquivos necessarios para a execução do fluxo.
A ferramenta MDLauncher visa automatizar o fluxo de Projeto Modular para a geração automatica de SDRs.
Em esta ferramenta foram validados todos os estudos de caso mostrados nos Capítulos 6 e 5.
Gerou- se os bitstreams totais e parciais para estes estudos de caso e estes funcionaram perfeitamente na plataforma de prototipação.
Porém se houver a re-síntese lógica e física do projeto para outra arquitetura alvo, deve- se reposioíonar os módulos fixo e reconfiguravel usando a ferramenta Floorplanner e deve- se reposicionar, quando for o caso, as bus macros, LUTs para fornecimento de energia das mesmas e DCMs.
Validação do Fluxo Modular de Projeto Em este Capítulo, serão apresentados estudos de caso que validam o método proposto no A plataforma V2 MB1000 da empresa Memec--Insight utiliza um FPGA de um milhão de portas lógicas num Ci de 456 pinos.
Além disso, a plataforma o erece também uma memória DDR (Double Data Rate) de 16M x 16 bits, uma From XC18 VO4 de 4 MBits, dois geradores de relógio, uma porta RS-232 e conector de 160 pinos para permitir acrescentar módulos especiais.
Junto a plata orma, existe uma interface LVDS (Low-Voltage Differential Signaling) que provê transmissão de dados de 16 bits em alta velocidade.
A Figura 5.1 mostra um diagrama de blocos de al o nível da plataforma V2 MB1000.
A plataforma dispõe de dois módulos externos acopláveis ao conector de 160 pinos, um módulo para desenvolvimento de projetos de comunicação e um extensor de pinagem.
A plata orma ainda dispõe de suporte para configuração e teste via cabo JTAG e MultiLINX e programação dos modos de configuração via chaves de programação na placa (jumpers).
Para finalizar, um microprocessador soft- core é integrado à plataforma para desenvolvimento de proje os relativamente complexos.
Para validação do fluxo do Projeto Modular no contexto da reconfiguração parcial e dina mica foram desenvolvidos os se uintes estudos de caso abaixo:
Calculadora reconfígurável:
Como o próprio nome diz, esta é uma calculadora de duas operações (subtração/ adição), onde cada operação é representada por um módulo (bitstream) reconfigurável;
Contador reconfigurável:
Este é um contador que pode assumir duas configurações:
Um contador de 1 Hz e um contador de 4 Hz de freqüência de operação;
Contador OCP reconfigurável:
Foi implementado o mesmo contador descrito acima, porém utilizando OCP como protocolo de comunicação entre os módulos;
Contador com duas áreas reconfiguráveis:
Foram implementados dois contadores:
Um contando em ordem crescente e outro em ordem decrescente.
Adicionalmente, estes podem ser configurados em duas areas reconfiguráveis;
Controlador de Memória SRAM:
Permite a mais de uma configuração de um módulo cliente enviar dados para memória SRAM (Static Ram) da plataforma VZMBIOOO;
Sistema R8 Reconfigurável:
É um estudo de caso maior, dividido em dois módulos:
Em este Capítulo serão descritos e analisados cada um dos estudos de caso acima, com excessão do último, que é discutido no Capítulo 6.
Este estudo de caso consiste numa calculadora de uma operação que pode ser configurada em duas funcionalidades:
Adição e subtração.
Este projeto consiste em dois módulos:
Módulo de captura dos dados (capture) situado na area fixa (area que não ocorre a reconfiguração) do dispositivo e um módulo que fica situado na area reconfiguravel (módulos de adição e subtração denominados de adder e sub respectivamente) conforme a Figura 5.2.
Módulo Fixo Cupluve Módulo Reconligulável addel/ sub Resel¡ l Módulo E Adição/:
T=7  bits É Displaw r l Conversor r:
O módulo de captura de dados é responsável por adquirir dados representados nas chaves dip-- switch da plataforma e armazenar estes dados nos registradores denominados F1 e F2.
A entrada Input_ A é definida por as 4 primeiras chaves do FPGA e a entrada Input_ B é definida por as outras 4 entradas restantes.
A entrada get_ data é responsável por a aquisição dos dados das chaves para os registradores F1 e F2.
A área fixa do FPGA, onde está situado o módulo de captura, se interconecta atraves de três bus macros com a área reconfiguravel, onde pode estar situado o módulo de adição ou de 68 Capítulo 5: Validação do Fluxo Modular de Projeto subtração.
Duas bus macros são responsáveis por a comunicação dos sinais de entrada que são a saída dos registradores.
Os barramentos de entrada, ao todo formam 8 bits (2 bus macros).
O módulo adder/ sub recebe então os valores oriundos das saídas dos registradores F1 e F2 e opera sobre estes.
O resultado então é transmitido por um barramento de saída de 4 bits (l bus macro) conectado a um display da plataforma.
A calculadora é composta por dois módulos reconfiguráveis combinacionais (adder e sub).
Esta calculadora foi prototipada no FPGA e foram feitos dois testes:
Primeiramente carregase o dispositivo reconfigurável com um bitstream inicial de soma e logo após carrega- se o dispositivo com um módulo reconfiguravel de subtração.
Depois foi feito outro teste utilizando um bitstream inicial de subtração e então carregou- se um módulo reconfigurável de soma.
Quando uma determinada configuração das chaves foi fixada e quando o sinal get_ data ficou em nível lógico 0 por o disparo manual de um botão da plataforma associado ao get_ data, o display mostrou o resultado da operação corretamente.
Quando se reconfigurou o FPGA com outro bitstream parcial, o display foi modificado indicando o resultado correto referente a esta nova funcionalidade reconfigurada.
Para o posicionamento das bus macros, usou- se pinos de E/ S para alimentar as mesmas.
Pinos de alimentação da bus macro devem estar associados a uma area (fixa ou reconfiguravel).
Para cada fronteira entre módulos reconfiguráveis e fixos/ reconfiguráveis, devem ser reservados dois pinos para alimentação das bus macros.
Em este projeto foi observado que qualquer sinal, inclusive sinais que comunicam pinos de E/ S que atravessem a fronteira entre as áreas fixa e reconfiguravel precisam obrigatoriamente de bus macros.
Todos os pinos que são utilizados por o módulo fixo foram incluídos na area fixas definida por a ferramenta Floorplanner.
Finalmente foi feito um experimento utilizando como bitstream inicial os módulos capture e adder.
Depois de carregar o dispositivo reconfiguravel com este bitstream, foi feita nova carga do dispositivo com um bitstream parcial que armazena o módulo adder.
Observou- se o comportamento dos displays da plataforma de prototipação e notou- se que não houve absolutamente nenhuma mudança comportamental no circuito.
Inicialmente foi feito a soma dos valores 6 e 4.
O display da plataforma mostrou o valor 10.
Quando foi feita reconfiguração do módulo de adição novamente, o valor mostrado no display não se alterou.
Mesmo experimento foi feito utilizando um bitstream total com o módulo sub.
Depois de carregas- lo no FPGA, foi feita a carga do bitstream parcial que armazena o módulo sub.
Observando o comportamento dos displays, novamente não houve nenhum distúrbio de comportamento do circuito, nem antes, nem durante, nem depois da reconfiguração.
O circuito contador realiza uma contagem de O a 9 numa determinada freqüência.
Existe um módulo fixo que captura os dados de entrada que são passo (A) de contagem (contagem pode ser t1 $= 0+ A, tg $= t1+ A, t3 $= t2+ A) e o módulo reconfiguravel é responsavel por a implementação do contador.
A funcionalidade do módulo fixo e muito semelhante ao módulo utilizado por a calculadora reconfiguravel.
No entanto, foram criados dois módulos reconfiguráveis:
Um contador de freqüência de l Hertz e outro contador de freqüência de 4 Hertz.
Foram feitas sucessivas configurações no FPGA e os resultados foram corretos.
Alternou- se os dois módulos reconfiguráveis e os dois tiveram o comportamento desejado.
Este estudo de caso utilizam dois módulos reconfiguráveis seqüenciais simples.
Para evitar erros no momento da reconfiguração parcial em circuitos síncronos, deve- se utilizar DCMs, como ja comentado no Capítulo 4.
O circuito não funciona mais depois da reconfiguração parcial em versões preliminares do projeto.
Em a Figura 5.3, e mostrado um esquemático do circuito reconfiguravel.
Usa- se um registrador para armazenar o valor de entrada definido por o pino get_ data, exatamente da mesma forma que no exemplo do circuito combinacional mostrado na Figura 5.2.
O contador mencionado na Seção anterior foi implementado com o encapsulamento de protocolo de comunicação OCP entre o módulo fixo e o módulo reconfiguravel.
O módulo capture, por ser o inicializador do sistema, e por requisitar serviços para os módulos de contagem (c_ zip/ c_ up_ faster), foi encapsulado com um invólucro OCP mestre.
Os módulos de contagem foram encapsulados com um invólucro OCP escravo.
O protocolo foi validado através da ferramenta CoreCreator.
Foi usado o protocolo de comunicação de sinais básicos do OCP como mostrado na Figura 3.7.
A Figura 5.4 mostra um diagrama de temporização do contador OCP.
5 geLdal a l.
De acordo com o protocolo de comunicação mostrado na Figura 3.7: O módulo de captura (mestre) faz uma requisição ao modulo de contagem (escravo) apresentando os sinais Mcmd:
WR, Maddr e Mdata.
Este último sinal representa o passo de contagem do sistema aqui apresentado.
Um ciclo de relógio após, o escravo responde com o sinal ScmdAccept em nível lógico 1.
O mestre então requisita uma leitura gerando o sinal Mcmd:
RD; O módulo escravo passa a responder para o mestre enviando um sinal de resposta Sresp:
DVA e o dado (Sdata) que é a saída do contador, a ser mostrado no display do FPGA;
Quando as chaves são modificadas por o usuario, o passo de contagem é atualizado quando o usuario dispara o sinal get_ data ativando um botão na plataforma de prototipação;
O circuito foi prototipado e o comportamento dos dois núcleos IP foi conforme o comportamento esperado.
Foi feita a reconfiguração parcial e dinâmica usando núcleos IP com interfaces de comunicação padronizadas, usando protocolo OCP.
Em este circuito, existe um módulo de captura dos dados chamado de capture e foram implementados 2 módulos reconfiguráveis:
Um módulo denominado contador_ up que conta em ordem crescente e outro módulo chamado de contador_ down que realiza a contagem em ordem decrescente.
Em a plataforma existem um display de 7 segmentos de dois dígitos.
Em este estudo de caso, cada dígito e associado a uma area reconfiguravel.
Através do fluxo do Projeto Modular, foram gerados 4 bitstreams parciais:
Contador_ up e contador_ down para uma area reconfiguravel e estes mesmos circuitos de contagem desenvolvidos para a outra área reconfiguravel.
Inicialmente os dois dígitos do display contam em ordem crescente.
Quando faz a reconfiguração carregando o dispositivo com um bitstream parcial, dependendo da area a ser reconfigurada, o dígito do display associado a esta area mostra uma contagem decrescente.
A mesma reconfiguração foi feita na outra área reconfiguravel obtendo- se assim o comportamento desejado dos quatro bitstreams parciais.
Em o desenvolvimento deste circuito, foi observada uma dificuldade no que diz respeito ã delimitação das areas do circuito.
A ferramenta de mapeamento gerou erros quanto a estas delimitações.
Estes erros foram sanados a partir de testes modificando a delimitação das areas através da ferramenta Floorplanner.
Este foi o primeiro estudo de caso usando duas áreas reconfiguráveis.
A partir de a especificação da memória localizada no módulo de comunicação da plataforma VZMBIOOO, foi desenvolvido um controlador de memória dividido em dois módulos:
Um módulo reconfiguravel chamado cliente, o qual recebe e envia dados de/ para memória e o outro que implementa o protocolo de comunicação entre o cliente e a memória SRAM conforme ilustrado na Figura 5.5.
Um módulo reconfiguravel cliente escreve um determinado valor na memória.
O outro módulo reconfigurãvel cliente escreve um outro dado na memória.
Em nível de simulação e prototipação deste circuito estaticamente, os resultados foram obtidos com sucesso, validando funcionalmente o circuito.
Porém com a inclusão das bus macros para a comunicação entre os módulos e depois da execução do Huxo do Projeto Modular, os bitstream totais e parciais gerados por este não funcionaram adequadamente no dispositivo reconfiguravel.
Por alguma razão indeterminada até o momento, as bus macros estão alterando a temporização do protocolo de comunicação entre os dois módulos (fixo e reconfiguravel), tornando instável o acesso a memória SRAM.
Foram realizados varios ajustes no Huxo sem sucesso.
Contactou- se o suporte da Xilinx e espera- se resposta para a resolução de eventuais erros de temporização causadas por as bus macros.
De acordo com, o tempo de reconfiguração total do FPGA Virtez H de 1 milhão de portas equivalentes da plataforma V2 MB1000, no modo de configuração mais rápido medido (Master SelectMAP) leva em torno de 7.5 ms a uma freqüência de configuração de 60 MHz.
O modo de configuração Master SelectMAP não pode ser usado para reconfiguração parcial e dinâmica.
Porém, o tempo de reconfiguração neste modo de configuração tem a mesma ordem de grandeza que a configuração realizada usando o módulo ICAP (Internal Confi gumtion Access Port) do FPGA.
Este componente permite o acesso à porta de configuração do dispositivo.
Desenvolvendo um hardware para acessar esta porta de configuração, e possível realizar a configuração a uma freqüência maxima de 33 MHz.
Porem este componente não foi usado corretamente segundo razões descritas em.
Através dos tempos na freqüência maxima de transmissão que foram extraídos para reconfiguração total para o modo de configuração Master SelectMAP (Figura 5.6), é possível fazer estimativas de tempo de reconfiguração parcial, sabendo que o tempo da mesma é proporcional ao tamanho do bitstream.
A Figura 5.7 mostra a estimativa dos tempos de reconfiguração em função de o tamanho do bitstream.
Segundo existem apenas dois modos de configuração que permitem reconfigurar parcialmente o FPGA.
Estes modos são denominados Boundary-Sean e Slave SelectMAP.
Todos os estudos de caso foram reconfigurados parcialmente usando o modo Slave SeleetMAP através do cabo USB (Universal Serial Bus), pois este é o mais rapido modo de configuração via cabo.
Através da implementação e execução dos estudos de caso descritos ao longo deste Capítulo, foram extraídos alguns tempos de reconfiguração usando cabo USB.
Estes dados são mostrados na Tabela 5.1.
Para desenvolvimento do emulador de SclcctMAP, na plataforma V 2 MB1000, foram cstudados os sinais que sào usados no modo SelectMAP.
Entre este sinais, existe um sinal de relógio que controla a configuração do FPGA.
Este sinal é denominado CCLK.
De acordo com este sinal mostrado na Figura 5.8, a diferença entre o tempo de amostragem da borda de subida da primeira oscilação do sinal e o tempo de amostragem da borda de descida da última oscilação do mesmo resulta no tempo de reconfiguração do FPGA (At).
O tempo em que leva para os dados do bitstream serem carregados para o FPGA é determinado por a variável Atm mostrada na Figura 5.8.
A variável Atmst (intervalo de tempo de dados para sincronização) é determinada atraves da equação abaixo:
Aires¡: At 7 Aim¡ Carvalho fez experimentos para possibilitar a redução do tempo de reconfigu ração.
Em este trabalho, foram analisados todos os sinais da interface selectMAP durante o processo de configuração.
A partir de aí, foi desenvolvido um circuito que emula 0 modo slave selectMAP da plataforma descrita nesta Seção.
Carvalho observou que era possível realizar melhorias no emulador através de alguns eventos percebidos:
Identiflcou-se que o tempo total de Configuração poderia ser reduzido a 1/3 do tempo original na configuração via software.
Isso foi possível porque os primeiros quatro pulsos de relógio de configuração, mostrados na Figura 5.8, possuíam uma freqüência desnecessariamente baixa em relação a os demais que compunham ao processo de configuração em si;
Identificou- se também que os pulsos de relógio após o último pulso que envia dados de configuração eram desnecessários.
De essa forma, pode- se remover estes ciclos;
Gradativamente aumentou- se a freqüência de operação do emulador até 12 MHz;
Carvalho diminuiu empiricamente o período dos ciclos de sincronização na ordem de poucos microssegundos, onde Aires;
&quot;Atm, obtendo então At z Atm.
Carvalho ainda conseguiu reduzir o tempo representado por Atm para uma ordem de grandeza através do aumento da freqüência de operação do emulador.
Para certificar o correto funcionamento desse emulador, foi implementado um sistema em duas placas de prototipação.
A primeira de elas contém a lógica reconfiguravel.
A segunda contém o emulador SelectMAP.
As duas plataformas foram conectadas, ligando os dados gerados por o emulador a interface SelectMAP de outra plataforma através de fios externos.
Assim, a segunda plataforma reconfigura parcialmente o dispositivo da primeira plataforma, transformando a lógica original desta.
A Figura 5.9 apresenta uma comparação dos tempos de reconfiguração extraídos no modo slave selectMAP e usando o circuito emulador desenvolvido por Carvalho.
Analisando os resultados, houve uma redução com o uso do emulador, em média, de obteve 740 ms de tempo de reconflguração usando cabo USB, este bitstream obteve 42 ms de tempo de reconfiguração com o uso do emulador em relação a a freqüência de operação do cabo usado.
Note- se que este último valor é ainda maior que os 7.5 HIS de configuração obtidos no modo Master SelectMAP.
Esta diferença ocorre porque o gargalo de configuração é a freqüência maxima de operação para acesso à memória SRAM externa da plataforma VZMBIOOO (24 MHz para o controle usado).
É possível realizar reconfigurações parciais de forma eficiente com esta proposta de emulador.
Processador Reconfigurâvel Para validação de um estudo de caso maior usando o fluxo do Projeto Modular, adicionouse módulos reconfiguráveis e instruções de acesso aos módulos num processador existente desenvolvido por o grupo local de trabalho.
O sistema RS Reconfiguravel (RSR) é composto por dois núcleos IP:
Um processador que contém instruções adicionais para acesso a um núcleo reconfiguravel (RSR); (
ii) núcleos reconfiguráveis chamados de coprocessadores reconfiguráveis que podem ter suas funcionalidades alteradas de acordo com a execução do programa no processador RSR.
Em este estudo de caso usa- se um processador load-store de 16 bits chamado de R8.
O processador R8 faz parte de uma família de processadores, concebida com a finalidade de dar suporte ao ensino de conceitos de arquitetura e organização de computadores em nível de graduação e pós-graduação.
Esse processador e uma maquina Von Neuman, com memória de dados e instruções conjunta.
Este apresenta um formato regular de instrução:
Todas as instruções tem exatamente o mesmo tamanho, ocupando uma palavra de 16 bits.
A instrução contem código de operação e a especificação dos operandos, no caso que estes existam.
Este processador é uma máquina RISC, porém ainda faltam algumas características tão comuns na maioria dos processadores RISC tais como pipeline.
As principais características organizacionais específicas neste processador multi-ciclo são:
Dados e endereços de 16 bits;
Banco de registradores com 16 registradores de propósito geral;
4 flags de status:
Negativo, zero, carry e ouerflow;
A execução das instruções requer 2 a 4 ciclos de relógio.
Os ciclos são assim denominados:
Ciclo 1 -- busca de instruções;
Ciclo 2 -- leitura de registradores;
Ciclo 3 operação com a ULA e ciclo 4 -- escrita dos resultados;
O conjunto de instruções do processador realiza as seguintes operações:
Operações lógicas e aritméticas binárias (com 3 operandos):
Soma, subtração, E, Ou;
Ou exclusivo.
Operações lógicas e aritméticas com constantes curtas:
Soma; Subtração;
Operações unarias:
Deslocamento para direita ou para a esquerda e inversão (NOT);
Carga de metade de um registrador com uma constante (LDL e LDH);
Inicialização do apontador de pilha (LDSP) e retorno de subrotina (RTS);
NOP (no operation):
Operação nula;
HALT: Suspende a execução de instruções;
Load: Leitura de posição de memória para um registrador (LD);
Store: Armazenamento de dado de um registrador numa posição de memória (St);
Saltos e chamada de subrotina com endereçamento relativo com deslocamento curto ou longo (contido num registrador) e endereçamento absoluto (a registrador);
Inserção e remoção de valores em o/ do topo da pilha (PUSH e Pop);
O processador R8 conta com o seguinte conjunto de registradores de 16 bits:
Ir (Instruction Register):
Armazena o código de operação (opcode) da instrução atual e o (s) operando (s) desta;
PC (Program Counter):
É o contador de programas do processador R8;*
SP (Stack Pointer):
Armazena o endereço do topo da pilha;
Controla a chamada e retorno de subrotinas.
Deve ser inicializado a cada programa com a instrução LDSP (carrega endereço do topo da pilha);
16 registradores de propósito geral rotulados de R0 a R15.
O banco de registradores tem uma porta de escrita e duas de leitura.
Isto significa que é possível escrever em apenas um registrador por vez, é possivelmente realizar duas leituras simultâneas;
A Figura 6.1 mostra um diagrama de blocos processador-memória.
O processador recebe do mundo externo dois sinais de controle:
Clock, que sincroniza os eventos internos ao processador;
E reset, que inicializa o processador para iniciar a execução de instruções a partir de a posição zero da memória.
O bloco de controle gera a microinstrução para execução das instruções.
A microinstrução é responsável por comandar as ações que serão executadas no bloco de dados, como habilitação de escrita em registradores, controle de multiplexadores no bloco de dados, operação que a ULA executará e acesso a memória externa.
O bloco de dados envia para o bloco de controle a instrução corrente (conteúdo do Ir) e os qualificadores de estado (flags).
Os sinais para a troca de informações com a memória são:
Data e address.
O controle de acesso à memória é feito por o bloco de controle, através dos sinais ce e rw.
O sinal ce indica se esta em curso uma operação com a memória e o sinal rw indica se esta operação e de escrita ou de leitura.
É importante ressaltar que os blocos de dados e de controle operam em fases distintas do sinal clock.
Em uma borda do clock (por exemplo, subida) o bloco de controle gera a micro-instrução, e na borda seguinte (descida) o bloco de dados modifica os registradores.
Com isto sempre se tem dados estáveis nas transições de relógio em cada um dos blocos.
80 Capítulo 6: Processador Reconfigurável O desenvolvimento do processador RBR é um projeto desenvolvido como uma das contribuições deste trabalho.
Este emprega conceitos de processadores que contém um conjunto de instruções dinâmico, denominados Dynamic Instruction Set Computers ou DISCs, tratados por Wirthlin e Hutchings.
Tal projeto propõe o desenvolvimento de um processador dinamico e parcialmente reconfiguravel (processador RSR), baseado na estrutura do processador R8.
O processador RSR permite a execução de varios coprocessadores numa mesma area do FPGA através da reconfiguração parcial e dinâmica.
O sistema RSR prototipado consiste em ter um módulo fixo denominado de processador RSR (sistema de um processador RSR e uma memória) e um módulo reconfiguravel chamado coprocessador (coprocessador reconfiguravel).
O módulo fixo é responsavel por agregar cinco módulos:
Processador B8B:
Este módulo e o processador R8 modificado para prover controle dos coprocessadores reconfiguráveis.
O processador executa funções em software e também requisita ao coprocessador que este execute determinada função;
Memória RAM:
Responsavel conectar os módulos serial e processador R8 em memórias blockRAMs do FPGA;
Serial: Este módulo permite a comunicação do sistema RSR com um PC hospedeiro.
O software do lado do hospedeiro e um software elaborado por o grupo local para enviar e receber dados por a interface serial do computador.
Este envia dados para o sistema R8R incluindo carga da memória com o código-objeto que o processador RSR vai executar.
O sistema hospedeiro também pode receber dados do sistema RSR atraves de leitura da memória do mesmo;
Barramento: Módulo responsável por o tráfego de dados que ocorrem entre os módulos serial, processador RSR e memória;
Árbitro: Módulo responsavel para definir qual é o módulo que vai ter acesso ao barra mento num determinado instante;
Para que o processador pudesse interagir com módulos, estes foram interconectados atraves de um barramento compartilhado.
Em este, foi implementado uma política de acesso por os coprocessadores e processador.
Foi implementado um árbitro de barramento responsavel por iniciar e monitorar todas as requisições feitas ao barramento.
Como mostrado na Figura 6.2, os módulos processador R8R, serial e memória são com o nectados ao barramento.
O coprocessador que esta localizado na area reconfiguravel esta conectado diretamente com o processador RSR através de sinais de dados e controle.
O módulo controlador de configurações é usado para reconfigurar coprocessadores por demanda gerada por o processador R8R (via software).
Seu detalhamento esta fora de o escopo deste trabalho e encontra- se em.
Ainda na Figura 6.2 mostra os sinais que fazem a interconexão entre o processador RSR, coprocessadores reconfiguráveis e o controlador de configurações.
Bus Macros Bus Macros Bus Macros Área Reconfigurável 1 Área Reconíigurável N Área Fixa 4¡ Olntervupt¡ Oce Memúna Loca¡ Iovesel 4\ Odalagn\ Odalajut o\ «4 u'* m..
Para obter a funcionalidade desejada do processador R8R, as seguintes características foram adicionadas ao processador R8 original:
Suporte para conexão de um ou mais coprocessadores reconfiguráveis, de acordo com o protocolo de comunicação entre o RSR e o coprocessador;
Interface de 16 bits de dados com o coprocessador reconfiguravel;
Interface de 11 bits com o controlador de configurações, responsavel por envia arquivos de configurações sob demanda no dispositivo reconfiguravel;
Adição de 5 novas instruções para seleção (SELR), inicialização (INITR), leitura (RDR), escrita (WRR) e disabilitação (DISR) de coprocessadores reconfiguráveis conforme detalhado na Tabela 6.1;
82 Capítulo 6: Processador Reconfigurável Urn protocolo de comunicação é utilizado entre o processador RSR e o coprocessador ormado por 8 sinais:
I Oce:
Sinal ativo em 71», que permite ao processador acessar o coprocessador identificado por o sinal I0address;
IOIntermpt: Sinal ativo em T. Este sinal indica o termino de execução do coprocessador.
Se este sinal estiver desabilitado e se for executada uma operação de leitura (instrução RDR) no coprocessador, a execução da instrução ficara esperando até que o sinal[ Olnterrupt seja habilitado.[
Oaddressz barramento de oito bits que contém o endereço para identificação do coprocessador.
Este é selecionado quando seu identificador é idêntico ao Valor transmitido por este barramento;
I Orw:
Sinal para modos de operação leitura/ escrita que o processador requisita ao coprocessador.
Este sinal corresponde a escrita de dados do processador para o coprocessador, em &quot;1 «corresponde a operação de leitura;
IOreSet: Sinal ativo em baixo, que inicializa um coprocessador identificado por 10m l dress;
IOack: Sinal ativo em 71», utilizado para um coprocessador sinalizar que recebeu deter minado dado ou realizou uma operação com sucesso;
I0data_ in:
Barramento de 16 bits utilizado para permitir que o processador possa ler dados do coprocessador identificado por IOaddress;
IOdata_ out:
Barramento de 16 bits utilizado para permitir que o processador possa escrever dados no coprocessador identificado por I0address;
Três sinais foram adicionados ao processador RSR para prover comunicação deste com o controlador de configurações:
I Oaddress:
Este e utilizado também para a comunicação entre o coprocessador e o processador;
Este sinal é utilizado para identificação do coprocessador que sera reconfigurado e acoplado no processador;
Req_ reconf:
Sinal usado para requisitar uma dada configuração identificada por IOad dress ao controlador de configurações;
I ack_ reconf:
Sinal para informar ao processador que a reconfiguração do coprocessador foi terminada.
A partir de aí, o processador continua sua execução normal;
Req_ remove:
Sinal para informar ao controlador de configurações que o coprocessador identificado por o sinal IOAddress foi removido logicamente;
As instruções SELR e DISR avisam o controlador de configurações para remover ou inserir módulos identificados no barramento I OAddress.
Estas instruções têm carater bloqueante.
Em a implementação dos coprocessadores, e comum estabelecer que sempre seja enviado uma palavra de 16 bits de comando e a seguir, uma palavra de dados de 16 bits do processador para o coprocessador.
A partir de as simulações do comportamento geral do processador RBR, sera explicado detalhadamente o protocolo de comunicação entre o processador e o coprocessador.
Depois de descrever o sistema RSR em VHDL, usou- se um software (Modelsim e Active HDL) para simulação funcional do comportamento do circuito.
Foi escrito um software em linguagem de montagem para que fosse possível ao processador RSR acessar e obter os resultados da execução do coprocessador reconfiguravel.
Foram desenvolvidos inicialmente cinco coprocessadores reconfiguráveis para validar o sistema RSR:
Coprocessador que executa a média de dois valores.
Simulação na Figura 6.4;*
4-Lwg: Coprocessador que executa a média de quatro valores.
Simulação na Figura 6.3;*
sqrt: Coprocessador que executa a raiz quadrada de um número de 32 bits e o resultado é um valor de 16 bits.
Simulação na Figura 6.6);
Multi: Coprocessador que executa a multiplicação de dois valores.
Simulação na Figura* div:
Coprocessador que executa a divisão inteira de dois valores gerando o quociente e o resto da operação.
Simulação na Figura 6.8;
Todos os coprocessadores são identificados por um endereço.
A Tabela 6.2 apresenta os coprocessadores e seus endereços respectivamente.
Em a Figura 6.3 é mostrado um diagrama de tempos extraído da simulação de hardware do coprocessador 4-avg.
Os passos da simulação do coprocessador 4-avg são descritos a seguir:
A instrução B12D é carregada.
Então o procedimento de escrita dos conteúdos dos registradores 1 e 2 é realizado.
I Odata_ out e mais uma vez, o coprocessador ativa I Oack para que o processador continue executando a instrução.
O identificador de estados denominado pr_ st_ cap mostra o estado atual da maquina de estados que implementa a lógica do coprocessador.
As instruções B34D, B56D, e B78D também são executadas da mesma forma.
Estas quatro últimas instruções escrevem respectivamente um comando e um dado.
O comando faz com que a maquina de estados do coprocessador avance e o dado é utilizando como um operando da média de 4 valores.
Os dados escritos em seqüência são 0104h, OFFIh, 0 FCFh e OFAOh;
A leitura dos dados oriundos do coprocessador se deve através destes procedimentos:
A instrução BBCE é executada e significa que o coprocessador vai escrever dados nos registradores r11 e r12 do processador RSR;
O sinal de IOce deve estar ativo e o sinal de[ Orw deve estar inativo para informar ao coprocessador que o processador requisita a leitura dos dados.
A leitura só sera feita se o sinal IOInterrupt estiver habilitado, indicando termino da execução do coprocessador.
Então o coprocessador envia no registrador rll um dado informando o status e no registrador r12 a resposta da média dos quatro números previamente escritos no coprocessador A Figura 6.4 apresenta a simulação do coprocessador que realiza a média de 2 operandos.
Os passos da simulação do coprocessador E- (wg são descritos a seguir, da mesma forma como ocorre na Figura 6.3: IOdata_ out..
Os dados 0001 (neste caso, este dado significa um comando que o coprocessador reconhece) e OFCFh (dado para calculo da média) são enviados serialmente para o coprocessador.
Para cada dado enviado, o coprocessador ativa IOack avisando que o processador RSR pode continuar a execução da instrução atual.
De a mesma forma acontece na instrução B38D para o envio do comando 0002 e do dado FAOh;
BBCE através dos procedimentos apresentados na Figura 6.3 para leitura para requisição e leitura dos dados do coprocessador.
Desta forma, o coprocessador envia no registrador r11 um dado informando o status e no registrador r12 a resposta da media dos dois números previamente escritos no coprocessador (valor FB7h).
A Figura 6.5 apresenta a simulação da instrução SELR utilizada para a seleção de um coprocessador reconfigurável.
Os passos da simulação da instrução SELR são descritos a seguir:
A instrução B02B é carregada e executada;
O sinal req_ reconf é ativado informando ao controlador de configurações para que seja feita a reconfiguração de um novo coprocessador;
A Figura 6.6 apresenta o diagrama de tempos da execução do módulo sqrt.
Os diagramas de tempos dos coprocessadores sqrt, multi e divide utilizam uma variação dos protocolos de comunicação dos módulos Q-avg e 4-avg.
Os items abaixo mostram cada passo da simulação do coprocessador sqrt.
Para definir o protocolo de comunicação deste módulo, deve- se seguir as regras de seleção, inicialização e uso de sinais de acesso ao coprocessador como foi mostrado nas Figuras 6.3 e 6.4.
O processador envia um valor através do sinal IOdata_ out para o coprocessador através de uma instrução &quot;wrr».
Desta forma, e iniciado o processo de execução do coprocessador sqrt;
Quando o sinal[ Olnterrupt estiver habilitado, o coprocessador terminou sua execução.
Este sinal é habilitado depois de 26 ciclos de relógio depois do início da instrução &quot;wrf», Então a instrução &quot;rdr «é executada.
O sinal IOdatzLin recebe o resultado da raiz quadrada.
Em esta simulação, logo após a execução da instrução &quot;wrr», o processador executa outras instruções em paralelo com a execução do coprocessador.
O sinal rdr é executado, neste caso, depois da execução do coprocessador.
A simulação do coprocessador mult também apresenta esta caracteristica.
A Figura 6.7 apresenta o diagrama de tempos da execução do módulo multi.
Este módulo é responsável por a execução da multiplicação de dois valores.
Os items abaixo mostram cada passo da simulação do coprocessador multi:
O processador envia um valor através do sinal IOdata_ out para o coprocessador através de uma instrução &quot;wrr&quot;;
Executando uma outra instrução &quot;wrr», IOdata_ out envia um outro valor.
A partir dai, começa a execução do coprocessador multi;
Depois de 19 ciclos de relógio, o sinal I Olnterrupt é habilitado, e então a instrução &quot;rdr «0EE2h);
A Figura 6.8 apresenta a simulação do módulo div.
Este coprocessador executa a divisão inteira entre dois valores resultando no quociente e resto.
Os items abaixo mostram cada passo da simulação do coprocessador div:
O processador envia um valor atraves do sinal IOdata_ aut para o coprocessador o valor do dividendo através de uma instrução &quot;wrr», Executando uma outra instrução &quot;wrr», IOzIata_ out envia o valor do divisor.
O processo de execução do coprocessador é iniciado;
Depois de 32 ciclos de relógio, o sinal[ Olnterrupt é habilitado, e então a instrução &quot;rdr «é executada totalmente.
O sinal I0data_ in recebe o resultado do resto e da divisão Em esta simulação, o processador executa a instrução de leitura (instrução &quot;rdr&quot;) antes do término de execução do coprocessador.
Então o processador bloqueia a sua execução e espera o término da execução do coprocessador.
Quando o coprocessador termina sua execução, o processador é liberado e executa a instrução de leitura.
Conforme a Figura 6.8.
Depois da execução da simulação do sistema como um todo com os cinco coprocessadores (não no mesmo sistema), prototipou- se a RSR usando o fluxo do Projeto Modular.
Em o sistema, foram inseridos DCMs e bus macros para 0 provimento de compensação de propagação do sinal de relógio e comunicação entre as areas fixa e reconfigurãvel respectivamente.
Foram inseridos 11 bus macros instanciadas no código HDL e posicionadas nos arquivos de restrições para a comunicação dos sinais entre o processador e o coprocessador.
Depois da inserção de todos os componentes e arquivos necessarios para a execução do fluxo, deve- se sintetizar logicamente cada arquivo fonte (arquivos de maiores níveis hierárquicos e os módulos coprocessadores).
Em seguida, executar o fluxo usando como entrada os arquivos gerados por a síntese lógica e, arquivos de restrição do usuário e arquivos de macros provida por o fabricante.
Depois da execução do fluxo do Projeto Modular e ao termino da geração dos bitstreams totais e parciais, para a validação em hardware varios passos são necessarios.
Primeiro foi feito a configuração do bitstream total do sistema RSR com o coprocessador 4-avg acoplado.
Foi previamente desenvolvido software que primeiramente executa instruções para acessar o coprocessador 4-avg e depois executa instruções para acessar os coprocessadores Z-aug, sqrt, multi e div.
O primeiro software encontra- se no Apêndice A. 1, faz a média de 4 valores.
Em a Tabela O software é transferido para a memória da RSR atraves de um software em JAVA desen volvido por o grupo local.
A Figura 6.9 mostra uma tela desta aplicação.
Depois de enviar o software para a RSR, deve- se então disparar o processamento da mes Como o controlador de configurações estava em desenvolvimento durante a fase de im plementação do sistema RSR, foi elaborado um meio de prototipar o sistema sem 0 uso do controlador7 conforme descrito a seguir, emulando este usando chaves e displays da platafor ma.
Para que fosse feita à reconfiguração parcial, inicialmente alguns sinais de saída do processador R8 foi mapeado em leds, botões da plataforma, além de se empregar um analisa dor lógico para observação de pinos selecionados do FPGA.
Abaixo são apresentados os sinais 92 Capítulo 6: Processador Reconfiguràvel que foram mapeados:
I req_ reconf:
Este sinal foi mapeado num led da plataforma.
Quando o processador requisita uma dada configuração, o led acende;
I0address: Este barramento foi mapeado num analisador lógico identificando qual é o coprocessador que sera reconfigurado;
Ack_ reconf:
Sinal associado por um botão da plataforma servindo para avisar que a reconfiguração do coprocessador identificado por[ Oaddress ja foi terminada e também informar que o processador já pode continuar a sua execução;
Quando a luz do led acender, então deve- se configurar o FPGA com o arquivo de configuração parcial identificado no analisador lógico, ou seja, deve- se configurar o FPGA com o coprocessador Q-aug através de um software e hardware de configuração.
Depois que a reconfiguração parcial for realizada, então deve- se pressionar o botão do FPGA que ativa o sinal aCÍíJ_ reconf para que o processador possa continuar sua execução.
Depois de realizar sucessivas reconfigurações parciais de acordo com o identificador amostrado no analisador lógico, o software termina de executar, enviando um aviso para a serial.
Para capturar os resultados, deve- se então realizar um dumpl na memória.
A Tabela 6.4 mostra o conteúdo da memória (exceto instruções) depois da execução do software.
Os resultados dos registradores rll e r12, no software, foram armazenados na área de dados do programa definido nas coordenadas Dl a I2 da Tabela 6.4.
O dado B006 definido nas posições Bl a C1 e a última instrução do programa (HALT).
Os valores do coprocessador 4-avg armazenados em R11 e R12 foram armazenados nas posições de memória apontados por D1 a E1 e H1 a Il (valor da resposta da média OOCCh).
Os valores do coprocessador Q-aug armazenados em R11 e R12 foram armazenados respectivamente nas posições de memória B2 a C2 e F2 a G2.
As respostas da execução dos coprocessadores multi, div e sqrt estão armazenados respectivamente nas posições B4 a C4, D5 a E5 e B6 a C6.
Através destes resultados valida- se funcionalmente a reconfiguração parcial e dinamica nos coprocessadores da RSR.
Em a execução, foram encontrados erros de sincronismo de relógio e corrigidos.
O problema foi causado por um sinal conectado ao DCM e que este sinal atravessou a fronteira entre a área fixa e reconfigurável.
Solucionou- se este problema com a inserção de uma bus macro neste sinal.
Em o sistema R8R, foram desenvolvidos vários coprocessadores reconfiguráveis, segundo o que consta neste Capítulo.
Os bitstreams parciais que implementam coprocessadores que executam operações matemáticas tais como raiz quadrada, divisão e multiplicação tem em média um tamanho de 46 Kb.
Segundo as medidas extraídas do gráfico da Figura 5.9, o tempo de reconfiguração feito via cabo USB foi cerca de 400 ms..
Porém com o uso do emulador, é possível realizar uma reconfiguração num tempo de 10 ms.
Para avaliar o desempenho quanto a velocidade de cada coprocessador, admitiu- se aqui o uso do tempo de reconfiguração de 10 ms..
Desenvolveu- se versões em softwares com a mesma funcionalidade para cada um dos coprocessadores reconfiguráveis.
De este modo, pode ser feita uma analise comparativa entre os tempos reconfiguração e execução dos módulos reconfiguráveis versus o tempo de execução em software.
A seguir, serão discutidos os resultados iniciais de avaliação do tempo de execução de cada um dos coprocessadores reconfigurãveis.
Em o Apêndice A2 é apresentado o software que foi executado na RSR.
Este software não acessa nenhum coprocessador, apenas executa as instruções nativas do processador R8.
A Figura 6.10 mostra um gráfico comparativo entre os tempos de execução do software em relação a o número de operações e o tempo de reconfiguração e execução do coprocessador em relação também ao número de operações, supondo que versões de software e hardware sejam iteradas de forma ininterrupta.
A partir de um certo número de operações, as retas se cruzam.
Isto significa que a partir de 750 operações, a reconfiguração parcial do coprocessador de multiplicação é mais eficiente em termos de tempo de execução que uma implementação em software.
Uma observação importante é que assume- se o software começando a ser executado ao mesmo tempo que o coprocessador a ser reconfigurado.
A execução do coprocessador só é inicializada depois da reconfiguração.
Os tempos de execução do software foram extraídos através da contagem do número de ciclos de relógio do software assumindo uma freqüência de relógio de 24 MHz para o processador.
Os tempos de execução do hardware foram extraídos através da contagem do número de ciclos de relógio da execução do coprocessador a uma freqüência de 24 MHz.
Em o Apêndice A. 3 é apresentado o software de divisão que foi executado na RSR.
A Figura número de operações e o tempo de reconfiguração e execução do coprocessador em relação também ao número de operações.
As condições de cálculo dos tempos são idênticas as do estudo de caso anterior.
Em o ponto de cruzamento das duas retas, nota- se que há ganho o uso do coprocessador reconfigurável ao invés de a execução do software a partir de a execução de 300 operações de divisão, antes de uma nova configuração.
As curvas referentes a operação dos coprocessadores implementados em hardware representam uma abordagem do pior caso.
Isso porque os experimentos foram desenvolvidos usando apenas uma area reconfiguravel.
Se o sistema possuir diversas áreas reconfiguráveis, o tempo 96 Capítulo 6: Processador Reconfigurável de reconfiguração pode ser escondido, assim obtendo um ganho de desempenho global do sistema.
Para melhor entendimento da importancia do uso dos coprocessadores em contraproposta as rotinas em software pode- se imaginar um sistema de software que aplica uma série de filtros em imagens.
Se esses filtros aplicam multiplicações, divisões, medias de valores e raízes quadradas constantemente, muito tempo poderá ser ganho utilizando os coprocessadores de alto desempenho, ainda mais se esses filtros forem aplicados a diversas imagens ou se as mesmas forem de grande tamanho.
Duas das mais importantes vantagens do processador implementado utilizando técnicas de reconfiguração dinâmica e parcial são o aumento da densidade funcional e da flexibilidade do sistema, conforme mencionado no Capítulo 1.
Tal Hexibilidade permite a modificação do sistema em tempo de execução, com razoável facilidade, através da adição de outros copro cessadores.
Conclusão e Trabalhos Futuros O presente trabalho apresentou:
Uma proposta de método de geração de bitstreams parciais baseada no Huxo de Projeto Modular;
Uma ferramenta para automatizar a aplicação do fluxo de Projeto Modular e, diversos estudos de caso, inclusive um estudo de caso de complexidade maior:
Processador RSR, gerados por o fluxo do Projeto Modular.
Pode- se compreender, neste trabalho, o cenário atual do desenvolvimento de SDRs.
Ficou evidenciada a falta de ferramentas para o projeto e suporte a implementação de sistemas desta natureza.
Embora diversos estudos sejam realizados enfatizando o uso de reconfiguração parcial e dinâmica, os fabricantes ainda não disponibilizam dispositivos que habilitam a sua reconfiguração dinamica e parcial de uma forma mais facilmente integravel ao fluxo de projeto tradicional de sistemas computacionais.
O fluxo de projeto convencional não se adequa corretamente ao projeto de SDRs e, na grande maioria dos casos e necessario utilizar estratégias alternativas para desenvolver SDRs, tal como o fluxo de Projeto Modular, proposto por a Xilinx e detalhado no Capítulo 4.
O uso do fluxo do Projeto Modular para desenvolvimento de SDRs foi motivado por o desenvolvimento de circuitos reconfiguráveis num nível de abstração maior que os níveis de abstração providos por a maioria das ferramentas usadas hoje para atingir este objetivo.
A documentação provida por a Xilinx sobre a execução do fluxo mostrou- se incompleta.
Muitos passos da execução do fluxo foram omitidos nesta documentação.
Muitos procedimentos adicionais foram criados neste trabalho a partir de extensa pesquisa.
Para automatizar a execução do fluxo, foi desenvolvida uma ferramenta que gera automaticamente bitstreams totais e parciais de um dado sistema reconfiguravel.
Em o desenvolvimento de circuitos, quando se emprega a reconfiguração, um grau de liberdade a mais e inserido no projeto e no emprego de SOC, pois núcleos IPs podem ser desenvolvidos em diversas versões, ao invés de serem parametrizados.
Porém, na maioria das aplicações embarcadas o interesse é custo final baixo, o que não e razoável de conseguir com o uso de hardware reconfiguravel.
Em este trabalho, foram apresentados estudos de caso de circuitos reconfiguráveis, mostrando 98 Capítulo 7: Conclusão e Trabalhos Futuros dificuldades encontradas na execução do fluxo, resolução de tais dificuldades e análise dos resultados.
Com a implementação de estudos de caso desenvolvidos usando o fluxo do Projeto Modular, foi possível tornar factível a reconfiguração parcial e dinamica, possibilitando o desenvolvimento de produtos comerciais.
Desenvolveu- se um estudo de caso maior (processador RSR) que apresenta resultados satisfatórios que viabilizam o uso da reconfigurabilidade.
Os coprocessadores reconflguraveis conectados ao processador RSR apresentam maior desempenho que implementações em software, desde que o coprocessador seja usado um certo número de vezes antes de empreender uma nova reconfiguração da area do coprocessador.
Também foi observado que há um compromisso entre o tamanho do bitstream parcial e o tempo de reconfiguração.
Quanto menor a área que ocupa o bitstream parcial, menor o tempo de reconfiguração.
A reconfiguração parcial e dinâmica aplicada nos estudos de caso foi executada através de cabo USB, tornando o processo de reconfiguração lento.
Teoricamente, o modo mais rápido de reconfiguração seria a utilização do módulo ICAP, o qual permitiria o acesso a porta de configuração do dispositivo reconfigurável.
Porém, segundo Carvalho, a documentação precária e a falta de suporte da empresa de FPGAs Xilinx impossibilitou o uso do componente ICAP.
E possível, para um conjunto de aplicações restrito, que se possa encontrar um ponto viável nesta comparação entre o hardware reconfiguravel e estático.
Para desenvolvimento de SDRs para aplicações com potencial comercial, a redução dos tempos de reconfiguração e o uso de mais de uma área reconfigurável, para que seja possível paralelizar varias reconfigurações, diminuindo o tempo total de reconfiguração, são imprescindíveis.
Exemplos de tais aplicações comerciais são filtros de imagem, os quais podem realizar operações que podem estar implementados em módulos reconfiguráveis.
A contribuição científica deste trabalho pode ser resumida em quatro aspectos:
Domínio do fluxo do projeto proposto por a XAPP290;
Proposta da parte de uma infraestrutura de reconfiguração para desenvolvimento de SDRs para mostrar a real possibilidade de se utilizar estes sistemas desenvolvidos por essa infraestrutura para estudos de casos reais;
Ferramenta para automatização do fluxo para geração de SDRs;
E tutorial extenso que complementa a documentação da Xilinx XAPPZQO, resumidamente descrito no Capítulo 4.
Como trabalhos futuros, citam- se:
Conclusão da prototipação da RSR com duas áreas reconfiguráveis e realizar analises de desempenho;
Desenvolvimento de mais coprocessadores reconflguráveis para o processador RSR.
Estes devem executar processamento exaustivo para comprovar o uso de reconfiguração em relação a circuitos estáticos;
Acréscimo de um módulo que insira automaticamente bus macros na ferramenta MDLaun Cher sem que o projetista precise explicitas- las no código-fonte;
Desenvolvimento de um mecanismo para posicionar estrategicamente os componentes no FPGA tais como LUTs, DCMs e buffers objetivando evitar erros de roteamento explicados na Seção 4.3;
Adaptação do fluxo do Projeto Modular para o desenvolvimento de SDRs com duas ou mais áreas reconfiguráveis;
Implementação de estudos de casos mais complexos, como por exemplo:
Varios precessadores reconfiguráveis acoplados a um sistema de interconexão (barramentos, NoCs (Network-on-Chip).
O trabalho realizado contribui também de forma estratégica, para o desenvolvimento e a implementação de SDRs.
Através de ele, pôde- se melhor entender o processo de criação de arquivos de configuração parciais, cruciais para o desenvolvimento de SDRs.
