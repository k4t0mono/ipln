Em o desenvolvimento de aplicações paralelas, além de a análise de aspectos ligados ao desempenho, torna- se também importante a análise das propriedades funcionais do sistema para garantir, por exemplo, que a estratégia de paralelização escolhida é adequada ao problema sendo abordado, ou que ela pode convergir para um resultado esperado, ou mesmo para identicar a possibilidade de um cenário de bloqueio na computação.
A garantia de correção sobre o modelo de uma aplicação paralela, além de aumentar o grau de conança nos resultados, pode também ser um fator de economia, já que possibilita a redução no tempo despendido no desenvolvimento e depuração da aplicação.
Porém, uma vez identicados os problemas e correções no modelo analisado, ainda existe a necessidade de se mapear as mudanças necessárias à aplicação original.
Em esse sentido, vericação formal e geração automática de código podem ser utilizadas como ferramentas complementares durante o desenvolvimento, possibilitando tanto a análise do comportamento do sistema quanto a rápida geração do código correspondente ao modelo proposto.
Este trabalho apresenta o uso de Gramática de Grafos Baseada em Objetos (GGBO) para a construção de aplicações paralelas, a partir de a denição de um método de tradução de modelos GGBO para código C, utilizando MPI como plataforma de comunicação.
Referencial Linguagens Grácas Ferramentas para Geração de Código Gramáticas de Grafos Baseadas em Objetos Tradução Semântica do Modelo Traduzido Propriedade III Mensagens podem ser consumidas em qualquer ordem.
112 Propriedade I Todas as mensagens com match são consumidas Estudos de Casos Conclusão Referências Bibliográcas Lista de Tabelas Lista de Figuras Hierarquia de padrões para sentenças LTL.
Modelo para Vericação Regras.
Modelos PROMELA Escolha de par MensagemRegra e Consumo de Mensagem.
108 Lista de Siglas Message Passing Interface Gramática de Grafos Baseada em Objetos Uniform Memory Access NonUniform Memory Access NonRemote Memory Access Scalable Coherent Interface Computed Aided Design Unied Modeling Language Pisa Parallel Programming Language Single Program Multiple Data Parallel Virtual Machine Remote Procedure Calls Network File System HeNCE Heterogeneous Network Computing Environ-ment ComputationOriented Display Environment DPnDP Design Patterns and Distributed Processes Correct ObjectOriented Patternbased Parallel Programming System Computation Tree Logic Lógica Temporal Linear BackusNaur Form PROcess Meta LAnguage Simple Promela INterpreter Association for Computing Machinery Tipo Abstrato de Dado 1 Introdução Clusters ou agregados são máquinas de alto desempenho que possuem uma arquitetura baseada na reunião de um conjunto de estações de trabalho independentes, interconectadas por uma rede de comunicação de baixa latência, formando uma plataforma de execução para aplicações paralelas.&amp;&amp;&amp;
Cada estação possui uma memória local, a qual somente os processadores locais tem acesso.
Em esse contexto, o MPI (Message Passing Interface) é um padrão bastante difundido para interface de passagem de mensagens para aplicações que utilizam computadores com memória distribuída.
Ele não oferece nenhum suporte para tolerância a falhas e assume a existência de comunicações conáveis.
Sistemas concorrentes1, mesmo os mais simples, podem apresentar comportamentos bastante difíceis de predizer.
Aspectos como condições de corrida e deadlocks podem surgir e comprometer seu funcionamento, mesmo quando a solução algorítmica apresentada inspirar um alto grau de conança.
Assim, no desenvolvimento de aplicações paralelas deve- se atentar ao correto funcionamento do sistema além de o seu desempenho.
Tal fato motiva a realização de análises como simulações, vericação e provas formais de maneira a aumentar a qualidade das soluções implementadas.
Além de aumentar o grau de conança nos resultados, a garantia de corretude sobre uma aplicação paralela pode ser um importante fator de economia já que reduz o tempo computacional de um cluster (que é um recurso caro) despendido com a realização de testes durante o desenvolvimento.
Numerosas tentativas no desenvolvimento de ferramentas para programação paralela usam abstração para reduzir o nível de complexidade no desenvolvimento, de forma que os usuários possam desenvolver rapidamente programas corretos.
A maioria dessas ferramentas visa princi1 O uso da palavra concorrência neste documento refere- se a sistemas onde várias ações podem estar habili-tadas num dado instante.
A ocorrência de tais ações de forma simultânea ou intercalada depende da forma de implementação do sistema.
Gramática de Grafo Baseada em Objetos (GGBO) é um formalismo para modelagem de sistemas concorrentes onde os elementos comunicam- se através de troca de mensagens, oferecendo um alto nível de abstração para modelagem.
Por ser baseada num conjunto simples de elementos e ter uma semântica formal, permite a descrição sem ambigüidades de sistemas concorrentes.
Por ser formal, permite o mapeamento para vericadores e simuladores, possibilitando análises sobre o comportamento dos sistemas modelados, bem como prova de propriedades dos mesmos.
Tanto GGBO quanto MPI apresentam unidades concorrentes distinguíveis, comunicação por troca de mensagens assíncronas, supõem ambientes comportados com relação a falhas e não impõem limites de atraso aos processos ou à comunicação (modelo assíncrono de computação).
Esse trabalho apresenta a denição de um método automatizável de tradução de modelos GGBO em código fonte C e utilizando MPI como plataforma de comunicação, possibilitando a realização de um mapeamento direto entre o modelo denido e a implementação correspondente.
Os resultados obtidos trazem vantagens como permitir a especicação de aplicações paralelas utilizando linguagem com paralelismo implícito, aumentando o nível de abstração do projetista;
Myrinet e SCI.
O restante deste documento organiza- se da seguinte forma:
Em o Capítulo 2 são discutidos aspectos relativos à plataforma de comunicação e de execução a que se aplica o trabalho e aspectos sobre modelagem, programação e análise de sistemas concorrentes O Capítulo 3 apresenta o formalismo utilizado como base para a geração dos modelos.
Em o Capítulo 4 é introduzida a estrutura de tradução proposta, apresentando os elementos adotados em função de as restrições relativas à linguagem de modelagem, linguagem de programação e ambiente de execução en2 Desenvolvimento Formal e Simulação de Sistemas Reativos (FAPERGS/CNPQ) Métodos Formais para Código Móvel em Sistemas Abertos (FAPERGS/CNPQ) Centro de Análise de Sistemas Concorrentes (Hp-PUCRS) volvidos.
Em o Capítulo 5, Vericação de Modelos é utilizada para relacionar o comportamento apresentado por o código gerado e a semântica associada à linguagem GGBO.
Estudos de caso visando exemplicar a utilização da metodologia proposta são apresentados no Capítulo 6.
Finalmente, são apresentadas considerações sobre o estudo desenvolvido, assim como discutidos trabalhos futuros dentro de a mesma proposta.
Em esse capítulo será introduzido o referencial teórico relativo aos temas envolvidos neste trabalho.
Inicialmente serão abordados conceitos gerais sobre paralelismo:
A motivação em seu uso, classicação de arquiteturas paralelas e as abordagens utilizadas no tratamento paralelo de tarefas.
São também discutidos aspectos sobre a detecção de parada em sistemas distribuídos, um tema que ganhará maior importância em seções futuras.
Após isso, serão discutidos aspectos sobre modelagem de sistemas paralelos, apresentando uma argumentação favorável à utilização de modelos para sua elaboração e análise.
São analisados alguns exemplos de linguagens para modelagem de aplicações paralelas, linguagens de programação propriamente ditas e bibliotecas de comunicação para linguagens seqüenciais.
Em este paralelas, Encerrando esta parte do volume, são discutidos elementos sobre vericação formal de modelos, sua aplicação em sistemas paralelos e limitações no seu uso.
São apresentadas a linguagem de especicação de propriedades e a ferramenta de vericação de modelos a ser utilizada no decorrer deste trabalho.
Historicamente, existe uma demanda crescente por poder computacional.
Apesar de o contínuo aumento da velocidade de processamento e capacidade de armazenamento obtidos por a indústria de equipamentos computacionais (Lei de Moore), existe uma ampla gama de aplicações onde mesmo o mais rápido computador tradicional não pode operar num tempo razoável.
Tais tarefas representam uma demanda imediata, sendo inviável esperar por o aumento da velocidade dos componentes a ponto de viabilizar a sua realização.
Uma das maneiras de aumentar o poder computacional é a utilização de múltiplos processadores operando juntos numa mesma tarefa.
O problema maior é dividido em partes, cada uma de as quais é realizada por um processador operando em paralelo com os demais.
A plataforma computacional um computador paralelo pode ser um computador especialmente projetado, contendo múltiplos processadores interconectados por um barramento, ou mesmo vários computadores independentes conectados através de uma rede de baixa latência.
A presença de múltiplos processadores num sistema distribuído abre caminho para a possibilidade de diminuição no tempo de resposta de uma tarefa intensiva em processamento.
Ainda, a existência de múltiplos dispositivos de armazenamento (memória, disco rígido) permite o tratamento de um volume de informação maior que o possível num sistema uniprocessado, tanto por questões de tamanho quanto de vazão de dados.
Além de o aumento de desempenho, podem ser apontados ainda outros fatores favoráveis ao uso de paralelização em sistemas computacionais:·
Simplicação do projeto através da especialização:
O desenvolvimento de um sistema computacional pode se tornar uma tarefa bastante complicada, especialmente se uma gama muito ampla de funcionalidades for requerida.
Assim, o projeto pode ser simplicado separando o sistema em módulos, com cada um implementando uma parte das funcionalidades requeridas e comunicandose com os demais.
Cada módulo pode tomar vantagem de características especícas do hardware onde é executado (periféricos, memória), sendo possível ainda um ajuste no do código para garantir o uso ainda mais eciente desses recursos.·
Compartilhamento de Recursos: Mesmo com a progressiva diminuição do custo dos equipamentos, tornando praticável equipar cada funcionário de uma empresa com um computador, o mesmo não é verdade para todos os periféricos como por exemplo impressoras, scanners e unidades de disco de alta capacidade, ou mesmo softwares com restrições especícas.
Em uma escala menor cada computador pode utilizar um servidor dedicado para prover serviços como compiladores ou gerenciar o uso de um dispositivo.·
Aumento da conabilidade através da replicação:
Sistemas distribuídos têm o potencial de se tornarem mais conáveis do que sistemas uniprocessados devido a a sua propriedade de falha parcial (partial failure).
Falha parcial signica que alguns elementos do sistema podem falhar, enquanto outros ainda continuam operando corretamente e podem assumir as tarefas do elemento falho.
Uma falha numa aplicação uniprocessada impossibilita o funcionamento do sistema como um todo.
Um sistema de alta conabilidade tipicamente consiste em duas ou mais unidades de processamento que rodam uma aplicação e utilizam um mecanismo de voto para ltrar os resultados obtidos.
Além de protocolos de eleição, o correto funcionamento de um sistema distribuído em presença de falhas requer suporte algorítmico adequado, como por exemplo detecção de falhas, recuperação, etc..
Tais mecanismos fogem do escopo denido nesse trabalho.
Computadores paralelos consistem basicamente em três partes principais:
Processadores, módulos de memória e meios de comunicação.
A rede de conexão interliga os processadores entre si, assim como a memória em alguns casos.
Uma classicação utilizada pra caracterizar máquinas paralelas diz respeito ao custo de acesso à memória.
Uma máquina paralela é dita Uma (Uniform Memory Access) quando todos os elementos de processamento acessarem a memória ou módulos de memória a um mesmo custo.
De outra maneira, quando por questões de topologia ou distribuição dos módulos de memória, existirem diferentes possibilidades de atraso na comunicação com esses módulos, a arquitetura é chamada Em uma (NonUniform Memory Access).
Quando cada um dos elementos de processamento de uma máquida paralela possui uma memória local, à qual só ele tem acesso, a arquitetura é chamada Norma (NonRemote Memory Access).
Clusters são máquinas paralelas Norma de alto desempenho que possuem uma arquitetura baseada na reunião de um conjunto de estações de trabalho independentes, interconectadas por uma rede de comunicação de baixa latência.
Estas máquinas paralelas também são referenciadas (NOWs).
Clusters constituem uma plataforma de execução de aplicações paralelas que têm ganhado bastante destaque por o custo acessível de implantação e por a escalabilidade oferecida.
Por ser baseado em estações de trabalho comuns funcionando como nodos de processamento na estrutura, uma máquina como essa pode ser construída a partir de componentes oftheshelf, encontrados a preços acessíveis, podendo ainda ser posteriormente ser ampliada através da compra de mais nodos.
A rede de intercomunicação utilizada pode ser baseada em padrões bem conhecidos como Ethernet, ou outras alternativas desenvolvidas especicamente visando maior desempenho como SCI e Myrinet.
Diversos fatores facilitam a geração de aplicações paralelas para a execução nessa plataforma.
A arquitetura utilizada nos nodos facilita a adaptação dos compiladores já existentes para a geração de código executável.
Existe também uma ampla gama de bibliotecas de programação adequadas a essa arquitetura, disponíveis para linguagens de programação convencionais, assim como um conjunto considerável de linguagens de programação especícas para ambientes paralelos.
Finalmente, existem ferramentas para o gerenciamento do recursos (e.
g), possibilitando um fácil acesso aos nodos, inicialização e controle de execução.
Programas concorrentes consistem numa coleção de processos e estruturas de acesso comum a esses processos usados para a comunicação.
Cada processo pode ser considerado como um subprograma seqüencial sendo executado em paralelo com os demais dentro de um mesmo programa maior 1.
Os objetos compartilhados permitem aos programas cooperar para a execução de uma tarefa em outros momentos além de seu início e término, trocando dados e informações de controle.
Basicamente, são utilizados dois mecanismos de comunicação:·
Memória Compartilhada:
Em arquiteturas com memória compartilhada, os processos se comunicam escrevendo dados em posições especícas de memória, as quais podem ser acessadas por os demais processos participantes.
Quanto utilizando tal estratégia de comunicação tornase necessário identicar quando é possível ler ou escrever os dados de maneira que a informação permaneça consistente.
Estruturas de controle padrão em sistemas operacionais como semáforos ou monitores são usados para tal propósito.·
Troca de Mensagens:
Quando não existir à disposição uma memória compartilhada entre os processos, estes podem compartilhar dados através de troca de mensagens.
O processo empacota a informação numa mensagem com um cabeçalho indicando a qual processador Em ambientes paralelos devese distinguir o paralelismo virtual de um programa, que corresponde ao número de processos lógicos independentes contidos nesse programa (dependente, pois, da lógica de execução utilizada), do paralelismo físico, relativo ao número de processos que podem estar ativos num determinado momento (que é menor ou igual ao número de processadores numa máquina paralela).
Esses mecanismos de comunicação não precisam corresponder diretamente ao que a arquitetura oferece.
É possível simular troca de mensagens usando memória compartilhada, assim como é possível simular memória compartilhada usando troca de mensagens (uma técnica conhecida como virtual shared memory).
Uma das mais fortes razões para a utilização do paradigma de troca de mensagens está na sua aplicabilidade direta a computadores conectados através de uma rede.
A rede de intercomunicação é o mecanismo que permite aos processadores comunicaremse entre si e com os módulos de memória.
A topologia dessa rede é o arranjo completo das ligações individuais entre os elementos de processamento, sendo naturalmente representada como um grafo.
A latência de uma rede de comunicação é o maior tempo necessário para qualquer par de elementos de processamento se comunicarem.
O desempenho (ou performance) de um programa é usualmente expresso em termos de seu tempo de execução.
Isso depende tanto da velocidade individual de cada processador quanto do arranjo da comunicação, além de a capacidade dos meios de comunicação em tratar o uxo de dados.
Em a busca por melhorias no desempenho de aplicações paralelas, podem ser encontrados na literatura um conjunto de padrões comuns para o fracionamento e distribuição das partes do problema sendo paralelizado.
De entre essas estratégias, destacamse as seguintes abordagens:·
MestreEscravo: Essa abordagem pode ser utilizada quando uma tarefa maior puder ser dividida em partes menores sem dependência entre si.
De essa forma, cada subtarefa pode ser tratada independentemente por um processo escravo distinto, sendo os resultados enviados de volta para o mestre.
Em a abordagem Bagoftasks, o mestre possui um conjunto grande de subtarefas, que são enviadas uma a uma para cada escravo.
Mediante o particionamento apropriado da tarefa o que muitas vezes não é uma decisão trivial podese conseguir um bom balanceamento de carga entre os nodos escravos.·
Pipeline: Essa abordagem é bastante utilizada em hardware para aumentar a vazão total do sistema.
Se existe um conjunto identicável de passos a ser realizado numa seqüência especíca, um algoritmo semelhante a uma linha de montagem pode ser utilizado, destinandose um elemento de processamento para cada atividade a ser desempenhada.
Cada passo é realizado por um processo diferente, sendo que a saída de um processo é tomada como entrada para o próximo, e assim sucessivamente.
Após um determinado número de passos, o pipeline ca cheio, e a vazão aumenta signicativamente, uma vez que cada estágio da linha de montagem está efetivamente atacando uma tarefa em paralelo.
Se o tamanho da tarefa a ser realizada não for signicante, a abordagem em pipeline não é eciente devido a o overhead necessário para encher o pipeline.·
Dividir e Conquistar:
Dentro de a abordagem &quot;dividir e conquistar», o processamento é feito a partir de sucessivas divisões da tarefa a ser executada.
O nodo inicial (raiz) avalia se o trabalho a ser desempenhado pode ser realizado localmente.
Em caso negativo, ele delega partes da tarefa para dois ou mais processos escravos.
Cada processo escravo decide se pode tratar a tarefa ou se é melhor realizar mais uma divisão do trabalho e delegar novamente as partes a outros processos.
De essa forma, a divisão da tarefa leva os processos a assumirem uma topologia em árvore para o tratamento do problema.
Quando o processamento nos nodos folha é terminado, os resultados são repassados para o processo pai, que pode realizar algum processamento adicional sobre esses resultados antes de novamente repassar os valores obtidos.
Esse processo continua sucessivamente, até que o nodo raiz processe o resultado nal.
Um problema potencial dessa abordagem recursiva está em certicarse que existe uma condição de terminação para a condição de particionamento, evitando assim que processos continuem a ser disparados indenidamente.·
Fases Paralelas: Em essa tipo de abordagem, todos os processos sincronizam suas computações regularmente durante a execução, garantindo que todos os participantes tenham terminado uma fase do processamento antes de iniciar a próxima.
Todos os processos iniciam uma etapa num mesmo momento, executando uma operação (e.
g, um barrier) em uníssono.
Dependendo do tipo de abordagem utilizada no tratamento do problema, podese compor um cenário em o qual o grande desacoplamento entre os participantes torne difícil identicar quando a computação distribuída como um todo tenha atingido um determinado estado em que o processamento possa ser declarado terminado.
Em a próxima seção esse problema é formalizado, sendo discutidos brevemente algumas classes de soluções possíveis.
Desde que foi proposto em 1980 por Francez e por Dijkstra e Scholten, o problema da terminação distribuída constitui um tema clássico em sistemas distribuídos, devido a sua importância prática e teórica.
Considerando a execução de uma aplicação distribuída (chamada computação primária), o objetivo é construir um programa de controle que detecte a terminação da computação primária.
Tal detecção não é trivial, uma vez que num sistema distribuído onde os processos se comuniquem unicamente através de troca de mensagens, em geral nenhum processo tem uma visão atualizada do estado global do sistema.
Para a especicação de um algoritmo de controle, é assumido o seguinte modelo para a computação primária genérica, ao qual qualquer aplicação paralela pode ser enquadrada:
Uma computação distribuída é considerada globalmente terminada quanto i.
Cada processo está localmente terminado;
Para que a identicação seja possível, a computação primária deve ser modicada de forma que o algoritmo de controle possa obter informações sobre o estado atual de cada elemento.
Isso é feito através da geração de mensagens de controle, destinadas ao algoritmo de controle, associadas a determinadas transições do algoritmo primário.
Essas mensagens de controle não alteram o estado da computação primária.
A computação é considerada terminada quando o algoritmo combinado (primário mais algoritmo de controle) alcançar um estado que respeite ambas as condições impostas.
Note que o algoritmo de controle pode tanto ser executado por apenas um dos processos participantes do sistema, quanto ser uma tarefa distribuída por todo o conjunto.
Uma solução possível é o uso de pooling, onde periodicamente um coordenador testa todos os processos, inspecionando seu estado (ativo ou bloqueado).
Assim, uma vez que tenha conrmado o estado bloqueado para todos os processos, ele pode concluir que a computação efetivamente terminou.
Essa solução não garante uma identicação rápida do estado do sistema um ciclo inteiro, no pior caso além de possibilitar falsos positivos quando ainda existirem mensagens em trânsito por os mecanismos de comunicação.
Existem muitas classes de soluções para o problema da detecção.
As mais importantes são algoritmos baseados em Probe, algoritmos baseados em Acknowledgements e algoritmos baseados em Contagem de Mensagens.·
Algoritmos baseados em Probe:
Um Probe é uma tarefa distribuída que visita todos os processos na rede.
Ela pode ser implementada como um token circulando um anel, por exemplo.
Para a detecção utilizando probes, tentase identicar um estado em que todos os processos visitados estejam bloqueados, e nenhuma mensagem esteja em trânsito destinada a um processo visitado.
Uma violação ocorre quando um processo não visitado envia uma mensagem a um processo visitado.
Quando isso ocorre, o probe corrente é marcado como inválido, e depois de sua nalização outro é iniciado.
A terminação é detectada quando o probe passa por todos os nodos sem encontrar violações.
Um exemplo desse tipo de algoritmo é dado em, e um tratamento geral em.·
Algoritmos baseados em Acknowledgements:
Em essa classe de algoritmos, toda a mensagem primária é conrmada (acknowledged), mas somente após toda a atividade computacional resultante de ela ter cessado.
Isso é, se um processo ativo recebe uma mensagem, ele a conrma imediatamente.
Se um processo bloqueado recebe uma mensagem, ele defere a conrmação até se tornar bloqueado novamente e ter recebido a conrmação de todas as mensagens que tenha originado após o desbloqueio, durante seu período de atividade.
Quando todos os processos estejam bloqueados e tenham recebido conrmações de todas as mensagens primárias, a terminação é identicada.
Generalizações sobre essa classe podem ser encontradas em.·
Algoritmos baseados em Contagem de mensagens:
Mantendose um controle do número de mensagens primárias geradas no sistema, é possível determinar se existe informação em trânsito por os mecanismos de comunicação, evitando assim a ocorrência de falsos positivos.
Em a Seção 4.1.5 é apresentada em maiores detalhes uma solução utilizando essa estratégia.
A escolha de um algoritmo de detecção num sistema que busque desempenho deve considerar a extensão em que o algoritmo de detecção interfere (e atrasa) o uxo principal de processamento.
O número absoluto de mensagens de controle não é um caracterizador único desse fator, uma vez que muitas dessas mensagens de controle são geradas/ processadas por participantes que não estão engajados na computação principal.
O volume de mensagens geradas gera impacto, porém, no tráfego da rede sendo utilizada.
Esse efeito é amortizado por exemplo, quando a rede sendo utilizada apresentar baixa latência e alta conabilidade.
Em e é argumentado que o principal fator a ser considerado na decisão por um algoritmo de detecção é o tempo necessário para identicar a parada.
Existem muitos fatores que tornam o atraso de detecção o fator mais importante a ser considerado.
Primeiro, esse atraso signica desperdício de recursos computacionais.
Além disso, em muitas aplicações (e.
g A programação paralela difere em vários aspectos da programação de um sistema seqüencial, modelo com o qual a maioria dos desenvolvedores tem seu primeiro contato.
A intercalação de estados possíveis entre os processos dentro de um sistema paralelo é difícil de predizer, dicultando a identicação da causa do problema com técnicas tradicionais de depuração de programas usados para algoritmos seqüenciais.
Ainda, considerandose as diferenças entre as várias plataformas de execução e comunicação possíveis, têmse um quadro bastante propenso a erros de programação durante o desenvolvimento.
São listadas como as três maiores fontes de erros em programas paralelos:·
Erros semânticos:
Esses erros são causados por equívocos sobre o modelo de programação paralela sendo utilizado e sua aplicação para o problema em questão.
Por exemplo, erros podem surgir devido a o não entendimento apropriado dos mecanismos de compartilhamento de memória entre os processos e da semântica da linguagem utilizada.·
Erros de implementação:
Esses erros ocorrem devido a a complexidade extra inerente à utilização de programação paralela, como o lançamento de processos, comunicação e sincronização.
Erros incluem o empacotamento/ desempacotamento (packing/ unpacking) de uma mensagem ou a criação de um cenário de deadlock.·
Erros de performance:
São erros causados por a falta de intuição ou experiência acerca de os custos de paralelismo e concorrência.
Por exemplo, essa classe de erros inclui a execução de segmentos de programas em grãono utilizando mecanismos de sincronização que restringem a concorrência.
Os dois primeiros erros normalmente resultam num programa que executa de maneira incorreta, ou mesmo impossibilitam a geração de um executável.
O terceiro tipo de erro geralmente leva a programas que rodam corretamente, porém com um ganho de desempenho baixo quando comparados com a solução seqüencial correspondente.
A utilização de ferramentas para a geração automática de código paralelo possibilita evitar os dois primeiros problemas naturalmente, uma vez que libera o usuário da necessidade de trabalhar aspectos especícos à linguagem e bibliotecas de comunicação utilizadas.
O terceiro erro, por sua vez, pode ser contornado através da especialização do gerador utilizado, de modo a guiar o usuário em direção a um modelo mais adequado durante o desenvolvimento.
Tais ferramentas tomam como entrada uma descrição um modelo do sistema a ser gerado, expressos seguindo algum padrão, formalismo ou metodologia de especicação.
Um modelo de computação paralela é uma interface separando propriedades de alto nível de propriedades de baixo nível.
Ele provê uma descrição do sistema considerado, focando os elementos mais diretamente envolvidos.
Retome como exemplo a descrição apresentada na Seção 2.3.2, onde a denição do problema e das soluções correspondentes é feita sobre um modelo bastante abstrato e simples, apresentando somente as características necessárias.
Tal abstração permite a denição de uma solução genérica e facilita seu mapeamento para aplicações reais.
Mais concretamente, um modelo para implementação é uma máquina abstrata que provê certas operações para o nível superior e requer uma implementação para cada uma dessas operações provenientes de um nível inferior.
É utilizado para separar conceitos de projeto de software de conceitos de execução paralela e provê tanto abstração quanto estabilidade.
Abstração é oferecida devido a as operações que o modelo disponibiliza são de um nível mais alto do que aquelas oferecidas por a nível/ arquitetura subjacente, simplicando a estrutura do software e diminuindo a diculdade em sua construção.
Estabilidade é obtida porque o desenvolvedor pode assumir uma interface padrão, válida mesmo quando mudanças ocorrerem nos níveis inferiores da arquitetura paralela2.
Ainda, o modelo funciona como um ponto de partida para os esforços de implementação (transformação do sistema, tradução, compilação) direcionados a cada máquina paralela.
Modelos existem nos mais diferentes níveis de abstração.
Por exemplo, cada linguagem de programação pode ser considerada um modelo, dado que todas provêm uma visão simplicada do hardware subjacente.
Dentro de as várias possibilidades, um bom modelo de computação paralela deve oferecer as seguintes propriedades:
Facilidade de utilização;
Metodologia de desenvolvimento;
Independência de arquitetura;
Fácil compreensão;
Desempenho e custo previsível.
A seguir, são discutidas cada uma dessas propriedades.
I) Facilidade de utilização:
Um modelo deve ocultar ao programador detalhes que ele não seja capaz de controlar durante o desenvolvimento do sistema.
A exata estrutura do programa a ser executado pode ser inserida por o mecanismo de tradução (ou compilação) em vez de o programador.
Por exemplo, uma linguagem de modelagem pode abstrair ao programador elementos como decomposição do programa em threads, mapeamento das threads entre os processadores, comunicação e sincronização.
Modelos devem ser o mais abstratos e simples possível, dentro de a nalidade à qual se destinam;
Devem ser o mais próximo possível da forma natural de se descrever o programa e das necessidades da linguagem de programação.
Em alguns casos, isso pode signicar que o par2 Desde que os elementos afetados por a mudança sejam adequados à nova situação, o modelo pode permanecer inalterado.
V) Desempenho:
Um modelo deve oferecer um bom desempenho.
Note que isso não signica que a implementação deve extrair cada possibilidade em performance de uma determinada arquitetura.
Para a maioria dos problemas, um nível tão apurado de performance só pode ser obtido através de gastos consideráveis em depuração e especialização do código.
Essas características desejáveis para linguagens de modelagem podem ser bastante dispendiosas e estarem em conito entre si.
Por exemplo, modelos abstratos facilitam a elaboração de programas mas tornam difícil a geração do código correspondente, enquanto modelos de baixo nível, apesar de dicultar a modelagem, facilitam a tradução e implementação do sistema.
A seguir, são discutidos vários exemplos de linguagens para modelagem de aplicações paralelas.
Algumas apresentamse como linguagens de programação, enquanto outras são utilizadas como bibliotecas, ou mesmo dentro de ambientes especícos para o projeto semelhantes à ferramentas CAD (Computed Aided Design).
Cada uma dessas linguagens quantica de forma diferente as características apresentadas, denindo assim uma melhor ou pior adequação de seu uso durante o projeto o sistema.
A técnica utilizada por linguagens funcionais ditas higher order para avaliar as funções é chamada redução de grafos (graph reduction).
Segundo essa representação, as funções necessárias para a realização do processamento são expressas como árvores, utilizandose sub árvores comuns para armazenar funções compartilhadas.
Regras selecionam as subestruturas do grafo, que representam seqüências de operações passíveis de execução num dado momento.
O resultado correspondente toma o lugar da subestrutura original, reduzindo progressivamente o grafo para formas mais simples.
Quando nenhuma outra regra computacional puder ser aplicada, o grafo nal é tomado como resultado da computação.
O método graphreduction pode ser paralelizado aplicandose regras em seções distintas do onde f, a e b são representados como subárvores, threads podem avaliar independentemente cada uma de elas.
Apesar de elegante, essa estratégia de paralelização pode não levar a um aproveitamento eciente dos recursos da máquina.
Em o exemplo, apenas um de entre a e b necessitaria efetivamente ser calculado, porém a escolha somente é possível se existir uma serialização na avaliação (realizálas após o cálculo de f (x)).
Esse tipo de dependência é um limitador para o paralelismo possível na linguagem.
Haskell é um exemplo de linguagem que utiliza graphreduction, incluindo também muitas características típicas de linguagens funcionais como lazy evaluation, pattern matching e compreensão de listas.
Padrões para programação paralela existem há cerca de duas décadas em formas como skele-tons, templates e design patterns, por exemplo.
Skeletons e Templates correspondem a algum algoritmo padrão ou fragmento de algoritmo de uso comum dentro de a qual o usuário introduz o código dependente da aplicação.
A implementação de cada skeleton é realizada de maneira que eles possam ser compostos seqüencialmente ou paralelamente.
É necessária a disponibilização de uma implementação de cada bloco para cada arquitetura alvo desejada, sendo que cada bloco pode ocultar uma quantidade arbitrária de computação paralela.
Durante o desenvolvimento da aplicação, o programador seleciona os skeletons que deseja utilizar e compõe o programa.
O compilador ou gerador de código determina como o paralelismo intra e entre blocos será explorado para cada arquitetura alvo possível.
Design patterns são estruturas descritivas para trechos de código de uso comum.
Eles incluem um diagrama esquemático (muitas vezes em UML) e uma descrição que consiste em sete partes:
Objetivo, motivação, aplicabilidade, estrutura, participantes, colaborações, conseqüências, implementação, código fonte, usos conhecidos e padrões relacionados.
Em a maioria dos casos também existem pontos onde devem ser inseridos trechos adicionais de código.
Design patterns implementam padrões comuns para estruturas de interações entre processos encontradas em sistemas paralelos e seqüenciais, porém deixando nãoespecicados os procedimentos dependentes da aplicação.
Design patterns, Skeletons e Templates abstraem estruturas de ocorrência comum na comunicação em aplicações paralelas, permitindo que os usuários desenvolvam aplicações de uma maneira mais rápida e fácil.
Esta aproximação fortalece a corretude da aplicação paralela por fornecer estruturas de código de comunicação bem testadas que de outra maneira teriam que ser escritos manualmente por o usuário.
Pisa Parallel Programming Language (P3 L) é um exemplo de linguagem que utiliza um conjunto de skeletons que capturam paradigmas paralelos comumente utilizados como pipelines, bagoftasks e worker farms.
Por exemplo, um worker farm em P3 L é modelado por o seguinte construtor:
Quando o skeleton é executado, um determinado número de workers W é acionado em paralelo como os dois processos P (um gerador de dados, outro coletor).
Cada worker executa a função Skeletons são simples e abstratos.
Porém a expressividade de uma linguagem de programação baseada em skeletons ca limitada aos blocos oferecidos.
Ainda, a semântica heterogênea permitida por as diferentes implementações de um mesmo padrão para arquiteturas diferentes pode tornar difícil a formalização do uso de cada bloco.
Cellular processing expressam sistemas paralelos baseandose num modelo de execução de autômatos celulares.
Um autômato celular consiste num reticulado ndimensional de células, onde cada célula é conectada a um conjunto limitado de células adjacentes.
O estado de um autômato celular como um todo é denido por os valores das variáveis em cada célula.
A atualização do estado das células é feita em tempo discreto, em passos atômicos e simultaneamente em vários pontos do reticulado.
As células atualizam seus valores utilizando funções de transição que tomam como entrada o estado corrente da célula local e um subconjunto dos valores das células vizinhas.
Linguagens Celulares de Processamento como Cellang, CARPET, CDL, e CEPROL permitem descrever algoritmos celulares através da denição do estado das células como variáveis ou estruturas de variáveis, e as funções de transição contêm as regras de evolução de um autômato.
São disponibilizados construtores para a denição de padrões de vizinhança de um célula que são considerados na aplicação das regras.
Essas linguagens implementam autômatos celulares como programas SIMD ou SPMD, dependendo da arquitetura alvo.
Segundo o paradigma SPMD (Single Program, Multiple Data) algoritmos celulares são implementados como uma coleção de processos mapeados em diferentes elementos de processamento.
Cada processo executa o mesmo programa (no caso, denido por as funções de transição).
Assim, todos os processos executam, em paralelo, as mesmas regras locais, alterando a conguração do reticulado localmente.
Isso permite implementações escaláveis tanto para plataformas MIMD quanto SIMD.
Linguagens de Coordenação (Coordination Languages) buscam simplicar o projeto de sistemas paralelos separando aspectos relativos ao processamento da entrada de aspectos inerentes à comunicação dentro de o sistema, provendo uma linguagem separada para especicar essa comunicação.
Tal separação torna a computação e a comunicação ortogonais entre si, de modo que um esquema de comunicação em particular possa ser aplicado a muitas aplicações seqüenciais Um exemplo dessa classe de linguagens é Linda, onde a comunicação pontoaponto é substituída por um pool compartilhado (shared pool) em o qual dados são colocados e retirados associativamente.
Esse pool compartilhado é chamado espaço de tuplas.
O modelo de comunicação oferecido por a linguagem Linda contêm três operações:
In, que remove a tupla do espaço de tuplas, baseada em sua aridade e nos valores de alguns de seus campos, preenchendo os demais campos com os valores a partir de a tupla obtida;
Read (rd), que apenas copia a tupla do espaço de tuplas, sem removêla do pool;
E out, que inclui uma tupla no espaço de tuplas.
Linda oferece uma operação (eval (t)) para a criação de novos processos para avaliar o espaço de tuplas.
Por exemplo, uma operação rd( «P laneta,?
X, «Brasil) procura dentro de o espaço de tuplas por uma tripla contendo Planeta, uma variável do mesmo tipo que X, e ainda Brasil como terceiro elemento, copiando para X o valor presente na tupla encontrada.
O modelo Linda requer que o programador gerencie as threads de um programa, mas reduz os custos impostos no controle da comunicação.
Outra característica importante é a existência de uma metodologia de desenvolvimento de software associada à linguagem, oferecida por ambientes de programação como, por exemplo, o Linda Program Builder.
Tais ambientes tornam possível projetar, codicar, monitorar e executar programas utilizando essa linguagem.
Orca é uma linguagem baseada em objetos que utiliza objetos de dados compartilhados para a comunicação entre processos.
Orca baseiase num conjunto hierarquicamente estruturado de abstrações.
Em o nível mais baixo, broadcast conável é a primitiva básica de comunicação.
De essa forma toda escrita na estrutura compartilhada reetese nas réplicas locais mantidas por os processos, o que oferece a abstração de um elemento único compartilhado.
O paralelismo em Orca é obtido a partir de a criação explícita de processos.
Em a chamada, é possível especicar em qual processador/ nodo executar o processo lhe&amp;lhes o.
Ainda, os parâmetros denem qual o objeto compartilhado a ser usado para comunicação entre os processos criados.
Em o modelo de comunicação baseado em rendezvouz, uma interação entre dois processos A e B ocorre quando A chama uma entrada (entry) de B e B executa um accept para aquela entrada.
Uma chamada entry é similar a uma chamada de procedimento.
Uma chamada accept, por sua vez, envolve uma lista de ações a serem executadas quando a entrada é executada.
A linguagem mais conhecida baseada em rendezvouz é Ada.
O paralelismo na linguagem Ada é baseado em processos, chamados nesse contexto de tasks.
Uma task pode ser criada explicitamente ou ser estaticamente declarada.
Tasks são compostas em duas partes:
A primeira (chamada specication) é responsável por a especicação, denindo quais as ações realizadas por a Tasks.
A segunda parte, chamada body, dene como as ações a são executadas.
Declarações do tipo entry são permitidas apenas na parte de especicação de uma task.
As estruturas accept referentes às entradas declaradas aparecem no corpo de uma task.
Ada comporta de maneira nativa um mecanismo de manipulação de exceções para tratar falhas de software.
Outra característica importante oferecida por a linguagem Ada para a programação paralela é o uso da estrutura select para expressar nãodeterminismo de forma similar à estrutura encontrada em PROMELA, conforme será apresentado na Seção 2.6.
Java oferece multiprogramação e multiprocessamento baseados em threads, e permite a comunicação utilizando memória compartilhada através de variáveis de condição.
Essas variáveis são acessadas através de métodos synchronized.
Uma seção crítica protegendo o código do método é gerada automaticamente.
Existem ainda muitos outras bibliotecas que estendem linguagens convencionais possibilitando a comunicação entre processos, tanto através de memória compartilhada quanto de troca de mensagens.
Esse assunto será explorado na Seção a seguir.
As operações necessárias na implementação de sistemas baseados em troca de mensagens são muito semelhantes para arquiteturas de memória distribuída, o que facilita a elaboração de padrões de interfaces de comunicação nesses sistemas.
A implementação de tais padrões na forma de bibliotecas de comunicação, por sua vez, permite a sua utilização dentro de linguagens originalmente seqüenciais como Fortran e C. Tal possibilidade tem grande aceitação por parte de os desenvolvedores, uma vez que a utilização dessas linguagens lhes é familiar, representando um desão muito menor do que o oferecido por uma linguagem nova ou mesmo paradigma completamente diferente.
Em esse contexto, padrões como o MPI e PVM destacamse por a grande aceitação e larga utilização.
O MPI (Message Passing Interface) é um padrão de interface de passagem de mensagens para aplicações que utilizam computadores com memória distribuída.
Ele não oferece nenhum suporte para tolerância a falhas e assume a existência de comunicações conáveis.
O comitê MPI, criado em 1992, dene este padrão para os ambientes de passagem de mensagens, reunindo membros de aproximadamente 40 instituições e inclui quase todos os fabricantes de máquinas paralelas, universidades e laboratórios governamentais pertencentes à comunidade envolvida na computação paralela mundial.
Os principais objetivos são a padronização e eciência para fabricantes de hardware e plataformas portáteis.
Sua semântica foi escrita para ser independente da linguagem utilizada e visando denir uma interface de troca de mensagens que fosse possível de ser implementada ecientemente.
MPI dene um conjunto de rotinas para facilitar a comunicação (troca de dados e sincronização) entre processos paralelos.
A biblioteca MPI é portável para qualquer arquitetura, tendo aproximadamente 125 funções para programação e ferramentas para analisar o desempenho.
Atualmente, a biblioteca MPI permite que os programas possam ser escritos nas linguagens Fortran, C e C+.
O MPI não é um ambiente completo para programação concorrente, visto que ele não implementa I/ O paralelos, depuração de programas concorrentes, canais virtuais para comunicação e outras características próprias de tais ambientes.
Um conjunto de rotinas responsáveis por a comunicação pontoaponto entre os pares de processos forma o núcleo do MPI.
Todo paralelismo é explícito, ou seja, o programador é responsável por identicar o paralelismo e implementar o algoritmo utilizando chamadas aos comandos da biblioteca MPI.
São implementadas rotinas bloqueantes e não bloqueantes para enviar e receber mensagens.
A rotina que envia a mensagem no modo bloqueante não retorna enquanto a mensagem contida no buer não estiver segura.
Em o modo não bloqueante a rotina que envia a mensagem pode retornar enquanto a mensagem ainda está volátil.
A biblioteca disponibiliza tipos primitivos para o envio de dados em mensagens quanto rotinas para o encapsulamento de estruturas complexas.
MPI possui grupos de processos e rotinas para o gerenciamento dos grupos.
Os grupos podem ser usados para duas funções distintas.
Em a primeira os grupos especicam os processos envolvidos numa operação de comunicação coletiva, como um broadcasting.
Toda a comunicação ocorre dentro e através dos grupos.
Em a segunda eles podem ser usados para introduzir o paralelismo dentro de a aplicação, onde diferentes grupos realizam diferentes tarefas.
Cada grupo pode possuir códigos executáveis diferentes ou o mesmo código.
Recentemente, o padrão MPI foi atualizado por o comitê MPI.
A nova versão, MPI2, contém tanto modicações no núcleo do daemon MPI quanto novas características, incluindo I/ O paralela, operações de acesso remoto a memória e criação dinâmica de processos.
Outro modelo de troca de mensagens independente de arquitetura desenvolvido visando permitir o uso transparente de NOWs é chamado Parallel Virtual Machine (PVM).
PVM permite que um conjunto heterogêneo de computadores conectados por uma rede sejam utilizados por o programador como um único computador distribuído.
Esse padrão provê um conjunto de primitivas para a criação de processos e comunicação que são incorporada às linguagens de programação C e Fortran.
Utilizando PVM, o programador ca encarregado de toda a decomposição, alocação e comunicação explicitamente, sendo que a plataforma realiza de forma transparente as conversões necessárias entre os diferentes formatos de dados que podem coexistir no ambiente utilizado.
As linguagens de modelagens apresentadas anteriormente possibilitam geração de código executável a partir de a compilação direta da linguagem de entrada, que se apresenta como código fonte textual.
As ferramentas apresentadas nessa seção utilizam uma linguagem de modelagem com forte apelo gráco, buscando explicitar elementos como topologia da aplicação e mapeamento entre processos e processadores.
Por modelarem a aplicação num nível ainda mais alto do que o das linguagens de programação paralela, normalmente os modelos gerados por essas ferramentas são primeiramente traduzidos para alguma linguagem intermediária, a qual é efetivamente compilada para a geração de um programa executável.
Assim, para cada linguagem dessas linguagens de modelagem, existe um tradutor e uma ferramenta de edição de modelos associada.
Linguagens grácas simplicam a denição da comunicação por utilizarem descritores num nível mas alto, intuitivo e estruturado que o possibilitado por linguagens textuais.
A decomposição da tarefa entre os elementos de computação e mapeamento é explícita, sendo o sistema descrito como um grafo, onde os elementos de processamento são representados por vértices e o uxo de dados por arestas.
A seguir, são discutidos alguns exemplos de maior destaque encontrados na literatura.
A ferramenta Frameworks é um dos primeiros trabalhos a utilizar recursos grácos para a modelagem da aplicação.
O sistema gerado consiste em módulos que se comunicam através de Remote Procedure Calls (RPC), sendo C a linguagem utilizada em todo o sistema gerado.
Os construtores oferecidos baseiamse na idéia de uxograma de dados, com símbolos que representam estruturas de divisão da massa de dados, escalonamento e sincronização inseridos na modelagem.
Nodos usados para a modelagem têm uma semântica variável e arestas representam canais de comunicação.
Assim, a ferramenta facilita a modelagem da topologia do sistema.
A ferramenta Enterprise é uma evolução do sistema Frameworks.
Ela consiste numa interface gráca, uma biblioteca de códigos, um précompilador e um gerente de execução.
A metáfora utilizada para modelagem é a de um escritório, substituindo termos como pipelines, O sistema suporta balanceamento de carga e distribuição dinâmica de trabalho.
Enterprise assume a existência de um sistema de arquivos global (e.
g NFS), não oferecendo de maneira nativa mecanismos para controle de I/ O concorrente em arquivos.
As bibliotecas implementadas usam uma interface genérica para um kernel de troca de mensagens.
Inicialmente, a ferramenta comportava as plataformas de comunicação ISIS e NMP.
Posteriormente, foi incluído suporte a PVM e Concern/ C.
As facilidades oferecidas por o plataforma ISIS permitem aos sistemas gerados através da ferramenta Enterprise um limitado grau de tolerância a falhas.
Ainda, PVM e Concern/ C oferecem suporte à utilização de ambientes heterogêneos.
HeNCE (Heterogeneous Network Computing Environment) é um ambiente gráco de programação criado para auxiliar o desenvolvimento de programas paralelos utilizando PVM como plataforma de comunicação.
A ferramenta permite a programação, compilação, execução e depuração, assim como a conguração do ambiente paralelo virtual oferecido por a plataforma.
A metodologia de utilização da ferramenta envolve as seguintes etapas:
Criar um grafo descrevendo a semântica da computação paralela;
Congurar a máquina virtual para a execução do programa;
Construir os executáveis para os vários nodos, considerando a arquitetura;
Executar o programa na máquina virtual;
Opcionalmente, o programador pode visualizar uma animação da troca de mensagens entre os nodos durante ou após a execução.
Nodos representam rotinas seqüenciais providas por o usuário, ou estruturas de controle de uxo de dados entre os nodos (e.
g Loops, Condicionais, Fans) providas por a linguagem de modelagem.
Um nodo Condicional dene para qual dos subgrafos os dados devem ser direcionados.
O construto Loop dene a execução de múltiplas iteração usando como corpo do laço o subgrafo associado.
O construto Fan permite a criação dinâmica de subgrafos.
Arestas representam os canais de comunicação utilizados entre os nodos, sendo que HeNCE não utiliza nenhum rótulo associado às arestas.
Segundo a semântica associada à linguagem de modelagem utilizada, um nodo não executa até que seus pais tenham executado, dado que a entrada num nodo é obtida a partir de seus ancestrais no grafo.
A ferramenta Code (ComputationOriented Display Environment) provê a geração de código tanto utilizando MPI quanto PVM, permitindo a geração de programas paralelos para arquiteturas com memória compartilhada e memória distribuída.
Ela utiliza uma linguagem de modelagem baseada em grafos de uxo de dados, em a qual computações representadas por nodos são conectadas por arestas, que representam canais FIFO para a comunicação entre um nodo e outro.
Nodos podem possuir mais de um canal de entrada, sendo que a denição de qual canal é utilizado é feita rotulandose a aresta que faz a ligação.
Opcionalmente, pode existir uma regra de acionamento a cada computação, indicando uma condição que permite a execução do nodo e as variáveis receber os valores de entrada.
Assim como na ferramenta HeNCE, além de os nodos representando processamento sobre os dados existem nodos para o controle de repetições e criação dinâmica de novos subgrafos.
DPnDP (Design Patterns and Distributed Processes) é um dos primeiros sistemas a apresentar a implementação e uso de design patterns parametrizáveis independentes da aplicação como uma biblioteca extensível de esqueletos de código para a geração de aplicações paralelas.
Uma aplicação é composta usandose um ou mais design patterns, que podem ser combinados com outras partes de código inclusive fazendo uso de primitiva de sincronização e comunicação em baixo nível.
Cada design pattern fornecido por a ferramenta provê uma interface padrão.
Utilizando essa interface padrão, novos design patterns podem ser adicionados no sistema incrementalmente, tornando o sistema extensível.
Esse é um dos principais focos da ferramenta.
Uma característica dos design patterns utilizados por a ferramenta DPnDP é o fato de serem livres do contexto (context insensitive).
Isso signica que uma implementação ou uso de um design pattern não faz suposição ou restrição nenhuma sobre a implementação dos demais.
Em DPnDP, uma aplicação paralela é representada gracamente por um grafo dirigido, onde os nós interagem entre si através de troca de mensagens.
Cada módulo possui um ou mais manipuladores de mensagens que recebem mensagens de outros nós e invocam o código seqüencial dentro de o módulo para processar estas mensagens apropriadamente.
Cada vértice do grafo é associado a um modelo de código da computação seqüencial escrito em C ou C+.
Alternativamente, uma aresta do grafo da aplicação pode representar um design pattern.
A interface de um design pattern é indistingüível da de um módulo, i.
e, em ambos os casos os outros nós interagem usando troca da mensagem através de uma interface comum.
Entretanto, a estrutura interna de um design pattern pode ser um subgrafo multinó.
Alguns destes nós podem inclusive ser outros design patterns.
A ferramenta CO2 P3 S (Correct ObjectOriented Patternbased Parallel Programming Sys-tem) gera código Java também utilizando design patterns, visando ambientes de execução distribuídos.
A linguagem de modelagem utilizada expressa principalmente a topologia da aplicação.
A ferramenta possui recursos para monitoração do processamento e comunicação entre os processos, possibilitando ao usuário modicar o modelo em busca de um melhor balanceamento.
Ainda, está associada a esse ambiente uma ferramenta para a edição dos patterns utilizados chamada MetaCO2 P3 S. A metodologia de utilização da ferramenta baseiase em cinco etapas:
As linguagens, bibliotecas e ferramentas apresentadas até então utilizam modelos como uma descrição do sistema visando gerar um programa executável.
Mesmo quando elaborada com cuidado, determinadas características na solução proposta podem carregar implicitamente algum aspecto negativo, que leve o comportamento do sistema a um estado indesejado.
Para evitar tais situações, é natural a realização de um conjunto de testes e simulações sobre o sistema gerado.
Porém, é comum armar que a realização nãoexaustiva de testes pode provar apenas a presença de erros, não as sua ausência (conforme enunciado pela primeira vez por Edsger Dijkstra em).
Isso motiva a utilização de outras metodologias complementares na análise de aplicações paralelas, de entre as quais a vericação de modelos (ou model checking) tem sido um grande foco de pesquisas e desenvolvimento.
Basicamente, vericação de modelos consiste na aplicação de algoritmos executados através de ferramentas computacionais objetivando vericar a corretude de um sistema.
O usuário provê uma descrição do sistema através de um modelo (o qual é utilizado para gerar seus comportamentos possíveis) e uma descrição de sua especicação (uma descrição de seu comportamento esperado).
A ferramenta então realiza uma busca exaustiva no espaço de estados possibilitado por o modelo, procurando por um comportamento (uma seqüência de estados) que viole a especicação fornecida.
A metodologia de uso de uma ferramenta de vericação pode ser ilustrada como na Figura 1.
Existem limitações para a aplicação de vericadores de modelos, impedindo sua utilização para qualquer tipo de sistema.
Este método de análise é apropriado para aplicações intensivas em controle, como comunicação entre componentes.
Não é adequada para aplicações intensivas em dados, uma vez que o tratamento de dados usualmente introduz um espaço de estados innito.
Outro aspecto a ser considerado é que determinar o conjunto apropriado de abstrações sobre o sistema para construção do modelo requer experiência.
Abstrações erradas podem levar o comportamento do modelo a perder a correspondência ao sistema real.
Ainda, como a vericação é realizada sobre o modelo construído, qualquer resultado obtido é tão bom quanto o modelo apresentado.
Lógicas especiais foram denidas objetivando fornecer a expressividade necessária para a especicação de propriedades e vericação de modelos.
A mais amplamente estudada é a lógica temporal, que foi introduzida na ciência de computação com propósitos de especicação e vericação por Amir Pnueli.
As origens de lógica temporal remontam ao campo da losoa, onde A. Prior é apontado como o criador na década de 60.
Lógica temporal estende a lógica clássica através da inclusão de novos operadores temporais, os quais permitem a formulação de propriedades como A e B são válidos depois de C ocorrer e no futuro A é válido, por exemplo.
Existem dois tipos principais de lógicas temporais com tempo discreto:
Ramicada e linear.
Computation Tree Logic (CTL) é uma lógica de tempo ramicado sobre árvores de computações.
Lógica de tempo ramicado permite ao usuário escrever fórmulas que incluem sensibilidade a escolhas possíveis durante a execução.
Ela permite considerações acerca de possíveis seqüências de estados a partir de um estado inicial.
Seus operadores consistem de operadores de caminhos seguidos imediatamente por um operador temporal.
Os quanticadores de caminho são A (para todos os caminhos) e E (para algum caminho).
Lógica Temporal Linear (LTL) é uma linguagem de asserções sobre computações, permitindo o estabelecimento de propriedades sobre seqüências de execuções de um sistema.
Um programa satisfaz uma fórmula LTL se todas as suas possíveis computações satisfazem essa fórmula.
CTL e LTL diferem por a maneira como interpretam as seqüências de estados possíveis.
Em CTL, uma seqüência de estados é interpretada conforme uma árvore, onde os lhe&amp;lhes os de um estado são os demais próximos estados alcançáveis a partir de ele.
Assim, durante uma execução o modelo ramica os estados conforme as possibilidades do modelo.
Em LTL, cada nova possibilidade representa uma nova seqüência linear de estados.
A Figura 2 apresenta o comportamento do autômato (Figura 2.
A) segundo a interpretação em CTL (Figura 2.
B) e LTL (Figura 2.
C): A denição a seguir apresenta o conjunto básico de fórmulas que podem ser expressas em Denição 1 -- Sintaxe da LTL:
Seja AP um conjunto de proposições atômicas:
Para todo p AP, p é uma fórmula.
Se é uma fórmula, então¬ é uma fórmula.
Se e são fórmulas, então (), () e () são fórmulas.
Se é uma fórmula, então X, F e G são fórmulas.
Se e são fórmulas, então é uma fórmula.
O conjunto de fórmulas elaborado de acordo com essas regras denotam sentenças em LTL.
Note que os três primeiros itens são relativos à lógica proposicional.
Os operadores temporais introduzidos são o X (pronunciado próximo), G (pronunciado sempre ou globalmente), F (pronunciado eventualmente ou no futuro) e U (pronunciado até) Alternativamente, a sintaxe de LTL pode ser dada na forma de BackusNaur (BNF) como:
Denição 1.
B -- Sintaxe da LTL na forma BNF:
Para p AP, o conjunto de fórmulas LTL é denido por.
A hierarquia de precedência dos operadores de LTL segue o mesmo esquema da lógica clássica.
Operadores unários têm precedência maior do que operadores binários.
Os operadores¬ e X têm a mesma precedência.
O operador temporal U tem precedência maior do que, e.
O operador tem precedência menor do que ou, os quais tem mesma precedência.
A inclusão balanceada de parênteses pode ser utilizada para forçar outras ordens de avaliação.
Assim, a sentença((¬)) U( (X) (F)) pode também ser escrita(¬) U (X F).
Formalmente, uma sentença LTL especica um padrão para uma seqüência de estados.
Intuitivamente, X representa que é válido no próximo estado, F representa que é válido no estado atual ou para algum estado no futuro.
O signicado formal de LTL é denido em termos de um modelo.
Denição 2 Modelo LTL:
Seja um modelo LTL M uma tripla M $= (S, R, Label) onde:
S é um conjunto não vazio e enumerável de estados.
R: S S associando a s S seu estado sucessor R (s);
Label: S 2 AP, associando a cada estado s S as proposições atômicas Label (s) que são válidas em s.
Para todo estado s S, R (s) é o estado subseqüente a s alcançado através da aplicação de R. A função R age como um gerador innito de seqüências de estados3.
A função Label (s) indica quais proposições atômicas são válidas para cada estado em M. Se para o estado s temse Note que seqüências de estado innitas podem ser geradas sobre um conjunto nito de estados, desde que a aplicação de R produza um laço como o observado na Figura 2a.
Label (s) $= isso signica que é válida em s.
Um estado s para o qual a proposição é válida, ou seja, Label (s), é muitas vezes referenciado como um state.
Para o estado s S, o estado R (s) é o único próximo estado de s alcançado a partir de a aplicação de R. Uma característica importante da função R é o fato de ela agir como um essas seqüências os elementos fundamentais a que se referem as sentenças LTL.
O signicado de fórmulas em LTL são denidos através de uma relação de satisfação (denotada por| $ ) entre um modelo M, um de seus estados s, e uma fórmula.
O sentido da relação (M, s,)| $= é representado em notação inxada por M, s| $= Denição 3 A Semântica de LTL:
Seja p AP uma proposição atômica, M $= (S, R, Label) um modelo LTL, s S, e fórmulas LTL.
A relação de satisfação| $= é denida por:
Aqui, R0 (s) $= s, e Rn+ 1 (s) $= Rn (R (s)) para todo n 0.
Se R (s) $= s, o estado s é chamado de sucessor direto de s.
Se Rn (s) $= s para n 1, o estado s é um sucessor de s.
Se M, s| $= é dito que o modelo M satisfaz no estado s.
Expresso de outra maneira, a fórmula é válida para o estado s do modelo M. Ainda, por a denição, F é válido para s se e somente se existir algum estado sucessor de s (não necessariamente direto) onde é válido, ou se for válido em s.
A fórmula G é válida em s se e somente se para s e todos os seus sucessores a fórmula é válida.
Baseado ainda na semântica apresentada, podese também denir os operadores temporais G e F como:
F true U Para a primeira sentença, uma vez que true é válido em todos os estados, F dene que é verdade em algum ponto do futuro.
Para a segunda sentença, uma vez que não exista nenhum estado no futuro onde¬ seja válido;
Então é válido em todos os pontos.
Podese comparar e combinar sentenças LTL a partir de a denição de uma lista de axiomas que respeitem a semântica denida.
Formalmente, o axioma é chamado válido se e somente se, para todo modelo LTL M e estado s em M:
M, s| $= se e somente se M, s| $= A aplicação de axiomas a uma certa fórmula resulta em outra fórmula de mesmos signicado e validade, i.
e, os axiomas não mudam a semântica da fórmula.
A seguir, é apresentada uma lista não exaustiva de axiomas válidos.
Uma listagem completa de axiomas para LTL existe, mas foge do escopo desse trabalho.
Dualidades Absorção Idempotência Distributividade Expansão Axiomas são utilizados principalmente para simplicar sentenças obtidas a partir de a combinação de partes mais simples, visando a elaboração de propriedades correspondentes à especicação do sistema.
A utilização de sentenças LTL dessa forma para a denição de propriedades de um modelo requer certo grau de habilidade por parte de o usuário, tanto na construção da propriedade quanto na interpretação dos resultados obtidos.
Para facilitar tal atividade, tornase comum a utilização de padrões prédenidos para sentenças de uso freqüente.
A literatura apresenta vários trabalhos onde são introduzidos padrões reutilizáveis para propriedades em lógica temporal, facilitando a utilização e evitando erros de especicação.
A classicação savetyliveness proposta por Lamport em 1977 é uma das classicações mais importantes encontrada na literatura, por adequarse a uma ampla gama de propriedades.
Ela diferência dois grandes grupos principais:
Safety: Algo de ruim nunca acontece durante a execução de um sistema;
E liveness:
Algo de bom deve ocorrer em cada uma das execuções do sistema.
Em a categoria safety enquadramse propriedades como dois processos não podem estar na seção crítica ao mesmo tempo ou o sistema nunca entra em deadlock.
Propriedades de liveness comuns são terminação (um sistema deve chegar ao término em algum momento) e starvation freedom (sempre deve ocorrer progresso num processo).
Dentro de cada grupo existem ainda quatro subdivisões.
Dentro de a categoria Existence encontramse as seguintes possibilidades:·
Absence: A proposição não ocorre4 dentro de as execuções;·
Universality: A proposição ocorre em todos os estados durante as execuções;·
Existence: A proposição deve ocorrer em pelo menos um estado dentro de cada uma das execuções;·
Bounded Existence: A proposição deve ocorrer k vezes em cada uma das execuções.
Para a categoria Order:·
Response: A proposição P deve sempre ser seguida da proposição Q em cada uma das execuções;·
Precedence: A proposição P deve sempre ser precedida por a proposição Q em cada uma das execuções;
Dentro de cada padrão apresentado, podese ainda denir os escopos de aplicação para as proposições.
Escopos denem as regiões de interesse dentro de as quais as proposições apresentadas devem ser válidas.
A Figura 5 apresenta os diferentes escopos oferecidos por os padrões apresentados.
Existem cinco tipos de escopos:·
Global: Durante toda a seqüência de estados;·
Before Q: A seqüência de estados até a proposição Q ser verdadeira;
Utilizase a proposição ocorre dentro de as execuções signicando ela é verdadeira para os estados dentro de as execuções.·
After Q: A seqüência de estados após a proposição Q ser verdadeira;·
Between Q and R: Dentro de a seqüência de estados, o trecho entre as proposições Q e R;·
After Q until R:
Dentro de a seqüência de estados, o trecho após a proposição Q, até a proposição R ocorrer;
Os padrões propostos em aplicamse para propriedades expressas sobre as seqüências de estados.
Em a vericação de determinados modelos, pode ser necessário especicar propriedades sobre as transições entre os estados, ou seja, propriedades sobre os eventos que levam às mudanças de estado.
Em eventos em LTL são chamados edges, sendo denidos a partir de uma proposição s como:
UpEdge s: S $ (¬ s X s) DownEdge s:
S $= (s X¬ s) Um evento s denota a mudança de estado de uma variável ou proposição s de nãoativa para ativa.
Um evento s, por sua vez denota a mudança de estado de ativo para nãoativo.
Por a modo como é expresso em LTL, um evento é detectado no estado anterior em que a proposição tornase verdadeira, i.
e, imediatamente antes da variável ou variáveis usadas na proposição mudarem de valor.
Em também são introduzidos padrões de propriedades sobre eventos para uso na vericação de modelos.
Eventos são utilizados para representar a aplicação de uma regra num modelo GGBO, como será visto no Capítulo 3.
A maior limitação no uso de vericação de modelos diz respeito ao problema de explosão de estados.
Quando de a vericação de um modelo, muitas vezes o espaço de estados gerado por a composição do modelo com a sentença LTL pode se tornar muito grande, especialmente se forem envolvidos vários processos concorrentes nesse modelo ou se a sentença LTL for complexa, de tal modo que ca impraticável o tratamento computacional do sistema.
Podese tentar contornar esse problema a partir de técnicas para a diminuição do espaço de estados dentro de as ferramenta de vericação, ou através da adoção de técnicas de modelagem diferentes por parte de o usuário.
Uma das técnicas utilizada por as ferramentas de vericação é chamada Redução de Ordem Parcial (Partial Order Reduction), a qual consiste em reduzir o espaço de estados gerados durante a vericação, selecionando apenas um subconjunto das possíveis intercalações para transições que são executadas independentemente.
Dois eventos são ditos independentes se a execução alternada de eles resulta no mesmo estado global.
Os padrões de sentenças apresentados em foram construídos de forma a possibilitar o uso adequado de Redução de Ordem Parcial na vericação dos modelos.
O usuário, por sua vez pode tratar o problema da explosão de estados utilizando abordagens do tipo dividir econquistar, onde a especicação de sistemas é feita em termos de as propriedades de seus componentes, sendo estas últimas vericadas separadamente.
A utilização de uma abordagem composicional para a vericação pode ser utilizada de maneira a restringir o tamanho total do modelo sendo vericado em cada etapa, possibilitando tratar de maneira iterativa o problema e permitindo a vericação de sistemas maiores, contornando o problema de explosão de estados.
Maiores detalhes sobre tal abordagem podem ser encontrados em.
PROcess Meta LAnguage (PROMELA) é uma linguagem de especicação formal baseada em processos, sendo utilizada como linguagem de entrada por o vericador de modelos Simple Promela INterpreter (SPIN).
Em o vericador de modelos SPIN, a partir de um modelo expresso em linguagem PROMELA e propriedades usando LTL é possível vericar especicações para todo o espaço de estados desse modelo.
SPIN é considerado um dos vericadores de modelos mais utilizados e ecientes da atualidade, tendo ganho o prêmio de sistema de software em 2001 conferido por a ACM (Association for Computing Machinery), e apresentando mais de uma década de desenvolvimento.
Uma especicação PROMELA consiste em processos seqüenciais, variáveis locais e globais, e canais de comunicação usados para conectar os processos seqüenciais.
Variáveis globais também podem ser usadas na comunicação entre processos, de forma que ambas as primitivas de comunicação citadas na Seção 2.3 podem ser modeladas.
A sintaxe de PROMELA é fortemente inuenciada por a linguagem C, apresentando ainda estruturas de controle inspiradas nos comandos guardados de Djikstra, usada para notação abstrata de programas.
Um processo P é denido como:
Esta estrutura dene o processo P, algumas variáveis e constantes locais a P, e seu comportamento.
Comandos são separados por pontoevírgula(;).
Processos são iniciados através da palavra reservada run, o qual aparece numa seção de inicialização indicada por init.
Em o exemplo a seguir, instâncias do processo P e Q são criadas e iniciadas:
Processo podem ser criados tanto de forma estática quanto dinâmica, ou seja, um processo pode ser criado a qualquer momento dentro de uma especicação.
Comandos em PROMELA podem estar habilitados ou bloqueados.
Caso um comando esteja uma situação em a qual a e b sejam diferentes.
As seguintes estruturas de controle existem em· Comando vazio, denotado skip.
Indica que nada deve ser feito, sendo usado para satisfazer estruturas sintáticas ou melhorar a legibilidade/ entendimento do modelo.·
Comandos de atribuição (por exemplo, x $= 7;).
Tais comandos são nãobloqueantes.·
Estruturas condicionais.
Possuem a forma if:
Guarda1\&gt; comando (s) 1;
Dentro de uma estrutura condicional, uma das alternativas cuja guarda esteja ativa é selecionada e a lista (não vazia) de comandos correspondentes são executados.
Caso mais de uma guarda esteja habilitada num determinado momento da execução, a escolha é habilitada quando todas as demais estiverem bloqueadas.
Caso todas as guardas estejam bloqueadas, a execução pára até que pelo menos uma de elas tornese habilitada.·
Estrutura de repetição.
Uma estrutura de repetição possui a mesma forma de uma estrutura condicional de o:
Guarda1\&gt; comando (s) 1;
Basicamente, essa estrutura representa um loop innito, o qual pode ser terminado com um comando goto ou break acionado por uma guarda.
Novamente, caso nenhuma guarda esteja habilitada, a execução é suspensa.
Adicionalmente, existem operações para inspecionar um canal sem afetar seu estado atual.
Canais de capacidade 0 também são permitidos, e seu uso indica que a comunicação entre os processo é realizada de forma síncrona (um processo que realize uma operação sobre um canal síncrono ca bloqueado até que outro processo realize a operação complementar).
A ferramenta de vericação oferece atomicidade em nível de linha de código para cada processo previsto dentro de o modelo (i.
e, a intercalação pode ser feita executandose uma linha de cada processo, por exemplo).
Também é possível denir seqüências atômicas numa especicação.
Tais seqüências caracterizamse por a execução num conjunto de comandos e declarações num único passo observável, não intercalando a execução dessas operações com a de outros processos.
As seqüências atômicas em PROMELA são denidas com o uso da estrutura atomic, sendo que as instruções dentro de o escopo atomic são executadas sem intercalação com os demais processos.
Se existirem comandos guardados dentro de uma estrutura atomic e em alguma situação nenhum destes estiver habilitado, irá ocorrer a perda de atomicidade da estrutura, acarretando na execução intercalada de comandos do escopo atomic com comandos de outros processos.
A vericação de modelo PROMELA é feita a partir de uma interface especial, que permite a elaboração de proposições atômicas e sentenças em LTL.
Proposições atômicas somente podem ser elaboradas a partir de variáveis globais.
Por exemplo, considere duas proposições atômicas e, denidas sobre duas variáveis, a e b, onde é verdadeiro se a e b forem iguais a 1 e é verdadeiro se a e b forem maiores que 2.
Dentro de a ferramenta, essas proposições são denidas como:
A sintaxe utilizada por a ferramenta para a especicação de propriedades é mostrada na Tabela 1.
Assim, a sentença(¬) U (X F) anteriormente formulada é expressa como(!
Phi --\&gt; psi) U (X phi&amp; psi).
A ferramenta comporta também a simulação de um modelo PROMELA.
Simulações não envolvem sentenças LTL.
Durante uma simulação, sempre que o modelo encontrar mais de uma possibilidade de prosseguir, um caminho é aleatoriamente escolhido.
Alterandose a semente numérica do algoritmo pseudoaleatório utilizado, podese realizar simulações para diferentes cenários.
Tanto para os contraexemplos obtidos quanto para os cenários de simulação é possível acompanhar o comportamento do modelo.
Para tanto, a ferramenta apresenta uma janela contendo o diagrama de troca de mensagens entre os processos, assim como uma janela indicando a intercalação de instruções entre os de processos e uma janela exibindo os valores assumidos por as variáveis e canais durante a animação.
Ainda, podese exibir um diagrama de barras contendo a proporção entre o número de operações executadas de cada processo presente.
Objetos Gramática de Grafos baseada em objetos (GGBO) é um formalismo gráco e declarativo para modelagem de sistemas reativos, oferecendo conceitos básicos de sistemas baseados em objetos, abstrações de nãodeterminismo e concorrência inerentes à utilização de tais conceitos.
Por ser baseada em objeto, carrega vantagens como modularidade, facilidade de reuso de denições e construção de sistemas grandes.
Por ser relativamente restrita em suas construções e ter uma semântica formal, permite seu mapeamento para ambientes de análise tais como simuladores e vericadores.
GGBO também se presta para o tratamento analítico necessário para avaliação de desempenho.
A linguagem de especicação GGBO foi proposta em para modelar sistemas concorrentes reativos.
As gramáticas de grafos fornecem uma forma bastante natural de expressar situações complexas, onde os estados do sistema sob análise são descritos por grafos e os aspectos dinâmicos podem ser capturados por as regras da gramática.
Uma gramática de grafos é composta por um grafo de tipos, que representa os tipos de vértices e arestas permitidas no sistema;
Um grafo inicial, que representa o estado inicial do sistema e um conjunto de regras que descrevem as possíveis mudanças e estado que podem ocorrer num sistema.
Em é proposta uma restrição de gramática de grafos chamada GGBO para descrever sistemas baseados em objetos.
Em GGBO, um sistema consiste em entidades autônomas, chamadas objetos.
Os objetos possuem um estado interno denido por o conjunto de valores assumidos por seus atributos e se comunicam unicamente através de troca assíncrona de mensagens.
A Figura 6 apresenta o modelo de um objeto segundo GGBO.
Gracamente, um objeto tem a notação de um retângulo, onde consta seu nome (Obj_ N, na Figura 6), um identicador de tipo de objeto e seu conjunto de atributos (e.
g atr_ A e atr_ B).
Instâncias de um mesmo tipo de objeto possuem identicadores de tipo idênticos.
Atributos de tipos de dados prédenidos são listados dentro de o retângulo, sendo que os atributos que referenciam outros objetos têm a notação de arestas que se ligam a outros objetos ou a identicadores de tipo de objetos.
O objeto alvo de uma referência é indicado por um círculo localizado no nal da aresta.
O comportamento de um objeto corresponde às reações executadas por ele ao receber mensagens, reações estas que podem mudar o estado interno do objeto e/ ou causar o envio de mensagens tanto para outros objetos quanto para si mesmo.
Exemplo: Para ilustrar a utilização desse formalismo será adotado um modelo GGBO para um sistema mestreescravo que implementa um método de Monte Carlo para o cálculo do valor aproximado de.
O método consiste em:
Observe que quanto maior o número de pontos, melhor a aproximação.
Em o modelo, serão utilizados três escravos e um mestre.
Um bom gerador pseudoaleatório fornece uma distribuição homogênea de pontos dentro de um domínio.
Se um gerador ruim for utilizado nesse modelo, o valor obtido não será próximo o bastante de.
Assim, dependendo do conjunto de pontos aleatorizado (i.
e dependendo do gerador utilizado), existem para o modelo computações possíveis em a qual o valor nal não é uma boa aproximação de.·
Em um sistema baseado em objetos podem existir vários tipos de objetos.
Para descrever um sistema baseado em objetos usando GGBO é necessária a denição do grafo de tipos (ou grafotipo) do sistema, que descreve todos os tipos de objetos que o compõe.
O grafotipo de um objeto (Figura 7) determina tanto os atributos que um objeto possui quanto as mensagens que qualquer instância de objeto daquele tipo pode receber e enviar, assim como seus parâmetros.
O grafo inicial de um sistema descreve todos os objetos, mensagens e valores de atributos que devem existir na situação inicial desejada para o modelo.
Todos estes objetos com seus atributos e mensagens são instâncias dos tipos de objetos denidos em grafostipo.
Os objetos podem ser instanciados estaticamente, a partir de o grafo inicial, ou dinamicamente, através da execução de regras que criem novos processos.
Como exemplo do grafo inicial, vide Figura 8.
Exemplo: A seguir, os grafostipo para os objetos Master e Slave propostos para o modelo.
Observe que junto ao retângulo que representa o objeto são apresentadas as mensagens que este pode receber.
As mensagens que o objeto gera estão representadas à direita em cada grafotipo, ligadas ao identicador do tipo de objeto ao qual são enviadas.
Em o grafotipo, referências a outros objetos também se ligam a identicadores de tipo, como é o caso das referências sl1, sl2 e sl3 para o objeto Master e mst para o objeto Slave.·
a) Grafotipo para o objeto Master.
Em GGBO, o estado de um sistema computacional que envolve os valores dos atributos, as mensagens existentes e os processos em execução é representado através de um grafo de estado, e o funcionamento do sistema ca atrelado a um conjunto de regras de transformação que são aplicadas sobre o estado atual do sistema.
Dentro de um modelo expresso em GGBO, as modicações no grafo de estado ocorrem onde for encontrado um subgrafo que represente um padrão previsto no lado esquerdo de uma regra, considerando ainda a condição associada a esta regra, caso exista.
A identicação de existência de um subgrafo e uma condição associada a uma regra é chamado ocorrência ou match.
Em uma gramática de grafos, cada regra r:
L R especica uma mudança de estado no sistema que ocorre da seguinte forma:·
Todos os itens que estão do lado esquerdo da regra L devem estar presentes no estado atual de um sistema para possibilitar a aplicação da regra;·
C, quando presente, especica uma condição sobre os valores dos atributos presentes em L também necessários para a aplicação da regra;·
Todos os tens que não são mapeados de L para R são apagados do estado atual;·
Todos os tens que estão em R e não estão em L são adicionados para a obtenção do novo estado.
As regras de um tipo de objeto são as que apresentam, no lado esquerdo da regra, uma mensagem sendo recebida por um objeto do tipo em questão.
Esta regra especica a reação de um objeto daquele tipo à recepção daquela mensagem.
Em o lado direito da regra, esta mensagem terá sido consumida, atributos do objeto podem mudar de valor e novas mensagens podem ser geradas, indicando a continuidade do processo.
Cada regra descreve o tratamento de apenas uma mensagem.
Todas as ações descritas numa mesma regra ocorrem de forma atômica e são chamadas eventos.
Um objeto somente pode enviar uma mensagem a outro objeto se existir pelo menos uma referência ao destino no lado direito da regra.
Esta referência pode ser tanto um atributo do objeto quanto um parâmetro da mensagem que disparou a regra.
As regras de uma GGBO permitem modelar a concorrência e o nãodeterminismo.
A concorrência é modelada por a possibilidade de aplicação de mais de uma regra numa mesma situação, quando essas regras não forem conitantes.
Duas regras são conitantes se estas consomem ou sobrescrevem os mesmos itens.
A concorrência pode ocorrer envolvendo objetos diferentes (concorrência externa) ou um mesmo objeto (concorrência interna quando um objeto pode tratar diversas mensagens ao mesmo tempo).
O não determinismo é modelado na escolha da regra para aplicação.
Caso mais de uma regra puder ser aplicada numa situação, uma destas é escolhida nãodeterministicamente para executar.
Exemplo: As Figuras 9 e 10 apresentam respectivamente regras para os objetos Master e Slave denidos anteriormente.
Será utilizada a notação NomeObjeto_ NomeRegra para referenciar as regras apresentadas.
Master_ Start é a primeira regra aplicada ao sistema, por ser a única que possibilita um match no grafo inicial.
Em ela, consumindo a mensagem Start, o objeto M aster envia para todos os escravos referenciados uma mensagem P oints, que indica em n quantos pontos devem ser gerados aleatoriamente.
A regra Master_ Receive apresenta o comportamento de Master recebendo respostas InsP oints, acumulando no atributo inside o total de pontos inscritos randomizados por o Slave originador.
Recebendo a última mensagem de resposta de um escravo (regra Mas- ter_ Done), M aster nalmente calcula o valor aproximado de pi.
A diferenciação entre a escolha de M aster_ Receive e M aster_ Done é feita através da guarda associada a cada regra, que envolve uma comparação entre o número total de participantes (valor sl para o atributo slaves) e o número de mensagens recebidas (valor t para o atributo received).
Por a regra Slave_ Start, na presença de uma mensagem Start, Slave xa o número de pares a serem aleatorizados no atributo total e envia para si mesmo o primeiro par como parâmetro de uma mensagem P oint.
A partir desse evento, Slave repetidamente consome P oints, computa se o ponto pertence ou não à circunferência (atributo inside) e atualiza o total de mensagens geradas (atributo done).
Quando processada a última mensagem necessária para compor o total informado por M aster, executa Slave_ Done enviando o total de pontos inscritos encontrado.
Tipo Abstrato de Dado Math: Operations:
Inicializa o TAD.
A função ins (s, x, y) determina se o ponto (x, y) pertence ou não a uma circunferência de raio s/ 2 inscrita num quadrado de lado s, sendo que o quadrado e a circunferência têm o mesmo ponto como centro.
Retorna 1 (um) caso o ponto esteja contido dentro de o círculo, ou 0 (zero) caso contrário.
Retorna um número menor ou igual a limit.
Aleatoriza um conjunto de n pontos dentro de um quadrado de lado s, retornando o total de pontos inscritos num círculo de raio s/ 2 inscrito dentro de o quadrado.
End Math. GGBO fornece uma linguagem baseada em objetos para a especicação de sistemas concorrentes.
Essas especicações apresentam algumas características que facilitam o desenvolvimento do sistema que descrevem.
Um sistema baseado em objetos é modular, uma vez que é composto por entidades autônomas (objetos) conectados via interfaces bem denidas (mensagens).
Os atributos e as operações que manipulam os objetos são descritos junto ao objeto e não podem se acessados por outros objetos (encapsulamento).
Um modelo baseado em objetos facilita o reuso das especicações devido a o encapsulamento e às interfaces de importação (operações que utiliza) e de exportação (operações que disponibiliza) de cada objeto.
Assim, objetos especicados num modelo podem se utilizados em outros modelos, sem a necessidade de conhecer sua estrutura interna.
Ainda, um sistema descrito por um modelo baseado em objetos apresenta uma arquitetura simples (devido a a abstração) e descentralizada (devido a a sua estrutura de objetos), que são dois princípios necessários para a extensibilidade, onde novas funcionalidades podem ser incluídas no sistema com pouco esforço, sem que o resto do sistema tenha de ser alterado.
Dentro de um modelo GGBO, a extensão de funcionalidades de um objeto ou do sistema é alcançada através da inclusão de novos tipos de mensagens e objetos e da inclusão de novas regras.
Diferente das ferramentas grácas apresentadas na Seção 2.4.4 que utilizam grafos para modelar a topologia da aplicação, GGBO utiliza grafos para representar tanto o estado do sistema quanto as transformações permitidas.
A comunicação entre os nodos das ferramentas grácas citadas anteriormente é feita através de canais de comunicação, simbolizados explicitamente através de arestas ligando os nodos.
Existem operadores grácos que permitem a criação de subgrafos, possibilitando certa dinamicidade na topologia.
Porém, não existem operadores permitindo a criação e deleção de canais de comunicação entre nodos já existentes durante a execução do programa.
GGBO, por sua vez, representa a comunicação através de mensagens, permitindo um arranjo dinâmico dos mecanismos de comunicação através da manipulação das referências existentes tanto como atributos dos objetos quanto como parâmetros nas mensagens.
Tal característica oferece bastante exibilidade para alterações estruturais na topologia do sistema modelado.
Por apresentar mecanismos centrados na troca de mensagens entre os participantes, GGBO apresenta características que a deixam mais próxima de uma linguagem de controle, como é o caso de Linda.
Existem semelhanças no nãodeterminismo possível na escolha da tupla da ser consumida do pool de mensagens (para Linda) com o nãodeterminismo na escolha da mensagem a ser consumida do grafo de estado (para GGBO).
Outra importante semelhança entre essas duas linguagens ca na utilização de mecanismos de matching para acionar o recebimento.
GGBO apresenta semelhanças com linguagens celulares, principalmente na utilização de regras para alterar o grafo de estado do sistema (que para linguagens celulares é chamado reticulado).
Porém, GGBO não apresenta a possibilidade de considerar atributos da vizinhança de um nodo na aplicação de uma regra.
Por outro lado, linguagens celulares têm restrições quanto a a comunicação entre os nodos (somente entre nodos vizinhos), o que não ocorre em GGBO, onde é possível enviar uma mensagem para qualquer outro objeto ao qual se tenha referência.
Um modelo de simulação é uma representação simplicada de um processo ou sistema que permite analisálo.
A principal vantagem é a possibilidade de validar uma estratégia de projeto, bem como os algoritmos a serem utilizados antes de sua implementação.
Além disso, a existência de um modelo formal descrevendo o sistema torna as interdependências entre seus componentes explícitas e claras.
Além de o uso da simulação como uma ferramenta para teste de especicações, esta também ser usada para avaliar o desempenho da aplicação modelada.
O simulador desenvolvido no ambiente do projeto PLATUS permite a realização de simulações sobre modelos descritos utilizando GGBO, a partir de o mapeamento desse modelos para código fonte JAVA.
Dentro de os projetos citados, a linguagem GGBO foi estendida, de maneira a possibilitar denir o intervalo de tempo necessário para que uma mensagem seja tratada.
Em o contexto de mobilidade, atribuir tempos para a entrega local e remota de mensagens assim como para a migração componentes de software permite que o desenvolvedor represente a latência das conexões da rede, o intervalo de tempo necessário para transferir um componente móvel ou outras operações tempodependentes, tornando possível comparar o desempenho de diferentes abordagens e estratégias de distribuição e mobilidade em cenários complexos.
Essa tradução utiliza um gerenciador de comunicações para repassar todas as mensagens entre os objetos, e dar uma coerência temporal a estes eventos.
Os objetos são descritos como classes em Java.
Cada objeto tem e controla um buer de mensagens recebidas e cria threads para executar as regras que manipulam mensagens recebidas.
As regras são descritas também por classes Java, onde é denido qual mensagem tratar, assim como as condições que têm que ser satisfeitas para ativar a execução das regras.
Para que possa ser realizada a vericação de um modelo descrito por uma GGBO, todos os elementos desse modelo (objetos, mensagens, regras e parâmetros) são traduzidos para estruturas na linguagem PROMELA, permitindo a utilização do vericador SPIN.
O processo de tradução consiste em mapear objetos GGBO para processos PROMELA (Tabela 3).
Além de a transformação de objetos para processos, outros elementos do modelo de gramática de grafos devem ser representados por um elemento equivalente na sintaxe da linguagem PROMELA.
Mais detalhes sobre o processo de tradução de GGBO para PROMELA são encontrados em, incluindo uma discussão sobre a compatibilidade semântica entre o modelo GGBO original e o modelo traduzido.
Ainda, em é apresentado como especicar propriedades sobre modelos GGBO usando LTL, levando em consideração a denição de eventos conforme descrita em.
O processo de tradução tanto para simulação quanto para a vericação é feito atualmente de forma automática por uma ferramenta de edição de modelos desenvolvida dentro de o projeto Casco.
A ferramenta é capaz de interpretar os contraexemplos gerados por o vericador, compondo um diagrama de troca de mensagens entre os objetos GGBO presentes no sistema modelado.
Essa funcionalidade mantém o mesmo nível de abstração para o desenvolvedor, eliminando a necessidade de analisar o contraexemplo gerado por o vericador, que é apresentado originalmente segundo os elementos presentes no modelo PROMELA gerado por a tradução.
Em essa seção serão discutidas as propriedades a serem provadas para o modelo apresentado na Seção 3.1.
Para manter tratável o espaço de estados gerado, o modelo será vericado usando se três Slaves e um M aster, e cada Slave aleatorizará somente quatro pontos.
A seguintes propriedades serão formalizadas em LTL e vericadas para o modelo:
Terminação: O modelo gera um resultado, e após isso nenhuma outra regra é aplicada;
Resposta: Um Slave sempre responde a uma requisição;
Convergência: Existe (pelo menos um) cenário levando a um resultado aceitável.
A seguir, será utilizada a sintaxe do vericador SPIN para expressar as propriedades.
Serão utilizados padrões de eventos conforme denidos em, sendo indicado após a propriedade qual foi o padrão de sentença utilizado para a fórmula LTL.·
Terminação: M aster_ Done é a regra a qual calcula o valor nal para.
Assim, devese provar que essa regra é aplicada, e depois de sua aplicação nenhuma outra regra é aplicada.
Para provar a aplicação da regra o modelo pode ser vericado para a seguinte sentença:
Que resulta em verdadeiro.
Como segundo passo, para provar que depois dessa regra nenhuma outra é aplicada, a sentença a seguir foi aplicada ao modelo:
Onde: Any_ Rule $= (M aster_ Start| M aster_ Receive| M aster_ Done| Slave_ Start| Slave_ Continue| Slave_ Done).
Essa fórmula é o padrão de Ausência Depois de um Evento, como apresentado em.
Em o caso, ausência de Any_ Event depois de M aster_ Done.
Essa sentença também representa uma propriedade verdadeira para o modelo.·
Resposta: A cada regra Slave_ Start aplicada existe sempre uma regra Slave_ Done associada.
Essa fórmula corresponde ao padrão Existência (de Slave_ Done) Após um Evento (Slave_ Start), e resulta em verdadeiro.·
Convergência: A convergência do modelo pode ser mostrada para o resultado dentro de um intervalo.
Porém, uma vez que a vericação do modelo considera todas as combinações possíveis de pontos gerados (neste caso, todas as possíveis combinações de pontos estarão fora de o círculo.
É possível provar através de model-- checking que existem computações que convergem.
Usando LTL, para provar que a convergência é possível, será elaborada uma sentença armando que o modelo não irá convergir.
O contraexemplo para essa sentença será um trace mostrando uma seqüência de eventos para a qual o modelo converge.
Porém, é importante lembrar que o fato do resultado convergir ou não para esse modelo está associado à qualidade do gerador aleatório utilizado na implementação real.
Assim, a sentença utilizada foi:
Onde: M aster_ Done_ P i_ Appox $= M aster_ Done &amp; &amp; Esta fórmula corresponda ao padrão de Ausência Global de um Evento e, como esperado, resultou falso.
A Figura 11 mostra um trace com a troca de mensagens entre processos relativa ao contraexemplo obtido a partir de essa sentença.
Este trace foi gerado automaticamente por a ferramenta utilizada na modelagem.
As linhas verticais representam o uxo de execução de cada processo envolvido.
O nome da regra aplicada aparece junto ao uxo de execução, e pode estar associado a qualquer uma das mensagem que estejam disponíveis para aquele objeto quando de a aplicação.
As setas representam o envio de mensagens, e junto a cada uma de elas está o nome da mensagem sendo enviada.
Observe que no contraexemplo existe uma seqüencialização no consumo das mensagens.
Uma limitação na ferramenta de vericação é a falta de suporte a variáveis de ponto utuante.
Para a vericação da sentença, o modelo foi modicado de maneira que 1000× (4× k ÷n) fosse a operação usada na regraM aster_ Done, e testando a convergência do resultado dentro de o intervalo.
Utilizandose um número maior de pontos aleatorizados em cada Slave poderiase diminuir o intervalo.
Em as seções anteriores foram apresentados a fundamentação teórica e o formalismo de modelagem usado para o projeto de aplicações paralelas.
Em este Capítulo serão propostas e discutidas estruturas de programação genéricas que possibilitem a conversão de um modelo GGBO em código fonte utilizando MPI como biblioteca de comunicação.
A partir de os mecanismos propostos, será gerado o programa correspondente ao modelo introduzido na Seção 3.1, para o qual será analisado o desempenho.
A partir de essa análise, o modelo é modicado e reavaliado.
Ainda, é apresentado um novo modelo visando ilustrar o comportamento do algoritmo proposto para os objetos GGBO em testes de envio de mensagens.
A tabela 4 apresenta um comparativo entre as características oferecidas por o formalismo GBBO e seus correspondentes encontrados num ambiente C/ MPI.
Além de o fato de existirem elementos análogos entre GGBO e MPI que por si só facilitam a tradução, a utilização de uma linguagem formal como entrada para um gerador de código facilita ainda mais a tarefa, por possibilitar a correta e inambígua identicação das estruturas de programação adequadas e geração do código correspondente ao modelo.
Um primeiro passo natural no processo de tradução é mapear cada objeto num processo separado (processo GGBO), possibilitando a execução paralela de regras por processos diferentes do sistema (paralelismo entre objetos concorrência externa).
Poderia ser oferecido também paralelismo na execução de regras dentro de um mesmo objeto GGBO (concorrência interna), porém, isso envolveria o desenvolvimento de um mecanismo de identicação de conitos entre regras, o que não foi feito por inserir um grau de complexidade muito alto para uma implementação inicial.
Outro aspecto a ser considerado diz respeito ao número de mensagens suportadas por o modelo.
O grafo de um sistema GGBO comporta, em tese, uma quantidade ilimitada de mensagens que podem ser consumidas a qualquer momento por o objeto ao qual essa mensagem se destine.
Essa característica pode ser aproximada utilizandose uma lista encadeada (Lin) para armazenar as mensagens já recebidas e ainda não processadas em cada processo GGBO.
Assim, pode se suportar um volume relativamente grande de mensagens, dentro de os limites que a alocação dinâmica de memória permitir.
Denido o tratamento a ser dado para as mensagens do sistema, podese determinar o processo para seleção e execução das regras existentes.
Uma vez que Lin abriga todas as mensagens endereçadas ao objeto, sobre essa lista podem ser identicados todos os matches mensagem regra possíveis.
Isso é feito varrendose toda a lista, cruzando cada mensagem (Mi) com as regras (Re) existentes para aquele objeto GGBO e vericando se a condição de ativação da regra (caso exista) é satisfeita.
Como uma mesma mensagem pode ativar mais de uma regra num determinado momento, a varredura deve cobrir todas as regras suscetíveis àquela mensagem.
Cada par (Mi, Re) gerado por a varredura é armazenado numa lista (Lmatches), de a qual é selecionado aleatoriamente um elemento.
A mensagem indicada é retirada da lista de entrada e consumida disparando a regra associada.
A execução de uma regra pode modicar os valores dos atributos presentes dentro de o processo GGBO e/ ou gerar uma ou mais mensagens.
De maneira análoga com o que é feito com as mensagens recebidas, podese inserir as mensagens geradas numa lista Lout durante a aplicação da regra, deixando o envio dessas mensagens para um passo posterior.
Essa escolha foi feita por livrar a aplicação de regras do ônus relativo ao envio de dados, permitindo assim passar imediatamente ao processamento da próxima mensagem em Lin.
A adoção de Lout possibilita também outras vantagens que serão discutidas nas próximas seções.
A partir de as considerações tomadas, o algoritmo básico executando dentro de um processo GGBO pode ser organizado em oito passos principais:
Recebe uma mensagem M;
Inclui M dentro de a lista de mensagens Lin;
Avalia Lin construindo lista Lmatches;
Seleciona aleatoriamente um par (Mi, Re) de Lmatches;
Retira Mi de Lin;
Aplica a regra Re (consumindo Mi e gerando n mensagens);
Insere cada mensagem gerada em Lout;
Envia cada mensagem em Lout segundo ordenação FIFO.
Esse foi o conjunto de considerações utilizados como base para a geração do código dos processos GGBO.
A seguir, são discutidos com maiores detalhes elementos adotados na denição de um esquema de tradução que possibilitam a transformação desse algoritmo básico em código fonte utilizável.
Considerando a complexidade em se implementar um sistema com tal característica, optou se por utilizar primitivas bloqueantes para envio e recebimento, porém adotando threads distintas para recebimento, processamento e envio de mensagens1.
Essas threads serão referenciadas respectivamente como Sender, Receiver e Evaluate.
De o algoritmo básico apresentado anteriormente, Receiver ca associado à execução os passos 1 e 2, Evaluate comporta os passos 3 a 7 e Sender executa o passo 8.
De essa forma, quebrase a sincronicidade e o processo GGBO (agora composto por três threads) estará apto a tratar as mensagens recebidas mesmo quando ainda existirem mensagens a serem (ou sendo) enviadas.
Ainda, tal estratégia possibilita a implementação de um programa mais modular, facilitando o entendimento, legibilidade e manutenibilidade Devido a o número de ações de comunicação que podem ocorrer num programa paralelo típico, processos são interrompidos mais freqüentemente do que num ambiente seqüencial.
Assim, a manipulação de processos num ambiente multiprogramado ca penalizada.
Para amortizar esse efeito, é comum o uso de threads de processamento dentro de um mesmo programa paralelo.
Diferente de processos completos, que possuem regiões de memória bem delimitadas e protegidas por o sistema operacional, todas as threads de um mesmo processo podem compartilhar uma mesma regiões de memória.
Como resultado existe muito menos contexto para ser salvo quando uma thread deixa o processador em favor de outra, com um custo mais baixo do que o envolvido no chaveamento entre processos.
Ainda, como o código relativo a todas as threads vêm de um mesmo código fonte, o compilador pode gerar de forma eciente o programa que controla a interação entre os elementos.
Todavia, a utilização de threads junto com MPI pode não ser trivial, pois determinadas implementações do padrão de comunicação não são threadsafe.
Uma trecho de código qualquer é dito thread- safe quando funciona corretamente durante a execução simultâneas por múltiplas threads.
Um código pode ser tornado threadsafe, por exemplo, protegendo os dados sensíveis através de exclusão mútua e manipulandoos através de operações atômicas.
Para contornar esse problema, foi feito o uso de um semáforo (M P I_ mutex) para garantir a exclusão mútua em determinadas chamadas à biblioteca MPI aquelas envolvendo o deamon de comunicação.
Essa escolha implica em cuidados adicionais enviando e recebendo mensagens utilizando primitivas bloqueantes.
Como a chamada Recv é bloqueante, se a thread Receiver bloquear M P I_ mutex e após isso car bloqueada num Recv, a thread Sender não poderá fazer nenhum envio, já que não poderá entrar na sua seção crítica antes que Receiver efetivamente nalize o Recv e libere o mutex.
A ocorrência simultânea desse evento em múltiplos processos GGBO pode colocar o sistema numa situação de deadlock.
Assim, antes que Receiver bloqueie o semáforo, essa thread verica se realmente existe uma mensagem a ser recebida através da chamada M P I_ Iprobe, a qual retorna false caso não exista nenhuma mensagem sendo enviada por outro processo (ou thread de processo) ou true (e outras informações de controle) caso contrário.
Sendo necessário executar um Recv, o semáforo é fechado e o processo realiza a chamada, ao nal de a qual o semáforo é liberado.
Caso não seja necessário receber uma mensagem, a thread As Figuras 12 e 13 apresentam o pseudocódigo do laço principal executado por as threads Receiver e Sender, respectivamente.
Evaluate será apresentada posteriormente, na Seção 4.1.3.
Observe a utilização de semáforos nas linhas 16 da Figura 12 e 2 da Figura 13, visando sincronizar o funcionamento entre essas duas threads e Evaluate.
Entre Receiver e Evaluate é utilizado um semáforo binário, uma vez que Evaluate bloqueia somente quando não existirem mais matches.
Assim, sempre que Receiver obtiver uma mensagem, ele seta o semáforo binário em 1, liberando Evaluate caso esse esteja bloqueado esperando uma mensagem que talvez possibilite um match.
Caso a mensagem não possibilite nenhum, Evaluate executa um down no semáforo e pára novamente3.
Disponível a partir de a inclusão da biblioteca sched.
H. Essa chamada força o processo ou thread que a invocou a abandonar o processador em favor de outro processo ou thread que esteja pronto para execução.
De essa forma, é amortizado o efeito de espera ocupada enquanto não existam mensagens a serem recebidas.
Entre Evaluate e Sender é utilizado um semáforo contador, incrementado/ decrementado condeslizamento de um ciclo de execução do laço principal de Evaluate antes que esse efetivamente bloqueie.
Forme o número de mensagens geradas e enviadas por o processo GGBO.
O semáforo mutex_ M P I usado é usado para controlar o acesso exclusivo ao MPI entre as linhas 2 a 8 da Figura 12, e entre as linhas 21 a 23 da Figura 13.
Também são utilizados semáforos para controlar o acesso às listas de armazenamento de mensagens, de modo a garantir a consistência dos dados nas linhas 14 a 17 de Receiver e 4 a 8 (ou 4 e 36) e 29 a 31 de Sender.
Apesar de problemas relativos à threadsafety estarem bastante relacionados à implementação da biblioteca MPI sendo utilizada, a adoção de estruturas de controle bem conhecidas como semáforos e variáveis condicionais possibilita a geração de um código capaz de coexistir com tais problemas, com um pequeno custo em performance.
Mensagens GGBO são traduzidas em mensagens MPI utilizandose estruturas de dados C.
Mensagens devem ser desempacotadas em mesma ordem por o código gerado para o receptor, Dentro de a estrutura de dados gerada por a tradução, o primeiro campo contém identicador do tipo da mensagem correspondente.
Os demais campos (quando existentes) relacionamse a cada parâmetro presente na mensagem.
A Figura 14 apresenta a tradução correspondente em C apresenta as operações de empacotamento e desempacotamento relativas aos parâmetros sendo enviados nas mensagens5.
Apesar de mensagens MPI possuírem um campo F LAG que poderia ser utilizado para in4 O tipo mtype utilizado na estrutura é uma enumeração contendo todas os nomes de mensagens e regras previstos no modelo, além de outras mensagens de controle.
O parâmetro buer indica a área de memória (limitada a Tam bytes) onde a mensagem é preparada para envio.
Em buer_ mesg está a estrutura sendo enviada.
Vetores de tipos de dados primitivos podem ser enviados passandose como parâmetro a posição do primeiro elemento seguida por o número de elementos a serem empacotados.
Observe que para a estrutura em questão, é informado apenas 1 (um) elemento.
O inteiro position é utilizado como um para indicar a posição em buer sendo modicada.
Elementos do tipo mtype são empacotados como inteiros.
Dentro desse primeiro esquema de tradução apresentado, o sistema gerado comporta apenas um tipo de estrutura de dados para mensagem, o qual é um superconjunto contendo todos os parâmetros de mensagem permitidos dentro de o sistema.
Devido a isso, existem mensagens as quais possuem mais parâmetros que o estritamente necessário, assim como operações de empacotamento e desempacotamento relativos a esses campos extras, o que degrada a performance do sistema gerado.
Entre os melhoramentos a serem incluídos em versões futuras está a denição de operações de empacotamento/ desempacotamento mais complexas, associadas ao tipo de mensagem a ser enviada/ recebida em cada situação.
Outra restrição importante adotada é a limitação dos parâmetros das mensagens apenas às estruturas baseadas em tipos de dados suportados por as primitivas de empacotamento MPI.
Assim, durante a modelagem dos sistemas GGBO, não é permitido o envio de estruturas de dados complexas como listas ou las, a menos que o usuário disponibilize operações para transformar essas estruturas em tipos primitivos de dados.
Antes de apresentar a tradução das regras propriamente ditas, será retomado em maiores detalhes o algoritmo de matching, de modo a deixar clara a implementação correspondente aos passos 3, 4 e 5 apresentados na Seção 4.1.1.
A lista Lmatches é composta por pares (Mi, Re), onde Mi associase a uma mensagem em Lin e Re a uma regra do objeto.
Lmatches é preenchida tomandose cada mensagem presente em Lin e avaliando se a condição de ativação de todas as regras, de modo a identicar todas as possibilidades de match para a mensagem naquele momento.
Para regras que não possuem uma condição associada, a simples existência da mensagem já corresponde a um match.
A Figura 16 apresenta um trecho correspondente ao algoritmo de matching proposto.
O tipo Elo declarado na função referência elos da lista encadeada usada para o armazenamento das mensagens.
Por exemplo, se a regra M aster_ Receive envolvesse o parâmetro points presente na linha 18.
A Figura 17, por sua vez, apresenta o pseudocódigo do laço principal sendo executado por Evaluate.
A função de matching é invocada na linha 6.
Em a gura encontrase explicitado em detalhes a tradução da regra M aster_ Start prevista no modelo Pi.
Sabendose o total de mensagens presentes em Lmatches, pode se aleatoriamente gerar o índice do par mensagemregra a ser utilizado.
A mensagem selecionada pode estar em qualquer posição de Lin.
Fazendose que o primeiro elemento do par (Mi, Re) seja um apontador para o endereço em que se encontra Mi em Lin, podese alcançar diretamente a mensagem, sem a necessidade de percorrer Lin novamente após a construção de Lmatches.
Além disso, decidiuse por a utilização de uma lista duplamente encadeada para implementar Lin, por facilitar a remoção de elementos em qualquer ponto da lista uma vez conhecida sua posição.
Uma vez identicada a regra a ser executada, o processo GGBO realiza os seguintes passos:
Consome a mensagem (retira de Lin, passandoa para um buer dentro de o código da regra;
Atualiza os atributos internos ao processo GGBO, se necessário fazendo uso de funções denidas externamente;
Gera as mensagens, inserindoas numa lista temporário Ltemp interna à thread de processamento (linhas 23 a 35);
Anexa Ltemp ao nal de Lout.
Como a guarda relativa à regra selecionada já é avaliada para a geração de Lmatches e nenhum atributo foi modicado desde então (uma vez que apenas a thread Evaluate é pode alterar os atributos do processo), não é necessário reavaliar essa condição antes de efetivamente disparar a regra.
Caso a inserção de cada mensagem gerada fosse efetuada diretamente na lista de saída, seriam necessários vários locks consecutivos sobre Lout, impossibilitando o acesso à lista por parte Sender em múltiplas situações.
Fazendo uso de uma lista temporária, só é necessário bloquear o acesso Lout para realizar uma operação, tornando a lista mais disponível à thread de envio.
Mensagens endereçadas ao próprio processo (como ocorre nas regras Slave_ Continue) são inseridas diretamente em Lin.
De maneira análoga, Receiver também inclui as mensagens recebidas numa lista temporária (chamada Incoming no pseudocódigo mostrado).
Após a aplicação de uma regra, Evaluate anexa Incoming à lista de mensagens Selected, sobre a qual é realizada a operação de matching.
O grafo inicial é responsável por a denição dos valores de todos aos atributos dos objetos dentro de o sistema, assim como a amarração das referências necessárias.
Outro função realizada por o grafo inicial é a de denir no grafo de estado as mensagens que irão iniciar o funcionamento dos objetos.
Essas duas funções são realizadas em separado no código gerado.
A denição dos valores relativos aos atributos dos objetos é traduzida como um conjunto de atribuições, que cam inseridas no código de cada objeto GGBO imediatamente antes do ponto em que as threads Evaluate, Receiver e Sender são disparadas.
De essa forma esses valores são xados antes do recebimento de qualquer mensagem, impossibilitando que o mecanismo de matching encontre o objeto num estado ainda inconsistente.
A geração e o envio de todas as mensagens é realizada por um processo especial chamado INIT.
A ordem de envio a ser seguida é denida aleatoriamente.
Após a última mensagem necessária ter sido enviada, INIT passa a operar como um coordenador entre os demais processos, conforme será exposto na Seção seguinte.
Tal conguração para INIT implica na necessidade de um processo a mais quando de a chamada de inicialização do sistema.
O esquema de tradução atualmente utilizado não oferece suporte à criação dinâmica de objetos GGBO.
Para este trabalho, tornase interessante adotar um protocolo de detecção de terminação que apresente uma baixa taxa de atraso para a identicação da parada.
Em esse sentido, destaca se o recente trabalho apresentado em.
Porém, o algoritmo proposto, apesar de apresentar resultados interessantes tanto em termos de número de mensagens quanto em atraso de detecção, baseiase no uso de acknowledgements, o que torna sua utilização pouco adequada para este trabalho devido a as modicações necessárias no mecanismo de comunicação.
Assim, optouse por utilizar a solução proposta em chamada Counting, por apresentar maior anidade com os objetivos do trabalho, bem como por adequarse a características de topologia do sistema gerado, conforme será discutido a seguir.
Esse algoritmo baseiase em contagem de mensagens, sinalizando a terminação quando todos os processos estiverem bloqueados e o total geral de mensagens enviadas por os processos for igual ao total de mensagens recebidas.
Ele adaptase à carga do sistema, gerando menos mensagens de controle quando o sistema está ocupado e mais mensagens quando ele estiver com pouco carga.
O algoritmo Counting é uma algoritmo distribuído em duas fases alternantes, utilizado em sistemas gerados a partir de a linguagem de programação paralela Charm.
Toda a comunicação de controle entre os componentes ocorrem seguindo a topologia formada inicialização dos processos, formando uma spanninng tree, suportando a geração dinâmica de novos processos, desde que eles sejam corretamente associados a um pai dentro de a árvore de ativação.
O nodo raiz da árvore assume a função de coordenador, cando responsável por identicar a parada e determinar a nalização do programa primário.
Para o modelo gerado, dentro de o algoritmo de detecção os processos GGBO organizamse hierarquicamente segundo uma topologia em estrela, com INIT como coordenador.
Apesar de a geração dinâmica de processos não ser suportada dentro de o esquema proposto, o protocolo escolhido comporta tal característica, não sendo necessária sua substituição caso a geração dinâmica venha a ser incluída posteriormente na tradução.
O algoritmo usa três tipos de mensagens de controle:
Initialization: Essa mensagem é enviada a todos os componentes, e indica a inicialização da Fase 1 ou Fase 2, alternadamente;
Idle: Essa mensagem signica que cada processo na subárvore abaixo esteve passivo pelo menos uma vez desde a última mensagem idle.
Activity: Essa mensagem é enviada para o pai durante a Fase 2 e contém contador de mensagens (criação e processamento) nas subárvores abaixo de o processo que originou a mensagem.
Dentro de o algoritmo, cada elemento mantém os seguintes contadores:
Nc: O somatório de mensagens primárias geradas por o processo;
Nc: O somatório de mensagens primárias criadas por o processos na subárvore abaixo;
Nc: O somatório de mensagens primárias recebidas por o processos na subárvore abaixo;
Todos são setados em zero no início da Fase 1 e Fase 2, e são enviados como parâmetros em mensagens idle e activity.
Em a Fase 1, cada folha que alcance o estado passivo envia uma mensagem idle a seu pai, com parâmetros Nc $= nc e Nd $= np.
Todos os demais componentes esperam até ter recebido uma mensagem idle de cada lhe&amp;lhes o, adicionando os valores recebidos em Nc e Nd adequadamente.
Uma vez que isso tenha ocorrido, quando o processo tornase passivo, ele envia uma mensagem idle as seu pai, sucessivamente.
Quando o nodo raiz recebe todas as mensagens, ele avalia (comparando os valores locais de Np e Nd) se o sistema alcançou uma possível conguração nal.
Em caso negativo, o nodo raiz considera a Fase 1 ainda ativa.
Em caso positivo, o nodo raiz envia a todos os lhe&amp;lhes os da mensagem initiation, sinalizando o início da segunda fase.
O broadcast continua até alcançar os nodos folha.
De maneira semelhante à Fase 1, mensagens idle são enviadas.
Quando o processo raiz estiver de posse de todas as mensagens necessárias, compara se os valores obtidos são os mesmos da rodada anterior.
Em caso negativo, o nodo raiz inicia a Fase 1 novamente.
Em caso positivo, o nodo raiz sinaliza a terminação para os demais processos.
São utilizadas duas fases para evitar casos em que numa conguração intermediária qualquer possa ser caracterizado um falso positivo.
Em esta seção são apresentadas medidas de desempenho relativos à execução do código gerado por a metodologia apresentada.
Todos os testes foram realizados no CPADPUCRS (Centro de Pesquisa em Alto Desempenho).
Inicialmente são apresentados dois testes para avaliar o desempenho do sistema enviando e recebendo mensagens.
O objetivo principal destes testes é medir a estabilidade do modelo enquanto executando operações simples.
A Figura 18 apresenta o conjunto de regras utilizadas no modelo, e na Figura 19 são apresentados dois exemplos de grafos iniciais relativos aos testes realizados.
Os demais grafos iniciais não serão mostrados por questões de espaço.
Em o teste 1 existem dois processos GGBO (A e B) e apenas uma mensagem SendM e sempre em trânsito, sendo continuamente recebida e reenviada um determinado número de vezes (regra T est_ ReSend).
Em cada execução, os tempos foram tomados na primeira aplicação comportamento do sistema gerado se manteve uniforme, com o tempo de execução aumentando linearmente devido aumento do número de reenvios.
A curva obtida para o segundo teste apresenta um crescimento polinomial em relação a o aumento do conjunto de mensagens.
Isso ocorre devido a o overhead introduzido por o aumento (b) Grafo Inicial Rajada de Mensagens.
Teste 1 -- ReSend Teste 2 -- Rajada ReSend Rajada tempo (s) Aplicações da regra ReSend Tamanho da Rajada (b) Tempos para Rajada de Mensagens.
O número de regras existente também inuência no custo de construção, porém essa inuência é um fator de multiplicação constante durante a execução do sistema Os grácos da Figura 22 referemse ao modelo apresentado na Seção 3.1, variandose o número de processos do tipo Slave participantes e tomandose o tempo total de execução do sistema.
O gráco 22 (a) referese à performance observada para um programa compilado a partir de o código gerado na tradução.
A curva na Figura 22 (b) traz medições obtidas para um algoritmo paralelo simples gerado manualmente, cujo funcionamento é análogo ao do modelo GGBO proposto.
Este programa será referenciado como programa base.
A Figura 23 mostra uma comparação entre os resultados obtidos.
Podese observar que os tempos obtidos a partir de o código traduzido são em torno de seis vezes maiores que os relativos ao programa base (apresentando porém o mesmo comportamento).
Isso acontece porque no exemplo existe um laço de repetição modelado como aplicação de re-Variando Slaves -- Código traduzido a partir de o Modelo Variando Slaves -- Código Base Modelo Código Base tempo (s) Slaves Slaves (a) Código gerado por a tradução do modelo.
Uma modelagem mais realista não utilizaria tal estratégia, e sim faria uso de funções externamente denidas.
Assim, substituindo as sucessivas execuções da regra Slave_ Continue por a chamada a uma função seqüencial idêntica ao laço executado no corpo do processo escravo do programa base, têmse a regra apresentada na Figura 24.
A diferença encontrada nas medições de tempo aproximase gradativamente de um valor constante, à medida que a paralelização diminui o processamento seqüencial em cada nodo.
Esta diferença existe porque os custos de comunicação entre os modelos são diferentes enquanto no algoritmo base somente é necessário o envio de um valor inteiro entre mestre e escravo (o que é realizado numa única chamada à plataforma MPI) no código traduzido são necessárias (neste caso) quatro operações relativas ao empacotamento/ desempacotamento de mensagens, assim como a manipulação de listas encadeadas.
Outro fator que leva a tempos diferentes são as operações de matching realizadas por o objeto antes da execução de regras.
É importante lembrar que o algoritmo modelado é bastante simples, sendo apenas utilizado como exemplo inicial para o estudo de aplicações paralelas.
A utilização de geração de código a partir de modelagem e tradução se aplica melhor a sistemas que contêm cenários mais complexos durante a execução, onde as possibilidades de análise oferecidas por a utilização de GGBO como vericação e simulação podem também ser utilizadas como apoio durante o desenvolvimento.
Em a Seção anterior foram apresentadas as estruturas de programação utilizadas na tradução de um modelo GGBO para código fonte C/ MPI.
Em esta seção, será apresenta a vericação do algoritmo proposto para os objeto GGBO.
Isso será feito para provar que a semântica de um objeto GGBO é respeitada por o programa gerado na tradução.
Outra alternativa para tal objetivo seria realizar uma prova formal de que a correspondência existe.
Porém, tal prova necessitaria da denição formal tanto para a linguagem de programação quanto para a biblioteca de comunicação utilizadas.
Para possibilitar a vericação do algoritmo, a estrutura básica gerada por a tradução GGBO C/MPI um template para processos será convertida num modelo PROMELA e vericada com a ferramenta SPIN.
Será elencado um conjunto de propriedades os requisitos do sistema a serem oferecidos por um objeto GGBO.
Essa propriedades todas deverão ser obedecidas por o programa gerado para que o comportamento apresentado seja correto.
Em a elaboração do modelo para vericação será mantida uma grande correspondência entre o código fonte C/ MPI e o código PROMELA utilizado, de modo que o conjunto de propriedades vericado possa ser aceito como verdadeiro para o código gerado.
Durante o transcorrer do propostas e as abstrações utilizadas para a vericação.
São esperadas as seguintes propriedades de um programa que implemente um objeto GGBO:·
Propriedade I Todas as mensagens com match são consumidas:
As mensagens existentes são consumidas até que não exista mais nenhuma presente no grafo de estado, ou que não existam mais regras habilitadas por essas mensagens.·
Propriedade II Qualquer mensagem com match pode ser consumida:
Existindo mais de uma mensagem disponível no grafo de estado do sistema, endereçadas a um mesmo objeto, qualquer uma dessas mensagens pode ser consumida se existir pelo menos uma regra habilitada.·
Propriedade III Mensagens podem ser consumidas em qualquer ordem:
Existindo mais de uma mensagem disponível para um mesmo objeto no grafo de estado do sistema, não deve existir nenhuma ordenação implícita no consumo de mensagens resultante de alguma característica presente no mecanismo de matching utilizado, a menos que existam condições associadas às regras que determinem tal ordenação.·
Propriedade IV Regras independentes podem ser aplicadas em qualquer or-dem:
De a mesma forma que foi apontado no item anterior, não deve existir nenhuma ordenação implícita na aplicação de regras independentes.
Essa propriedade deve ser verdadeira mesmo quando essas regras puderem ser disparadas por mensagens idênticas.
O modelo proposto é bastante simples, não sendo necessária a utilização de nenhum TAD associado.
Assim, o código fonte correspondente é elaborado apenas em termos de a estrutura proposta no Capítulo 4.
A partir de o modelo GGBO apresentado foi gerado o código C/ MPI correspondente, e a partir desse código foi elaborado um modelo PROMELA análogo, que foi utilizado para a análise.
Em o código do processo GGBO foi utilizada uma estratégia baseada no uso de três threads distintas para o recebimento, tratamento e envio de mensagens.
Essas threads interagem entre si através do uso de listas encadeadas para o armazenamento das mensagens.
Cada uma das threads de processamento será mapeada para um processo PROMELA distinto.
Chamadas a procedimentos e funções serão substituídas no modelo por chamadas a estruturas PROMELA inline.
Tais extruturas denem trechos de código PROMELA que são inseridos no modelo no ponto em que foram invocados.
Essas estruturas não possuem parâmetros de invocação ou variáveis de retorno.
De essa forma, o modelo para procedimentos/ funções é elaborado de modo que as atualizações ocorram modicando diretamente as variáveis do processo que chamou o inline.
Semáforos binários são mapeados para canais de comunicação de tamanho 1.
Assim, quando um processo execute down (mutex) (que ca mapeado para uma operação de receive no canal), este cará bloqueado caso o valor de mutex seja zero (ou seja, se o canal estiver vazio).
De maneira análoga, variáveis de condição cam modeladas através do uso de canais de comunicação, porém nesse caso são utilizados canais com uma maior capacidade de armazenamento.
Quando outro processo realizar um up (mutex) (i.
e enviar uma mensagem para o canal), o processo bloqueado poderá continuar normalmente.
Em a implementação original, foi utilizada alocação dinâmica de memória para as funções de manipulação de lista.
Porém, canais são limitados a um número máximo de elementos.
Apesar de a utilização de alocação dinâmica oferecer uma grande exibilidade no número de mensagens, ainda assim existe um limite no volume máximo de mensagens passivo de ser tratado.
De essa forma, a abstração de uma lista encadeada num canal de mensagens nito não representa um impacto maior do que limitar o tamanho da memória disponível para o programa.
MPI síncronas send/ receive são mapeadas para operações de envio e recebimento sobre canais alguma mensagem no canal, e false caso contrário.
Além de os processos necessários ao funcionamento do módulo sendo analisado são gerados dois processos adicionais:
Um driver, responsável por gerar as mensagens que irão disparar o funcionamento do elemento sendo vericado, e um stub, responsável por consumir as mensagens geradas e, eventualmente, gerar as respostas necessárias para o funcionamento do módulo.
Para a vericação do modelo apresentado, será tomado como módulo do processo GGBO os três processos PROMELA correspondentes às threads Sender, Evaluate e Receiver.
O driver PROMELA cará responsável por gerar três mensagens mesg com parâmetros em ordem crescente.
O stub utilizado realiza apenas o consumo das mensagens enviadas por o módulo.
Observe que, apesar de essa abstração, existe uma grande semelhança entre as funções desempenhadas por INIT e por o driver, assim como entre o objeto Dest e o stub.
Uma vez denida a estrutura do modelo PROMELA a ser utilizado, podese partir para a vericação das propriedades propostas.
Para provar que todas as mensagens com match podem ser consumidas foi incluída no modelo a variável global consumed_ mesg_ value, atualizada por Evaluate.
Em essa variável é copiado o valor do atributo mesg de Object.
Esse atributo duplica o valor contido na mensagem consumida por a aplicação de uma regra, tanto para Rule_ 1 quanto Rule_ 2.
Observe no modelo que essas regras estão sempre habilitadas por a existência de uma mensagem, portanto, sempre existem matches no modelo, enquanto existirem mensagens.
A partir de essa variável tornase possível observar qual o estado em que o modelo se encontra durante o seu funcionamento.
Sobre ela foram denidas as seguintes proposições atômicas:
A partir de essas proposições foram elaboradas e vericadas as seguintes sentenças:
Eventualmente m1 é consumida:
True; Eventualmente m2 é consumida: (m2):
True; Eventualmente m3 é consumida: (m3):
True; É importante lembrar que em toda sentença LTL existe implicitamente subentendido o operador de caminhos A, ou seja, a sentença sempre é vericada para todas as possíveis seqüências de estados do modelo.
Assim, ca provado que, em todos os possíveis caminhos oferecidos por a execução do modelo, em algum estado futuro a partir de o inicial, a mensagem m1 é consumida, assim como no futuro m2 e m3 são consumidas.
Para provar que mensagens podem ser consumidas em qualquer ordem foi denida mais uma variável global, consumed_ mesg_ ord, também modicada por Evaluate.
Em essa variável, inicializada em zero, é copiado valor presente no atributo ord de Object atualizado na aplicação de uma regra.
Esse atributo sempre é incrementado na aplicação de uma regra, e indica qual é a ordem da mensagem sendo consumida (primeira, segunda, etc.) no momento da aplicação.
Sobre essas duas variáveis foram denidos as seguintes proposições atômicas:&amp;
dene rst_ m1&amp; dene rst_ m2&amp; dene rst_ m3 Inicialmente, foram vericadas as seguintes sentenças:
Eventualmente m1 é consumida primeiro:
False Nunca m1 é consumida primeiro:
False Por as propriedades provadas na Seção anterior, sabese que tanto m1 quanto m2 e m3 são efetivamente consumidas num determinado momento da execução do modelo.
Por as primeiras duas sentenças vericadas nesta Seção, têmse que existem tanto casos onde m1 não é a primeira mensagem consumida (nos contraexemplos resultantes da primeira vericação), quanto casos onde m1 é a primeira mensagem consumida (nos contraexemplos da segunda).
Analogamente, podese expressar as sentenças para m2:
Eventualmente m2 é consumida primeiro: (rst_ m2):
False Nunca m2 é consumida primeiro:(!
Rst_ m2):
False Ou seja, por os contraexemplos, existem casos onde m2 não é a primeira consumida, assim como casos onde m2 é a primeira consumida.
Igualmente para m3:
Eventualmente m3 é consumida primeiro: (rst_ m3):
False Nunca m3 é consumida primeiro:(!
Rst_ m3):
False De essa forma, podese concluir que qualquer uma das três mensagens pode ser consumida em primeiro lugar.
Podese ainda provar que qualquer uma das mensagens pode ser a primeira a ser consumida numa única sentença verdadeira.
Para tanto são aplicadas ao modelo:
Eventualmente m1 é consumida primeiro, ou eventualmente m2 é consumida primeiro:
Eventualmente m1 é consumida primeiro, ou eventualmente m3 é consumida primeiro:
Eventualmente m2 é consumida primeiro, ou eventualmente m3 é consumida primeiro:
Provadas essas propriedades, foi vericada a seguinte sentença:
Eventualmente m1 é consumida primeiro, ou Eventualmente m2 é consumida primeiro, ou Eventualmente m3 é consumida primeiro:
Conforme observado nas propriedades vericadas, cada um dos termos do ou é falso isoladamente, e também cada par possível de ser composto a partir de as subfórmulas1.
A sentença é verdadeira somente quando todos as mensagens forem consideradas, ou seja, quando enunciar que tanto m1 quanto m2 quanto m3 puderem ser a primeira mensagem consumida.
De maneira análoga, a partir de a denição das proposições:&amp;
dene sec_ m1&amp; dene third_ m1 Isso porque o termo não considerado na fórmula surge como contraexemplo para a sentença.
Eventualmente m1 é a segunda consumida:
False Nunca m1 é a segunda consumida:
False Eventualmente m1 é a terceira consumida:
False Nunca m1 é a terceira consumida:
False Eventualmente m2 é a segunda consumida: (sec_ m2):
False Nunca m2 é a segunda consumida:(!
Sec_ m2):
False Eventualmente m2 é a terceira consumida: (third_ m2):
False Nunca m2 é a terceira consumida:(!
Third_ m2):
False Eventualmente m3 é a segunda consumida: (sec_ m3):
False Nunca m3 é a segunda consumida:(!
Sec_ m3):
False Eventualmente m3 é a terceira consumida: (third_ m3):
False Nunca m3 é a terceira consumida:(!
Third_ m3):
False E, a partir de essas sentenças2:
A partir de as propriedades provadas para o modelo, podese concluir que qualquer uma das três mensagens geradas por o driver pode ser consumida na aplicação da primeira, da segunda ou da terceira regra.
Apesar de m1 poder ser consumida tanto na aplicação da primeira quanto da segunda ou terceira regra (o mesmo valendo para m2 e m3), ainda pode existir uma ordem implícita no consumo das mensagens.
Por exemplo, suponha que exista uma dependência circular no consumo de mensagens numa ordem, sendo que tal dependência faça que o consumo de De a mesma forma que foi realizado para a sentença anterior que considera as três mensagens, todas as com-binações de subfórmulas possíveis dentro de cada uma destas sentença foram vericadas, resultando todas em falsidade.
Tais sentenças foram omitidas por questão de espaço.
Tal ordenação não ca excluída nas propriedades provadas até então.
Assim, resta provar que a ordem em que uma mensagem é consumida não inuência na ordem que as demais o são3.
A partir de os predicados denidos para provar a propriedade anterior, as seguintes propriedades foram vericadas:·
m1 é consumida antes de m2;·
m1 é consumida depois de m2;
As propriedades enunciadas foram formalizadas em LTL utilizando os padrões de sentenças apresentados em.
Para a primeira sentença, os contraexemplos mostrados envolviam tanto m1 sendo consumido depois de m2 quanto m3 sendo consumido antes de m2.
A segunda sentença por sua vez pode ser violada fazendose m1 ser consumida antes de m2 (exatamente o comportamento vericado na sentença anterior) ou fazendose m3 ser consumida após m2.
De maneira análoga ao realizado na subseção anterior, foi elaborada uma terceira sentença enunciando que m1 é consumida antes de m2, ou m1 é consumida depois de m2:
Assim, temse que m1 pode tanto ser consumida antes de m2 quanto depois de m2, ou seja, não existe uma dependência no consumo de m1 e m2.
De a mesma forma, foram vericadas as seguintes sentenças sobre a ordenação entre m1 e m3:
Por último, as seguintes sentenças correspondentes a m2 e m3 foram aplicadas ao modelo:
Para os casos em que isso não estiver explicitamente previsto no modelo sob a forma de uma condição associada às regras incluídas no modelo m2 é consumida antes de m3:(!
M2 U m3):
False m2 é consumida depois de m3:
False m2 é consumida antes de m3, ou m2 é consumida depois de m3:
A partir de as propriedades vericadas, podese concluir que não existe nenhuma ordem relativa no consumo de mensagens.
Ainda, associando esse resultado ao obtido na subseção anterior, onde foi vericado que uma mensagem pode ser consumida em qualquer ordem, podese concluir que as mensagens são consumidas em todas as ordens possíveis.
Durante o funcionamento do modelo, uma mesma regra pode ser aplicada várias vezes, ou pode haver uma intercalação entre a aplicação da primeira ou da segunda regra.
Para possibilitar a detecção de qual regra foi aplicada durante o funcionamento do modelo, foi incluído no modelo a variável global event_ rule_ name, atualizada por Evaluate imediatamente após a execução do último comando relativo à regra aplicada.
Essa variável recebe rule_ 1 caso a regra aplicada tenha sido Rule_ 1, ou rule_ 2, caso Rule_ 2 tenha sido executada.
Ainda, antes da determinação de qual mensagem será consumida na aplicação de uma regra, o estado de event_ rule_ name é alterado para nothing, possibilitando assim a detecção da aplicação de uma mesma regra sucessivas vezes.
Sobre o estado de event_ rule_ name foram denidas as seguintes proposições atômicas:&amp;
dene Rule1 Para provar que regras podem ser aplicadas em qualquer ordem, inicialmente vericaramse as seguintes sentenças:
Eventualmente regra1 é aplicada:
False Eventualmente regra2 e aplicada:
False Eventualmente regra1 é aplicada, ou Eventualmente regra2 é aplicada:
De maneira análoga ao que ocorre com as sentenças simples vericadas para as propriedades anteriores, especicandose apenas obtémse contraexemplos mostrando que existem casos em que apenas Rule2 é aplicada sucessivas vezes.
Especicandose apenas obtémse contra exemplos mostrando sucessivas aplicações de Rule1.
Com a terceira sentença, provase que tanto Rule1 quanto Rule2 podem ocorrer para ao modelo.
Uma vez provado que ambas as regras podem ser aplicadas, resta provar que pode existir alternância nessa aplicação, ou seja, que os contra exemplos mostrados não são as únicas possibilidades em que Rule1 e Rule2 são aplicadas.
Para tanto, foram vericadas para o modelo as sentenças:
Regra 1 não é aplicada após Regra2:
Regra 1 não é aplicada antes de Regra2:
False Regra1 ou Regra2 podem ser aplicadas depois de Regra2:
Regra1 ou Regra2 podem ser aplicadas depois de Regra1:
True De o primeiro conjunto de sentenças vericado, temse que tanto Rule1 quanto Rule2 podem ser aplicados no sistema.
A partir de os contraexemplos obtidos para as sentenças, podese concluir que existem tanto casos em que a mesma regra é aplicada sucessivamente quanto casos em que existe alternância na aplicação de regras.
Apesar de o modelo apresentar algumas abstrações em relação a o template original, o código PROMELA foi elaborado procurando manterse a mesma estrutura e semântica do template proposto.
As estruturas inline para funções e procedimentos foram elaboradas de maneira a apresentar o mesmo comportamento presente nas oferecidas por o programa original.
Apesar de serem utilizados canais para representar listas encadeadas e semáforos, as operações sobre canais permitem simular o funcionamento das operações básicas, facilitando a modelagem de maneira geral.
Assim, uma vez provadas as propriedades para o modelo do template utilizado, podese esperar que estas sejam obedecidas por os programas gerados a partir de o esqueleto proposto.
A seguir serão realizados estudos de caso, visando exemplicar a utilização de GGBO para a implementação de aplicações paralelas.
Em esse capítulo são desenvolvidos estudos de casos visando ilustrar a utilização da técnica proposta.
Para tanto, será apresentado um problema cuja solução possa ser implementada de maneira distribuída utilizandose uma estratégia em fases paralelas.
São apresentados dois modelos GGBO semelhantes para o problema.
Finalmente, os modelos são vericados, sendo provadas propriedades relativas ao correto funcionamento e terminação.
Metálica Considere uma na peça de metal quadrada, de a qual seja necessário determinar a distribuição de temperatura quando suas laterais estiverem em contato com diversas fontes de calor.
Em essa situação, dentro de uma determinada faixa de valores1, a temperatura do ambiente altera a temperatura do corpo, até que o sistema alcance uma conguração onde a temperatura em cada ponto da peça permanece inalterada.
A temperatura dos pontos presentes nas laterais da placa rapidamente alcança uma temperatura constante e igual à dos corpos aos quais ela está em contato.
A temperatura dos pontos presentes na superfície interior da placa, por sua vez, depende da temperatura em torno de ela, onde encontramse as fontes de calor.
A temperatura do interior pode ser calculada dividindose a placa numa grade de pontos, e considerando na temperatura de cada ponto a inuência dos pontos adjacentes.
Recalculando sucessivas vezes essa inuência, podese aproximar a variação de temperatura que ocorre dentro de a peça.
Essa estratégia de cálculo é conhecida como método A partir de um determinado patamar de temperatura, o material pode entrar em fusão.
Para a situação analisada no decorrer desse Capítulo todos os valores de temperatura serão considerados abaixo de tal limite.
Para uma peça bidimensional como uma placa, a temperatura de cada ponto no interior do corpo é calculada como a média das temperaturas de seus quatro pontos vizinhos (quatro lados).
O método pode ser estendido para um volume tridimensional considerandose seis pontos vizinhos em vez de apenas quatro (quatro lados, acima, abaixo).
Suponha que a distribuição de temperatura original de todos os pontos da placa esteja armazenada numa matriz M de dimensões l × c relativas ao tamanho da peça, e os pontos laterais estejam inicializados com o valor da temperatura externa correspondente.
Cada posição Mi, j da matriz associase a um ponto hi, j da peça.
O cálculo da temperatura interna da placa é feito varrendose a matriz (exceto por as linhas e colunas mais externas, em contato direto com o ambiente) e calculandose a nova temperatura hi, j de cada ponto como hi, j $= ÷ 4.
Observe que existe a necessidade de uma segunda matriz para armazenar os novos valores calculados, caso contrário pode ocorrer uma situação em que sejam considerados pontos atualizados e pontos nãoatualizados numa mesma aplicação da função.
De essa forma, são utilizadas duas matrizes, M para armazenar o estado atual da placa, e M para armazenar o próximo estado, calculado em função de a temperatura de cada ponto no estado atual.
Feito isso, copiamse para M os novos valores contidos em M e o processo continua2.
Dentro de um mesmo passo de atualização, o novo valor de temperatura para cada ponto poderia ser calculado em paralelo com os demais.
Por exemplo, utilizando uma cellular processing language, poderiase reproduzir tanto a topologia quanto o cálculo descrito no problema.
Podese também paralelizar o cálculo da distribuição utilizandose troca de mensagens.
Uma abordagem simples seria mapear cada ponto da peça num processo separado, utilizando mecanismos de comunicação para consultar a temperatura do ponto adjacente.
De essa forma, cada processo enviaria quatro mensagens para seus vizinhos (informando sua própria temperatura atual) e obteria a temperatura correspondente da circunvizinhança.
Após a troca de dados, todos atualizariam seus valores num passo paralelo e novamente trocariam mensagens contendo suas temperaturas puntuais.
Tal estratégia, porém, seria extremamente custosa em termos de troca de mensagens.
O Esse passo de cópia não é estritamente necessário.
Contanto que tanto M quanto M possuam as mesmas dimensões e aos mesmos valores para as bordas, podese realizar o cálculo de maneira alternada, avaliando os pontos de M para compor um perl atualizado em M, e depois considerando os pontos de M e denindo o novo perl para M, sucessivas vezes.
Devido a o fracionamento da matriz original, para a realização do cálculo indicado tornase necessário replicar junto a cada pedaço da peça os pontos das peças vizinhas com o qual a fração faz contato.
Isso pode ser feito associando ao perímetro de cada pedaço da placa original um conjunto extra de pontos, responsável por replicar o perl de temperatura das bordas vizinhas.
Assim, é adicionando um contorno de pontos à fração da peça, e para esse contorno é copiado o vetor de temperaturas presente em cada mensagem.
Incluindose na mensagem um parâmetro para indicar a qual lado da peça a mensagem está relacionada, podese atualizar o trecho do contorno relativo à face correspondente.
Uma vez que todo o perímetro esteja preenchido, a nova distribuição de temperaturas dentro de a placa é calculada e, novamente, são enviados aos vizinhos mensagens contendo o perl de temperatura do lado correspondente.
Essas mensagens serão consumidas durante a fase seguinte.
Observe que peças cujas bordas estão em contato direto com o ambiente nunca recebem mensagens indicando a atualização daquele trecho do contorno.
Assim, durante todo o processo de cálculo, os valores setados para o contorno na inicialização do sistema mantémse constantes.
Aproveitando essa característica, fazendose os trechos relativos ao contorno mais externo da placa original receber os valores de temperatura do ambiente, podese reproduzir a inuência externa no aquecimento da peça.
Um arranjo onde todos os processos enviam suas mensagens primeiro para então receber as mensagens dos demais, conforme apresentado aqui, é apontado por a literatura como inse-guro quando utilizandose diretamente a biblioteca MPI.
Por exemplo, caso todos os nodos estejam utilizando primitivas síncronas de comunicação, inicializadas todas em mesma ordem, podese criar um cenário de deadlock, com todos os processos aguardando num receive, por exemplo.
Outra possibilidade seria a utilização de primitivas de comunicação buerizadas (BSend/ BRecv).
A implementação de tais chamadas permite ao programa disponibilizar um volume de dados para o deamon de comunicação e continuar o processamento.
Novamente, essa estratégia poder carregar problemas implicitamente, uma vez que o tamanho dos buers não é especicado por o padrão MPI.
Uma alternativa para tornar o código mais seguro seria a utilização alternada de sends e receives, orquestrada de maneira a garantir que os processos vizinhos executem sempre operações complementares numa ordem que evite o deadlock.
Operações nãobloqueantes também podem ser utilizadas, disparandose todos os sends e receives e utilizandose uma chamada para aguardar que todas as comunicações se completem.
Porém, ambas as soluções requerem um balanceamento natural no número de operações de envio e recebimento entre os participantes, o que nem sempre é trivial dentro de um sistema.
Assim, tais estratégias não são sucientemente genéricas para que possam ser adotadas como uso comum.
A utilização de listas encadeadas para o armazenamento de mensagens, como é feito no código gerado a partir de um modelo GGBO, permite uma maior exibilidade nos mecanismos de comunicação.
De essa forma, é oferecido um nível de abstração mais natural ao problema abordado, evitando que o programador preocupese em evitar alguma arranjo desastroso na ordem das operações de comunicação, facilitando a modelagem e correspondente implementação da solução.
O modelo GGBO apresentado nas Figuras 35 a 40 implementa o método discutido.
O sistema é composto apenas por a classe de objetos Cell.
Cada objeto possui referências apontando os objetos vizinhos (atributos up, dw, lf e rg).
Cada objeto possui um atributo part, relativo ao TAD HeatCalc, onde estão implementadas as estruturas de dados necessárias para a simulação de uma fração da peça metálica por um objeto Cell.
Uma vez realizado Cell_ Start, todos os objetos passam a consumir as mensagens enviadas por os objetos adjacentes, considerando o passo de iteração (atributo phase) em sucessivas aplicações da regra Cell_ Receive.
Observe que existe uma comparação implícita entre o valor contido no atributo phase e o valor contido no parâmetro ord da mensagem Hvet, dado que ambos estão representados por n nas regras.
O atributo count mantém o controle de quantas mensagens já foram processadas dentro de uma mesma fase.
Ainda, no consumo de cada mensagem é atualizado o perl de temperatura na borda da fração da peça, a partir de a função p..
U ().
O controle de quantas mensagens devem ser consumidas antes de realizar o cálculo e o broadcast do perl é feito através da condição associada à regra, que considera o atributo neigh, onde ca setado o número de objetos adjacentes ao nodo em questão.
O objeto Cell apresentado nas Figuras 35 a 36 possui regras considerando quatro nodos adjacentes.
Assim, as regras apresentadas não aplicamse aos objetos responsáveis por as partes laterais da peça metálica.
Portanto, o modelo apresentado deve ser estendido, de maneira a possibilitar o matching para células presentes na borda da grade.
As regras contidas nas Figura 37 e 38 adaptam a regra Cell_ HStart para situações em que o objeto possua apenas três vizinhos e dois vizinhos, respectivamente.
As Figuras 39 e 40, por sua vez, adequam a regra Cell_ HBCast para os casos onde existam três e dois processos adjacentes.
As funções utilizadas no modelo são denida a partir de o seguinte TAD:
Abstract Data Type HeatCalc: EndStruct;
Type heat is Struct:
EndStruct. Operations:
HeatCalc new_ HeatC (initCalc intc);
Inicializa o TAD.
Aloca as matrizes points e ghostpoints, dimensionadas por intc.
Col e intc.
Lin. Dene como intc.
Max o tamanho de vetor.
Ajusta os pers de temperatura nas bordas (superior, inferior, esquerda, direita) conforme os valores passados em intc.
Perf_ up, intc.
Perf_ dw, intc.
Perf_ lf e intc.
Perf_ rg, respectivamente.
Inicializa todos os pontos presentes na fração da peça com o valor passado para intc.
Temperatura. Atualiza o perl de temperatura do lado s de points de para os valores indicados em vet..
Assume u para a linha superior, d para a linha inferior, l para a coluna esquerda e r para a coluna direita.
Retorna o perl de temperatura presente no lado s de points.
Assume u para a linha superior, d para a linha inferior, l para a coluna esquerda e r para a coluna direita.
Atualiza o perl de temperatura de toda a matriz points.
Após sua aplicação, tanto points quanto ghostpoints possuem o mesmo conjunto de elementos.
End HeatCalc. A Figura 41 apresenta o grafo inicial para o modelo discutido.
Observe que não foram explicitados os valores passados como parâmetros para new_ HeatC.
De essa forma, o grafo inicial apresenta uma situação genérica para o arranjo das referências entre os objetos.
De maneira análoga ao modelo HeatCell, no modelo HeatCollumn é necessário denir regras especícas para possibilitar o matching para os processos responsáveis por as bordas da placa.
A tradução dos modelos Heatcell e HeatCollumn para C/ MPI está sendo realizada manualmente, um trabalho ainda em andamento durante a elaboração desse volume.
Até o presente momento, foram implementados protótipos para os modelos, sendo realizados testes iniciais utilizando matrizes de 10 × 10 pontos e a execução de até dez fases.
Para modelo HeatCell existe um grande número de regras envolvidas, o que por sua vez implica num código fonte mais extenso que o dos estudos de casos anteriores, dicultando a depuração.
Em esse sentido, a implementação de um gerador de código seria de grande valia, por realizar de maneira sistemática as modicações relativas a cada modelo, diminuindo assim os problemas enfrentados.
Inicialmente, podese considerar que não deve existir nenhuma diferença de fase entre os processos.
Ou seja: Nenhum processo se desgarra dos demais durante a execução.
Essa característica pode ser obtida num programa MPI utilizandose uma chamada barrier no nal de cada fase, que garante que todos os processos executem essa mesma função de maneira síncrona.
Esse comportamento não pode ser obtido diretamente para o modelo proposto, uma vez que GGBO não disponibiliza nenhuma operação semelhante a um barrier, e todo o processamento é completamente assíncrono.
De essa forma, pode existir num modelo GGBO uma situação em que processos encontremse numa fase (após a execução da regra Cell_ HBCast) e outros ainda na anterior (antes da execução de Cell_ HBCast).
Essa diferença no passo de execução pode ser acumulada conforme o número de células entre outras duas, de modo que a diferença entre duas células quaisquer sucientemente distantes seja ainda maior.
Para garantir que todos os processos computem os valores de maneira coerente, devese garantir que a diferença entre dois processos adjacentes nunca seja maior que uma fase.
Ou seja, essa diferença (observável no valor do atributo phase presente no objeto) nunca pode ser maior do que uma unidade para células vizinhas.
Outra característica importante a ser certicada é a terminação do algoritmo.
Uma vez que o processamento no modelo proposto é feito atrelado a um número máximo de fases (setado no grafo inicial através do parâmetro total das mensagens Start), tal propriedade ca garantida desde que todos os processos possam executar o número suciente de passos.
De essa forma, as propriedades fundamentais em tal estratégia são:
Sincronia: A diferença de fase entre dois processos adjacentes nunca difere em mais de uma unidade;
Terminação: Eventualmente o modelo naliza.
Para a vericação do problema, será utilizada uma peça composta por quatro pontos.
Em a vericação do modelo HeatCell, foram utilizados quatro objetos Cell para compor a grade.
Cada objeto ca responsável por apenas um ponto da grade, e o modelo é congurado por o grafo inicial de maneira a executar três fases.
Para o modelo HeatCollumn, foram utilizados quatro objetos Collumn, cada um de eles responsável por uma coluna de dois pontos, e o modelo executa também três fases3.
Inicialmente tentouse realizar a vericação de HeatCell para uma grade de nove pontos e nove processos, Observe que a vericação é realizada apenas considerando aspectos relativos à troca de mensagens entre os participantes.
As operações oferecidas por o TAD utilizado foram modeladas em PROMELA manualmente.
A vericação das propriedades propostas foi feita da seguinte forma:·
Sincronia: Para vericar a sincronia no modelo HeatCell, é declarado um conjunto de variáveis globais Cell_ P hase_ i, cada uma associada a um processo GGBO, permitindo assim diferenciar os objetos entre si.
Para essa variável é copiado o valor do atributo phase presente no processo associado, imediatamente após a aplicação de cada regra.
Assim, inspecionandose o valor dessas variáveis é possível ter uma visão global da fase em que cada objeto se encontra.
De essa forma, a diferença de fase entre os objetos vizinhos da grade ca registrada nas variáveis globais, permitindo a denição das seguintes proposições atômicas:
Para que as proposições sejam verdadeiras, é necessário que a diferença de fase entre os processos vizinhos mantenhase dentro de o intervalo, indicando que não existe diferença, ou então existe uma diferença de apenas uma mas o grande número de intercalações possíveis para essa conguração impossibilitou o tratamento do modelo.
A partir de essas denições, vericouse a seguinte sentença para o modelo:
Após a vericação obtevese como resultado que a propriedade é verdadeira para o modelo proposto.
Assim, o modelo sempre computa os pontos de maneira coerente, não apresentando um deslizamento entre as fases dos participantes que possa causar a geração de dados inconsistentes.
O modelo HeatCollumn apresenta o mesmo número de processos porém uma topologia diferente.
Assim, a associação de variáveis Cell_ P hase permanece a mesma para os processos, porém foram declaradas as seguintes variáveis globais para monitorar a diferença de fase:
Sobre essas variáveis, as seguintes proposições atômicas foram elaboradas:
E foi aplicada ao modelo a fórmula:
De a mesma forma que para HeatCell, a sentença vericada para o modelo HeatCollumn é verdadeira.·
Terminação: Para vericar a terminação, a partir de as mesmas variáveis globais incluídas para vericar a propriedade anterior, foram denidas as seguintes proposições atômicas:&amp;
def ine Cell_ F inish_ 1 para m igual ao parâmetro total da mensagem Start incluída no grafo inicial do sistema, e i variando de 1 a 9.
Essa conguração corresponde ao estado nal previsto para os objetos dentro de o modelo (número de fases executadas igual ao valor estipulado).
A partir de essas proposições, aplicouse a seguinte sentença aos modelos HeatCell e Heat-Collumn:
A vericação dessa sentença resultou em verdadeiro, indicando que todos os processos podem executar o número indicado de fases para ambos os modelos.
Em este Capítulo foi exemplicada a utilização de GGBO para a modelagem de uma aplicação paralela real, sendo realizada a vericação e a prova de propriedades para os modelos propostos.
Apoiandose nos resultados apresentados no Capítulo anterior, onde foi provado que a semântica do código gerado é a mesma do modelo GGBO, podese assumir que a semântica do programa gerado a partir de a tradução dos modelos apresentados também respeite as propriedades vericadas.
Ainda, desde que a implementação do TAD utilizado no modelo respeite às condições impostas para a sua utilização nesse trabalho, e considerandose que as propriedades enunciadas dizem respeito somente à troca de mensagens entre os participantes, podese manter a correspondência entre o modelo vericado e o programa gerado por a tradução proposta.
O presente trabalho apresenta uma estrutura para a tradução de modelos GGBO em código fonte C/ M P I, possibilitando a sua utilização como uma linguagem de análise e projeto de aplicações paralelas.
Um dos objetivos desse trabalho é a denição de estruturas de dados e algoritmos que ofereçam a semântica do formalismo de modelagem e ainda permitam a sua geração de maneira automatizável.
De essa forma, as estruturas de programação foram propostas visando reproduzir o comportamento de um processo GGBO genérico.
A partir de essa estrutura básica um template o comportamento dos objetos previstos no modelo sendo traduzido é inserido através da inclusão de modicações especícas referentes ao modelo GGBO sendo tratado.
Essas modicações são feitas em quatro pontos:
Em o mecanismo de matching, no código executado por as regras, no processo INIT e nas funções de empacotamento de mensagens.
O mecanismo de matching é modicado visando reproduzir as condições associadas à execução de uma regra, sendo consideradas também comparações denidas do lado esquerdo da regra.
Em o código relativo às ações desempenhadas por a aplicação de cada regra são reetidas as modicações presentes no lado direito da regra.
Em o código relativo ao processo INIT, que reproduz o grafo inicial do modelo, a ordem do envio de mensagens é denida de maneira aleatória.
Também são realizadas modicações relativos ao empacotamento e desempacotamento de dados para as mensagens sendo enviadas.
O template proposto foi vericado, visando garantir que o algoritmo utilizado reproduz o comportamento esperado de um objeto GGBO.
Essa tradução foi feita manualmente, mantendose ao máximo a semelhança entre o código C gerado e o código PROMELA correspondente.
Cada uma das threads que compõem um processo GGBO foi convertida num processo PROMELA, dentro de os quais os procedimentos, funções e estruturas de dados foram também traduzidos.
A partir de a semelhança mantida, pode- se assumir que o comportamento vericado para o modelo do template é mantido por o código gerado.
É importante diferenciar a tradução para PROMELA realizada para o template da tradução realizada automaticamente proposta em.
Enquanto a primeira foi realizada especicamente para o código C gerado, a segunda apresenta um método genérico para a geração de um modelo para vericação a partir de um modelo GGBO.
O presente trabalho usa os resultados obtidos em para provar as propriedades para os modelos GGBO Pi, HeatCell e HeatCollumn.
Apesar de já oferecer resultados que possibilitem a geração e execução de programas a partir de modelos GGBO, existe ainda a necessidade da implementação e incorporação do algoritmo de detecção de parada proposto para a tradução, assim como vericação do modelo correspondente ao código resultante dessa modicação.
Após tal implementação torna- se interessante a reelaboração do código relativo aos modelos já estudados e vericação do template resultante, possibilitando assim uma análise do impacto de sua utilização.
A partir de o esquema de tradução apresentado e análise dos resultados obtidos nesse trabalho, pode- se identicar alguns focos principais de esforços para a melhoria dos algoritmos propostos.
A principal melhoria a ser aplicada no processo de tradução envolve a geração de tipos de mensagens diferentes, com um número mínimo de atributos em cada mensagem, assim como a correspondente modicação nos algoritmos para empacotamento e desempacotamento de dados.
Essas mudanças podem trazer resultados interessantes ao desempenho do código gerado.
Tal modicação se reetiria também nos algoritmos de gerenciamento de listas implementados, possibilitando a utilização de menos atributos em cada elo e um melhor aproveitamento da memória.
Ainda, podem ser realizados estudos visando otimizações no mecanismo de matching, que no momento é bastante genérico.
Uma possível otimização nesse sentido seria a utilização de uma hash table para agilizar a localização do par selecionado dentro de Lmatches, diminuindo o impacto sofrido quando existirem muitas possibilidades de escolha mensagem-regra.
Existem ainda trabalhos a serem conduzidos para oferecer suporte à criação dinâmica de processos, que podem tanto envolver a adaptação da presente proposta de tradução para o padrão MPI-2, ou mesmo buscar uma solução utilizando o padrão atual.
Além de as modicações discutidas, outro importante trabalho futuro é a implementação do protótipo de um gerador de código baseado nas estruturas propostas, a ser incorporado à ferramenta de edição de modelos GGBO existente.
A elaboração desse trabalho também oferece como resultados argumentos que motivam a realização de análise quanto a a extensão da linguagem de modelagem utilizada.
A partir de o estudo de caso desenvolvido no Capítulo 6, pode- se observar que determinadas características presentes no modelo podem exigir um grande número de regras para possibilitar um matching adequado dentro de o grafo de estado.
Em o exemplo, a partir de duas regras elaboradas prevendo quatro processos vizinhos, outras dezesseis foram derivadas visando adequar- se a situações com três e dois processos adjacentes.
Ainda, na Seção 4.2, quanto analisando o comportamento para envio de rajadas de mensagens, por questões de espaço, foi apresentada somente uma regra relativa a uma rajada de duas mensagens, deixando- se comentada a existência das demais regras responsáveis por a geração dos dados apresentados.
Em esse sentido, modicações na linguagem de modelagem visando aumentar a expressividade poderiam facilitar a sua utilização, permitindo abranger um número maior de situações com menos regras.
