A presença de falhas em software sempre foi um grande problema.
Embora as técnicas de teste de software existentes sejam eficientes para encontrar falhas, elas não garantem sua ausência num sistema.
Mecanismos de tolerância a falhas de software são abordagens geralmente utilizadas em casos onde somente teste de software não garante a confiabilidade que um sistema necessita.
Entretanto, esse tipo de tolerância a falhas pode se tornar muito custosa e por isso na grande maioria das vezes é aplicada somente em softwares que necessitam de alto grau de confiabilidade.
Este trabalho propõe uma nova estratégia para o desenvolvimento de software tolerante a falhas.
Esta estratégia se preocupa não somente com a melhora de confiabilidade mas também com a diminuição de custos através de uma manutenção facilitada e da possibilidade de automatização de grande parte do seu processo de desenvolvimento.
A elaboração dessa nova estratégia esta baseada em técnicas tradicionais de tolerância a falhas, técnicas de tolerância a falhas para sistemas orientados a objetos, mutação de código e engenharia de software.
A existência de falhas &quot;faults «nos sistemas de software é um problema para o qual há muito tempo se procura uma solução.
O teste de software é uma alternativa muito conhecida para encontrar falhas e corrigir- las antes que um sistema se torne operacional.
Contudo, mesmo com as técnicas de teste de software se tornando cada vez mais eficazes, além de não se ter certeza se um sistema está livre de falhas, estudos mostram que a razão do número de defeitos &quot;failures «causados por falhas de software têm aumentado gradativamente à medida que o tempo passa Certamente tais fatos têm muito a ver com a complexidade crescente dos sistemas atuais.
Tolerância a falhas de software tem a finalidade de esconder do usuário final possíveis defeitos causados por falhas que passaram despercebidas durante a fase de desenvolvimento e teste de um software.
Estratégias de tolerância a falhas visam fornecer uma maior quálidade a sistemas que necessitam ser muito confiáveis, como por exemplo softwares para usinas atômicas, usinas hidrelétricas, naves espaciais e satélites.
Um dos grandes problemas da tolerância a falhas de software é que sua aplicação num sistema tem um custo alto, pois hâ a necessidade de muitos recursos para que tal aplicação se realize com sucesso.
Em os projetos de sistemas ultrá-confiáveis, onde geralmente já é previsto um orçámento de milhões de dólares, e o que mais interessa realmente é a confiabilidade, visto que falhas podem custar grandes prejuízos, métodos de tolerância a falhas de software são muito atrativos.
Todavia, nem todos os sistemas necessitam de uma ultrá-confiabilidade e nem têm um orçamento tão grande para sua viabilização.
Este trabalho propõe uma nova estratégia de tolerância a falhas de software, a qual tem como principais objetivos possibilitar a construção de sistemas confiaveis e também diminuir o custo no desenvolvimento de aplicações tolerantes a falhas.
Um objetivo adicional da estratégia é possibilitar que software desenvolvido em linguagens de programação orientadas a objetos possam se utilizar dessa tecnologia, visto o crescente uso desse tipo de linguagem nos dias de hoje.
Para que os objetivos propostos pudessem ser alcançados, alterações nas atuais técnicas de tolerância a falhas de software tiveram de ser propostas.
Os principais pontos trabalhados foram:
Diversidade de Projeto (design diversity):
Técnicas de tolerancia a falhas de software necessitam de muitas versões de um mesmo software ou parte de software para funcionar, sendo que tais versões necessitam ser desenvolvidas por equipes de programadores isoladas.
O desenvolvimento de software diverso é sem dúvida uma das etapas mais custosas das estratégias de tolerância a falhas tradicionais.
A proposta elaborada neste trabalho visa permitir uma maior flexibilidade e uma melhor gerência dos softwares diversos necessarios à construção de um sistema.
A abordagem proposta foi elaborada de tal forma a permitir uma melhor administração da quantidade de diversidade a ser utilizada durante todo o ciclo de vida de uma aplicação.
Para que isso fosse possível, componentes de software foram usados como blocos basicos para prover diversidade a um sistema.
Manutenção: Sabe- se que a manutenção do software é um processo caro, e se torna mais caro ainda quando se tem uma quantidade maior de código implementado, como no caso de as técnicas de tolerância a falhas de software, as quais necessitam de software diverso para fornecer maior confiabilidade a sistemas.
A manutenção de software tolerante a falhas é tão cara que em certos casos pode chegar a 70% do custo total de desenvolvimento de um sistema A proposta do presente trabalho é facilitar a incorporação de componentes de software diversos no sistema sendo desenvolvido, com o objetivo de gerar versões diversas de software e ainda melhorar sua manutenção.
Tais facilidades podem ser obtidas através do desenvolvimento de ferramentas automáticas para geração de versões, as quais são capazes de possibilitar tanto uma melhora de manutenção para a correção de falhas como para incorporação de componentes mais confiáveis ao sistema.
A técnica proposta neste trabalho foi denominada de Diversidade Orientada a Mutação (Mutation-Like Oriented Diversity MOD).
Essa técnica é baseada na modificação de instruções no código fonte de uma aplicação para geração de novos softwares diversos.
Os softwares diversos gerados são utilizados na estratégia MOD através do auxílio de técnicas tradicionais de tolerância a falhas de software, como por exemplo Programação NVersões (NVersion Programming NVP) e Bloco de Recuperação (Recovery Block Rb).
O fato de utilizar mutações de código e de ser semelhante a etapa de geração de mutantes da técnica de teste Analise de Mutantes foram os principais responsaveis por a nova abordagem ser denominada de MOD.
Com o objetivo de fazer uma avaliação inicial da estratégia de tolerância a falhas proposta, um estudo de caso de uma calculadora foi desenvolvido.
Em este estudo de caso, dois experimentos foram realizados:
O primeiro envolveu a implementação da calculadora utilizando a linguagem Java.
O segundo compreendeu a programação do sistema da calculadora usando a linguagem Java e as tecnologias CORBA e RMI, para a utilização em ambientes distribuídos.
Estudos foram realizados no sentido fazer comparações entre implementações sem a utilização de recursos de tolerância a falhas e sistemas desenvolvidos com a estratégia MOD de tolerância a falhas.
Para fazer as avaliações necessarias, técnicas de injeção de falhas em software foram utilizadas como recurso.
Visando comparar a eficiência da estratégia MOD com uma técnica de tolerância a falhas tradicional adaptada a orientação a objetos, um segundo estudo de caso foi desenvolvido.
Esse estudo de caso compreendeu a implementação de um editor de texto distribuído, chamado de ECD (Editor Colaborativo Distribuído).
Em este estudo técnicas de teste de software foram utilizadas para comparar as duas versões do sistema ECD (uma utilizando MOD e a outra utilizando NVP tradicional, onde equipes diversas produziram as diferentes versões).
Este trabalho está organizado da seguinte maneira:
O Capítulo 2 apresenta o referencial teórico utilizado no desenvolvimento da dissertação, que envolveu teste de software e tolerância a falhas.
Ainda neste capítulo são apresentados trabalhos relacionados à presente dissertação.
O Capítulo 3 descreve a técnica de tolerância a falhas MOD, a qual é assunto principal dessa pesquisa.
O Capítulo 4 apresenta os estudos de caso desenvolvidos com o objetivo de avaliar a técnica de tolerância a falhas criada.
Finalmente, o Capítulo 5 apresenta as principais conclusões a respeito de o trabalho.
Referencial Teórico. Este capítulo apresenta a fundamentação teórica utilizada no presente trabalho.
A Seção 2.1 introduz o tópico &quot;Teste de Software».
Em essa seção são abordados os níveis de teste, que são estratégias utilizadas para dividir e facilitar o teste de aplicações, e também as técnicas de teste, responsaveis por encontrar falhas no software.
De as técnicas de teste apresentadas, a chamada de Análise de Mutantes recebe atenção especial, devido a sua relação com o trabalho apresentado.
A Seção 2.2 apresenta &quot;Dependabilidade», os conceitos relacionados e a terminologia aceita nesta area de pesquisa.
Tolerância a Falhas de Software é um assunto que recebe uma evidência maior nesta seção, tendo em vista que ele esta diretamente ligado a este trabalho.
As duas técnicas de tolerância a falhas de software abordadas nessa seção são:
Programação N-Versões e Bloco de Recuperação.
Finalmente, a Seção 2.3 faz referência a trabalhos relacionados à presente dissertação.
O principal objetivo do teste de software é encontrar o maior número de falhas possível num sistema sendo testado A partir desse objetivo fundamental, o teste de software vem a possibilitar uma gama de vantagens no processo de desenvolvimento de software, como por exemplo:
Possibilidade de aumentar a confiabilidade do produto através da correção das falhas encontradas, verificar se as funcionalidades do software se comportam como o especificado e ainda avaliar a aceitabilidade ou qualidade do software.
No entanto, embora o teste de software ofereça uma quantidade grande de instrumentos para atingir o objetivo de encontrar falhas em software, ele não é uma ciência exata e conseqüentemente não garante a existência de um sistema livre de falhas O teste de software, embora vantajoso para o desenvolvimento de sistemas, é um prolTradução do termo dependability.
Não existe consenso sobre como traduzir esse termo, desta forma será adotado dependabilidade neste trabalho.
O custo não é a única razão de se realizar o teste de software de maneira adequada.
O teste de software é capaz de fornecer dados valiosos para os desenvolvedores.
Através desses dados é possível, por exemplo, obter vantagens no desenvolvimento de novas versões de um software, ou até obter estimativas de confiabilidade capazes de indicarem o melhor momento para se comercializar um sistema.
Qualidade é outro fator importante nos dias de hoje.
Com a concorrência cada vez maior, a qualidade do produto é fator decisivo para crescimento das empresas.
E embora a qualidade do software não dependa somente do teste de software (ela também é garantida por técnicas de prevenção de falhas), ele tem papel fundamental na obtenção de produtos de alta qualidade.
Antes de prosseguir com o trabalho, torná- se necessario definir alguns termos básicos bastante usados na literatura, pois freqüentemente seus significados não são bem entendidos.
No entanto, é interessante notar que tal terminologia, utilizada na area de teste de software, é um pouco diferente da utilizada na area de tolerância a falhas, a qual sera apresentada adiante neste trabalho.
Os seguintes termos são usualmente utilizados na literatura:
Erro: As pessoas se enganam, ou seja, cometem erros.
Os erros podem ser cometidos tanto na especificação dos requerimentos, projeto ou codificação de um sistema.
Quanto antes os erros são cometidos, mais eles se propagam durante o desenvolvimento do software.
Falha: É a representação ou expressão de um erro.
Um exemplo disso poderia ser um texto escrito para especificação de requerimentos errada ou uma codificação errada por o mal entendimento de uma especificação.
Defeito: Defeitos acontecem quando falhas são executadas.
Um exemplo de defeito é o retorno de um resultado errado por o sistema ou simplesmente o término do sistema de maneira anormal.
Uma possível falha causadora do defeito poderia ser um problema em sua codificação, também comumente chamado de bug.
Casos de Teste:
Casos de teste são a parte mais importante do teste de software.
Um bom desenvolvimento de casos de teste é essencial para que um teste obtenha bons resultados.
A formulação dos casos de teste esta relacionada com a escolha de um conjunto de entradas para um software e do conjunto de saídas esperadas.
Teste: O teste é a atividade de procurar falhas num software a partir de a aplicação de variados casos de teste ao mesmo.
Um teste geralmente é dividido em diversos passos:
Planejamento do teste, desenvolvimento de casos de teste, execução dos casos de teste e avaliação dos resultados.
Devido a complexidade dos sistemas na atualidade, a aplicação do teste de software necessita de organização.
A organização geralmente utilizada consiste em dividir um software em níveis de acordo com 0 modo de desenvolvimento, e testar- lo de acordo com essa divisão.
As vantagens de dividir o teste de software em níveis são muitas:
Facilidade, confiabilidade, efetividade e diminuição do tempo de teste.
A não existência de níveis dificultaria bastante o teste de uma aplicação.
Hoje em dia existem diversos modelos de desenvolvimento de software, tais como, por exemplo, o modelo tradicional, o modelo incremental, o modelo evolucionario, e o modelo espiral.
Sabe- se que o teste de software é dependente dos modelos de desenvolvimento, e portanto cada modelo de desenvolvimento teria seus próprios níveis de teste de software.
Contudo, os níveis de teste identificados no modelo tradicional também são válidos para a maioria dos outros modelos de desenvolvimento, e por isso ele servirá como base para a nossa discussão.
Os níveis de teste estudados nesta seção são mostrados na Figura 2.1 (baseada em Figura de).
Esta figura foi elaborada de acordo com o modelo de desenvolvimento tradicional de software, o qual é muitas vezes chamado de modelo &quot;cachoeira».
Em a figura é possível ver que para cada fase do modelo de desenvolvimento tradicional (descida da cachoeira, parte esquerda da figura) existe um nível correspondente de teste de software (subida, parte direita da figura).
Lnterpretando a parte referente a o teste de software na Figura os quais são elaborados na fase do projeto detalhado;
O &quot;nivel de teste de integração «é responsavel por fazer o teste da integração dos componentes individuais do software, os quais são planejados no projeto preliminar;
O &quot;nível de teste de sistema «é o responsável por fazer um teste do sistema como um todo, correspondente à especificação do sistema.
O &quot;teste de unidade «é um nível de teste de software que tem por objetivo testar individualmente as pequenas partes, módulos ou componentes de um programa.
Ele foi elaborado visando facilitar o processo de teste, visto que o teste de programas completos e inteiros é uma tarefa muito difícil, de alto custo e de baixa produtividade.
Entre as vantagens de se utilizar o teste de unidade estão:
A o se testar um programa grande, as possibilidades de teste são muitas.
Dividindo- se o programa em pequenas partes facilita o processo de administrar a explosão combinatorial de testes;
O teste de unidade facilita o processo de encontrar uma falha, pois se sabe que as falhas encontradas numa unidade estarão restritas àquele pequeno pedaço de código pertencente ao teste de unidade;
Com uma maior facilidade no processo de se localizar uma falha também se adquire uma maior facilidade no processo de corrigir- las;
Uma parcela de paralelismo é adicionada ao processo de teste, ou seja, varias unidades podem estar sendo testadas ao mesmo tempo, trazendo portanto a possibilidade de diminuição do tempo de teste de um software.
Em a aplicação do teste de unidade, duas são as informações que podem ser utilizadas para que seja possível testar um software.
Em primeiro lugar, o próprio código da unidade sendo testada é utilizado no desenvolvimento de casos de teste.
Através de ele são elaboradas as entradas que farão parte do teste e suas respostas esperadas.
Tal tecnica de teste, a qual utiliza o código do sistema para elaboração dos casos de teste é chamado de teste &quot;estrutural», ou também teste de &quot;caixa branca», A segunda informação que pode ser utilizada no teste de unidade é a sua especificação.
Através da especificação podem ser elaborados os casos de teste utilizados para efetuar o teste do sistema.
Esse tipo de teste, o qual não utiliza o código da aplicação e sim somente sua especificação de funcionalidade, é freqüentemente chamado de &quot;funcional «ou &quot;caixa preta».
A técnica de teste de &quot;caixa preta «é menos utilizada que a &quot;caixa branca «no teste de unidade.
O &quot;teste de integração «é um nível de teste que tem a finalidade de encontrar uma classe de falhas diferente do teste de unidade.
Em o teste de integração tentá- se encontrar falhas quando os componentes do software são agrupados para trabalhar juntos e formar um sistema, ou seja, o objetivo é avaliar o comportamento do software quando suas partes são unidas.
A o contrario do teste de unidade, os casos de teste para o teste de integração são desenvolvidos principalmente por tecnicas de testes &quot;caixa preta», pois seu objetivo é testar as interfaces de comunicação entre os componentes ou módulos do software, os quais já devem ter passado por o teste de unidade.
O &quot;teste de sistema «e um nível de teste que tem como principal objetivo averiguar se 0 software esta inconsistente com os seus objetivos originais Em o teste de sistema, não são feitos testes funcionais ou estruturais, pois isso seria redundante com os níveis de teste de unidade e de integração, mas sim testes que encontram outras classes de falhas.
O desenvolvimento de casos de teste para teste de sistema envolve uma comparação da analise da documentação do usuário com uma analise dos objetivos da aplicação.
A partir de isso, os casos de teste são aplicados ao software para averiguar se os objetivos foram atingidos ou não.
No entanto, não é possível criar uma metodologia para o desenvolvimento desses casos de teste, pois objetivos variam muito de aplicação para aplicação.
Visto que metodologias praticamente não são possíveis, geralmente o desenvolvimento de casos de teste de sistema segue algumas categorias, sendo que as principais são:
Testes de funcionalidade, testes de volume, testes de stress, testes de usabilidade, testes de segurança, testes de performance, testes de armazenamento, testes de configuração, testes de compatibilidade, testes de facilidade de instalação, testes de confiabilidade, testes de recuperação e testes de documentação Durante a fase de manutenção muitas mudanças podem vir a ocorrer num software.
Exemplos disso são a correção do código fonte em função de defeitos apresentados, a adição ou remoção de funcionalidades ao software e até mesmo modificações em suas especificáções.
O &quot;teste de regressão «é um nível de teste que tem como principal objetivo validar essas correções e modificações realizadas no software, assegurando que elas introduzam o menor número possível de novas falhas ao programa.
Como recém visto, cada nível de teste de software usa técnicas para que seja possível o desenvolvimento de casos de teste para um determinado sistema.
Cada uma destas técnicas oferece procedimentos diferentes com os quais é possível identificar falhas em programas.
É interessante também salientar que não existe nenhuma técnica perfeita, e por isso não se pode eleger uma técnica de teste como a melhor forma de testar um programa.
A melhor abordagem que se pode adotar para o teste de um programa e fazer uma mistura da aplicação de diversas técnicas de teste.
Em o restante dessa seção serão apresentadas três técnicas/ estratégias de teste de software:
Teste funcional ou &quot;caixa preta», teste estrutural ou &quot;caixa branca «e teste de Analise de Mutantes.
Teste funcional e uma técnica de teste de software que não leva em consideração o comportamento interno ou a estrutura do código fonte da aplicação, e por isto somente a especificação do software é suficiente para que se possa desenvolver casos de teste.
Esta técnica esta apoiada na visão de que um programa pode ser considerado como uma função que mapeia um conjunto de valores de entrada num outro conjunto de valores de saída As principais informações utilizadas no teste funcional são os dados de entrada, os resultados esperados para os dados de entrada e os dados de saída.
Esta técnica de teste também é chamada de &quot;caixa preta», pois o conteúdo da caixa, ou seja, o código do programa, não é conhecido por as pessoas responsaveis por o teste.
Basicamente, o teste funcional trabalha da seguinte maneira:
Escolha dos dados de entrada adequados para o teste do programa.
Visto que o conjunto de dados de entrada para um sistema pode ser muito grande, ou até infinito, geralmente se define metodologias para escolher um subconjunto de dados de entrada.
Um exemplo é a escolha aleatória de alguns dados contidos no conjunto de entrada.
Outro exemplo mais elaborado é a escolha de dados que tem uma maior probabilidade de serem fornecidos por um usuário;
Definição dos valores esperados como saída para os dados de entrada escolhidos.
A definição dos valores de resposta esperados pode ser bastante custosa, dependendo da complexidade das operações realizadas por o sistema e também do tamanho do subconjunto de dados escolhidos;
Aplicação dos dados de entrada ao sistema em teste.
Em alguns casos, não é necessária a utilização do sistema inteiro, mas sim somente algumas partes ou módulos do mesmo são postos em execução;
Comparação dos resultados obtidos com os dados de saída esperados;
Reparo do sistema em teste quando falhas forem encontradas.
O teste de software &quot;caixa preta «apresenta duas principais vantagens:
Os casos de teste desenvolvidos são independentes da implementação, e por isso, mesmo que o código do software mude, os casos de teste continuam sendo úteis.
O outro fator positivo é que o desenvolvimento dos casos de teste pode ser realizado em paralelo com a implementação do software, visto que este é baseado simplesmente na sua especificação.
Essa vantagem pode resultar numa diminuição do tempo total de desenvolvimento do projeto.
Entretanto, os testes de &quot;caixa preta «também têm fatores negativos, como por exemplo, a possível existência de casos de teste redundantes.
Um outro exemplo é a dificuldade de elaborar casos de teste que cubram todas as classes de dados de entrada, ou seja, ha a possibilidade de existir funcionalidades não totalmente testadas no sistema por os casos de teste definidos.
Existem diversas diferentes metodologias para o desenvolvimento de casos de teste funcionais, sendo que as abordagens mais conhecidas são:
Teste com valores de entrada randômicos, teste de entrada exaustiva, analise de valores limites, classes de equivalência para dados de entrada, classes de equivalência para dados de saída e testes baseados em tabelas de decisão.
Detalhes sobre essas abordagens de elaboração de casos de teste para o teste funcional podem ser encontrados em.
Diferentemente do teste de software funcional, o teste de software estrutural leva em consideração a implementação dos programas.
Esse tipo de teste também é chamado de teste de &quot;caixa branca «(ou caixa limpa), por o motivo de trabalhar com o código do programa, ou seja, enxergar dentro de a caixa, ao invés de somente conhecer a funcionalidade da caixa.
Algumas vantagens apresentadas por o teste de software estrutural são a minimização das redundàncias nos casos de testes, realização de heurísticas baseadas em erros comuns de programação, de entre outros.
Entretanto, desvantagens também existem:
Novos casos de teste devem ser realizados sempre que o código da aplicação é mudado, o teste só pode ocorrer a partir de o momento em que a codificação do programaja foi efetuada, funções não codificadas não podem ser detectadas como erros.
Os testes de caixa branca podem ser divididos em duas categorias:
Testes estáticos e testes dinâmicos.
Os testes estáticos têm a característica de não precisarem que o programa seja executado no computador para serem aplicados, pois todos são realizados através de revisões no código programado.
Existem muitos tipos de testes estáticos, de entre eles destacam- se as inspeções, wallcthroughs, avaliações simbólicas e analise de anomalias A o contrario dos testes estáticos, onde o código é analisado sem ser executado, os testes dinâmicos necessitam de execução do programa.
Eles são semelhantes ao teste &quot;caixa preta «no sentido em que é necessario rodar do sistema.
Contudo, a diferença se encontra na maneira que os casos de teste são desenvolvidos.
Enquanto no teste &quot;caixa preta «os casos de teste levam em consideração as especificações e funcionalidades do sistema, nos testes dinâmicos &quot;caixa branca «o próprio código é levado em consideração no desenvolvimento de casos de teste.
Quanto a elaboração dos casos de teste, os testes dinâmicos são freqüentemente classificados em dois tipos:
Os testes de caminho e os testes de fluxo de dados.
Os casos de teste no teste de caminho são elaborados levando em consideração um grafo que descreve a estrutura do código de um programa.
As variáveis de entrada são escolhidas visando cumprir algum critério de caminhamento nesse grafo.
Ja nos testes de fluxo de dados são outros fatores que fazem com que os casos de teste sejam elaborados:
A combinação das variáveis do programa.
No entanto, embora a elaboração dos casos de teste seja orientada por a combinação de variaveis, eles estão bastante relacionados com os testes de caminho, pois 0 caminho é necessario para verificação dos resultados.
O teste de Análise de Mutantes, ou simplesmente teste de mutantes, é uma técnica de teste aplicada ao nível de unidade de teste de software, a qual é bem diferente das apresentadas anteriormente.
Ao invés de se basear na especificação ou no código do sistema, como fazem as técnicas de teste &quot;caixa branca «e &quot;caixa preta», o teste de mutantes se baseia numa lista de erros comumente cometidos por programadores, a fim de elaborar casos de teste.
É interessante notar que uma das grandes vantagens do teste de mutantes é a possibilidade de automação na sua aplicação.
O teste de Análise de Mutantes tem a finalidade de responder questões que não são respondidas por técnicas tradicionais de teste.
Suponha o caso em que um conjunto de casos de teste foi elaborado para testar um sistema, e não foi capaz de encontrar falhas.
As técnicas tradicionais não são capazes de dizer se as falhas não foram encontradas porque o software realmente era muito bom e não apresentava falhas ou se o conjunto de casos de teste era muito ruim e não foi capaz de encontrar- las.
De essa forma, o teste de mutantes tem dois objetivos principais:
Primeiramente ele procura avaliar a adequação de um conjunto de casos de teste inicial, ou seja, verifica se os casos de teste são realmente capazes de encontrar falhas no software.
Em segundo lugar, caso o conjunto inicial de casos de teste não seja adequado, o teste de mutantes possibilita a elaboração de casos de teste adicionais para melhorar a confiabilidade do teste sendo executado.
Entretanto, a técnica de Análise de Mutantes não pode ser realizada sem a ajuda de uma técnica de teste auxiliar.
Ela necessita que exista um conjunto de casos de teste inicial, desenvolvido por qualquer outra técnica de teste.
A partir de o momento em que existe um conjunto de casos de teste inicial, o teste de mutantes pode avaliar- lo e, caso necessario, melhorar- lo com a adição de casos de teste extras, para que o teste realizado se torne confiavel.
A estratégia de Análise de Mutantes esta baseada em erros simples e comuns cometidos freqüentemente por os programadores.
Tais erros são problemas na implementação do sistema, os quais não podem ser detectados por Compiladores ou verificadores sintaticos, pois estão sintaticamente corretos.
Exemplos desses erros simples são trocas de nomes de variaveis no programa (usar uma variavel A onde seria correto usar a B), trocas de um operador relacional por outro (usar o operador relacional quando seria correto usar í), trocas de um operador aritmético (usar o operador+ quando seria correto utilizar), de entre muitos outros tipos de erros cometidos por os desenvolvedores.
É evidente, portanto, que cada linguagem diferente deve ser estudada a fim de se encontrar uma lista com os erros mais comuns que os programadores realizam quando estão implementando um sistema.
&quot;Geração de programas mutantes&quot;: Mutantes são programas gerados a partir de uma única modificação sintatica no código original do sistema que se quer testar.
A modificação sintatica efetuada no código original esta baseada em algum dos erros comuns cometidos por programadores, e gera um programa mutante sintaticamente correto, ou seja, podendo ser compilado normalmente.
A quantidade de mutantes gerados no teste de mutantes geralmente é bastante grande, e depende do tamanho do código sendo testado e também do tamanho da lista de erros comuns.
Os programas modificados são chamados de mutantes por a sua relação com o termo proveniente da biologia.
Como exemplo de mutação, observe as Figuras 2.2 e 2.3.
Enquanto a primeira mostra um programa original escrito na linguagem C, a segunda mostra três mutantes deste programa:
O primeiro mutante está designado por A1.
Ele deve substituir a linha 103, onde a variavel &quot;a «foi trocada por a &quot;b».
Os outros dois mutantes estão indicados por A2 e A3.
Ambos são mutantes da linha 105, onde o operador &quot;foi trocado, respectivamente, por «í &quot;e por&quot;\&gt;».
Note que os mutantes estão todos na mesma figura por questão de espaço, pois eles devem criar programas separados;
Os passos apresentados previamente foram bastante sucintos, pois tinham a finalidade de apresentar de maneira geral o teste de mutantes.
A seguir serão apresentados alguns detalhes importantes a respeito de essas fases.
Conceitos e suposições Para que 0 teste de mutantes venha a ser útil como técnica de teste de software, algumas suposições tiveram que ser feitas por seus proponentes.
A primeira de elas é a suposição de que um programa a ser testado por a técnica de Analise de Mutantes é implementado por um programador competente, ou seja, os programas desenvolvidos tem poucas falhas e estão quase corretos.
Caso essa suposição não venha a ser levada em consideração, muito provavelmente testes realizados não terão resultados positivos.
Uma segunda suposição, chamada de &quot;efeito do acoplamento», é relativa a geração dos programas mutantes.
Essa suposição diz respeito ao porquê dos mutantes serem criados através de urna única mudança sintatica no código do sistema original.
Ela diz que erros complexos estão acoplados a erros simples, de modo que se um conjunto de casos de teste é capaz de encontrar falhas simples eIn um sistema, ele também é capaz de encontrar falhas complexas no sistema, Assim, não ha a necessidade de criar mutantes corn mais de urna modificação em relação a o programa original.
Tal suposição e uma das maiores contestações do teste de mutantes.
Entretanto, estudos empíricos sugerem que tal suposição é valida.
Operadores de Mutação Os &quot;operadores de mutação «são regras capazes de transformar o código de um programa original num programa mutante, de acordo com um tipo de erro comum.
A escolha dos operadores de mutação a serem utilizados é fundamental para o sucesso do teste de mutantes.
Os operadores de mutação devem gerar programas mutantes corn apenas uma modificação em relação a o programa original.
Essa modificação é feita a partir de a substituição de alguma estrutura sintatica no código do programa original por outra estrutura sintatica (a substituição é dependente do tipo do operador de mutação).
Tais operadores devem ser desenvolvidos de acordo coIn a hipotese do programador competente e com o efeito do acoplamento, pois isso resulta num teste de mutantes mais eficiente e menos caro.
Os operadores de mutação são classificados de acordo com um critério sintatico, ou seja, de acordo com 0 tipo de modificação que eles fazem a partir de o programa original.
Embora os operadores de mutação sejam específicos para cada linguagem de programação, existem algumas classes de operadores que são muito comuns entre diversas linguagens:
Mutação de operadores:
Em esta classe procurá- se criar mutantes a partir de trocas de operadores, como por exemplo trocas entre operadores relacionais, operadores aritméticos e operadores lógicos;
Mutação de cláusulas:
Em esta classe de operadores procurá- se modificar uma cláusula inteira do programa, ou até mudar seus elementos sintáticos.
Exemplos disso são a Mutação de variaveis:
Realizado a partir de a troca de identificadores.
Exemplos muitos comuns são trocas entre referências a variáveis escalares e troca entre referências a vetores;
Mutação de constantes:
Essa classe de operadores esta relacionada com o uso de constantes no código fonte do programa.
Alguns operadores que poderiam ser definidos são, por exemplo, troca entre referências a variáveis escalares, troca entre constantes, troca de constante por variavel escalar.
Operadores de mutação têm sido desenvolvidos e utilizados em varias linguagens de programação.
Exemplos dessas linguagens são o Fortran, C, Ada, Java, VHDL, de entre outras.
Mutantes Equívalentes Durante a geração de mutantes, acontece de mutantes gerados terem a mesma funcionalidade do programa original, ou seja, não existindo nenhum conjunto de casos de testes capaz de diferenciar os programas mutantes do programa original.
Esses mutantes são chamados de &quot;mutantes equivalentes».
Os mutantes equivalentes são gerados porque em certos casos os operadores de mutação fazem alguma transformação no programa original que não muda sua funcionalidade, apenas fazendo com que a otimização do código fonte seja melhorada ou piorada.
Os mutantes equivalentes têm sido um grande problema para o teste de Analise de Mutantes.
Isso acontece pois em certa etapa da aplicação da técnica e necessario saber quais mutantes foram &quot;mortos «por o teste e quais ainda estão &quot;vivos», a fim de averiguar a adequação do conjunto de casos de teste.
Se for considerado que todos os mutantes têm funcionalidades diferentes do programa original, uma simples comparação das respostas dos mutantes com as do programa original pode decidir entre &quot;mortos «e &quot;vivos».
Contudo, é difícil saber se os programas realmente apresentam funcionalidade diferente, ou se eles são mutantes equivalentes e apresentam a mesma funcionalidade do programa original.
Uma possível solução para o problema seria diferenciar manualmente os programas.
Entretanto, como no teste de mutantes freqüentemente se trabalha com centenas de mutantes, isso se torna muito caro.
Saber se um mutante é equivalente ou não é um problema &quot;indecidível», ou seja, não se consegue um algoritmo genérico para solucionar- lo.
A fim de resolver esse problema, muitas pesquisas baseadas em heurísticas têm sido estudadas.
Resultados interessantes têm sido obtidos através de técnicas de otimizações de Compiladores e de restrições matemáticas.
Análise de Adequação.
A analise de adequação é um calculo que deve ser feito assim que os casos de teste terminaram de ser aplicados tanto no programa original como nos mutantes.
Deve- se ter a contagem de todos os mutantes &quot;mortos «e todos os mutantes &quot;vivos».
De os mutantes vivos, deve- se detectar quais são os mutantes equivalentes ao programa original.
Depois de detectados todos esses dados, eles devem ser aplicados ã Equação 2.1, a qual representa o &quot;escore de mutação».
Em esta equação, D representa a quantidade de mutantes mortos, M representa a quantidade total de mutantes e E representa a quantidade de mutantes equivalentes.
Quando o escore de mutação resultar 1.0, a mutação é dita &quot;adequada «Em a pratica, devido a existência de mutantes equivalentes não detectados, escores acima de 0.9 são dificeis de alcançar e escores acima de 0.95 são muito difíceis de atingir.
Problemas Um grande problema enfrentado por o teste de mutantes é o enorme número de mutantes gerados para um programa.
Em um software com n linhas, 0 número de mutantes gerados é de aproximadamente H2.
A geração dos mutantes e o custo de armazenamento dos códigos gerados não chega a ser problema.
Já o custo de compilação e execução de todos os casos de teste nos mutantes é extremamente alto.
E é esse alto custo que fez com que o teste de mutantes não tenha sido largamente utilizado na indústria até hoje Em função desse grande custo no teste de mutantes que muitos estudos têm sido destinádos a baratear- lo.
De entre os estudo realizados estão, por exemplo a melhora dos algoritmos usados no teste de mutantes e também a invenção de novas variações do teste, tais como a mutação seletiva, a mutação firme e a mutação fraca Um último problema associado ao teste de mutantes é o da elaboração dos casos de teste para os mutantes que foram considerados &quot;vivos».
Essa criação de casos de teste necessita de muita interação do testador com as ferramentas de apoio ao teste de mutantes, o que a torna uma das mais caras tarefas dessa técnica de teste, juntamente com a detecção dos mutantes equivalentes.
Ferramentas Embora o teste de mutantes possa ser aplicado de uma maneira não automatizada, sempre é interessante a ajuda de ferramentas para diminuir os custos do teste.
Contudo, não são muitas as ferramentas existentes para ajudar na automação do teste de mutantes.
Mothm e Proteum são as ferramentas de auxílio mais conhecidas.
Mothm é uma ferramenta que ajuda na automatização do teste de mutantes para programas escritos na linguagem Fortran.
Através de ela, testadores são capazes de criar e executar casos de teste, medir a adequação dos casos de teste, determinar se resultados estão corretos ou não, localizar e remover erros e bugs, controlar e documentar o teste.
Um de seus objetivos é fazer com que programadores, testadores e os responsaveis por a manutenção sejam capazes de interagir de uma forma padrão com o sistema durante o seu desenvolvimento Proteum é outra ferramenta que suporta o critério de teste de software Análise de Mutantes.
Pmteum permite o teste de programas escritos em varias linguagens de programação procedurais, e ainda fornece suporte a um tipo de teste de mutantes mais recente, chamado &quot;mutação de interface «Além disso, linguagens não procedurais são suportadas, como é o exemplo do módulo Proteum/ ST, que trabalha com especificá ções.
Statechartsz. Assim como na ferramenta Mothm, a ferramenta Proteum também disponibiliza as principais rotinas requeridas por um testador para realizar o teste de mutantes:
Definição dos casos de teste, geração de mutantes, execução dos mutantes, analise dos mutantes vivos e calculo do escore da mutação.
Mais recentemente, o teste de mutantes tem sido pesquisado também em linguagens orientadas a objetos.
O teste de mutantes em linguagens orientadas a objetos muitas vezes difere um pouco da mutação em linguagens procedurais, mas a idéia principal não deixa de ser semelhante.
Assim como existem ferramentas capazes de auxiliar o teste de mutantes para as linguagens procedurais, existem também mecanismos capazes de ajudar na automatização do teste de mutantes para linguagens orientadas a objetos.
Exemplos disso são o Ome (Object Mutatíon Engine) e o MuJava.
Os sistemas de computadores provêm à sociedade atual uma grande variedade de serviços de os quais ela e totalmente dependente.
Tais sistemas provêm importantes facilidades para os meios de transporte, de telecomunicações, de serviços financeiros, de produção de energia, de entre outros.
Essa dependência da sociedade tende a aumentar cada vez mais, visto a rapida difusão de softwares, computadores pessoais, celulares, palmtops, sistemas embarcados e todos os novos dispositivos que vem sendo criados a cada dia que passa.
Em determinadas áreas de aplicação os sistemas têm uma necessidade maior de confiábilidade, visto a importancia do tipo de serviço que eles desempenham.
Exemplo disso são os softwares que desempenham tarefas críticas com relação a a vida de seres humanos, como sistemas para aviões, para usinas atômicas, para naves espaciais, para controle de tráfego aéreo.
Outro exemplo está relacionado com sistemas de grande porte que necessitam de disponibilidade contínua, onde problemas podem trazer grandes prejuizos financeiros, como é o caso de softwares para bolsas de valores, centrais telefônicas e bancos.
&quot;Dependabilidade «é o conceito utilizado para qualificar a confiabilidade que é indispensável para sistemas como os citados.
Por definição, dependabilidade é a qualidade do serviço provido por um sistema tal que se possa justificadamente confiar nesse serviço.
O serviço provido por um sistema é o comportamento percebido por outro sistema especial com o qual ele interage e é considerado como seu usuário.
Tal usuário pode ser tanto um ser humano, bem como um outro sistema.
Em outras palavras, pode- se dizer que dependabilidade é o conceito utilizado zExtensões de Máquinas de Estados Finitos utilizadas para especificar aspectos comportamentais de Sistemas Reativos.
O conceito de dependabilidade consiste de três partes principais:
As ameaças ã dependábilidade (Falhas, Erros, Defeitos), as propriedades relativas à dependabilidade (Disponibilidade, Confiabilidade, Segurança, Confidencialidade, Integridade, Manutenção) e os meios por os quais ela pode ser atingida (Prevenção de Falhas, Tolerância a Falhas, Remoção de Falhas, Previsão de Falhas).
As partes constituintes do conceito de dependabilidade são apresentadas na Figura 2.5.
O restante desta seção se dedica a explicar sucintamente o conceitos fundamentais de &quot;sistema», &quot;serviço «e &quot;especificação», e ainda cada um dos três componentes da dependabilidade:
As ameaças, os meios e as propriedades.
O assunto Tolerância a Falhas, um dos meios por os quais a dependabilidade é atingida, sera tratado com uma maior evidência, visto que ele é o tópico principal dessa seção do trabalho.
&quot;Sistema «é um conjunto de componentes que mantém um padrão de comportamento com um ambiente através de uma interface de comunicação.
A interface de comunicação, vista a partir de o ambiente, representa o comportamento externo do sistema, ou seja, o &quot;serviço «provido por esse sistema.
O ambiente que interage com o sistema, utilizandose do serviço provido por ele, pode ser tanto um outro sistema como um operador humano.
Um sistema pode ser composto por varios outros sistemas (sub-sistemas ou também componentes), os quais compartilham a definição de sistema dada anteriormente, formando uma hierarquia.
O objetivo da existência de sub-sistemas dentro de sistemas é simples:
Idealmente é a &quot;especificação «de um serviço que deve dizer se um resultado está correto ou não.
É a especificação do serviço que diz as saídas corretas do sistema, suas interações com o ambiente e as condições sob as quais o serviço é provido Contudo, não é incomum que um sistema tenha problemas em sua especificação, ou mesmo não tenha especificação, e isso cause falta de dependabilidade.
Por este motivo, freqüentemente a definição do conceito de &quot;serviço «é descrita em relação a a &quot;função «do serviço, ou seja, a funcionalidade que o serviço deve prover, e não por sua especificação.
Um sistema pode ser percebido por seus usuários através de uma alternância entre dois estados:
Um estado onde o sistema provê o serviço correto, e o outro onde o serviço está incorreto.
A transição de um estado correto para um estado incorreto é dada por um defeito no sistema.
Essa é a transição responsavel por ameaçar a dependabilidade de um sistema.
A transição de um estado incorreto para um estado correto é dada por o evento chamado de &quot;restauração do serviço».
Esta seção tem como objetivo apresentar os conceitos que estão relacionados com a transição de um sistema de um estado correto para um estado incorreto.
Esses conceitos são expressos por os seguintes termos do Inglês:
Fault, error e failure.
Não existe um consenso entre os pesquisadores da area na tradução desses termos para o Português, por esta razão é interessante que se preste atenção na tradução utilizada, visto que ela pode mudar de autor para autor.
Em este trabalho fault sera utilizado como &quot;falha», error sera utilizado como &quot;erro «e failure sera utilizado como &quot;defeito».
Um &quot;defeito «de sistema acontece sempre que um sistema não é capaz prover completamente o serviço que ele se propõe a fazer, ou seja, o serviço entregue não cumpre completamente a sua função.
Um &quot;erro «ocorre quando o estado de um sistema não esta de acordo com o que deveria estar, e este estado errado podendo fazer com que o sistema venha a apresentar defeito.
A causa de um erro é uma &quot;falha».
Quando um erro realmente se propaga e afeta o serviço de um sistema, então é dito que um defeito de sistema ocorreu.
Existem varios detalhes a respeito de os conceitos de falha, erro e defeito que são importantes e devem ser destacados.
Uma falha é algo que esta presente no componente.
Considere uma lâmpada como sendo um componente.
Com o uso, um dia o filamento que produz luz ira se romper e isso sera caracterizado como uma falha do componente (a falha, o rompimento do filamento, está presente no componente).
Como um outro exemplo, considere um componente de software que foi programado de maneira errada.
O problema de codificação que esta no código, também conhecido como bug, e uma falha do sistema (os bugs são também chamados de &quot;falhas de projeto «design faults).
Sobre erros, e importante notar que eles podem se propagar e fazer corn que o sistema apresente defeito, entretanto nem sempre isso acontece.
Em muitos sistemas são empregadas técnicas de recuperação de erros, e quando um erro é detectado e recuperado com sucesso, ele não chega a se propagar e afetar o serviço e portanto não provoca defeito no sistema.
A manifestação dos defeitos, falhas e erros geralmente é apresentada em função de uma &quot;cadeia fundamental», como mostrado na Figura 2.6.
Essa cadeia segue um ciclo, que se deve a definição de sistema.
Visto que um sistema pode ser composto de vários sub-sistemas formando hierarquias de sistemas, a cadeia fundamental segue os componentes, subindo a hierarquia de níveis do sistema.
Sempre que uma falha e ativada num componente, ela causa um erro no mesmo componente.
Caso esse erro se propagne, ele atingirá o serviço do componente e fará com que o mesmo apresente um defeito.
Um defeito num componente se torna uma falha num sistema que usa tal componente, e faz com que a cadeia continue desta maneira, sucessivamente, até que o nível mais alto da hierarquia do sistema seja alcançado e apresente defeito em seu serviço, ou ate que alguma providência seja tomada para impedir que isso aconteça.
As falhas têm uma classificação bem extensa e complexa, e por essa razão tal classificação não será apresentada nessa seção.
Entretanto, existem três tipos de falhas de suma importância que não podem passar desapercebidas:
As transientes, as intermitentes e as permanentes.
As falhas transientes ocorrem e desaparecem.
Pode ser que uma instrução num momento apresente uma falha e num instante posterior, ela já não ocorra mais.
As falhas intermitentes ocorrem de tempos em tempos.
Em alguns momentos elas não aparecem, num momento posterior elas podem vir a aparecer novamente, e em outro elas voltam a sumir.
Já uma falha permanente, ocorrendo uma vez, ela continuará a ocorrer até que ela seja reparada.
A dependabilidade de um software é caracterizada por uma série de propriedades, as quais são sucintamente descritas a seguir:
Disponibilidade: Característica que diz respeito a prontidão para fornecer o serviço correto.
A medição de índices de disponibilidade se preocupa em dizer a porcentagem do tempo total que um sistema se encontra pronto para prover o serviço correto.
Confiabilidade: Diz respeito a continuidade do serviço correto.
Índices de confiabilidade se preocupam em mostrar de quanto em quanto tempo defeitos serão observados por um usuário do sistema.
Segurança (Safety):
ê uma característica que se preocupa em qualificar as possibilidades de não ocorrência de conseqüências catastróficas durante a execução de um sistema;
Confidencialidade: Diz respeito a não ocorrência de divulgação não autorizada de informação;
Integridade: Caracteriza a não ocorrência de alterações impróprias do estado do sistema.
Manutenibilidade: Tem o objetivo de qualificar o sistema quanto a facilidade de se fazer reparos, modificações, adaptações e melhoramentos.
As propriedades relativas a dependabilidade podem ser mais ou menos evidenciadas, dependendo do tipo de sistema.
No entanto, disponibilidade é uma das propriedades que deve estar presente em qualquer projeto que se preocupe com dependabilidade.
Integridade é pré-requisito para a disponibilidade, confiabilidade e segurança, e portanto também deve estar presente em sistemas preocupados com dependabilidade.
Confiabilidade, segurança e confidencialidade são opcionais e não necessariamente aparecerão em todos os sistemas.
Segurança de acesso, que têm como característica a tentativa de evitar a existência de defeitos relativos a acesso a dados ou informações não autorizadas, não é diretamente um atributo da dependabilidade, pois pode ser gerada a partir de a combinação das propriedades de confidencialidade, integridade e disponibilidade Para se desenvolver sistemas com alta dependabilidade ha a necessidade da existência de técnicas e metodologias que visam minimizar a freqüência e a seriedade dos defeitos que ocorrem em sistemas.
As técnicas e metodologias existentes são geralmente agrupadas em quatro diferentes classes:
Prevenção de falhas, tolerância a falhas, remoção de falhas e previsão de falhas.
Apesar de o que se pode pensar, não é somente a utilização de uma única técnica que fara com que a dependabilidade de um sistema seja alta.
Uma efetiva combinação de todas as diferentes classes de metodologias é crucial para se atingir esse objetivo, A seguir são apresentados com mais detalhes as classes de metodologias utilizadas na construção de sistemas de alta dependabilidade:
Prevenção de Falhas:
Tem o objetivo de evitar que falhas sejam introduzidas no desenvolvimento de um sistema.
Esse objetivo geralmente é atingido através de rigorosos métodos de projeto.
O projeto deve ser feito com extremo cuidado, bem estruturado e bem administrado, as funcionalidades e inclusive as não funcionalidades devem estar bem especificadas.
A arquitetura do sistema deve ser desenvolvida cuidadosamente, assim como sua implementação;
Remoção de Falhas:
A remoção de falhas geralmente é realizada através de validação e de verificação.
A &quot;validação «se encarrega de verificar se os requerimentos impostos ao sistema estão consistentes e a &quot;verificação «se encarrega de assegurar que o sistema desenvolvido realmente realiza o que estava especificado para ser realizado.
Métodos de verificação estáticos como &quot;inspeção «e dinâmicos como o teste e a depuração são técnicas muitos comuns para encontrar falhas em sistemas, as quais posteriormente devem ser corrigidas.
A utilização de ferramentas automáticas pode ser muito útil no processo de localização e remoção de falhas;
Tolerância a Falhas:
Tem a finalidade de diminuir a quantidade ou seriedade das falhas existentes no sistema quando este se encontra em sua fase operacional.
Técnicas de tolerância a falhas têm sido empregadas principalmente em hardware desde os primórdios da computação.
J à tolerância a falhas em software é uma area de estudo muito mais recente,* Previsão de Falhas:
Tem como objetivo avaliar o sistema quanto as estimativas da quantidade presente, da futura incidência e das conseqüências das falhas.
Em as areas de hardware a obtenção de tais estimativas se encontra em estado bem maduro, onde ha a existência de ferramentas poderosas no auxílio dos calculos, fazendo com que resultados precisos possam ser obtidos.
Em a ãrea de software, os &quot;modelos de confiabilidade «se destacam no que se refere ã previsão de falhas.
Tolerância a falhas tem como principal objetivo fazer com que um serviço continue sendo provido, ou seja, não se torne defeituoso, mesmo na presença de falhas em seus componentes internos.
Tolerância a falhas provê possibilidades de aumentar a confiabilidade de sistemas que vão além de as técnicas de prevenção e remoção de falhas.
As falhas que devem ser toleradas por as técnicas de tolerância a falhas podem ser geradas por diversas razões:
Componentes velhos, especificações errôneas, problemas de projeto ou implementação, teste mal feito, problemas de interação com o ambiente, e até a combinação de varias destas razões.
Todas essas variedades de problemas fazem com que técnicas de tolerância a falhas não sejam faceis de ser aplicadas em sistemas.
Tendo em vista as dificuldades que tais problemas podem causar, é necessario que o desenvolvimento de sistemas tolerantes a falhas seja realizado através de especificações de requisitos bem elaboradas, de análises do ambiente de execução e de estudos cuidadosos de projeto, dos defeitos que podem surgir, das possíveis causas desses defeitos e das ações a serem tomadas quando de o acontecimento de eles.
Evidentemente que além de todos os cuidados no desenvolvimento de sistemas tolerantes a falhas, é necessario que existam técnicas para tolerar falhas.
Redundância é a palavra chave quando se trata de técnicas de tolerância a falhas.
É a redundância que faz com que seja possível tolerar falhas existentes num sistema para que esse continue funcionando e provendo serviço.
Ela possibilita que falhas sejam mascaradas durante a execução de um sistema, fazendo com que o usuário não venha a percebes- las.
Redundância é definida como todas as partes do sistema que não são necessarias para que um sistema funcione corretamente São quatro os tipos de redundância utilizados em tolerância a falhas:
Redundancia de hardware, de software, de tempo e de informação.
Redundância de hardware se compõe de todos os componentes de hardware adicionais num sistema para suportar a tolerância a falhas em hardware.
Redundância de software inclui programas extra desenvolvidos para tolerar falhas tanto de software quanto de hardware.
Redundância de tempo compreende trechos de código escritos com a finalidade de serem executados diversas vezes a fim de tolerar falhas intermitentes e transientes de hardware.
Redundância de informação acontece quando informações adicionais são utilizadas a fim de tolerar falhas, como por exemplo os códigos de Hamming ou os códigos de redundância cíclicas (Cyclic Redundancy Codes CRC), utilizados em linhas de transmissões.
Redundância custa tempo e dinheiro, e por isso ela deve ser otimizada em função de o nível de tolerância a falhas requerido.
É interessante notar que a redundância capaz de prover tolerância a falhas faz com que o comportamento de um sistema venha a ser modificado de alguma forma.
Por exemplo, redundância de tempo faz com que o processador tome mais tempo para executar uma tarefa;
Tolerância a falhas em software pode trazer problemas de performance nos sistemas.
De um modo geral, quatro fases podem ser definidas nas tecnicas tomadas para tolerar falhas em sistemas:
&quot;detecção de erros», &quot;confinamento de dano», &quot;recuperação de erro «e &quot;tratamento de falhas».
Detecção de falhas é a fase onde se detecta um erro no estado de um sistema.
Em a fase do confinamento de dano o defeito causado por um erro é identificado e delimitado.
A próxima etapa, a recuperação de erros, é a responsavel por remover o erro contido no estado do sistema para que esse não se propague.
A recuperação de erros deve fazer com que um sistema fique livre de erros em seu estado interno.
Finalmente, a fase de tratamento de falhas é aquela responsável por identificar o componente que contém a falha e fazer com que ele não seja mais utilizado por o sistema, ou que ele seja reconfigurado para não causar mais erros no estado do sistema.
Nem sempre a aplicação de uma técnica de tolerância a falhas atinge os seus objetivos de aumentar a confiabilidade de um software e de fazer corn que um serviço seja continuamente provido.
É por essa razão que existem métodos de avaliação das técnicas de tolerância a falhas.
Uma primeira forma de avaliar um sistema é através de um modelo analítico, assim como um modelo de Mar/ mv, formado de estados e taxas de probabilidades, o qual pode fornecer diversas métricas a respeito de a dependabilidade de um sistema.
No entanto a elaboração e análise de tais modelos pode ser complexa e se tornar inviável.
Uma outra maneira de avaliação mais comum são as técnicas de &quot;Injeção de Falhas».
Através da injeção artificial de falhas, tanto de software como de hardware, é possível que se simule problemas reais internos ou externos ao software, e se avalie o comportamento e a dependabilidade de um sistema tolerante a falhas, e também a efetividade da técnica de tolerância a falhas utilizada.
Uma vez que esta seção tem o objetivo de apresentar o assunto tolerância a falhas, a seguir são apresentadas algumas tradicionais técnicas de tolerância a falhas utilizadas largamente em hardware e em software.
Tolerância a falhas em hardware, como mencionado anteriormente, se preocupa em adicionar componentes redundantes a um hardware com o objetivo de tolerar falhas.
Em a maioria das vezes, a tolerância a falhas em hardware lida com problemas diferentes dos tratados na tolerância a falhas em software.
Como exemplo, ern hardware tentá- se tolerar falhas que ocorrem devido a o tempo de uso de um componente.
Contudo, em determinados casos também se trata de problemas semelhantes aos encontrados em software, como por exemplo falhas na implementação de um circuito.
A seguir serão apresentadas as técnicas mais comuns de tolerância a falhas utilizadas em hardware.
TMR (Triple Modular Redundancy) é um tipo conhecido de tolerância fálhas em hardware (Figura 2.7).
Em o TMR cada componente de um dispositivo é triplicado três vezes.
As saídas de cada um desses componentes servem como entrada para três votadores, responsaveis por detectar a saída correta por a maioria de resultados iguais, em outras palavras, uma votação dos resultados é feita.
Os votadores poderiam ser resumidos a somente um componente, contudo, como eles também podem conter falhas, eles são replicados da mesma forma.
As saídas de cada um dos componentes são entrada para um novo componente replicado três vezes, o qual por sua vez também retorna resultados para três votadores, e assim o circuito continua sucessivamente.
Um outro tipo de tolerância a falhas utilizado em hardware e a &quot;Redundância Dinâmica «Em a redundância dinâmica ha a existência de varias unidades com a mesma funcionalidade, sendo que somente uma esta ativa num determinado momento.
Caso o componente ativo esteja apresentando defeito, ele é dinamicamente desligado e um novo componente extra é chaveado.
Em essa classe de tolerância a falhas um dos principais problemas que se encontra é a detecção de que um componente esta apresentando defeitos.
De entre as principais abordagens para resolver este problema estão os testes periódicos, os watchdog timers e os circuitos de checagem própria (self-- checking circuits) Urna das variedades mais importantes de tolerância a falhas de hardware são as codificações.
A codificações permitem que as linhas comunicação de dados façam transmissões mais seguras e confiáveis (onde linhas de comunicação podem ser consideradas barramentos de processadores, linhas telefônicas, etc).
A codificação funciona através da adição de bits extra aos dados, os quais permitem saber se a informação sofreu algum tipo de erro durante uma transmissão, e em alguns tipos de codificação permite até corrigir tais erros.
Exemplos desse tipo de tolerância a falhas são os bits de paridade, o código de Hamming, código de Reed-Solomon, códigos de redundância cíclica (CRC).
Tolerância a falhas em software e uma area de pesquisa bastante abrangente.
Ela é definida por tudo aquilo que é feito em software para tolerar falhas em sistemas Tolerância a falhas em software é bastante utilizada na area de sistemas distribuídos devido a sua grande complexidade e a sua maior probabilidade apresentar defeitos.
Em essa area, tolerância a falhas é aplicada tanto nos blocos basicos de construção de sistemas, como por exemplo nos protocolos de comunicação confiável e de broadcast atômico e confiável, tanto como nos serviços tolerantes a falhas construídos em cima de os blocos basicos, tais como as transações distribuídas, recuperação de estados consistentes, ações atômicas e processos resilentes.
Um outro tipo de tolerância a falhas em software, o qual esta diretamente ligado ao presente trabalho, é a tolerância a falhas de software (note a diferença entre tolerância a falhas Q software e tolerância a falhas E software Em essa modalidade de tolerância a falhas o principal objetivo é fazer com que o software seja capaz de se recuperar e não apresentar defeito quando de a execução de seus próprios erros de codificação (bugs de software), os quais são freqüentemente chamados de falhas de projeto (design faults As técnicas de tolerância a falhas de software utilizam estratégias parecidas com a técnica TMR de hardware apresentada anteriormente.
Componentes de software com a mesma funcionalidade são desenvolvidos com o objetivo de retornar resultados, os quais são avaliados para saber qual deve ser o correto.
Contudo, em software não se pode usar da mesma maneira essa técnica.
Enquanto em hardware a tentativa é de tolerar problemas físicos, como por exemplo um fio rompido ou um circuito queimado, em software tentá- se tolerar problemas conceituais, como por exemplo um erro de um programador.
Fazer cópias idênticas de um componente obviamente não funcionaria, pois todos componentes têm o mesmo comportamento e apresentariam os mesmos resultados, mesmo em caso de defeito.
Em a tolerância a falhas de software as réplicas de componentes necessitam ter uma característica chamada de &quot;diversidade de projeto «(design diversity) para superar o problema das falhas de projeto.
Em a estratégia de diversidade de projeto, uma única especificação de um sistema inteiro, um módulo de um sistema, ou ainda um componente, é dada a diversos grupos de programadores, os quais, separadamente, devem projetar e implementar tal software.
Sabe- se que quanto mais distintas as formas como os grupos de projetistas e programadores fizerem suas réplicas de software, melhores são as possibilidades de se obter uma confiabilidade melhor no software que as utilizará para tolerar falhas.
Freqüentemente as cópias diversas são implementadas em linguagens diferentes, compiladas com compiladores distintos, as modelagens são expressas por formalismos diferentes e algoritmos diferentes são utilizados no desenvolvimento do sistema.
Através da diversidade de projeto esperá- se que as réplicas sejam independentes em relação a falhas, ou seja, esperá- se que duas de elas não apresentem defeitos numa mesma circunstância.
Entretanto, é muito difícil de saber se as cópias são ou não independentes em relação â falhas.
Estudos mostram que em certos casos as cópias diversas não são totalmente independentes e portanto talvez não fossem tão úteis para serem utilizadas na tolerancia a falhas de software.
As relações de dependência entre os componentes diversos utilizados em tecnicas de tolerância a falhas têm sido alvo de muitas pesquisas ultimamente.
Programação N-Versões é uma estratégia de tolerância a falhas de software que se utiliza de três ou mais versões diversas de um software e um algoritmo de decisão.
Essas versões diversas de software são colocadas em execução paralelamente e as suas respostas passam por a implementação do algoritmo de decisão, o qual usualmente é um procedimento que calcula a maioria dos votos, os seja, as respostas das versões, a fim de apontar um resultado correto.
A arquitetura de um sistema construído com a técnica NVP é semelhante a mostrada na Figura 2.8, onde &quot;V1», V2 e &quot;V3 «são componentes de software construídos com a característica da diversidade de projeto e organizados para executar em paralelo.
O componente &quot;Votador «representa a implementação do algoritmo de decisão.
&quot;Entrada «representa os dados de entrada passados como parâmetro para os componentes de software e &quot;Saída «representa o resultado final da computação.
Recuperação de Bloco é um mecanismo que é composto de dois elementos principais:
Duas ou mais versões ou rotinas diversas de uma parte importante de um sistema, repre representado por o componente &quot;At «na Figura 2.9.
O sistema que usa esse mecanismo e construído de maneira que uma das versões diversas é escolhida como a rotina primaria.
Sempre que ocorre a execução da rotina primaria, seu resultado e passado por o teste de aceitação.
Se o teste for considerado correto, a execução do sistema continua normalmente.
Caso o teste acuse um erro, deve ser recuperado o estado do sistema anterior a execução da rotina primaria, representada por o componente &quot;RP «(ponto de recuperação) na Figura 2.9, e uma rotina alternativa deve ser executada.
A partir de então, tal processo e repetido até que o teste de aceitação retorne um resultado correto ou até que acabem as versões alternativas, resultando num erro.
O referencial teórico apresentado até este momento permite oferecer uma base de conceitos para apresentar os trabalhos que influenciaram o desenvolvimento dessa dissertação.
Em essa seção serão apresentados trabalhos que utilizam métodos de tolerância a falhas de software aplicados a sistemas orientados a objetos, trabalhos relacionados com a aplicação de mutantes com um objetivo diferente de sua função original e por último trabalhos que utilizam a mutação de sistemas na linguagem Java.
Objetos As tecnicas de tolerância a falhas de software tradicionais foram desenvolvidas para serem aplicadas a sistemas programados em linguagens procedurais.
No entanto, nos dias de hoje há uma difusão muito grande das linguagens orientadas a objetos, e portanto trazer as idéias de técnicas de tolerância a falhas tradicionais para a orientação a objetos sem dúvida é uma necessidade.
Entretanto, devido as características da orientação a objetos não se pode simplesmente aplicar técnicas de tolerância a falhas de software tradicionais de uma maneira orientada a objetos.
Novos problemas surgem devido a esse novo paradigma de programação e portanto novas soluções devem ser apresentadas.
O trabalho de Xu É uma proposta para trazer as técnicas Programação N-Versões e Recuperação de Bloco originais para a orientação a objetos.
Em esse trabalho são apresentados os problemas relacionados e também possíveis soluções arquiteturais e de implementação para o problema da adaptação dessa técnica ã orientação a objetos.
Xu Propõe uma extensão de um componente idealizado, ou seja, um componente com comportamento bem definido tanto para respostas normais quanto anormais, em o qual a diversidade de projeto esteja encapsulada.
Dentro de tal componente estaria implementado um algoritmo de tolerância a falhas particular, composto de subcomponentes tais como as cópias diversas de software, um componente controlador que passa os parametros e recebe os resultados das cópias e um componente decisor, ou seja, um componente que escolhe a resposta correta baseado nas respostas das cópias diversas.
Xu Propõe ainda um framework orientado a objetos independente de linguagem de programação, com a finalidade de facilitar a implementação do componente idealizado com diversidade de projeto.
Esse framework é composto de classes abstratas especiais projetadas para fiexibilizar seu uso com uma variedade de estratégias de tolerância a falhas de software existentes.
Outro trabalho relacionado ao uso de tolerância a falhas de software em programação orientada a objetos é o de Romanovsky.
Em esses trabalhos Romanovsky trata de assuntos como a utilização de classes diversas, a utilização de estados abstratos e a recuperação de estado na estratégia de Programação N-Versões aplicada em sistemas orientados a objetos.
Existem certos tipos de problema em que ha a necessidade de diversas tarefas serem reálizadas sincronizadas e concorrentemente.
Os mecanismos de tolerância a falhas de software orientados a objetos existentes assumem que somente um chamador utilizará um componente idealizado com diversidade num determinado momento.
Em, Romanovsky trata de um novo esquema de Programação N-Versões aplicado a sistemas orientados a objetos, onde varias tarefas chamadoras podem utilizar de uma maneira sincronizada e concorrente um mesmo componente idealizado com diversidade.
Em seu framework, que foi exemplificado na linguagem Ada, Romanovsky ainda trata da importância da divisão de responsabilidades no desenvolvimento do sistema:
Os programadores de sistemas projetam a sincronização dos objetos e os templates para desenvolver as classes diversas, os prográmadores de aplicação desenvolvem as classes diversas e os programadores de tolerância a falhas projetam o componente decisor e ainda juntam todos os componentes diversos dentro de um componente idealizado.
Enquanto a programação orientada a objetos pode trazer varias vantagens ao desenvolvimento de um sistema, ela pode também trazer problemas quanto a a utilização de mecánismos de tolerância a falhas de software.
Os problemas ocorrem principalmente devido a o fato de que na orientação a objetos os dados são encapsulados dentro de os objetos.
Assim, quando um objeto pertencente a uma classe apresenta algum defeito em sua interface, ele provavelmente também se encontra com um estado interno errado.
Isso faz com que na tolerância a falhas de software devam existir mecanismos que façam com que o estado de um objeto diverso possa ser recuperado.
Uma possibilidade é projetar classes diversas sem estado interno.
Outra possibilidade é a utilização de estados abstratos Em, Romanovsky fala sobre a ideia de criação de estados abstratos para as versões de software diversas, os quais têm a finalidade de possibilitar a recuperação de estados quando erros forem detectados.
Os estados abstratos representam uma descrição geral dos estados das versões de software corretas.
Para que esses estados abstratos possam ser utilizados, cada uma das versões diversas deve prover duas funções de mapeamento de estados:
A primeira é a função give_ state, a qual retorna um estado abstrato correspondente ao estado interno de uma versão.
Ela é utilizada quando se necessita recuperar o estado de uma versão de software que possui o estado interno correto, a fim de corrigir uma outra versão errada.
A segunda função é a correct_ state, a qual corrige o estado interno de uma versão baseada num estado abstrato correto passado por parâmetro.
Em, Romanovsky trata com maiores detalhes a idéia de recuperação de estado a partir de estados abstratos.
Ele introduz a detecção de erros de estados na técnica NVP, fala das funções de mapeamento de estados e ainda da recuperação dos estados errados.
Ele fala ainda de uma estratégia adicional, a monitoração dos estados das versões diversas.
No geral, sistemas NVP detectam que aconteceu um erro apenas quando uma versão retorna uma resposta que discorda das demais versões.
Contudo, versões podem ter estados incorretos e ainda assim retornarem respostas corretas.
Caso as versões acumulem estados errados e continuem a prover respostas corretas, dois problemas principais podem ocorrer:
Quando uma versão tiver que ter seu estado recuperado, ele pode ser recuperado por uma outra versão que ja continha um estado errado mas ainda não tinha apresentado defeitos;
E em segundo lugar ha uma maior probabilidade de duas versões se tornarem defeituosas ao mesmo tempo caso estados errados estiverem sendo acumulados.
Assim, a monitoração de estados, que é possível graças à existência dos estados abstratos, tem por objetivo comparar os estados das versões diversas de software antes de elas se tornarem defeituosas, fazendo com que os estados possam ser corrigidos imediatamente após eles se tornarem errados.
Os mutantes foram inicialmente definidos por Demillo, para a utilização na técnica de teste Analise de Mutantes.
A criação dos mutantes esta associada a modificação de um programa original por operadores de mutação, os quais têm por finalidade gerar programas com comportamento diferente ao do programa original.
Os mutantes gerados por esta técnica de teste têm a característica de terem apenas uma diferença sintática em relação a o programa original, e por isso são freqüentemente chamados de mutantes de primeira ordem.
Em o teste de analise de mutantes, os mutantes de primeira ordem são utilizados com dois objetivos principais:
Avaliação de um conjunto de casos de teste para uma aplicação, e analise da propagação dos erros num sistema desde o momento em que uma falha é executada até o momento que um serviço se torna defeituoso.
Embora inicialmente definidos para serem utilizados no teste de Analise de Mutantes, a idéia dos mutantes tem servido para outros propósitos também.
Em, Madeira A ferramenta G-SWFIT consiste em encontrar estruturas de programação chave, ou seja, estruturas padrão no código objeto de um sistema onde seja possível emular falhas de projeto.
Madeira Propõem fazer uma biblioteca de estruturas chave, às quais podem ser aplicadas mutações de baixo nível, para emular falhas de software.
Tal biblioteca de mutações é baseada em dois princípios:
A existência de erros simples de programação nos sistemas e o conhecimento de como as linguagens de alto nível geram o código objeto das aplicações.
Madeira Alertam que na construção da biblioteca de mutações devem ser analisádas diversas questões:
Diferentes padrões de código objeto podem ser gerados por compiladores diferentes e até por diferentes parâmetros passados a eles;
Diferentes linguagens de programação podem requerer diferentes tipos de padrões no código objeto devido a construções distintas;
E principalmente, arquiteturas diferentes requerem padrões de código objeto diferentes.
De as vantagens dessa estratégia encontram- se, primeiramente, a sua eficacia:
Os resultádos obtidos com experimentos mostram uma boa precisão na emulação de falhas de software.
Uma segunda vantagem provém do fato de que a abordagem elaborada se utiliza do código de maquina da aplicação para gerar mutantes, e por esse motivo o código fonte do sistema não e necessario para utilização dessa tecnica de injeção de falhas.
As mutações de código de baixo nível não são as únicas que podem ser utilizadas como técnica de injeção de falhas.
Estudos mostram que os mutantes tradicionais definidos por Demillo, considerados como formas estáticas de injeção de falhas, também podem ser utilizados na injeção de falhas de software.
Em experimentos mostram que erros gerados por falhas reais em software são, em grande parte, também produzidos por os mutantes tradicionais.
Isso mostra uma boa representatividade dos erros gerados por os mutantes, em relação a erros produzidos por falhas reais de software.
Uma outra indicativa interessante apresentada em é que os erros gerados por mutantes, os quais são gerados por falhas simples, apresentam comportamento semelhante aos erros gerados por falhas complexas reais de software.
Embora o teste de Analise de Mutantes não tenha sido muito difundido na indústria de software, na pesquisa ele tem sido bastante estudado ao longo de o tempo.
Visto que nesse tipo de teste é necessário uma adaptação de acordo com a linguagem que se utiliza, é normal que surjam pesquisas desse tipo de teste a respeito de linguagens mais recentes.
A linguagem Java é um desses casos.
As mutações tradicionais foram propostas para programas implementados em linguágens procedurais.
Operadores de mutação eram aplicados para modificar sintaticamente os códigos fontes com a finalidade de induzir erros simples de programação que as pessoas cometem corriqueiramente.
No entanto, Java é uma linguagem orientada a objetos.
Java utiliza objetos, enquanto linguagens procedurais usam somente variaveis escalares.
Java utiliza classes e hierarquia de classes enquanto linguagens procedurais utilizam procedimentos.
Isso faz com que não seja trivial a utilização de mutantes em Java.
Em, uma proposta de mutação diferente é feita.
Ao invés de modificar sintaticamente um programa fonte para gerar mutantes, são modificados em tempo de execução valores que constituem o estado interno da aplicação.
Bieman Propõem a injeção de erros em tempo de execução em objetos das bibliotecas Java que são usadas em grande escala comercialmente.
Ao invés de definir operadores de mutação para cada tipo de classe específica, o que seria praticamente impossível, eles definem operadores de mutação apenas para algumas interfaces e classes que implementam essas interfaces, como por exemplo as interfaces Collection, List e Iterator do pacote java.
Util. As mutações são feitas em tempo de execução, através da instrumentação do código fonte da aplicação, por uma ferramenta chamada de Object Mutation Engine.
De entre as mutações existentes estão:
Esvaziar uma coleção de dados (interface Collection ou List), remover algum elemento de uma coleção, adicionar elementos a uma coleção, reordenar elementos de uma coleção.
A efetividade do teste de mutantes depende muito da qualidade dos operadores de mutação desenvolvidos.
Uma vez que operadores de mutação foram projetados inicialmente para linguagens procedurais, ha a necessidade de elaboração de operadores capazes de levarem em conta assuntos relativos a orientação a objetos, os quais possibilitam que os programadores venham a cometer novos tipos de erros.
Em, Me a Sugerem novos operadores de mutação para a linguagem Java baseados nas características orientadas a objetos dessa linguagem.
Os operadores sugeridos por eles tratam dos seguintes aspectos:
Este capítulo teve por objetivo apresentar os assuntos mais relacionados com a elaboração do presente trabalho.
O teste, por exemplo, foi extremamente necessário para que se pudesse extrair resultados e tirar conclusões dos experimentos realizados.
O teste de Analise de Mutantes teve ainda especial importância, uma vez que além de ser utilizado como técnica de teste num dos estudos de caso apresentados nesta dissertação, também serviu de base para a elaboração da metodologia de tolerância a falhas proposta, que foi chamada de Diversidade Orientada a Mutação (MOD).
Dependabilidade é outro assunto relacionado com o trabalho, visto que este estuda os atributos, os meios e as ameaças â qualidade do software.
O termo dependabilidade foi elaborado junto com muitos outros para padronizar a terminologia utilizada, que até então era usada de maneira confusa.
Em essa ârea de estudo, a tolerância a falhas, assunto principal da presente dissertação, é tratada como um meio de prover dependabilidade a um sistema.
De as técnicas de tolerância a falhas apresentadas, as técnicas de tolerância de falhas de software foram tratadas de maneira especial.
Finalmente, foram apresentados os trabalhos relacionados â presente dissertação.
Em primeiro lugar, foram apresentadas pesquisas relacionadas â tolerância a falhas de software em sistemas orientados a objetos, as quais estão diretamente relacionadas à metodologia MOD.
Em seguida foram apresentadas algumas das conhecidas aplicabilidades do conceito de mutantes:
Teste e injeção de falhas.
Essa seção tem um significado especial, visto que a metodologia de tolerância a falhas proposta também faz uso de mutantes porém com uma finalidade diferente das apresentadas.
Por último, mas não menos importante, foram apresentados alguns tipos de teste de mutantes aplicados â linguagem Java, que é a mesma linguagem utilizada nos estudos realizados no presente trabalho.
Diversidade Orientada a Mutação O presente capítulo tem a finalidade de apresentar a estratégia de tolerância a falhas de software proposta neste trabalho, Diversidade Orientada a Mutação (MOD MutatíonLike Oriented Diversity), e as questões relacionadas a seus objetivos, funcionalidades, arquitetura, aplicação e limitações.
MOD é uma estratégia de tolerância a falhas que tem como principais objetivos prover uma melhora de confiabilidade à sistemas implementados em linguagens de programação orientadas a objetos e também uma facilidade maior em sua manutenção.
Esses objetivos são obtidos, por um lado, por o mascaramento de falhas de software, e por outro, através de uma arquitetura que possibilite facilidades na incorporação e manutenção individual de componentes de software.
Como vantagens secundárias, esperá- se prover uma técnica que possibilite uma migração facilitada de um sistema não tolerante a falhas para um novo sistema tolerante a falhas, e fazer com que seja possível aumentar gradativamente o nível de confiabilidade de um sistema sem a necessidade de mudanças drásticas em sua estrutura.
A estratégia MOD foi elaborada com o propósito de melhorar alguns dos pontos fracos das estratégias tradicionais de tolerância a falhas de software.
Entre os pontos fracos estão o alto custo de aplicação da estratégia e também de manutenção, a necessidade de mudanças significativas na estrutura de um sistema para suportar a técnica de tolerância a falhas e a capacidade pequena de suportar melhoras de confiabilidade durante o ciclo de vida do software.
Diversidade de projeto é fundamental para a eficiência das técnicas de tolerância a falhas.
Quanto mais software diverso um sistema tiver, maiores serão suas chances na tarefa de tolerar falhas.
Em a estratégia MOD de tolerância a falhas isso não é diferente.
A diversidade de projeto é extremamente necessaria.
Contudo, as vantagens da estratégia MOD estão diretamente ligadas a maneira como a diversidade é utilizada.
A0 contrário de estratégias tradicionais, como Programação N-Versões e Bloco de Recuperação, MOD permite gerenciar a quantidade de software diverso usado na construção das aplicá37 ções.
A quantidade de diversidade pode ser administrada de acordo com as necessidades ou conveniência de quem projeta um sistema.
Alem disso, facilidades são providas na geráção de novas versões do sistema, baseadas no aumento da quantidade de software diverso utilizado.
A característica da estratégia MOD de poder ter um melhor controle sobre o software diverso está diretamente relacionada ao uso de componentes de software como unidade básica de fornecimento de diversidade.
Por outro lado, a arquitetura elaborada na estratégia e as diversas etapas de construção dos sistemas também são responsaveis por sua flexibilidade.
A efetiva combinação do uso de componentes de software diversos e da arquitetura desenvolvida para os sistemas MOD, associada a um sistema de mutação de software, foi a característica responsavel por fazer corn que a estratégia alcançasse os objetivos propostos.
O restante deste capítulo destiná- se a explicar mais detalhadamente as questões relativas à estratégia elaborada.
Primeiramente, na Seção 3.1, sera apresentada sucintamente a aplicação da estratégia.
As seções seguintes explicarão as etapas de aplicação da estratégia, começando por as Camadas de Software, seguido por o Sistema de Mutação e por último o Processo de Tolerância a Falhas.
Em a Seção 3.5 serão apresentados alguns problemas relacionados e limitações da abordagem proposta.
Finalmente, na Seção 3.6, serão apresentadas as considerações finais.
A estratégia MOD consiste na transformação de um sistema inicial, desenvolvido de acordo com uma arquitetura padrão definida, num sistema final tolerante a falhas.
Essa transformação do sistema ocorre em diversas etapas.
A primeira etapa consiste na obtenção de um sistema implementado de acordo com a arquitetura MOD.
Esse sistema pode ser tanto um sistema novo, como um sistema previamente desenvolvido, desde que tenha se adaptado à arquitetura MOD.
Ainda na primeira etapa, ha a necessidade da existência de componentes de software, os quais devem necessariamente ter a característica da diversidade e de ser de grande utilidade nessa etapa da aplicação da estratégia proposta.
Em uma segunda fase, chamada de &quot;Sistema de Mutação», ocorre a geração de &quot;mutantes».
Mutantes são pedaços de software diverso utilizados por a estratégia MOD para tolerar falhas no sistema.
Os mutantes são construídos atraves da modificação do código fonte de algumas classes específicas do sistema inicial.
A etapa do sistema de mutação é a parte mais importante da abordagem MOD, pois ela é responsável por criar uma camada de software capaz de fazer com que a futura incorporação de novos componentes diversos não necessite mudar a arquitetura do sistema tolerante a falhas.
Essa característica melhora a facilidade de manutenção do sistema.
O sistema de mutação proposto é semelhante a mutação utilizada no teste de Analise de Mutantes.
Todavia, os mutantes gerados na Análise de Mutantes têm o objetivo de apresentar comportamento diferente do programa original de o qual eles provêm.
Em os mutantes criados por a técnica MO D0 objetivo é outro:
Gerar códigos com 0 mesmo comportamento de um código original, contudo com a característica da diversidade.
Para que isso seja possível, primeiramente hã a necessidade de se usar os componentes de software diversos obtidos na primeira etapa da aplicação da estratégia.
Em segundo lugar, &quot;Operadores de Mutação «especiais devem ser elaborados.
Eles são os responsaveis por especificar as regras de modificação de um código fonte, a fim de gerar um novo mutante.
Enquanto na técnica de Analise de Mutantes os mutantes gerados correspondem a um programa completo, na técnica MOD isso não ocorre.
MOD deve gerar subprogramas ou partes de um programa que sejam diversas e que possam ser posteriormente chamadas como se fossem softwares diversos.
Isso só é possível devido a arquitetura desenvolvida nessa técnica de tolerância a falhas.
A arquitetura elaborada foi construída tendo em vista praticas comuns de planejamento de sistemas para facilitar uma migração de um sistema não tolerante a falhas para um tolerante a falhas.
A elaboração da arquitetura também levou em consideração a exigência de facilitar a geração de mutantes diversos por o sistema de mutação.
A etapa final de aplicação da estratégia MOD consiste em implementar uma técnica de tolerância a falhas tradicional para controlar os softwares diversos gerados na etapa do sistema de mutação.
Em esta etapa uma nova camada de software deve ser criada, a qual é responsavel por tolerar falhas de software contidas no sistema.
A nova camada, denominada de &quot;Camada de Controle», somente precisa ser construída uma única vez, na primeira versão do sistema.
Não ha necessidade de modificar- la nos casos em que novos componentes diversos estejam sendo adicionados ao sistema, desde que a camada intermediária não se modifique.
A Figura 3.1 mostra as etapas de aplicação da estratégia MOD.
As etapas da transformação de um sistema inicial num sistema tolerante a falhas começam na parte esquerda da figura, onde estão os pré-requisitos para a aplicação da técnica:
Um &quot;Sistema Inicial «e um conjunto de &quot;Componentes Diversos».
Esses dois pré-requisitos servem de entrada para o &quot;Sistema de Mutação».
O sistema de mutação é um processo que tem a finalidade de gerar conjuntos de classes mutantes, que são chamados de &quot;Software Diverso «na figura.
Os softwares diversos, juntamente com o mesmo sistema inicial adquirido na primeira etapa da estratégia, passam por uma etapa de ajuste onde uma &quot;Técnica de Tolerância a Falhas «é aplicada.
O resultado final é um &quot;Sistema Tolerante a Falhas».
As duas partes mais complicadas e propensas a falhas encontradas no processo de aplicação da estratégia MOD são relativas ao &quot;Sistema de Mutação «e a execução da &quot;Técnica Sistema Inlclal publnc A (Sistema' puvlvcellcíl ml Inicial m` V&quot;' Ú public A (public A (l.
Como visto anteriormente, é necessario que existam componentes de software diversos e também um sistema inicial para que a técnica MOD seja aplicada.
Tais pré-requisitos são de extrema importância para a efetividade da estratégia, pois são os responsáveis por prover diversidade ao sistema, tornando possível o mascaramento de falhas e o aumento de confiabilidade da técnica de tolerância a falhas.
Já a arquitetura do sistema inicial tem a função de facilitar todo o desenvolvimento de um sistema, sua manutenção e ainda fornecer as características necessárias ã aplicação da estratégia MOD.
Em essa seção serão apresentados os conceitos definidos na estrategia MOD que permitem a obtenção de componentes diversos e o desenvolvimento do sistema inicial.
Primeiramente serão apresentados os componentes e os conceitos associados a eles.
Em seguida é apresentada a arquitetura desenvolvida para apoiar a construção de um sistema inicial.
Um componente é um pedaço de software sem limite de tamanho, podendo ser composto tanto de apenas algumas linhas como de milhares de linhas de código, o qual tem seu projeto e implementação internos fortemente encapsulados e escondidos do mundo exterior.
Cada componente pode implementar uma ou mais interfaces, as quais são assinaturas de métodos que especificam contratos de comunicação entre um cliente (objeto que utiliza o componente) e o fornecedor (o próprio componente).
Além disso, um componente se comunica com seus clientes exclusivamente através de suas interfaces.
Os componentes utilizados na abordagem MOD seguem a descrição dada.
Contudo, a estratégia MOD não impede que padrões de programação sejam definidos para a utilização desses componentes.
O uso de padrões de programação é inclusive obrigatório em certos casos, visto que algumas regras de mutação são especificamente desenvolvidas para reconhecer tais padrões.
Exemplos de padrões de programação são, por exemplo, obrigar que um programador faça a instanciação de um componente através de um construtor padrão, o qual não recebe nenhum tipo de parâmetro em sua inicialização.
A utilização de padrões se torna importante quando se deseja implementar uma ferramenta que automatize o processo do Sistema de Mutação.
Existem casos onde uma transformação de código poderia se tornar muito trabalhosa para ser implementada numa ferramenta automatica.
Operadores de mutação podem ser desenvolvidos visando obrigar os programadores a utilizar certas estruturas para facilitar a tarefa do sistema automatico.
A abordagem de utilização de padrões é bastante utilizada comercialmente.
Java Beans e Enterprise Java Beans, por exemplo, são tecnologias conhecidas que fazem grande utilização de padrões.
A abordagem MOD não regula de nenhuma forma a maneira como os componentes diversos a serem aplicados na estratégia são obtidos.
Eles podem tanto ser implementados por uma equipe de programadores internos a instituição desenvolvedora de um sistema, como ser componentes COTS comprados.
Além disso, não é necessario o código fonte dos componentes para que a estratégia seja aplicada.
A única exigência é que eles apresentem diversidade.
As conseqüências de falta de diversidade nos componentes podem ser graves, fazendo com que o sistema não seja capaz de tolerar falhas.
Em a atualidade, onde se torna cada vez mais comum a existência de especificações de padrões baseados em interfaces e em componentes, a estratégia MOD de tolerância a fálhas pode ser muito útil.
Considere, por exemplo, a especificação Java Enterprise Edition (J2EE).
A companhia Sun Microsystems projetou uma interface baseada em Java, para um servidor de Aplicações, que foi implementada por uma variada quantidade de empresas.
Cada uma das implementações nada mais é do que um conjunto de componentes diversos, os quais poderiam ser utilizados em conjunto com a estrategia MOD.
A estratégia MOD foi desenvolvida tendo por objetivo flexibilizar a incorporação de componentes a um sistema.
Portanto, não hã a necessidade de implementar ou conseguir de alguma outra forma todos os componentes diversos de software numa primeira versão do sistema.
Componentes diversos podem ser adquiridos durante o ciclo de vida de um software e serem incorporados ao sistema de uma maneira facilitada, para lançamentos de versões de softwares atualizadas mais confiaveis.
Contudo, é necessario que a modelagem inicial do sistema faça a previsão de quais tipos de novos componentes diversos sejam incorporados ao sistema.
Sistemas orientados a objetos são desenvolvidos através de ligações entre classes de objetos.
As ligações entre as classes podem ter diversas formas num sistema.
Muitas vezes as classes estão muito interligadas, fazendo com que a dependência entre elas se torne grande.
Isso dificulta o entendimento do sistema e também a utilização de componentes de software.
A abordagem escolhida nesse trabalho foi a de criar uma hierarquia de classes organizada em camadas, onde as classes de uma camada superior somente podem se comunicar com as classes de uma camada imediatamente inferior.
De essa forma, é possível que se evite uma grande dependência entre as classes e portanto facilite o entendimento e a organização de um sistema.
A escolha de uma arquitetura baseada em camadas se torna conveniente pois é genérica, sendo que ha uma incidência grande de sistemas que utilizam arquiteturas similares.
Isso vêm a satisfazer um dos objetivos da estratégia MOD que é facilitar a migração de sistemas ja existentes.
Além disso, ela favorece a utilização de princípios basicos da orientação a objetos, como a alta coesão e o baixo acoplamento.
Por seguir bons princípios de engenharia de software, ela também é uma arquitetura conveniente para a construção de sistemas novos.
Entretanto, é evidente que cada tipo de sistema e projetado de uma forma particular e portanto nem todos se encaixam com a arquitetura desenvolvida.
Em tais casos, infelizmente, o trabalho de migração será maior.
A Figura 3.2 mostra a arquitetura considerada para a estratégia MOD.
Ela é composta de camadas:
A &quot;camada de componentes», a &quot;camada intermediária «e a &quot;camada de usuário».
A camada de componentes é a parte inferior da figura, onde ficam os componentes diversos a serem utilizados.
A camada intermediária é composta de classes que utilizam os componentes da camada imediatamente inferior.
Por fim, a camada superior é a camada de usuário.
Note que não existe nenhuma relação entre camada de &quot;usuãrio «e a possibilidade de ser usada por uma pessoa.
Ela é chamada assim porque simplesmente faz uso das classes da camada intermediária.
A Figura 3.3 mostra um exemplo hipotético do projeto de um sistema.
Como é possível Ver, ele é um sistema complexo, onde existem diversos tipos de ligações entre as classes.
Esse sistema foi projetado com o propósito de mostrar a flexibilidade da arquitetura MOD.
Em o exemplo, foi escolhida uma parte do sistema que fara parte da estratégia a ser aplicada.
A caixa &quot;1 «da figura mostra a camada de usuário, a caixa &quot;2 «mostra a camada intermediária e a caixa &quot;3 «mostra a camada de componentes da arquitetura MOD.
A configuração mostrada na Figura 3.3 tem algumas peculiaridades da arquitetura MOD mencionadas a pouco.
A &quot;Classe D», por exemplo, não poderia fazer parte da camada intermediária (indicada por a caixa &quot;2&quot;), pois ela faz referência a &quot;Classe B», que é uma classe superior na hierarquia de camadas.
Além disso, veja que existem muitas classes fora de a arquitetura, pois MOD pode ser aplicada a apenas algumas partes do sistema, caso necessario ou conveniente.
Finalmente, é interessante notar que a configuração mostrada no sistema da Figura 3.3 não é a única que poderia ser adaptada para a arquitetura MOD.
Essa configuração depende do sistema e também da conveniência.
Uma configuração alternativa seria fazer com que &quot;Classe A «fosse a única classe pertencente a camada de usuário.
Em seguida, a camada intermediária poderia ser composta das classes:
&quot;Classe B», &quot;Classe C», &quot;Classe D», &quot;Classe E», &quot;Classe F», &quot;Classe G», Classe H &quot;e «Classe l».
A camada de COIHPOHGIIÊGS permaneceria a mesma.
O sistema de mutação é um processo que consiste em usar um sistema inicial desenvolvido de acordo com a arquitetura MOD e componentes diversos para gerar &quot;softwares diversos», os quais são capazes de serem utilizados numa etapa seguinte, o processo de tolerância a falhas.
O sistema de mutação garante que novos componentes possam ser incorporados ao sistema sem a necessidade de modificações na estrutura do sistema.
Esta seção sera apresentada em duas partes:
Primeiramente o processo de geração dos mutantes sera introduzido.
Logo em seguida serão apresentados os operadores de mutação, que são as regras responsaveis por as modificações no código fonte de uma aplicação, a fim de gerar os mutantes.
O objetivo da fase de geração de mutantes é criar cópias diversas da camada intermediária definida na arquitetura do sistema.
Os softwares diversos são chamados de &quot;mutantes «na estratégia MOD por a sua analogia a técnica de Analise de Mutantes.
Os mutantes dessa técnica de teste são produzidos para terem comportamento diferente do original.
Por outro lado, os mutantes da abordagem MOD devem ter o mesmo comportamento de seu sistema fonte e ainda apresentar a característica da diversidade.
Em a estratégia MOD, os mutantes gerados irão compor, juntamente com as classes intermediárias já disponíveis, a nova camada intermediária do sistema tolerante a falhas.
Esses conjuntos de classes serão utilizados por uma camada controladora para tolerar falhas de software no sistema.
Os mutantes são gerados na técnica MOD através de uma ou mais modificações no código inicial da camada intermediária de um sistema.
As modificações são realizadas visando desativar o uso de alguns componentes utilizados no sistema inicial e trocar- los por outros componentes diversos equivalentes disponíveis, a lim de compor o novo sistema tolerante a falhas.
Os mutantes gerados são praticamente cópias da camada intermediária do sistema inicial, pois a sua lógica é definitivamente a mesma.
A única diferença são os componentes utilizados por esse novo software.
Por esse motivo, a qualidade da mutação depende muito dos componentes diversos obtidos para participarem da camada de componentes do novo sistema.
Não existem limites quanto a quantidade de novos componentes utilizados para geração de uma cópia diversa da camada intermediária inicial.
Por esse motivo, também não existem limites na quantidade de modificações realizadas no Código fonte da aplicação.
Contudo, é aconselhável que exista pelo menos um componente diverso para cada conjunto de mutantes gerado.
Suponha que a técnica de tolerância a falhas escolhida para ser utilizada no processo de tolerância a falhas de um sistema foi Programação N-Versões, e definiu- se que o sistema terá três conjuntos de mutantes na camada intermediária.
Tal sistema deveria, portanto, ter no mínimo três cópias diversas de cada tipo de componente para a geração dos mutantes.
A Figura 3.4 foi elaborada para exemplificar varios aspectos relacionados com a geração de mutantes.
Ela representa a Figura 3.2 numa fase posterior de desenvolvimento da abordagem MOD de tolerãncia a falhas, onde mutantes ja foram gerados.
Em primeiro lugar sera analisada a camada de componentes.
Note que existem nessa figura varios tipos de componentes representados por interfaces:
InterfaceXXX, InterfaceYYY, InterfaceZZZ.
Em relação ã Figura 3.2, o componente diverso ComponentYV2 foi adicionado ao sistema.
Agora a atenção é direcionada a camada intermediária.
Note que agora existem dois conjuntos de classes, enquanto na Figura 3.2 havia apenas uma.
Isso significa que um novo software diverso (conjunto de classes mutantes) foi gerado a fim de fazer parte da camada intermediãria do novo sistema.
Note ainda que um dos conjuntos de classes da nova camada intermediãria é o próprio conjunto de classes iniciais da camada intermediária do sistema.
Finalmente, veja que nessa figura existe uma camada adicional na arquitetura do sistema, chamada de &quot;Camada de Controle».
Ela sera apresentada adiante neste trabalho.
A automatização do processo descrito por uma ferramenta de software é algo que deve ser considerado.
Em sistemas pequenos, utilizados para teste, até que e possível fazer manualmente a geração dos mutantes, pois as modificações feitas no código fonte, descritas por os operadores de mutação, geralmente são simples.
Contudo, em software de uso comercial, onde a quantidade de código freqüentemente é grande, uma ferramenta automatica pode tornar esse processo muito mais barato e também menos propenso a erros humanos.
Os operadores de mutação são as regras que dizem como os códigos fontes da camada intermediária inicial devem ser modificados em função de gerar novos softwares diversos.
Os operadores de mutação da estrategia MOD funcionam de maneira que cada um de eles pode fazer uma ou mais modificações num código fonte.
Alem disso, no sistema MOD, varios operadores de mutação são aplicados em cadeia, ou seja, é necessario que um código fonte passe por diversos operadores a fim de gerar apenas um mutante diverso.
Esse comportamento é diferente do teste de Analise de Mutantes, onde cada operador de mutação utilizado faz apenas uma modificação num programa, para gerar um novo programa mutante.
A Figura 3.5 mostra o processo por o qual todas as classes da camada intermediária passam para que seja possível gerar novos mutantes.
Observe que o código fonte da classe que entra para processamento vai se modificando aos poucos.
Cada um dos operadores da cadeia de operadores é responsavel por fazer a sua parte da modificação de um código fonte.
A o final da cadeia encontrá- se o resultado mutante de apenas uma das classes da camada intermediária.
Um software diverso completo e gerado quando todas as classes da camada intermediãria inicial passam por a mesma cadeia de operadores de mutação.
A cadeia de operadores utilizada para modificar as classes da camada intermediária, mostrada na Figura 3.5, é dependente do sistema sendo utilizado.
Cada sistema podera ter configurações diferentes para esse conjunto de operadores de mutação aplicados em Sistema Sistema Inicial Mutante package A:
Package B: Os operadores de mutação utilizados na abordagem MOD são dependentes de linguagem de programação.
Alem disso, eles também são dependentes da tecnologia sendo usada e de padrões de programação desenvolvidos por os projetistas do sistema de mutação.
Os operadores de mutação MOD têm a finalidade de serem desenvolvidos sob demanda, ou seja, de acordo com as características de um sistema.
Entretanto, freqüentemente é possível projetar novos operadores de mutação para um sistema a partir de pequenos ajustes em operadores padrões existentes.
Em esta seção serão apresentados dois operadores de mutação para exemplificar as regras de modificação de código fonte.
Eles são mostrados em código Java, visto que os estudos de caso da presente dissertação usam essa linguagem de programação.
Suponha que a seguinte instrução tenha sido programada numa das classes intermediárias da Figura 3.2: Suponha também que um novo componente diverso, chamado C0 mp0nentYV2, o qual implementa a interface InterfaceYYY, esteja disponível ao sistema de mutação.
Em esta situação um operador de mutação deve retirar o código referente ã instanciação do componente do tipo ComponentY da classe a ser gerada, e colocar em seu lugar um novo construtor capaz de gerar objetos do tipo ComponentYV2, como no seguinte trecho:
O resultado da modificação é a geração de uma nova classe, com o mesmo comportamento, contudo agora apresentando diversidade de projeto, em função de o uso de um novo componente.
Suponha agora que o componente ComponentY esteja implementado num pacote chamado CompY.
Suponha também que o componente ComponentYV2 esteja disponível num outro pacote, denominado de CompV2.
A modificação realizada a pouco, sozinha, não é suficiente para gerar um mutante completo.
Para que ela gere um mutante completo é necessario que se importe o pacote C0 mpV2, referente a o novo componente diverso.
Suponha que a seguinte instrução esteja na classe que instancia componentes do tipo ComponentY:
Para que o novo componente diverso seja utilizado, é necessário que seu pacote seja declarado no código do programa.
Um operador de mutação designado com a função de importar pacotes, poderia então modificar a instrução anterior para a seguinte expressão:
Essa modificação faria com que a primeira mutação realizada apresentasse efeito.
Note que nos dois exemplos de mutação está apresentado o conceito de cadeia de operadores, mencionado anteriormente:
O código de uma classe primeiramente passou por a modificação do operador de instanciação, e logo após sofreu modificações do operador de pacotes import.
A partir de o momento em que a fase do sistema de mutação foi terminada e que alguns softwares diversos já estão disponíveis para serem usados, começa o processo de tornar o novo sistema tolerante a falhas.
Essa é a etapa em que todos os mutantes serão agrupados na camada intermediária, sob o comando de classes Controladoras, a fim de serem utilizadas por o novo sistema.
A estratégia de tolerância a falhas proposta esta centrada na camada intermediária da arquitetura do sistema.
Por este motivo, a intenção deste trabalho é fazer com que as outras camadas sejam modificadas o menos possível.
Em a camada de componentes por exemplo, não é necessario que exista o código fonte dos componentes, pois eles não devem ser modificados.
Um dos objetivos do processo de tolerância a falhas e fazer com que a camada de usuãrio, de maneira semelhante a camada de componentes, não necessite ser modificada.
O processo de tolerância a falhas da estratégia MOD esta relacionado a construção de uma camada de software, chamada de &quot;Camada de Controle».
A camada de controle é a responsavel por implementar um algoritmo de tolerância a falhas de software, capaz de mascarar possíveis falhas existentes no sistema.
O software diverso utilizado por esse algoritmo é exatamente o conjunto de mutantes produzidos na fase do sistema de mutação.
A camada de controle pode ser observada na Figura 3.4, apresentada anteriormente nesse capítulo.
Um dos objetivos da camada de controle é prover exatamente o mesmo serviço e interface que a camada intermediária inicial provia a camada de usuário, a fim de evitar que o código da camada de usuário seja alterado.
Essa tarefa pode ser feita de duas maneiras.
A primeira de elas é fazer com que a nova camada de controle tenha exatamente os mesmos nomes da camada intermediária inicial.
Uma segunda alternativa é implementar essa camada utilizando reflexão, da mesma maneira que a utilizada em.
Outro objetivo da camada de controle é possibilitar que a camada intermediária seja implementada somente na primeira versão do sistema, ou seja, para que quando novas versões do sistema puderem ser geradas, a partir de a obtenção de novos componentes diversos, não sejam necessarias mudanças adicionais na camada de controle.
Isso evita que se tenha que refazer ou adaptar todo o algoritmo de mutação sempre que uma nova versão do sistema for gerada.
Esse objetivo só pode ser alcançado se a quantidade de softwares diversos utilizados por o algoritmo de mutação for constante para todas as versões de sistema geradas.
Finalmente, o objetivo principal da camada de controle é fazer com que ela implemente um algoritmo de tolerância a falhas de software.
Os softwares diversos utilizados por esse algoritmo de tolerância a falhas são justamente os mutantes gerados na fase do sistema de mutação e ainda, opcionalmente, a camada intermediária original.
A estratégia MOD não define um algoritmo específico.
Qualquer um que se encaixe na arquitetura do sistema proposto pode ser implementado.
Os algoritmos Programação N-Versões e Bloco de Recuperação, os quais são os mais conhecidos na area de tolerância a falhas de software, são suportados por a arquitetura proposta.
Em a elaboração da estratégia de tolerância a falhas MOD foram feitas varias escolhas que, por um lado favoreciam a estratégia sendo desenvolvida, mas por outro causavam certos tipos de problemas.
MOD é uma abordagem que, embora tenha sido idealizada para ser utilizada de forma generalizada, nem sempre pode ser usada dessa forma.
Esta seção tem o objetivo de discutir algumas questões relativas aos problemas e limitações existentes nessa estratégia.
Um problema conhecido por as técnicas de tolerância a falhas de software aplicadas ã orientação a objetos é a recuperação de estados incorretos.
A inconsistência de estado entre as diversas versões de software de um sistema podem levar a prover serviços defeituosos, o que vem a ser prejudicial especialmente a sistemas tolerantes a falhas.
A abordagem MOD, por trabalhar com software diverso, sofre desse problema também.
Durante a apresentação da técnica não foram dados detalhes de como esse problema pode ser tratado, por dois motivos principais:
Primeiramente, nem todos os sistemas que implementam técnicas de tolerância a falhas necessitam de técnicas de recuperação de erros.
Em segundo lugar, tais problemas podem ser tratados semelhantemente à técnicas já conhecidas, como as apresentadas na Seção 2.3.
Em a abordagem MOD, dependendo da aplicação, a recuperação de estado deve ser provida em dois níveis:
Primeiramente a nível de camada intermediária.
Ela deve prover os meios necessarios para se recuperar em caso de erros em seu estado interno.
Em um segundo nível, os componentes diversos da camada de componentes também podem necessitar prover mecanismos de recuperação de estado.
Outro problema é relacionado com classes que executam operações de controle de entrada e saída.
Uma vez que varios mutantes serão gerados a partir de as classes intermediárias, e que todos esses mutantes podem num determinado momento ser usados para que se garanta a computação de uma tarefa, todas as instruções de entrada e saída serão repetidas tantas vezes quantos mutantes forem executados.
Isso muito provavelmente provocaria erros na aplicação final.
Essa restrição está relacionada com a existência de um possível compartilhamento de recursos entre as diversas cópias da camada intermediária e também entre os componentes, ja que estes vão compor cada cópia da camada intermediária.
Portanto, é necessario que se assegure que nem os componentes base nem mutantes da camada intermediária utilizem recursos compartilhados.
Em muitos casos, tal restrição pode ser facilmente superada.
Considere a utilização, por um mutante, de um arquivo num disco local.
Para que o problema seja solucionado, basta que o arquivo seja replicado e que cada mutante acesse apenas a sua cópia do arquivo.
Contudo nem sem re é ossível ue se re li ue um recurso e nesses casos a aborda em não funcionará adequadamente.
Para tais casos, deve- se utilizar a estratégia em partes da modelagem do sistema que não apresentem essa restrição.
Este capítulo teve o propósito de apresentar a estratégia MOD de tolerância a falhas, seus objetivos principais e as etapas de aplicação da estratégia proposta.
Os componentes diversos são um pré-requisito importante para a aplicação da estratégia.
Embora MOD não defina como implementar ou obter tais componentes, eles são importantes pois são os responsáveis por prover a diversidade do sistema.
Além disso, são as falhas de eles que se pretende tolerar.
As vantagens oferecidas por o fato de se trabalhar com componentes para prover diversidade são variadas:
Possibilita uma melhor divisão na implementação do problema, possibilita o uso de componentes COTS, permite uma melhora de confiabilidade gradual.
E interessante notar também que o código fonte dos componentes não e necessario para a aplicação da estratégia.
A fase de mutação é a principal parte da estratégia.
Ela é a responsável por gerar os softwares diversos que formarão o sistema final tolerante a falhas.
Ela trata de gerar mutantes da camada intermediária a partir de componentes diversos disponíveis na camada de componentes.
A fase de mutação é a responsavel por facilitar a produção de novas versões do sistema por a incorporação de novos componentes diversos.
Os operadores de mutação são indispensáveis na etapa de mutação.
Eles são responsaveis por modificar o código fonte de uma aplicação para gerar softwares diversos corn a característica da diversidade.
Eles devem ser desenvolvidos sob demanda de acordo com a linguagem e tecnologias usadas no desenvolvimento dos sistemas.
A etapa do processo de tolerância a falhas é a parte da estratégia responsável por a implementação de uma técnica de tolerância a falhas tradicional.
Para isso, urna nova camada é introduzida na arquitetura do sistema, a camada de controle.
A camada de controle é responsavel por invocar os mutantes gerados na etapa do sistema de mutação e tolerar falhas existentes na aplicação.
Programação N-Versões e Bloco de Recuperação são técnicas possíveis de serem utilizadas na construção de camada de controle do sistema.
Finalmente, alguns aspectos problemáticos da técnica MOD foram apresentados.
Entre eles se encontra um problema já conhecido das técnicas de tolerância a falhas de software quando aplicadas a orientação a objetos:
A recuperação de estado.
Outro problema também relacionado à estratégia é o uso de recursos compartilhados na camada intermediária.
Estudos de Caso A estratégia MOD necessita ser avaliada de acordo com seus diversos aspectos a fim de mostrar sua utilidade e facilidades.
O aspecto mais fundamental a ser avaliado com certeza é a efetividade ao tolerar falhas.
Além de a efetividade em tolerar falhas, muitos outros experimentos podem ser realizados para verificar se as aparentes vantagens listadas no podem vir a elucidar a questão da facilidade do uso da arquitetura elaborada.
Em a etapa de mutação, experimentos relacionados a utilização de outras linguagens de programação, diferentes da linguagem Java, também devem ser realizados.
Em a etapa da construção da camada de controle, a implementação de técnicas de recuperação de erros certamente precisa ser avaliada.
Foram dois os estudos de caso propostos para avaliar a técnica MOD:
Primeiramente foi desenvolvido um estudo de caso baseado numa maquina para calcular expressões na notação polonesa reversa (RPN Reverse Polish Nutrition).
Os requisitos desse estudo de caso renderam a implementação de dois sistemas, um desenvolvido com mecanismos tradicionais de programação orientada a objetos e outro com tecnologias de programação de sistemas distribuídos baseados em objetos.
O segundo estudo de caso envolveu o desenvolvimento de um sistema maior.
Esse sistema é um editor de texto distribuído, o qual foi chamado de Editor Colaborativo Distribuído (ECD).
Ele foi implementado em CORBA, utilizando a linguagem Java.
Este capítulo apresentará os estudos de caso propostos.
A Seção 4.1 mostra os experimentos realizados com o sistema da Calculadora RPN.
Já a Seção 4.2 apresenta um estudo de um sistema mais complexo e de maiores proporções, o qual trata de um editor de texto colaborativo distribuído.
O objetivo principal do estudo de caso do sistema da calculadora RPN (Reverse Polish Notation) é obter resultados quanto a confiabilidade de sistemas desenvolvidos com a estratégia MOD.
Para que esses resultados fossem obtidos, foram feitas comparações entre sistemas desenvolvidos sem técnicas de tolerância a falhas e sistemas desenvolvidos com a tecnica MOD de tolerância a falhas.
Uma calculadora RPN tem por finalidade calcular expressões matemáticas na notação polonesa reversa.
Considere a expressão &quot;l+ 2+ 3».
Em notação polonesa reversa, ela é escrita da na forma &quot;l 2 3+», ou, alternativamente, também pode ser escrita na forma «1 2 + 3 +7.
O calculo dessas expressões é realizado através de sucessivas ações de &quot;adiciona «e &quot;retira «de operandos da expressão numa estrutura de dados conhecida como &quot;pilha».
Dois experimentos foram realizados com o sistema da calculadora.
O primeiro experimento foi a implementação de um sistema de forma tradicional, orientado a objetos, na linguagem Java.
Esse sistema será referenciado no trabalho por &quot;calculadora tradicional».
Ja o segundo experimento envolveu o desenvolvimento de uma calculadora para um ambiente distribuído.
O sistema inicial foi implementado através da tecnologia Java RMI.
Os componentes utilizados foram implementados com a tecnologia Java RMI e também CORBA.
Esse segundo experimento sera referenciado no trabalho por &quot;calculadora distribuída».
Em as próximas seções são apresentados detalhes da construção de todas as camadas referentes a estratégia MOD, tanto na implementação do experimento da calculadora trádicional, como também da calculadora distribuída.
Os operadores de mutação elaborados para o estudo de caso são de dois tipos principais.
Em primeiro lugar estão os &quot;operadores de mutação de pacotes».
Eles tem a finalidade de manter a organização dos programas e evitar conflitos de nomes.
Os operadores dessa classe são:
Package Operator (PacOp) e Import Operator (ImpOp).
A segunda classe e referente a os &quot;operadores de mutação de uso de componentes diversos».
Sua operação é relativa a trocas de instâncias de classes Java num código fonte.
Eles são:
Instantiation Operator, RMI to RMI Operator (RÊROp) e RM] to CORBA Operator (RQCOp).
Package Operator (PacOp) Uma vez que os mutantes gerados por o sistema de mutação farão parte da camada intermediaria do novo sistema tolerante a falhas, e que muitos desses mutantes podem ter os mesmos nomes de suas classes originais, providências devem ser tomadas para que não haja conflitos de nomes no sistema final.
Uma primeira alternativa para resolver o problema seria modificar o nome das classes geradas.
A modificação de nomes de classes pode ser bastante útil quando um sistema é pequeno, por exemplo onde apenas uma classe seja disponível na camada intermediária.
Contudo, quando o sistema é maior, com a possibilidade da existência de vários tipos de classes na camada intermediária, essa solução pode se tornar um problema.
Mudar o nome de uma classe faz com que todas as referências a essa classe tenham que mudar também.
Isso pode se tornar uma operação custosa e complicada.
Uma outra alternativa elaborada na estratégia MOD foi criar um operador de mutação que organize cada conjunto de classes mutantes num pacote diferente.
Essa solução faz com que não existam conflitos de nomes entre os softwares diversos, pois cada conjunto de mutantes pertencente a camada intermediária do sistema tolerante a falhas passa a fazer parte de um pacote diferente.
O operador PacOp tem a finalidade de criar um novo pacote para o conjunto de classes mutantes que formará um novo software diverso.
Esse operador pode funcionar de dois modos.
O primeiro modo acontece quando a classe que gera mutantes já pertence a um pacote, como no exemplo da Figura 4.1.
Em esse caso o operador PacOp tem a função de apenas mudar o nome do pacote.
Em o código da Figura 4.1, ele poderia, por exemplo, trocar o nome example por mutantA.
O segundo modo de operação ocorre quando a classe original não pertence a um pacote.
Em esse caso o operador PaCOp deve apenas adicionar a instrução package correspondente ao novo mutante na primeira linha da classe gerada.
Note que o uso do operador PaCOp deve estar associado a operadores de mutação de uso de componentes.
Import Operator (ImpOp) Existem casos em que os componentes utilizados por um programa pertencem a determinados pacotes.
Quando isso ocorre, geralmente o comando import é utilizado para que o componente venha a ser usado no código de uma classe.
O operador Imp 0p tem a função de trocar declarações import quando um novo componente incorporado ao sistema pertencer a um pacote diferente do pacote do componente original.
Veja no código da Figura 4.1 que o componente do tipo ComponentX pertence ao pacote jaVa.
C0mpX (linha 2).
Suponha agora que um componente do tipo ComponentY, pertencente ao pacote java.
CompY, esteja disponível para ser utilizado por o sistema de mutação.
O operador de mutação ImpOp tem a função de trocar o nome &quot;java, CompXComponentXf «da linha 2 do código usado como exemplo, por o nome «java, CompY.
ComponentY;», a fim de fazer com que o componente ComponentY pudesse ser usado na classe mutante.
Note que a aplicação desse operador deve estar associada a operadores de mutação de uso de componentes.
Instantiation Operator (InsOp) O operador InsOp tem a finalidade de, ao gerar uma nova classe mutante, trocar um ou varios componentes utilizados por a classe original, por novos componentes diversos disponíveis.
Essa mudança ocorre nas instruções do código responsaveis por a instanciação de um componente.
Observe o exemplo da Figura 4.1.
A linha 5 mostra a instanciação de um objeto do tipo ComponentX.
Suponha que uma classe ComponentY esteja disponível ao sistema de mutação.
Tudo que o operador 1715013 deve fazer é trocar a instrução new ComponentXU;
Por a instrução new ComponentYU:
Em a nova classe gerada.
Isso faz com que um objeto ComponentY passe a ser utilizado por a classe mutante, ao invés de o antigo objeto do tipo ComponentX.
Note, no entanto, que padrões de programação foram adotados na implementação da classe intermediária, a fim de que esse tipo de mutação fosse possível.
No caso de o exemplo da Figura 4.1, ambas classes ComponentX e ComponentY implementam a interface chamada Interface.
Outra hipótese seria ambas herdarem comportamento de uma mesma classe.
A quantidade de trocas de componentes efetuadas por o operador IrLsOp depende do algoritmo de mutação utilizado.
As experiências realizadas até o momento utilizaram uma abordagem em que todos os componentes usados numa classe eram trocados por componentes novos na geração de uma classe mutante.
Contudo, misturas podem ser feitas.
Suponha que o exemplo da Figura 4.1 tivesse duas instanciações do tipo Componentx, ao invés de uma só.
Suponha também que ao invés de só um componente diverso, estivessem disponíveis dois:
ComponentY e ComponentZ.
Uma abordagem possível era trocar uma instância de ComponentX por ComponentY, e a outra por ComponentZ.
RMI to RMI Operator (R2ROp) A0 contrario de programas tradicionais orientados a objetos, programas que utilizam a tecnologia Java RMI obtêm referências de objetos a partir de um servidor de nomes.
Esses objetos não são instanciados diretamente no código fonte do programa cliente, por este motivo não e possível que se utilize um operador como o InsOp.
O operador RQROp tem a função de trocar um componente RMI no código fonte de uma classe original por um outro componente RMI diverso, a lim de gerar uma classe mutante.
Para realizar essa tarefa, o operador de mutação deve mudar a chamada de método responsável por a obtenção da referência do componente original, por uma outra chamada responsavel por obter um novo componente diverso disponível.
Visto que os componentes RMI são localizados através de URLs (Uniform Resource Locutor), basta que a URL do componente original seja trocada por a URL de um novo componente diverso.
Em Java RMI, a classe java.
Rmi. Naming é a responsavel por prover as chamadas que trabalham com objetos remotos disponíveis num servidor de nomes.
A chamada que nova URL que identifique um novo componente diverso.
Suponha que um objeto remoto gerado deve, portanto, gerar um código que apresente a seguinte chamada:
Embora pareça simples, essa chamada pode trazer problemas para o sistema de mutação.
Uma variavel fosse passada por parametro.
Isso faria com que o operador de mutação tivesse que saber o valor dessa variavel para poder efetuar uma troca de um componente específico por outro diverso.
Esse problema realmente não é facil de resolver, pois o valor da variavel, em muitos casos, só pode ser obtido com o programa em execução.
A solução encontrada para o problema das variáveis foi criar um padrão de programação.
Em os estudos de caso realizados todos os programas desenvolvidos deveriam obrigatoriamente menos difícil identificar um componente no código original, a fim de trocar- lo por outro componente diverso a ser utilizado no código mutante.
RMI to CORBA Operator (R2COp) O objetivo do operador de mutação R2 C0p é possibilitar que um programa que utilize um componente Java RMI possa ser transformado num programa mutante que utilize um componente CORBA.
Esse é 0 operador de mutação mais complicado dos apresentados até o momento.
Ele envolve uma tradução indireta, onde apenas um comando RMI pode ser transformado em varios comandos CORBA.
Esse operador também necessita de padrões de programações extra.
Em função de as diferenças entre RMI e CORBA, nesse operador de mutação não são utilizados nem a herança de classes, nem uma interface em comum entre os componentes diversos.
Em essa mutação é necessario que o &quot;nome «da interface CORBA seja igual ao &quot;nome «da interface RMI.
Além disso, todas as chamadas de métodos dessas interfaces devem ser as mesmas.
Embora a padronização diga que as interfaces e as chamadas de métodos tenham que ter os mesmos nomes, as exceções lançadas por os métodos não podem ser iguais.
Os métodos RMI necessariamente devem lançar algumas exceções padrão, e os métodos CORBA não precisam obrigatoriamente lançar exceções.
Esse problema faz com que um novo padrão de programação tenha que ser usado na implementação das classes intermediárias.
Os programadores devem obrigatoriamente capturar as exceções lançadas por os métodos Java RMI através exceção javalangException.
Além disso, os programadores dos componentes diversos CORBA devem definir que cada método das interfaces CORBA seja capaz de lançar no mínimo uma exceção, ou seja, mesmo que um método não necessite lançar exceções, ao menos uma deve ser declarada.
O trecho de código abaixo mostra a padronização definida, onde uma única exceção Exception é declarada para capturar exceções:
O código programado dessa maneira permite que componentes, tanto CORBA como RMI, utilizados dentro de o bloco try catch, possam funcionar corretamente.
A Figura 4.2 mostra uma tradução de código Java RMI dado no trecho de código 4.3, para a tecnologia CORBA.
Em essa tradução o componente diverso CORBA utilizado é identificado por o host hat, e tem nome StackB.
Como pode ser observado, a tradução de uma chamada de obtenção de referência não é direta.
Agora não existe uma URL para identificar um objeto distribuído.
O novo componente ó obtido através dc um conjunto de chamadas de inicialização do sistema.
A inicialização ocorre através da passagem de parâmetros, os quais alguns são provenientes do novo componente diverso CORBA, e outros são parâmetros definidos por padrão.
A Figura 4.2 mostra a inicialização do sistema desde a linha 2 até a linha 10.
Em seguida, alguns outros passos como a obtenção de uma referência ao servidor de nomes devem ser tomados.
Por fim, a referência ao objeto remoto CORBA é obtida nas linhas 15 e 16.
Ambos os sistemas iniciais da calculadora, tanto a tradicional como a distribuída, foram construídos através da arquitetura mostrada na Figura 4.3.
A camada de usuário é composta de somente uma classe, a qual é a interface entre um usuário humano e o sistema.
Ela é a responsável por guardar a expressão passada por o usuário na linha de comando de execução do sistema.
A camada intermediária, também composta de uma única classe, é a responsavel por interpretar a expressão em notação polonesa reversa passada e posteriormente calcular o seu valor.
A camada de componentes é composta de um componente que implementa uma estrutura de dados &quot;pilha», a qual é necessária para o cálculo de uma expressão na camada intermediária.
A camada de usuário, representada por a classe ProgramaPrincípal, é a interface de interação do usuário com o sistema.
A implementação dessa classe é exatamente igual para o sistema tradicional como para o distribuído e por este motivo o mesmo código foi utilizado em ambos os sistemas.
A função desta classe é simplesmente fazer uma instanciação de objeto da classe Calculadora, pegar uma expressão em notação RPN recebida por parâmetro e passar para o objeto do tipo Calculadora.
Logo em seguida ela deve receber o resultado disponível nesse objeto e escreves- lo na saída padrão.
A camada intermediária é responsavel por implementar a classe Calculadora do diagrama da Figura 4.3.
Ela é a responsável por implementar a lógica do calculo de uma expressão em notação polonesa reversa.
Para isso é necessario que se tenha um componente pilha.
Em a camada intermediária de ambos os sistemas da calculadora o componente pilha utilizado é proveniente da camada de componentes.
Em função de o sistema tradicional utilizar tecnologias diferentes das usadas no sistema distribuído, a construção da classe Calculadora desses sistemas teve algumas diferenças.
Em o desenvolvimento da calculadora tradicional, o uso de componentes da camada de componentes obedeceu as padronizações definidas por o operador de mutação InsOp.
Ja na implementação do sistema distribuído, a implementação da camada intermediária seguiu as regras dos operadores RQROp e RQCOp.
A camada de componentes é a responsável por implementar os componentes previstos na arquitetura do sistema.
Em o sistema inicial da calculadora tradicional, um componente pilha foi desenvolvido a partir de a interface lnterfacePilha da Figura 4.3.
Em o sistema inicial da calculadora distribuída, um componente pilha Java RMI foi desenvolvido, implementando também uma interface semelhante à lnterfacePilha, portada para a tecnologia RMI.
Essa nova interface foi gerada a partir de a adição de algumas exceções aos métodos da interface lnterfacePilha original.
Essa nova interface é mostrada na Figura 4.4.
Depois que todo o processo de construção dos sistemas iniciais da calculadora tradicional public interface InterfacePilha extends Remote (throws RemoteExceptíon, WrongResultException;
WrongResultExceptíon Z throws RemoteException;
InterfacePi1ha, a fim de formar a nova camada de componentes do sistema tolerante a falhas.
Em a calculadora distribuída, 0 fato de se utilizar componentes CORBA levou ao desenvolvimento de uma nova interface, a qual é mostrada na Figura 4.5.
A partir de essa nova interface criada, três novos componentes diversos CORBA foram implementados para fazer parte da camada de componentes do sistema tolerante a falhas.
A interface dos componentes RMI, mostrada anteriormente, adicionou dois novos componentes diversos ao sistema.
StackInterfaceOperatíons. Org.
OmgCORBA. Object, org.
OmgCORBA. Portable.
IDLEntity public interface StackInterfaCeOperations throws Calculator.
WrongResultException; Em o final da primeira etapa de desenvolvimento do sistema tolerante a falhas, em am bos os experimentos, tanto no da calculadora tradicional como na distribuída, a camada de componentes do sistema foi composta de seis componentes diversos:
Um único componente implementado durante a fase de desenvolvimento do sistema inicial, e os outros cinco componentes obtidos posteriormente.
A utilização de um sistema automatizado para realizar as modificações de código descritas por os operadores de mutação pode ser muito útil na aplicação da estratégia MOD.
Contudo, o desenvolvimento de um sistema como esses em geral é bastante trabalhoso.
Em função de isso, no sistema de mutação das calculadoras não se usou nenhuma ferramenta especial para geração de mutantes.
Em os experimentos realizados, os mutantes foram gerados a partir de a edição de forma manual do código fonte.
Em o sistema de mutação, uma cadeia de operadores deve ser aplicada ao código da camada intermediaria para geração de mutantes.
Em o sistema de mutação para a calculadora tradicional, a cadeia usada para gerar mutantes foi composta de dois operadores:
O primeiro operador a ser utilizado foi o InSOp, seguido por o operador ImpOp.
Em o sistema de mutação para a calculadora distribuída, duas cadeias foram construídas.
A primeira cadeia de operadores foi constituída por o operador R2 R0p seguida do operador ImpOp.
Essa cadeia foi usada para mutações com componentes RMI.
Ja na mutação de componentes diversos CORBA, a cadeia usada foi composta do operador R2 C0p seguida do operador ImpOp.
O operador Pac0p não foi utilizado nesse primeiro estudo de caso.
Todos os mutantes gerados tiveram seus nomes de classes modificados, inclusive o código da camada intermediária do sistema inicial.
Tanto no sistema tradicional como no sistema distribuído da calculadora, cinco mutantes da camada intermediária foram gerados, um para cada componente diverso excedente na camada de componentes.
Em o final da aplicação do sistema de mutação, seis softwares diversos estavam disponíveis para formarem a camada intermediária do novo sistema:
Os cinco mutantes gerados, mais a própria camada intermediária do sistema inicial.
Essa situação pode ser vista na Figura 4.6, a qual mostra a arquitetura do sistema da calculadora tolerante a falhas quando pronta.
Em essa figura a camada de componentes mostra todos os componentes construídos para fazerem parte do sistema.
PilhaA é o componente do sistema inicial.
Os outros componentes pilha são componentes diversos implementados posteriormente.
Em a camada intermediária, a classe CalculadoraA é a classe intermediária do sistema inicial corn seu nome modificado.
As outras são mutantes gerados por o sistema de mutação.
Finalmente, a classe Calculadora implementa a camada de controle onde uma técnica de tolerância a falhas de software é aplicada.
A camada do usuário continua inalterada.
A camada de controle dos sistemas da calculadora é mostrada na Figura 4.6.
Como pode ser observado, tal sistema consiste de uma única classe, a classe Calculadora, a qual é responsavel por implementar o mecanismo de tolerância a falhas tradicional da camada de controle.
A camada de controle foi implementada, em ambos os experimentos, com a utilização do mecanismo de tolerância a falhas de software Programação N-Versões, adaptado a orientação a objetos.
A fim de possibilitar que a camada de usuário não precisasse ser modificada, a classe de controle foi desenvolvida utilizando o mesmo nome de classe intermediária do sistema inicial.
Evidentemente que essa classe também fornece as mesmas assinaturas de métodos da camada intermediária original.
O mecanismo de tolerância a falhas implementado em ambos os sistemas da calculadora é o responsavel por instanciar cada um dos seis softwares diversos da nova camada intermediária, e fazer invocações a cada um de eles quando um serviço for requisitado.
O algoritmo de decisão da estratégia Programação N-Versões foi a implementação de um votador simples:
A classe de controle chama cada software diverso disponível e recolhe seu resultado.
Logo uma votação é feita, baseada na maioria dos resultados recolhidos, com a finalidade de definir a resposta correta.
Os experimentos realizados nessa seção serão relativos à comparação de sistemas não tolerantes a falhas, representados por os sistemas iniciais da calculadora, com sistemas tolerantes a falhas, representados por os sistemas originados da aplicação da técnica MOD.
A firn de comparar os sistemas iniciais da calculadora com seus correspondentes tolerantes a falhas, há a necessidade de se desenvolver algum tipo de conjunto de casos de teste.
Posteriormente, esses casos de teste devem ser aplicados aos sistemas para coletar os resultados e fazer analises.
Entretanto, devido a a simplicidade do sistema elaborado, é improvável que tanto os componentes do sistema inicial quanto os componentes diversos contenham falhas em seu código fonte, o que faria que os resultados do teste aplicado não apresentassem diferenças significativas.
A solução para este problema foi utilizar uma técnica de injeção de falhas, com o propósito simular falhas de software nos componentes usados no desenvolvimento dos sistemas da calculadora.
Um pré-requisito para esta técnica de injeção de falhas é que as falhas introduzidas nos componentes pudessem simular uma &quot;independência entre falhas «dos diversos componentes rodando.
A técnica de injeção de falhas usada nesse estudo de caso é bastante semelhante a descrita em.
Esta técnica consiste em adicionar instruções nos códigos fontes de um sistema com a finalidade de modificar seu estado interno quando executado.
Os erros introduzidos no sistema são gerados com base em taxas de probabilidade.
As instruções de injeção de falhas incluídas nos códigos fontes foram colocadas urna em cada método implementado por componente da camada de componentes.
A taxa de probabilidade de geração de erros de cada uma das instruções de injeção de falhas foi definida corno sendo de 2%, ou seja, 2 em cada 100 chamadas de métodos modificam o estado interno do sistema com um valor errado.
Os erros gerados por as instruções de injeção de falhas introduzidas nos componentes variam de acordo com quatro tipos diferentes de falhas:
Ao invés de retornar o número inteiro correto do topo da pilha em urna chamada pop, um novo número inteiro gerado aleatoriamente é devolvido;
Ao invés de retornar o número inteiro correto do topo da pilha numa chamada pop, um valor nulo é retornado;
Ao invés de colocar o número correto no topo da pilha numa chamada push, um novo número inteiro aleatoriamente gerado é colocado;
A o inves de colocar o número correto no topo da pilha numa chamada push, nenhum número é colocado.
Caso o número gerado seja maior que 0.98, ou seja, compreendendo uma porcentagem de 2%, um erro é gerado no estado da pilha.
No caso de o exemplo, o erro gerado é a introdução de um novo valor gerado também aleatoriamente, que corresponde a um número inteiro no intervalo de, o qual substitui o valor recebido no parametro number do método em questão.
Note que opcionalmente mensagens de erro são escritas na saída de erro caso a variavel Debug esteja setada.
Depois que os componentes envolvidos nos sistemas da calculadora foram instrumentados com instruções de injeção de falhas, os casos de teste a serem usados no experimento de teste foram desenvolvidos.
Em o total foram geradas aleatoriamente 104 expressões na forma RPN a serem executadas nos sistemas em teste.
Os casos de teste desenvolvidos correspondem a seis tipos distintos de expressões:
Expressões constituídas de 2, 3, 4, 5, 6 e 7 operandos.
A execução de casos de teste nos sistemas, tanto da calculadora tradicional como da distribuída, pode resultar em dois tipos de resultados:
Um número, correspondente ao calculo da expressão passada ao sistema, ou uma exceção, proveniente de um erro introduzido por a técnica de injeção de falhas.
Note que o fato do sistema retornar um número não quer dizer que a resposta esta correta.
Em muitos casos, devido a o tipo de falha inserida, uma resposta é retornada mas o resultado do calculo está incorreto.
O grafico mostrado na Figura 4.8 é uma primeira analise dos resultados obtidos da aplicação dos casos de teste desenvolvidos nos sistemas da calculadora.
Devido as grandes semelhanças entre os graficos gerados por o sistema tradicional e por o sistema distribuído, apenas o do sistema tradicional sera apresentado, contudo as interpretações podem ser consideradas para os dois experimentos realizados.
A Figura 4.8 apresenta um grafico que mostra a relação entre os resultados retornados por o sistema da calculadora e o número de operandos utilizados em cada tipo de expressão RPN.
Note que &quot;resultados retornados «significa todas as respostas que não apresentaram exceções quando calculadas por os sistemas da calculadora.
Note também que entre os resultados retornados existem respostas corretas e também respostas incorretas para as expressões passadas.
Em uma primeira analise, é possível ver que os sistemas iniciais da calculadora, os quais são representados por uma linha pontilhada, produzem maiores quantidades de respostas que os sistemas tolerantes a falhas (representados por a linha sólida).
Os sistemas tolerantes a falhas aparentemente são mais eficientes somente para expressões com 2 e 3 operandos.
Em todos os outros tipos de expressões as calculadoras não tolerantes a falhas são superiores.
Note também que em expressões com 7 operandos, as calculadoras tolerantes a falhas retornam resposta para apenas pouco mais da metade das expressões calculadas, ou seja, um pouco mais de 50% das expressões apresentam resultados.
Embora de acordo com a primeira análise as calculadoras sem tolerância a falhas aparentemente sejam superiores que as calculadoras geradas através da técnica MOD, um fator que ainda não foi analisado é relativo a qualidade das respostas geradas, ou seja, não foi verificado se os resultados dados por o sistema estavam corretos ou incorretos.
Essa dúvida fez com que uma segunda analise fosse gerada.
Em essa nova analise uma calculadora gold foi utilizada para verificar os resultados retornados na analise anterior.
Um novo grafico, mostrado na Figura 4.9, foi gerado para mostrar somente os resultados corretos retornados.
Esse novo grafico mostra claramente que as respostas retomadas por o sistema tolerante a falhas estão sempre corretas, pois tanto na Figura 4.8 como na Figura 4.9 as linhas correspondentes aos sistemas desenvolvidos através de MOD são exatamente iguais.
Ja no caso de o sistema inicial sem tolerância a falhas, esse comportamento é diferente.
É possível ver que a quantidade de respostas corretas retornada por os sistemas é bem menor que a quantidade total de respostas retornadas, ou seja, embora os sistemas iniciais sem tolerancia a falhas retornem mais resultados, suas respostas são menos confiáveis pois não se sabe se elas estão corretas ou incorretas.
A conclusão que se chegou a partir de a analise dos graficos gerados e que as respostas obtidas dos sistemas tolerantes a falhas desenvolvidos com a estratégia MOD são mais confiáveis que as dos sistemas sem tolerância a falhas, devido a o fato de sempre entregarem resultados com valores corretos.
Os sistemas das calculadoras sem tolerância a falhas na maior parte dos testes executados retorna uma maior quantidade de respostas, mas não é possível que se confie no seu resultado pois algumas vezes eles 7 l l I-.
L l I l Operandos ff J 3~ Calculadora lnicial~ o~ t».
Calculadora tolerante a falhas_ 2 I l l l l «l Porcentagem de resultados retornados estão incorretos.
A partir de os graficos, outras conclusões podem ser tomadas.
Por exemplo, embora 98% das invocações a métodos retornem resultados corretos, em nenhum momento essa taxa de resultados corretos é vista.
Isso ocorre pois, uma vez que um método invocado retorne um resultado errado, todo 0 estado de uma pilha fica errado e as chamadas subseqüentes também retornam resultados errados.
Isso ocorre pois nenhuma técnica de recuperação de erros foi aplicada ao estudo de caso.
Uma outra conclusão claramente Vista nos graficos é que quanto mais operandos tiver uma expressão, maiores as chances de uma saída retornar valor errado, ou não retornar absolutamente.
Isso ocorre pois quanto maior o número de operandos, maior é o número de chamada de métodos.
Isso faz com que cresça a probabilidade de se invocar um método com uma falha inserida.
Deixando de lado os resultados empíricos obtidos, agora são analisadas as facilidades que a estratégia MOD oferece para a geração de sistemas tolerantes a falhas.
Em primeiro lugar, é possível dizer que a arquitetura do sistema inicial, pré-requisito para desenvolvimento de um sistema MOD, pode ser aplicada com sucesso no desenvolvimento de projetos, como no exemplo mostrado.
Além disso, notou- se que a incorporação de componentes ao sistema pode ocorrer facilmente devido a arquitetura do sistema MOD.
Por último, a aplicação dos operadores de mutação é simples, e embora a técnica MOD defina que os operadores devam ser desenvolvidos sob demanda, foi percebido que alguns de eles podem facilmente ser utilizados de forma genérica, para uma variedade de projetos diferentes.
O segundo estudo de caso, o qual envolve o desenvolvimento de um sistema de edição de texto para um ambiente distribuído, assim como o primeiro estudo de caso, também tem como objetivo a analise da eficiência da técnica de tolerância a falhas MOD.
Contudo, nesse novo estudo a ênfase foi dada a obtenção de resultados, ao invés de explicar a estratégia passo a passo.
A especificação do segundo estudo de caso, chamado de &quot;Editor Colaborativo Distribuído «(&quot;ECD&quot;), foi retirada de um trabalho dado na disciplina de Programação Distribuída do Programa de Pós-graduação em Ciência da Computação da PUCRS.
Tal sistema tem mais características de um sistema real, tanto no que diz respeito ã complexidade como da quantidade de código necessaria para implementar o sistema.
Uma característica de interesse para o estudo de caso é que sua especificação inicial não foi desenvolvida visando ser utilizada por a abordagem MOD.
Outro fator importante é que no presente estudo versões de software realmente diversas, construídas por alunos, foram utilizadas na construção dos sistemas tolerantes a falhas.
Em o estudo do editor ECD a confiabilidade da técnica MOD também foi testada através de comparações.
Entretanto, as comparações foram realizadas entre sistemas desenvolvidos atraves de técnicas de tolerância a falhas.
O primeiro sistema foi construído com a técnica de tolerância a falhas Programação N-Versões, adaptada a orientação a objetos.
O segundo foi implementado com a estratégia MOD.
A finalidade dessa comparação é mostrar que um sistema desenvolvido através de MOD pode ser semelhante a um sistema construído de maneira tradicional em termos de efetividade ao tolerar de falhas.
Outra diferença em relação a o primeiro estudo de caso é relativa ao teste dos sistemas.
Em o presente estudo optou- se por utilizar uma técnica de injeção de falhas que representasse melhor as falhas de software que um sistema pode apresentar.
Ao invés de introduzir erros no estado interno da aplicação através da instrumentação de código, procurou- se inserir falhas &quot;reais «na implementação dos sistemas.
A técnica de injeção de falhas utilizada foi baseada na técnica de teste de Analise de Mutantes.
Os componentes utilizados no desenvolvimento dos sistemas são mutantes gerados através de uma ferramenta de apoio ao teste de mutantes.
A presente seção esta organizada da seguinte forma:
Primeiramente é apresentada a especificação do sistema do editor de texto ECD.
Em seguida são debatidos alguns aspectos relativos a implementação dos sistemas utilizados, das arquiteturas desses sistemas e também dos novos operadores de mutação desenvolvidos para o estudo de caso.
Os aspectos relativos a injeção de falhas nos sistemas e ã preparação dos sistemas para o teste são dados a seguir.
Por último, as análises dos resultados obtidos são apresentadas.
Em linhas gerais, o editor de texto colaborativo distribuído é um sistema que tem por finalidade a edição de textos de maneira compartilhada, entre diversos usuários, através de interfaces textuais de linhas de comandos, semelhantes às usadas em interpretadores de comandos.
A Figura 4.10 mostra um exemplo de interface de interação do usuário com o sistema do editor ECD.
O sistema do editor distribuído deve prover comandos que possibilitem que usuários, simultaneamente, editem um texto compartilhado, visualizem seu conteúdo, tenham a capacidade de mover o cursor do texto e também saibam informações específicas a respeito de o ambiente em que o sistema roda.
A Figura 4.10 mostra exemplos de alguns dos comandos que devem ser fornecidos por o sistema.
A lista dos comandos que deve estar disponível aos usuários do sistema é mostrada a seguir.
São quatro os tipos de comandos usados no sistema:
Comandos de edição:
Os comandos de edição estão relacionados a construção de um texto.
Estão disponíveis ao usuário o comando &quot;i», 0 qual tem a função de inserir uma linha de texto na posição atual do cursor;
O comando &quot;e», o qual tem a funcionalidade de editar a linha de texto corrente;
E o comando de edição &quot;r», o qual deleta a linha corrente.
Ambos os comandos &quot;i «e &quot;e «oferecem ao usuário um prompt para que uma nova linha de texto seja digitada.
Todos os comandos exibem mensagem de erro quando utilizados de maneira incorreta;
Comandos de visualização:
Visto que a interface do editor de texto é baseada em instruções textuais, é necessario que estejam disponíveis comandos com os quais os usuários possam saber o status atual de um documento.
Os comandos de visualização providos por o sistema têm por objetivo listar o texto escrito.
O comando &quot;l «tem o propósito de mostrar na tela todo o texto corrente.
Caso seja passado por parâmetro um número de linha ao comando &quot;l», o mesmo só apresentará na tela a linha de texto indicada por o número.
Caso um intervalo de números de linhas seja passado por parametro, apenas esse intervalo será exibido na tela;
Comandos de posição:
Os comandos de posição têm por finalidade fazer com que o usuário possa movimentar o cursor do texto.
Para mostrar o número e texto da linha corrente, o comando &quot;m «é disponibilizado.
O comando &quot;g «é o responsável por mudar a linha corrente do texto.
Ele recebe como parametro o número da linha de texto desejada;
Comandos de sistema:
Os comandos de sistema são relativos à utilização do sistema.
O comando vv tem a função de indicar em qual nodo da rede se encontra o processo coordenador das interfaces clientes.
O comando &quot;c «indica os códigos identificadores de todas as interfaces clientes conectadas ao sistema.
O comando &quot;q «faz com que um usuário deixe o sistema de edição de texto.
O modelo da arquitetura do sistema distribuído é mostrado na Figura 4.11.
Esse modelo representa um sistema onde não há um servidor central, mas sim processos independentes coordenados através de um objeto coordenador, o qual pertence a um dos processos independentes.
O objeto coordenador é o responsável por verificar constantemente a existência de clientes entrando e saindo do sistema de edição.
Ele também deve coordenar a troca de informações entre os clientes ativos.
Caso por algum motivo o processo cliente que carrega o objeto coordenador deixar de participar do sistema de edição, uma eleição deve ser realizada entre os outros participantes do sistema a fim de eleger um novo coordenador.
O algoritmo Bully foi padronizado para ser utilizado como algoritmo de eleição.
O retângulo pontilhado da Figura 4.11 refere- se a parte do sistema onde ficam os processos distribuídos.
Em a figura são mostrados três hosts, que nada mais são do que processos, os quais fazem parte do sistema.
Embora os hosts estejam mostrados em número fixo, quantidades maiores ou menores são permitidas.
Cada um dos hosts é composto por um objeto cliente e um objeto coordenador.
O objeto cliente é o responsável por se comunicar com um shell, o qual é a interface de comunicação de usuário com o sistema.
O objeto coordenador esta conectado a todos os clientes e é responsavel por dirigir a troca de informações textuais entre os clientes.
Os objetos coordenadores podem estar ativos ou inativos.
Sempre deve existir um objeto coordenador ativo no sistema.
Os Coordenadores inativos ficam a espera de uma eleição para se tornarem líderes, em caso do antigo coordenador ter sido desativado.
Visto que no modelo do sistema distribuído não existe um processo mestre, ou seja, um repositório central dos dados a respeito de o texto, fica por conta de cada cliente que participa do sistema manter seu repositório interno atualizado.
Para que uma atualização local reflita nas outras versões clientes que participam do sistema, um protocolo de distribuição de comandos foi elaborado.
De acordo com esse protocolo, sempre que um cliente recebe um comando do shell, o mesmo é repassado ao coordenador do sistema, o qual por sua vez distribui tal comando entre todos os outros clientes.
Contudo, para que o texto sempre seja igual em todos os clientes, cada um de eles deve interpretar as regras do sistema da mesma maneira.
Por esse motivo houve a necessidade da definição de padrões a respeito de as implementações dos clientes e das modificações realizadas por cada comando no texto:
Cada interface de interação com usuário tem sua própria linha corrente;
Não é possível mover o cursor para uma linha anterior ao início do texto e nem posterior ao final do texto;
Os números das linhas do texto devem começar com o valor 1;*
Sempre que o comando &quot;i «for distribuído por o coordenador, os processos clientes devem criar uma linha nova de texto após a linha indicada;
Sempre que um comando &quot;e «for distribuído por o coordenador, os processos clientes devem trancar a linha indicada e não devem permitir que outro usuário venha a apagar- la ou editar- la;
Sempre que um comando &quot;r «for distribuído por o coordenador, os processos clientes devem limpar a linha indicada e retroceder numa linha todas as linhas posteriores ao texto apagado;
Em função de todas as características dadas em relação a o modelo arquitetural do sistema e aos protocolos padrões definidos, uma interface de programação entre os objetos do sistema foi definida.
Uma vez que a intenção do trabalho na disciplina de Programação Distribuída era a utilização de tecnologias específicas para construção de sistemas distribuídos, as interfaces padrão foram definidas em CORBA.
A Figura 4.12 mostra as interfaces servidora e cliente para os objetos distribuídos do sistema.
A Figura 4.12 fornece a interface de comunicação entre os coordenadores e os clientes do sistema ECD.
A comunicação entre um cliente e um shell não foi padronizada no projeto do sistema, e portanto pode ser programada diferentemente por desenvolvedores.
A interface server refere- se ao coordenador de um host.
Ela fornece serviços que vão desde coordenação geral da edição do texto, até coordenação dos clientes que entram e saem do sistema.
Seus usuários são os objetos clientes.
Ja a interface Client é implementada por os clientes.
Ela fornece serviços de edição local de texto e também de eleição de novo líder.
Os serviços de edição de texto estão disponíveis aos objetos coordenadores.
Os serviços de eleição estão disponíveis aos outros objetos clientes participantes do sistema.
Os sistemas utilizados nos testes, tanto o MOD como o NVP, foram desenvolvidos a partir de três implementações diversas das especificações do editor ECD.
As três versões do sistema serão chamadas a partir desse momento no texto como versões C, D e R. Todas as implementações diversas utilizadas foram programadas na linguagem Java, por alunos da disciplina de Programação Paralela.
Embora em momento algum tivessem sido levados em consideração aspectos da estratégia MOD durante a elaboração das especificações e da arquitetura do sistema do editor ECD, essa arquitetura foi facilmente separada de acordo com os requerimentos exigidos na module Editorí module EditorAppí typedef;
R, embora implementadas por grupos de pessoas separadas, apresentavam uma mesma estrutura:
Uma camada de usuário, responsavel por implementar a interface de interação com o usuário;
A camada intermediária, composta por todas as classes relativas à implementação das interfaces CORBA;
E finalmente a camada de componentes, composta de componentes utilizados por as classes da camada intermediária, como por exemplo pilhas e listas.
Visto que na técnica MOD apenas um sistema inicial é necessario para que se aplique a estratégia, e que existiam a disposição três sistemas compatíveis, houve a necessidade de se escolher um.
O software escolhido foi a versão &quot;D».
Os componentes diversos necessarios para a aplicação da estratégia são classes que implementam a interface Java java.
Uti1. List.
Em o total, três classes diversas foram programadas usando algoritmos diferentes.
A etapa de geração de softwares diversos para a construção da camada intermediária do sistema MOD ocorreu de forma semelhante ao estudo de caso anterior.
Em o desenvolvimento do editor ECD os operadores de mutação utilizados foram o ImpOp, PaCOp e o Ins0p, usados exatamente da mesma maneira como definidos para o estudo de caso da calculadora.
A camada de controle também foi implementada de maneira semelhante à desenvolvida no estudo de caso anterior, através da técnica tradicional de teste NVP.
&quot;MutantA». É necessário que se compile a interface CORBA cada Vez que um novo software diverso for gerado por o sistema de mutação.
A Figura 4.13 mostra a arquitetura do sistema tolerante a falhas construído através da técnica MOD.
O elemento da figura denominado de shell é composto das classes que implementam a interface com o usuário.
A camada de controle é representada por o elemento controller, onde a técnica NVP foi aplicada.
Logo abaixo são mostrados os três softwares diversos do sistema, &quot;D1», D2 e &quot;D3», gerados a partir de os 3 componentes &quot;Lista «e da versão de software &quot;D».
A camada mais de baixo, indicada por figuras geométricas diferentes, forma a camada de componentes do sistema.
Cabe salientar que a camada intermediária do sistema inicial utiliza varios componentes, mas neste estudo de caso apenas um dos componentes foi utilizado para gerar os softwares diversos, como mostrado nas figuras.
O desenvolvimento do sistema tolerante a falhas tradicional, que foi implementado através da técnica NVP, utilizou as três versões não tolerantes a falhas do sistema ECD disponíveis:
C, D e R. Contudo, algumas adaptações foram necessárias durante a construção desse sistema.
Uma vez que as versões de software C, D e R eram sistemas completos, houve a necessidade de escolher apenas uma interface de interação com usuário para ser utilizada no novo sistema.
Logo em seguida, assim como no sistema MOD, houve a necessidade do desenvolvimento de uma camada adicional, correspondente a camada de controle do sistema MOD, responsavel por implementar a técnica NVP de tolerância a falhas.
A Figura 4.14 mostra a arquitetura do sistema NVP.
Ela e semelhante a figura que descreve a arquitetura do sistema MOD, contudo, note que os softwares diversos utilizados não são mutantes, mas sim classes realmente implementadas diversamente por cada um dos sistemas C, D e R. O desenvolvimento do sistema NVP apresentou algumas dificuldades.
Primeiramente, note que por se tratarem de sistemas diferentes, cada um dos sistemas C, D e R apresentava um protocolo de comunicação diferente entre a interface do usuãrio e a lógica de negócios do sistema.
Esse fato fez com que a nova camada de controle criada para o sistema NVP fosse mais complexa de ser implementada.
Outro problema enfrentado foi relativo aos componentes utilizados no sistema NVP.
Houve a necessidade de adaptar o sistema NVP ao uso dos componentes diversos utilizados no sistema MOD, uma vez que a injeção de falhas é realizada nos componentes, e as comparações necessitam que as mesmas falhas sejam inseridas em ambos os sistemas.
Note que o resultado dessa adaptação foi o uso de componentes iguais nas Figuras 4.14 e 4.13.
Em o editor ECD, diferentemente do estudo de caso da calculadora, foi decidido que falhas reais seriam injetadas no código fonte dos componentes.
O objetivo disso é simular de uma maneira mais real erros cometidos por programadores.
A maneira mais facil de injetar falhas no código de sistemas é através do uso de mutantes tradicionais do teste de Analise de Mutantes.
A ferramenta de mutação de código utilizada na injeção de falhas do estudo de caso ECD é chamada de MuJaua.
Ela é composta de uma grande quantidade de operadores de mutação, os quais simulam tanto erros relacionados a programação tradicional de sistemas como erros relacionados a paradigmas de programação orientada a objetos.
Tal ferramenta trabalha com a linguagem Java e tem suporte a variadas rotinas associadas ao teste de Analise de Mutantes.
No entanto, somente as características de geração de programas mutantes foram utilizadas nos experimentos.
Através da ferramenta MuJaua e dos três componentes &quot;Lista «diversos disponíveis, foram criados 341 mutantes tradicionais para cada componente diverso, totalizando uma quantia de 1023 mutantes.
ECD desenvolvido através da estratégia A definição da configuração do sistema que sera testado é um assunto de alta importância para a obtenção de resultados significativos.
Os sistemas que estão sendo avaliados foram implementados para rodarem num ambiente distribuído, utilizado simultaneamente por varios usuários.
Portanto, testar o sistema com apenas uma instancia cliente não seria adequado.
O número de clientes simultâneos considerados ideal para a realização dos testes foi estipulado em 3 unidades.
Esta escolha foi feita pois, por um lado, uma quantidade menor de clientes seria muito pouco, e por outro lado, uma quantidade maior complicaria a tarefa de gerar casos de teste, aplicar casos de teste e analisar os resultados obtidos do sistema.
Os casos de teste aplicados ao sistema também influenciam na qualidade dos resultados obtidos.
Os casos de teste usados no editor ECD foram desenvolvidos por uma ferramenta de teste chamada TestGenerator, desenvolvida para ser utilizada nesta dissertação, a qual é apresentada no Apêndice A. Dois casos de teste foram elaborados para testar os sistemas, o primeiro contendo em torno de 210 comandos de edição de texto e o segundo em torno de ambos os casos de teste desenvolvidos, a quantidade de comandos total é dividida entre cada um dos clientes do sistema sendo testado.
Isso quer dizer, por exemplo, que no primeiro caso de teste, em torno de 70 comandos são especificados para serem executados no primeiro cliente, outros 70 serão destinados ao segundo e finalmente mais 70 destinados ao terceiro.
É evidente que o teste de sistemas de forma manual é uma tarefa difícil, lenta e propensa a erros.
A ferramenta TestGenemtor veio outra vez a facilitar o trabalho com o experimento do editor ECD.
Essa ferramenta foi designada para testar automaticamente sistemas distribuídos baseados em interfaces de linha de comando.
Ela recebe um script de teste como parâmetro e consegue enviar os comandos corretos para cada participante do sistema distribuído de maneira automatica.
Assim não hã necessidade de interação humana durante a etapa de aplicação dos casos de teste nos sistemas.
Embora a ferramenta TestGenerator consiga enviar instruções de uso para sistemas distribuídos baseados em linha de comando, ela não consegue recuperar de maneira automatica os seus resultados.
Por esse motivo, mais uma modificação foi necessária nos sistemas do editor ECD sendo testados.
A camada de controle dos sistemas foi instrumentada com instruções de uma biblioteca para a linguagem Java que fornece chamadas para gravar informações de log, a qual é chamada de log4j.
As instruções inseridas no código fonte da aplicação são responsáveis por armazenar em arquivos de log as respostas retomadas por o sistema sendo executado.
O primeiro experimento foi efetuado através da aplicação dos dois casos de teste, CTl e CT2, nos sistemas do editor de texto ECD desenvolvidos por a técnica MOD e por a técnica NVP.
Esses dois sistemas serão referenciados de agora em diante por as siglas MOD_ A e NVP_ A.
O segundo experimento também fez uso dos casos de teste CTI e CT2.
Contudo, a construção desses sistemas fez a utilização de um número maior de componentes mutantes.
Os sistemas do segundo experimento serão referenciados por MOD_ B e NVP_ B de agora em diante.
São três as variáveis relevantes para as analises dos experimentos realizados.
A primeira variavel a ser analisada neste estudo de caso é a quantidade de comandos executados por um sistema quando um caso de teste é aplicado a ele.
Esse é um dado muito importante, visto que nem sempre os sistemas chegam ao fim do processamento de um caso de teste.
Uma das causas dos sistemas nem sempre chegarem ao fim do processamento é devido a não utilização de técnicas de recuperação de erros nos sistemas, o que faz com que aumentem as chances das técnicas de tolerância a falhas não chegarem a uma resposta.
A segunda variavel de interesse nos dados obtidos é relativa a quantidade de falhas que foram toleradas por o sistema de mutação para os comandos que foram executados no sistema.
Este dado e obtido a partir de a votação da camada de controle que decide se uma resposta está correta ou incorreta.
Sempre que a votação não obtiver um resultado unânime, uma falha foi tolerada por o sistema de mutação.
A última variavel relevante é o número de defeitos no serviço provido, ou seja, a quantidade de vezes que o sistema conseguiu retornar uma resposta para o usuário, contudo a resposta não era a resposta correta.
Essa última variável não pode ser extraída sozinha dos arquivos de log da execução dos sistemas.
Para que ela fosse computada houve a necessidade de se elaborar uma tabela com os resultados corretos para os casos de teste.
O primeiro experimento foi composto de duas etapas:
Aplicação do caso de teste CT1 e aplicação do caso de teste CT2.
A primeira etapa é relativa ao caso de teste CT1.
Ele é um script de teste formado por urna lista de 210 comandos do editor ECD.
Em essa primeira etapa, 341 sistemas MOD e 341 sistemas NVP, construídos a partir de os mesmos componentes com falhas injetadas, foram desenvolvidos para que o caso deste CT1 fosse executado.
A execução do caso de teste CT1 nos 682 sistemas gerados foi sumarizada na Tabela 4.1.
A primeira informação da tabela, com o identificador &quot;Executados», diz respeito à quantidade de sistemas que foram executados, que são os 341 sistemas MOD e NVP, A próxima linha da tabela diz respeito à quantidade de sistemas que conseguiram executar todos os comandos do caso de teste CT1.
Em a linha a seguir são mostrados dados que dizem a quantidade de sistemas que executaram todos os comandos do caso de teste CT1 e não apresentaram nenhum defeito, ou seja, um serviço correto foi provido.
A linha identificada por &quot;Que abortaram sem executar «diz respeito a quantidade de programas que, devido as falhas injetadas, nem começou a execução de comandos.
Em a próxima linha são apresentados os dados relativos aos programas que terminaram a execução por problemas na votação dos resultados.
A última linha diz respeito aos sistemas que terminaram por erro de votação mas não apresentavam nenhum defeito no serviço apresentado até o momento do término.
Para completar a comparação dos dois tipos de sistemas estudados no primeiro experimento, uma nova tabela de estatísticas foi elaborada.
A Tabela 4.2 mostra dados a respeito de as três variaveis comentadas no inicio desta seção:
Comandos executados, falhas toleradas e defeitos apresentados.
Em a linha com indicador &quot;Comandos Executados «é dada uma média da quantidade de comandos que cada sistema conseguiu executar para o caso de teste CTI (num primeiro momento desconsidere os dados relativos ao caso de teste CT2).
Em a linha indicada por &quot;Falhas toleradas «é dada a média das falhas toleradas por todos os sistemas executados.
A próxima linha indica a média de falhas toleradas por os sistemas que executaram todos os comandos e não apresentaram defeitos em seu serviço.
A linha seguinte mostra a média das falhas toleradas por os sistemas que terminaram, contudo não apresentavam defeitos até o momento do término.
Por último é dada uma media dos defeitos apresentados por todos os sistemas que executaram.
Começando a analisar os resultados obtidos, é possível observar na Tabela 4.1 que existem diferenças consideráveis nos dados referentes aos programas NVP e MOD que abortaram e que terminaram por erro.
Mesmo assim notá- se que existem algumas semelhanças entre os dados dos sistemas que executaram todos os comandos e dos que não apresentaram defeitos, o que é uma indicativa inicial de que ambos os sistemas têm capacidades semelhantes na tolerância a falhas.
Partindo para a analise da Tabela 4.2, veja que os resultados de todos os itens mostrados agora são realmente bastante semelhantes e evidenciam ainda mais os indícios de capacidades parecidas de confiabilidade.
A fim de terminar a comparação entre os sistemas executados nessa etapa do caso de teste CTl do primeiro experimento, um gráfico foi elaborado para mostrar a relação entre as três variáveis de ambos os sistemas MOD e NVP.
A Figura 4.17 mostra um gráfico que é ordenado de acordo corn a quantidade crescente de comandos executados por os sistemas testados.
Esse último resultado mostra uma alta semelhança visual entre as variaveis dos sistemas MOD e NVP.
Note que as linhas azul e preta, referentes a quantidade de comandos executados respectivamente por os sistemas NVP e MOD, são quase sobrepostas.
Note que o mesmo comportamento pode ser observado em relação a os atributos quantidade de falhas toleradas e defeitos apresentados.
A conclusão que se chegou nessa primeira parte do primeiro experimento é que ambas as abordagens apresentam capacidades semelhantes ao tolerar falhas de software.
A segunda etapa do primeiro experimento é relativa à aplicação do caso de teste CT2.
Em essa etapa, a idéia foi fazer o mesmo tipo de análise realizada durante a primeira etapa.
Contudo, deve ser notado que essa nova etapa contou com a elaboração de sistemas novos.
Uma nova combinação dos componentes mutantes foi feita e isso resultou em novos 341 sistemas MOD e 341 sistemas NVP.
Os novos sistemas foram gerados na tentativa de verificar se novas configurações na construção do software afetariam de maneira drástica os resultados ja obtidos.
Os resultados obtidos a partir de a aplicação do caso de teste CT2 nos novos sistemas gerados são mostrados na Tabela 4.3.
Note que com exceção da linha que diz respeito aos sistemas que executaram todos os comandos do caso de teste e que não apresentaram defeitos, onde a diferença é grande entre sistemas NVP e MOD, todas as outras apresentam comportamentos semelhantes aos obtidos na primeira etapa do experimento.
Embora a idéia inicial não era apontar qual a melhor estratégia de tolerãncia, os resultados apresentados na Tabela 4.3 dão claramente a impressão de vantagens na confiabilidade dos sistemas MOD sobre os sistemas NVP.
Um dos resultados que evidência essa conclusão é o da quantidade de sistemas que não apresentaram defeitos, onde os sistemas MOD apresentam uma porcentagem maior que os sistemas NVP.
A última parte da comparação relativa à fase de teste do caso CTZ refere- se à analise visual das quantidades de comandos executados, falhas toleradas e defeitos apresentados.
Esses atributos são dados através de um gráfico semelhante ao já observado na primeira etapa do experimento.
O novo grafico é mostrado na Figura 4.18.
Em esse grafico notá- se novamente a grande semelhança entre as linhas relativas aos sistemas desenvolvidos com a estratégia MOD e os sistemas desenvolvidos com a estratégia NVP.
A conclusão geral tirada do primeiro experimento foi que ha indícios fortes de que ambas as estratégias podem se comportar de maneira semelhante, ou seja, ambas podem ter a mesma capacidade ao tolerar falhas de software.
É interessante notar também que essa conclusão foi tirada não apenas a partir de um teste, mas com um experimento realizado com casos de teste diferentes e também com sistemas diferentes.
Além de as conclusões, esse experimento mostrou também, em sua segunda etapa, um comportamento realmente inesperado:
Aparentemente os testes realizados apontam uma pequena vantagem em relação ã capacidade de tolerar falhas aos sistemas desenvolvidos com a abordagem MOD.
O segundo experimento segue os moldes do primeiro:
Foi divido em duas etapas onde se aplicou dois casos de teste diferentes a sistemas MOD e NVP.
Os casos de teste utilizados inclusive foram os mesmos utilizados no experimento anterior.
É evidente que realizar dois experimentos iguais não teria nenhum fundamento.
Contudo, o segundo estudo apresentado nessa seção tem um carater mais experimental que os outros apresentados até o momento.
Os sistemas desenvolvidos nesse experimento foram implementados a partir de uma arquitetura diferente, onde não apenas 1 componente mutante foi utilizado em cada pacote que faz parte da camada intermediária, mas sim dois componentes mutantes.
As Figuras 4.15 e 4.16 mostram a arquitetura dos sistemas utilizados no experimento.
É interessante notar que devido a um uso de mais mutantes em cada sistema, uma quantidade menor de sistemas foi usada no experimento.
Em esse novo caso, apenas 170 sistemas MOD e 170 sistemas NVP foram utilizados.
As médias da Tabela 4.5, tanto dos casos de teste CT1 como CT 2, mostram que embora aparentemente melhor na maioria dos itens, os sistemas MOD são bem piores no que diz respeito aos defeitos apresentados.
Se a media de defeitos apresentados é maior, com certeza a confiabilidade está diminuindo em relação a os sistemas NVP.
NVP, as linhas referentes aos defeitos apresentados são maiores nos sistemas MOD.
Isso mostra uma menor confiabilidade por parte de os sistemas MOD.
Enquanto os resultados comparativos com o primeiro experimento mostraram- se muito semelhantes, fator que levou à conclusão que os sistemas tenham níveis de confiabilidade parecidos, o segundo experimento não mostrou o mesmo comportamento.
Em o segundo experimento a comparação dos resultados mostrou diferenças significativas.
O sistema MOD, além de aparentar tolerar mais falhas do que realmente tolera, possui uma média de defeitos maior que os sistemas NVP tradicionais.
A conclusão que se chegou a partir de o segundo experimento é que nem sempre a estratégia MOD de tolerância a falhas se comportará da mesma forma que outras abordagens de tolerância a falhas existentes.
Contudo, de maneira alguma essa conclusão inviabiliza o uso de MOD como técnica de tolerância a falhas de software.
O presente capítulo teve como propósito apresentar os casos de teste desenvolvidos para fazer uma avaliação inicial da estratégia MOD de tolerância a falhas.
Dois estudos foram apresentados, o primeiro de um sistema que calcula expressões matemáticas na notação polonesa reversa, e o segundo que trata a respeito de um sistema de um editor de texto distribuído de acesso simultâneo por varios usuários.
O estudo de caso da calculadora RPN trata da implementação de dois sistemas, um de forma tradicional e outro com tecnologias de programação distribuída, atraves da estratégia MOD, a fim de fazer uma avaliação inicial da abordagem.
Entre seus objetivos estão a apresentação da aplicação da estratégia passo a passo e também uma avaliação em relação ã efetividade da nova tecnica na tarefa de tolerar falhar de software.
As conclusões tiradas do estudo apresentado mostram que a aplicação da estratégia é simples e que a arquitetura definida para a estratégia pode ser aplicada.
A respeito de a efetividade, comparações foram realizadas entre sistemas construídos de forma tradicional e sistemas construídos com a abordagem MOD.
Os resultados da comparação apresentam vantagens ao sistema tolerante a falhas no que diz respeito a confiabilidade.
O segundo estudo de caso trata do desenvolvimento de um sistema de um editor de texto distribuído, o qual foi chamado de Editor Colaborativo Distribuído.
Em esse estudo de caso o foco principal é apresentar resultados a respeito de a confiabilidade da estratégia MOD.
Em esse segundo estudo de caso técnicas de tolerância a falhas são aplicadas em ambos os sistemas a serem comparados.
Os resultados são apresentados em dois experimentos.
O primeiro experimento mostra que a estratégia MOD pode ser tão confiável quanto a segunda estrategia de tolerância a falhas utilizada, a estratégia NVP.
Ja no segundo experimento realizado, a estratégia MOD apresenta algumas desvantagens em relação ã NVP, contudo isso não inviabiliza sua utilização como técnica de tolerância a falhas.
Como conclusão final a respeito de os estudos de caso, pode- se dizer que a estratégia MOD, em primeiro lugar, apresenta uma arquitetura geral possível de ser utilizada e também apresenta facilidades para 0 desenvolvimento de sistemas, inclusive na migração de um sistema já existente para um sistema tolerante a falhas.
No que diz respeito à efetividade, os sistemas construídos através da estratégia MOD mostraram que são capazes de tolerar falhas de software e portanto têm utilidade como técnica de tolerância a falhas.
Essa última conclusão abre caminho para que novas características da estratégia venham a ser avaliadas.
Conclusões O presente trabalho apresentou uma nova abordagem para a construção de sistemas orientados a objetos tolerantes a falhas.
Visto que a abordagem proposta é de uma técnica de tolerãncia a falhas, o principal objetivo do trabalho é possibilitar que se construa sistemas que tolerem falhas de software, aumentando a confiabilidade no serviço produzido.
Entretanto, aumento de confiabilidade não é o único objetivo da estratégia.
Um outro propósito do trabalho foi a elaboração de uma metodologia que viesse a fornecer possibilidades de diminuir o custo de desenvolvimento, facilitar a manutenção e prover maneiras de melhorar a confiabilidade do software durante seu ciclo de vida.
O resultado obtido a partir de os objetivos listados foi a elaboração da estratégia denominada &quot;Diversidade Orientada ã Mutação «(MOD Mutation-Like Oriental Diversity).
A estratégia MOD se utiliza de softwares diversos gerados através de um sistema de mutação para tolerar falhas de software.
Os objetivos de diminuição de custo e manutenção facilitada são providos por o método de mutação elaborado, o qual ajuda na utilização de componentes de software diversos e possibilita a construção de ferramentas automatizadas que são muito úteis no desenvolvimento de um sistema.
A propriedade de uma melhora de confiabilidade gradativa durante o ciclo de vida do software e provida por a possibilidade de anexar a qualquer momento componentes diversos ao sistema.
A utilização do sistema MOD é feita em diversas etapas a fim de proporcionar seus objetivos.
Em primeiro lugar, uma arquitetura geral para o sistema foi definida.
Ela foi elaborada de maneira a não ser muito restritiva e também a possibilitar que as etapas subseqüentes da estratégia pudessem ser realizadas.
A fase do sistema de mutação é responsavel por gerar os softwares diversos e por facilitar a constante incorporação de componentes diversos ao sistema.
A etapa final da estratégia refere- se à aplicação de uma técnica de tolerãncia a falhas tradicional, a qual é responsável por a utilização dos softwares diversos.
Urna vantagem adicional referente a a maneira como a estratégia foi elaborada é a possibilidade de utilização de COTS no desenvolvimento de um sistema, jã que o código ss Capítulo 5.
Conclusões dos componentes não é necessario na camada de componentes definida na estratégia MOD.
Em a presente dissertação, em função de fazer uma avaliação inicial e também de testar a efetividade da estrategia proposta, dois estudos de caso foram propostos.
O primeiro envolveu o desenvolvimento de sistemas capazes de calcular expressões matemáticas na notação polonesa reversa.
Esse estudo de caso foi chamado de calculadora RPN.
Os resultados obtidos nesse estudo mostraram que a aplicação da estratégia proposta era realmente possível, além de não ser complexa de utilizar.
Além disso, comparações realizadas entre o sistema desenvolvido com a estratégia MOD e um outro sistema desenvolvido sem tolerância a falhas mostraram uma significativa vantagem em relação â confiabilidade do serviço provido por o sistema MOD.
O segundo estudo de caso teve por finalidade a realização de testes com um sistema de maior porte, com proporções de um sistema real.
O estudo de caso envolveu implementações de um editor de texto distribuído, chamado de Editor Colaborativo Distribuído (ECD), o qual tinha por objetivo a edição de textos por varios usuários simultaneamente.
Esse estudo contou com a utilização de software construído por vários programadores, o que enriquece os resultados obtidos.
Os testes realizados no segundo estudo de caso mostram que a estratégia MOD pode ser tão efetiva quanto estrategias tradicionais na tarefa de tolerar falhas de software.
Embora a estratégia MOD apresente inúmeras vantagens, é necessario notar que ela, como as outras técnicas de tolerância a falhas, também apresenta limitações.
Assim como outras estratégias, MOD também necessita de algoritmos de recuperação do estado da aplicação, que muitas vezes são complexos de utilizar.
Uma segunda desvantagem é relativa â performance do sistema.
A existência de muitos softwares diversos com o mesmo comportamento faz com que a performance do sistema seja menor e que a quantidade de memória utilizada seja maior.
Conforme já falado em capítulos anteriores, a existência de recursos compartilhados no código da camada intermediãria também pode se tornar um problema no desenvolvimento de um sistema MOD.
Como conclusão do trabalho, é possível dizer, em primeiro lugar, que a estratégia proposta realmente é capaz de tolerar falhas de software, como visto nos estudos de caso realizados.
Além disso, indícios iniciais mostram que a estratégia é de facil utilização quando comparada a técnicas tradicionais.
Os estudos de caso mostraram ainda, devido as varias tentativas de implementação de cada sistema, facilidades na manutenção dos sistemas MOD.
Em relação â implementação do sistema do editor distribuído, a característica da economia de recursos também esteve aparente:
Enquanto o sistema tradicional necessitou das três versões diversas de software disponíveis, o sistema MOD utilizou apenas uma das cópias diversas.
Visto que uma primeira etapa na avaliação da abordagem MOD de tolerância a falhas foi completada, indicando que a estratégia tem sucesso na efetividade de tolerância a falhas, novos tipos de testes já podem começar a ser elaborados para continuar a avaliação da estratégia.
Em trabalhos futuros, o primeiro tipo de avaliação a ser realizado é relativo à utilização de ferramentas automáticas para o desenvolvimento e manutenção dos sistemas MOD.
Embora indícios já estejam disponíveis de que isso trará vantagens à estratégia, somente um estudo de caso vira realmente validar a proposição.
