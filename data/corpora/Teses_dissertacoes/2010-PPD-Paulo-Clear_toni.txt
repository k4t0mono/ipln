O processo de desenvolvimento de software é uma tarefa que envolve um conjunto de atividades a serem realizadas, e em muitos casos, por equipes grandes que podem se encontrar geograficamente dispersas.
Isso exige do desenvolvedor a utilização de metodos que proporcionem uma visão de todas as etapas desse processo de desenvolvimento.
A UML (Unified Modeling Language) é uma linguagem de modelagem que possibilita essa visão atraves do uso de diagramas que demonstram graficamente a estrutura do software em desenvolvimento.
O diagrama de atividades é utilizado para modelar o comportamento do sistema, atraves dos fluxos de execução de cada atividade desempenhada por o mesmo.
Com o objetivo de obter um modelo comportamental de sistemas computacionais apresentamos neste trabalho uma proposta de conversão de diagramas de atividades para SAN (Stochastic Automata Networks), um formalismo matematico que possibilita a modelagem de sistemas em geral, a partir de o qual é possível extrair índices probabilísticos relacionados aos estados, permitindo aos responsaveis por o processo de desenvolvimento tomar decisões sobre os recursos alocados no projeto.
Com o intuito de demonstrarmos como executar a conversão, us-amos uma versão simplificada dos elementos do diagrama de atividades da UML, para descrever os parametros e regras utilizadas para a conversão proposta.
Apresentamos ainda os resultados obtidos a partir de o modelo SAN gerado.
Palavras-chave: Redes de Autômatos Estocásticos, Teste de Software, UML (Unified Modeling Language).
O processo de desenvolvimento de software é uma tarefa que envolve um conjunto de atividades a serem realizadas, e que em muitos casos, podem envolver equipes grandes.
Esse processo exige muitas vezes do desenvolvedor, a utilização de metodos que proporcionem uma visão de todas as etapas do ciclo de vida de desenvolvimento do sistema.
A UML (Unified Modeling Language) é uma linguagem de modelagem, desenvolvida por Rumbaugh, Booch e Jacobson, que possibilita essa visão atraves do uso de diagramas que demonstram graficamente a estrutura do software em desenvolvimento.
De entre os diagramas UML, o diagrama de atividades é um dos que permite modelar o comportamento do sistema, atraves dos fluxos de execução de cada atividade desempenhada por o mesmo.
Segundo Bernardi, por falta de uma semantica formal não é possível aplicar, diretamente, tecnicas matematicas de analíse em modelos UML com o objetivo de validar o sistema em desenvolvimento.
Assim, para alcançar este objetivo, algumas pesquisas, de entre elas[ BDM02, LGMC04, Bar06, LSP+ 08, Neu08], propoem o uso de formalismos como redes de Petri estocásticas (SPN -- Stochastic Petri Nets).
Os modelos construídos para essa analise, em pesquisas como as de Lopez-Grão em, Bernardi em, Lachtermacher em e Neuwald em, Barros em baseiam- se em diagramas UML que descrevem o comportamento do sistema e proporcionam, no caso de a pesquisa feita por Barros, a geração de casos de teste de software.
Um modelo matematico é uma representação ou interpretação simplificada da realidade, ou uma interpretação de um fragmento de um sistema, segundo uma estrutura de conceitos mentais ou experimentais, que apresenta apenas uma visão ou cenario de um fragmento do todo.
Os modelos matematicos baseados em processos Markovianos são aplicados em diversas areas, tais como biologia, física, ciencias sociais, processos de modelagem de negocios e engenharias.
Um modelo matematico, baseado num processo Markoviano, é modelado como um conjunto de estados onde o sistema só pode ocupar um e somente um desses estados num dado espaço de tempo.
Com base em modelos matematicos gerados, é possível executar testes de software.
O teste de software é definido por Pezzé e Youg em como atividade que tem por objetivo ou avaliar a qualidade do software ou possibilitar melhorias no software revelando defeitos.
Em a tentativa de obter um modelo comportamental de sistemas computacionais apresentamos neste trabalho um metodo de conversão de diagramas de atividades para SAN, um formalismo matematico que possibilita a modelagem de sistemas em geral.
A partir de os modelos criados, é possível extrair índices probabilísticos relacionados aos estados do modelo SAN gerado, permitindo a geração de cenarios de testes de software que possibilitem uma maior qualidade ao produto desenvolvido.
É fato conhecido que o custo para a correção de erros nas especificações de requisitos no desenvolvimento de sistemas é muito mais baixo quando encontrado nas fases iniciais do projeto, do que quando encontrados na fase de execução.
Assim, a validação de especificações de requisitos em fases iniciais de desenvolvimento é muito importante.
O uso de notações como UML, atraves do uso de diagramas, proporciona uma visão comportamental do sistema em desenvolvimento, porem, apenas o uso da UML não permite uma analisé matematica do sistema em desenvolvimento.
Assim, visando associar a UML ao formalismo de modelagem SAN, de modo que tal ação seja possível, destacamos os objetivos específicoss deste trabalho:
desenvolver um metodo para transformar diagramas de atividades em redes de autômatos estocásticos (SAN), a partir de o mapeamento dos elementos que compoem o diagrama de atividades, para uma estrutura equivalente em SAN que represente o modelo comportamental do sistema;
definir as regras para a conversão de diagramas de atividades da UML para SAN;
gerar cenario de teste de software e analise dos índices de cobertura dos testes gerados com base no metodo proposto;
executar a aplicação do metodo proposto, atraves da elaboração de um estudo de caso, que tem por finalidade demonstrar a utilização do metodo em processos de desenvolvimento de sistemas.
Essa dissertação tem o foco principal na conversão de diagramas de atividades da UML para SAN e geração de cenarios de teste de software.
Para isso, definiremos as regras de conversão a serem utilizadas para a conversão dos diagramas de atividades e posterior geração dos modelos.
A versão UML utilizada nesta pesquisa será a versão 1.5, homologada em 2002, que consideramos ser suficientemente capaz de gerar os resultados esperados para este trabalho.
Em a pesquisa desenvolvida por Barros, foram obtidos resultados, de entre eles, a construção de um modelo de uso do sistema analisado e a definição de índices de cobertura para a geração de casos de teste de software, associando o formalismo SAN a UML, porem baseados em outros diagramas.
Assim esta dissertação baseia- se em diagramas de atividades para a obtenção dos modelos SAN e posterior geração dos cenarios de teste de software.
Esta dissertação fornece contribuições para a area de Engenharia de Software e avaliação de desempenho contribuindo para a melhoria do processo de desenvolvimento de software.
Portanto, entre os benefícios da nossa proposta, podemos citar:
obtenção de índices de desempenho, tais como probabilidade e execução de atividades de scritas no diagrama, a partir de os modelos gerados por a conversão;
tempoparaa execução durante o desenvolvimento.
A revisão bibliografica foi a primeira etapa na elaboração deste trabalho, onde foram feitos levantamentos acerca de os assuntos pertinentes a esta pesquisa.
Inicialmente foram revisados os conceitos sobre UML (Unified Modeling Language), dando- se enfase ao diagrama de atividades.
Ainda nessa primeira etapa foram pesquisados os principais conceitos sobre SAN (Stochastic Automata Networks) e teste de software.
Em a segunda etapa, foram realizados estudos sobre o processo de conversão de diagramas UML, de entre eles diagramas de atividades para redes de Petri e SAN, que serviram de base para a formulação do metodo proposto nesta dissertação, buscando identificar padrões de mapeamento dos elementos UML durante a conversão, quando de a existência desses, que pudessem ser adotados tambem neste trabalho.
Os padrões buscados nessa etapa podem ser exemplificados como tratamento de condições transição, seja num diagrama de estados ou num diagrama de atividades.
Em a terceira etapa, foram gerados os primeiros modelos de redes de autômatos estocásticos gerados a partir de diagramas de atividades, com o objetivo de modelar o comportamento do sistema em estudo, tais modelagens, inicialmente, levaram em consideração apenas algumas características do diagrama de atividades, uma vez que, os primeiros modelos gerados não levaram em consideração a existência de condições de guarda no diagrama modelado.
Finalmente, para a conclusão deste trabalho, foi realizada a aplicação do metodo aqui proposto, em dois exemplos, onde os diagramas elaborados foram convertidos num modelo SAN que serviu de base para a geração dos casos de teste.
Apos a introdução definida como sendo o Capítulo 1, este trabalho está estruturado em cinco capítulos e uma conclusão, a qual sumariza as contribuições e faz propostas de trabalhos futuros referentes ao tema.
SAN obtida no processo de conversão.
Para finalizar, o Capítulo 6 apresenta as considerações finais e os trabalhos futuros propostos com base nos resultados obtidos com este trabalho.
A Engenharia de Software é uma disciplina da engenharia relacionada com todos os aspectos da produção de software, desde os estagios iniciais de especificação do sistema até sua manutenção depois do mesmo entrar em operação, abordando tanto aspectos tecnicos quanto de gerenciamento de processo.
De o ponto de vista formal, pode- se dizer que a Engenharia de Software busca conciliar custo baixo e qualidade no processo de desenvolvimento de software, associando as melhores praticas para a obtenção de um software confiavel, seguro e eficiente.
Em muitos projetos, o desenvolvimento de software envolve tanto a modelagem quanto o uso de linguagens orientadas a objeto, buscando empregar sempre os elementos da Engenharia de Software, de entre eles a UML (Unified Modeling Language).
Um processo de software define o conjunto de atividades que serão conduzidas no contexto do projeto, os recursos necessarios (software, hardware e pessoas), os artefatos (insumos e produtos) e os procedimentos a serem adotados na realização de cada uma das atividades.
Atualmente, desenvolver software de qualidade, com elevada produtividade, dentro de o prazo estabelecido e sem necessitar de mais recursos do que os alocados, tem sido o grande desafio da Engenharia de Software, seja por a melhoria de processos ou por o desenvolvimento de ferramentas de gerenciamento dos mesmos.
Em esse sentido a UML foi desenvolvida com o objetivo de descrever qualquer tipo de sistema, em termos de diagramas orientados a objetos e de padronizar a forma de especificação de sistemas, desde as fases iniciais até a fase de testes e manutenção.
A padronização do processo de desenvolvimento, proporcionada por a Engenharia de Software seja com tecnicas ou atraves de seus paradigmas de desenvolvimento e programação, abrange todas as fases do desenvolvimento.
A fase de testes, dentro de um processo de desenvolvilmento, é considerada uma das fases que demandam mais tempo e consomem mais recursos do projeto.
Em as proximas seções será detalhada a composição da UML, um dos focos principais desta dissertação, dando enfase ao diagrama de atividades demonstrando um exemplo de aplicação da UML com base no uso desse diagrama, demonstrando- se um exemplo de aplicação do diagrama de atividades.
Aborda- se ainda, de entre os assuntos descritos nesse capítulo, a definição e classificação do teste de software.
As linguagens de modelagem orientadas a objeto sugiram entre meados dos anos 70 e final dos anos 80 como metodologia aplicada à analise e ao projeto de software.
O número de metodos orientados a objeto aumentou de menos de 10 para mais de 50 durante o período entre 1989 e Booch, OOSE (Object Oriented Software Engineer) proposto por Jacobson e OMT (Object Modeling a Tecnical) proposto por Rumbaugh.
Em outubro de 1994 a UML foi oficialmente homologada por a OMG (Object Manager Group), apos Rumbaugh se juntar a Booch na empresa Rational, com o objetivo de unificar os metodos Booch e o OMT, dando origem, em outubro 1995, a versão 0.8 da UML que representava o metodo unificado.
Pouco tempo depois, Jacobson passou a integrar o projeto, que incorprou a metodologia OOSE (Object Oriented Software Engineer).
Essa união deu origem a versão 0.9 da UML, lançada em junho 1996.
Apos o lançamento da versão 0.9, um consorcio de empresas como a Digital Equipament Corporation, a Hewlett--Packard, a iLogix, a Intell corp, a IBM, a MCI Systemhouse, a Microsoft, a Oracle, a Rational, a Texas Instruments e a Unisys passou a contribuir para uma definição forte e completa da UML.
Esta colaboração conduziu à UML 1.
0, uma linguagem de modelagem mais expressiva, poderosa, e aplicavel a um maior número de problemas decorrentes do ciclo de vida de desenvolvimento de software (CVDS).
A versão 1.0 foi oferecida à OMG, para a padronização, em janeiro 1997, em resposta ao seu pedido de elaboração de uma linguagem de modelagem padrao.
Uma versão revisada da UML, a 1.1, foi oferecida à OMG para a padronização em julho 1997 e aprovada em setembro 1997, sendo então adotada por a OMG em 14 de novembro do mesmo ano.
Em junho de 1998 foi liberada a versão 1.2 e em dezembro do mesmo ano OMG homologou a versão 1.3 da UML.
Em 2001 a OMG homologou a versão 1.4 da UML e em 2002 a versão 1.5, mas foi a versão 2.0, lançada em 2003, que trouxe mais alterações à UML.
Em sua versão 2.0, a UML possui 13 diagramas classificados em estruturais (diagrama de classes, diagrama de objetos, diagrama de componentes e diagrama de implantação) e comportamentais (diagrama de casos de uso, diagrama de sequência, diagrama de atividades, diagrama de colaboração e diagrama de estados), sendo o diagrama de atividades, foco desta pesquisa, empregado para modelar aspectos dinamicos do sistema atraves de etapas sequenciais e, em alguns casos, concorrentes num processo computacional.
A UML tem por objetivos principais:
oferecer aos modeladoresuma linguagemexpressiva e visual para o desenvolvimentode mod elos significativos;
fornecer mecanismos de extensibilidade e especialização de conceitos de base;
descrever modelos de sistema -- do mundo real e de software -- baseado em conceitos de orientação a objetos;
fornecer uma linguagem de modelagem orientada a objeto, visual, facil e pronta para uso, permitindo amplas facilidades de modelagem;
admitir conceitos de desenvolvimento de componentes, framework e padroes;
integrar melhores praticas em desenvolvimento de sistemas orientados a objeto.
A UML utiliza- se de diagramas para representar o sistema, ou de parte de ele, em desenvolvimento modelando seu comportamento em diferentes fases.
A UML 2.
0 possui 13 diagramas, classificados em estruturais e comportamentais, que podem ser descritos da seguinte forma:
Diagrama de Classes:
Define a estrutura das classes utilizadas por o sistema determinando seus atributos e metodos;
Diagrama de Objetos:
Fornece uma visão dos valores armazenados por os objetos de um diagrama de classes num determinado momento da execução de um processo;
Diagrama de Componentes:
Representa os componentes do sistema, tais como bibliotecas, codigos fonte, modulos executaveis, os quais serão implementados.
Pode ser utilizado para mod elar interfaces;
Diagrama de Implantação:
Define as necessidades de hardware do ambiente onde o sistema sera executado.
Diagrama de Estrutura Composta: Modela as colaborações entre os componentes do sistema.
Uma colaboração descreve um conjunto de entidades, as quais interagem para a execução de uma função específica;
Diagrama de Sequencia: Modela a ordem temporal em que as mensagens são trocadas entre os objetos envolvidos num determinado processo;
Diagrama de Comunicação:
Modela os vínculos existentes entre os objetos e quais as mensagens trocadas entre eles, independente da ordem temporal em que elas acontecem;
Diagrama de Estados:
Baseia- se no diagrama de caso de uso, e representa o comportamento do sistema;
Diagrama de Atividades:
Descreve os passos a serem percorridos para a conclusão de uma ativi dade específica que altera o estado de um sistema;
Diagrama de Pacotes:
Descreve os subsistemas englobados por um sistema de forma a determinar as partes que o compoem.
Diagrama de Interação Geral: Descreve uma visão ampla do sistema ou processo de negocios e pode englobar diversos diagramas de interação a fim de atingir os seus objetivos;
Diagrama de Pacotes:
Tem o objetivo de representar os subsistemas que compoem um sistema, determinando assim as partes que o compoem;
Diagrama de Tempo:
Descreve a mudança no estado ou condição de uma instancia de uma classe ou seu papel durante um tempo.
Apesar de fazermos uma descrição suscinta de todos os diagramas UML, neste trabalho utilizaremos apenas o diagrama de atividades, o qual descreveremos com mais detalhes na proxima seção.
Um estudo mais aprofundado dos demais diagramas pode ser feito em &quot;UML a bíblia».
A UML possui cinco diagramas utilizados para a modelagem de aspectos dinamicos e comportamentais de um sistema, são eles:
Diagrama de atividades, diagrama de colaboração, diagrama de sequência, diagrama de estados e o diagrama de caso de uso.
Cada um dos diagramas comportamentais modela uma característica em relação a o comportamento do sistema, sendo empregado numa ou mais etapas do processo de desenvolvimento de um sistema.
O uso de diagramas comportamentais para a obtenção de modelos matematicos analíticos se deve a sua capacidade de representar um ou mais estagios de uso ou execução dó sistema em diferentes fases.
Essa característica comportamental desses diagramas UML os torna passíveis de serem representados por formalismos matematicos como redes de Petri, usadas em, cadeias de Markov usadas em e SAN (Redes de Autômatos Estocásticos) usadas em.
O diagrama de atividades é um dos cinco diagramas UML utilizados para a modelagem de aspectos dinamicos e comportamentais de um sistema, que em alguns casos envolve atividades sequenciais e possivelmente concorrentes em processos computacionais.
Essa característica de modelagem de execuções em forma de atividades e fluxos que as relacionam, e ainda a possibilidade de representação sequencial dessas execuções, confere ao diagrama de atividades um carater significativo, o que torna sua semantica semelhante as utilizadas em formalismos como cadeias de Markov (Cm), redes de autômatos estocásticos (SAN) e redes de Petri estocásticas (SPN).
A escolha deste diagrama como foco deste trabalho deve- se as características anteriormente citadas que possibilitam a conversão dos mesmos para modelos criados com base no formalismo SAN, o que viabiliza uma analise matematica dos diagramas.
Um exemplo de conversão de UML para SAN pode ser encontrado na pesquisa desenvolvida por Barros, onde diagramas de estados da UML, que tambem são diagramas comportamentais foram convertidos para modelos SAN, demonstrando a viabilidade de analise matematica dos mesmos.
Um diagrama de atividades representa o fluxo de uma atividade para outra, descrevendo os passos a serem percorridos para a conclusão de um metodo ou algoritmo específicos.
Os elementos que compoem a estrutura de diagrama de atividades podem ser descritos da seguinte forma[ Pen04, BRJ05, FoS08]:
Estado Inicial:
Estabelece o início da execução de uma atividade.
E representado por um çirculo totalmente preenchido;
Atividade: Uma atividade é uma execução de um processamento nao-átomico numa maquina de estados, de modo que cada atividade modela o processamento de uma ação.
Uma atividade é representada por um retangulo de cantos arredondados;
Merge: É representado por um losango com até tres transições de entrada e uma unica transição de saída.
E usado, assim como o join, para unir diferentes fluxos.
Um ponto de união ou de fusão funde um conjunto de fluxos (transições) num unico.
O ponto de união não tem conotação de sincronização, mas apenas de reunir um conjunto de elementos sintaticos num unico fluxo.
Nao possui semantica associada, apenas acrescenta informação ao diagrama.
Um diagrama de atividades pode conter fluxos de controle concorrentes, isso significa que pode haver dois ou mais fluxos sendo executados simultaneamente, ou seja, de forma paralela.
Para sincronizar dois ou mais fluxos, barras de sincronização são utilizadas.
Essas barras de sincronização podem ser de dois tipos:
Fork: É uma barra de bifurcação que estabelece os fluxos concorrentes, ou seja, recebe um fluxo de entrada e cria dois ou mais fluxos de saída;
Join: É uma barra de junção que recebe dois ou mais fluxos de entrada unindo- os num unico fluxo.
Esta barra tem o objetivo de sincronizar os fluxos de controle, concorrentes ou não, cri ados por o elemento fork.
Os fluxos de saída da barra de sincronização join só são disparadas quando todos os fluxos de entrada tiverem sido disparados.
O diagrama de atividades ainda possui os seguintes elementos:
Objeto: Representa um objeto de uma classe que participa de um fluxo de trabalho representado por o grafico de atividades.
O objeto pode ser a saída de uma atividade e a entrada de muitas outras atividades.
O mesmo objeto pode ser manipulado por um número de atividades consec utivas que mudam o estado do objeto.
O objeto pode ser exibido varias vezes num graficó de atividades, cada uma representando um estado diferente da sua vida e o estado do objeto a cada ponto pode ser colocado entre parenteses e anexado ao nome da classe.
O objeto é representado por um retangulo;
Fluxo de Objeto:
O fluxo de objeto é um tipo de fluxo de controle com entrada ou saída.
O símbolo de fluxo de objeto representa a existência de um objeto num determinado estado, não só o proprio objeto;
Estado Final: Estabelece o final da execução de uma atividades, finalizando o diagrama de ativi dade.
E representado por um circulo semi preenchido.
Swimlanes são mecanismos para organizar visualmente as atividades dentro de o diagrama, demon strando quem ou que parte do sistema é responsavel por a execução de uma determinada atividade.
Um Swimlanes pode ser representado por barras verticais.
Exemplo de descrição atraves do diagrama de atividades A Figura 2.1 mostra um exemplo de aplicação do diagrama de atividades.
Em esse exemplo é apresentado um processo de controle de estoque.
O diagrama apresentado descreve um processo integrante de um sistema de controle de estoque que é iniciado quando o usuario efetua o login no sistema.
O sistema valida os dados de login fornecidos por o usuario, caso haja inconsistência em algum dos dados fornecidos por o usuario, o sistema emite mensagem de erro e solicita novos dados para a validação.
Essas ações são representadas por as atividades efetuar login e validar usuario e senha mostrados no diagrama.
Apos a validação, o usuario informa os dados do cliente e o sistema consulta se o cliente está ou não cadastrado, caso não esteja, é necessario efetuar o cadastramento, onde os dados necessarios a realização do cadastro devem ser fornecidos.
Essas ações são representadas por as atividades cadastrar e consultar clientes, que estão relacionadas entre si por o elemento decisão, que determina a execução de uma ou outra atividade mostrada no diagrama.
Apos a confirmação da existência do cliente ou da efetivação do cadastro do mesmo no sistema, é executada a abertura do pedido, representado por o elemento atividade com o mesmo nome, procedendo a consulta dos itens cadastrados, representado tambem por o elemento com mesmo nome, caso o produto não esteja cadastrado ou não disponível em estoque, o sistema solicita ao cliente que informe um novo item a ser consultado.
Essas ações são representadas por o elemento decisão~ e os fluxos a ele relacionado.
Quando o item é localizado ele é adicionado ao pedido do cliente que informa se deseja adicionar mais produtos ou fechar o pedido e posteriormente emitir a nota fiscal.
Tais elementos são representados por os elementos atividade nomeados com o mesmo nome e relacionados tambem por um elemento decisão.
O proximo passo executado por o sistema é confirmar pedido e separar produtos, tais ações são executadas separadamente, e são representadas por elementos atividades e por uma barra de sincronização fork.
Posteriormente o sistema procede a baixa nas mercadorias selecionadas no pedido.
O sistema permite o cancelamento da nota fiscal e na sequência do pedido.
Caso o pedido seja confirmado, o sistema encerra a compra.
Tais ações são representadas por elementos atividade, elemento decisão e um elemento de junção join.
O elemento estado final representa o encerramento das atividades demonstradas no diagrama.
Os sistemas de informação passaram a fazer parte do ambiente das empresas, seja por meio de convergência, canais multimídia, múltiplos fatores interligados e negocios cada vez mais dependentes de softwares e computadores.
Isso ocasiona uma crescente demanda por produtos de software com qualidade, o que faz com que as empresas invistam em profissionais, ferramentas e tecnicas que proporcionem a melhoria do processo de desenvolvimento de produtos de software.
Em muitos casos, a obtenção de melhorias advem da adoção de tecnicas de teste de software.
Durante o processo de desenvolvimento de software há diversas atividades que tem por objetivo garantir a qualidade do produto a ser entregue ao cliente.
Porem problemas ainda podem aparecer, assim sendo, os testes são executados para garantir a identificação e resolução desses problemas.
Segundo Bartié, os custos decorrentes da correção de um problema detectado nas fases inicias do desenvolvimento são consideravelmente inferiores aos custos do mesmo problema, quando detectado apos a entrega do produto ao cliente.
Em essa fase, os custos podem ser bem mais que financeiros, pois podem atingir tambem a imagem e a credibilidade da empresa perante o cliente.
Os testes podem ser considerados como o processo de executar ações visando encontrar e revelar a presença de erros no sistema, ou seja, consiste na verificação dinamica do funcionamento de um determinado programa, baseado num conjunto finito de casos de testes, cuidadosamente relacionados dentro de um domínio infinito de entradas contra seu funcionamento esperado.
Os testes são amplamente utilizados e bem aceitos para a avaliação e aceitação de um sistema de software e podem ser considerados como uma forma de se fazer uma revisão completa do sistema, avaliando e apontando os erros, desde o projeto até a implementação e podem ser classificados em teste estrutural ou teste funcional.
Teste estrutural (White
Box) Segundo Bartié, o teste estrutural, tambem chamado de teste de caixa-branca, consiste em examinar a estrutura interna do programa testando a logica do mesmo atraves da analise do codigo fonte e da elaboração de teste, cobrindo todos os caminhos do programa.
Esses testes devem garantir que todas as linhas de codigos e condições estejam corretas.
Os testes devem exercitar:
todos os caminhos independentes dentro de um modulo, ao menos uma vez;
as decisões logicas para verdadeiro e falso;
todos os laços em suas fronteiras e dentro de seus limites;
as estruturas de dados internas para garantir a sua validade.
Os criterios pertencentes a estas tecnicas são classificados:
com base no fluxo de controle que utilizam características do controle de que são necessarias;
com base no fluxo de dados que associam ao grafo de fluxo de dadosde controle, informações sobre o fluxo de dados do programa;
com base na complexidade que utiliza informações sobre a complexidade do programa para determinar os requisitos de teste.
Estes testes são divididos em diferentes categorias que por sua vez possibilitam a detecção de falhas no sistema sob diferentes perspectivas, sendo que devido a a baixa criatividade de certos sistemas, algumas categorias podem ser planejadas em conjunto.
Teste funcional (Black
Box) O teste funcional testa o software com uma função que mapeia um conjunto de valores de entrada num conjunto de valores de saída, sem levar em conta a forma como esse mapeamento foi implementado.
O teste funcional tem por objetivo garantir que os requisitos do sistema foram plenamente atendidos por o algoritmo que compoem a estrutura do software.
O teste funcional preocupa- se em identificar quais funcionalidades estão sendo executadas, e não como elas são executadas.
Este tipo de teste baseia- se exclusivamente na especificação de requisitos para determinar que tipo de saídas são esperadas para um certo conjunto de entradas.
Em este tipo de teste são definidos os criterios de teste como:
Particionamento de equivalencia:
Essa tecnica de teste, tambem conhecida como classe de equivalência é uma tecnica introduzida por Myers em 1979 para reduzir o número de casos de teste a um nível controlavel, mas mantendo uma cobertura razoavel de teste.
Ba sicamente a tecnica considera que uma vez que não se pode testar todas as possibilidades de execução de um sistema, é possível dividir- lo em classes, de modo que casos de teste dentro de cada classe sejam equivalentes;
Analise do valor limite:
Esta tecnica valida os valores limites do domínio de entrada de um deter minado sistema, os casos de teste selecionados são os valores das fronteiras.
Essa tecnica geralmente é usada para complementar a tecnica de particionamento de equivalência, pois permite testar valores nos limites de cada classe.
Segundo Pezzé e Young e Bastos, os testes são aplicados de acordo com o ciclo de desenvolvimento do sistema e são classificados da seguinte forma:
Teste de unidade:
Tambem chamado de teste unitario, concentra- se no esforço de validação dá menor unidade de projeto de software e tem por objetivo garantir que a logica do programa esteja completa e correta;
Teste de integração:
Verifica basicamente se as unidades testadas de forma individual comportam se de maneira adequada quando são colocadas juntas, isto e, integradas;
Teste de sistema:
É usado para demonstrar que o sistema inteiro está correto, para tanto, esse teste coloca o sistema para funcionar junto com outros sistemas e elementos de hardware, nas mesmas condições em que será utilizado por o cliente;
Teste de aceitação:
É realizado por o cliente quando partes significativas, ou o sistema como um todo, são consideradas concluídas apos a realização dos testes.
Os testes de aceitação po dem ser do tipo alfa, quando realizado no mesmo ambiente onde o software foi desenvolvido, ou beta realizado no ambiente onde o sistema será implantado.
Um cenario de teste de software é uma historia hipotetica que visa ajudar a solucionar um problema complexo, recriando um caminho a ser seguido ou situação a ser testada, podendo ser descrito com base em especificações como UML (Unified Modeling Language).
Um cenario de teste de software é composto por casos de teste, que incluem os dados de entrada, os resultados esperados, as ações e as condições gerais para a execução dos testes.
Um caso de teste é uma especificação mais detalhada do teste com informações sobre itens do sistema, estabelecendo quais informações serão empregadas durante os testes do cenario e quais serão os resultados esperados.
Em Engenharia de Software, um &quot;test suítes «é uma coleção de casos de teste que se destina a ser utilizada como base para um programa demonstrar que ele possui um conjunto de especificações para avaliar o comportamento do sistema.
Um test suíte geralmente contem instruções detalhadas ou metas para cada conjunto de casos de teste e informações sobre a configuração do sistema a ser utilizado durante o ensaio, podendo conter tambem condições, estados, etapas e as descrições dos testes seguintes.
A geração dos casos de teste pode usar inúmeras metodologias, e de entre as metodologias utilizadas, destacam- se o:
Teste Randomico:
São aplicados sobre o metodo da caixa-preta e é com esse tipo de teste que é gerado o maior número de caso de teste.
Mas o mesmo seleciona apenas algumas entradas, não garantindo a efetividade dessa solução;
Teste Estatístico: Em esse teste os eventos de interesse são sequencias de estímulos que representam uma execução do software, onde uma descrição estatística das sequencias é obtida por a definição de variaveis randomicas que caracterizam o perfil do conjunto total de~ sequencias usadas na verificação do software;
Teste Estocástico: Este é um metodo para seleção de casos de teste que possibilita uma alternativa de formalização de teste de software, atraves da criação de modelos estocásticos, por parte de os testadores, que descrevem o comportamento do sistema em alternativa a geração de casos de teste de software;
Teste Baseado em Modelos:
O teste baseado em modelos consiste em usar ou derivar mod elos do comportamento esperado para produzir especificações de casos de teste (test suítes) que podem revelar discrepancias entre o comportamento real do programa e o modelo.
Os modelos podem ser derivados de modelos formais tais como maquinas de estados finitos (FSM -- Finite State Machine) ou gramaticas, ou informais, como diagramas UML (Unified Modeling Language), especialmente dos diagramas comportamentais como diagrama de estados, diagrama de atividades e diagrama de sequencia.
Em este capitulo é apresentada uma definição informal do formalismo de Redes de Autômatos Estocásticos (SAN -- Stochastic Automata Networks), a partir de a descrição das primitivas utilizadas por o formalismo.
Redes de Autômatos Estocásticos, do ingles -- SAN (Stochastic Automata Networks), é um for-malismo proposto por Plateau nos anos 80, para modelagem analítica de sistemas com um grande espaço de estados, equivalente a cadeia de Markov, dividido em subsistemas.
Essa modularização característica do formalismo SAN, permite o armazenamento e a solução de sistemas complexos, onde o problema de explosão de estados que ocorre com o uso do formalismo de cadeias de Markov, com o qual SAN possui equivalência, é atenuado.
Uma SAN é composta por um conjunto finito de estados e um conjunto finito de transições entre os estados.
As transições entre os estados são disparadas por eventos que podem ser do tipo local ou sincronizante e onde cada evento tem uma taxa de ocorrência associada a ele.
O estado de um autômato representa toda a informação referente a seu passado, assim, para um determinado conjunto de estados, um sistema poderá assumir somente um estado a cada momento, sendo este denominado como estado local.
O estado local do sistema modelado com o uso do formalismo SAN é o estado individual de cada autômato do modelo.
O estado global de um modelo do SAN é definido como a combinação de todos os estados locais de cada autômato componente da mesma.
Em uma SAN, um evento é uma entidade responsavel por disparar uma transição que altera o estado global de um modelo.
Cada transição possui um ou mais eventos associados a ela e esta é disparada por a ocorrência de qualquer um dos eventos.
Os eventos podem ser de dois tipos:
A Figura 3.2 apresenta a CTMC (Continuous Time Markov Chain) equivalente ao modelo SAN da Figura 3.1.
Os eventos sincronizantes disparam transições que mudam o estado local de mais de um autômato, isto e, dois ou mais autômatos podem mudar seus estados locais simultaneamente, ocasionando assim, tambem uma mudança no estado global da SAN.
A Figura 3.3 apresenta um autômato com eventos locais e sincronizantes.
Em a Figura 3.3, o autômato A possui tres estados 0, 1 e 2, já o autômato A possui dois estados 0 e 1.
O modelo apresenta ainda quatro eventos, sendo tres locais e2, e3, e4, e um sincronizante e1.
O evento e1 possui uma probabilidade de ocorrência de 1 e 2 respectivamente.
O evento sincronizante e1 altera os estados dos autômatos A e A de 0 para 1 e 0 para 1, respectivamente, com uma probabilidade 1 e tambem altera os estados dos autômatos A é A de 0 para 1 e 0 para 1, respectivamente, com uma probabilidade 2.
A Figura 3.6 apresenta a CTMC (Continuous Time Markov Chain) equivalente ao modelo SAN da Figura 3.3.
Cada evento deve possuir uma taxa de ocorrência e uma probabilidade associada ao mesmo.
Tanto a taxa quanto a probabilidade de ocorrência podem ter valores constantes ou valores funcionais, os quais assumem valores diferentes de acordo com os estados de outros autômatos do modelo.
A classificação de um evento como local ou sincronizante é feita por o identificador do evento e no conjunto de eventos de um autômato.
Caso o identificador apareça num unico autômato, esse evento é classificado como local, caso ele apareça em mais de um autômato ele será denominado como sendo sincronizante.
As taxas funcionais são usadas quando as taxas de ocorrência dos eventos que disparam as transições, não forem constantes, ou seja, tem- se uma função do estado local de outros autômatos da SAN, avaliada conforme os estados atuais do modelo.
As taxas funcionais podem ser atribuídas a eventos locais ou sincronizantes para definir se um evento pode ou não ocorrer dado o estado de outros autômatos da rede.
As transições disparadas por eventos aos quais existam taxas funcionais associadas baseiam- se nos estados atuais do modelo, podendo variar seu valor conforme os estados em que se encontram os autômatos envolvidos na função.
Por exemplo, se no autômato A quisessemos representar uma transição disparada por um evento local ao qual existe uma taxa funcional associada, teríamos que definir uma função f1, conforme é demonstrado abaixo:
A Figura 3.5 mostra uma SAN que possui um evento ao qual foi atribuída taxa funcional, mostrada anteriormente.
A taxa atribuída determina que a transição disparada por o evento e3 ocorrerá somente quando autômato A estiver no estado 1, caso contrario a transição não ocorrera.
Porem, na maioria dos modelos, não é o que acontece, pois quando se modela um sistema do mundo real é possível identificar- se condições para que determinados eventos ocorram ou não, o que significa dizer que quando estas condições não forem cumpridas, alguns estados globais terão probabilidade nula de ocorrerem, ou seja, serão considerados como estados inatíngiveis.
A função de atingibilidade para o modelo apresentado na Figura 3.5, com base na linguagem defnida para a ferramenta PEPS2003, pode ser escrita da seguinte forma:
A função de atingibilidade pode ser melhor compreendida quando imaginamos um modelo com um número N de clientes disputando uma quantidade R de recursos e que a quantidade de recursos é inferior a quantidade de recursos disponíveis.
Para o exemplo aqui descrito, adaptado do trabalho de, é apresentado um modelo onde existem C clientes que disputam R recursos, como demonstrado na Figura 3.7.
Um autômato que descreve os clientes pode ser modelado com dois estados, aguardando ou usando, quando o cliente está aguardando o recurso, significa dizer que autômato se encontra no estado 0 (i e quando o) cliente está de posse do recurso o autômato se encontra no estado 1.
A função de atingibilidade, com base na ferramenta PEPS, para o exemplo descrito é escrita da seguinte forma:
Para esse exemplo a atingibilidade é possível caso a somatoria dos estados do autômato C, que representa a quantidade de clientes, seja menor ou igual à quantidade de recursos disponíveis, representado por o autômato R.
As funções de integração são definidas para a obtenção de resultados numericos sobre o modelo SAN visando avaliar qual a probabilidade do modelo estar num determinado estado.
Com isso, pode- se compor funções de integração que levem em conta a probabilidade do modelo se encontrar num conjunto de estados, podendo assim obter índices de desempenho e confiabilidade do modelo.
As funções de integração não fazem parte do formalismos SAN, sendo apenas uma implementação da ferramenta PEPS mas que se mostra bastante util para a obtenção de resultados, a partir de os modelos gerados.
As funções de integração são avaliadas sobre o vetor de probabilidades, o qual contem a probabilidade do modelo de se encontrar em cada um dos estados pertencente a ele.
Por exemplo, podemos compor a seguinte função de integração para o modelo da Figura 3.5, onde X representa a probabilidade do autômato A se encontrar no estado 1:
Em esta seção são descritos alguns metodos de conversão de diagrama de atividades da UML para formalismos como Redes de Petri e SAN.
Tais trabalhos servirão de base para a elaboração do metodo proposto nesta dissertação.
Tres dos trabalhos aqui descritos baseiam- se em redes de Petri.
Os metodos baseados em redes de Petri são:
O desenvolvido por Bernardi, o metodo de conversão desenvolvido por Lachtermacher, o metodo de conversão desenvolvido por Lopez-Grão e adicionalmente o metodo de conversão de diagrama de estados da UML para SAN, desenvolvido por Barros tambem é apresentado.
Redes de Petri é uma ferramenta de modelagem aplicavel a uma serie de sistemas, especialmente aqueles com eventos concorrentes.
Elas foram criadas por C. A. Petri, que na sua tese de doutorado apresentou um tipo de grafo orientado e bipartido com estados associados, com o objetivo de estudar a comunicação entre autômatos.
De acordo com Reisig, as redes de Petri são formadas por dois tipos de componentes:
Um ativo denominado transição, correspondente a uma ação realizada dentro de o sistema, e outro passivo.
Uma rede de Petri recebe uma ou mais marcas (ou tokens) que podem estar em mais de um lugar ao mesmo tempo.
O disparo de uma transição consome marcas, fazendo com que elas mudem de lugar.
Os trabalhos aqui apresentados não esgotam as discussões sobre o tema, mas elencam algumas contribuições significativas para esta pesquisa.
Em o metodo de conversão apresentado por Bernardi, é descrito um estudo sobre a utilização de diagramas de sequência e diagramas de estados da UML para a validação e avaliação do desempenho de sistemas, a partir de a conversão dos mesmos para uma rede de Petri.
Para tal Bernardi assume que um sistema é especificado como um conjunto de estados (sequência de graficos e diagramas), os quais são usados para representar &quot;Execuções de Interesse».
Segundo Bernardi em, a conversão deve- se ao fato da UML não possuir uma semantica formal que possibilite a aplicação de uma forma direta de analise matematica no sistema modelado com o uso dessa linguagem.
Assim a utilização de formalismos, de entre eles as redes de Petri, possibilita a analise matematica do sistema.
A pesquisa propoe a conversão automatica de diagramas de estados e diagramas de sequencia~ em GSPN (Generalized Stochastic Petri Nets -- Redes de Petri estocásticas Generalizadas), para que seja possível a aplicação de metodos matematicos de avaliação de desempenho de sistemas.
Cabe ressaltar que os autores não detalham em seu trabalho, quais índices de desempenho ou probabilidades de ocorrência dos estados foram obtidos a partir de a conversão dos diagramas.
De acordo com Bernardi, a pesquisa tinha por objetivo analisar a coerência entre as duas descrições e avaliar estocásticamente se o comportamento do sistema é consistente com os padrões de interação descritos por os diagramas de sequência e de estados.
A proposta de conversão não leva em consideração a totalidade de elementos dos diagramas de sequência e de estados.
Em os diagramas de sequência, os recursos não considerados são:
Iterações, temporalidade e restrições.
Já no diagrama de estados, não são considerados:
Estados compostos, pseudoestados e historico dos estados.
Maiores detalhes sobre os elementos que compoem os diagramas de estados e de sequência podem ser encontrados em «UML:
Guia do usuario».
As analises do modelo obtido são feitas segundo uma das duas tecnicas denominadas por Bernardi em, como The full case é The constrained case.
A primeira tecnica é baseada na construção de um modelo completo do diagrama de atividades e do diagrama de sequência para a geração da LGSPN (Labeled Generalized Stochastic Petri Nets -- Redes de Petri estocásticas Generalizadas Rotuladas) resultante.
Em a segunda tecnica, Bernardi define os possíveis caminhos na rede de Petri, a partir de alterações na sua estrutura, assim, os resultados obtidos são analisados na pesquisa, de acordo com um comportamento do sistema, definido por os pesquisadores.
Em os dois casos, os modelos foram submetidos, afim de se obter os índices de desempenho do modelo, a uma ferramenta denominada GREATSPN (GRaphical Editor and Analyzer for Timed and Stochastic Petri Net), ferramenta desenvolvida por o departamento de Informatica da Universidade de Torino, para a modelagem, validação e avaliação de desempenho de sistemas distribuídos, usando Redes de Petri estocásticas Generalizadas e sua extensão colorida1.
Essa pesquisa contribuiu para a definição dos primeiros passos para a conversão de diagramas de atividades, pois com base nessa pesquisa defini- se que as atividades seriam convertidos em estados de um modelo SAN.
Outra contribuição dessa pesquisa, foi a definição de que não seria possível utilizar todos os elementos do diagrama de atividades no momento da conversão.
Como contribuição, cita- se tambem a definição de transições entre os estados bem como os eventos que disparam essas transições.
O metodo proposto por Lachtermacher em tem por objetivo converter diagramas de atividades da UML em redes de Petri, baseado numa especificação definida por a OMG (Object Modeling Group), denominada de MOF/ QVT (Meta Object Facility/Query View Transformation), que visa a conversão de um modelo UML num modelo matematico.
O processo de conversão proposto é executado considerando os seguintes aspectos:
o elemento Atividade no diagrama de atividades é convertido em transição numa rede de Petri;
o elemento Estado Inicial do diagrama de atividades e o elemento Decisão são convertidos em elemento Lugar, na rede de Petri, sem nenhuma marca;
os elementos Fork (separação) e Join (junção) são mapeados como uma transição na rede de Petri;
os elementos Final de Fluxo e Final de Atividade são mapeados para um lugar que não tem saída, chamado de Sink;
o elemento Objeto é mapeado para um lugar com uma marca que representa a mudança de estado do objeto.
Em sua pesquisa, Lachtermacher afirma que para atender a especificação da OMG foram desenvolvidos dois metamodelos, um contendo as definições para a composição de um diagrama de atividades e o outro contendo as definições para a composição de uma rede de Petri.
Um metamodelo é uma descrição, ou seja, a definição de regras para criação de novos modelos, a partir de um modelo padrao.
As regras para a conversão, em as quais o metamodelo se baseia, uma ferramenta opensourse denominada MediniQVT.
O objetivo da pesquisa foi realizar um estudo sobre QVT, visando auxiliar o desenvolvedor de software a utilizar o diagrama de atividades para finalidades as quais ele foi estruturado para realizar, que é a de demonstrar o fluxo de execução de processos ou de um algoritmo que compoem um sistema.
Para alcançar o objetivo proposto, Lachtermacher realizou a conversão de modelos UML para redes de Petri, afim de demonstrar a viabilidade de conversão de modelos.
A pesquisa não teve por objetivo extrair nenhum índice de desempenho ou probabilidades a partir de os modelos gerados.
As contribuições dessa pesquisa para a construção do metodo proposto podem ser descritas da seguinte forma:
O processo de transcrição do elemento atividade é o mesmo tanto na pesquisa de, onde o referido elemento é transcrito como um lugar numa rede de Petri, quanto na dissertação aqui apresentada, pois esse elemento representa um estado numa SAN.
O elemento decisão e união são mapeado como um lugar sem marcas na rede de Petri.
Em o metodo aqui proposto, esses elementos são mapeados como sendo transições entre estados do modelo SAN.
Outra contribuição deste trabalho é em ralação ao elemento fork, que tanto neste trabalho relacionado, quanto no metodo proposto é mapeado como sendo uma transição.
Em a pesquisa apresentada por Lopez-Grão é descrito um metodo de conversãó de diagramas de atividades numa rede de Petri, adotando uma semantica formal que possibilite transformar cada elemento de um diagrama de atividades num elemento equivalente em LGSPN (Labeled Generalized Stochastic Petri Nets).
O resultado da composição é uma nova LGSPN que representa um modelo para avaliação de desempenho do sistema com um razoavel grau de expressividade para lidar com a descrição é avaliação da dinamica de sistemas grandes e complexos.
O objetivo do metodo de conversão proposto por Lopez-Grão é formalizar uma semantica qué~ permita traduzir diagramas de atividades em modelos de Redes de Petri Estocaticas Generalizadas analisaveis.
A pesquisa buscou uma tradução do digrama de atividades num modelo estocástico baseado em redes de Petri, o qual permita verificar propriedades logicas, bem como calcular os índices de desempenho.
Os autores não informam, no material pesquisado, quais índices de desempenho podem ser extraídos a partir de o modelo gerado.
Em a pesquisa de Lopez-Grão, apresenta- se uma breve descrição de um prototipó da ferramenta que implementa o metodo de conversão proposto por os autores.
A conversão dé cada um dos elementos do diagrama de atividades para a rede de Petri pode ser resumida como um processo executado em tres etapas, obedecendo regras de transição definidas com o uso da linguagem OCL e podendo ser descrita da seguinte forma:
inicialmente as transições são identificadase para cada tipo de transição uma regra é aplicada;
posteriormente é gerada a rede de Petri correspondente ao diagrama;
finalmente, num terceiro passo, uma nova LGSPN é gerada considerando- se, caso existam, pseudo estados como fork e join.
Lopez-Grão relata em que com o objetivo de automatizar o processo de conversão foi desenvolvida uma ferramenta, utilizando- se a linguagem Java, que coleta informações em arquivo.
Xmi. O XMI combina os benefícios da XML para definição, validação e compartilhamento de formatos de documentos com os benefícios da linguagem de modelagem visual UML para especificação, visualização, construção e documentação de objetos construídos tambem a partir de modelos UML.
Os arquivos.
Xmi citados por Lopez-Grão em foram gerados com o uso da ferramenta ArgoUML, que segundo os autores, apresenta limitações de modelagem que foram compensadas durante o desenvolvimento da ferramenta proposta.
A rede de Petri resultante dessa pesquisa tem seus índices de desempenho extraídos com o uso da ferramenta GreatSPN.
As contribuições dessa pesquisa para a construção do metodo proposto podem ser descritas da seguinte forma:
o elemento decisão é substituído por transições de saída equivalente a estados de ação, preservando as propriedades inerentes ao desempenho da rede gerada.
Em o metodo proposto esse elemento tambem é transcrito da mesma forma;
o elemento merge tanto na pesquisa de quanto no metodo proposto são transcritos como transição entre os estados;
o elemento fork, tanto na pesquisa quanto no metodo proposto, é mapeado como transições que no caso de SAN é feita entre os estados;
A pesquisa apresentada por Barros teve como objetivo obter um modelo de uso do sistema a ser construído, baseado em diagrama de estados da UML, sobre o qual, com o uso de SAN seria possível efetuar analises de comportamento do software.
Em a pesquisa de Barros, inicialmente define- se um metodo de conversão dos elementos do diagrama de estados para uma estrutura correspondente em SAN e as taxas de transição a serem utilizadas nesse mesmo modelo.
As informações referentes aos eventos (nome e tipo) foram compostas a partir de informações coletadas com base nos estados envolvidos em cada transição, considerando- se o contexto em que essa transição ocorre.
O processo de transcrição do diagrama UML para o modelo SAN ocorre considerando- se cada estado do diagrama como sendo um estado de um autômato.
As transições existentes no diagrama são modeladas como eventos locais, ou eventos sincronizantes, podendo ser associadas taxas funcionais aos eventos que disparam essa transição, quando de a existência de condições de guarda associadas ao diagrama de estados.
Como resultado final de sua pesquisa Barros apresenta uma ferramenta que executa o processo de conversão de diagramas UML para SAN, a partir de informações extraídas de um arquivo.
Xmi, gerando um arquivo com extensão.
San, que posteriormente é submetido a As contribuições dessa pesquisa para a construção do metodo proposto, podem ser descritas da seguinte forma:
o elemento fork, em SAN, é modelado com a utilização de eventos sincronizantes que asse guram a execução simultanea de cada uma das regiões, sendo que cada região é modelada por um autômato distinto.
Em o metodo proposto cada transição oriunda de um elemento fork tambem é modelada como um autômato distinto;
o tratamento de condições de guarda que tanto nesta pesquisa quanto no metodo são tratadas de maneira que a presença de condições de guarda em determinadas transições sugere a inclusão de uma estrutura (um autômato), que avalie a restrição, para então permitir (ou nao) o disparo dessa transição.
Em o capítulo seguinte, apresentamos o metodo de conversão de diagramas de atividades para Redes de Autômatos Estocásticos (SAN).
Em este capítulo são apresentadas as regras criadas para a conversão de diagramas de atividades da UML (Unified Modeling Language) para um modelo SAN (Stochastic Automata Networks), buscando descrever as ações executadas em cada passo da conversão.
Em esta seção, serão descritas as regras de conversão de diagramas de atividades da UML para um modelo SAN.
Inicialmente cabe ressaltar que um dos principais desafios do uso de diagramas UML para a avaliação de desempenho é a escolha de uma semantica de forma adequada, que não seja nem demasiadamente restritiva, permitindo ao modelador um bom grau de expressividade, nem muito permissiva a ponto de não representar o comportamento adequado do sistema a ser modelado.
Assim, segundo Bernardi o uso de metodos de conversão de UML para formalismos matematicos Markovianos implica em tomadas de decisão por parte de o desenvolvedor sobre a interpretação do diagrama.
O metodo que se propoem neste trabalho é uma conversão manual de diagramas de atividades da UML para um modelo SAN que possibilite realizar analises de comportamento, tais como, determinar a funcionalidade do sistema que possui uma maior probabilidade de uso.
Pretende-se ainda, com base no modelo SAN obtido, gerar casos de teste de software.
A seguir são descritos os passos para a obtenção de uma SAN a partir de um diagrama de atividades da UML.
O metodo de conversão aqui apresentado baseia- se nos metodos propostos por:
Bernardi, para a conversão de diagramas de atividades em rede de Petri;
Lachtermacher metodo de conversão de diagrama de atividades para rede de Petri com base em QVT;
Lopez-Grão o metodo de conversão de diagrama de atividades para rede de Petri;
Barros metodo de conversão de diagrama de estados para SAN.
Ressalta- se que nos modelos aqui apresentados, tanto na descrição dos passos de conversão quanto nos exemplos demonstrados, não se está levando em consideração as taxas de ocorrência dos eventos atribuindo- se a todas elas o valor 1.
Tal decisão se deve ao fato de estarmos focando apenas a execução do metodo, visando demonstrar sua viabilidade.
O processo de conversão pode ser descrito em sete passos, conforme apresentado nas subseções a seguir.
Os diagramas de atividades mostram uma sequência de ações, e deverão indicar o ponto de partida da sequência, e para tal, é utilizado o elemento estado inicial.
O estado inicial é desenhado como um solido çirculo com uma linha de transição (seta) que o conecta a primeira atividade modelada no diagrama.
Embora a especificação UML não defina uma localização específica para o estado inicial no diagrama de atividades, ele é normalmente colocado antes da primeira atividade, no canto superior esquerdo do diagrama.
Outra característica desse elemento é a de que só pode existir um unico estado inicial e apenas uma linha de transição que liga o mesmo a uma atividade.
O fluxo de atividade termina quando a linha de transição da ultima ação no diagrama se conecta a um estado final, símbolo que é representado por um çirculo em torno de um çirculo menor, sendo este totalmente preenchido.
Todo diagrama de atividades deve ter pelo menos um símbolo do estado final, podendo possuir varios.
Passo 1: Inicia- se com a identificação dos elementos que compoem o diagrama de atividades e que serão convertidos em estados ou transições de um ou mais autômatos.
Assim os elementos estado -- inicial e estado -- final são convertidos como sendo um autômato com dois estados nomeados como I e F e duas transições disparadas por dois eventos sincronizantes.
A criação desse autômato se deve ao fato de que a semantica da UML, para o diagrama de atividades, define que deva existir um elemento estado -- inicial e um elemento estado -- final.
A Figura 4.1 traz a representação grafica de um diagrama de atividades que possui os elementos estado -- inicial e estado -- final.
A Figura 4.2 traz a representação grafica do autômato obtido com base na Figura 4.1.
O~ autômato mostrado na Figura 4.2, possui dois estados denominados I, que representa o elemento estado -- inicial e ao qual foi associada uma transição disparada por o evento sincronizante es1 e um estado denominado F que representa o elemento estado -- final e que possui uma transição disparada por o evento sincronizante es2.
Em este exemplo, a atividade demonstrada na Figura 4.1 não foi convertida, aqui foram considerados apenas os elementos estado -- inicial e estado -- final.
Quando um diagrama de atividades possuir mais que um estado final, estes serão convertidos em apenas um estado denominado F, conforme descrito anteriormente.
Um elemento atividade num diagrama de atividades é indicado por um objeto retangular com as bordas arredondadas e o texto em seu interior indica uma ação.
O nome atribuído a uma atividade deve ser formado por a combinação de um verbo e um substantivo.
A descrição de uma atividade deve definir uma unica instancia, exprimindo o que ela faz e como ela o faz.
Passo 2: Cada atividade de um diagrama é mapeada como sendo um estado de um autômato n representa a quantidade de atividades existentes no diagrama.
Afim de melhor representar cada elemento pode- se utilizar como forma de identificação de cada estado do modelo SAN criados com base nas especificações definidas no diagrama de caso de uso.
A Figura 4.3 traz a representação grafica do elemento atividade em UML ao passo que a Figura 4.4 traz a representação grafica do modelo SAN obtido com base na Figura 4.3.
O modelo SAN obtido possui dois autômatos, denominados Aut1 e Aut2, sendo que o primeiro autômato representa a execução do passo 1 descrito anteriormente e o segundo representa a execução do passo 2.
O autômato Aut2 possui os estados 0 que possui uma transição disparada por o evento E1 e é utilizado para representar o momento em que nenhuma atividade está sendo executada.
O autômato traz ainda os estados E1 que possui uma transição disparada por o evento local el1, e o estado E2 que possui uma transição disparada por o evento sincronizante es2.
Ambos os estados são resultantes da conversão das atividades 1 e 2 respectivamente.
A Figura 4.5 traz a representação grafica da cadeia de Markov equivalente ao modelo SAN resultante da execução do passo 2.
A transição representa o relacionamento entre duas atividades e são chamadas de transição nao-ativadas, por não representarem um espaço de tempo.
Quando um estado de ação ou de atividade se completa, o fluxo de controle passa imediatamente para o proximo estado de ação ou de atividade conectados via uma transição.
O fluxo que representa o elemento transição é indicado por uma seta unidirecional.
Passo 3: As transições entre as atividades do diagrama são mapeadas como transições entre os estados.
Essas transições são disparadas por eventos locais ou sincronizantes, de acordo com as características do diagrama.
As transições em SAN, assim como as transições em UML, são representadas por uma seta unidirecional.
Normalmente algumas decisões precisam ser tomadas durante uma atividade, dependendo do resultado de uma ação específica previa.
Para tal utiliza- se o elemento decisão representado por um diamante num diagrama de atividades.
Uma vez que a decisão terá pelo menos dois resultados diferentes, o elemento decisão tera duas linhas de transição conectado a duas ações diferentes.
Cada linha de transição envolvida num ponto de decisão deve ser rotulada com um texto que indica uma condição de guarda, comumente abreviado como guardas.
A condição de guarda define quando uma ação pode ou nao~ ser executada.
Passo 4: O elemento decisão é mapeado como transições disparadas por eventos locais ou sin cronizantes.
As condições de guarda existentes nesse elemento são tratadas utilizando- se um autômato que possui dois estados denominados T e F respectivamente e possuem duas transições disparadas por eventos locais.
As transições resultantes da conversão do elemento decisão tem suas taxas de ocorrência definidas com o uso de taxas funcionais que de terminam que o disparo da transição ocorrerá conforme o estado do autômato que representa a condição de guarda.
A Figura 4.6 traz a representação grafica de um diagrama de atividades que possui um elemento decisão em UML ao passo que a Figura 4.7 traz a representação grafica do modelo SAN obtido com base na Figura 4.6.
O modelo SAN obtido possui tres autômatos definidos como Aut1, Aut2 e cond -- guard, sendo que o primeiro autômato representa a execução do passo 1 descrito anteriormente e possui dois estados denominados I e F com duas transições disparadas por os eventos sincronizantes es1 e es2, o segundo e o terceiro autômatos representam a execução do passo 4.
O autômato Aut2 possui 3 estados denominados 0 que possui uma transição disparada por o evento sincronizante es1, que representa a não execução de qualquer atividade, o estado E1 que representa a atividade 1 e que possui uma transição disparada por o evento local el1 e uma transição disparada por o evento el2 que levam aos estados E2 e E3 respectivamente.
Para esses eventos foi definida uma taxa de ocorrência da transição, atraves de uma taxa funcional que determina que essas transições só poderão ocorrer se o autômato cond -- guard estiver no estado T para haja a transição disparada por o evento el1 ou no estado F para o disparo do evento el2.
Os estados E2 e E3 possuem uma transição cada disparadas por os eventos locais el4 e el3 respectivamente, que levam ao estado J que representa o final da execução de todas as atividades e que possui uma transição disparada por o evento sincronizante es2 que leva ao estado 0.
O autômato cond -- guard possui dois estados denominados T que possui uma transição disparada por o evento el5 que leva ao estado F que tambem possui uma transição disparada por o evento el6 que leva ao estado T. Esse autômato é utilizado para a avaliação da condição de guarda existente no diagrama de atividades, tal avaliação é feita com o uso da taxa funcional descrita anteriormente.
O estado J existente nos autômatos Aut2 e Aut3 representam o elemento join que será descrito posteriormente.
A Figura 4.8 traz a representação grafica da cadeia de Markov equivalente ao modelo SAN resultante da execução do passo 4.
Passo 5: O elemento fork é mapeado como sendo uma ou mais transições disparadas em autômatos que representam as atividades executadas, uma vez que cada execução das atividades parale las do diagrama é mapeada como sendo um autômato onde cada estado componente desse autômato representa uma atividade do diagrama.
A Figura 4.9 traz a representação grafica de um diagrama de atividades que possui um elemento fork.
O modelo SAN obtido possui tres autômatos definidos como Aut1, Aut2 e Aut3, sendo que o primeiro autômato representa a execução do passo 1 descrito anteriormente e possui dois estados denominados I e F com duas transições disparadas por os eventos sincronizantes es1 ees2, o segundo e o terceiro autômatos representam a execução do passo 5.
Tanto o autômato Aut2 quanto o Aut3 possuem a mesma estrutura, a qual possuem 3 estados denominados 0 que possui uma transição disparada por o evento sincronizante es1, que representa a não execução de qualquer atividade, o estado E1 que possui uma transição disparada por o evento local el1 no autômato Aut2 e el2 no autômato Aut3 e que representa a atividade 2, o estado J que possui uma transição disparada por o evento es2.
O estado J representa o elemento join que sera descrito posteriormente.
De acordo com Jacobson, Booch and Rumbaugh em, a utilização do elemento fork, requer a utilização do elemento join, uma vez que esse elemento é o responsavel por a união dos fluxos gerados.
A conversão do elemento join é detalhada no passo seguinte.
Cabe ressaltar que devido a essa exigência da UML as Figuras 4.9 e 4.12 utilizadas para demonstrar a representação grafica dos elementos fork e join são as mesmas.
A Figura 4.11 traz a representação grafica da cadeia de Markov equivalente ao modelo SAN resultante da execução do passo 5.
Quando o diagrama de atividades representa um comportamento paralelo definido por um elemento fork, se faz necessario uma sincronização dos fluxos gerados por esse elemento.
Essa sincronização ou junção é executada por o elemento join que alem de desempenhar a função anteriormente citada determina que a transição seguinte será efetuada somente quando todos os estados nas transições de entrada tenham completado suas atividades.
Passo 6: O elemento join é mapeado como sendo um estado nomeado como ji, com i variando diagrama.
O estado ji é associado a quantos estados gerados de acordo com a quantidade de atividades existentes no diagrama.
Tal mapeamento visa garantir a preservação de uma das características desse elemento, a qual determina que a transição que leva ao estado final do diagrama só pode ocorrer quando todas as atividades paralelas tiverem sido executadas.
Assim é possível atribuir ao estado que representa esse elemento, uma transição disparada por um evento sincronizante.
Os estados gerados nesse passo são nomeados como Ji com tambem pode ser aplicada quando de a execução desse passo.
Tanto o autômato Aut2 quanto o Aut3 possuem a mesma estrutura, a qual possuem tres estados denominados:
0 que possui uma transição disparada por o evento sincronizante es1, que representa a não execução de qualquer atividade, o estado E1 que possui uma transição disparada por o evento local el1 no autômato Aut2 e el2 no autômato Aut3 e que representa a atividade 2, o estado J que possui uma transição disparada por o evento sincronizante es2, que leva ao estado 0.
A criação dos estados J visa garantir a semantica existente no diagrama de atividades da UML que determina que quando o elemento join é utilizado, podem ocorrer situações onde as atividades modeladas são finalizadas em instantes diferentes, o que só habilita a transição para o elemento final quando todas as atividades se encerram e tem seu fluxo direcionado ao elemento join.
A Figura 4.14 traz a representação grafica da cadeia de Markov equivalente ao modelo SAN resultante da execução do passo 6.
Em alguns casos, o fluxo processual de um caminho decisão pode ligar de volta para outro caminho decisão.
Em estes casos, podemos conectar dois ou mais caminhos de ação juntamente com o ícone do mesmo diamante com varios caminhos apontando para ele, mas com apenas uma linha de transição que vem de fora.
Isso não indica um ponto de decisão, mas sim uma forma de unir diferentes fluxos, essa característica é modelada por um elemento denominado merge.
Passo 7: O elemento merge, assim como o elemento decisão, é mapeado como transições dis paradas por eventos locais ou sincronizantes conforme a utilização do elemento.
Cabe ressaltar que diferentemente do elemento decisão, este elemento não possui nunca uma condição de guarda associada a ele, pois o mesmo tem apenas a função de unir diferentes fluxos.
SAN apresentada neste passo seguem a descrição apresentada anteriormente no passo 4.
A Figura 4.16 traz a representação grafica da cadeia de Markov equivalente ao modelo SAN resultante da execução do passo 7.
Em esta seção, apresentamos alguns elementos que compoem um diagrama de atividades, mas que não foram considerados no momento da conversão de UML para um modelo SAN.
Tal decisão se deve ao fato de que o uso dos elementos a seguir descritos não altera as características do diagrama e tambem não traz nenhuma informação adicional sobre o comportamento do sistema que está sendo modelado.
As definições a seguir se baseiam no trabalho de Bell.
Swimlanes (raias):
Em diagramas de atividades, muitas vezes, é util para o modelo da ativi dade processual fluxo de controle entre os objetos (pessoas, organizações ou outros entidades responsaveis) que realmente executar a ação.
Para isso, é possível adicionar um elemento de nominado swimlanes (raias) para o diagrama de atividades.
Cabe ressaltar que, embora o uso de raias melhore a clareza de um diagrama de atividades, todas as regras que regem a criação dos diagramas de atividades devem ser obedecidas, assim o uso ou não desse elemento não altera as características nem a função do diagrama.
Objeto: O objeto em símbolo do estado é o retangulo que possui um texto sublinhado que representa a informação sobre aquele objeto.
A inclusão de um objeto não altera a forma como o diagrama de atividades é lido, apenas fornece informações adicionais sobre a execução da atividade a qual o objeto está relacionado.
Fluxo de objeto:
Um fluxo de objeto é similar a uma linha de transição, mas é mostrado como uma linha tracejada, em vez de uma solida.
Um fluxo de objeto linha está ligado a um objeto no estado símbolo, e uma outra linha de fluxo objeto conecta o objeto em símbolo do estado para a proxima ação.
Em o capítulo seguinte serão demonstrados dois exemplos de conversão de um diagrama de atividades para um modelo SAN, seguindo os passos anteriormente descritos.
O capítulo apresenta ainda o processo de geração de casos de teste baseado no modelo SAN obtido.
Em este capítulo serão apresentados dois exemplos de conversão de diagramas de atividades UML (Unified Modeling Language) para SAN (Stochastic Automata Networks).
O capítulo traz ainda a descrição do processo de geração de casos de teste de software baseado no modelo SAN obtido.
O diagrama apresentado aqui descreve um processo de venda de produtos que tem início com o recebimento do pedido.
Em a sequência duas atividades são executadas paralelamente, tais atividades são preencher pedido e emitir nota fiscal.
Apos a atividade preencher pedido, é modelada a escolha entre duas atividades que podem vir a ser executadas, são elas, entrega durante a noite que pressupoem urgência na execução da tarefa, ou entrega regular.
O processo de emissão de nota fiscal é caracterizado por duas atividades, emitir nota fiscal e receber pagamento.
Apos a execução dessas atividades, o diagrama remete a um elemento join que simboliza o aguardo do termino de todas as atividades executadas em paralelo.
Com base no diagrama apresentado na Figura 5.1, o elemento estado inicial e final do diagrama de atividades é convertido para os estados I e F do autômato A. Para esse autômato foram definidas duas transições, disparadas por os eventos sincronizantes es1 e es3 respectivamente.
O autômato A possui dois estados, o estado 0 representa a espera por a execução da primeira atividade do diagrama, esse estado possui uma transição que leva ao estado RP disparada por o evento sincronizante es1.
O outro estado do autômato é denominado RP e representa a atividade Receber Pedido com uma transição que leva ao estado 0 e é disparada por o evento sincronizante es.
Essa transição representa o elemento fork que possui duas atividades paralelas que originam os autômatos A e A.
O autômato A possui cinco estados sendo um denominado 0 representa a espera por a execução da atividade Preencher Pedido, esse estado possui uma transição que leva ao estado Pp e é disparada por o evento sincronizante es2.
Esse estado possui duas transições disparadas por os eventos locais el1 e el2 repectivamente, que levam ao estado Entrega Durante a Noite, denominado EN ou para o estado Entrega Regular, denominado Er.
O estado EN possui uma transição disparada por o evento local el3 que leva ao estado J e o estado Er tambem possui uma transição disparada por o evento local el4 que leva ao estado J. O Estado J representa o elemento join e possui uma transição disparada por o evento sincronizante es3 que leva ao estado 0.
A condição de guarda existente nesse diagrama é tratada com o uso do autômato A~ que possui dois estados definidos como T que possui uma transição disparada por o evento el5 que leva a estado F que por sua vez possui uma transição disparada por o evento el6 e que leva ao estado T. Para a validação da condição de guarda, foi atribuída uma taxa funcional aos eventos el1 e el2 ambas no autômato A.
A taxa funcional do evento el1 determina que a transição do estado Pp para o estado EN só poderá ocorrer quando o autômato A se encontrar no estado T, já a taxa funcional do evento el2 determina que a transição do estado Pp para o estado Er só poderá ocorrer quando o autômato A se encontrar no estado F. O autômato A modela a segunda tarefa paralela representada por o diagrama de atividades e possui os estados 0 representa a espera por a execução da atividade Emitir Fatura, esse estado possui uma transição que leva ao estado ENF e é disparada por o evento sincronizante es2.
O estado ENF representa a atividade Emitir Fatura o qual possui uma transição disparada por o evento local el7 que leva ao estado RPT que representa a atividade Recebe Pagamento e que possui uma transição disparada por o evento local el8 que leva ao estado J que representa o elemento join, assim como no autômato A e que possui uma transição disparada por o evento es3 e leva ao estado 0.
Em esta seção apresentamos uma descrição do processo de geração de casos de teste, baseado em modelos Markovianos, e o algoritmo desenvolvido com base na descrição feita por Copstein para a geração dos mesmos.
O algoritmo aqui proposto tem por finalidade gerar casos de teste a partir de um modelo SAN.
Segundo Pezzé e Young nos testes tem por objetivo detectar o maior número possível de erros, e para se alcançar tal objetivo, deve- se executar o programa de maneira a forçar certos limites para que os erros possam ser encontrados.
Em alguns programas, o número de caminhos possíveis a serem executados aumenta de maneira a tornar o teste inviavel e exaustivo.
Assim, é necessario definir os casos de teste de maneira que os caminhos possíveis possam ser testados.
A geração de casos de teste aqui apresentada baseia- se nos trabalhos de Copstein, Bertolini e Barros, e tem como objetivo identificar as probabilidades dos estados atingíveis do modelo, ou seja, a partir de um estado denominado inicial pode se calcular a probabilidade de se chegar a outro estado, definindo- se assim um passo, ou trajeto, com relação a o funcionamento do sistema.
Segundo Bertolini e Barros, uma trajetoria é composta por uma quantidade finita e conhecida de passos, e cada passo possui uma probabilidade de ocorrência.
Essa probabilidade é a ocorrência de uma transição do i-ésimo estado para o i-ésimo+ 1 é dada por:
De acordo com a formula acima, é a probabilidade do i-esimo estado da solução estacionariá (ou transiente) de um modelo, e k i significa a possibilidade de ir para todos os k -- esimos estados sucessores do i-esimo estado.
A probabilidade de um caso de teste é o produtorio de todas as probabilidades dos passos i do caso de teste, o qual compreende uma trajetoria T. Assim, a probabilidade de um caso de teste Pt é dada por:
Casos de teste (ou trajetorias) são basicamente representados por uma sequência de estado-transição- estado (passo), partindo do estado inicial de um passo é possível encontrar seus estados finais atraves da execução dos eventos, dito isto, conclui- se que casos de teste são caminhadas aleatorias, atraves dos estados atingíveis do modelo.
Cada vez que um estado ou arco é percorrido, um caso de teste é executado.
Assim num modelo estocástico, os estados atingíveis são considerados casos de teste executados com sucesso.
A geração de casos de teste é um processo que tem como finalidade percorrer caminhos possíveis até chegar a um estado final, partindo de um estado inicial.
Esse percurso é traçado de forma aleatoria, pois existem estados que podem possuir mais de uma transição para chegar a outro estado, e entre essas transições, uma de elas deverá ser sorteada.
Um caso de teste é concluído quando ocorrer uma transição para um estado final.
Antes de iniciar a geração de casos de teste, é feita uma procura por estados iniciais em todos os autômatos da rede.
Os autômatos que não possuírem estados iniciais terão todos os seus estados como possíveis estados iniciais.
Apos essa etapa, é escolhido um estado global do modelo SAN, a ser denominado estado inicial da rede.
Esse estado global será selecionado aleatoriamente dentro de um grupo de estados globais, que são formados por estados iniciais e por possíveis estados iniciais dos autômatos.
A partir de o estado inicial da rede, é iniciado o processo de geração de casos de teste, em que o primeiro step (passagem de um estado da rede a outro) de cada caso de teste ocorre em função de um evento start no estado inicial da rede.
O evento do tipo start é um evento criado para setar o primeiro step da rede.
Os steps seguintes são realizados a partir de a escolha de eventos candidatos com base no atual estado da rede.
E escolhido um evento candidato para que ocorra a mudança para outro estado global.
Os passos são realizados até ocorrer o evento do tipo quit, criado para finalizar o caso de teste.
Com base na descrição feita na subseção anterior, é apresentado aqui o Algoritmo 5.1 desenvolvido para a geração de casos de teste.
O algoritmo foi desenvolvido com base no trabalho de Copstein:
Algoritmo 5.1 Algoritmo para a geração de casos de teste de software Inserir ESTADOFINAL (QUIT).
Enumere o ESTADOGLOBAL da SAN.
Escolha aleatoria do ESTADOINICIAL (START).
Adicione o ESTADOINICIAL para Casoteste.
Enumere o evento Candidato (QT) a sair.
Calcular a probabilidade relativa do Candidato.
Selecione Candidato (QT) a sair (usando probabilidade computacional).
Adicione o Evento selecionado ao Casoteste.
Compute o proximo estado do autômato correspondente.
Atualize o estado global com o estado do autômato local.
Encontre o autômato afetado por o evento.
Compute o proximo estado de cada autômato afetado por o evento.
Atualize o estado global com o estado do autômato afetado.
Adicione o Estado Global atualizado para o Casoteste.
Adicione o Casoteste para a lista de Casoteste.
Imprime Casoteste.
Inicialmente há a inserção do estado final onde é definido o primeiro estado do modelo SAN para dar início a geração dos casos de teste.
Logo apos é feita a comparação entre os casos de teste gerado e o estado final criando- se um loop.
Posteriormente o estado global do modelo é enumerado e o estado inicial é escolhido de maneira aleatoria para geração do caso de teste.
E criado um loop que compara se o estado inicial sele cionado é diferente do estado final, caso não seja são definido os estados possíveis para a transição a partir de o estado inicial e é calculada a probabilidade de cada uma das transições e essa probabilidade é adiciona ao caso de teste.
Caso o evento que dispara a transição seja um evento local é feita mudança de estado no autômato e o estado global do modelo é alterado.
Caso contrario, é feita a busca por os autômatos do modelo que são alterados e o estado global do modelo é atualizado e o caso de teste é adicionado a lista de casos de teste gerados.
Para finalizar é criado um contador para armazenar os casos de teste gerados que posteriormente serão impressos.
Em esta seção apresentamos os resultados obtidos com a aplicação do algoritmo apresentado anteriormente e com o uso da ferramenta PEPS.
Segundo Whittaker na aplicação da sequência de testes pode ser automatica ou~ manual dependendo do ambiente de testes e do suporte dado a automação dos testes, assim para o modelo SAN gerada (Figura 5.2), inicialmente apresentamos na Tabela 5.2 as probabilidade do modelo se encontrar num dos estados atingíveis, essas probabilidades para a geração dos casos de teste a soma dos valores apresentado na Tabela 5.2 é igual a 1.
Cabe ressaltar que os resultados obtidos são baixos devido a os valores atribuídos as taxas de ocorrência dos eventos que foram todos definidos com valor 1, pois o objetivo desse trabalho é apenas demonstrar a conversão de diagramas de atividades da UML para SAN e a posterior geração de casos de teste é viavel.
A Tabela 5.1 demonstra a equivalência entre a nomenclatura utilizada por a ferramenta PEPS e a atribuída ao modelo gerado.
Os elementos apresentados na tabela variam de acordo com o modelo a ser descrito.
A nomeclatura usada para os estados atingíveis obtidos com a função de atingibilidade e descrita a seguir seguem a definição feita na Tabela 5.1: Em essa combinação de estados, ambas atividades paralelas foram executadas, o que habilita o disparo da transição que leva ao elemento estado final.
Para a geração dos casos de teste, utiliza- se os dados apresentados na coluna estado global da Tabela 5.2 de modo que partindo- se do primeiro estado atingível do modelo, que na geração do caso de teste, é denominado como start (st) e atingindo- se o estado final denominado como quit (qt), obtem um caso de teste.
Se existirem mais que dois estados atingíveis, os estados entre o estado inicial st e o estado final qt serão denominados s que representam os passos percorridos entre o estado inicial e final, assim para o modelo gerado um dos casos de teste seria st qt aos demais seriam acrescidos os estados até se atingir todos os estados globais do modelo gerado.
Com base nos estados atingíveis do modelo gerado obteremos as seguintes probabilidades de ocorrência para os casos de teste:
Como forma de demonstrar, de maneira detalhada, a aplicação do metodo proposto neste trabalho será apresentado nesta seção o segundo exemplo de conversão de diagramas de atividades para SAN.
Com o objetivo de aplicar o metodo proposto nesta pesquisa, neste capítulo é apresentado um estudo de caso.
Apresentamos aqui os detalhes do sistema de estudo proposto, bem como a modelagem e a transcrição dos diagramas gerados para uma estrutura equivalente em SAN.
O exemplo utilizado neste trabalho foi proposto por, assim como o diagrama de atividades apresentado na Figura 5.1, foi desenvolvido por o professor Duncan Dubugras Alcoba Ruiz na disciplina IPN (Inteligência de Processos de Negocios), ofertada por o PPGCC/ FACIN (Programa de Pos--Graduação´ em Ciencia da Computação da Faculdade de Informatica da PUCRS).
Um grupo de estudantes quer formar uma agência que organiza festas.
O cliente indica a quantidade de dinheiro que quer gastar, o número de pessoas que a festa vai receber e a area onde a festa vai ser oferecida.
Com estas informações, a agência procura por uma localização adequada e cuida do resto.
A localização pode ser num lugar fechado ou aberto.
Se a localização é num lugar fechado, um salão deve ser alugado.
Caso a localização seja num local aberto, uma tenda e um terreno devem ser arrumados, e provavelmente deve permitir que se possa fazer barulho (música).
Há dois tipos de música:
Ao vivo ou som mecanico.
A escolha é feita por a agencia.
A música ao vivo é preferida, mas é cara, então a maioria das festas é feita com som mecanico.
O som mecanico tambem é escolhido se não se tem tempo para se contratar uma banda.
Se som mecanico é escolhido, um sistema de som deve ser arrumado.
No caso de música ao vivo, porem as coisas são mais complicadas.
Primeiro, uma banda é selecionada.
Entaó é enviada para esta banda uma carta convidando para tocar na festa.
Se a banda não retorna a mensagem dentro de uma semana, uma nova banda é selecionada e o procedimento é repetido.
Se existe retorno, novamente existem duas possibilidades:
Eles estão interessados ou eles não estao.
Em o ultimo caso uma nova banda é selecionada e o processo é repetido.
Em o primeiro caso, porem, a banda não é contratada imediatamente.
Primeiro a agência precisa ver e ouvir a banda para ver se eles são bons o suficiente.
Porque os estudantes contratam apenas os melhores, cerca de 30% das bandas são consideradas boas o suficiente, para os outros 70%, uma nova banda é selecionada, etc..
Se os estudantes não conseguem rapidamente uma banda, eles optam por o som mecanico.
É claro que as bandas que já foram selecionadas alguma vez não precisam ser novamente avaliadas, elas são contratadas imediatamente.
Apos cuidarem da localização e da música, eles então cuidam da comida e da bebida.
No caso de uma banda, eles compram comida e bebida extra para os músicos.
Para ter certeza que tudo está certo, os estudantes supervisionam a festa quando ela esta começando.
Apos isto, a conta é enviada para o cliente.
O diagrama de atividades construído por o professor Dr Duncan Ruiz, com base na descrição acima, é apresentado na Figura 5.1: O modelo SAN obtido é apresentado na Figura 5.4, o elemento estado inicial e final do diagrama de atividades é convertido para os estados I e F do autômato Aut1.
Para esse autômato foram definidas duas transições disparadas por os eventos sincronizantes denominados es1 e es5.
O autômato Aut2 possui dois estados, um denominado 0, que representa a não execução de nenhuma atividade, que possui uma transição disparada por o evento sincronizante es1 e que leva ao estado RS, que representa a atividade registra solicitação e possui uma transição que leva ao estado 0 e é disparada por o evento sincronizante es2.
O autômato Aut3 possui estados 0, que representa a não execução de nenhuma atividade, que possui uma transição disparada por o evento sincronizante es2 e que leva ao estado V L, que representa o elemento atividade verifica localização, que possui duas transições, uma disparada por o evento local el1, que leva ao estado As, resultante do elemento aluga salão e a outra disparada por o evento sincronizante es3, que leva ao estado 0.
Alem desses estados, existe ainda o estado J, que representa o elemento join e possui uma transição disparada por o evento es5, que leva ao estado 0.
A os eventos es3 e el1, foram associadas taxas funcionais que condicionam o disparo de cada uma das transições ao estado do autômato, denominado cond-terreno, que por sua vez possui dois estados nomeados com T e F. Tal associação tem por base o passo 4 proposto para o tratamento de condições de guarda existentes no diagrama modelado.
Todos os autômatos citados ao longo de esta subseção e usados para atender as condições de guarda existentes no diagrama modelado possuem a mesma estrutura.
Essa estrutura é composta de dois estados nomeados como T e F, ambos com uma transição disparadas por eventos locais.
O autômato Aut4 possui o estado 0 que representa a não execução de nenhuma atividade, que possui uma transição disparada por o evento sincronizante es1 e que leva ao estado V M, o qual representa o elemento atividade verifica musica.
Esse estado possui duas transições, uma disparada por o evento el5, que leva ao estado CB, que representa elemento atividade convida banda e outra disparada por os eventos el6 e el7.
A esses eventos tambem foram associadas taxas funcionais, que condicionam o disparo das mesmas ao estado dos autômatos cond -- musica e cond -- tempo, como forma de garantir o atendimento da condição de guarda existente.
O estado CB possui duas transições, disparadas por os eventos locais el15 e el8 que levam ao estado Cs que representa o elemento atividade contrata aparelho de som e ao estado Br, que representa o elemento atividade banda responde e que possui tres transições disparadas por os eventos locais el9 que leva ao estado CB, el10 que leva ao estado AB que representa o elemento atividade avalia banda e el11 e a ultima que leva ao estado CTB que representa a atividade contrata banda.
Os eventos el9, el10 e el11 possuem taxas funcionais a fim de que se possa garantir o tratamento das condições de guarda.
As taxas funcionais desses eventos estão relacionadas ao estado dos autômatos cond -- resposta e cond -- aval -- banda.
O estado AB possui duas transições disparadas por os eventos locais el13, que leva ao estado CB e el14 que leva ao estado CTB que representa o elemento atividade contrata banda.
Os eventos citados tambem possuem taxas funcionais que condicionam o seu disparo ao autômato cond-aval- banda.
Para finalizar, o autômato Aut4 possui um estado denominado J que possui uma transição disparada por o evento sincronizante es4 que leva ao estado 0.
O Aut5 possui tres estados, o estado 0 representa a não execução de nenhuma atividade, que possui uma transição disparada por o evento sincronizante es3 e que leva ao estado ATD, que representa o elemento atividade aluga tenda, que possui uma transição disparada por o evento local el25 que leva ao estado J resultante do elemento join e que possui uma transição disparada por o evento sincronizante es4 que leva ao estado 0.
O Aut6 possui cinco estados, o estado 0 representa a não execução de nenhuma atividade, que possui uma transição disparada por o evento sincronizante es3 e que leva ao estado ATR que representa o elemento atividade aluga terreno, que possui uma transição disparada por o evento local el 26 que leva ao estado V P que representa o elemento atividade verifica permissão e que possui duas transições disparadas por os eventos locais el 27, que leva ao estado OP, que representa o elemento atividade obtem permissão e el28 que leva ao estado J. Esses eventos tambem possuem taxas funcionais que condicionam o disparo das transições ao estado do autômato cond-permissão.
O estado OP possui uma transição disparada por o evento local el29, que leva ao estado J, que por sua vez, possui uma transição disparada por o evento sincronizante es4 que leva ao estado 0.
O Aut7 possui cinco estados 0 que representa a não execução de nenhuma atividade, que possui uma transição disparada por o evento sincronizante es4 e que leva ao estado AC, que representa o 88 Capítulo 5.
Elemento atividade adquiri comida e bebida, que possui uma transição disparada por o evento local el, que leva ao estado V FI que representa o elemento atividade verificafestanoinicio e que possui uma transição disparada por o evento local el33, que leva ao estado PNS, que representa o elemento atividade prepara nota de serviço.
Esse estado, por sua vez, possui uma transição disparada por o evento local el34, que leva ao estado J, que possui uma transição disparada por o evento sincronizante es5, que eleva ao estado 0.
O modelo apresentado na Figura 5.4, possui 39754 estados atingíveis, definidos com base na função de atingibilidade e representam a execução de um conjunto de atividades ou de apenas uma atividade de acordo com a parte do diagrama de atividades que foi modelado.
Um estado atingível pode representar alem das atividades, a avaliação de uma determinada condição de guarda ou um elemento join do diagrama.
A Tabela 5.8 demonstra a equivalência entre a nomenclatura utilizada por a ferramenta PEPS e a atribuída ao modelo gerado.
Os elementos apresentados na tabela variam de acordo com o modelo a ser descrito.
Como exemplo desses estados atingíveis, a partir de uma escolha aleatoria, cita- se os seguintes:
Esse estado é atingível pois representa a execução da atividade recebe solicitação que é a primeira atividade do diagrama, a atividade verifica localização para a qual uma condição de guarda é avaliada e que por o autômato cond -- terreno ser falsa, isto e, estar no estado F o evento es3 é disparado.
Essa combinação de estados indica que a atividade aluga tenda está sendo executada e tambem a atividade obtem permissão uma vez que o autômato cond-permissão está no estado F o que habilita o disparo do evento el27.
Os autômatos, cond- musica, cond-tempo, cond resposta, cond-aval- banda e por serem autômatos que possuem apenas eventos locais podem se encontrar em qualquer de seus dois estados possíveis, ou seja, T ou F uma vez que para execução dessas atividades os mesmo não são avaliados.
Com relação a o exemplo dois, apresentado nessa dissertação, obteve- se uma grande quanti dade de estados atingíveis, conforme citado anteriormente.
Assim, as probabilidades desses estados, bem como os casos de teste gerados não serão apresentados neste capítulo.
Os exemplos aqui demonstrados não tem por objetivo esgotar as possibilidades de aplicação do metodo proposto, mas sim elucidar a maior quantidade de dúvidas que possam existir a respeito de o mesmo.
A area de Engenharia de software, ao longo de os anos, tem buscado disciplinar o processo de desenvolvimento de software atraves do uso das mais diferentes tecnicas de gerenciamento de projeto, mas uma das etapas do desenvolvimento que mais consome tempo e recursos é a de teste de software.
Assim, com o intuito de melhorar os processos de teste de software e baratear os custos de execução dos mesmos, busca- se aplicar tecnicas de avaliação de desempenho de sistemas no referido processo.
Este trabalho teve por objetivo apresentar um metodo de conversão de diagramas de atividades da UML para SAN e a geração de casos de teste de software.
Para tal, foram apresentados os principais conceitos sobre UML, dando- se enfase ao diagrama de atividades.
Descreveram- se tambem as principais tecnicas de teste de software, tais como teste estrutural e teste funcional.
Abordaram- se aqui os conceitos sobre o formalismo SAN (Stochastic Automata Networks), buscando demonstrar as principais características do mesmo.
O metodo apresentado baseou- se nos trabalhos aqui relacionados e descritos, que contribuiram para a construção da proposta.
De entre os trabalhos relacionados destaca- se o trabalho desenvolvido por Barros, em virtude de a semelhança com o metodo apresentado neste trabalho.
Cabe ressaltar, que as pesquisas desenvolvidas para a elaboração desta dissertação demonstraram em sua maioria metodos de conversão de diagrama de atividades para redes de Petri, de entre eles, o que faz com que o metodo aqui apresentado seja unico.
Como forma de demonstrar a aplicação do metodo, foram apresentados neste trabalho dois exemplos de conversão de diagramas de atividades UML para SAN.
Foram apresentados tambem os casos de teste gerados para os dois exemplos.
A seguir, são apresentadas as conclusões e considerações feitas a partir de o desenvolvimento desse trabalho.
Para finalizar, são propostos trabalhos futuros que podem ser desenvolvidos a partir deste estudo.
Uma das principais limitações do metodo de conversão desenvolvido nessa dissertação é a baixa probabilidade de execução dos casos de teste gerados, que pode ocorrer em alguns casos.
Acredita- se que a integração do diagrama de atividades com outros diagramas da UML (Unified Modeling Language) possa proporcionar melhores resultados.
Outra limitação do metodo é a forma de tratamento das condições de guarda, que deve ser feita com a criação de um autômato para cada condição de guarda existente no diagrama a ser convertido.
Uma vez que o estado global de uma SAN é definido como a combinação de todos os estados locais de cada autômato componente da SAN, com isso cada autômato criado para tratar essa característica do elemento decisão impacta no total de estados do modelo.
A partir de esta dissertação, surgem alguns trabalhos futuros no sentido de complementar e dar continuidade ao trabalho realizado, de entre eles, relatamos alguns.
Um dos principais trabalhos futuros é a melhoria no metodo que proporcione a redução no estado global dos modelos SAN gerados, uma vez que os exemplos apresentados aqui, com base em diagramas com poucas atividades apresentaram um espaço de estados relativamente grande nos modelos gerados, especialmente em se tratando do exemplo dois.
Acredita- se que a conversão de um número maior de diagramas, gerará um modelo, cujo espaço Como trabalho futuro, espera- se encontrar outras formas de tratar as condições de guarda, visando obter modelos SAN com um tamanho menor, o que possibilitaria analisar sistemas mais complexos.
Outro estudo futuro é o desenvolvimento de um software, com base nos algoritmos aqui apresentados, visando automatizar o metodo de conversão e a geração dos casos de teste.
Tal proposta se fundamenta no fato de que a ferramenta STAGE, desenvolvida por os CTPS (Centro de Pesquisa e Teste de Software), é restrita aos membros do referido projeto.
Tambem como estudo futuro, propoe- se a adaptação do metodo à UML 2.
0, pois o mesmo foi desenvolvido para o padrão UML 1.
5. O poder de modelagem proporcionada por a UML 2.
0 exige alterações no metodo desenvolvido, pois se espera que tal adaptação propicie outras formas de aplicação do referido metodo.
