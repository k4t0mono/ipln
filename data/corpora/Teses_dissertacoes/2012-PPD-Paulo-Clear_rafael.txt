Atualmente, existe uma crescente demanda por se disponibilizar, através da Internet, software na forma de serviços.
Este novo modelo de negócio é denominado de &quot;Software como Serviço», aonde aplicações não são mais vendidas como um produto, mas sim cedidas na forma de um serviço e utilizados por clientes, que pagam apenas de acordo com a utilização.
Entretanto, soluções que não foram desenvolvidas com o foco em integração, não conseguem entrar facilmente nesta nova tendência.
PEPS (Performance Evaluation of Parallel Systems) e PLAT (Production Line Analysis Tool) são exemplos de ferramentas que se enquadram nesta situação.
Apesar de serem soluções eficientes e confiáveis para a solução de, respectivamente, modelos de Redes de Autômatos Estocásticos e modelos teóricos de linhas de produção seriais, nenhuma das duas possui mecanismos de integração.
Em este sentido, este trabalho propõe:
Primeiro, a especificação de um framework genérico e reutilizável para a disponibilização de ferramentas na forma de serviços;
Segundo, as implementações deste framework para a disponibilização dos software PEPS e PLAT na forma de serviços.
Palavras-chave: Software como Serviço;
Arquitetura Orientada a Serviços;
Computação na Nuvem;
Soluções numéricas;
Redes de Autômatos Estocásticos. Em os dias de hoje, os sistemas operacionais e os aplicativos que usamos estão cada vez mais se fundindo com a Internet.
Muitas vezes temos a impressão de estar utilizando um software instalado localmente, mas, na verdade, estamos acessando um serviço que foi disponibilizado na Web.
Serviços on-line estão cada vez mais inseridos em nosso cotidiano, trazendo com si um novo modelo de negócio.
Este novo negócio é o modelo de distribuição Software como Serviço, aonde aplicações não são mais vendidas como um produto, mas sim cedidas na forma de um serviço por um fornecedor e utilizadas por um cliente consumidor.
Em este modelo, o fornecedor do serviço se responsabiliza por toda a infraestrutura necessária para a disponibilização do sistema e o cliente utiliza o software via Internet, pagando um determinado valor por a utilização.
Entretanto, aplicativos antigos, legados ou que não tenham sido planejados para integração, não conseguem ser inseridos neste modelo facilmente.
Em este contexto, este trabalho propõe um framework para facilitar a disponibilização como serviço desses aplicativos.
O PEPS é um software criado para solucionar numericamente grandes modelos Markovianos, expressos na forma de Redes de Autômatos Estocásticos (Stochastic Automata Networks -- SAN).
E apesar de ser uma ferramenta eficiente e em constante evolução, o PEPS não possui funcionalidades que facilitem a sua integração com outras ferramentas ou sistemas.
Carente do mesmo tipo de funcionalidade, o PLAT é uma ferramenta criada para calcular soluções exatas para linhas de produção confiáveis.
Em este sentido, este trabalho visa apresentar uma solução para estes problemas, oferecendo uma solução para tornar simples e eficiente a criação de mecanismos de integração para ambos PEPS e PLAT, e assim, tornar possível a disponibilização destes software como um serviço.
Apesar de o foco deste trabalho estar centrado nas ferramentas PEPS e PLAT, o framework proposto pode ser facilmente estendido e utilizado na disponibilização como serviço de qualquer ferramenta.
Objetivo Os objetivos deste trabalho são propor um framework para disponibilização de ferramentas não integráveis na forma de serviços.
E apresentar as implementações desta solução para a exposição das ferramentas PEPS e PLAT através do modelo de distribuição software como serviço.
Contribuição A o alcançar os objetos, é esperada uma solução genérica que possa ser reutilizada para a disponibilização de diversas ferramentas que atualmente não possuem funcionalidades de integração, além de fornecer à comunidade científica as ferramentas PEPS e PLAT na forma de serviços.
Organização Esta dissertação está organizada da seguinte forma.
O Capítulo 2 contem uma introdução aos conceitos de Computação na Nuvem, Software como Serviço, Web Services e Arquitetura Orientada a Serviços e ao final apresenta uma descrição dos trabalhos relacionados a este projeto.
A seguir, juntamente com a apresentação das ferramentas de simulação que são alvo do estudo deste trabalho.
Este capítulo apresenta os principais conceitos de Software como Serviço (Software as a Service SaaS).
A Seção 2.1 apresenta a Arquitetura Orientada a Serviços e a Seção 2.2 mostra os conceitos e as especificações da tecnologia Web Services.
Ambas as Seções são pré-requisitos para a Seção 2.3, aonde é introduzido o conceito de computação na nuvem, juntamente com o conceito de Software como Serviço.
Arquitetura Orientada a Serviço Soa (Service-Oriented Architecture) representa uma recente abordagem para a utilização dos recursos de Ti (Tecnologia da Informação) em apoio ao negócio de uma organização.
É um tipo de arquitetura de software que utiliza processos de negócio e distribui funções em forma de serviços.
Apesar de ainda carecer de certa maturidade, Soa apresenta a renovação da forma como a Ti deve ser usada para apoiar a estratégia de uma organização.
Utilizar Soa significa modularizar uma aplicação na forma de diversos serviços interoperáveis.
Em seu nível mais abstrato, uma arquitetura orientada a serviços é composta por três elementos que representam papéis distintos:
O prestador de serviço, o consumidor do serviço e o registro do serviço.
Estes três elementos compõem o modelo operacional triangular.
A Figura 2.1 representa a interação entre os elementos desse modelo.
Cada um dos elementos do modelo triangular se comporta da seguinte forma:·
Provimento do serviço (Provedor):
Determina o comportamento daquele que está disponibilizando o serviço, ou seja, é considerado o dono do serviço;
É o responsável por fornecer toda a infraestrutura de acesso, tipicamente via rede, e é capaz de responder as requisições.·
Consumo do serviço (Consumidor):
Determina o comportamento daquele que representa o cliente da organização provedora do serviço.
Em Soa, um consumidor pode ser representado por uma pessoa, uma organização, uma máquina ou um componente de software.
A identificação do cliente é irrelevante no sentido de que um consumidor representa aquele que localiza um serviço, entende seu protocolo de operação e se utiliza desse protocolo para executar- lo.·
Registro do serviço (Registro):
Determina o comportamento que a organização deve ter para divulgar seu serviço e o do cliente que deve proceder para localizar o serviço desejado.
É responsável por gerenciar os repositórios que armazenam informações sobre os serviços e entidades que os fornecem.
Normalmente, esses registros contêm:
São as denominadas páginas verdes;
­ Informações sobre o serviço, tais como as operações existentes e versões disponíveis.
São as denominadas páginas amarelas;
É da responsabilidade do registro oferecer mecanismos de publicação e busca para que esse possa ser usado, garantindo facilidade de localização e utilização do serviço.
O modelo operacional triangular determina que os provedores de serviços registrem suas informações num repositório central.
Por sua vez, o registro deve ser capaz de aceitar a publicação, mediante um protocolo específico de comunicação e autenticação, organizar semanticamente as informações que irão representar o serviço dentro de o registro e oferecer mecanismos de busca para que esse serviço possa ser descoberto por eventuais clientes/ consumidores.
Normalmente, um registro mantém seu repositório associado a duas interfaces de comunicação:
A de publicação e a de busca.
O conceito de Soa está fortemente ligado com o de Web Services, pois o seu modelo é um ótimo exemplo de Soa, uma vez que possui as características desta arquitetura e é considerada, atualmente, a tecnologia padrão para implementação de uma arquitetura orientada a serviços.
Entretanto, a implementação de um sistema Soa pode ser realizada utilizando qualquer outra tecnologia padronizada para Web, como por exemplo CORBA (Common Object Request Broker Architecture), RMI (Remote Method Invocation), DCOM (Distributed Component Object Model) e REST (Representational State Transfer).
Uma boa comparação para esta situação é mostrar Soa como se fosse um algoritmo.
Ambos não pressupõem o uso de nenhuma tecnologia ou linguagem de programação específica, permitindo a escolha de implementação por parte de o desenvolvedor.
A Seção a seguir irá detalhar a tecnologia Web Services, pois além de ser a implementação mais comum para Soa, também foi a tecnologia utilizada na implementação do framework que será apresentado no Capítulo 4.
Web Services O W3C (World Wide Web Consortium) define Web Services como um sistema de software projetado para suportar a interoperabilidade entre máquinas sobre uma rede.
Deve possuir uma interface descrita num formato compreensível por as máquinas, chamado de WSDL (Web Services Description Language).
As chamadas para Web Services são feitas utilizando- se o descritor WSDL e através de mensagens SOAP (Simple Object Access Protocol), tipicamente transportadas usando Http (Hypertext Transfer Protocol) com a serialização XML (Extensible Markup Language) em conjunto com outros padrões para Web.
O W3C juntamente com o OASIS (Organization especificação de todas estas tecnologias.
Web Service é uma solução utilizada na integração de sistemas e na comunicação entre diferentes aplicações.
Com esta tecnologia é possível que novas aplicações possam interagir com aquelas que já existem e que sistemas desenvolvidos em plataformas diferentes sejam compatíveis.
Existe uma grande motivação sobre a tecnologia Web Service, pois ela possibilita que diferentes aplicações comuniquem entre si e utilizem diferentes recursos.
Por exemplo, um software escrito na linguagem C e rodando numa plataforma UNIX pode fazer chamadas para funções de um outro software construído em Java e rodando numa plataforma Windows.
Basicamente, Web Services são pequenas funcionalidades (funções, procedimentos ou métodos) de uma aplicação que pode ser chamado através de um protocolo de rede, ambos os parâmetros de entrada quanto os valores de retorno são especificados numa estrutura XML.
Os Web Services surgiram da necessidade de padronizar a comunicação entre diferentes plataformas e diferentes linguagens de programação.
Já haviam sido feitas algumas tentativas na criação deste padrão, porém nenhuma obteve êxito considerável.
CORBA, RPC (Remote Procedure Call) e RMI são exemplos destas tentativas não sucedidas.
O fator crucial para o fracasso destas tecnologias em se tornar o padrão de intercomunicação, foi o protocolo de comunicação utilizado.
Enquanto Web Services trafega através de Http, as outras tecnologias procuraram criar seus próprios protocolos de comunicação, a fim de otimizar a transferência de dados.
Esta otimização trouxe como consequência a necessidade de utilização de portas de comunicação específicas.
Esta obrigatoriedade de disponibilização de portas específicas praticamente inviabilizou o uso destas tecnologias num ambiente como a Internet, pois a abertura de portas de comunicação representa uma ameaça à segurança das redes das corporações.
A impossibilidade de troca de mensagens via Internet também impossibilitou a integração de serviços entre distintas organizações.
Web Services foi planejado para contornar este problema, o uso de Http como protocolo de comunicação não necessita que regras de firewall sejam modificadas para permitir a comunicação, assim sendo, não representa uma ameaça à segurança da rede.
Proposto em 1999 através de um consórcio entre empresas, foi desenvolvido o modelo Web Services.
Após uma adoção significativa deste modelo, surgiu a iniciativa UDDI (Universal Description Discovery and Integration).
O UDDI é um diretório universal de descrição de serviços.
Como o próprio nome sugere, tal iniciativa se propõe a listar todos os Web Services disponíveis na Internet.
Em os anos seguintes, muitas linguagens de programação criaram Apis (Application Programming Interface) para o desenvolvimento de Web Service.
Surgiram, então, padrões de desenvolvimento, de qualidade e de segurança, características responsáveis por tornar Web Services uma tecnologia cada vez mais sólida.
Os padrões para Web Services definem os formatos para as mensagens de entrada e saída, e também especificam como a mensagem será enviada.
Estes padrões também descrevem as convenções de mapeamento de conteúdo das mensagens dentro e fora de os programas que implementam o serviço, também definem mecanismos para publicar e descobrir interfaces de Web Services.
Web Services podem ser executados tanto em computadores desktops como em dispositivos portáteis.
Podem ainda ser utilizados para integração business- to business (B2B), conectando aplicações que estão rodando em várias organizações num mesmo aplicativo.
As Seções a seguir apresentam os principais conceitos relacionados à Web Services.
XML representa uma família de especificações relacionadas que são publicadas e mantidas por o W3C.
Pode- se considerar o XML como a base sobre a qual os Web Services estão construídos, pois provê o armazenamento de descrições e determina o formato de transmissão para a troca de todos os dados via Web Services.
Baseada na SGML (Standard Generalized Markup Language), em 1996, oitenta peritos uniram forças ao W3C para definir uma linguagem de marcação com o poder da SGML, mas com maior facilidade de implementação.
O surgimento da linguagem XML transformou o modo como dados são representados e alcançou o patamar de padrão para descrição e transmissão de dados na Internet.
O uso desse modelo se popularizou devido a sua flexibilidade, refino e capacidade de representação estruturada de qualquer informação.
Esta grande flexibilidade implica em alguns problemas, pois permite a definição de estruturas diferentes para representar a mesma informação.
Em uma integração entre sistemas, é difícil assegurar que ambas as partes usarão a mesma estrutura para representar os dados.
A Figura 2.2 representa duas estruturas em XML que representam a mesma informação de um endereço.
XSLT (eXtensible Stylesheet Language for Transformation), XQuery e XPath são algumas das tecnologias utilizadas para fazer a tradução entre diferentes esquemas durante uma integração.
Com estas tecnologias é possível fazer um mapeamento entre os elementos de cada esquema, obtendo assim o dado numa estrutura homogênea.
Documentos XML conseguem difundir um conhecimento específico de forma inteligente, estruturada e eficaz.
Sua aceitação deve- se ao conjunto de ferramentas de suporte existentes atualmente, como banco de dados XML, ferramentas de desenvolvimento, browsers e diversos outros, que suportam e permitem manipular documentos XML de maneira simples e rápida.
As estruturas em XML são compostas por elementos denominados nós (tags).
Elementos podem ser vazios, simples ou complexos (quando o elemento contem outro elemento aninhado).
Sua estrutura pode ser vista como uma hierarquia em formato de árvore e todo documento deve ser iniciado por um único elemento raiz.
Atualmente, o XML é uma tecnologia amplamente adotada, principalmente em grandes sistemas como os ERPs (Enterprise resource planning), onde é necessária a customização da solução para se adaptar ao modelo de negócio de cada empresa.
Podemos considerar, então, que o XML pode ser utilizado numa grande variedade de aplicações, como na formatação, serialização e transformação de dados.
Web Services se comunicam trocando instâncias formatadas em documentos XML.
Assim pode- se afirmar que o principal benefício proporcionado por o XML aos Web Services é a independência das estruturas e dos tipos de dados, deixando livre a intercomunicação entre aplicativos.
A linguagem de descrição de Web Services pode ser vista como uma gramática em XML que tem o objetivo de descrever um Web Service como uma coleção de pontos de acesso.
Ponto de acesso é o termo usado para definir uma URL (Unified Resource Locator) para a qual requisições de serviço são efetuadas.
Deve também definir as interfaces públicas que um Web Service pode expor, incluindo suas funcionalidades e a forma de como invocar- las, além de declarar os parâmetros das operações e a forma de tratamento das exceções.
WSDL foi originalmente criada por a IBM, Microsoft e Ariba, através da união de 3 propostas anteriores:
Microsoft's SOAP Contract Language, Service Description Language e o Network Accessible Service Specification Language.
Atualmente a WSDL está na versão 2.0.
A WSDL estabelece um formato comum para descrever e publicar informações de serviços na Web.
Utiliza elementos que contêm uma descrição de dados, que tipicamente utiliza um ou mais esquemas XML, de modo a tornar as informações compreensíveis de ambos os lados da comunicação.
A especificação WSDL é frequentemente caracterizada por uma parte abstrata e uma parte concreta.
A parte abstrata é composta por uma coleção de operações lógicas.
Cada operação define uma troca de mensagem simples.
Uma mensagem é uma unidade de comunicação, representando os dados trocados numa transmissão.
A parte concreta define protocolos de conexão e os endereços dos serviços.
O UDDI é um padrão para publicação e localização de Web Services por o uso de consultas (queries) baseadas em documentos XML.
É uma iniciativa da indústria no sentido de criar uma arquitetura livre de plataforma capaz de propagar serviços.
A analogia normalmente feita é com uma lista telefônica, onde as páginas brancas possuem uma lista de organizações, informações de contato e de serviços que estas organizações proporcionam.
Em as páginas amarelas, há uma classificação dos serviços e das empresas de acordo com o tipo de serviço que oferecem.
Já as páginas verdes descrevem como os serviços devem ser invocados.
Esta organização normalmente é muito flexível e permite a fácil consulta de Web Services, bem como possibilita um fácil comparativo entre serviços similares oferecidos por uma mesma empresa.
O objetivo inicial do UDDI era a criação de um diretório mundial de descrição de serviços gratuitos, onde qualquer pessoa ou empresa poderiam publicar os seus serviços ou pesquisar por serviços já implementados.
Porém este objetivo não obteve sucesso, e com o tempo uma nova abordagem foi introduzida.
Hoje em dia UDDI está mais direcionado para implementação em ambientes privados, tipicamente empresariais, aonde uma corporação publica os serviços disponíveis para serem consumidos por demais aplicações.
UDDI pode ser visto como um motor de busca para serviços, é possível navegar por os registros em busca de um serviço que melhor atenda às necessidades do cliente consumidor.
Http é um protocolo de transferência amplamente utilizado na Internet.
Basicamente, ele especifica as mensagens que os clientes podem enviar aos servidores e quais as respostas que eles receberão.
Por usar TCP (Transmission Control Protocol), o controle das mensagens (confirmações de entrega, reenvio de mensagens) é garantido, deixando o Http livre para tratar melhor de outros assuntos.
Ainda podemos acrescentar que a partir de a versão 1.1, foi adicionada a função de conexões persistentes, que permite que mensagens adicionais sejam trocadas através de uma mesma conexão a TCP.
Este tipo de conexão diminui o overhead das conexões.
Em Web Services, Http é o protocolo mais utilizado.
Ele é o grande facilitador que permite que os Web Services se comuniquem de forma transparente através de firewalls.
É importante deixar claro que o uso do Http não é obrigatório quando falamos de Web Services, pode- se ainda utilizar SMTP (Simple Mail Transfer Protocol), Beep (Block Extensible Exchange Protocol) entre outros.
Serve para uso com um proxy que possa se tornar um túnel Consulta certas opções O protocolo SOAP é uma especificação do W3C para troca de informação estruturada em ambientes descentralizados e distribuídos.
Usa o XML como linguagem de criação das mensagens e o protocolo Http como infraestrutura de transmissão.
Além disso, o protocolo SOAP é visto como o padrão internacional de interoperabilidade entre aplicações.
Em uma mensagem SOAP, o elemento Envelope é obrigatório, pois define a raiz da estrutura XML da mensagem.
A Figura 2.3 apresenta a estrutura de uma mensagem SOAP.
Elemento Header O elemento Header é opcional e quando existe, deve conter informações específicas sobre a mensagem SOAP.
Normalmente, é nessa seção que são enviadas informações sobre o contexto da execução de um serviço.
Por exemplo, se a execução do serviço necessita de pagamento, no header podem ser enviados os dados bancários do cliente para autorizar o débito.
Outro cenário comum é enviar informações de segurança, como tokens de autenticação.
Elemento Body O elemento Body é obrigatório e é ele que contem a informação que está sendo enviada ao Web Service.
O Body pode conter um ou mais blocos de mensagens, também denominados de Partes (Parts).
Dentro de as Partes é que estão efetivamente os valores que são enviados ao serviço.
Elemento Fault Erros e exceções de negócio podem ocorrer durante a execução do serviço, em Web Services os erros são retornados ao cliente através de Falhas SOAP (SOAP Faults).
O elemento opcional Fault serve para indicar códigos e mensagens de erro provenientes da execução do serviço.
Computação na Nuvem A computação na nuvem (Cloud Computing) surgiu recentemente como um novo paradigma para hospedagem e prestação de serviços através da Internet.
A computação em nuvem é atraente para os donos de negócios pois elimina a necessidade de planejar antecipadamente a infraestrutura necessária para suportar as soluções, e permite que as empresas iniciem com uma operação pequena e que possam crescer de acordo com o aumento na demanda de serviços.
No entanto, apesar de o fato de computação em nuvem oferecer grandes oportunidades para a indústria de Ti, o desenvolvimento da tecnologia está recem iniciando, com muitas questões e desafios em aberto para serem abordados A ideia principal por trás da computação na nuvem não é nova.
John McCarthy na década de 1960 já previa que as instalações de computação seriam fornecidas ao público em geral como um utilitário (computing as a utility).
O termo &quot;nuvem «também não é novo, nos anos de 1990 foi utilizado para descrever grandes redes ATM (Asynchronous Transfer Mode).
No entanto, foi depois que o CEO do Google, Eric Schmidt, usou a palavra para descrever o modelo de negócio de prestação de serviços através da Internet em 2006, que o termo realmente começou a ganhar popularidade.
Desde então, o termo &quot;computação na nuvem «tem sido usado principalmente como um termo de marketing numa variedade de contextos para representar muitas ideias diferentes.
A falta de uma definição formal juntamente com um grande apelo publicitário, gerou confusão e desconfiança com relação a a usabilidade e aplicabilidade de computação na nuvem.
Visando obter um consenso, em foram comparados mais de 20 definições diferentes a partir de uma variedade de fontes para chegar numa definição padrão.
Em este trabalho, adotamos a definição fornecida Definição NIST:
&quot;Computação na nuvem é um modelo conveniente para permitir o acesso sob demanda à uma rede de recursos compartilhados (por exemplo redes, servidores, armazenamento, aplicativos e serviços) que podem ser rapidamente fornecidos e liberados com o esforço mínimo de gerenciamento ou pouca interação com o prestador de serviços.»
Ou seja, computação na nuvem é um termo genérico para qualquer funcionalidade que envolva a entrega de serviços hospedados na Internet.
Alguns benefícios da utilização de computação na nuvem são:·
É pago de forma incremental, economizando dinheiro às organizações;·
As organizações podem armazenar mais dados do que no ambiente computacional privado;·
Equipe de Ti não precisa consumir tempo em manter os sistemas atualizados;·
Oferece muito mais flexibilidade do que métodos tradicionais;·
A informação fica disponível a partir de qualquer lugar;·
Separação do serviço de negócio da infraestrutura necessária para executar- lo;·
Flexibilidade para escolher vários fornecedores que prestam serviços confiáveis e escaláveis, ambientes de desenvolvimento e infraestrutura, com o custo medido conforme a utilização;·
Natureza elástica da infraestrutura para rapidamente alocar e de-alocar recursos, tornando a solução altamente escalável com base na demanda;·
Redução de custos devido a a eficiência operacional e implantação mais rápida de novos serviços.
Computação na nuvem é dividida em três categorias:
Infraestrutura como Serviço (IaaS -- Infrastructure as a Service), Plataforma como Serviço (PaaS -- Platform as a Service) e Software como Serviço (SaaS -- Software as a Service).
O termo &quot;Infraestrutura como Serviço «refere- se a uma combinação de hospedagem, hardware e fornecimento de serviços básicos necessários para executar um serviço na nuvem.
Este modelo ganhou popularidade nos últimos anos devido a a flexibilidade, escalabilidade e confiabilidade que ela oferece às empresas e instituições que não tem os meios ou o interesse de gerenciar suas próprias infraestruturas de rede.
IaaS é a categoria mais simples em computação na nuvem.
Provedores de IaaS entregam o acesso a computadores (máquinas físicas ou, mais frequentemente, máquinas virtuais), sistemas de arquivos, firewalls, balanceadores de carga e redes.
Prestadores de IaaS fornecem estes recursos sob demanda, alocando- os dinamicamente de seus grandes em centros de dados.
Em este modelo, o cliente é responsável por a instalação, correção e manutenção dos sistemas operacionais e softwares aplicativos.
Prestadores de serviços de nuvem tipicamente cobram com base no número de utilização dos recursos, isto é, o custo irá refletir a quantidade de recursos alocados e consumidos.
São exemplos de ofertas de IaaS o Amazon Web Services Elastic Compute Cloud (EC2) e o Secure Storage Service (S3).
Plataforma como Serviço é o conceito de que alguém pode fornecer o infraestrutura (como em IaaS) adicionando- se uma certa quantidade de software no produto entregue, como por exemplo o sistema operacional, sistemas gerenciadores de banco de dados, suporte a linguagens de programação entre outros.
Em PaaS, além de o hardware, são fornecidas todas as bases necessárias para a construção e implantação de aplicações que irão atender a necessidade do negócio.
Isto facilita o desenvolvimento e implantação de aplicações sem o custo e a complexidade de compra e gestão da infraestrutura básica, proporcionando todas as facilidades necessárias para apoiar o ciclo de vida completo de construção e entrega de aplicações web e serviços, totalmente disponível a partir de a Internet.
Normalmente, a infraestrutura utilizada para fornecer PaaS consiste de um ambiente virtualizado e clusterizado de grades (grids) computacionais.
Algumas ofertas de PaaS possuem uma API ou linguagem de programação específica.
Por exemplo, o Google AppEngine é uma solução de PaaS aonde desenvolvedores podem construir aplicações em Python ou em Java.
Software como serviço, também conhecido como software sob demanda (on- demand software), é uma forma de distribuição e comercialização de software.
Em o modelo SaaS o fornecedor do serviço se responsabiliza por toda a infraestrutura necessária para a disponibilização do sistema e o cliente utiliza o software via Internet, pagando um determinado valor por a utilização.
A forma de cobrança pode variar entre o pagamento recorrente de um favor fixo, ou de acordo com a intensidade do uso.
Este modelo se caracteriza por retirar o processamento da custódia do cliente e disponibilizar- lo através da Internet (ou outra infraestrutura de rede) na forma de um serviço de fácil acesso e que possa ser consumido por diversos clientes.
Esta transferência só foi possível devido a o grande avanço da Internet e da larga adoção de Soa.
Comparando com o modelo tradicional de distribuição de software (em o qual o cliente adquire a licença de uso e se responsabiliza por a instalação e manutenção em produção) podemos destacar as seguintes vantagens do modelo SaaS para os clientes:·
Não exige que o cliente crie uma estrutura e capacite os profissionais para manter o sistema funcionando, permitindo que ela se foque no seu negócio;·
Permite uma abordagem gradual de implantação, podendo começar com poucas licenças e expandir conforme tiver um retorno positivo do seu investimentos, reduzindo os riscos e o tempo para o retorno do investimento;·
Permite aumentar ou reduzir as licenças ao longo de o tempo, de acordo com as necessidades do negócio;·
Redução de custos do quadro funcional das equipes de Ti;·
Redução dos custos de Hardware e gastos com energia elétrica, pois o provedor do serviço é responsável por a manutenção dos servidores.
Uma pesquisa realizada por o instituto AMR Research, indicou que o mercado de SaaS cresce 20% a cada ano, enquanto que o modelo tradicional cresce menos do que 10%.
Um questionário realizado por a consultoria ThinkStrategies mostrou que um terço dos 118 entrevistados já estava usando SaaS, e outro terço já estava avaliando a possibilidade e utilização para os próximos 12 meses.
Trabalhos Relacionados Com o objetivo de entender e levantar o estado da arte no quesito frameworks para exposição de ferramentas como serviço, foram analisadas diversas iniciativas de pesquisa, direta e indiretamente relacionadas com este trabalho.
Existem diversas pesquisas na área de Software como serviço na exposição de ferramentas, algumas focadas na interação entre o usuário e o sistema, outras focadas no ponto de vista do fornecedor de SaaS e outras focadas no modelo de implementação.
Entretanto, nenhuma possui o objetivo deste trabalho, criar um framework reutilizável para a exposição de ferramentas de simulação analítica.·
Em os autores propõem um framework em Soa para modelar serviços colaborativos.
Primeiramente é definido um modelo genérico, aonde a arquitetura de um serviço de colaboração pode ser dividida em quatro componentes:
A lógica do serviço, dados do serviço, conteúdo do serviço e o perfil do serviço.
Este modelo é então mapeado para uma arquitetura orientada a serviços.
A o final, o framework é elaborado baseado nos resultados obtidos a partir de o mapeamento.
Como contribuição do trabalho, o framework resultante oferece aos desenvolvedores de serviços colaborativos uma camada de colaboração, aonde são fornecidos serviços para acesso simultâneo de recursos (locking), controle de apresentação, gestão de presença do usuário, gerenciamento organizacional e controle de comunicação.·
Em é proposto o framework CloudSim que visa oferecer os recursos necessários para a simulação de ambientes computacionais em nuvem.
É extensível, facilmente adaptável e permite a criação de simulações em grande escala com alto grau de customização.
Através do CloudSim pesquisadores e desenvolvedores podem testar o desempenho dos serviços da aplicação em desenvolvimento num ambiente controlado e de fácil configuração.
Com base nos resultados da avaliação do CloudSim, é possível modificar e configurar os serviços para otimizar o desempenho.
As principais vantagens da utilização CloudSim para teste de desempenho inicial incluem:
Eficácia tempo:
Exige pouco esforço e tempo para implementação de um ambiente de testes em nuvem para as aplicações e flexibilidade e aplicabilidade:·
Em os autores apresentam um modelo de interação baseado num autômato finito para migrar sistemas legados em Web Services.
É utilizada uma técnica de encapsulamento (wrapping) de caixa preta, ou seja, o sistema legado não é modificado e uma nova camada entre o usuário e o sistema é introduzida para mapear os valores de entrada e saída.
O wrapper tem a responsabilidade de interagir com o sistema legado durante a execução de cada possível de interação, efetuar a troca de dados e comandos entre o sistema e o usuário até que a resposta final seja obtida.
O autômato finito é definido como:
AF $= (S, T, da interação.
Esta abordagem de encapsulamento com caixa preta é a mesma adotada na solução proposta por este trabalho que será detalhada no Capítulo 4.·
Em é proposto o modelo CloudMIG para migrar sistemas legados para ambientes na nuvem.
É apresentada uma abordagem semiautomática para auxiliar na reengenharia de sistemas.
O processo é composto por seis atividades.
Extração: Aonde é feito um levantamento manual da atual arquitetura do sistema a ser migrado.
Também são obtidos dados estatísticos do comportamento da solução.
Seleção: Com base nos resultados obtidos na atividade de extração, é necessário selecionar manualmente as características do ambiente na nuvem de destino, como por exemplo, a quantidade de instâncias de máquinas virtuais, a quantidade de threads de trabalho por instância, etc..
Geração: Em esta atividade são produzidos três artefatos, a arquitetura destino, o modelo de mapeamento e uma listagem das características do sistema legado que não estão conforme a com arquitetura de destino na nuvem.
Esta listagem contem as partes da aplicação que deverão ser reconstruídas manualmente por a reengenharia.
Adaptação: A quarta atividade é utilizada para ajustar manualmente requisitos específicos que não puderam ser cobertos por a fase de geração.
Avaliação: Com o objetivo de avaliar a arquitetura produzida, a atividade de avaliação verifica os resultados das fases Geração e Adaptação.
A avaliação envolve análises estáticas e dinâmicas da arquitetura resultante.
Transformação: Esta atividade compreende a transformação real do sistema legado a partir de a arquitetura gerada e melhorada para o ambiente de nuvem selecionado.·
Em é apresentado um processo de reengenharia para decompor sistemas legados em sub-rotinas que possam representar um serviço a ser exposto.
Um algoritmo baseado em análise aglomerativa (Agglomerative Clustering Analysis) é utilizado para transformar o código procedural num modelo orientado a objetos.
Funções, procedimentos e classes são definidas como entidades de aglomeração e funcionalidades são utilizadas para medir a similaridade entre as entidades.
As funcionalidades são definidas conforme a ocorrência de nomes identificadores no código legado.
Um dendrograma é obtido como resultado da execução do algoritmo e este dendrograma é manualmente analisado para identificar as funcionalidades chaves do aplicativo legado.
Sub-árvores do dendrograma são manualmente selecionadas e a qualidade desta analise manual influência diretamente na granularidade dos serviços, impactando diretamente a coesão e o acoplamento dos mesmos.
As sub-rotinas selecionadas passam então por um processo manual de refatoração e os serviços são gerados utilizando- se as interfaces de entrada e saída.
O objetivo deste trabalho é propor um framework para disponibilizar ferramentas de simulação analítica na forma de Web Services, utilizando o modelo de distribuição de software como serviço.
Como forma de validar o trabalho proposto, foram feitas duas implementações do framework para disponibilizar duas ferramentas de simulação já existentes.
Os simuladores PEPS e PLAT foram os escolhidos para a prova de conceito do framework.
Ambos simuladores são implementações que visam solucionar redes de autômatos estocásticos.
Este capítulo introduz aos conceitos de redes de autômatos estocásticos e em seguida apresenta uma visão geral sobre as ferramentas PEPS e PLAT.
Redes de Autômatos Estocásticos O formalismo de Redes de Autômatos Estocásticos foi inicialmente proposto por Plateau em 1984.
Em o início da década de 90 as primeiras soluções foram formalizadas para modelos em escala de tempo contínua e discreta.
Também chamada de SAN (Stochastic Automata Networks), essa técnica permite que modelos Markovianos possam ser descritos de forma compacta e eficiente.
A ideia básica das Redes de Autômatos Estocásticos é que esta descreva um modelo global de um sistema em diversos subsistemas (submodelos) quase independentes entre si, onde cada dois ou mais submodelos interagem somente em alguns casos.
Estes subsistemas, definidos como autômatos estocásticos, são caracterizados por três aspectos:
Estados, transições e eventos.
A denominação de estocásticos atribuída aos autômatos deve- se ao fato de que o tempo é tratado como uma variável aleatória com distribuição exponencial.
Autômato estocástico é um modelo matemático de um sistema que possui entradas e saídas discretas.
O sistema pode se encontrar em qualquer um de entre o número finito dos estados do sistema ou das configurações internas.
O estado interno em que o sistema se encontra sumariza as informações sobre as entradas anteriores e indica ainda o que é necessário para determinar o comportamento do sistema para as entradas seguintes.
Baseado nessa definição, pode- se descrever um autômato estocástico como um conjunto finito de estados e um conjunto finito de transições entre esses estados.
O estado local do sistema modelado em SAN é o estado individual de cada autômato do modelo.
Por sua vez, o estado global do mesmo é definido por a combinação dos estados locais de todos os autômatos que compõem o modelo.
A mudança do estado global do sistema dá- se por a mudança do estado local de qualquer um dos autômatos do modelo.
Estados Locais e Globais O estado de um autômato resume toda a informação referente a seu passado, pois a entrada passada é necessária para determinar qual será o próximo comportamento adotado por o autômato mediante novas entradas.
Ou seja, para um determinado conjunto de estados, um sistema poderá assumir somente um estado a cada momento, e este estado irá variar de acordo com a nova entrada recebida.
O estado individual de cada autômato é chamado de estado local.
O estado global de uma SAN é definido como a combinação de todos os estados locais de cada autômato componente da SAN.
A mudança de um determinado estado local para outro é feita através de transições.
As transições são construções que indicam a possibilidade de mudança entre um estado e outro.
No entanto, cada transição necessita ter ao menos um evento associado a ela para que essa possa ser disparada Eventos Evento é a entidade do modelo responsável por a ocorrência de uma transição, a qual muda o estado global do modelo.
Um ou mais eventos podem estar associados a uma transição e esta é disparada através da ocorrência de qualquer um dos eventos a ela associada.
Em o formalismo SAN existem dois tipos eventos:
Locais e sincronizantes.
Eventos locais são os eventos que alteram o estado local de um único autômato do modelo.
São utilizados para demonstrar o comportamento do processamento individual de cada autômato.
Eventos sincronizantes são os eventos que alteram o estado de dois ou mais autômatos do modelo simultaneamente.
Estes eventos são utilizados para descrever a interação entre dois ou mais autômatos do modelo.
Taxas e Probabilidades Funcionais Um outro tipo de denominação para os eventos locais e sincronizantes é que ambos podem ser chamados de transições funcionais.
Isto ocorrerá quando suas taxas não forem constantes, ou seja, tem- se uma função do estado local de outros autômatos da SAN, avaliada conforme os estados atuais do modelo.
Logo, as taxas funcionais podem ser colocadas tanto em transições locais como em transições sincronizadas, e estas podem ser definidas por funções que refletem a avaliação dos estados atuais da rede de autômatos estocásticos em questão.
A Figura 3.1 apresenta um modelo em SAN com 2 autômatos.
O autômato A possui três estados e o autômato B possui dois estados.
Esta SAN utiliza cinco eventos, aonde os eventos e1, e2, e3 e e5 são eventos locais e o evento e4 é sincronizante, visto que este está presente em ambos autômatos.
Este evento e4 possui ainda uma probabilidade associada a diferentes transições no autômato A. Além disso, o evento e5 possui ainda uma função f 1 associada à sua taxa de ocorrência.
A tabela com as taxas de ocorrência dos eventos para este modelo pode ser vista em 3.1.
Como pode- se observar na definição da função f 1, a taxa de ocorrência da transição do estado 0 para o estado 1 do autômato B é igual a 1 quando autômato A estiver está estado 0, igual a zero quando o autômato A estiver no estado 1 (neste caso, a transição não ocorrerá) e igual a 2 quando o autômato A estiver no estado 2.
Outra possibilidade dentro de o formalismo é que para cada modelo pode- se definir uma função espaço total de estados.
Esta função definirá os estados atingíveis do modelo SAN.
Quando esta for igual a 1, significa que todos os estados do modelo são atingíveis.
Geralmente isto não representa a realidade, em muitas situações existem condições que previnem alguns estados serem atingidos.
A Ferramenta PEPS o objetivo de criar um software para modelar e calcular soluções numéricas para redes de autômatos estocásticos.
Ele usa um descritor Kronecker para representar as transições do modelo numa forma eficiente em termos de consumo de memória.
O modelo é solucionado usando este descritor e aplicando- se métodos VDP (Vector-Descriptor Product), como Shuffle ou Split.
A primeira versão do PEPS foi apresentada em e foi implementada como uma multiplicação vetor-matriz simples, aonde as colunas da matriz são geradas, coluna por coluna, a cada iteração.
Em 2000 uma nova versão foi lançada, esta versão implementa um conjunto de novos algoritmos.
A maior contribuição desta versão é o método de multiplicação do vetor-descritor, o algoritmo Shuffle.
Com este método, cada termo do tensor produto multiplica uma parte do vetor, evitando assim a geração de partes da matriz completa.
Após todas as multiplicações do tensor, obtemos uma multiplicação vetor-matriz completa.
A versão 2003 do PEPS trouxe uma nova interface de compilação, manipulação de vetores esparsos e avaliações de funções em tempo de execução (just-in-time).
A nova interface de compilação é mais intuitiva e compacta.
Também foram introduzidos os operadores de replicação de autômatos.
A implementação do formato de vetores esparsos, permitiu o cálculo exclusivo dentro de o espaço de estados alcançáveis.
Este tipo de abordagem reduz consideravelmente o espaço de armazenamento para alguns determinados modelos.
Outra característica é a avaliação de funções just-in-time, este método gera, para cada função descrita no modelo SAN um código de linguagem de programação.
Os códigos gerados são compilados e ligados com o método de solução do PEPS e são chamados toda vez que uma função precisa ser avaliada.
O último lançamento oficial do PEPS é a versão 2007.
Em esta versão a ferramenta foi dividida em módulos independentes, com o intuito de facilitar a manutenção e o desenvolvimento de novas funcionalidades.
Em esta versão as funcionalidades de replicação de autômatos foram aperfeiçoadas, possibilitando a replicação de autômatos com diferentes transições, eventos ou taxas.
O PEPS é uma ferramenta em desenvolvimento, e apesar de novas versões não terem sido lançadas, algumas melhorias foram implementadas, com por exemplo a execução paralela do algoritmo Split.
A entrada da ferramenta é um arquivo texto descrevendo um modelo SAN numa determinada gramatica.
O PEPS carrega este modelo e constrói um sistema de equações usando os eventos e as taxas informadas.
Este sistema de equações é resolvido utilizando- se soluções iterativas e ao final um arquivo texto é gerado, contendo a solução do sistema de equações.
Todo o código fonte da ferramenta é escrito na linguagem de programação C+, e apesar de ser um código aberto, até hoje não foram feitos esforços na direção de facilitar a integração da ferramenta com outras aplicações ou outros sistemas.
A Interface Textual O módulo de interface textual mantém a característica chave do formalismo SAN:
A modularidade.
O PEPS incorpora uma abordagem baseada em grafos que é próximo a os modelos semânticos.
Em esta abordagem cada autômato é representado por um grafo, em que os nodos são os estados e os arcos representam transições por a ocorrência de eventos.
Esta descrição textual foi mantida simples, extensível e flexível.·
É bastante simples, porque há poucas palavras reservadas, o suficiente para delimitar os diferentes níveis de modularidade;·
Extensível porque a definição do modelo SAN é executado hierarquicamente;·
Flexível porque a inclusão de estruturas de replicação permite a reutilização de autômatos idênticos, e a construção de autômatos repetindo blocos de estado com o mesmo comportamento.
Identificadores e Domínios O primeiro bloco, identificadores (identifiers), contêm todas as declarações dos parâmetros:
SAN. Por exemplo, «o número de autômatos no estado n0 (que dado um resultado inteiro) pode ser expresso como nb n0.
Uma função que retorna o valor 4 se dois autômatos estão em diferentes estados, e o valor 0, caso contrário, é expresso como&quot;* 4».
Operadores de comparação retornam o valor &quot;1 «para o resultado verdadeiro ou o valor &quot;0 «para o resultado falso.
É possível declarar quantos identificadores forem necessários e a sua definição é a seguinte:·
&quot;id_ name\&gt; «É um identificador de expressão que começa com uma letra e é seguido por uma sequência de letra ou números.
O comprimento máximo de uma expressão é 128 caracteres;·
&quot;dom_ name\&gt; «É um identificador de domínio.
É um conjunto de índices.
Um domínio pode ser por um intervalo», por uma lista &quot;ou por lista de intervalos».
Identificadores podem ser usados para definir um intervalo», onde ID1 e ID2 são identificadores com valores constantes.
Em todos os casos, o domínio deve respeitar uma ordem crescente de valores;·
&quot;exp\&gt; «É um número real ou uma expressão matemática.
Um número real tem um dos seguintes formatos:
Um número inteiro, tal como &quot;12345&quot;;
Um número real com ponto flutuante, tal como &quot;12345,6789&quot;;
Um número real com mantissa e exponente, tal como &quot;12345.6789 e+ 100».
Conjuntos de índices são usados para definir números de eventos, autômatos ou estados que podem ser descritos como replicações.
Um grupo de autômatos replicados de A com o conjunto em índices define o conjunto contendo os autômatos A;
A; A;
A; A;
A; Eventos O bloco de eventos define cada evento do modelo dado:·
seu tipo (local ou sincronizante);·
seu nome (um identificador);·
seu índice (uma constante ou função previamente definida no bloco de identificadores).
Adicionalmente, eventos podem ser replicados usando os conjuntos de índices (domínios).
Esta facilidade pode ser usada quando eventos com os mesmos índices aparecem num conjunto de autômatos.·
&quot;loc «define o tipo de evento como um evento local;·
&quot;syn «define o tipo do evento como evento sincronizado;·
&quot;evt_ name\&gt; «o identificador do evento inicia com uma letra e é seguida por uma sequência de letras ou números.
O tamanho máximo de um identificador é de 128 caracteres.·»
é um conjunto de índices.
O replication domain deve ter um identificador definido no bloco de identificadores.
Um evento pode ser replicado em até três níveis.
Cada nível é definido um por replication domain.
Por exemplo, um evento replicado em dois níveis é definido como;·
&quot;rate\&gt; «define a taxa dos eventos.
Deve ser um identificador de expressão declarado no bloco de identificadores.
Rede de autômatos O bloco rede (network) é o principal componente do descritor SAN e é composto de uma estrutura hierárquica.
É formado de um conjunto de autômatos, aonde cada autômato é composto por um conjunto de estados.
Cada estado é conectado a outro estado através da identificação de um evento.·
&quot;type\&gt; «define o tipo do modelo.
A definição prevê dois tipos, contínuo (continuous) e discrito (discrete), porém atualmente a versão atual suporta somente modelos contínuos;·
&quot;aut_ name\&gt; «define o nome de um autômato.
É um identificador alfanumérico e pode ser usado na definição de funções;·
&quot;number_ of_ replications\&gt; «é um conjunto de índices.
Pode ser definido com um intervalo «ou por um identificador de domínio declarado;·
&quot;stt_ name\&gt; «É o identificador de um estado, o qual pode ser usado para avaliação de funções;· «(
evt_ name)\&gt; «É o identificado do evento que dispara a transição de estado.
O evento deve ser declaro no bloco events.· «(
prob)\&gt; «É a taxa de probabilidade da ocorrência do evento.
Deve ser utilizando quando um evento possui mais do que um estado de destino.
Pode ser um número real ou um identificador declarado.
Função de Atingibilidade O bloco reachability é uma função definindo o espaço de estados atingíveis do modelo SAN.
Usualmente, é uma função Booleana, que retorna um valor diferente de zero para os estados atingíveis do conjunto completo de estados do modelo SAN.
Um modelo onde todos os estados são atingíveis tem a função de atingibilidade definida como qualquer constante diferente de zero, e.
g, o valor 1.
Opcionalmente, a função de atingibilidade parcial pode ser definida por a adição da palavra reservada &quot;partial».
Resultados Em este bloco são definidas as funções usadas para computar os índices de desempenho do modelo.
Os resultados dado por o PEPS são os valores integrais dessas funções com a distribuição estacionária do modelo.
A Ferramenta PLAT A ferramenta PLAT (Production Lines Analysis Tool) foi criada para calcular soluções exatas para linhas de produção confiáveis.
Como resultado, o PLAT retorna o rendimento (throughput), a utilização dos buffers (buffer occupation), a utilização dos servidores (server utilization) e o tempo sojourn (sojourn time) de uma linha de produção, considerando- se que a quantidade de estações confiáveis, a taxa de serviço e o tamanho dos buffers são enviados como parâmetros para a ferramenta.
O diferencial desta ferramenta é calcular a solução exata para a linha de produção com grandes espaços de estados, enquanto que outras soluções não proveem valores precisos o suficiente.
A partir de os valores de entrada, a ferramenta gera automaticamente o modelo Markoviano correspondente a linha de produção, na forma de uma rede de autômatos estocásticos.
Esta SAN gerada é então analisada e resolvida utilizando- se ferramentas auxiliares específicas.
O PLAT é dividido em três módulos.
O primeiro gera o modelo SAN equivalente a linha de produção especificada por o usuário.
O segundo módulo determina a solução numérica exata do modelo.
E o terceiro módulo calcula as métricas de performance da linha de produção.
Em este primeiro modulo, o usuário informa o número de estações da linha de produção serial, assim como a capacidade do buffer de cada estação e também a taxa de serviço para cada servidor.
Este módulo gera automaticamente um modelo SAN equivalente a linha de produção informada, ou seja, é feita transformação da linha de produção num modelo em redes de autômatos estocásticos.
O algoritmo que realiza esta transformação pode ser visto em.
O produto cartesiano de todos os estados locais do modelo definem o PSS (Product State Space), no entanto, considerandose um estado inicial, apenas um subconjunto do PSS é atingível de fato.
Este novo subconjunto é denominado de RSS (Reachable State Space).
Ambos PSS e RSS são calculados neste primeiro módulo do PLAT, e com base nos valores obtidos o métodos de solução mais apropriado é recomendado para a execução no próximo módulo.
O segundo módulo é o responsável por a solução do modelo SAN previamente gerado.
O PLAT fornece distribuições probabilísticas estacionárias ou distribuições probabilísticas transientes.
A solução exata do modelo é computada através de ferramentas pré-existentes para resolução de redes de autômatos estocásticos, como o PEPS2007 ou o GTAEXPRESS.
O PEPS2007 é uma versão específica da ferramenta já apresentada na Seção 3.5 deste mesmo Capítulo.
O GTAEXPRESS é outra ferramenta para solução de modelos SAN, se caracteriza por armazenar as transições do modelo como uma matriz esparsa Harwell--Boeing que é calculada a partir de os estados atingíveis do modelo, o qual é armazenado numa estrutura MDD (Multi-valued Decision Diagrams).
De acordo com as características da linha de produção e dos valores RSS e PSS do modelo SAN gerado, o PLAT sugere a ferramenta de solução mais adequada.
Cabe ao usuário aceitar a sugestão ou selecionar outra forma de solução.
Assim que definida a forma de solução, as ferramentas auxiliares para solução do modelo são executadas e as probabilidades de distribuição dos estados do modelo são computadas.
Dada as probabilidades de distribuições dos estados do modelo SAN, o PLAT calcula as medidas de desempenho de cada estação, e seu respectivo buffer, da linha de produção modelada.
Mais especificamente, ele calcula par a par (estação e buffer) a taxa média de transferência (throughput), taxa média de ocupação do buffer (buffer occupation), taxa de ocupação do servidor da estação (station server utilization) e o tempo sojourn (sojourn time).
Este capítulo apresenta, na Seção 4.1, o problema a ser solucionado.
Logo após, a Seção 4.2 descreve a solução proposta e em seguida, as Seções 4.3 e 4.4 apresentam as duas implementações realizadas com o objetivo de verificar se a proposta deste trabalho atende ao problema identificado.
A o final, na Seção 4.5 são apresentados os resultados das análises de overhead introduzidos na adoção do framework.
Problema Atualmente, existe uma crescente tendência de se disponibilizar soluções, aplicações e ferramentas na forma de serviços que possam ser utilizados por usuários ou integrados a outras aplicações.
Em este contexto, o Capítulo 3 apresentou duas ferramentas de simulação analítica, denominadas PEPS e PLAT, que não possuem mecanismos de integração.
Ambas as ferramentas possuem dependências com relação a o sistema operacional suportado e bibliotecas de compilação, além de possuírem apenas uma interface de usuário em modo texto.
Estas restrições exigem um conhecimento prévio por parte de os usuários que não está diretamente relacionado ao objetivo dessas ferramentas.
Assim sendo, dois problemas são identificados:·
Impossibilidade de integração com outras ferramentas.·
Grande complexidade na utilização das ferramentas por parte de os usuários.
Framework Com o objetivo de solucionar os problema identificados na Seção 4.1, este trabalho propõe um framework reutilizável, para expor ferramentas de simulação analíticas na forma de Web Services, utilizando como forma de distribuição o conceito de Software como Serviço.
Apesar de o foco deste trabalho estar em simulação analítica, este framework pode ser facilmente estendido para suportar praticamente qualquer ferramenta em a qual se deseje disponibilizar através de SaaS.
O objetivo central é reduzir a complexidade na utilização, fornecer acessibilidade a qualquer usuário e possibilitar a integração das ferramentas.
Para atender aos problemas apontados, dois módulos distintos são propostos.
O primeiro visa atender ao requisito de integração e o segundo o requisito de usabilidade.
O primeiro módulo é uma interface Web Services para receber as requisições dos usuários, transformar o pedido numa execução da ferramenta e retornar ao usuário o resultado obtido.
Seguindo os conceitos de Software como Serviço, o usuário não precisa se preocupar como ou aonde a execução da ferramenta será feita, o usuário preocupa- se apenas em realizar o pedido e receber o resultado.
A Figura 4.1 representa a visão do ponto de vista do cliente consumidor do serviço, aonde a única interação é realizada através da interface.
Pedidos de execução são recebidos e retornados ao cliente através de Web Services trafegando sobre o protocolo de transporte Http.
O framework foi projetado para suportar chamadas Web Service síncronas e assíncronas.
Independentemente do modo de execução, ao receber os pedidos de clientes, a interface analisa os valores enviados e verifica se a entrada é válida.
Uma mensagem de erro é retornada sempre sincronamente caso existam inconsistências.·
Execução Síncrona: Durante uma execução síncrona, o cliente envia o pedido e fica aguardado, num estado bloqueado, o término por completo da execução da ferramenta.
A Figura sua execução, pois se tratam de ferramentas de simulação iterativa que buscam um algo grau de precisão.
Em situações como estas, idealmente buscamos minimizar o impacto do tempo de execução para o usuário, e isto é feito utilizando- se chamadas assíncronas.·
Execução Assíncrona: No caso de execuções assíncronas, os padrões de Web Services possibilitam duas alternativas, One Way e Request/ Callback.
O framework disponibiliza nativamente tanto o modo síncrono quanto os modos assíncronos.
Entretanto, algumas customizações são necessárias durante a criação de uma solução.
As validações dos valores de entrada e a transformação dos valores de entrada em parâmetros para a ferramenta sendo exposta, devem ser codificados manualmente durante a fase de implementação, respeitando- se os nomes de métodos e parâmetros provenientes do framework.
Após a transformação dos valores de entrada vem a fase de execução.
Com exceção de casos específicos, nesta fase não são necessárias customizações, basta apenas que seja informado nos arquivos de configuração os caminhos no sistema de arquivos onde estão armazenados os binários executáveis da ferramenta.
De posse dos parâmetros transformados e dos caminhos para os executáveis, o framework realiza o controle de execução de processos.
Uma chamada ao sistema operacional é efetuada para a inicialização de um novo processo, paralelo ao processo aonde o framework esta sendo executado, para a execução da ferramenta.
Ao longo de a execução o framework monitora tanto os arquivos de log quanto os sinais do sistema operacional para identificar interrupções por erro ou o término com sucesso da execução.
Terminada a fase de execução, os resultados precisam ser traduzidos para o formato esperado por o consumidor do serviço.
Em este ponto, novamente se faz necessária uma customização de código, aonde os resultados obtidos por a execução da ferramenta devem ser transformados no formato que o cliente espera receber.
O valor de P deve ser especificado nos arquivos de configuração do framework.
Para viabilizar as execuções assíncronas One Way, se faz necessário o armazenamento de resultados.
Um banco de dados relacional é utilizado para este fim e o diagrama entidade-relacionamento da Figura 4.5 demonstra as entidades utilizadas para este armazenamento.
Este banco de dados também é utilizado para os serviços auxiliares que efetuam por exemplo:
Autenticação de usuários, reexecução de pedidos e listagem de execuções anteriores.
A partir de esta estrutura relacional simples, também é possível a extração de métricas de utilização e desempenho da ferramenta.
A entidade Execução, representa a tabela principal do sistema.
E é em ela que ficam armazenadas as execuções e seus respectivos resultados.
Associadas a tabela principal estão as entidades Usuário, Grupo_ Execução, Parâmetros_ Entrada e Arquivo_ Entrada.
A tabela Usuário armazena dados pessoais dos usuários e é utilizada para realizar a autenticação do sistema.
Este mecanismo de segurança se faz necessário para evitar que execuções prévias e seus resultados, cujo conteúdo possivelmente contenha dados sigilosos, sejam visualizadas indiscriminadamente por outras pessoas.
O framework possui também uma opção de execução em lote, aonde pode- se definir um intervalo de variação e um valor de incremento para popular automaticamente parâmetros da execução.
De posse do intervalo e do incremento, o framework gera uma combinação de execuções que são lote.
A partir de o momento em que todas as execuções do lote estão finalizadas, a interface habilita um serviço que gera gráficos com os resultados das variações da execução em lote.
Esta funcionalidade é particularmente interessante em simulações analíticas, aonde rotineiramente diversas simulações são executadas, variando- se valores de entrada, com o objetivo de identificar quais variações impactam mais no resultado final.
A Figura 4.6 apresenta um exemplo desse gráfico.
A tabela Parâmetros_ Entrada salva os valores dos parâmetros utilizados na execução e a tabela Arquivo_ Entrada é utilizada quando os parâmetros são enviados na forma de um arquivo texto.
Os serviços expostos por o módulo Web Service são descritos a seguir e o arquivo WSDL correspondente pode ser encontrado no Apêndice B.· Autentica:
Serviço que recebe como parâmetro um usuário e uma senha.
Utilizando cripto-grafia SHA-1, verifica se as informações enviadas conferem com os dados armazenados no banco de dados.·
SalvaUsuario: Serviço que recebe os dados pessoais de um usuário e armazena no banco de dados um nove registro.·
SolicitaNovaSenha: Serviço que recebe o endereço de e-mail do usuário e gera uma nova senha.
Esta nova senha é gerada utilizando criptografia SHA-1 e é enviada através de e-mail ao usuário.·
BuscaExecução: Serviço que retorna os parâmetros e resultados de uma execução, selecionada através do identificador único.·
ExecutaFerramenta: Serviço que executa a ferramenta disponibilizada na forma de serviço.
Este serviço recebe os parâmetros para a execução e faz a comunicação com o sistema operacional que irá executar a ferramenta.
Primeiramente é feita a transformação dos dados recebidos para o formato de entrada esperado por a ferramenta.
Em seguida ocorre a verificação do semáforo para entrada na seção crítica, assim que a entrada for permitida ocorre uma chamada ao sistema operacional para criação do processo que irá executar a ferramenta.
A o final da execução, os resultados são armazenados no banco de dados.
O Algoritmo 4.1 apresenta a lógica deste serviço.
Algoritmo 4.1: Lógica do serviço ExecutaFerramenta.
Processo iniciaP rocesso (parametros) armazenaResultado (processo) O módulo Web Services foi implementado utilizando a linguagem de programação Java na versão servidor de aplicação Apache Tomcat na versão 7.0.11.
Por se tratar de uma solução que segue os padrões J2EE (Java2 Platform Enterprise Edition), pode ser instalado em qualquer plataforma ou em qualquer servidor de aplicação compatível com J2EE.
Além disso, este módulo e utiliza uma série de tecnologias e frameworks de código aberto.
De entre elas podemos citar:·
Apache Axis 2: Axis 2 é um projeto mantido por a Apache Software Foundation e é uma implementação em Java para o protocolo SOAP.
Proporciona grande agilidade no desenvolvimento, pois possui geradores de código capazes de criar toda a infraestrutura necessária para a exposição de classes Java via Web Services;·
Apache Derby: É uma implementação puramente em Java de um sistema gerenciador de banco de dados (SGBD).
Este banco de dados foi selecionado por ser de código aberto e por ser um software considerado leve.
É utilizado para armazenar as solicitações de execução e seus respectivos resultados.·
Hibernate 3: É uma framework de mapeamento objeto-relacional.
Sua função é transformar tabelas e registros do banco de dados em objetos que possam ser manipulados numa programação orientada a objetos.
Está atualmente na terceira versão e é a implementação mais popular para a especificação JPA (Java Persistence API);·
Spring Framework: É um framework para facilitar a implementação de padrões de projeto O segundo módulo é responsável por atender ao requisito de usabilidade, reduzindo a complexidade na manipulação das ferramentas.
Este módulo é uma aplicação Web que atua como um intermediário entre o usuário final e os Web Services expostos por o primeiro módulo.
Esta aplicação recebe os valores de entrada do usuário, faz a comunicação com os serviços e retorna ao usuário o resultado, formatado amigavelmente, como páginas Html (HyperText Markup Language).
Em este cenário, o consumidor do serviço não é o usuário final, mas sim a aplicação Web intermediária.
É nesta aplicação que serão criadas as mensagens SOAP e são feitas as chamadas aos serviços.
De o ponto de vista do usuário, a ferramenta se comporta como uma página comum da Internet, aonde entradas são enviadas e os resultados são exibidos através do navegador.
O Diagrama de Casos de Uso da Figura 4.7 apresenta as operações da aplicação que são disponibilizadas ao usuário.
Os Casos de Uso são descritos abaixo:·
Faz Login:
O usuário fornece o seu login e senha.
A aplicação Web envia ambos os valores para o serviço de autenticação do módulo Web Service que por sua vez confronta os dados com a informação armazenada no banco de dados e retorna ao módulo Web a confirmação.
1. O usuário acessa o endereço da aplicação através do navegador.
3 a..
Login e senha não são válidos.
Caso retorno verdadeiro, o acesso as outras funcionalidades da aplicação é garantido (Tabela· Cadastra Conta:
Antes de poder acessar a aplicação, o usuário necessita efetuar o cadastramento de uma conta de acesso.
Em este Caso de Uso, o usuário informa seus dados pessoais como:
Nome de usuário (login), senha, nome completo, e-mail e linguagem de preferência.
3. Sistema verifica se o campo e-mail foi corretamente inserido.
2 a..
Usuário não preenche todos os campos.·
Solicita Nova Senha:
O usuário fornece o e-mail informado durante a criação da conta.
A aplicação Web valida a entrada e encaminha o endereço de e-mail do usuário ao serviço SolicitaNovaSenha do módulo Web Service, que por sua vez irá gerar uma nova senha aleatoriamente e enviará via SMTP ao usuário.
Gerar uma nova senha e enviar ao usuário via e-mail.
O novo valor no registro de conta do usuário.
2 b.
Sistema efetua a exclusão do registro de execução e atualiza a listagem do usuário.
2 c..
Retorna ao passo 1.·
Visualiza Resultado:
O usuário seleciona a execução em a qual deseja visualizar o resultado, a partir de o &quot;Caso de Uso Lista Execuções Anteriores».
A aplicação Web executa o serviço BuscaExecução do módulo Web Service, passando como parâmetro o identificador único do registro.
O serviço retorna todos os dados associados a execução solicitada e a aplicação Web deve customizar a formatação dos resultados ao usuário (Tabela 4.5).
1. Usuário seleciona a opção de visualizar resultados, a partir de o &quot;Caso de Uso Lista Execuções Anteriores».
BuscaExecução não retorna dados de resultado 3b.
Sistema informa ao usuário que não existem dados para visualização.
Assim como o módulo Web Service, o módulo Web também foi implementado na linguagem de programação Java em sua versão 1.6 e num ambiente Linux.
Faz uso do mesmo servidor de aplicação Apache Tomcat, porém o conjunto de tecnologias utilizadas na implementação são distintos.
Em este módulo foram utilizados os seguintes frameworks:·
Apache Struts 2: É um framework MVC (Model-View--Controller) para separação de camadas da aplicação.
A divisão de camadas da proporciona um baixo acoplamento e uma maior coesão, melhorando a qualidade e consequentemente facilitando a manutenção do código.
A camada de apresentação (View) é responsável por ditar como os dados devem ser organizados, independente de seus valores.
Model é a representação lógica dos dados e Controller é a camada responsável por manipular os dados e fazer a ligação entre as outras duas camadas.·
Apache Axis 2: É uma biblioteca para criação de Web Services em Java.
No caso de o módulo Web, o Apache Axis é utilizado para a geração do código cliente, ou seja o código que irá acessar os serviços expostos no módulo Web Service.
Como forma de validar esta solução e provar a sua funcionalidade, duas implementações do framework foram realizadas.
Foram disponibilizadas como um serviço as ferramentas PEPS e PLAT, apresentadas no Capítulo 3.
PEPS como Serviço O objetivo principal em disponibilizar o PEPS como um serviço é possibilitar sua integração com outras ferramentas e tornar o acesso e a utilização por parte de os usuários mais simples.
Além disso, no contexto deste trabalho, também serviu como forma de validar a funcionalidade do framework.
O PEPS é uma ferramenta para solucionar Redes de Autômatos Estocásticos e possui como entrada um arquivo texto representando um modelo SAN.
Este arquivo deve necessariamente seguir as regras da Interface Textual apresentada na Subseção 3.5.1.
Em esta implementação foram criadas três opções de execução, cada uma de elas focada num perfil de usuário diferente.·
Simple Run (Execução Simples):
Este é o modo de execução mais simples e visa atender aos usuários menos familiarizados com o PEPS.
Em esta opção o usuário precisa apenas informar o arquivo contendo o modelo SAN e aguardar o término da execução.
Todos os outros parâmetros necessários para a execução recebem um valor padrão.
A Figura 4.12 apresenta a interface do usuário aonde se informa o arquivo a ser executado.·
Expert Mode (Modo Avançado):
Este modo é voltado para usuários com experiência na utilização do PEPS.
Em este caso, além de informar o arquivo com o modelo SAN, o usuário também pode informar todas as outras opções de parâmetros suportadas por o PEPS.
A Figura· Experimenter (Experimentador):
Este modo é voltado para experimentos aonde diversas execuções serão feitas com o objetivo de identificar tendências nos modelos.
Este modo faz uso da funcionalidade de execução em lote.
Independentemente do modo de execução escolhido, os resultados são visualizados através da listagem de execuções anteriores.
A Figura 4.14 apresenta um exemplo de listagem.
Através da listagem de execuções são disponibilizadas diversas operações, são elas:·
Visualizar arquivo SAN:
Através do link em (A), é apresentado o arquivo texto do modelo SAN que foi utilizado na execução;·
Agrupador de execução em lote:
O agrupador em (B) mostra como as execuções em lote são agrupadas;·
Visualizar o log de execução:
O ícone em (C) é utilizado para abrir o arquivo de log de uma execução;
No caso de uma execução em andamento, a visualização é atualizada a cada três segundos;·
Excluir execução:
O ícone em (D) exclui do bando de dados todas as informações relativas a execução.
No caso de uma execução em andamento, além de efetuar a exclusão, o processo no sistema operacional também é destruído;·
Visualizar resultado da execução em lote:
O ícone (E) é utilizado para visualizar os resultados da execução em lote na forma de uma planilha Excel;·
Visualizar gráfico:
Os ícones em (F) e (G) são utilizados para exportar as informações da execução em lote na forma de gráficos.
Ambos geram o mesmo resultado, porém o primeiro gera o gráfico em formato EPS (Encapsulated PostScript) e o segundo em formato PNG (Portable Network Graphics);·
Visualizar matriz de resultados:
O ícone em (H) serve para apresentar a matriz de resultados da execução em lote.
Esta matriz é a mesma utilizada para a formação dos gráficos;·
Visualizar arquivo TIM:
A operação em serve para visualizar o arquivo TIM gerado durante a execução do PEPS;·
Visualizar resultado:
O ícone (J) é utilizado para visualizar o resultado de uma única execução.
O resultado é formatado como uma planilha Excel;·
Visualizar arquivo VCT:
A operação em (K) serve para visualizar o arquivo VCT gerado durante a execução do PEPS;
PLAT como Serviço O PLAT é uma ferramenta para obtenção de índices (throughput, buffer occupation, server utilization e sojourn time) de linhas de produção seriais.
Assim como o PEPS, o objetivo em disponibilizar como serviço é possibilitar a integração com outras ferramentas e tornar a usabilidade mais amigável com o usuário final.
Em o PLAT todos os parâmetros são informados por a interface do usuário.
O usuário inicia informando a quantidade de estações (K) da linha de produção.
Aonde K pode variar de 3 a 18.
O sistema automaticamente atualiza a interface de acordo com a quantidade de estações.
A Figura 4.15 apresenta, respectivamente, a formatação da tela para K $= 3 e K $= estação, que possui buffer infinito) e o valor da taxa de atendimento de serviço para cada estação.
O PLAT analisa os parâmetros de entrada e calcula ambos PSS e RSS do modelo SAN equivalente à linha de produção.
O método de solução é sugerido com base nestes valores.
A Figura 4.16 demonstra a interface aonde o usuário seleciona o método e o modo de execução, aonde os modos disponíveis são estacionário e transiente.
Em execuções transientes, o usuário precisa ainda informar a unidade de tempo e o estado inicial.
Após a seleção do método e modo de execução, o usuário é direcionado para a listagem de execuções anteriores.
Esta listagem, além de permitir o acompanhamento das execuções em andamento, também permite ao usuário efetuar as seguintes operações:·
Excluir execução:
O ícone (A) exclui do bando de dados todas as informações relativas a execução;·
Visualizar arquivo SAN:
O ícone (B) permite visualizar o arquivo SAN equivalente a linha de produção;·
Visualizar resultado:
O ícone (C) apresenta o resultado da execução.
Por exemplo a Figura· Editar parâmetros de execução:
O ícone (D) permite ao usuário criar uma nova execução tomando como exemplo os parâmetros informados anteriormente;·
Cancelar execução:
O ícone (E) permite ao usuário cancelar uma execução em andamento.
Plat, deste o dia 26 de setembro de 2011, possui 4 usuários e já obteve índices de 19 linhas de produção.
Overhead Introduzido Os resultados apresentados a seguir são baseados em observações feitas a partir de a execução das ferramentas PEPS e PLAT, utilizando- se modelos exatamente iguais, nas versões originais e nas versões implementadas através do framework.
Estes resultados tem como objetivo analisar o overhead gerado para inclusão do framework.
O objeto dessa análise é comparar a utilização de memória e o tempo de resposta de cada uma das soluções.
Para obter um resultado mais confiável, foram realizadas 30 execuções para cada teste.
O consumo de memória foi calculado considerando- se a média de utilização durante toda a execução das ferramentas e o tempo de resposta foi obtido através da subtração do instante marcado por o relógio interno do sistema operacional quando de o término da execução e do instante inicial da execução.
Para ambos, consumo de memória e tempo de resposta, foi realizada uma média aritmética simples sobre os valores obtidos sobre a quantidade de execuções.
Em esta análise foram ignorados os tempos gastos em função de transmissões de dados sobre redes.
Os testes foram efetuados num único servidor, uma máquina virtual instalada com ambiente Linux/ Ubuntu versão 10.10, com o CPU Intel (R) Core (TM) 2 Duo T6600 de 2.20 GHz e 2 GBytes de memória RAM.
Em os testes de comparação de desempenho do PEPS foram utilizados dois modelos.
O primeiro modelando o famoso problema do Jantar dos Filósofos, aonde foi utilizada uma mesa com 12 filósofos.
E o segundo representando uma Rede de Filas Fechadas com um conjunto de 15 filas.
Os modelos utilizados podem ser encontrados em.
Já para as execuções da ferramenta PLAT, foram utilizadas duas configurações de linhas de produção.
A primeira com 10 estações confiáveis e a segunda com 12 estações confiáveis.
Antes de analisar o consumo de memória gasto por as ferramentas, cabe aqui ressaltar que as versões implementadas através do framework fazem uso tanto do servidor de aplicação Apache Tomcat quanto do banco de dados Apache Derby.
Análise feita no mesmo servidor de teste, constatou- se que o banco de dados consome cerca de 38 Megabytes de memória e o servidor de aplicação cerca de 119 Megabytes, totalizando em torno de 157 Megabytes de memória que são utilizados independentemente da execução das ferramentas.
A Tabela 4.8 apresenta o comparativo de consumo de memória obtidos nos testes do PEPS.
Observa- se um incremento de 17% e de 20% sobre a utilização de memória, o que podemos consi-derar um impacto significante.
Assim como nos testes anteriores, as execuções da ferramenta PLAT também apresentaram um overhead significante em termos de consumo de memória.
Foram observados incrementos de 25% e 13% na versão exposta como serviço.
A Tabela 4.9 mostra os resultados obtidos na comparação.
O gráfico da Figura 4.19 apresenta a comparação de consumo de memória entre todas as execuções e é possível identificar um incremento linear com relação a o overhead introduzido por a adoção do framework, ou seja, independentemente do tamanho do modelo a ser solucionado por as ferramentas, a diferença de utilização de memória permanece a mesma.
Por os testes analisados, as diferenças obtidas estiveram em torno de 160 Megabytes, que se deve em grande parte por a adoção do servidor de aplicação e do banco de dados.
Entretanto, este overhear, mesmo sendo significativo, nos dias de hoje é facilmente absorvível por as infraestruturas de hardware.
Para a análise de overhead sobre o tempo de resposta foram desconsiderados os tempos de interação humana, necessários na utilização das ferramentas, assim como os tempos gastos em transmissões de dados.
Restando assim, apenas o tempo efetivo de processamento para obtenção da solução numérica dos modelos testados.
O tempo de resposta foi obtido subtraindo- se o instante de término de processamento do instante de início de processamento.
Os instantes inicial e final são obtidos através do arquivo de log que registra o processamento de uma execução.
Este arquivo registra, utilizando o relógio interno do sistema operacional, as etapas do ciclo de execução das ferramentas.
É considerado o instante inicial o momento registrado na primeira operação de escrita realizada no arquivo de log e instante final o momento da última operação de escrita.
A Tabela 4.10 apresenta os tempos de resposta, medidos em segundos, obtidos nos testes do PEPS.
Verifica- se um incremento de, em média, apenas 5 segundos no tempo total de execução, representando 2,45% e 0,24% a mais no tempo de espera.
Ao contrário de o que foi verificado na análise de consumo de memória, neste caso o overhead gerado é praticamente desprezível.
Seguindo a mesma tendência, os testes realizados com a ferramenta PLAT também mostraram um acréscimo em torno de 5 segundos no tempo de processamento.
Em este caso, o incremento representou um adicional de apenas 0,55% e 0,02% do tempo total.
Em a Tabela 4.11 são apresentados os tempos médios, em segundos, obtidos nos testes.
Comparando- se todos os resultados dos testes de tempo de resposta, nota- se um overhead constante, sempre em torno de 5 segundos.
Tendo em mente que a principal usabilidade das ferramentas PEPS e PLAT é solucionar problemas que exigem grande quantidade de processamento, e em geral, problemas que exigem a execução da ferramenta por diversos minutos ou horas, o incremento de 5 segundos no tempo total de resposta pode ser considerado desprezível tendo em vista os benefícios que o framework agrega.
O gráfico da Figura 4.20 mostra a comparação dos resultados obtidos nos testes de tempo de resposta para ambas as ferramentas.
A análise geral do overhead introduzido indica um aumento considerável com relação a o consumo de memória e um aumento aceitável no tempo de resposta.
Este incremento considerável não é considerado um problema ou impedimento na implementação de soluções utilizando o framework, exceto para situações aonde o consumo de memória seja um fator crítico.
Para estes cenários, a sugestão para tentar mitigar o excesso de memória consumida é efetuar a troca do servidor identificado que o aumento no consumo está relacionando à infraestrutura utilizada por o framework.
Por exemplo, o Apache Tomcat poderia ser substituído por o Jetty e o banco de dados Apache Derby por os bancos SQLite ou por o HyperSQL Db.
Por seguir fielmente a especificação J2EE, não seria necessária nenhuma alteração no código do framework para utilizar servidores de aplicação e banco de dados diferentes.
Este trabalho apresentou, no Capítulo 4, a especificação e implementação de um framework para a disponibilização de ferramentas de simulação analítica na forma de software como serviço.
Apesar de o foco deste trabalho estar em simulação analítica, este framework poderia ser facilmente adaptado para disponibilizar qualquer solução como um serviço.
Foram definidos métodos, assinaturas e comportamentos dos serviços criados por a solução, assim como identificado os pontos aonde se faz necessário a customização de código para transformar a execução do software numa chamada Web Service.
A abordagem proposta utiliza uma técnica de encapsulamento de caixa preta, ou seja, a aplicação original não é modificada e introduz- se uma nova camada entre o usuário cliente e o software.
As vantagens em utilizar esta abordagem são possibilitar o reuso da camada de interface para diferentes aplicações e também diminuir o tempo de desenvolvimento, pois um processo de reengenharia dos software legados demandaria uma quantidade de tempo muito maior.
Além de a demonstração das funcionalidades da solução, também está presente neste trabalho as implementações para expor como serviço as ferramentas PEPS e PLAT.
Ambos requisitos de usabilidade e integralidade foram alcançados, atingindo assim os objetivos propostos.
As ferramentas estão atualmente em produção e disponíveis ao publico em geral.
Podem ser utilizadas por usuários através da interface Web (módulo Web) e também podem ser parte de uma orquestração de serviços, utilizando- se os serviços do módulo Web Service.
Algumas dificuldades foram encontradas ao longo de o desenvolvimento deste trabalho.
O principal e mais crítico problema foi o consumo exagerado de memória do servidor quando diversas solicitações de execução eram requisitadas ao mesmo tempo.
Dependendo do tamanho dos modelos e do número de estados atingíveis o servidor chegava a abortar os processos no sistema operacional por falta de execuções, aonde um semáforo é responsável por permitir somente P execuções simultâneas.
Além deste problema, também foram encontradas dificuldades no gerenciamento dos processos do sistema operacional.
Diversas horas de depuração e pesquisa foram utilizadas para tentar construir um mecanismo dinâmico de alocação de recursos.
Este mecanismo tinha como objetivo analisar a quantidade de memória disponível e a quantidade de memória necessária para a execução dos processos, e com base nestas informações, determinar em tempo real, a quantidade de processos paralelos suportados por o framework.
Apesar de o tempo investido nessa solução, não foi possível obter resultados satisfatórios e tomou- se a decisão de implementar o controle de execuções paralelas estático, aonde apenas P execuções paralelas são permitidas com o uso de um semáforo.
Contribuição Este trabalho contribui para a comunidade acadêmica no sentido de fornecer uma solução reutilizável para ser usada na disponibilização, através de Web Services, de aplicativos que não foram projetados com foco na integração.
Além de demonstrar a solução genérica, este trabalho também apresentou duas implementações concretas, disponibilizando como serviço as ferramentas PEPS e PLAT.
Ambos trazem como benefício a possibilidade de integração através de Soa e uma grande melhoria na interface com o usuário, tornando suas usabilidades mais simples.
Além de facilitar o processo de instalação do software, pois basta ao usuário simplesmente acessar o endereço aonde as aplicações estiverem disponíveis, evitando assim todo o processo complexo de compilação da ferramenta.
A utilização destas aplicações por os acadêmicos proporcionará ao leigos uma melhor aprendizagem do formalismo SAN.
E para os mais experientes, será útil no sentido de facilitar a utilização e visualização dos resultados.
Trabalhos Futuros Como trabalho futuro é sugerido uma extensão do framework para que os serviços disponibilizados possam ser utilizados na forma de computação na nuvem (Cloud Computing).
A disponibilização das ferramentas na forma de Web Services já é um primeiro passo na direção à nuvem, porém adaptações seriam necessárias para fazer uso dos conceitos de computação elástica (Elastic Computing), com o objetivo de tornar o framework capaz de alocar e desalocar outras unidades de processamento de acordo com a demanda exigida e também, possuindo a habilidade de particionar paralelamente o processamento entre as diversas instâncias alocadas.
Em este caso, o ideal seria substituir a abordagem de encapsulamento de caixa preta e adotar uma estratégia de reengenharia, como proposto em e, e reescrever novamente a ferramenta sendo exposta, tornando- o capaz de solucionar problemas em paralelo.
Também é sugerido a disponibilização de outras ferramentas além de as já apresentadas neste trabalho.
Novas implementações serviriam para validar ainda mais a solução proposta e também trariam o benefício da integração e melhor usabilidade para os usuários.
