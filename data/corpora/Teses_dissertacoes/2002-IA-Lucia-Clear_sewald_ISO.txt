O uso de jogos computadorizados interativos como ambientes para a pesquisa na área de Intelig ência Artificial (Ia) pode ser considerado como uma tradição.
Existem muitos trabalhos que envolvem jogos clássicos, como os jogos de tabuleiro tradicionais (xadrez e damas), cartas e quebra-cabeças.
Muitos destes jogos tiveram soluções baseadas na utilização de uma ou mais técnicas de Ia.
Contudo, encontramos- nos numa nova era na pesquisa de Ia envolvendo jogos:
Os jogos interativos modernos em tempo-real.
Estes novos ambientes estão tornaram- se um campo interessante para experimentação e exploração dos limites e possibilidades das técnicas de Ia.
Os jogos computadorizados modernos consistem, em sua maioria, de ambientes virtuais que envolvem alto nível de dinamismo e interatividade.
Embora, para muitos pesquisadores, a aplicação de técnicas de Ia nos jogos modernos (interativos) seja questionável como aplicação científica, considera- se esta postura muito tradicional e preconceituosa, uma vez que os jogos sempre foram utilizados como plataformas de teste (&quot;testbeds&quot;) no contexto de Ia.
Isto ocorre devido a sua alta complexidade de modelagem e implementação.
Estes ambientes fornecem uma variada e complexa lista de problemas que permite aos pesquisadores testar e experimentar resultados da pesquisa em agentes inteligentes ora em curso.
Este volume apresenta a descrição do projeto de pesquisa Score (Simulator for COgnitive agent's behavioR), desenvolvido dentro de o no Grupo de Jogos e Ia (JEIA) do PPGCC/ PUCRS, bem como os resultados obtidos no projeto.
Em o Score é utilizado um formalismo para especificação de agentes que seguem a arquitetura Belief-Desire-Intention (BDI), aplicado ao ambiente de jogo interativo chamado Unreal Tournament (UT).
Este trabalho apresenta, também, alguns aspectos relacionados com o uso da tecnologia de agentes aplicado a jogos computadorizados interativos, com ênfase em aplicações de modelagem de agentes cognitivos em personagens de jogos.
Capítulo 1 Introdução Os jogos computadorizados interativos em tempo-real têm apresentado um grande grau de evolução tanto em nível de performance e interfaces, bem como no que tange ao conjunto de técnicas de projeto utilizado.
O marco inicial desta evolução deu- se no início da década de 70, marcada por o jogo Pong.
Este foi o primeiro jogo com grande sucesso comercial, conforme citado por Battaiola.
Em o Pong, os dois jogadores são representados por retângulos, que se confrontam numa partida de tênis.
A partir de então, as aplicações de entretenimento interativo têm mostrado uma constante evolução, tendo se constituído em notórios espaços de absorção de inovações tecnológicas, tanto na área de Computação Gráfica (CG) (com gráficos em Três Dimensões (3 D) e total liberdade de movimento), quanto na área de Ia, com a utilização de diversas tecnologias, destacando- se, mais recentemente, a de agentes, como descrito em Cunha.
Em os anos 80 surgem os primeiros computadores de 16 bits, como o IBM Personal Computer (PC), o Atari ST e o AMIGA 500.
Como consequência, os jogos computadorizados tiveram uma melhoria significativa, no que se refere à interface e à interação, se comparados aos seus concorrentes na época.
Alguns jogos de simulação em 3D também surgiram neste período, Segundo Lamothe, a grande revolução no jogos computadorizados para a plataforma IBM PC surgiu na década de 90, quando a empresa Id Software criou, em 1993, Doom um personagem que tinha como objetivo destruir os mais variados tipos de monstros.
O grande diferencial de Doom foi a inovação tecnológica associada ao ambiente sombrio do jogo, onde o jogador visualizava o ambiente por a perspectiva do personagem.
Esta tecnologia foi chamada de First Person Perspective (Perspectiva em Primeira Pessoa).
Em o jogo Quake, a evolução tecnológica avançou mais um passo.
Quake foi o primeiro jogo em 3D real para PC's.
Até então, se utilizava um conjunto de técnicas onde o ambiente 3D era apenas simulado.
Isto é, criava- se a ilusão de elementos tridimensionais1.
É importante destacar 1 Em o que tange a programação gráfica de jogos computadorizados, em jogos como Doom e Duke Nukem 3 D, os programadores utilizavam- se do recurso de tiles 2D.
Um tile é um gráfico em 2 D, que pode representar qualquer objeto do jogo, seja este uma parede, um lado de uma árvore ou a frente de um personagem inimigo.
Através do uso de fórmulas matemáticas de rotação e translação de objetos, os programadores implementavam uma falsa noção de objetos 3 D:
Dada uma determinada posição para o tile, caso o jogador se movesse ao redor de o gráfico em questão (numa tentativa de visualizar as costas de um inimigo, ou o outro lado de uma que tanto o Doom quanto o Quake foram utilizados em projetos de pesquisa em ambiente acadêmico, como mostram os trabalhos de Chão e Piekarski.
A rapidez da evolução dos jogos estava, até então, concentrada no âmbito gráfico.
Unreal empresa Epic Megagames, mostrou um avanço significativo não só nas aplicações de técnicas de CG mas também no uso de técnicas de Ia.
Foram utilizadas tecnologias de Ia baseada em regras, como as Finite State Machines (FSM's) e Fuzzy State Machines (FuSM).
Além disso, foi também implementada uma técnica de programação chamada de Extensible Ai, que possibilita ao usuário modificar ou estender o nível de complexidade da Ia presente nos elementos do jogo, desta forma permitindo enorme flexibilidade (estas técnicas serão descritas mais adiante).
Logo após o lançamento de Unreal, a Epic desenvolveu e lançou, em 1999, Unreal Tournament (UT), um jogo utilizando a mesma arquitetura de seu antecessor, Unreal, mas com um apelo maior às comunidades de jogadores na Internet.
Os jogos computadorizados atuais possuem gráficos 3D sofisticados, podendo ser jogados em rede, cooperativamente ou competitivamente.
Estes jogos também apresentam um nível de utilização de técnicas de Ia razoavelmente complexo.
Porém, o atributo mais importante dos jogos modernos é que estes estão sendo projetados e desenvolvidos com o uso de arquiteturas que possibilitam, de uma forma simplificada, expandir, adicionar ou modificar o seu conteúdo.
Unreal, UT, entre outros, são exemplos de jogos criados com base em uma arquitetura com estes atributos.
Para um histórico mais detalhado da evolução dos jogos interativos, pode- se consultar o trabalho de Cunha.
A aplicação de técnicas de Ia em jogos computadorizados, especialmente no que tange o uso da tecnologia de agentes, está diretamente relacionada ao comportamento dos personagens.
Os personagens de um jogo podem ser vistos como agentes, pois suas propriedades e funcionalidades se associam adequadamente a noção de agente utilizada na Ia.
Segundo Maes, a construção de agentes para entretenimento possui as mesmas questões básicas de pesquisa que são centrais para todas as áreas de pesquisa em agentes:
Percepção: O agente deve perceber o ambiente onde se encontra, que freqüentemente é dinâmico e imprevisível, especialmente quando um usuário pode afetas- lo;
Seleção de comportamento:
O agente deve decidir quais são suas próximas ações de forma a haver progresso em direção a os seus objetivos;
Controle de ações:
As ações relevantes de um agente devem ser traduzidas em comandos concretos, de nível de abstração mais baixo;
Adaptação: O agente deve mudar e melhorar seu comportamento com base em suas experiências anteriores;
Esta técnica de programação, apesar de rudimentar, se mostrou útil, visto que não necessitava de alto poder de processamento.
Com o surgimento do jogo Quake, a técnica de programação foi modificada.
Ao invés de a utilização de tiles 2 D, passou- se a utilizar modelos 3 D, onde era criado, com o auxílio de ferramentas de modelagem gráfica em 3 D, um modelo completo de um objeto (com a noção de profundidade).
Desta forma, o jogo exibiria o objeto por todos os lados os quais este teria, dando a noção de 3D real.
Comunicação: O agente deve ser capaz de se comunicar com outros agentes no mundo, tanto humanos quanto artificiais.
Por exemplo, um personagem de um jogo computadorizado, que simula um comportamento humano, possui objetivos (manter- se vivo, encontrar o jogador, etc), pode ter um certo nível de percepção do ambiente onde ele se encontra (ver e tocar em objetos, ouvir sons, etc).
E, também, ele possui a habilidade de realizar ações que o levem a atingir seu (s) objetivo (s) (andar para frente, pegar a chave, etc).
Os personagens devem ser capazes de tomar as decisões adequadas para atingir seus objetivos, adaptando seu comportamento às características de novos ambientes e/ ou oponentes.
Em alguns casos, não só as ações individuais do agente devem ser consideradas inteligentes, como também haver uma forma de comunicação entre eles para que estes realizem alguma tarefa em grupo (cooperativa ou colaborativa) 2 Em o que tange a pesquisa em Ia, existem muitos trabalhos que envolvem jogos clássicos, como os jogos de tabuleiro, cartas ou quebra-cabeças, sendo que muitos destes jogos já foram resolvidos com a utilização de uma ou mais técnicas de Ia.
Porém, os jogos computadorizados modernos são, na sua maioria, jogados em tempo real, em ambientes virtuais que envolvem alto nível de dinamismo e interatividade.
Em os jogos interativos, os desenvolvedores utilizam técnicas de Ia para as mais variadas tarefas:
Controle de personagens, fornecimento de direções estratégicas para grupos de elementos do jogo, mudança dinâmica de parâmetros internos do sistema para tornar o jogo mais desafiador, ou ainda produzir comentários para jogadas num jogo de esporte, por exemplo.
Por estas características, os jogos computadorizados em tempo real apresentam um campo diferenciado para estudo e implementação de técnicas de Ia.
O contexto deste trabalho de pesquisa se encontra melhor descrito por a Figura 1.1.
Este é um trabalho de cunho fortemente interdisciplinar, envolvendo diversas subáreas da Ia e da CG.
Os jogos computadorizados interativos possuem forte influência, no seu projeto e modelagem, de resultados da pesquisa em CG.
Entretanto, estes aspectos serão considerados apenas de forma indireta neste trabalho.
Ou seja, serão somente mencionados, via o estudo de caso selecionado para a investigação envolvendo agentes BDI.
O foco principal e as contribuições se concentram na tecnologia de agentes.
O grupo de pesquisa em Ia do PPGCC da PUCRS vêm desenvolvendo trabalhos de pesquisa investigando a utilização da tecnologia de agentes para a modelagem e projeto de sistemas de informacação 2 Em este trabalho, utiliza- se o termo colaboração como a atividade onde os agentes realizam uma tarefa que faz parte da solução de um problema a ser resolvido por a sociedade de agentes ao qual ele pertence.
O produto final (solução) decorre da agregação das contribuições individuais, sem nenhuma interação.
A cooperação utiliza o mesmo esquema que o da colaboração, no que tange às atividades de cada membro do grupo.
Porém, o produto final é constituído em conjunto e de forma interativa, como salientado por Dámico Considera-se a colaboração como pré-requisito da cooperação.
Busca- se, com estes estudos, ampliar as investigações no que concerne ao uso da ferramenta X-BDI proposta por Móra.
Para tal, utilizou- se como testbed uma aplicação diferenciada das demais, que é o jogo computadorizado interativo, voltado ao entretenimento.
Estes ambientes congregam um conjunto de esforços significativos para sua elaboração.
Desta forma, tornando- se robustos testbeds para a área de Ia, especialmente para o uso exploratório dos agentes.
Os jogos interativos oferecem ambientes robustos para o teste e o desenvolvimento de técnicas de Ia.
Segundo Laird, a idéia de construir agentes que possam ser utilizados num ambiente de jogo computadorizado fornece uma nova visão e aplicação para o estudo de técnicas de Ia.
Um projeto de pesquisa utilizando jogos possui contribuições em nível científico tanto para a comunidade acadêmica quanto para a indústria de entretenimento interativo, pois a possibilidade da utilização de ambientes de jogos interativos no auxílio à pesquisa de agentes inteligentes demonstra o potencial das técnicas de Ia para futuros projetos de jogos.
Segundo Maes, o campo do entretenimento é uma das áreas de aplicação da pesquisa em agentes que tem recebido menos interesse, porém esta área pode se tornar uma das mais importantes nos próximos anos, sendo que uma possível causa é o fato da principal fonte de recursos para a pesquisa em agentes, oriunda do departamento de defesa, vem reduzindo seus investimentos nessa linha de pesquisa.
Em se tratando especificamente de entretenimento interativo, com a saturação da qualidade gráfica dos jogos3, este panorama desfavorável está se modificando, e a qualidade dos jogos começa a ser avaliada, também, por o nível de técnicas de Ia utilizado na modelagem dos personagens, fazendo com que a Ia deixe de ser tratada como uma tarefa em segundo plano no projeto de um jogo.
Apesar de ainda em caráter inicial, a pesquisa acadêmica utilizando jogos computadorizados interativos já possui resultados interessantes em diversas areas de aplicação, como frisado por Lewis.
Como exemplos de estudos envolvendo jogos tanto em projetos de pesquisa de CG quanto de Ia, podemos citar os trabalhos de Kaminka, Jacobson, Bylund, Piekarski e Laird, envolvendo jogos como Quake III:
Arena e o UT.
A industria do entretenimento é um campo extremamente grande, cuja única expectativa é de que cresça ainda mais nos próximos anos.
Várias formas de entretenimento empregam personagens que atuam em algum ambiente, onde os jogos computadorizados se fazem presentes.
O campo do entretenimento é uma área de aplica-ção promissora e desafiadora, a qual certamente virá a exigir bastante esforço por parte de os pesquisadores em agentes, como destacado por Maes.
Alguns jogos computadorizados modernos possuem suas engines4 implementadas sob a forma de Dynamic Link Libraries (DLL's), ou seja, arquivos que agrupam bibliotecas de objetos/ funções do sistema.
Estas DLL's são utilizadas para manipular os dados do jogo (texturas, objetos gráficos) e interagir com certas partes do sistema que são implementadas de forma externa à engine, como por exemplo, o subsistema que controla música e efeitos de som e o subsistema que coordena a Ia dos elementos do jogo.
Através da utilização de algumas ferramentas de autoria (que, na maioria dos casos, são fornecidas juntamente com o jogo), o código-fonte destes subsistemas pode ser visualizado e/ ou manipulado, fazendo com que o usuário possa modificar os atributos do jogo sem a necessidade de adquirir o código-fonte do mesmo.
Estes subsistemas podem ser considerados como as interfaces programáveis da engine, pois esta interpreta o seus códigos-fonte.
Estas interfaces permitem acesso a funções internas do jogo.
A maior parte destas interfaces se apresentam sob a forma de linguagens de script, cujos comandos associados às tarefas do sistema de Ia do jogo geralmente representam ações de baixo nível.
Desta forma, desenvolvedores que utilizarem estas interfaces podem modificar diversos aspectos do jogo, em particular, o comportamento dos personagens.
Porém, seria uma tarefa difícil criar um comportamento complexo (inteligente) através da programação direta na linguagem de script, devido a o seu baixo nível de abstração.
Em este ponto faz- se necessário o uso de ferramentas que auxiliem na modelagem e implementação do agente, especialmente no que concerne aos agentes cognitivos.
A complexidade inerente a estes agentes pode ser reduzida com o uso de outras ferramentas, que não somente os recursos tradicionais de programação fornecidos por o jogo.
Acredita- se que o uso de uma ferramenta auxiliar, para especificação do comportamento dos agentes cognitivos, pode auxiliar na modelagem e no refino do seu comportamento.
Como o grupo de pesquisa em Ia do PPGCC já vem desenvolvendo pesquisas na área de agentes cognitivos modelados com a arquitetura BDI e, existindo um conjundo de recursos disponíveis e elaborados dentro de o grupo (resultante de trabalhos anteriores), decidiu- se por utilizar estes resultados para buscar uma alternativa de solução para este problema, que envolve a modelagem/ implementação do comportamento dos personagens em jogos interativos.
Tendo delimitado este contexto e identificado o problema a ser tratado nesta dissertacão, emergiu a questão de pesquisa norteadora deste trabalho:
Que recursos/ funcionalidades deve possuir o módulo de comunicação para garantir o fluxo de informações entre uma interface de script e o X-BDI?
Hipótese 1:
A interface programável do jogo deve implementar o maior número possível de situações que o agente pode enfrentar no ambiente do jogo.
Hipótese 2:
Deve ser feita uma seleção prévia de quais informações fornecidas por o jogo são relevantes para serem processadas por o X-BDI.
Hipótese 3:
O tradutor a ser desenvolvido e implementado deve ser o mais genérico possível, de forma a estabelecer um padrão para tratar a saída do X-BDI.
Desenvolver um módulo para estabelecer a comunicação entre o X-BDI e o ambiente de jogo O presente trabalho de pesquisa visa integrar a ferramenta X-BDI, um formalismo para especificação e linguagem de programação de agentes desenvolvido por Mora, com o ambiente de jogo UT, com o objetivo de possibilitar a modelagem e programação de comportamentos complexos para agentes BDI (através da ferramenta X-BDI) e visualizar os resultados desta modelagem num ambiente de jogo interativo.
Para tanto, deve- se desenvolver um tradutor a ser utilizado num módulo para estabelecer a comunicação de uma interface programável do UT com a ferramenta X-BDI, mapeando as saídas do jogo (interpretadas por o X-BDI como os sensores do agente) em entradas para o X-BDI, e vice-versa.
Os objetivos específicos deste trabalho são:
Verificar o uso da ferramenta X-BDI num ambiente interativo de alto desempenho;
Desenvolver uma técnica com um tradutor associado para tratar a saída gerada por o· Modelar e implementar um agente inteligente, através das ferramentas X-BDI e E-BDI, para ser utilizado num ambiente de jogo interativo, desta forma validando o tradutor;
Contribuir para a pesquisa do Grupo de Ia da PUCRS, no que se refere à pesquisa e aplicação de agentes cognitivos modelados/ implementados no paradigma BDI.
Este volume está dividido em cinco capítulos.
O capítulo 2 descreve o conjunto de técnicas de Ia mais comumente utilizado em jogos.
O capítulo 3 descreve alguns projetos de pesquisa que são utilizados como ferramentas para o desenvolvimento de agentes cognitivos.
O capítulo 4 descreve projeto de pesquisa Score, foco deste volume.
Considerações finais, limitações e trabalhos futuros, bem como as contribuições deste trabalho, são apresentados no capítulo 5.
Referências bibliográficas são apresentadas no final deste volume.
Técnicas de Ia utilizadas em Jogos Este capítulo descreve o conjunto de técnicas de Ia que compõem o estado-da-arte, no que tange ao uso de tecnologias de Ia aplicado a jogos.
Foi realizado um estudo detalhado destas técnicas em Cunha e, apresenta- se neste capítulo, apenas um resumo, com os principais aspectos que permitirão ao leitor um melhor entendimento da complexidade e variedade de técnicas aplicadas no projeto e desenvolvimento dos jogos.
Segundo Woodcock, enfoques baseados em regras, como as FSM's FuSM's, são as tecnologias de Ia mais utilizadas atualmente por os desenvolvedores de jogos computadorizados, pois sua implementação é relativamente simples, além de serem técnicas já consolidadas no mercado de jogos computadorizados.
Uma FSM é composta por um conjunto de estados (incluindo um estado inicial), um conjunto de entradas, um conjunto de saídas e uma função de transição de estado.
A função de transição recebe as entradas e o estado atual e retorna um único novo estado e um conjunto de saídas, como apresentado em Funge.
As máquinas de estados finitos são normalmente representadas por diagramas de transição de estados, e podem ser implementadas através do uso de comandos case aninhados.
Para a realização de modelagens mais complexas, as FSM's podem ser hierarquizadas, de forma que cada nodo de uma hierarquia possa expandir uma nova hierarquia, e assim sucessivamente, até o último nível, expandindo uma FSM.
Esta técnica é chamada de Hierarchical Finite State Machine (HFSM), a qual fornece uma forma conveniente para a modelagem de FSM's.
Como descrito em Kantrovitz, as FuSM's são baseadas em cadeias de Markov.
Pesos (probabilidades) são associados aos estados e às transições de estado, e regras são estabelecidas para calcular pesos de estados futuros.
Um jogo que utiliza FuSM's é Call ções, sendo que o perfil e os traços característicos de cada civilização foi modelado com a utilização de FuSM's.
A utilização de máquinas de estados finitos permite criar elementos com comportamentos inimigos tomavam uma série de decisões baseadas nas ações do jogador.
A Ia extensível é classificada como uma técnica de Ia por sua aplicabilidade no controle de funções internas da Ia de um jogo.
O nome &quot;IA Extensível», ou Extensible Ai, foi associado a esta técnica devido a o atributo a nível de modelagem que esta dá aos jogos que a implementam.
Estes jogos possibilitam que o usuário possa manipular/ estender a Ia dos elementos do jogo.
A forma como a Ia Extensível é apresentada ao usuário varia de scripts semelhantes a linguagens como Java e até conjuntos de ordens que podem ser passadas ao elemento do jogo (para tanto, os desenvolvedores geralmente implementam um compilador de script personalizado).
Os scripts se baseiam em chamadas de funções definidas no sistema interno de Ia do jogo, o qual não pode ser modificado através de uma implementação padrão da técnica de Extensible Ai.
Segundo Woodcock, vários jogos lançados nos últimos anos implementaram a técnica de Ia Extensível, mantendo uma tendência que surgiu com Duke Nuke' em 3D Segundo Woodcock, dos algoritmos de busca disponíveis (busca em amplitude, busca em largura, entre outros), o A-star (A*) é o mais utilizado em jogos computadorizados, sendo que os desenvolvedores de jogos fizeram suas próprias versões deste algoritmo, adaptando- o a cada projeto.
Segundo Stout, o A* é um algoritmo que utiliza uma função heurística que determina a qualidade de cada um dos estados possíveis (nodos), através de uma estimativa do custo da melhor rota até o destino, passando por o nodo atual.
O custo determina a qualidade de um nodo, sendo que quanto menor o custo, melhor a sua qualidade.
O desempenho do A* depende da função heurística selecionada.
Uma função heurística ruim pode reduzir drasticamente a velocidade do algoritmo, ou fazer com que este produza rotas incorretas.
Segundo Patel, para que o A* calcule sempre as melhores rotas, a função heurística deve ser admissível, ou seja, deve fazer estimativas menores do que o custo real do caminho.
De modo geral, os desenvolvedores de jogos já possuem um certo domínio sobre as técnicas de busca, direcionando seu foco para implementações em casos específicos, tais como pathfinding associado com análise de terreno.
Situação esta encontrada por exemplo em Age of Empires II:
The Age of Kings, um jogo onde o jogador deve desenvolver civilizações antigas.
De acordo com Hayking, as redes neuronais empregam uma interligação maciça de células computacionais simples denominadas &quot;neurônios «ou &quot;unidades de processamento».
As ligações entre os neurônios, também chamadas de sinapses, possuem um valor associado, chamado de peso sináptico, que é utilizado para armazenar o conhecimento adquirido.
O algoritmo de aprendizagem de uma rede neuronal tem como função modificar os pesos sin ápticos, desta forma aperfeiçoando a rede neuronal.
O processo de aprendizagem de uma rede neuronal é dito ser supervisionado se a saída desejada já é conhecida;
Já quando não há exemplos rotulados da função a ser aprendida por a rede, o processo de aprendizagem é dito não-supervisionado.
Os algoritmos genéticos são modelos computacionais inspirados por a evolução humana, Whitley, uma implementação de um algoritmo genético começa com um conjunto (população) de atributos, ou &quot;cromossomos».
Estas estruturas são então avaliadas e oportunidades de &quot;reprodução «são alocadas, de forma que os atributos que representarem uma melhor solução para o problema em questão possuirão mais chances de se &quot;reproduzirem «do que os outros atributos, daí o conceito de evolução, que está associado com o método de aprendizagem utilizado nos algoritmos genéticos.
A qualidade de uma solução é definida de acordo com o conjunto atual de atributos.
Existem alguns projetos que exploraram combinações entre algoritmos genéticos e redes Este oponente utiliza uma rede neuronal para controlar suas ações e um algoritmo genético para &quot;treinar «sua rede neuronal.
Isto faz com que o oponente possua um alto grau de autonomia, sem nenhuma espécie de comportamento pré-programado.
De acordo com Woodcock, as técnicas de representação de vida artificial (A-Life) fornecem formas flexíveis para a criação de comportamentos realísticos nos elementos do jogo.
A A-Life busca simular o comportamento de organismos vivos do mundo real através de uma variedade de métodos, tais como a implementação de regras, algoritmos genéticos, entre outros.
Ao invés de tentar implementar uma grande variedade de comportamentos complexos, a idéia é dividir estes comportamentos em partes menores, simulando comportamentos mais simples.
Estas partes são então interligadas por uma forma de hierarquia de tomada de decisão, utilizada por os elementos do jogo para determinar que ações devem ser tomadas para satisfazer as necessidades destes elementos.
Desta forma, combinações e seqüências de comportamentos mais simples geram comportamentos complexos de forma automática, sem a necessidade da implementação direta destes.
As técnicas de A-Life são utilizadas, na sua maioria, em simuladores, mas a tendência é que seu uso se expanda para outros diferentes gêneros de jogos, como já acontece com alguns enfoques de A-Life, como as técnicas para coordenar agrupamentos e aglomerações, mais conhecidas como flocking algorithms.
Utilizados para controlar o movimento de grupos de elementos, os flocking algorithms já foram utilizados em vários tipos de jogos computadorizados, desde jogos do tipo first person perspective, como Unreal, onde as técnicas de flocking eram utilizadas para controlar o movimento conjunto de cardumes de peixes ou grupos de pássaros, até jogos de estratégia, como Age of Empires, para controlar formações de soldados.
Os Software Development Kits (SDK's), ou simplesmente toolkits, são conjuntos específicos de uma ou mais técnicas de Ia, que auxiliam na sua utilização, agilizando o processo de desenvolvimento da aplicação.
Alguns SDK's foram criados especificamente para serem utilizados em jogos, enquanto outros têm um escopo de utilização mais genérico.
Como exemplos de SDK's disponíveis no mercado podemos citar:
O editor possui uma interface gráfica para a criação e modificação de sistemas de lógica difusa, sendo que estes sistemas podem ser depurados sem a necessidade de recompilação da aplicação.
Para a integração com a aplicação, o Spark!
Disponibiliza uma API escrita em C+;
Dado ao enfoque do trabalho, esta seção apresenta um maior detalhamento do que as outras tecnologias anteriormente descritas.
Segundo Nwana, o termo &quot;agente «é amplamente utilizado nas mais diversas áreas de pesquisa, e não existe um consenso acerca de seu conceito.
De acordo comWooldridge, um agente é um sistema computadorizado capaz de atuar de forma independente em nome de seu usuário ou &quot;proprietário».
Um SMA é um sistema que consiste de um determinado número de agentes que interagem entre si.
Os SMA's fornecem uma nova ferramenta para simular sociedades, o que pode auxiliar no entendimento dos vários tipos de processos sociais.
Logo, agentes podem ser considerados como uma ferramenta que auxilia no entendimento das sociedades, humanas ou baseadas nesta.
Para que os agentes possam interagir com sucesso, eles devem possuir habilidades como cooperação, coordenação e negociação.
De acordo com Nwana, Russel e Wooldridge, os agentes possuem diferentes atributos característicos (propriedades).
Algumas destas propriedades devem ser observadas quando se deseja construir um agente:
Autonomia: Se refere ao princípio de que agentes podem operar de forma independente, sem a necessidade de intervenção humana constante.
Um elemento chave da autonomia de um agente é a sua habilidade de &quot;tomar a iniciativa «quando ocorrem mudanças no ambiente.
Observe- se que este conceito de autonomia é semelhante ao utilizado na maioria dos SMA's.
Para Russel, a autonomia permite ao agente escolher uma ação baseado mais na própria experiência.
Pode, entretanto, acontecer uma situação onde seja necessária a interferência do agente humano.
Em jogos, dificilmente esta situação ocorrerá, visto que se espera uma independência dos elementos do jogo neste sentido.
Atualmente, é praticamente um consenso que todos os agentes devem apresentar esta propriedade num certo grau;
Reatividade: Se refere a capacidade de reação do agente aos estímulos do ambiente.
Um sistema reativo mantém uma interação constante com o ambiente, respondendo às mudanças que ocorrem em ele;
Comunicação e Habilidade Social (interação):
Se refere a interação do agente com outros agentes (e possivelmente humanos) através de uma linguagem/ protocolo de comunica ção.
Em este trabalho, adota- se a noção de agente utilizada por Nareyek, que define um agente como uma entidade que possui objetivos, é capaz de perceber certas propriedades do ambiente onde se encontra, podendo executar ações específicas neste mesmo ambiente, sendo que algumas destas ações e/ ou percepções podem/ devem ser feitas através da cooperação com outros agentes.
Segundo Vicari e Girafa, existe uma taxonomiamuito utilizada na comunidade de IAD que aglutina os agentes em dois grupos:
Reativos e cognitivos.
A diferença entre eles está centrada no fato dos agentes reativos considerarem as informações correntes (momento) do ambiente para sua tomada de decisão, eles não têm &quot;memória «para armazenar vivências.
Os cognitivos podem aprender com suas experiências e são deliberativos (planejam e executam planos criados por eles).
Entretanto, não se deve inferir que por o fato de serem considerados reativos, os agentes são de simples modelagem ou fácil implementação.
Podemos encontrar agentes reativos muito sofisticados, como exemplo, nos jogos computadorizados.
Esta divisão funciona de forma mais para fins didáticos do que prático.
Observando um sistema multiagente fica difícil para o usuário diferenciar os agentes.
É uma questão interna de projeto (arquitetura) e, muitas vezes esta informação não está explícita na descrição do trabalho.
De acordo com Dámico, a arquitetura de agentes cognitivos é tipicamente incapaz de agir rápida e adequadamente perante situações não previstas, enquanto o agente cuja arquitetura é reativa é incapaz de descobrir alternativas para o seu comportamento quando a situação do mundo diverge bastante de seus objetivos iniciais.
A Tabela 2.1 estabelece um comparativo entre agentes reativos e cognitivos, no que tange suas características básicas.
Para solucionar as deficiências principais das duas arquiteturas descritas anteriormente, as arquiteturas híbridas, onde técnicas reativas e cognitivas são combinadas, foram propostas como alternativas.
Segundo Nareyek, os agentes híbridos utilizam um sistema de planejamento, que não é executado em tempo real (of- line), para a geração de planos em alto nível de abstração, enquanto decisões sobre alternativas de refinamento menos significativas de passos de planos são tratadas por sistemas reativos.
A escolha da ação é feita através de uma delibera-ção explícita sobre diferentes opções, por exemplo, usando um modelo interno simbólico do mundo, um plano ou mesmo alguma função que avalia uma ação conforme a sua utilidade Possuem um controle de ações feito através de regras do tipo situação-ação fixadas Um sistema de planejamento (planning system) interno baseado em refinamentos sucessivos utiliza as informações fornecidas por a representação do ambiente para construir um plano que atinja os objetivos do agente Demonstram excelente desempenho num ambiente em tempo real, mas às custas de um grande esforço prévio para a determinação de soluções específicas para as possíveis situações encontradas Problema está na sua falta de velocidade em ambientes de tempo real.&amp;&amp;&amp;
O tempo necessário para analisar as situações, construir e reutilizar planos, tipicamente pode tornar o agente muito lento para agir num ambiente em tempo real Construídos a partir de mecanismos de controle simples tais como máquinas de estados finitos ou conjuntos de regras do tipo estímulo/ resposta Originados dos sistemas de planejamento clássicos, os quais produzem uma seqüência de ações corretas (planos) para alcançar determinado objetivo Em geral não possuem objetivos explícitos que possam ser arbitrados e alterados durante a execução do sistema Possuindo um certo objetivo e o conhecimento de que uma certa ação o conduzirá a este objetivo, então o agente seleciona esta ação As subseções, a seguir, apresentam alguns exemplos de jogos que utilizam a tecnologia de agentes.&amp;&amp;&amp;
Analisaremos estes jogos para tratar de questões sobre a arquitetura do ambiente e dos agentes que o compõem.
Os jogos apresentados nesta seção foram intencionalmente escolhidos por apresentarem as características, a nível de projeto e implementação, adequadas aos objetivos deste trabalho.
Dividimos os jogos analisados em dois grupos:
Comerciais e oriundos de projetos acadêmicos.
Este último grupo em particular cita dois trabalhos realizados por o JEIA.
O trabalho de Cunha contém maiores detalhes sobre o estudo dos jogos descritos a seguir.
Os projetos dos jogos, apresentados a seguir, apresentam- se como resultados interessantes da aplicação da tecnologia de agentes em aplicações de jogos interativos.
Porém, fica claro que existe pouca preocupação por parte de a maioria dos desenvolvedores com alguns atributos importantes, característicos da área de Engenharia de Software, como a definição de uma arquitetura reutilizável para os agentes.
Esta falta de rigorismo/ formalismo contribui, de certa forma, para a resistência, por parte de os pesquisadores, em aceitar a pesquisa em Ia aplicada aos jogos computadorizados modernos.
Com estas ressalvas, busca- se motivar o leitor a refletir na questão dos jogos como testbeds.
Não buscando, com este enfoque, uma explicação por ter escolhido a área apesar de as dificuldades e preconceitos, como anteriormente destacado.
Creatures é um simulador de formas de vida num ambiente interativo, onde o jogador controla a evolução de criaturas.
As criaturas habitam um mundo de duas dimensões (2 D) estendido, implementado com várias camadas visuais, o que faz que alguns objetos visualizados aparentem estar um atrás de o outro (técnica referenciada por Grand como multi-plane depth cueing).
Em o mundo de Creatures existem vários tipos de objetos com os quais a criatura pode interagir de diferentes maneiras.
O sistema foi escrito com a utilização de técnicas de programação orientada a objetos, de forma que os objetos virtuais do jogo (brinquedos, comida, etc) possuem scripts associados que determinam como estes objetos interagem com outros objetos, até mesmo as próprias criaturas e outras partes estáticas do ambiente.
Alguns objetos são automatizados, como por exemplo elevadores que sobem e/ ou descem quando um botão é pressionado.
Segundo Grand, o jogo teve como objetivo geral a criação de agentes biológicos e sintéticos, cujo comportamento fosse suficientemente life-like, ou seja, próximo a o natural.
Para a modelagem e implementação dos agentes do jogo, representados por as criaturas, foram utilizadas diversas técnicas de Ia, como redes neuronais e A-Life.
A arquitetura interna das criaturas foi baseada na biologia animal.
Foi desenvolvida uma tecnologia denominada CyberLife, onde os agentes possuem redes neuronais controlando o sensoriamento e aprendizado e um conjunto de bioquímicas utilizado para coordenar o metabolismo de energia e regulagem hormonal do comportamento.
Tanto a rede neuronal quanto a bioquímica são geneticamente especificados para permitir que a evolução ocorra através da reprodução da população de cromossomos (atributos).
Quando o usuário posiciona o mouse sobre a janela do ambiente, o cursor se transforma numa mão humana, indicando que o usuário pode:
Mover objetos presentes no ambiente;
Atrair a atenção da criatura fazendo um movimento de abano com o cursor;
Clicar na criatura, o que gera um sinal de reforço positivo, de recompensa por suas ações;
Bater na criatura, o que gera um sinal de reforço negativo, de punição.
A medida que uma criatura vai envelhecendo, seu tamanho aumenta.
O ciclo de vida de uma criatura é geneticamente influenciado:
Se uma criatura consegue sobreviver até uma idade avançada (contabilizada em horas de jogo), os genes do envelhecimento podem ser ativados, desta forma matando a criatura.
Segundo Grand, as criaturas possuem sensores simulados de visão, som e tato.
Todos estes sensores foram modelados com a utilização de técnicas de aproximação semisimb ólicas.
Por exemplo, a simulação da visão não envolve uma simulação de conceitos de óptica ou processamento de imagens da retina.
Ao invés de isso, se um determinado objeto esta dentro de o campo de visão de uma criatura, um neurônio da rede neural representando a presença daquele objeto no campo visual se torna ativo.
Um objeto somente pode ser visto se os olhos da criatura estão apontando para a direção do objeto.
Sons são atenuados por a distância e são abafados por quaisquer objetos que estejam entre a criatura e a fonte que produz o som.
As criaturas podem aprender uma linguagem verbo-objeto simples, tanto através do usuário por o teclado, ou utilizando- se de uma máquina de ensino presente no ambiente, ou ainda através da interação com outras criaturas do ambiente.
O Guimo é um jogo, lançado oficialmente em 1997, por a empresa brasileira Jack in the
Box Computing. Em este jogo, o jogador é representado por uma espécie de lagarto que tem por objetivo salvar o mundo.
O ambiente do jogo é em 2 D, sendo que o personagem utilizado por o jogador, o Guimo, pode movimentar- se no ambiente tanto na horizontal quanto na vertical, o que faz este jogo pertencer ao estilo de jogos de plataforma.
Os personagens do jogo foram modelados como agentes reativos, exibindo um certo nível de inteligência em suas ações.
O jogo foi desenvolvido para ser utilizado no sistema operacional DOS, utilizando o paradigma de orientação a objetos.
A ferramenta de desenvolvimento utilizada foi o DJGPP, um ambiente de programação Gnu C/ C+ para DOS.
Praticamente todos os elementos do jogo são agentes, com exceção do cenário e alguns efeitos visuais, como no caso de fumaça.
Como o sistema foi desenvolvido com a utilização dos recursos da orientação a objetos, os elementos que são modelados como agentes reativos (Guimo, inimigos, projetis, etc) derivam de uma classe base de agentes, para então, implementar- se seus atributos e métodos específicos.
O Guimo também possui um tipo especial de personagem, denominado por Lykawka de inimigo evolutivo.
É uma classe de personagem diferente dos agentes reativos, que utilizam uma implementação equivalente a uma simplificação de uma rede neuronal.
Estes personagens acessam uma estrutura de dados chamada de DNA que contém pesos para a rede neuronal, e possuem um banco de dados contendo os comportamentos para jogadas posteriores.
Os agentes foram construídos seguindo o princípio das HFSM's.
A HFSM possui estados como Vagar, Retroceder e Atacar, sendo que cada um destes &quot;macro-estados «possuía uma FSM interna, que executava as ações especificadas.
Os agentes têm acesso a dados referentes ao cenário em sua volta, para sua movimentação.
Assim como no jogo Creatures, descrito na seção 2.7.1.1, os sensores de entrada dos agentes foram modelados com a utilização de técnicas de aproximação semi-simbólicas, como descrito em Lykawka.
De acordo com Lykawka, como um sistema multiagente, o jogo possui uma lista de todos os agentes, representada através de ponteiros para os objetos.
Para cada quadro (frame) do jogo, o sistema percorre a lista executando o método Run de cada um de eles.
Esse método é virtual e pode ser sobrescrito.
Os métodos Run podem então executar os comportamentos de cada agente, mas sem entrar em loop, ou seja, é executado apenas um comportamento por quadro.
Segundo Cunha, a utilização de agentes cognitivos em jogos computadorizados ainda é pouco explorada, mas já existem alguns jogos que implementam as técnicas presentes nas arquiteturas deliberativas, sendo Black &amp; White um dos mais significativos.
Black &amp; White consiste num jogo de estratégia onde o jogador controla e treina uma população de criaturas, de uma forma semelhante a Creatures e The Sims.
Para a realização de tal tarefa, os agentes foram desenvolvidos com base em uma arquitetura BDI, implementada em diferentes formas.
A idéia por trás desta metodologia era de evitar a imposição de uma estrutura uniforme para as representações utilizadas na arquitetura, de forma que a melhor forma de representação poderia ser escolhida de acordo com determinada tarefa.
Desta forma, crenças sobre os objetos foram representados simbolicamente, através de listas de pares atributo-valor, crenças sobre tipos de objetos foram representadas com a utilização de árvores de decisão, enquanto desejos foram representados através de perceptrons.
Observe- se que as crenças são representadas em estruturas simbólicas, enquanto desejos são representados por estruturas mais difusas, como apresentado por Woodcock.
A arquitetura do jogo foi elaborada de forma a permitir os mais variados tipos e situações que ativam o processo de aprendizado da criatura, como por exemplo:
Através do feedback do jogador, acariciando ou agredindo a criatura;
Quando comandos são passados a criatura:
Por exemplo, se é dada uma ordem para a criatura atacar uma cidade, a criatura assimila que aquele tipo de cidade deve ser atacado;
Através da observação:
Por exemplo, observando as ações das pessoas das cidades, do jogador, ou ainda de outras criaturas;
Com base em experiências anteriores:
Após realizar uma ação para satisfazer um motivo, é feita uma avaliação do quanto aquele motivo foi satisfeito.
Com base nesta avaliação, é feito um ajuste em pesos que representam a qualidade daquela ação e quão positiva foi a sua utilização para resolver a situação em questão.
Segundo Woodcock, para construir opiniões sobre uma situação, a criatura verifica dados sobre experiências anteriores da realização de uma ação para resolver a ação em questão.
No caso de uma criatura estar com fome, ela verifica o feedback de suas experiências em comer diferentes tipos de objetos e constrói uma árvore de decisão, na tentativa de categorizar os dados referentes a essas experiências.
A árvore de decisão é construída através da leitura dos atributos que melhor dividem as experiências de aprendizado em grupos com valores de feedback semelhantes.
A melhor decisão a ser tomada é aquela que minimiza a entropia2 que, no contexto do jogo, é uma medida de quão desordenados estão os valores de feedback.
O algoritmo utilizado para a construção dinâmica de árvores de decisão para reduzir a entropia é baseado no sistema ID3 de Quinlan.
A criatura decide qual o objetivo mais importante a ser atingido num determinado momento e qual o objeto mais útil nas proximidades da criatura para satisfazer tal objetivo.
Para tratar a questão da performance do sistema de planejamento utilizado, o espaço de busca da criatura é abstraído em duas camadas:
A de objetos grandes, tais como cidades, grupos de animais, vilarejos ou outras criaturas;
E a de objetos pequenos, tais como pessoas, pedras, ou animais tratados de forma individual.
Para manter a velocidade de processamento rápida o suficiente para uma boa performance do jogo, o processamento do sistema de planejamento é escalonado num determinado número de ciclos do jogo.
Quando o plano for construído, este é dividido em ações atômicas para então serem executadas.
Desta forma, vários elementos do jogo exercem influência sobre a evolução do comportamento das criaturas, desde o caminho que o jogador escolhe na estória do jogo, até a música e os sons presentes no ambiente.
Segundo os desenvolvedores de Black &amp; White, as criaturas deveriam ter um comportamento semelhante ao de uma pessoa, porém elas também deveriam ser úteis.
O requerimento do comportamento semelhante a um ser humano implica em autonomia, enquanto o requerimento de utilidade exclui muito da autonomia.
Para fazer um balanceamento destas propriedades, as criaturas iniciam suas vidas completamente autônomas, mas a medida que o tempo do jogo progride, através de treinamento, o jogador pode moldar o comportamento da criatura de forma que esta somente seguirá as ordens do jogador.
A medida que o treinamento prossegue, a criatura se torna mais focada em determinados objetivos, ou seja, a medida que a criatura se torna mais útil, seu comportamento se torna mais &quot;robótico».
A seguir serão apresentados três projetos de jogos educacionais cujos sistemas de Ia, além de utilizarem a tecnologia de agentes, aplicam conceitos de Engenharia de Software e foram desenvolvidos dentro de o grupo de pesquisa onde estre trabalho realizou- se.
O Multi--Cooperative Environment (MCOE), é um jogo educacional multimídia, criado como protótipo da tese de doutorado de Girafa.
O trabalho de tese produziu um protótipo baseado na arquitetura de um Sistema Tutor Inteligente (STI) multiagente, que é a principal contribuição da tese.
O STI é concebido como um SMA híbrido composto por um ambiente reativo e um núcleo cognitivo, que interagem entre si de maneira a ampliar as informações quantitativas e qualitativas dos 2 Segundo Wilson, a medida de entropia determina a quantidade média de informação presente num atributo de uma instância.
Em o MCOE, o aluno tem um ambiente onde aparecem inúmeros problemas ao longo de a sua sessão de trabalho, e ele deverá solucionar- los utilizando seu conhecimento prévio e combinar ferramentas na construção de uma estratégia de ação.
O jogo é composto por um lago onde existe um ecossistema formado por peixes, plantas, água e microrganismos que possuem um sistema de reprodução em equilíbrio até a intervenção de poluentes que provocam alterações no seu estado normal.
Estes poluentes aparecem de forma aleatória ao longo de o jogo e são combatidos através de ferramentas do personagem escolhido por cada aluno.
O aluno tem a liberdade de escolher a ferramentas que quiser, e pode ou não interagir com um colega para construir uma estratégia comum para resolver o problema da poluição do lago.
O MCOE utiliza técnicas de Ia tanto na simulação do ecossistema como no auxílio ao aluno.
Segundo Girafa, a arquitetura multiagente híbrida permite a exploração dinâmica e interativa do ambiente.
Ela é composta por agentes reativos, que compõem um Sistema Multiagente Reativo (SMAR), e agentes cognitivos, formando um Sistema Multiagente Cognitivo (SMAC).
Segundo Goulart, cada agente da SMAR implementa o comportamento reativo de um indivíduo do ecossistema do lago.
Desta forma, a cadeia alimentar desenvolve um comportamento autônomo semelhante ao de uma cadeia alimentar real, onde os peixes e demais seres podem morrer, nascer, se alimentar quando estão com fome, etc..
Já os agentes cognitivos SMAC, que representam o comportamento dos alunos e do tutor, são modelados utilizando uma arquitetura BDI.
Um outro jogo educacional interessante sob o ponto de vista da aplicação da tecnologia de agentes é o TCHÊ -- Uma Viagem por o Rio Grande do Sul, jogo desenvolvido no trabalho raciocínio lógico, a capacidade de tomada de decisão e habilidades psicomotoras, utilizandose da área da Matemática como tema, e tendo seu cenário inspirado em características do estado do Rio Grande do Sul (RS).
O jogo TCHÊ foi projetado de modo que o usuário busque realizar um conjunto de atividades num período de tempo pré-definido e configurável.
A possibilidade de ajustar o tempo conforme os objetivos dos alunos e do professor é um aspecto muito importante nos jogos educacionais e enfatizado na literatura, como descrito em Girafa.
Segundo Mazzorani, os situações modeladas envolvem o reconhecimento dos limites do ambiente onde os agentes estão se movimentando, assim como também a sua movimenta ção, prevenindo- se de colidir com os demais agentes e objetos que estão na interface.
Os agentes, quando alcançam qualquer um dos limites do ambiente, optam por um dos movimentos possíveis.
Um exemplo disso é quando o limite superior do ambiente é sensoriado por o agente que pode optar por uma mudança de direção (passando a dirigir- se na direção oposta ao limite inferior) ou, por continuar movendo- se no extremo num dos sentidos.
O sensoriamento de uma colisão é verificada sempre que o agente move- se, sendo que a ação que este terá quando de a sua verificação é a de manter- se na mesma direção e sentido, enquanto que o agente com que colidiria inverterá o seu sentido de movimentação.
O quero-Quero é um jogo desenvolvido durante o trabalho de conclusão de Comunello.
O trabalho é um ambiente educacional composto por um conjunto de atividades relacionadas a operações básicas de aritmética elementar.
O trabalho está vinculado ao grupo JEIA que busca desenvolver jogos educacionais computadorizados que exploram técnicas de Ia, considerando uma equipe interdisciplinar e uma situação real de sala de aula.
O trabalho foi desenvolvido num período de dois semestres letivos consecutivos.
O tema já estava previamente escolhido por a orientadora e buscava dar continuidade ao trabalho desenvolvido no ambiente TCHÊ de Mazzorani.
O jogo, destinado aos alunos das séries iniciais da escola elementar, possui cinco atividades monitoradas por um assistente que observa cada passo executado por o aluno de avaliando- o e classificando- o numa das quatro categorias de complexidade trabalhadas de acordo com a orientação da especialista.
As categorias definidas são:
Iniciante, intermediário, pleno e avançado.
A a cada início de um sessão de atividades do aluno com os jogos, os seus dados são resgatados a partir de um banco de dados previamente organizado por a professora.
Ela cadastra todos seus alunos e decide qual o nível que cada um de eles deve Ter quando de o início da primeira utilização do jogo.
Cabe a ela, também, informar ao programa de gerenciamento em qual nível de dificuldade o aluno se encontra e o conjunto de valores a serem associados às regras que o assistente vai utilizar para classificar o aluno no decorrer de as interações.
A fim de ampliar o potencial pedagógico do ambiente, em nível de utilização por parte de os alunos e professores, foi criado um assistente inteligente, modelado usando a tecnologia de agentes.
O objetivo deste assistente é fornecer ajuda aos usuários que interagem com o programa.
Todas as interações são armazenadas num banco de dados, a fim de serem analisadas a posteriori por o professor.
O registro do trabalho que ocorre durante as interações entre os alunos e o sistema, visa superar a limitação tradicional que acontece nas aulas do laboratório, onde o professor não pode supervisionar todos os estudantes, durante todo o tempo.
Logo, a mediação desempenhada por o ambiente permite que as interações ocorram de forma personalizada, levando em conta o estilo cognitivo de cada aluno.
A arquitetura do jogo é baseada em STI multiagente, onde o assistente que monitora o usuário durante a realização das atividades.
O objetivo de utilizar- se este assistente é avaliar o grau de conhecimento do aluno após a realização das tarefas.
O assistente emite um relatório para que o professor possa acompanhar o desenvolvimento do aluno.
Isto não é tratado no sistema de forma automática.
Gera- se um relatório para posterior uso do professor.
O ambiente foi modelado utilizando a tecnologia de agentes.
Arquitetura do sistema como um SMA De modo geral, os jogos de mercado não são concebidos como SMAs, ou então não utilizam técnicas com embasamento científico para construção de SMA's, porém, a medida que a Ia nos jogos vai ganhando importância, a tend ência é a que os jogos de mercado passem a implementar arquiteturas de SMA's utilizadas em jogos oriundos de pesquisas acadêmicas, onde o formalismo na construção dos jogos é maior.
Entretanto, pode- se dizer que os agentes presentes nos jogos de mercado, de modo geral, se comunicam de forma direta, e o controle é descentralizado.
A sociedade de agentes geralmente é heterogênea, fechada e baseada em leis.
Arquitetura dos Agentes Em geral, os jogos provenientes de projetos de pesquisa em universidades possuem uma definição mais formal de arquitetura para os agentes do que a utilizada nos jogos de mercado.
Porém, a medida que a importância da Ia aplicada nos jogos de mercado vai aumentando, a tendência é que a utilização de agentes com uma arquitetura melhor organizada aumente.
Documentação A documentação detalhada (metodologia de desenvolvimento, diagramação) está mais presente nos jogos oriundos de projetos acadêmicos do que em jogos de mercado.
Entretanto, os jogos de mercado possuem como documenta ção o design document, que se trata de um documento detalhado contendo as características e especificações do jogo num nível conceitual.
Além de servir como um guia de construção para toda a equipe de desenvolvimento do jogo (programadores, artistas, desenvolvedores de níveis, entre outros), o design document tem a função de apresentar o jogo para as empresas denominadas publishers, que distribuem o produto e o levam para a mídia.
A o final do desenvolvimento de um projeto de um jogo, o design do- cument, quando bem elaborado, representa o jogo na sua forma escrita.
Segundo Rollings, apesar de existirem diretrizes a serem seguidas na elaboração de um design document, não há uma metodologia formal para a elabora-ção deste tipo de documentação.
A medida que os jogos de mercado forem crescendo em complexidade, a tendência é que o design document passe a incorporar uma descrição formal da arquitetura do sistema.
Ambiente de programação utilizado Em geral, o ambiente de programação utilizado para a implementa ção do sistema é o mesmo em ambos os tipos de jogos.
Geralmente, por questões de performance, utiliza- se a linguagem C/ C+ no ambiente de programação Microsoft Visual C+ para Windows, a exceção do Guimo, que foi implementado no sistema DOS.
Em particular, para a implementação de agentes cognitivos, nos jogos acadêmicos são utilizados ambientes específicos, como o X-BDI.
Já para os jogos de mercado, em geral soluções próprias são elaboradas sem a utilização destes ambientes.
BDI, implementadas em ambientes bem específicos.
A comunicação entre os agentes dá- se, geralmente, de forma indireta, inspirado na arquitetura Blackboard, proposta por Hayes-Roth.
Os sistemas que se utilizam de comunicação direta entre os agentes lançam mão de protocolos personalizados e não se observou o uso de um padrão, tal como a Agent Apesar de a utilização do paradigma de orientação a objetos na implementação dos jogos, observamos que a maioria dos ambientes não apresenta uma documentação mais formal que permitiria a reutilização/ aplicação da sua modelagem/ solução, em contexto similar, de forma clara e objetiva.
Novamente, apenas nos jogos oriundos de projetos acadêmicos encontramos algum nível de preocupação neste sentido.
Como a pesquisa envolvendo metodologias para a especificação e desenvolvimento de SMA se encontra numa fase de definição, com diferentes propostas encontradas na literatura (Bastos, Zambonelli), observamos também a inexistência de uma metodologia para especificação dos jogos.
Desta forma, os jogos implementados com agentes seguem o estado corrente da maioria dos SMA, onde a questão da documentação não obedece um padrão.
No caso de os jogos este estado é ainda mais crítico, visto que a maioria destes jogos são produtos comerciais onde os procedimentos e o processo de design são, algumas vezes, intencionalmente omitidos, deixando apenas margem à inferência.
Este conjunto de restrições é, ao mesmo tempo, limitador do nosso trabalho e incentivador, uma vez que toda a contribuição que se fizer no sentido de tomar a pesquisa envolvendo jogos e agentes, terá significância num certo grau.
Após este levantamento, passou- se a analisar a questão envolvendo o comportamento dos personagens, análise esta que é apresentada a seguir.
Segundo Meneguzzi, uma das principais áreas que vem tomando impulso no processo de evolução dos jogos é a definição de comportamentos para as entidades contidas nos mundos virtuais dos jogos, os personagens.
Dentro de o contexto de pesquisa acadêmica em Ia, a utilização da tecnologia de agentes vem ganhando destaque nos últimos anos, uma vez que estes são vistos como entidades definidas com um alto grau de abstração, facilitando a modelagem de sistemas.
A questão do comportamento de um personagem pode ser tratada em dois níveis de abstração diferentes:
Considerando o nível da arquitetura dos agentes do sistema, o comportamento de um personagem pode ser considerado como a forma que o personagem executa ações no ambiente.
Por exemplo, um personagem pode realizar ações simplesmente reagindo a informações presentes em seus sensores de entrada, exibindo um comportamento reativo, ou ainda pode possuir a habilidade de traçar planos para atingir seus objetivos, exibindo um comportamento cognitivo.
A seleção do comportamento de um personagem se dá em dois momentos distintos:
Quando o personagem está interagindo com os objetos ou outros personagens do ambiente, ou ainda quando de uma intervenção por parte de o jogador.
Funge afirma que existem duas possibilidades para instruir um personagem sobre como se comportar:
Comportamento pré-definido:
As ações do personagem são pré-programadas.
Esta é uma característica típica de agentes reativos;
Comportamento orientado a objetivo:
Dado um objetivo, o personagem escolhe as ações que fazem com que o personagem se aproxime mais do objetivo.
Esta é uma caracter ística típica de agentes cognitivos.
Basicamente estas duas classificações se apresentam como formas para definir comportamentos dos personagens.
A distinção entre estas duas classificações reside no poder que o personagem tem de selecionar ações de forma determinística (pré-determinada) ou nãodetermin ística (quando o personagem escolhe uma ação ele também leva em consideração as outras ações que poderia ter escolhido).
Considerando um nível de abstração mais alto, o comportamento de um personagem pode ser tratado no nível conceitual.
A maioria dos jogos computadorizados interativos, quando em fase de concepção, são criados juntamente com um script, escrito no design document.
Este determina um roteiro de ação a ser desenvolvido no jogo.
O script do jogo geralmente define um conjunto de personagens que farão parte do ambiente do jogo.
Normalmente, a quantidade de personagens definidos num script varia de acordo com o estilo do jogo.
Os jogos dos tipos Adventure e RPG, como por exemplo Diablo 2 e Baldurs Gate II:
Shadows of Amn, possuem muitos personagens, cada um de eles possuindo características únicas e script relacionado.
O papel de cada um destes personagens no contexto do jogo determina uma série de atributos pertinentes ao personagem em questão.
De entre o conjunto de atributos está sua aparência e seu comportamento.
Por exemplo, os personagens que têm a função de auxiliar o jogador geralmente possuem uma aparência bondosa3, ou que realce seus traços positivos.
Eles possuem um comportamento baseado nos benefícios e na sua utilidade para o jogador, referenciado por alguns desenvolvedores de jogos como comportamento orientado à utilidade (utility-- driven behavior, ou ainda companion Ai).
Em esse nível conceitual, o que se entende por comportamento num personagem de um jogo computadorizado é a forma como este personagem atua dentro de o contexto do jogo.
É importante destacar que isto não se trata de uma definição de comportamento, mas sim de uma contextualização da palavra, no que tange a sua utilização em jogos computadorizados.
As técnicas de Ia utilizadas na modelagem e implementação dos jogos variam de acordo com os diferentes tipos de personagens existentes.
De modo geral, o papel mais evidente assumido por a Ia nos jogos é para o controle de non-- player characters (NPCs), ou seja, aqueles personagens que não são controlados diretamente por o jogador.
Segundo Fairclough, os diferentes tipos de NPCs, bem como as diferentes aplicações da Ia para controle de personagens, podem ser classificados da seguinte forma:
Oponentes táticos (Tactical Opponents):
Provavelmente a aplicação mais comum da Ia para regular o comportamento de personagens em jogos se encontra no controle de 3A questão da aparência visual de um personagem não será detalhada, visto que não é foco deste trabalho.
Levando- se a questão das interfaces para um outro trabalho de cunho interdisciplinar, envolvendo pesquisadores da área de comunicação, artes plásticas e CG.
Parceiros (Partners):
A Ia pode ser utilizada para controlar personagens que auxiliam o jogador de alguma forma.
Alguns jogos, como o Half-Life, por exemplo um jogo de ação onde o jogador deve escapar de um laboratório infestado de alienígenas e militares, utilizou técnicas de Ia para controlar diferentes parceiros para prestar serviços ao jogador, como por exemplo os cientistas e guardas, que ajudavam o jogador a acessar salas trancadas, ou a destruir inimigos.
Os parceiros também são personagens importantes em outros estilos de jogos, como em RPGs e jogos de esporte, por exemplo;
Personagens de suporte (Support Characters):
Personagens de suporte são geralmente utilizados para complementar o mundo em o qual um jogo é ambientado, podendo assumir papéis que são importantes para o jogo, porém que não requerem a definição de um comportamento complexo.
Por exemplo, o ferreiro presente no jogo Diablo 2 vende e/ ou conserta itens utilizados por o jogador.
Porém, não necessariamente ele precisa se engajar em diálogos complexos;
Oponentes estratégicos (Strategic Opponents):
Os oponentes estratégicos possuem a habilidade de realizar planos e utilizar raciocínio a longo prazo (long-term reasoning) para então confrontar o jogador.
Este tipo de oponente se faz presente em jogos de estratégia e God-games.
São considerados como um nível acima de os oponentes táticos;
Unidades (Units):
Vários estilos de jogos utilizam o conceito de units para representar os personagens, em particular os jogos de estratégia, onde uma unit pode ser representada por um tanque, um soltado, um cavaleiro, enfim, qualquer NPC que possa ser separado de um grupo e entrar em combate por vontade própria, ou ainda recebendo comandos do jogador.
A Ia para tratar as units engloba implementação de técnicas de pathfinding não só para evitar obstáculos físicos, mas também para evitar oponentes;
Comentaristas/ Diretores (Commentators/ Directors):
Além de os papéis mais óbvios assumidos por a Ia para controlar personagens, a Ia pode ser utilizada para controlar personagens que assumem papéis mais externos.
Por exemplo, um sistema de Ia é necess ário para que a fala de um comentarista de um jogo de esporte seja condizente com a ação que ocorre no jogo.
Outros exemplos de usos de técnicas de Ia para controlar elementos do jogo que estão sob esta categoria:
Câmeras inteligentes, trilhas sonoras que refletem a ação que ocorre no jogo num determinado momento e ainda o uso de diretores inteligentes, que fazem com que o desenrolar dinâmico do jogo se mantenha consistente.
Observa- se que o comportamento de um personagem presente num jogo computadorizado é diretamente dependente do papel que este assume no contexto do jogo em questão.
Sendo que este comportamento pode variar entre dois extremos:
Um comportamento típico de seres dotados de inteligência de alto nível, semelhante ao de um ser humano, e um comportamento de seres não dotados de inteligência ou com um nível muito baixo, característica de seres inanimados.
Por exemplo, uma cadeira, na maioria dos jogos, não tem nenhum objetivo a cumprir a não ser ficar parada.
Uma possível forma de comportamento que esta cadeira poderia assumir seria um comportamento reativo, como por exemplo, se a cadeira for atingida por alguma explosão, ela deve responder imediatamente se danificando ou eventualmente sendo destruída.
Porém, dependendo do papel que esta cadeira assume no jogo, ela poderia assumir um comportamento diferenciado, como por exemplo, voar, ou ainda sair andando.
O que se busca, em termos de comportamento para personagens inteligentes de jogos computadorizados, é aumentar o nível de realismo nas interações que estes personagens possuem com o jogador e com o ambiente onde estão inseridos.
Este aumento de interatividade reflete numa maior complexidade de modelagem e implementação do sistema como um todo.
Logo, para tratar esta questão, muitos desenvolvedores freqüentemente utilizavam- se de artifícios de programação que fizessem com que o jogo &quot;enganasse «o jogador, fazendo com que personagens inimigos tivessem acesso a dados como a posição do jogador num mapa, por exemplo.
Estes fatores associados ao aumento da interatividade influem diretamente na jogabilidade 4 do jogo, em especial o aumento da interatividade entre o personagem e o jogador, fazendo com que este sinta que está interagindo com um personagem que demonstra ser inteligente, aumentando o grau de inserção do jogador no mundo virtual proposto por o jogo, o que torna a experiência de entretenimento mais prazerosa.
Alguns jogos conseguiram associar uma boa jogabilidade com uma modelagem e implementação interessante dos seus sistemas de Ia, no que tange a pesquisa e aplicação de técnicas de Ia em ambientes interativos.
É o exemplo de Creatures, Guimo e Black and White, cujas implementações foram apresentadas anteriormente.
Projetando agentes cognitivos As seções a seguir descrevem projetos de pesquisa que atualmente são utilizados como ferramentas para o desenvolvimento de agentes cognitivos.
De entre as ferramentas analisadas, o X-BDI foi selecionado para ser utilizado neste projeto, por sua característica de implementar somente o kernel cognitivo do agente (como veremos adiante), além de ser uma ferramenta produzida e mantida por membros do Grupo de Pesquisa em Ia da PUCRS.
Segundo Laird, a Soar é uma arquitetura unificada para o desenvolvimento de sistemas que exibem um comportamento inteligente.
Construída com base em teorias sobre a capacidade humana de resolução de problemas (human problem solving theory), a arquitetura Soar fornece estruturas computacionais fixas, em as quais o conhecimento pode ser codificado e utilizado para produzir ações em busca de objetivos (um comportamento deliberativo).
A arquitetura Soar tem, como objetivo geral, simular todas as características presentes num agente inteligente genérico, tais como:
Resolver os mais variados tipos de tarefas, desde as rotineiras até tarefas com objetivos mais complexos;
Representar e utilizar formas apropriadas de conhecimento, tais como procedural, declarativo, entre outras;
Empregar uma ampla variedade de métodos de resolução de problemas;
Interagir com o ambiente externo;
Conhecer todos os aspectos das tarefas a serem executadas, bem como seu desempenho em elas.
Segundo Laird, a arquitetura Soar possui uma representação simbólica explícita de suas tarefas, as quais são manipuladas através de processos simbólicos.
A arquitetura codifica o conhecimento sobre o ambiente de cada tarefa em estruturas simbólicas e tenta utilizar este conhecimento para guiar seu comportamento.
Possui também um esquema genérico de objetivos e sub-objetivos para representar o que o sistema deseja atingir, além de controlar o seu comportamento.
De acordo com Laird, a arquitetura Soar é uma arquitetura para resolução de problemas (problem solving architecture), pois todas as tarefas enviadas à arquitetura são resolvidas através do uso de espaços de problema (problem spaces), ou seja, um espaço com um conjunto de operadores que se aplicam a um determinado estado e que, quando aplicados, determinam um novo estado.
Logo, toda a resolução de tarefas toma a forma de uma busca heurística.
A Figura 3.1 exibe a estrutura da arquitetura Soar.
De acordo com Laird, a memória de trabalho (working memory) armazena todo o processamento atual da resolução do problema, e contém três componentes:
Uma pilha de contexto (context stack), que especifica a hierarquia de objetivos ativos, espações de problema, estados e operadores;
Objetos (objects), tais como objetivos e estados (e seus sub-objetos);
Preferências (preferences) que codificam o conhecimento para as funções de busca e controle.
A estrutura de processamento é composta de duas partes:
A memória de produção (production memory) que é um conjunto de produções que podem examinar e manipular qualquer parte da working memory;
E o procedimento de decisão (decision procedure), um processo fixo que examina as preferences e o context stack, modificando o context stack.
As produ-ções e a decision procedure são combinadas para implementar as funções de busca e controle.
Dois outros mecanismos fixos são exibidos na figura:
O o gerenciador da memória de trabalho (working-- memory manager), que exclui elementos da working memory;
E o mecanismo de agrupamento (chunking mechanism), que adiciona novas produções.
De entre os projetos onde foi utilizada a arquitetura Soar, destacamos o projeto que serviu de base para a elaboração deste trabalho, o projeto de pesquisa em human-level Artificial Intelligence (Ai), coordenado por Laird, onde a arquitetura Soar é integrada com o ambiente do jogo Quake II, como mostra a Figura 3.2.
O projeto envolve a criação de bots1 inteligentes para desafiar o jogador.
O bot criado com o uso da arquitetura Soar se comunica com o jogo através da camada interface DLL, que é na verdade uma interface modificada com o jogo, estendida para suportar os comandos da arquitetura Soar.
A arquitetura determina os comportamentos e ações (actions) do bot, enquanto este devolve à arquitetura conjuntos de informações referentes ao sensoriamento do agente no ambiente do jogo (perception), desta forma utilizando o jogo como ambiente para teste de implementações de comportamentos complexos feitos na arquitetura Soar.
O X-BDI é uma ferramenta que permite a descrição formal de agentes cognitivos, sendo ao mesmo tempo, uma linguagem para a implementação de agentes.
Segundo Mora, sua proposta disponibiliza um sistema formal cuja linguagem é adequada para a representação de conhecimento.
A ferramenta permite ao projetista construir o kernel cognitivo do agente, ou seja, a parte do agente responsável por o processo deliberativo.
O sistema fornece suporte 1 Personagens do jogo, controlados por computador.
O modelo possui duas características:
Serve como um ambiente de especificação de agentes, em que é possível definir formalmente um agente através da descrição dos seus estados mentais e de suas respectivas propriedades.
O ambiente pode, também, fazer a verificação destas propriedades;
Serve como um ambiente de implementação de agentes.
O X-BDI é um ambiente onde se formaliza e se executa o agente, verificando se o comportamento desejado ocorreu ou não, como descrito por Zamberlam.
Segundo Mora, a abordagem utilizada no X-BDI consiste em adotar uma perspectiva do agente na construção do modelo, ou seja, ao invés de visualizar o modelo simplesmente como uma ferramenta a ser utilizada por o projetista, ver- lo também como uma ferramenta a ser utilizada por o agente para representar os estados mentais e raciocinar sobre eles.
A Figura 3.3 exibe a arquitetura do X-BDI, como destacado em Goulart.
Segundo Zamberlam, o X-BDI possui um ambiente de implementação com alto nível de abstração (os estados mentais), o que reduz a complexidade no desenvolvimento de sistemas baseados em agentes.
Isto significa que o projetista da área de domínio (aplicação) apenas precisa colocar suas heurísticas a respeito de o processo a ser modelado, a fim de guiar o seu comportamento.
A linguagem do X-BDI possui baixa complexidade no que diz respeito à sintaxe, facilitando o trabalho de especificação e implementação de agentes baseados na arquitetura BDI.
Segundo Mora, o X-BDI, como modelo formal de agentes, reduz a distância entre a especificação e implementação de agentes.
Adotando a Programação Lógica Estendida (Extended Logic Programming (ELP)) como formalismo de apoio, preserva- se tanto as principais características dos modelos formais (habilidade para definir e verificar agentes formalmente), como fornece um mecanismo para o raciocínio dos agentes.
Maiores detalhes sobre a ELP podem ser obtidos no trabalho de Zamberlam.
Para fins de exemplificação, a situação abaixo mostra o uso do X-BDI para fins de modelagem e implementação de um agente BDI.
O texto a seguir foi extraído do original de Móra «Em o edifício de gabinetes dos professores de uma Universidade, um robô autônomo tem por função transportar documentos entre a secretaria e os gabinetes.
Este robô deve, ainda, conduzir os visitantes que chegam ao edifício até o gabinete do professor com quem este deseja falar.
Em um dado instante, o robô recebe um chamado do gabinete 310 para apanhar um envelope e entregar- lo à secretária, no andar térreo, onde o robô encontra- se naquele instante.
O robô, então, planeja um curso de ações capaz de levar- lo a cumprir sua tarefa:
Ele deslocarse-á até o elevador e, após acionar e aguardar a chegada do elevador, subirá ao terceiro andar e apanhará o envelope, levando- o de volta à secretaria.
Elaborado o plano, o robô passa a ação e começa a executar- lo.
Não ocorrendo nenhum contratempo, o robô chega ao gabinete 310, apanha o envelope e começa o caminho de volta.
A o chegar ao elevador, no entanto, o robô observa que há algum problema, pois ao pressionar o botão, a luz deste não se acende.
Não podendo usar o elevador, o plano previamente traçado por ele não pode mais ser executado.
Assim, o robô reconsidera suas opções e decide tomar a rampa de acesso aos andares e, através de ela, chegar a secretaria e entregar o envelope.
Possuindo novamente um plano de ação, ele passa a executar- lo.
Enquanto está a caminho, o robô recebe duas novas ordens:
Levar um envelope da secretaria para o gabinete 330 e conduzir um visitante ao gabinete 312 (ambos no terceiro andar).
Analisando suas novas ordens, ele conclui ser mais adequado fazer a entrega do envelope que ele tem no momento antes de atender as duas outras ordens (pois ele terá que ir à secretária de qualquer forma para encontrar o visitante e apanhar o novo envelope).
Enquanto se dirige a secretaria, o robô constrói um plano para atender suas novas ordens:
Ele apanhará o envelope, encontrará o visitante e conduzirá- lo- ao gabinete 330, para depois fazer a entrega do envelope.
Existiria outra opção, qual seja entregar o envelope primeiro.
Mas ele tem como prioridade atender aos visitantes, para não fazer- los esperar ou caminhar desnecessariamente.
Após cumprir sua ordem corrente, o robô passa a executar seu novo plano.
No entanto, enquanto se dirigia ao gabinete 312, após conduzir o visitante ao gabinete 330, o robô sensora uma baixa carga em suas baterias.
Imediatamente, ele dirige- se ao ponto de recarga mais próximo.
Feita a recarga da bateria, ele retoma o plano interrompido, entrega o envelope e retorna a secretaria.»
A listagem da Figura 3.4 exibe uma implementação reduzida, em X-BDI, da situação descrita acima.
Os trabalhos que utilizam o X-BDI como ferramenta para construção de agentes são o MCOE, criado por Girafa, Editor-BDI (E-BDI), de Zamberlam, que será descrito no próximo item, Extended-MCOE (E-MCOE), de Goulart, uma proposta de extensão da arquitetura apresentada em Girafa e, a proposta de extensão da metodologia M-DRAP utilizando estados mentais, apresentada por Roza.
Identity (rbt).
Act (rbt, levar (visitante)) causes bel (rbt, entrada (CARTAVISITA)), bel (rbt, acompanhando (CARTAVISITA)).
O E-BDI é a instância física (editor) associado à técnica para programar agentes BDI, criada por Zamberlam e Girafa.
O editor, associado à ferramenta X-BDI, permite ao projetista visualizar definir o conjunto de estados mentais BDI e suas inter-relações, através de uma interface textual e gráfica.
O E-BDI, apresentado na dissertação de Zamberlam, busca contribuir para tornar a programação de agentes BDI utilizando o X-BDI mais inteligível, operacional e de mais fácil entendimento para os diversos grupos de pesquisa.
Desta forma, o editor permite:
A visualização e a organização das informações (os estados mentais desejos e crenças) a serem processadas no kernel cognitivo do X-BDI;
Facilitar a descrição declarativa dos estados mentais dos agentes que serão necessários para a especificação das ações destes agentes;
A análise dos estados mentais definidos, detectando de forma estática algumas inconsist ências (contradições e &quot;deadlocks&quot;).
A dificuldade de se modelar/ implementar agentes BDI se concentra na descrição do conjunto de estados mentais conectados a agente, pois essa descrição segue um paradigma declarativo, ou seja, ao invés de se descrever passo a passo, proceduralmente, o comportamento do agente, descreve- se os seus desejos e crenças, sendo seu comportamento gerado a partir de esta descrição.
Se por um lado descrições declarativas tendem a ter um nível de abstração mais alto, facilitando a modelagem, por outro, à medida que as descrições crescem, visualizar e depurar o modelo tende ser razoavelmente complexo.
O E-BDI foi proposto para atender aos programadores de agentes BDI.
A Figura 3.5 exibe a tela do E-BDI, composta por quatro janelas principais.
Janela de Controle:
Comandos básicos de gerência de arquivo, bem como comandos para controlar a análise sintática e a visualização das demais janelas;
Janela de Texto:
Onde o projetista digita/ escreve o código X-BDI;
Janela de Visualização Gráfica: Onde os diagramas, contendo seus estados mentais e seus relacionamentos, são gerados;
Janela de Mensagens:
O editor permite a análise sintática das sentenças digitadas, sendo então, na janela de mensagens, a exibição dos possíveis erros percebidos.
Como exemplo da utilização do E-BDI, o trecho de código da Figura 3.6 representa a descrição de um agente BDI.
Associada ao código-fonte descrito na Figura 3.6, a Figura 3.7 exibe a representação gráfica do agente, relacionando as crenças, desejos e intenções num diagrama, contendo os estados mentais do agente em questão.
Segundo Zamberlam, o X-BDI é uma ferramenta em fase de consolidação, necessitando que uma série de refinos e recursos sejam incorporados, afim de que sua utilização seja mais abrangente e acessível.
Identity (rbt).
De o conjunto de ferramentas descrito acima, esta- se utilizando neste trabalho o X-BDI e o E-BDI.
Estas duas ferramentas foram criadas por membros do grupo de pesquisa em Ia do PPGCC/ PUCRS.
A escolha do X-BDI se deu por os objetivos deste trabalho, que consistem, também, em tratar a saída do X-BDI.
A opção por utilizar o editor E-BDI associado ao XBDI deu- se por conseqüência da escolha da primeira ferramenta, visto que o E-BDI facilita a programação de agentes BDI através do X-BDI.
Score: Integrando jogos com Agentes O projeto Score utiliza o jogo UT como ambiente de teste (testbed).
UT foi criado por a ao estilo de jogos de ação em primeira pessoa, onde o jogador visualiza o ambiente por a perspectiva do personagem.
A funcionamento do sistema é relativamente complexo, considerando o contexto de modelagem e implementação dos jogos comerciais.
O enfoque é semelhante ao do funcionamento da linguagem de programação Java, consistindo de uma Máquina Virtual, um compilador e código de bytes, como mostra a Figura 4.1.
O trecho marcado na figura como &quot;Init «compila o script com o código-fonte para código de bytes e carrega- o na Máquina Virtual, para ser executado.
Em este ponto, o loop de execução do jogo inicia.
Durante a execução do jogo, o estado do sistema muda diversas vezes.
A Máquina Virtual executa funções e chamadas de serviços da engine até que seja encontrada a requisição &quot;EndGame», marcando o término de execução do sistema, como descrito no trabalho de Cunha.
O trecho &quot;Script «exibido na Figura 4.1 representa a linguagem de script integrada ao UT, chamada UnrealScript (US).
A linguagem foi criada com o intuito de fornecer uma ferramenta de programação de jogos personalizada, com suporte nativo a diversos atributos freqüentemente presentes em implementações de projetos de jogos, tais como conceitos de estados, tempo e comunicação via rede.
A linguagem foi utilizada por a equipe de desenvolvimento do UT durante o desenvolvimento do jogo, sendo atualmente utilizada por muitos usuários que possuem conhecimentos em programação.
A linguagem é orientada a objetos, misturando características de linguagens de programa ção como C+ e Java.
O código criado na linguagem é compilado para código de bytes utilizando- se a ferramenta UCC.
EXE, um compilador criado por a equipe de desenvolvimento do UT para ser utilizado com a linguagem, e executado por a Máquina Virtual que, na abstra ção da Figura 4.1, pode ser vista como a engine do jogo.
O trabalho de Cunha descreve em detalhes as características da linguagem.
A linguagem é associada a uma poderosa ferramenta de edição (fornecida com o jogo) chamada UnrealEd (exibida na Figura 4.2), e pode ser acessada através deste editor.
A equipe de desenvolvimento do UT utilizou o UnrealEd durante a fase de implementação do UT, e após o lançamento do jogo, tornou- o disponível para os usuários, de forma que estes pudessem utilizar- lo para manipular os elementos do jogo.
Todos os elementos do jogo (música, efeitos de som, texturas, personagens, armas e Ia) podem ser manipulados através do editor e/ ou através da linguagem US.
A Figura 4.2 exibe duas janelas relacionadas com o código-fonte do jogo:
A janela da esquerda exibe uma parte da hierarquia de objetos do jogo, enquanto a janela da direita exibe um trecho de código US da classe pawn, que representa um elemento de jogo que possui comportamento controlado por técnicas de Ia.
O usuário pode modificar o código-fonte de uma classe, ou ainda criar uma nova classe, herdando propriedades de outras superclasses e então recompilando o códigofonte 1, desta forma alterando o conteúdo do jogo.
O UT foi escolhido para ser utilizado no projeto Score por uma série de fatores:
O UT faz parte de uma categoria de jogos que possuem grande parte do código-fonte aberto, sendo que o código correspondente a Ia do jogo é disponibilizado;
O UT e a linguagem US possuem documentação on-line elaborada por a própria empresa;
O UT é totalmente orientado a objetos, diferente de outros jogos de mercado também utilizados em projetos de pesquisa acadêmicos (como por exemplo Quake II Arena), que foram implementados com variações da linguagem C;
A característica de orientação a objetos do UT permite que o programador modifique o comportamento do jogo sem possuir conhecimento detalhado do mesmo, separando o código da engine do código referente a a lógica do jogo.
O grupo de pesquisa em Ia da PUCRS tem a sua disposição duas ferramentas para o auxílio na modelagem e implementação de agentes cognitivos:
O X-BDI e o E-BDI (descritos no capítulo 3).
A Figura 4.3 exibe a proposta do sistema Score.
O sistema X-BDI possui um nível de abstração mais alto do que a linguagem US, fazendo com que esta ferramenta seja uma alternativa para a modelagem de agentes cognitivos.
Logo, é necessário construir uma camada intermediária para estabelecer a comunicação entre a interface programável do jogo com o kernel cognitivo do agente.
Para estabelecer este nível de comunicação, implementou- se um tradutor.
Este tradutor tem a função de mapear as saídas do jogo, codificadas em US, como entradas para o XBDI, representando o sensoriamento do ambiente por parte de o agente, codificado no padrão utilizado por o X-BDI, para ser então processado por o mesmo.
O tradutor também faz o processo inverso, isto é, traduzir os planos gerados por o X-BDI em seqüências de ações, codificadas em US, para serem executadas por o personagem do jogo.
Para a construção do protótipo, foram selecionados trechos de código US que representam estados de um personagem da classe ScriptedPawn, que engloba personagens controlados por a linguagem US.
Estão- se utilizando resultados de trabalhos anteriores obtidos por Mora, Girafa, Vicari, Zamberlam e Goulart sobre o controle de comportamentos de personagens de jogos computadorizados interativos.
É utilizado o enfoque de estados mentais (modelados com o uso do editor E-BDI) de uma forma semelhante ao projeto realizado por Laird, onde a arquitetura Soar2 foi utilizada.
Exemplos de código em US e uma descrição de um agente X-BDI são exibidos na Tabela Como é exibido na Tabela 4.1, a linguagem do X-BDI é semelhante a linguagem PROLOG, possuíndo baixa complexidade no que diz respeito a sintaxe.
O trecho de código US mostrado acima exibe a implementação nativa do conceito de estados, utilizado principalmente nas implementações de técnicas de Ia do UT.
A programação de estados em US possui diversos benefícios, de entre eles a utilização das chamadas funções latentes, que serão descritas a seguir.
Soar é integrada com o ambiente do jogo Quake II.
Para maiores detalhes sobre o conceito de estados em US, bem como outras informações sobre a sintaxe da linguagem, pode- se consultar o trabalho elaborado por Cunha.
Segundo Sweeney, até o surgimento da linguagem US, a noção de programação de estados estava associada ao estágio de modelagem de uma aplicação.
A linguagem US suporta a programação de estados no nível de linguagem, através do comando state.
Com este comando, o programador pode definir estados do personagem, onde este executa determinadas ações.
O trecho de código exibido na Figura 4.4 ilustra a utilização do comando state para a definição do estado MeleeAttack, que representa o ataque corpo-a-corpo de um personagem.
Através do uso de estados, pode- se implementar uma mesma função de diferentes formas dentro de diferentes estados, de forma semelhante à idéia de sobrecarga de método, na orientação a objetos;
Dentro de um estado, pode- se utilizar as chamadas funções latentes.
Uma função latente é, no contexto de jogos computadorizados interativos, uma função que executa e retorna após ter passado um determinado tempo de jogo.
Isso permite ao programador implementar código sensível a tempo, ou seja, pode- se implementar de forma linear um programa da mesma forma como este é planejado conceitualmente;
Devido a possibilidade de se efetuar a sobrecarga de métodos, tanto em classes filhas quanto em estados, a medida que o código se torna complexo, fica difícil encontrar qual instância do método sobrecarregado que será executada num determinado momento.
O conceito de estados implementado na linguagem US define seqüências de ações as quais podem ser associadas às ações realizadas por um agente programado em X-BDI.
As condições que determinam se um agente irá ou não entrar num determinado estado podem ser associadas com crenças de um agente programado em X-BDI.
Os desejos do agente podem Para testar a funcionalidade do protótipo do tradutor, foi elaborado um estudo de caso, que envolve a seleção de um determinado comportamento de um personagem do jogo.
Para tanto, foi criada uma nova classe de personagem, através da herança da classe Brute, que implementa um personagem inimigo do jogo.
De a nova classe criada, denominada Sewald, foi selecionado, para modelagem e implementação, o comportamento do personagem que corresponde ao estado de ataque corpo-a-corpo, denominado MeleeAttack.
Em este estado, o personagem não utiliza nenhuma arma, apenas tentando atingir o jogador com socos e/ ou pontapés.
Em a hierarquia de classes do UT, a classe Sewald é filha da classe Brute, como mostra a listagem abaixo:
Onde: Object:
Classe base do jogo, de onde todos os outros objetos derivam;
Actor: Representa todos os objetos que são visíveis no ambiente do jogo;
Pawn: Representa um personagem controlado por computador;
ScriptedPawn: De esta classe derivam todos os personagens, controlados por computador, que possuem um código em linguagem US para controlar suas ações (comportamento);
Brute: Um personagem com comportamentos específicos, gráficos e sons associados.
Para o personagem entrar no estado MeleeAttack, ele necessita satisfazer algumas condi-ções:
Quando o personagem toca em alguma coisa, e o objeto tocado é um personagem inimigo, ou ainda o jogador;
Quando o personagem se encontra pronto para atacar;
Quando a distância entre o personagem e o inimigo (ou o jogador) é suficientemente pequena para o personagem atingir o inimigo em questão com um golpe;
Casos particulares, como quando o personagem estiver entrando no estado TakeHit, ou ainda quando estiver no próprio estado MeleeAttack, no método AnimEnd.
Cada uma destas situações representa, no código-fonte do jogo, um número de condições a serem testadas.
O protótipo do tradutor foi implementado como um módulo caixa preta3 (black box), ou seja, os resultados processados por o X-BDI entram como parâmetros no módulo e saem convertidos em comandos no padrão da linguagem US, e vice-versa.
Para que houvesse a comunicação, foram necessárias, além de a codificação do tradutor e do agente X-BDI, pequenas alterações no código fonte do UT para que este disponibilizasse, sob a forma de arquivo, as informações relevantes para o agente.
Em o que tange as alterações feitas no código-fonte do UT, nos arquivos de log do UT, podese Através deste comando, são gravadas, no arquivo de log chamado UnrealTournament.
Log, marcadores (flags) que indicam que as condições que fazem o agente entrar num determinado estado (neste caso, no estado MeleeAttack) foram atingidas.
Como por exemplo, para a crença BumpInEnemy (OK), o conjunto de condições avaliado e gravado no arquivo de log envolvem a detecção de objetos no ambiente, por parte de o personagem;
O objeto Other é um personagem o inimigo atual do personagem, retorna True.
Quanto a o funcionamento do protótipo do tradutor, este possui duas funções básicas:
Converter condições para a entrada num determinado estado para crenças do agente.
Converter desejos do agente em transições de estado;
Para o primeiro caso, foi elaborado um conjunto de associações entre as crenças do agente BDI e as condições que antecedem a entrada num estado, por parte de o personagem.
No caso de o estado MeleeAttack, foram feitas as seguintes associações, conforme mostra a Tabela Cada uma destas condições aparece diversas vezes no código-fonte (US) associado à parte da Ia do personagem.
Contudo, este fato não se mostra como relevante para o processo 3 Um módulo, subrotina ou programa autocontido e independente, designado para realizar uma função em particular.
O usuário não tem conhecimento de sua estrutura interna, mas pode utilizas- lo através da passagem de um conjunto de parâmetros de entrada.
Em o segundo caso, a tradução é direta:
Os desejos do agente BDI são diretamente associados exemplo:
A execução do sistema como um todo ocorre no momento em que o tradutor efetua uma do jogo atingiu o determinado conjunto de condições (significando que o agente em questão vai entrar no estado correspondente).
Seguindo o exemplo dado anteriormente, o conjunto de condições citado para a crença BumpInEnemy é representado no arquivo de log do UT que um determinado conjunto de condições foi encontrado.
O tradutor converte, então, este flag num comando, com uma sintaxe adequada para ser tratada por o X-BDI.
Este comando é informado ao X-BDI via o arquivo de coreografia Coreo.
A. Seguindo o exemplo dado indicando que o personagem do jogo se encontra nas condições necessárias para que o agente X-BDI tome como crença o item 1 da Tabela 4.2, BumpInEnemy (OK).
O trecho de código exibido na Figura 4.5 trata esta situação.
As variáveis fpUT e fpOut representam, respectivamente, os arquivos UnrealTournament.
Log e o arquivo Coreo_ A. Em o caminho inverso, o agente interpreta, através do seu código-fonte.
O módulo caixa-preta do tradutor recebe dois parâmetros via linha de comando:
O tipo de conversão a ser efetuado e o nome dos arquivos de entrada e saída.
Os parâmetros que identificam o tipo de conversão são:
Ux: Converte de US para X-BDI.
O módulo lê do arquivo de log do UT (passado como arquivo de entrada) e converte para código X-BDI, gravando num arquivo (passado como arquivo de saída);
Xu: Converte de X-BDI para US.
O módulo lê do arquivo gerado por o X-BDI e converte para os comandos apropriados (transições de estado) em US.
Duas funções separadas foram implementadas para realizar a conversão:
A função UT_ XBDI (usada quando é passado o parâmetro ux) procura por as informa-ções gravadas no arquivo de log do UT, passado por parâmetro, e as converte para o padrão X-BDI, seguindo a tabela de associações, exibida na Tabela 4.2.
Já a função XBDI_ UT (usada quando é passado o parâmetro xu) lê o arquivo de saída, produzido por o X-BDI, passado por parâmetro, e converte as informações para a sintaxe adequada das transições de estado US.
Para cada linha encontraNdo o string &quot;SCORE FOUND&amp;», lê o restante da linha e converte para o comando X-BDI apropriado (entradas de sensoriamento para o X-BDI);
Grava no arquivo de saída, para ser lido por o X-BDI;
XBDI_ UT Lê do arquivo de saída, gerado por o processamento do X-BDI;
Grava no arquivo de saída, para ser lido por o UT;
Em o X-BDI, é possível visualizar a execução do código em tempo-real, facilitando a sua depuração.
Já no UT, o código compilado é executado entrando- se no jogo.
É possível, no entanto, depurar o sistema exibindo mensagens na tela quando determinados trechos do código-fonte são atingidos.
Desta forma, para validar o tradutor, é feita uma depuração textual no X-BDI e uma depuração visual no UT.
Como frisado anteriormente, o X-BDI é uma ferramenta experimental, ainda em fase de consolidação.
Portanto, sua utilização neste projeto levantou algumas deficiências.
O XBDI, apesar de facilitar a descrição formal, implementação e execução de agentes cognitivos, ainda necessita de uma melhor documentação associada.
A ferramenta possui um manual identity (sewald).
Contudo, o uso do E-BDI foi descontinuado (implementando- se o agente apenas com o uso do X-BDI), visto que, talvez por um problema de diferença de versões entre o X-BDI e o E-BDI, o código implementado no E-BDI não funcionava no X-BDI, mostrando que existem problemas não somente no X-BDI, mas também no E-BDI.
O protótipo do tradutor, em seu estado atual, se apresenta como uma ferramenta que disponibiliza ao usuário uma nova forma de programar o comportamento dos personagens do UT.
Por questões de tempo, inerentes ao porte de um projeto mestrado, o protótipo não acrescenta novas funcionalidades ao personagem, como por exemplo novos comportamentos, que não os já implementados na linguagem US.
Contudo, através da combinação de comportamentos já existentes (implementados na linguagem US), é possível definição de novos comportamentos para o personagem (comportamento emergente).
A função do protótipo é a interpretação e tradução de comandos de uma linguagem para outra, permitindo obter as informações para esta pesquisa.
Uma das dificuldades encontradas na elaboração deste trabalho foi a questão da diferença de paradigma de programação existente entre o X-BDI e a linguagem US.
Em este aspecto, as associações elaboradas entre as duas linguagens foi um dos pontos importantes deste trabalho.
A extensão do sistema Score, fornecendo suporte a inclusão de novos comportamentos para o personagem (além de os já implementados na linguagem US), se mostra como um trabalho futuro interessante.
Inicialmente, o tradutor possuia quatro funções básicas:
Converter desejos do agente em transições de estado;
Converter crenças em condições para a entrada num determinado estado;
Converter comandos para efetuar transições de estado em desejos do agente;
Converter as condições para a entrada num determinado estado para crenças do agente.
Estas quatro funções foram definidas com o propósito de se estabelecer um conversor entre as linguagens.
Contudo, o segundo e o terceiro casos se mostraram como sendo irrelevantes para o propósito deste trabalho (criar um sistema capaz de estabelecer a comunicação entre as duas linguagens).
Logo, estes dois casos foram desconsiderados, e a implementação focou- se no primeiro e no quarto casos, definindo- se, desta forma, um módulo de comunicação Como foi destacado anteriormente, o protótipo foi implementado com o auxílio da ferramenta E-BDI.
Através da técnica de programação associada ao E-BDI, pode- se modelar agentes com mais facilidade, se comparado a programar diretamente no X-BDI.
Contudo, a ferramenta E-BDI, em seu estágio atual, possui algumas limitações, no que tange a sua compatibilidade com a ferramenta X-BDI.
O E-BDI ainda não suporta o X-BDI em sua totalidade.
Isto faz com que, em determinadas situações, seu escopo de utilização seja limitado.
O protótipo de agente programado no E-BDI corresponde a apenas um estado do personagem do jogo.
Isso mostra que, para modelar a FSM do personagem do jogo no X-BDI, mesmo com o auxílio do E-BDI, em sua totalidade, seria necessário um esforço de programa ção relativamente grande.
Para efetuar a modelagem completa do personagem para o X-BDI utilizando o E-BDI como ferramenta de apoio, tornando então o tradutor funcional, seriam também necessárias atualizações na técnica de programação associada ao E-BDI, como as propostas elaboradas por Zamberlam e Roza.
Considera- se este um trabalho futuro a ser realizado.
Considerações Finais Durante a elaboração deste trabalho de pesquisa, pôde- se constatar que a Ia aplicada aos jogos computadorizados interativos é, na verdade, uma área pouco valorizada e extremamente rica, no que diz respeito a pesquisa.
A escassez de material científico sobre o assunto foi uma das principais dificuldades na elaboração deste trabalho.
Ainda existe alguma forma de preconceito no que tange a utilização de jogos interativos como testbeds para a aplicação de técnicas de Ia.
Segundo Laird, o fato dos pesquisadores de Ia não utilizarem jogos computadorizados interativos em suas pesquisas está associado ao fato de que, geralmente, o objetivo dos sistemas de Ia implementados nos jogos não é criar personagens inteligentes, mas sim aperfeiçoar o nível de jogabilidade do jogo através da ilusão de um comportamento inteligente.
Além de estas constatações, pode- se afirmar, com base nos estudos realizados, que existe uma falta de generalização intrínseca nas aplicações de jogos computadorizados, em especial no que concerne ao desenvolvimento dos sistemas de Ia dos jogos.
Isso ocorre devido a concorr ência existente no mercado de jogos, fazendo com que as empresas de desenvolvimento de jogos criem suas próprias soluções para seus sistemas de Ia, em algumas vezes refazendo soluções já existentes, para evitar adotar soluções criadas por outras empresas.
Estas, geralmente oferecidas a altos preços.
Isto faz com que os projetos de desenvolvimento de jogos computadorizados durem, em média, três anos, desde sua concepção até os testes finais.
Geralmente, por questões de prazos, os sistemas são finalizados às pressas, e preocupações com requisitos de Engenharia de Software, tais como a definição de uma arquitetura reutilizável, são desconsideradas.
Segundo Woodcock, a falta de uma metodologia rigorosa para desenvolvimento de aplicações de jogos computadorizados faz com que muitas soluções propostas por a industria de jogos não sejam adequadas como suporte para um estudo formal da Ia.
Contudo, este cenário está mudando.
Os trabalhos desenvolvidos por Laird e Adobbati são bons exemplos do potencial de uso destas aplicações.
Com este projeto, o grupo JEIA também está contribuindo, em algum grau, para modificar esta situação.
É importante destacar- se que a comunidade brasileira começa a organizar- se.
Um exemplo realizado neste ano, na cidade de Fortaleza.
A participação neste evento foi de extrema import ância, por os seguintes fatores:
Foi possível exibir, à comunidade acadêmica, os resultados parciais deste projeto de pesquisa, através de uma apresentação no evento;
Interação com pesquisadores de diversas universidades, bem como empresas de vários estados do país, investigando trabalhos envolvendo jogos em projetos de pesquisa em ambiente acadêmico.
De entre os diversos trabalhos interessantes, podemos destacar os projetos desenvolvidos por Demasi, Bittencourt, entre outros trabalhos envolvendo jogos com a pesquisa em Ia.
A realização deste workshop, patrocinado por a Sociedade Brasileira de Computação (SBC), mostra a importância e o reconhecimento dos jogos computadorizados interativos como linha de pesquisa.
O grupo de pesquisa onde este projeto está inserido (JEIA) vem explorando o uso da tecnologia de agentes para a construção de jogos educacionais computadorizados.
O grupo JEIA tem por meta a pesquisa envolvendo a tecnologia de agentes aplicada na modelagem e implementação de jogos educacionais.
Com este projeto, o grupo está estendendo sua área de aplicação, através da utilização de jogos computadorizados interativos.
O acervo do grupo As contribuições deste trabalho são:
Auxiliar nos estudos que buscam fornecer um padrão para o tratamento da saída gerada por o X-BDI;
Contribuir para disseminar a pesquisa em jogos interativos na comunidade acadêmica;
Fornecer subsídios para desenvolver uma ferramenta que permita modelar e programar comportamentos de alto nível através da técnica de programação associada ao E-BDI;
Visualizar os resultados de implementações utilizando a ferramenta num ambiente de jogo interativo, desta forma auxiliando a implementação, teste e visualização de resultados de aplicações de agentes inteligentes;
Contribuir para a pesquisa com agentes BDI.
A proposta inicial deste trabalho, definida no Plano de Estudo e Pesquisa (PEP) era a criação de uma linguagem, ou seja, uma gramática para efetuar a comunicação do formalismo para especificação de agentes (X-BDI) com o ambiente de jogo selecionado (UT).
Após a fase inicial deste trabalho, os estudos em cima de esta proposta foram aprofundados.
Constatou- se, então, que a proposta da criação de uma gramática para tratar a saída do X-BDI seria um trabalho muito grande e complexo, tornando inviável sua conclusão no tempo disponível.
O trabalho foi então modificado.
Foi definido que não seria feita uma linguagem, uma gramática, mas sim um tradutor, com a função de efetuar a conversão entre os comandos do X-BDI e o UT.
Desta forma, a proposta teve algumas alterações, no que tange às suas contribuições e objetivos.
Mas a principal alteração da proposta foi na implementação do protótipo, onde ao invés de se implementar uma gramática, seria implementado um tradutor, desta forma reduzindo a complexidade do trabalho, visto que, para criar uma gramática, seria necessária uma prova formal de sua funcionalidade.
Além de estas alterações, para a criação do protótipo, foi selecionado somente um comportamento de um personagem, representado por o estado MeleeAttack, descrito anteriormente.
Este comportamento já está implementado na classe correspondente ao personagem do jogo.
Mesmo assim, constatou- se que o esforço para se efetuar a tradução das informações entre as duas linguagens é relativamente grande.
Como já destacado anteriormente, o X-BDI e a linguagem US pertencem a paradigmas de programação diferentes.
Para se efetuar uma conversão apropriada, foi necessário tratar, de forma específica, as condições associadas aos comportamentos modelados e implementados.
Como trabalho futuro, pode- se citar a complementação da implementação do tradutor, desta forma consolidando a implementação de uma ferramenta para efetuar a comunicação do X-BDI com o UT, ferramenta esta que poderia ser utilizada para a modelagem e teste de agentes para serem utilizados tanto em ambientes de jogos quanto em outras aplicações, dada a flexibilidade do ambiente de jogo selecionado.
Desta forma, o ambiente de jogo pode ser considerado como um framework para o desenvolvimento de ambientes de teste para agentes inteligentes.
Além de a implementação do tradutor em sua totalidade, considera- se como um trabalho futuro interessante uma extensão do tradutor, onde se possa adicionar novos comportamentos ao personagem do jogo, ou ainda remover comportamentos existentes, como frisado anteriormente.
A o longo deste projeto, obteve- se aprovação de artigos nos seguintes eventos:
