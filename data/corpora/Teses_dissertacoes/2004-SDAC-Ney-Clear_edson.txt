O aumento da capacidade de circuitos integrados tem permitido a inclusão de um número crescente de módulos de hardware num único dispositivo.
Apesar de as vantagens tecnológicas potencialmente providas por tal característica, a complexidade para a descrição e gerenciamento destes projetos de hardware aumenta na mesma proporção.
Isto dificulta atender figuras de mérito tais como o tempo de chegada ao mercado de produtos tecnológicos, escalabilidade e qualidade de projeto.
É possível superar ou pelo menos amenizar tal problema por o aumento do nível de abstração em que se realiza a captura inicial de projeto, por o incentivo maciço ao reuso e por a implementação de mecanismos mais eficazes de interconexão de componentes no interior de circuitos integrados.
O presente trabalho contribui inicialmente com uma proposta de organização para níveis superiores de abstração de projeto a empregar durante a modelagem de sistemas digitais complexos.
Com base nesta proposta, mostram- se resultados iniciais da comparação entre modelagens sistêmica e a modelagem RTL tradicional, a partir de um estudo de caso implementado em SystemC e VHDL.
O domínio da complexidade do projeto passa por o tratamento em separado dos aspectos de computação e comunicação do sistema, assumindo importância central neste trabalho.
Em particular, endereça- se a preocupação crescente com a comunicação de módulos de hardware num sistema digital complexo.
Propõe- se aqui a modelagem abstrata de uma rede de comunicação intrachip parametrizável denominada Hermes, usando o nível de abstração de transação e empregando a linguagem SystemC.
Esta modelagem é validada através de experimentos, e levou à proposta e ao desenvolvimento de ferramental específico de apoio ao projeto da comunicação intrachip.
Através do processo de modelagem e dos resultados iniciais obtidos com a rede Hermes, evidencia- se um conjunto potencial de vantagens que pode ser auferido por o uso de níveis superiores de abstração, durante a modelagem abstrata da comunicação e da computação para sistemas digitais complexos.
Palavras chave:
Sistemas num único chip, projeto de SoCs, níveis de abstração, nível de transação, nível de transferência entre registradores, SystemC, redes intrachip.
O avanço tecnológico tem permitido cada vez mais a utilização da automatização de atividades cotidianas do homem.
Sistemas computacionais são uma das formas modernas de prover esta automatização.
Eles são formados por módulos de hardware e software, cujas operações combinadas provêem um serviço.
Sistemas computacionais utilizados em controle de veículos, em comunicação à distância e na automação de residências são cada vez mais importantes para disponibilizar principalmente conforto e segurança.
Sistemas embarcados constituem uma classe de sistemas computacionais.
Apesar de possuírem a mesma estrutura interna de computadores, sendo formados por processadores, memórias, barramentos, e dotados de software, sistemas embarcados se caracterizam por não serem percebidos como computadores por os seus usuários finais.
Exemplo dessa característica é dado por a interação do usuário com um telefone celular e carros com freios ABS.
Gordon Moore observou, na década de 60 que a cada 18 meses a capacidade dos circuitos integrados (CIs) duplicava, o que vem se mantendo válido até então.
A esta observação denominou- se a &quot;lei de Moore», a qual tem funcionado como um acionador da velocidade de evolução da indústria de semicondutores.
Nota- se a velocidade de evolução por o aumento exponencial do número de transistores por unidade de área de Ci ocorrido nos últimos 20 anos.
O contínuo aumento do número transistores por unidade de área de Ci permite que sistemas completos sejam montados num único Ci, criando- se o conceito de SoC (em inglês, System-on-a-chip).
O desenvolvimento de SoCs é visto como uma tendência crescente em projetos de hardware pois permite resolver parcialmente problemas tais como redução de área excessiva de sistema, e suavizar gargalo de desempenho na comunicação entre diferentes módulos de hardware.
Apesar de isto, o contínuo aumento da capacidade dos CIs permite que mais módulos de hardware façam parte de um único SoC, o que torna um projeto complexo de descrever, validar e gerenciar.
Estes fatores propiciam o aumento do tempo de projeto, o que tende a invalidar a vantagem do uso de SoC para atender o time- to-- market.
Time- to-- market é a necessidade que as indústrias têm de lançar um produto no mercado no prazo mais curto possível para obter maior lucratividade.
Algumas propostas para superar tal problema são:
A elevação do nível de abstração de captura de projeto, técnicas de reuso de projeto e métodos mais eficientes de interconexão de módulos de hardware em SoCs.
Em o presente trabalho são propostos níveis de abstração superiores ao de transferência entre registradores (em inglês Register transfer Level, RTL) para projeto de hardware e é implementada uma rede intrachip (em inglês, barramentos, e que utiliza uma interface padronizada para facilitar seu reuso em projetos.
O presente Capítulo organiza- se da seguinte forma:
Em a Seção 1.1 introduz- se a definição sobre núcleos de propriedade intelectual e SoCs.
A Seção 1.2 adianta- se a motivação para este trabalho, tendo por parâmetro os problemas atuais vinculados a projeto de SoCs e algumas alternativas de solução.
Em a Seção é mostrada.
Núcleos de propriedade intelectual (núcleos IP ou IPs ou núcleos) são módulos de hardware complexos, digitais ou analógicos, estruturados em diferentes formatos e níveis de abstração.
Núcleos IP são classificados em três categorias distintas, de acordo com a forma em a qual são disponibilizados, quais sejam:
Núcleos Duros:
São otimizados para uma tecnologia específica e não podem ser modificados por o projetista.
Estes núcleos possuem um layout e planta baixa (floorplanning) pré-definida.
Núcleos Firmes: Netlist (lista de conexões) gerado para a tecnologia empregada, que muda de fabricante para fabricante.
Este tipo de núcleo pode ser parcialmente parametrizado por o projetista, permitindo que sua arquitetura seja adaptada à necessidade do projeto.
Entretanto, como o netlist é específico para uma dada tecnologia, existe a dificuldade do uso de componentes fornecidos por fabricantes diferentes.
Núcleos Flexíveis: Descritos em linguagens de descrição de hardware (em inglês, Hardware Description Language, HDL), oferecendo flexibilidade e independência de tecnologia.
O núcleo pode ser modificado e empregado com tecnologias de diferentes fabricantes.
PPk Mp Interface externa Rede de Interconexão CiAE1 CiAEm LRn Legenda:
A especificação de um SoC define quais requisitos o sistema deve atender, tais como funcionalidade a ser atingida, desempenho desejado e consumo máximo de potência.
A a especificação inicial segue- se a fase de projeto do SoC.
Esta fase pressupõe duas atividades principais:
A modelagem ou descrição e a validação.
A modelagem consiste em partir da especificação e produzir uma descrição do sistema ou de parte deste usando um formalismo escolhido.
Exemplos de tais formalismos são linguagens ou métodos gráficos de representação de funcionalidade, estrutura, etc..
A validação consiste em exercitar a descrição produzida na fase de modelagem para verificar suas propriedades.
Assim, pode- se garantir, em maior ou menor grau, o atendimento da especificação por o resultado da modelagem.
Devido a a complexidade de SoCs, deve- se sempre iterar as fases de modelagem e validação um certo número de vezes, num processo de refinamentos sucessivos.
Cada iteração está associada a um nível de abstração de projeto, onde o resultado da última modelagem realizada representa a especificação do próximo nível de abstração, e assim por diante.
Segundo Cai e Gajski, pode- se classificar métodos de projeto de SoCs em três grupos de classes, quais sejam:
Projeto baseado em componentes (Component-based design):
Esta abordagem utiliza uma metodologia ascendente (em inglês, bottom-up).
Em ela, são utilizados núcleos IP e software pré-definidos e prévalidados.
A partir destes módulos, um SoC é montado para atender uma funcionalidade específica ou mesmo definir uma plataforma para projetos futuros.
Síntese em nível de sistema (em inglês, System--level):
Esta abordagem utiliza uma metodologia descendente (em inglês, top-down).
O passo inicial do projeto de SoC se dá por a descrição abstrata do sistema.
O passo seguinte são refinamentos sucessivos, finalizando quando um conjunto de núcleos IP sintetizável e a descrição do software associado são obtidos.
Projeto baseado em plataformas (Platform-based design):
Esta abordagem utiliza a metodologia mista ascendente-descendente de geração de projeto (em inglês, meet-in- the- middle).
Em esta metodologia, o SoC é obtido a partir de o mapeamento de módulos de hardware e software na plataforma.
Em este caso, módulos de hardware e suas interconexões já estão presentes na plataforma.
Esta abordagem de projeto visa atender a um domínio de aplicações específicas, tal como o processamento de imagens.
A Tabela 1 apresenta uma comparação qualitativa das abordagens de concepção de projeto de SoCs segundo aspectos de descrição de projeto, complexidade de descrição de módulos e de suas interconexões e o tempo de projeto estimado.
Aspectos de modelagem e validação específicos não foram levados em conta, por representarem a mesma complexidade independente da abordagem utilizada.
A síntese em nível de sistema inicia com a modelagem e, depois de criada uma primeira especificação executável, prossegue com passos de refinamento até chegar a uma descrição válida de entrada para ferramentas de síntese automatizada.
Para projetos baseados em plataformas, a funcionalidade do sistema é atingida a partir de o momento em que os módulos pré-projetados são mapeados na plataforma com o auxílio de ferramentas de apoio.
Para projetos baseados em componentes, a descrição do projeto fica restrita à seleção e interconexão de componentes ou módulos pré-disponibilizados.
Em a síntese em nível de sistema, a complexidade de descrição de módulos é considerada alta por envolver muitos passos de refinamento, metodologias de trabalho e ferramentas de apoio.
Para projetos baseados em plataformas, esta complexidade é menor, pois as ferramentas de apoio têm como função específica mapear um componente do sistema para estruturas pré-definidas de uma dada plataforma.
Projetos baseados em componentes possuem complexidade nula para descrição de módulos, pois tais módulos são reaproveitados de projetos anteriores ou adquiridos de terceiros.
A complexidade de interconexão de módulos tende a ser um dos pontos cruciais para a tomada de decisão sobre a abordagem de projetos do SoC a adotar.
Para síntese em nível de sistema, o refinamento de módulos de forma manual e a possibilidade de personalizar a interface de comunicação com os demais módulos do projeto de SoC diminuem a complexidade de interconexão dos módulos implementados.
Para projetos baseados em plataformas, a interconexão entre os diferentes módulos já está projetada, bastando apenas ser mapeada por ferramentas de apoio ao projeto.
Para projeto baseado em componentes, esta complexidade pode ser alta ou média.
Pode ser alta, se caracterizada por o uso de componentes heterogêneos no que tange a freqüência de operação ou mesmo a largura de banda para comunicação.
O mesmo pode ocorrer devido a o não uso de interfaces de comunicação padronizadas, o que exige do projetista o desenvolvimento de lógica de adaptação entre os diferentes módulos.
Com o uso de interfaces padronizadas, tal complexidade pode ser reduzida.
O último aspecto a ser analisado é o de tempo estimado de projeto.
Para síntese em nível de sistema, o tempo estimado é grande, pois os passos de refinamento e a validação tendem a consumir tempo de projeto considerável.
Para projetos baseados em plataformas, este tempo tende a diminuir, pois se pressupõem que estruturas de validação da plataforma pré-existam.
Adicionalmente, o uso de ferramentas de mapeamento de módulos pré-projetados na plataforma contribui para a aceleração do projeto.
Para projetos baseados em plataformas, o critério tempo de projeto pode ser grande ou médio.
Esta variação está principalmente ligada a questões de descrição de projeto e interconexão dos diferentes módulos.
O crescimento do uso de SoCs é visto como uma certeza, devido a vantagens, tais como a possibilidade de diminuição da área e de tempo de projeto, e aumento de desempenho de comunicação.
O aumento da capacidade dos CIs habilita a presença de cada vez mais núcleos IP num único Ci e sua heterogeneidade, o que torna complexa a interconexão entre os núcleos IP e a validação global do SoC.
Com isto, a concepção e o gerenciamento dos projetos tornam- se tarefas extremamente complexas.
Soluções parciais para garantir as vantagens do uso de SoCs e minimizar suas desvantagens podem ser obtidas via três tipos de ação:
Emprego de técnicas de reuso de projetos, fomentar a evolução dos métodos de interconexão de módulos on- chip, e por a elevação dos níveis de abstração das fases de captura de projeto.
Cada uma destas ações é discutida a seguir.
O reuso de núcleos IP permite a redução do tempo de projeto.
Com o aumento da capacidade dos CIs, a possibilidade de inserir cada vez mais núcleos IP num único SoC também cresce.
Todavia, núcleos IP desenvolvidos para uma aplicação específica ainda não seguem, hoje, uma padronização da sua interface externa.
O grande número de núcleos IP num SoC e a uso ineficiente dos padrões de interconexão faz com que a reutilização de módulos torne- se uma tarefa complexa.
O uso de meios de comunicação compartilhados, tais como barramentos, para interconectar módulos de um SoC torna- se ineficiente à medida que cresce o número de módulos de hardware num único Ci.
Este problema deve- se principalmente a fatores elétricos, incluindo o carregamento capacitivo dos fios do barramento, o conseqüente aumento de consumo de energia, além de a limitação topológica de apenas permitir uma mensagem trafegando no meio de comunicação a cada instante.
Cada vez mais núcleos IP processadores e outros componentes reutilizáveis têm sido integrados num único Ci.
Estudos prevêem que futuramente SoCs sejam compostos por centenas de núcleos IP[ BEN01, GUE00].
A comunicação entre núcleos IP costuma ser realizada seguindo duas abordagens distintas:
Uma proposta que supere tais problemas e que venha a atender as futuras necessidades de projetos é obtida a partir de o uso de esquemas de comunicação intrachip mais elaboradas.
Conceitos derivados dos domínios de redes de computadores, sistemas distribuídos e arquivos paralelos vêm sendo adaptados para o ambiente interno a um Ci complexo estendendo o conceito de redes intrachip (em inglês network on chip ou NoCs).
O uso de NoCs como mecanismo de comunicação entre núcleos IP de um projeto de SoC.
Tem sido crescentemente por estas apresentarem, quando comparadas a barramentos tradicionais, características de melhora de parâmetros tais como:
Eficiência energética, confiabilidade, reusabilidade, comunicação não bloqueante e escalabilidade de largura de banda[ GUE00, A elevação do nível de abstração de projeto também é vista como uma contribuição para aumentar a eficiência de concepção dos projetos de hardware.
Novamente, devido a o aumento do número de núcleos IP num SoC e ao aumento da complexidade da tecnologia de interconexão destes IPs, descrições em RTL são difíceis de se desenvolver e alterar.
A elevação dos níveis de abstração de projeto para os chamados níveis sistêmicos permite que detalhes sejam ocultados, tornando mais fácil descrever a funcionalidade de cada módulo e suas interconexões.
A lacuna existente entre o nível de especificação e os de concepção do projeto usados hoje pode ser preenchida com níveis intermediários como o nível não temporizado e o nível de modelagem de transações (em inglês, Transaction Level Modeling, TLM) conforme proposto, por exemplo, por Arnout em.
SystemC é uma linguagem de descrição de projeto em nível de sistema (em inglês, System Level Design Language, SLDL) que prove mecanismos para a modelagem projetos em RTL e de níveis mais abstratos.
Esta linguagem atende à necessidade de elevação do nível de abstração de captura e validação de projeto.
Construída como um conjunto de classes sobre a linguagem C+, SystemC foi desenvolvida com a finalidade de preencher a lacuna entre a especificação do projeto de sistemas computacionais e sua concepção.
SystemC permite a descrição de hardware e software num ambiente homogêneo, facilitando o processo de compreensão, descrição e validação de projeto.
Com isto, a detecção de erros funcionais pode ser realizada nos estágios iniciais de desenvolvimento, diminuindo os esforços e custos de projeto.
Observada a tendência da utilização de SoCs em projetos de sistemas e as vantagens daí advindas, nota- se à complexidade intrínseca de projetos com múltiplos núcleos IP.
Assim, a aplicação de técnicas de reuso de núcleos IP, o emprego de novas abordagens para definir a interconexão destes núcleos, e a elevação dos níveis de abstração para a descrição de projetos são vistos como temas relevantes a serem investigados.
Este trabalho contribui para o avanço da pesquisa em redes de comunicação intrachip.
Um dos aspectos importantes neste contexto é disponibilizar técnicas que facilitem o processo de projeto e as tomada de decisão sobre características de SoCs que utilizem como meio de comunicação NoCs.
Com isto, incrementa- se o desenvolvimento de uma cultura de planejamento de projeto e validação funcional em altos níveis de abstração antes da implementação da comunicação em SoCs em baixos níveis de abstração.
O desenvolvimento das técnicas mencionadas teve como alvo a construção de ferramentas que contribuem para o aumento de produtividade e para a eficiência da análise do processo de projeto da comunicação em SoCs que emprega NoCs.
Para alcançar esta contribuição, o trabalho partiu do conjunto de objetivos estratégicos e específicos descritos a seguir.
O objetivo estratégico principal foi aumentar o corpo de conhecimentos sobre a modelagem de NoCs em altos níveis de abstração.
A o lado deste, considerou- se também importante aumentar o ferramental teórico e prático disponível para avaliar a relação custo-benefício entre realizar a captura formal de projetos a partir de altos níveis de abstração e fazer o mesmo a partir de o nível RTL.
Para atingir os objetivos estratégicos, alguns objetivos específicos foram delineados.
O principal destes foi desenvolver pelo menos uma proposta de NoC, incluindo o estudo de diferentes arquiteturas e algoritmos relacionados a estas estruturas de comunicação intrachip.
Adicionalmente, objetivou- se estudar e empregar ambientes que suportem a modelagem de NoCs em níveis de abstração superiores ao RTL.
Estes ambientes permitem não apenas modelar hardware, mas também avaliar e prototipar sistemas, ainda que baseado em fluxos apenas parcialmente automatizados de projeto, o que é obtido, por exemplo, através da integração do ambiente em questão com sistemas comerciais de síntese.
Outro objetivo específico delineado deriva diretamente dos anteriores.
Este consiste e proporem, e se possível implementa, ferramentas de apoio que capturem as técnicas de projeto desenvolvidas ao longo de a implementação de NoCs.
O restante deste documento está assim organizado.
O Capítulo 2 apresenta a revisão do estado da arte para questões pertinentes ao trabalho:
NoCs, SLDL, níveis de abstração de projetos de SoCs e ferramental disponível para modelagem em nível sistêmico.
Adicionalmente, este Capítulo inclui as propostas da NoC alvo do trabalho e dos níveis de abstração adotados.
O Capítulo 3 apresenta uma comparação inicial entre os compromissos envolvidos no uso de linguagens sistêmicas versus o uso de linguagens RTL para o projeto de hardware, através de um estudo de caso.
Em o Capítulo 4 é apresentada a abordagem para a implementação de NoCs em nível de transação.
Em o Capítulo 5 são apresentadas as conclusões sobre o trabalho e perspectivas de trabalhos futuros.
Em os últimos anos, diversas pesquisas têm sido realizadas com a finalidade de aumentar a produtividade através do uso de técnicas que facilitem a modelagem, a descrição, a validação e o gerenciamento de projeto de SoCs.
Diferentes temas de pesquisa são investigados para encontrar soluções parciais ao problema intrínsecos nos projetos de SoCs.
Entre estes temas destacam- se o uso de níveis de abstração para modelagem de projetos, linguagens de descrições de sistemas que permitam maior abstração (SLDLs), (iii) ambientes que viabilizem a modelagem abstrata e redes intrachip.
Em o presente Capítulo é feita a revisão do estado da arte destes quatro temas.
A crescente complexidade do processo de projeto de sistemas digitais implica a decomposição hierárquica deste num conjunto de passos de projeto.
Um mecanismo fundamental para conduzir a decomposição do processo de projeto é a abstração de informações.
Abstração é o nome que se dá ao processo de representar um objeto via um conjunto limitado de informações representando aspectos relevantes deste para um dado tipo de manipulação.
Também se pode usar o termo para referir- se ao resultado do processo em si.
Segundo Calazans, pode- se definir nível de abstração no contexto de projeto de sistemas computacionais como um conjunto de descrições de projeto com o mesmo grau de detalhamento, onde uma descrição de projeto é o resultado de um dado processo de abstração.
Durante o projeto de um SoC, um grande número de descrições de projeto com diferentes níveis de detalhamento são manipuladas.
Por exemplo, diagramas de portas lógicas contêm muito menos detalhes que uma descrição elétrica do tipo SPICE, mas ambos são descrições do projeto relevantes em algum contexto.
Os primeiros podem ser usados para rapidamente validar blocos grandes, com dezenas de milhares de portas lógicas, enquanto a partir de descrições SPICE é possível obter validações com alto grau de detalhamento para pequenos blocos, tipicamente com não mais que alguns milhares de transistores.
O número de níveis de abstração manipulados durante o projeto de sistemas complexos tem aumentado à medida que aumenta a complexidade dos projetos.
Descrições de projeto RTL são Com a crescente complexidade dos projetos de sistemas computacionais e a necessidade de aumento de produtividade de projeto, o uso de níveis de abstração superiores ao RTL tem sido proposto, tal o nível de sistema.
Aliada a proposta de modelagem em nível de sistema está a separação de características do projeto, tal como computação e comunicação.
Um componente essencial de novos paradigmas de projeto de sistemas é a divisão de interesses, ou seja, a separação dos vários aspectos de projeto, para permitir exploração mais eficiente de soluções alternativas de projeto está relacionada à natureza dos problemas.
Alguns aspectos de projeto passíveis de separação, conforme são:
A função e a arquitetura;
A comunicação e a computação.
Em o presente trabalho, os principais aspectos de projeto cuja separação será considerada são:
A comunicação e a computação.
Estes são considerados os principais aspectos a serem separados segundo e.
g Keutzer, Cesário e Fayad.
Entende- se aqui por computação, o comportamento interno de um núcleo IP, sem preocupação de valores serão compartilhados com outros núcleos IP.
Entende- se aqui por comunicação o comportamento que descreve a troca de dados entre dois ou mais núcleos IP.
Este entendimento pode ser exemplificado por um produtor/ consumidor, onde, focando o núcleo IP produtor, a computação limita- se à descrição do comportamento que gera valores aleatórios e a comunicação limita- se à descrição do comportamento de transferência os dados.
A abordagem de separação de características permite concentrar- se na solução de problemas de computação, abstraindo detalhes de comunicação.
Quanto mais para o final do projeto do sistema a comunicação puder ser refinada, mais maleáveis serão o desenvolvimento e gerenciamento do projeto.
Independente da separação de características que se pretende adotar, o uso de níveis de abstração específicos é fundamental.
Arnout propôs dois níveis de abstração superiores ao RTL:
O nível não temporizado, e o nível de transação.
Em o nível não temporizado, o objetivo é a descrição da funcionalidade do projeto sem precisão temporal, ou seja, sem a noção do tempo necessário para executar um determinado algoritmo.
Em este nível não há separação dos módulos de hardware e software, apenas a geração de uma especificação executável.
Em o nível de transação, a funcionalidade de cada módulo é descrita de forma abstrata, assim como no nível não temporizado.
Todavia, como há separação entre os módulos, há necessidade de comunicação, sendo esta baseada em ciclos de transação.
Com isto, pode- se garantir o correto funcionamento do sistema via simulações mais eficientes, visto que o detalhamento das descrições é menor.
Outra proposta de níveis de abstração em projetos de sistemas computacionais é apresentada por a Synopsys em.
Em esta referência, são definidos como níveis de abstração superiores ao RTL os níveis não temporizado, temporizado e de transação.
Em o nível não temporizado, os algoritmos que descrevem o comportamento dos módulos são mais facilmente capturados, verificados e otimizados, devido a alto grau de abstração das descrições.
Em este nível, os módulos do projeto que estão sendo desenvolvidos comunicam- se ponto-a-ponto através de canais abstratos do tipo fila, acessados via operações bloqueantes de leitura e escrita.
Assim, projetistas são beneficiados de duas formas.
Primeiro, a facilidade de desenvolvimento, pois a comunicação é simples e a sincronização é implícita.
Segundo, uma maior eficiência de simulação, pois muitos detalhes de implementação da computação são abstraídos neste nível.
A comunicação entre os módulos do sistema, neste nível, pode ser validada de forma abstrata otimizando o processo de transmissão e recepção de informações do ponto de vista funcional.
O desempenho obtido pode ser avaliado com métricas tais como a taxa de erro de transferência de bits entre a fonte transmissora e o destino.
A inserção de erros na transferência dos bits permite avaliar a perda de desempenho quando muitos erros ocorrem, o que contribui para a descrição do algoritmo que consuma menos tempo de execução e corrija erros.
Outra vantagem do uso deste nível é a validação de um algoritmo logo nos primeiros estágios do projeto, onde é verificada a real funcionalidade do mesmo.
Como exemplo, pode- se descrever um algoritmo de roteamento o qual pode ser garantida a não ocorrência de problemas tais com deadlock ou livelock.
Em o nível temporizado, empregam- se modelos funcionais dotados de informações de atraso.
A modelagem de atrasos pode considerar atrasos de processamento, de comunicação, ou ambos.
Este nível de abstração é usado para analisar os efeitos de latência no comportamento do sistema e a arquitetura do sistema nos estágios iniciais do projeto.
Através de especificações de atraso de processamento, é possível definir modelos funcionais temporizados para determinar se o sistema vai gerar resultados em tempo hábil ou não, conforme a especificação.
Normalmente, empregam- se aqui esquemas de comunicação ponto- aponto, a exemplo do que ocorre no nível não temporizado.
Modelos funcionais temporizados são geralmente usados para analisar o compromisso entre implementações alternativas de hardware e software nos estágios iniciais de projeto.
Isto é feito por a avaliação do impacto do mapeamento de processos para ambos, hardware e software.
A idéia de tempo neste nível é normalmente expressa através de estimativas de ciclos de relógio.
Nota- se então que os modelos funcionais descritos tanto no nível não temporizado quanto no temporizado não fazem distinção entre módulos de hardware ou software.
A partir de a avaliação do desempenho e/ ou custo de projeto para a separação dos módulos em hardware ou software, é definido o nível de transação.
Em o nível de transação, os componentes da arquitetura, tais como memórias, unidades aritméticas, e geradores de endereço comunicam- se através de meios compartilhados, como barramentos.
Barramentos costumam envolver mecanismos de arbitragem para resolver conflitos de acesso ao meio de comunicação, que ocorrem quando vários componentes requisitam acesso a este simultaneamente.
Um grande esforço é necessário para projetar e verificar modelos comportamentais em HDL, pois sua simulação é pouco eficiente.
Além de isto, não existem técnicas universais para transformar todas as partes de uma descrição HDL puramente comportamental em hardware.
A depuração de software normalmente requer a simulação de hardware em níveis próximos ao RTL, o que pode tornar a verificação de um sistema complexo inviável.
Com a modelagem em nível de transação, a comunicação não necessita de uma implementação com alto grau de detalhamento.
O comportamento desta comunicação é modelado e expresso em termos de transações.
O conceito de transação varia de autor para autor.
Por exemplo, segundo Pasricha transação é uma troca de dados qualquer entre módulos, independentemente do protocolo de troca empregado ou do tempo necessário para efetuar esta troca.
Esta definição foi adotada para o presente trabalho visto que o objetivo é exatamente prover interfaces de comunicação sem detalhamento da implementação e sem o uso de conceito de tempo.
Descrições em nível de transação são mais fáceis de desenvolver e usar se comparadas a descrições RTL, devido a o baixo grau de detalhamento de implementação dos módulos.
A modelagem no nível de transação cria uma especificação executável do modelo que simula ordens de magnitude mais rápido que modelos RTL.
Esta especificação executável provê um modelo abstrato que desenvolvedores de software podem utilizar para testar seus códigos no contexto de um SoC.
Esta modelagem também provê um mecanismo para análise de comprometimento de hardware e software, e permite um nível de confiança na verificação funcional do sistema logo nos primeiros estágios do processo de projeto.
As diferentes equipes de um projeto devem preferencialmente comunicar- se no nível de transação.
Problemas em projetos são bem menos custosos se detectados e resolvidos em nível de transação do que em RTL.
Em o passado, níveis de abstração eram utilizados para descrever a computação dos módulos de um sistema, sendo que a descrição da comunicação entre módulos era vista como acessória.
Por este motivo, a descrição da comunicação era realizada da mesma forma que a descrição da computação.
Contudo, a crescente escala de interconexão de módulos em sistemas leva ao aumento da importância de interconexões.
A partir deste momento surge então a necessidade de processos de modelagem específica para a comunicação entre módulos, usando um conjunto de níveis de abstração próprios.
Exemplos de propostas de níveis de abstração para tratar questões de comunicação são apresentados por Haverinen et diferentes níveis de abstração numa modelagem de comunicação onde o nível mais baixo de abstração, RTL, é descrito por a implementação detalhada do protocolo OCP.
O protocolo OCP é uma proposta de padronização de interfaces para a interconexão de núcleos IP.
O nível de mensagem não é temporizado, ou seja, não inclui informações de tempo para executar uma transação.
A transferência de dados entre os núcleos envolve a passagem de vários dados, que podem ser tipos abstratos, tais como registros estruturados em software (e.
g construções struct na linguagem C).
A mensagem a ser trocada representa toda a informação necessária para que os núcleos IP possam se comunicar.
O nível de transação é temporizado, mas abstrai o conceito de ciclos de relógio.
O termo temporização neste caso refere- se a correta ordem das transações que ocorrem entre os diferentes núcleos IP.
Uma única transação neste nível pode envolver a troca de um ou diversos dados, assim como no nível de mensagem.
O tempo de execução decorrido de uma transação é estimado internamente nos núcleos que trocam dados.
Sistemas descritos neste nível são independentes dos protocolos de comunicação específicos.
Assim, para a comunicação entre núcleos IPs o dado que será enviado a outro núcleo IP é repassado para um mecanismo que se encarregará de realizar a transferência, sendo que esta transferência pode ocorrer através de um handshake ou ainda através da implementação de uma fifo, ficando implícito aos núcleos IP.
O nível de transferência se caracteriza por o uso de descrições comportamentais com temporização baseada em ciclos de relógio, mas sem detalhamento da estrutura interna de hardware, o que o diferência de em RTL.
Resumidamente, neste nível há o detalhamento da interface do núcleo IP, mas o comportamento interno que descreve a estrutura de comunicação permanece num grau elevado de abstração o que o torna descrição não sintetizável.
Em este nível é descrito um protocolo de comunicação específico, mas não sintetizável, como por exemplo, Amba para descrever um barramento mestreescravo.
Jerraya propõem 3 níveis de abstração superiores ao nível RTL para abstrair detalhes de comunicação, quais sejam o nível de serviço, o nível de mensagem e o nível de driver.
O nível de serviço é definido como a implementação de métodos que descrevem ações de um módulo, denominados serviços.
Em este nível, um módulo pode requisitar um serviço que é disponibilizado por outro.
Questões como camadas de protocolos de comunicação a serem adotadas, estratégias de conexão e questões de temporização não são detalhadas neste nível de abstração.
Assim, a funcionalidade é mais facilmente descrita.
Exemplos de serviços que podem ser requisitados são pedidos de impressão ou transferência de arquivos.
Com este tipo de abstração, a expressão de paralelismo e temporização é facilmente suportada.
Em o nível de mensagem, a comunicação é modelada através de canais ativos com capacidade de interconectar módulos independentes, ocultando questões de protocolos de comunicação específicos e tamanhos de dados.
Assim, canais implementando métodos de envio e recebimento de dados são modelados neste nível.
Estes canais executam transferências ponto-a-ponto de dados entre módulos.
Em o nível de driver, a comunicação entre os módulos é definida através de uma conexão lógica, que realiza trocas de dados com tipos fixos ou enumerados.
O tempo de comunicação é diferente de zero, mas é previsível, visto que o tamanho e a estrutura dos dados são bem definidos, o mesmo ocorrendo com os protocolos de transmissão de dados.
Assim, modelos de representação de barramentos mestre-escravo são facilmente definíveis.
Com as características dos níveis de abstração apresentados nesta Seção, é possível observar as vantagens decorrentes de descrever processamento e comunicação em níveis de abstração superiores ao RTL.
A definição é empregada em modelagem no nível de transação para projeto de hardware está sendo ativamente empregado e pesquisado.
Alguns trabalhos, tais como e, descrevem algumas das vantagens da descrição neste nível de modelagem.
Para o presente trabalho, foram definidos níveis de abstração que melhor descrevam os possíveis passos de refinamento a adotar na descrição de aspectos de computação e comunicação dos núcleos IP.
Em este trabalho, o objetivo não é descrever um SoC, mas sim modelar núcleos IP, em particular NoC.
O uso de níveis mais abstratos de modelagem tem como objetivo é apresentar justificativas à proposta de modelagem em níveis mais abstratos em questões tais como funcionalidade, custos, consumo de área, desempenho e potência.
A abordagem aqui proposta, contudo, possui potencial para habilitar a modelagem em nível de sistema, onde há necessariamente a definição de um fluxo de projeto completo com uma definição clara das etapas de refinamento.
Assume- se o fluxo de projeto de SoC em nível de sistema representado por a Figura 4.
A primeira etapa do fluxo de projeto consiste do processo de especificação, tendo como prioridade a criação de um modelo de especificação executável, onde não há particionamento entre módulos, sejam de hardware ou software.
Tal modelo é a seguir particionado em domínios de hardware e software, conforme análise de requisitos de desempenho e custo a serem atingidos no projeto.
Esta ação se dá na etapa de particionamento do projeto.
O problema de particionamento está fora de o contexto deste trabalho.
Em o domínio de software, descrevem- se recursos como o sistema operacional embarcado que será utilizado, algoritmos parametrizáveis para atender um dado domínio de aplicação e drivers de interfaceamento com módulos de hardware descritos.
O domínio de software também é considerado fora de o contexto deste trabalho.
Em o domínio de hardware, descrevem- se módulos que executam a computação e/ ou a comunicação.
Isto inclui a descrição de microprocessadores, controladores de memória, barramentos e NoCs podem ser descritos.
O domínio de hardware é o foco deste trabalho.
O resultado final da junção tanto do domínio de hardware e software é o sistema completo, ou SoC.
Com base no fluxo de projeto de SoCs apresentado anteriormente, propõem- se níveis de abstração para representar o foco de hardware de um sistema em cada fase do projeto até sua implementação.
A Figura 5 representa de forma resumida a proposta.
Nota- se que os níveis de abstração para descrição do software agregado ao sistema foram desconsiderados nos níveis de abstração propostos.
Em o nível de especificação é fornecida uma representação abstrata do que se pretende atingir com o sistema, sem a preocupação de particionar esta em módulos de hardware ou software, ou ainda detalhar sua temporização.
Esta descrição se denomina modelo de especificação e deve ser executável.
O objetivo deste nível de abstração é propor algoritmos que descrevam a solução do problema com algum grau de otimilidade.
Nota- se que o objetivo deste nível não é a análise de desempenho ou tomada de alguma decisão do projeto, mas sim a representação da funcionalidade a ser adotada.
O particionamento da especificação executável em módulos de hardware e/ ou software caracteriza o fim do nível de especificação e o início da implementação de um domínio de hardware e um domínio de software.
Dentro de o domínio de hardware o nível de transação é o nível mais abstrato.
O nível de transação caracteriza- se por ser a primeira fase de particionamento de um projeto.
Ali, os núcleos IP são então modelados seguindo um conjunto de graus de detalhamento, conforme apresentado na Figura 6, tanto para as características de comunicação quanto comunicação.
Define- se neste trabalho que o nível de transação não se concentra unicamente na modelagem da computação, mas também na da comunicação.
Em o nível de transação é realizada a busca por a eficiência na descrição de modelos de computação e de comunicação.
O principal objetivo deste nível de abstração é dar apoio à implementação de diferentes algoritmos para descrever a solução a ser adotada e, a partir de a análise e detecção do algoritmo mais interessante, refinar- lo.
Como modelos de computação e comunicação não compartilham hoje um formalismo único eficiente para descrever o detalhamento destes dois aspectos de projetos, propõem- se aqui dois subconjuntos hierárquicos distintos de níveis de abstração dentro de o nível de transação.
O nível RTL é visto como o último nível de abstração do domínio de hardware.
Este nível é assumido dentro de o fluxo de projeto, pois é em ele que as ferramentas de síntese trabalham atualmente, conforme e.
g Jerraya.
Em o nível RTL, a computação e a comunicação de cada núcleo IP não são vistas separadamente.
A computação é representada a partir de lógica combinacional e seqüencial, e a comunicação é realizada a partir de sinais bem definidos, a comunicação entre os diferentes núcleos IP através destes, que implementam o protocolo de comunicação.
A Seção a seguir apresenta o detalhamento da proposta através da comparação desta com outras existentes na literatura.
Tabela 2 -- Comparação entre propostas de níveis de abstração para o projeto sistêmico.
Separação entre computação e comunicação Lukai Cai Guido Arnout Haverinen Proposta deste trabalho Sim Não Sim Sim Níveis de Número de abstração níveis diferenciados para superiores comunicação e ao RTL computação Não Não Sim Sim Cai define 3 níveis de abstração para projetos de SoC, quais sejam:
Não temporizado, temporizado aproximado e temporizado em ciclos de relógio, conforme mostra a.
A partir De estes níveis de abstração, os dois primeiros são superiores ao RTL.
Apesar de apresentar uma abordagem que separa a comunicação e computação, não há diferença entre os níveis de abstração adotados para as diferentes características.
Em a abordagem de Cai, a exploração da comunicação fica prejudicada em relação a a computação, pois os detalhes de funcionamento da comunicação não se concentram unicamente na precisão temporal.
A proposta do presente trabalho apresenta uma abordagem específica para comunicação objetivando o refinamento mais específico para aspectos de comunicação e mais específicos para aspectos de comunicação.
Desta forma, a comunicação pode ser mais facilmente refinada, quando comparada à abordagem de Cai.
Arnout define 2 níveis superiores ao RTL, quais sejam o nível não temporizado e o nível de transação.
Todavia não é apresentada uma separação clara das características de comunicação e computação nestes dois níveis.
Desta forma a definição de metodologias de projeto se torna imprecisa, permitindo diversas abstrações para um mesmo grau de detalhamento.
Em o presente trabalho, o nível de transação também é adotado e em ele é definido um conjunto de detalhamento a serem assumido para a modelagem das características de comunicação e da computação de núcleos IP.
Desta forma a modelagem permite um fluxo mais preciso quando comparada a abordagem de Arnout.
Haverinen propõem 3 níveis de abstração para comunicação superiores ao RTL, quais sejam, o nível de mensagem, o nível de transação e o nível de transferência.
O grau de detalhamento de informações em cada um dos níveis é grande, o que favorece o fluxo de um projeto no que tange a descrição da comunicação dos núcleos IP.
Apesar de isto, não há uma preocupação explícita com os níveis de abstração para descrição da computação.
Em o presente trabalho, há preocupação tanto com a descrição da comunicação quanto coma a computação.
Para tanto, os níveis propostos neste trabalho busca enfatizar as peculiaridades de cada uma das características, conforme melhor detalhado a seguir.
Como a comunicação e para a computação dos núcleos IP possuem características distintas, aqui se trata cada uma de elas em separado, neste trabalho definem- se 3 níveis de abstração para comunicação, conforme Figura 8, e 2 níveis de abstração para computação, conforme Figura 9, todos acima de o nível RTL.
Com esta abordagem, características distintas de cada aspecto podem ser mais bem descritas, facilitando a criação de metodologias de projeto.
O principal objetivo dos níveis propostos é favorecer a modelagem de núcleos IPs favorecendo a descrição dos diferentes aspectos de projeto.
Com base nas revisões de propostas realizadas, definiram- se os seguintes níveis de abstração para descrever comunicação nos projetos de SoCs, níveis estes que absorvem as características mais interessantes de cada uma das abordagens já existentes, conforme Figura 8.
A proposta apresentada privilegia- se de definições apresentadas por Jeraya e Haverinen, conforme detalhamento a seguir.
Em o nível de serviço, o detalhamento da comunicação é abstraído, sendo o principal objetivo descrever a computação desempenhada por os módulos.
Assim, ao invés de detalhar protocolos de comunicação ou criar interpretações dos dados compartilhados, a solicitação de um serviço é implementada.
Exemplo de serviço é uma escrita em memória por parte de um processador, onde ao invés de definir um conjunto de sinais a ser ativado, o processador apenas faz uma chamada de um método (e.
g escreveNaMemoria) passando como parâmetro a posição da memória e o dado a ser armazenado.
Tal método é definido de forma abstrata numa interface e implementado por o canal que interconecta a memória e o processador.
A operação de escrita ocorre através da chamada de método de uma interface de comunicação.
Em este nível, não há necessidade de interpretação de uma cadeia de bits, apenas a execução de uma requisição de serviço provido por núcleos IP.
Este nível é equivalente ao nível de serviço proposto por Jerraya, em e provê maior abstração do que o nível de mensagem proposto por Haverinen Em o nível de mensagem, ainda não há detalhamento de tempo em ciclos de relógio.
O objetivo é fornecer um primeiro refinamento da comunicação, que ocorrerá através da interpretação dos dados que são compartilhados entre os diferentes núcleos IP.
Os eventos de troca de dados ocorrem de forma sincronizada.
Podem ser descritas interfaces que definem os métodos para envio e recebimento de informações entre módulos, assim como no nível de serviço.
As informações repassadas entre os módulos podem representar operações a serem realizadas e os conjuntos de dados relacionados.
Por exemplo, no caso de uma comunicação entre o processador e a memória, cria- se uma estrutura (e.
g struct) ou mesmo pacotes de dados, contendo o tipo de operação a ser realizada (escrita ou leitura), o endereço referente a a posição de memória, e o dado a ser armazenado, caso seja uma operação de escrita.
Quando forem usados pacotes de dados para a comunicação, estes devem ser montados no destino para que sejam interpretadas as requisições.
Quando forem usadas estruturas de dados para a comunicação, a estrutura contém tipos quem definem que requisição está sendo solicitada.
Pacotes de dados permitem a abstração do tamanho do dado, apesar de exigirem a necessidade de remontagem para interpretação, enquanto estruturas de dados já não permitem tanta flexibilidade, porém facilitam a interpretação do dado.
Todavia ambas abordagens concentram- se em representar as informações que terão de ser trocadas, como endereço, abordagem que facilite o refinamento para o próximo nível, tendo como alvo a estrutura que será adotada para troca de mensagens.
O importante neste nível é definir quais as informações que terão de ser transferidas.
Esta definição pode ser realizada tanto através do uso de pacotes de dados quanto através do uso de estruturas de dados bem definidas.
Em o nível de dados, há precisão de ciclos de relógio, como no nível RTL.
Todavia, o que diferência este do nível RTL é a troca de dados a partir de tipos bem definidos além de mecanismos que descrevam protocolos específicos, como barramentos mestre-escravo, de modo funcional.
Assim, podem ser definidos canais de comunicação com a pinagem de endereçamento e operação, por exemplo, são definidos e o que resta é o detalhamento de como ocorre a comunicação internamente ao canal.
Esta abordagem é muito próxima da proposta por Haverinen Em o nível de transferência e por Jerraya Em o nível de dados.
Com o objetivo de definir um conjunto completo de níveis de abstração a serem adotados para a modelagem de núcleos IP, adicionalmente aos níveis de comunicação propõem- se níveis de abstração superiores ao RTL para descrever computação, conforme Figura 9.
Assim como os níveis de abstração assumidos para a comunicação, os níveis assumidos para a computação iniciam logo após o particionamento do modelo de especificação executável.
O nível de abstração mais alto de um módulo de computação é denominado nível não temporizado.
Em ele descreve- se a funcionalidade dos núcleos IP sem o uso de um sinal de sincronismo nem a idéia de inserção de atrasos temporais.
Apesar de a despreocupação com o sincronismo interno da atividade dos núcleos IP, a execução dos eventos internos ocorre de forma ordenada total ou parcialmente.
Esta organização de execução interna dos núcleos IP, sem precisão temporal, permite garantir a validade do modelo quanto a sua funcionalidade.
Adicionalmente esta estrutura contribui para a avaliação de qual o melhor algoritmo para modelar o funcionamento do núcleo IP.
Em o nível temporizado, há a preocupação com o sincronismo das operações realizadas, assim como com o conhecimento do atraso específico de cada tarefa executada.
Apesar de isto, o nível temporizado se diferência do nível RTL, devido a abstração da modelagem da comunicação e da computação.
Com tal nível de detalhamento, o comportamento do modelo pode ser mapeado e parâmetros de atraso de processamento podem ser analisados.
Com esta abordagem é possível validar o desempenho do modelo e definir sua validade ou não de acordo com as especificações do sistema.
O uso de níveis de abstração superiores ao de transferência entre registradores ainda é uma questão em aberto.
Durante o desenvolvimento deste trabalho, foram propostas características de modelagem para facilitar o desenvolvimento do trabalho.
De entre as principais vantagens que se busca com a elevação do nível de abstração estão a facilidade de modelagem do sistema, seu gerenciamento, e principalmente a possibilidade de validação do sistema descrito logo nos estágios iniciais do projeto.
Com esta abordagem, os domínios de hardware e software podem ser explorados em paralelo e validados de forma homogênea, diferentemente do que ocorrem em abordagens ad-hoc tradicionalmente empregadas hoje.
A definição do nível de transação é uma das contribuições do presente trabalho e tem por finalidade prover mecanismos de refinamento, manuais ou automatizados, que diminuam o tempo de projeto de um sistema completo.
Resumidamente, a modelagem no nível de transação permite abstrair detalhes de implementação, usando chamadas de funções que implementam as operações desejadas entre os modelos computacionais.
Esta abordagem permite ainda a descrição funcional da operação a ser realizada, o que traz vantagens como o ganho em velocidade de simulação para a validação de um sistema.
Como sinais de sincronismo específicos, tais como sinais de relógio, são abstraídos no nível de transação, detalhes como comunicação bloqueante ou não bloqueante podem ser mais facilmente descritos, o que facilita a descrição funcional de barramentos e outros esquemas de comunicação.
Assumindo- se a necessidade de elevação do nível de abstração de captura de projetos, o uso de HDLs, tais como VHDL e Verilog podem dificultar o processo de modelagem, se estas não suportarem mecanismos que possibilitem a abstração na modelagem de projetos, tanto para comunicação quanto para computação.
Uma solução para resolver tal problema é a utilização de linguagens que façam uso de orientação a objetos, tal como ocorre com várias SLDLs.
Devido a a exigência da indústria de semicondutores por maior produtividade no projeto de SoCs, é interessante que algumas características sejam providas por linguagens de descrição de projetos em nível de sistema.
Uma destas é a facilidade para projetistas aprenderem a usar a linguagem.
Subsídios para a descrição do projeto e a velocidade com que o resultado obtido vai ser apresentado são vistos como outras características a serem providas.
Independente do método de projeto de SoC adotado, ou seja, projeto em nível de sistema, projeto baseado em plataforma ou projeto baseado em componentes, o uso de uma SLDL deve apresentar duas características importantes, quais sejam:
Suportar diversos os níveis de abstração, desde o puramente funcional não temporizado até o de transferência entre registradores;
Ser executável, de forma que a funcionalidade do projeto e as restrições de temporização possam ser validadas, usando ferramentas que aceitem a SLDL escolhida.
O restante desta Seção apresenta algumas SLDLs.
Não serão detalhadas a semântica ou particularidades das linguagens, mas apenas suas origens e propósitos.
OOVHDL é um grupo de estudo preocupado como aumento da complexidade de projetos de hardware e a necessidade do aumento de produtividade na indústria.
O principal objetivo deste grupo é adicionar orientação a objetos à linguagem VHDL, para facilitar a descrição e o gerenciamento de projetos complexos.
A orientação a objetos e a modelagem genérica oferecem mecanismos para abstração e encapsulamento de descrições de projeto e testbenches, provendo maior facilidade no reuso de projetos.
Duas propostas de linguagens foram definidas por o grupo OOVHDL, ambas baseadas em VHDL, quais sejam:
Objective VHDL e Suave.
Estas foram propostas iniciais, visando suprir um caminho incremental de uma linguagem majoritariamente RTL para uma linguagem SLDL.
Objective VHDL tem como objetivos habilitar a modelagem em alto nível de abstração, facilitar a adição de novas funcionalidades e garantir o reuso de projeto.
Tendo por base VHDL, as características que esta proposta busca agregar a VHDL são a inclusão do conceito de classes, herança, polimorfismo, troca de mensagem e chamada de métodos.
Suave, assim como Objective VHDL, tem como base a linguagem VHDL.
Conforme, para o projeto da linguagem Suave, foram definidas as seguintes características, que deveriam ser alcançadas para permitir modelagem em alto nível de abstração, quais sejam:
Prover suporte à modelagem comportamental em alto nível, através do uso de encapsulamento, capacidade de ocultamento de informações, e permitindo o uso de hierarquias de abstração;
Prover suporte ao reuso incremental de desenvolvimento, através da inclusão de tipos genéricos e do polimorfismo dinâmico;
Prover formas mais abstratas de comunicação.
A comunicação VHDL é baseada na declaração de sinais, sua associação entre os diferentes núcleos IP e a definição de protocolos explícitos;
Prover a criação e destruição dinâmica de processos;
Preservar a capacidade de síntese e de formas de análise de projeto, ou seja, apenas adicionar características à linguagem VHDL, sem remover as características atuais;
Prover abstrações que não sejam tendenciosas para implementações de hardware ou software, permitindo o particionamento e refinamento de sistemas complexos;
Suportar o projeto concomitante de hardware e software, através da integração com linguagens de programação;
Suportar o refinamento de modelos, através da elaboração de componentes ao invés de reparticionamento.
Apesar de a organização do grupo de estudo OOVHDL, não foi possível encontrar registros de avanço de pesquisa e/ ou desenvolvimento das linguagens propostas, tendo o último encontro do grupo ocorrido em maio de 2000, a julgar por a disponibilidade de informações em conferências e na internet.
Uma abordagem semelhante à adotada por o grupo de trabalho OOVHDL é SystemVerilog da Accellera.
SystemVerilog foi desenvolvida de dar seqüência a evolução das linguagens de descrição de hardware agregando características novas de desenvolvimento e verificação para os projetistas.
Esta linguagem é fortemente baseada na linguagem Verilog, mas inclui também algumas características de VHDL tais como a possibilidade de definição de vetores multidimensionais e comando generate no código.
O objetivo desta inclusão de características é possibilitar que projetistas que até então trabalhavam com VHDL possam migrar para SystemVerilog sem ter de encarar mudanças muito radicais na semântica de descrição dos projetos.
Além de a combinação das duas linguagens de descrição de hardware, SystemVerilog inclui a possibilidade de modelagem e validação de sistemas em alto nível de abstração, provendo mecanismos tal como a possibilidade da modelagem abstrata da comunicação.
As classes que definem SystemVerilog provêem um modelo orientado a objeto em o qual projetistas podem encapsular métodos, tal como funções ou tarefas e dados.
SystemVerilog suporta herança simples, métodos virtuais, dados estáticos, construtores e polimorfismo.
As classes definidas em SystemVerilog podem ser instanciadas dinamicamente como objetos, atribuídos valores, desalocadas, e acessadas via manipuladores de objetos.
Adicionalmente, a linguagem ainda prevê que a integração da linguagem C com SystemVerilog suporte projetos arquiteturais e comportamentais, verificação de sistemas e tipos de dados definidos na linguagem C, permitindo aos projetistas traduções de e para modelos algorítmicos descritos em C. Sysjava é uma extensão da linguagem Java utilizada para a descrição de hardware.
Diferentemente das extensões de VHDL e SystemVerilog, Sysjava não evoluiu de uma HDL, mas sim de Java, uma linguagem de programação.
Algumas das principais características que permitem utilizar Java como linguagem base para descrição de hardware são a portabilidade, a grande quantidade de pacotes nativos para a solução de vários problemas como threads e sockets, facilidade na geração de interfaces gráficas, sintaxe simples, paradigma de programação orientado a objeto, compilador e interpretador gratuitos.
Apesar de isto, Sysjava foi desenvolvido, pois Java possui algumas limitações para descrever paralelismo, transição de eventos de sinais entre outras características que são inerentes a hardware.
A linguagem SpecC é uma notação formal para especificação e projetos de sistemas digitais embarcados incluindo hardware e software.
Construída sobre a linguagem de programação ANSI-C, a linguagem SpecC atende a conceitos essenciais para projetos de sistemas embarcados tais como hierarquia comportamental e estrutural, comunicação, concorrência, sincronização, transição de estados, tratamento de exceções e temporização.
Um programa SpecC pode ser executado após a compilação com um compilador SpecC que primeiramente gera um modelo de programa intermediário C+, o qual é compilado em seguida por um compilador C+ qualquer para execução do código objeto num computador hospedeiro.
É fato comum que a comunidade de projetistas de hardware está familiarizada com programação em C/ C+ e em menor escala com a linguagem Java.
Assim, a curva de aprendizagem para utilizar uma destas linguagens é menos íngreme que a de aprender uma linguagem totalmente nova.
A velocidade de simulação e os recursos disponibilizados por a linguagem C/ C+ são superiores aos de Java.
Java é uma linguagem interpretada enquanto C/ C+ cria um arquivo executável, o que possibilita maior eficiência de execução.
Quanto a recursos, C/ C+ possui mais mecanismos se comparado a Java, tal como o uso de estruturas genéricas (templates).
Assim, C/ C+ ganha por ser uma linguagem mais tradicional se comparada a Java, uma linguagem considerada nova conforme exposto por Grötker SystemC é uma biblioteca de classes escrita em C/ C+, que facilita o processo de modelagem, por possuir características como tipos de dados próprios para definição de hardware (sc_ lv), estruturas (sc_ module) e processos (sc_ method) que flexibilizam a descrição de paralelismo, natural em hardware.
Adicionalmente, SystemC permite a descrição em diferentes níveis de abstração.
SystemC foi escolhido como a linguagem a ser adotada por dois motivos.
O primeiro é que SystemC atende as necessidades previamente expostas, tal como menor curva de aprendizagem, maior velocidade de simulação e maior confiabilidade do projeto descrito.
Menor curva de aprendizagem está associada ao fato de que durante a formação acadêmica normalmente tem- se maior contato com a linguagem C/ C+ do que com HDLs.
Quanto a maior velocidade de simulação, há a possibilidade de utilização de níveis de abstração superiores ao RTL.
Maior confiabilidade do projeto descrito está relacionada ao fato de que a linguagem permite que modelos gerados em alto nível de abstração sejam usados como estrutura passível de refinamento e validação para as descrições subseqüentes de maior grau de detalhe.
O segundo motivo da adoção de SystemC é estratégico, pois SystemC é visto como a mais forte candidata para se tornar padrão para a descrição de hardware.
Características adicionais que favorecem o uso de SystemC dá- se ao fato de que ela está vinculada a um organização responsável por a evolução e suporte a linguagem, a qual chama- se Open SystemC Initiative.
Esta organização disponibiliza uma lista de suporte de alcance mundial.
Adicionalmente, SystemC foi sido escolhida por grandes empresas como base para o desenvolvimento de ferramentas de modelagem, validação e síntese de hardware e sistemas.
Exemplos destas são Synopsys Inc. E CoWare Inc..
Adicionalmente, a captura e a validação de sistemas podem ser obtidas mediante uso de ferramental gratuito.
Apesar de permitir eficiência em projetos de SoC a partir de seu uso, SLDLs atuais não possuem suporte para a síntese automática de sistemas em altos níveis de abstração e necessitam de intervancão humana para sua interpretação e para gerar código passível de síntese automática.
A seguir, são apresentadas algumas ferramentas atualmente disponíveis para projetos de SoC que viabilizam a modelagem em nível de sistema.
Forge é um sistema para síntese de alto nível desenvolvido e comercializado por a Xilinx, Inc..
Forge tem como entrada uma descrição comportamental em Java e produz como saída Verilog RTL sintetizável ou ainda um bitstream para configurar o FPGA.
Além de a síntese em alto nível, Forge permite que a descrição seja direcionada para uma tecnologia alvo do fabricante, tal como FPGAs Virtex e Virtex II.
Ambas as ferramentas CoCentric SystemC Compiler e CoCentric System Studio são desenvolvidas e comercializadas por a Synopsys, Inc..
O CoCentric SystemC Compiler é um sistema de síntese de alto nível que limitadamente converte descrições comportamentais ou RTL escritas em SystemC para HDL sintetizável ou para EDIF.
Algumas restrições são adotadas para que seja possível tal conversão, como por exemplo, a definição detalhada de portas, o uso de métodos do tipo sc_ method proprietários de SystemC e tipos restritos de dados.
O CoCentric System Studio é um ambiente de especificação, modelagem e simulação de projetos que utilizam SystemC como linguagem de descrição de hardware.
Esta ferramenta possibilita a verificação e a análise de modelos algorítmicos, arquiteturais, hardware e software em diferentes níveis de abstração.
Adicionalmente, ela suporta a descrição de projetos em diferentes níveis de abstração.
SPARK é um sistema para síntese de alto nível desenvolvido por o grupo CECS1.
SPARK tem como entrada uma descrição comportamental em ANSI-C e produz VHDL RTL sintetizável.
Para tanto, o sistema usa uma tecnologia de compilador desenvolvido para detectar paralelismo ao nível de instrução.
Este mesmo compilador foi adaptado para a síntese em alto nível através da incorporação dos conceitos de exclusão mútua de operações, compartilhamento de recursos e modelos de custo de hardware.
O sistema SPARK provê um mecanismo de transformação de código e suporte a compiladores de transformação, o que permite ao projetista aplicar heurísticas para selecionar e controlar transformações individuais sob modelos de custo realístico para síntese de alto nível.
SPARK inclui um sistema completo de síntese de alto nível que provê um caminho a partir de a entrada de uma descrição comportamental ANSI-C com restrições ao uso de ponteiros, funções recursivas e o comando goto.
O sistema de síntese Rose trabalha com a síntese da comunicação.
Este sistema foi desenvolvido para complementar a funcionalidade alcançada por o VCC da Cadence, Inc., cuja finalidade é proporcionar mecanismos para exploração do espaço de soluções de projeto.
O fluxo proposto por o grupo que desenvolveu o sistema Rose é o de especificação do sistema, exploração de espaço de projeto e particionamento entre hardware e software utilizando a ferramenta VCC e posterior integração dos módulos heterogêneos através da síntese da comunicação para a implementação de um SoC, utilizando o Rose.
Uma solução para modelagem em SystemC de projeto de SoCs, que não utiliza ferramentas comerciais, obtém- se uma especificação executável do modelo descrito.
Para validação da funcionalidade do modelo descrito em SystemC, é possível utilizar funções da linguagem C+ (e.
g cout, printf) ou gerar arquivos de formas de onda.
SystemC é composto por um núcleo de simulação, que permite analisar o conteúdo de sinais utilizados nos módulos em SystemC, a ISDB.
Depois de compilado e executado o modelo implementado em SystemC, estes arquivos de formato de onda são gerados, sendo armazenado os valores contidos nos sinais (sc_ signal) e portas (sc_ in, sc_ out, sc_ inout).
Arquivos do tipo VCD podem ser lidos por a ferramenta de domínio público GTKWave, sendo gerada representação gráfica da forma de onda rastreada.
Esta ferramenta pode ser executada nas Desde a década de 90, cada vez mais núcleos IP processadores e outros componentes reutilizáveis têm sido integrados num único Ci.
Estudos prevêem que futuramente SoCs sejam compostos por centenas de núcleos IP.
A comunicação entre núcleos IP é tradicionalmente realizada seguindo uma ou duas combinações de abordagens:
Canais dedicados e barramentos.
Canais dedicados não são vistos como uma abordagem eficiente, por dificultar o reuso de projetos.
Barramentos superam este problema, porém apresentam limitações tais como a diminuição da freqüência de operação com o aumento da densidade de SoCs, devido a o uso compartilhado do canal de comunicação por um número crescente de IPs e à escalabilidade limitada.
Algumas práticas podem ser adotadas para diminuir estas limitações, tal como a utilização de arquiteturas de barramento hierárquicas.
Exemplos destas são CoreConnect e Amba.
Todavia, esta abordagem ainda agrega problemas, tais como a possibilidade de comunicação bloqueante atingindo todo o barramento hierárquico, a diferença entre as freqüências de operação e largura de banda entre cada barramento e principalmente a forma desestruturada de montagem destes barramentos.
Todos estes fatores afetam a escalabilidade em sistemas de grande porte.
Uma proposta que supere tais problemas e que venha a atender as futuras necessidades de projetos tem sido sugerida a partir de o uso de redes complexas de comunicação intrachip (ou NoCs, do inglês Networks on chip) como mecanismo de comunicação entre núcleos IP de um projeto de SoC[ BEN01, KUM02, WIN01].
Esta proposta deve- se ao fato de NoCs apresentam, quando comparadas a barramentos tradicionais, melhorias em:
Eficiência energética, confiabilidade, reusabilidade, comunicação não bloqueante e escalabilidade de largura de banda.
NoCs são estruturas de interconexão de núcleos IP em SoCs, assim como barramentos, porém mais complexos que estes, visto que fazem uso de conceitos mais elaborados, como são vistos a seguir.
Projetos de NoCs adaptam conceitos originalmente surgidos nas áreas de redes de computadores e sistemas distribuídos.
Estes incluem conceitos tais como topologias de rede, roteamento, chaveamento, uso de pacotes e uma pilha de protocolos de comunicação.
Para tanto, núcleos IP assumem a característica de elementos computacionais e chaves a característica de elementos de comunicação tais como adaptadores de rede, roteadores, etc..
Uma mensagem consiste de um conjunto coerente de informações a ser transmitido entre uma fonte e um destino.
Um pacote é a unidade de transmissão de informação empregada pelo meio de comunicação para transmitir mensagens.
Pacotes são normalmente constituídos de um cabeçalho (em inglês header), corpo (em inglês payload) e cauda (em inglês trailer).
Em geral, o cabeçalho contém dados úteis para o roteamento, o corpo da mensagem contém dados úteis ao núcleo IP destino e a cauda contém dados que garantem a coerência do pacote que está sendo enviado.
Em NoCs a comunicação entre os núcleos IP se dá através da troca de mensagens efetivada com freqüência através do envio de pacotes.
Problemas que devem ser evitados em NoCs, assim como em redes de computadores e sistemas distribuídos, são a possibilidade de ocorrência de situações de deadlock, livelock e starvation.
Deadlock é definido como uma dependência cíclica entre elementos de comunicação, onde estes solicitam recursos para transmitir informação, mas estes jamais serão concedidos devido a a dependência cíclica citada.
Uma situação de deadlock é ilustrada na Figura 10, para uma rede com topologia malha bidimensional.
Livelock é definido como uma situação em que uma informação transmitida jamais atinge seu destino, devido a o fato desta percorrer caminhos cíclicos e o ciclo não incluir o destino da informação, conforme ilustrado na Figura 11.
Este problema está normalmente associado à utilização de algoritmos de roteamento não mínimos, definidos mais adiante.
Starvation é uma condição onde, dada uma estrutura de comunicação, não é possível definir, de forma quantitiva ou qualitativa, um limite superior para os recursos necessários para transmitir uma dada informação de uma fonte para um destino (postergação indefinida).
Tal situação pode ser exemplificada quando a todo o momento em que um elemento de comunicação solicita roteamento o seu caminho está ocupado por outro pacote.
Este problema está diretamente relacionado a algoritmos de arbitragem.
Uma rede de interconexão é composta por duas partes, quais sejam:
Serviços e sistemas de comunicação.
Serviço é o que a rede deve prover, ou seja, a garantia de entrega de mensagens sem erros.
Associado a QoS), tais como latência média, taxa de recepção de mensagens, largura de banda, taxa máxima e média de erros de transmissão, etc..
O sistema de comunicação é a estrutura para que a rede possa prover o serviço com a QoS necessária.
Esta estrutura está associada as escolhas de implementação física adotadas tais como topologia, algoritmo de roteamento e modos de chaveamento.
Chaves são os elementos básicos de comunicação da NoC.
A forma como estes chaves estão interconectados definem a topologia da NoC, normalmente representável através de grafos.
Chaves podem ser consideradas os vértices de um grafo e suas ligações os arcos.
De acordo com a topologia, redes de interconexão podem ser classificadas como estáticas ou dinâmicas.
Redes estáticas são caracterizadas por conexões ponto a ponto entre as chaves, como ocorre para topologias tais como anel, malha, torus e árvore, representadas na Figura 12.
Redes dinâmicas usam conexões multiponto entre as chaves, como ocorre em barramentos e chaves crossbar.
Além de a topologia, mecanismos que definem a comunicação na rede têm de ser descritos.
Tais mecanismos devem garantir questões como a entrega da mensagem, o caminho a ser adotado na rede e a validade da mensagem transferida entre um recurso fonte e seu destino.
Segundo Guerrier, uma NoC transfere dados de um núcleo IP a outro baseado em troca de mensagens, respeitando um determinado protocolo.
Para redes de computadores, protocolos de comunicação são definidos a partir de o Modelo de Referência de Interconexão de Sistemas Abertos (em inglês, Open Systems Interconnect Reference Model, OSI-RM) proposto por a International Organization for Standardization (Iso).
O OSI-RM define uma pilha de protocolos, de 7 camadas cujas 4 camadas inferiores são:
Camada Física:
Em ela é definida a organização de interconexões da rede, ou seja, a distribuição dos canais de comunicação.
Esta camada é responsável por os detalhes referentes à transmissão e recepção de pacotes, sem a preocupação de detecção de erros por o hardware.
Em este nível, são definidos os parâmetros elétricos dos sinais, como nível de tensão, freqüência, forma da onda e ciclo de serviço.
Um dos problemas deste nível é a sincronização entre os núcleos, pois os mesmos podem ter domínios de relógio diferentes.
Camada de Enlace de Dados: O principal propósito desta camada é diminuir a falta de confiabilidade na transferência de dados sobre o meio físico.
Esta camada define o protocolo para transmitir dados entre um recurso e uma chave e entre duas chaves.
Camada de Rede:
É responsável por prover conexões e por rotear pacotes na rede de comunicação.
Em esta camada são tratados os endereços dos pacotes que chegam e saem das chaves para a definição da direção que o pacote irá percorrer.
Camada de Transporte:
É responsável por acesso de baixo nível a rede e por transferir mensagens entre os clientes (núcleos IP).
Adicionalmente esta camada é responsável por particionar as mensagens em pacotes, gerenciar a ordem dos pacotes, controlar o fluxo e gerar o endereçamento físico.
A relação entre as camadas do protocolo OSI-RM com NoCs pode ser definida da seguinte forma:
Camada física:
Em ela são definidos o tamanho do canal de comunicação, os sinais de controle, a topologia;
Camada de enlace de dados:
Em ela são definidas questões de controle do dado que estão sendo transferidos tais como:
A forma de armazenamento temporário, controle de fluxo e arbitragem dos pacotes.
Em esta camada também podem ser empregados métodos de detecção e controle de erros na transmissão do pacote;
Camada de rede:
Em ela é definido como o pacote fará seu caminhamento na rede.
Assim, uma das principais funções é a definição do algoritmo de roteamento baseado no endereçamento definido na rede;
Camada de transporte:
Em ela é implementada a organização de como o pacote deve ser montado na origem ou remontado no destino.
Necessariamente esta estrutura está relacionada com a estrutura do pacote e a semântica de comunicação definida na rede.
O modo de chaveamento de uma rede de comunicação é definido como a estratégia por a qual o pacote será transmitido de sua fonte até o destino.
Os modos de chaveamento podem ser definidos por a reserva de um canal de comunicação entre a origem de um pacote e seu destino ou por o armazenamento temporário do pacote que permite caminhamento dinâmico na rede.
Os principais modos de chaveamento são:
Chaveamento de circuito (circuit switching):
É aquele onde previamente ao envio de mensagens, deve ser estabelecido um caminho da chave fonte até a chave destino denominado conexão e logo após, são enviadas todas as mensagens;
Chaveamento de pacotes (packet switching):
É aquele onde a transferência da informação, entre a fonte e o destino, é realizada a partir de uma estrutura padronizada, denominada pacote.
Em este modo de chaveamento, o caminho a ser percorrido por o pacote é definido em tempo de roteamento, podendo ser armazenado parcialmente em memória durante o caminho.
Quanto a a forma de armazenamento dos pacotes no modo de chaveamento de pacotes, destacam- se três tipos, quais sejam:
STORE-AND-FORWARD (armazenar e passar):
A chave não pode repassar o pacote até que o tenha recebido por inteiro;
Virtual Cut--THROUGH (cortar através):
A chave pode repassar o pacote assim que a próxima chave der garantias de que pode receber todo o pacote;
Wormhole: É uma variante do modo cut-through que permite o uso de estruturas de armazenamento menores que o cut-through visto que não precisa armazenar todo o pacote numa chave.
Em ele o pacote é transmitido entre as chaves em unidades chamadas flits (flow control digits), Apenas o flit de cabeçalho tem a informação de roteamento.
Os flits restantes seguem o mesmo caminho do header.
O modo de chaveamento de pacotes pressupõe uma estrutura de armazenamento temporário dos dados na chave.
Diferentes estratégias de memorização podem ser adotadas cada qual associada a um controle de fluxo dos pacotes, e isto tem influência marcante no desempenho da rede.
De entre as estratégias de memorização destacam- se o armazenamento na entrada, armazenamento central compartilhado ou na saída.
Armazenamento na entrada consiste em inserir filas na entrada das chaves, sendo esta uma estratégia simples de armazenamento temporário por dois fatores:
É definido um espaço fixo de uso da memória e, os dados são lidos na mesma ordem em que são escritos na memória.
Apesar de simples, ao uso de armazenamento na entrada está associado um problema denominado bloqueio do header do pacote (em competindo por a mesma porta de saída, por exemplo, a porta C. Somente um dos pacotes será transmitido por vez, enquanto que o outro pacote ficará aguardando na fila de sua porta de origem a liberação da porta C. Supondo que o pacote da porta A está sendo transmitido por a porta C, o pacote da porta B terá de ficar aguardando uma próxima oportunidade de envio à porta C. Se um novo pacote chegar a porta B, e este pacote tiver como destino na porta D, este novo pacote terá de aguardar o envio do primeiro pacote armazenado na fila da porta B. Este novo pacote na armazenado na fila da porta B poderia estar sendo enviado para a porta D, porém também ficará bloquedo na fila.
Esta situação descreve o problema de Armazenamento temporário central compartilhado faz uso de um buffer onde as portas de entrada de uma chave irão depositar os dados a serem transmitidos.
Diferente do armazenamento de entrada, o espaço de memória a ser utilizado por as portas de entrada é distribuído dinamicamente entre os pacotes em ele armazenados.
Em este caso, o tamanho mínimo do buffer deve ser igual ao tamanho do dado que será trocado multiplicado por o número de portas.
Pressupondo uma chave de cinco portas de entrada e o tamanho dos dados é igual a 2 bytes, é necessário um buffer de pelo menos 10 bytes.
O endereço do buffer onde os dados provenientes de uma porta da chave serão armazenados é dinamicamente definido.
Armazenamento temporário central compartilhado oferece uma melhor utilização de memória do que aquelas proporcionadas por as abordagens onde este espaço é prévia e estaticamente alocado às portas de entrada.
Apesar de isto, o compartilhamento completo do buffer pode gerar problemas semelhantes ao HOL.
Supor duas portas, A e B, com pacotes destinados à mesma porta de saída C. Se a porta de saída C estiver transferindo o pacote da porta de entrada A e a porta de entrada B continuar recebendo dados, isto poderá levar ao preenchimento do buffer centralizado.
Esta situação de recebimento de dados por a porta B e conseqüente armazenamento poderá ocasionar o fim do espaço em memória.
Conseqüentemente as demais portas de entrada não poderão armazenar seus pacotes, que não serão transmitidos e ficarão bloqueados.
Em o armazenamento temporário de saída são inseridas filas nas portas de saída, replicadas para cada uma das portas de entrada.
Ou seja, cada porta de saída possui N filas, sendo N o número de portas de entrada.
O controle de escrita nestas filas pode ser realizado de duas formas.
Em a primeira, há N portas de escrita na fila operando na mesma velocidade que as portas de entrada.
Esta abordagem tem como desvantagem o aumento do tamanho de hardware.
Em a segunda, há apenas uma porta de escrita na fila operando numa velocidade N vezes maior que a velocidade de operação da porta de entrada.
Esta abordagem tem como desvantagem a queda de desempenho.
Adicionalmente, o uso de armazenamento temporário de saída exige a implementação de um controle de fluxo entre a porta de entrada e de saída, aumentando a complexidade desta abordagem.
O uso de algoritmos de arbitragem proporciona meios para resolver conflitos de requisições simultâneas de serviço, através do gerenciamento de acesso a recursos compartilhados no elemento de comunicação da rede.
A o receber requisições de roteamento simultâneas de diferentes portas de entrada da chave decorrente da chegada de novos pacotes, a arbitragem atribui uma prioridade a cada porta e encaminha pacotes para roteamento conforme esta prioridade.
A a arbitragem está relacionado o problema de starvation que pode ser amenizado ou mesmo resolvido de acordo com o critério adotado.
De entre os critérios de arbitragem exemplificam- se a prioridade estática, prioridade dinâmica, escalonamento por idade, FCFS (First Come First Served), LRS (Least Recently Served) e RR (Round-Robin) cujas vantagens e inconvenientes são amplamente discutidos na literatura Roteamento é o método usado para definir o caminho de pacotes na rede.
Dependendo do algoritmo de roteamento implementado, a rede pode apresentar variação no desempenho da transferência do pacote devido principalmente ao maior ou menor caminho percorrido.
Algoritmos de roteamento têm influência direta em algumas propriedades da interconexão de rede, quais sejam:
Conectividade: Garantir que qualquer pacote a partir de a fonte chegará em seu destino indefinidamente;
Ausência de livelock e deadlock:
Garantir que nenhum pacote ficará bloqueado na rede;
Adaptatividade: Garantir que os pacotes poderão adequar seu percurso quando na presença de problemas tais como congestionamento de rede;
Tolerância a falhas:
Garantir a entrega de um pacote mesmo quando alguma parte da rede apresenta defeito (chave, conexão, etc).
Os algoritmos de roteamento podem ser classificados de acordo com diversos critérios.
Em a literatura existem algumas propostas de taxonomia para algoritmos de roteamento.
Alguns critérios e classificações baseadas nestes são:
O momento de realização do roteamento:
Dinâmico quando realizado em tempo de execução e estático quando realizado em tempo de compilação;
O número de destinos das mensagens:
Unicast, quando os pacotes têm apenas um destino e multicast quando os pacotes têm mais de um destino;
O local onde a decisão de roteamento é tomada:
Centralizado quando um único elemento define o caminho de todos os pacotes, fonte quando o caminho do pacote é definido na origem e distribuído quando o caminho do pacote é definido por os elementos presentes ao longo de seu caminho;
A forma de implementação:
Baseado em tabelas, quando o caminho é definido de acordo com uma tabela armazenada em memória ou baseado em máquinas de estado, quando o caminho é definido a partir de um algoritmo implementado em hardware ou software;
A adaptatividade:
Determinístico, quando o caminho entre a fonte e o destino é sempre o mesmo ou adaptativo quando o caminho entre a fonte e o destino é determinado por fatores da rede, como congestionamento.
Roteamentos adaptativos podem ser classificados de acordo com a abordagem do algoritmo:
Quanto a a progressividade:
Progressivo se o cabeçalho sempre avança reservando canais ou regressivo se o cabeçalho puder retornar liberando os canais previamente reservados;
Quanto a a minimalidade:
Mínimo quando a próxima chave em direção a o destino estiver mais perto que a anterior e não mínimo quando o algoritmo de roteamento permitir o afastamento eventual do pacote do seu destino;
Quanto a o número de caminhos:
Completo quando todos os caminhos ao destino são possíveis ou parciais quando apenas um conjunto limitado de caminhos é viável.
NoCs são propostas como um novo paradigma de interconexão de núcleos IP adequado para uso no projeto de SoCs.
Diversas pesquisas têm sido desenvolvidas.
Em esta Seção, apresenta- se parte do panorama atual de NoCs presente na literatura, baseado em, cuja tabelam com um resumo do estado da arte em NoCs é reproduzido na Tabela 3.
Quanto a o modo de chaveamento, uma escolha comum à maioria das NoCs revisadas é a escolha do modo chaveamento por pacotes, informação esta não é explicitada na tabela.
A exceção é a NoC aSoC, onde a definição do caminho que cada mensagem assume é fixada em tempo de síntese de hardware, o que caracteriza um chaveamento por circuito.
A topologia de rede e a estratégia de chaveamento são apresentadas na primeira coluna da Tabela 3.
A topologia de rede predominante na literatura é a malha 2D.
A razão para a escolha deriva de três vantagens:
A facilidade de implementação usando a tecnologia planar de CIs atual, a simplicidade de estratégias de chaveamento XY e a escalabilidade da rede.
Outra abordagem é o uso da topologia toro 2 D, para reduzir o diâmetro da rede.
A topologia toro 2D dobrado é uma opção para reduzir o custo crescente de fios quando comparado a topologia toro.
Um problema das topologias malha e toro é a latência da rede associada.
Duas propostas alternativas de NoCs revisadas são apresentadas para superar este problema.
A NoC SPIN e a chave proposta em empregam a topologia árvore gorda, enquanto a NoC Octagon sugere o uso de topologia anel cordal, ambas trabalhando com um diâmetro de rede pequeno, conseqüentemente com uma latência reduzida.
Com relação a a estratégia de chaveamento, a informação sobre os algoritmos adotados é ainda escassa.
Isto indica que mais pesquisa é necessária nesta área.
Em o momento, sabe- se que o algoritmo XY adaptativo é propenso a deadlock, todavia há soluções para prover chaveamento XY sem perigo de deadlock.
O segundo parâmetro quantitativo importante de chaves em NoCs é o tamanho do flit.
Em a Tabela 3 é possível classificar as abordagens em dois grupos, os que focam nas tecnologias futuras de SoCs e os adaptados para as limitações existentes.
O primeiro grupo inclui as propostas de Dally e Kumar, onde canais de chaveamento possuem barramentos de 300 fios, sem afetar significativamente a área total do SoC.
Isto pode ser alcançado e.
g por o uso de tecnologias futuras de 60 nm para construção de CIs de 22mm x 22mm, com uma NoC 10x10 para conectar 100 IPs de 2mm x 2mm.
Todavia, isto é inatingível atualmente.
O segundo grupo envolve chaves com o tamanho de flit variando entre 8 e 64 bits.
Este tamanho é similar ao tamanho dos dados com o qual os processadores atuais trabalham.
Os trabalhos que provêem um protótipo, Marescaux e, tem os menores tamanhos de flit quando comparados às demais propostas, quais sejam, 16 e 8 bits respectivamente.
O próximo parâmetro na Tabela 3 é a estratégia de armazenamento das chaves.
A maioria das NoCs emprega armazenamento na entrada da chave.
Visto que armazenamento na entrada necessita de apenas uma fila na entrada, isto causa pouco consumo de área, justificando a escolha.
Todavia, filas de entrada causam o já mencionado problema de bloqueio na cabeça do pacote.
Para resolver o problema, filas de saída podem ser usadas, conforme, com um custo alto, visto que esta solução aumenta o número de filas de armazenamento na chave.
Uma solução intermediária é encontrada via uso de filas virtuais de saída (em inglês, Virtual Output Queues, VOQ) associado com multiplexação temporal de canais, como proposto por.
Outro importante parâmetro é o tamanho das filas, importante no desempenho da rede bem como consumo de área da chave.
Uma fila grande leva a uma rede com baixa contenção, alta latência de pacotes e chaves grandes.
Filas pequenas levam à situação oposta.
O último parâmetro estrutural é o tipo de interface entre o núcleo IP e a chave.
O uso de uma interface padronizada para comunicação intrachip é uma tendência na indústria e no meio acadêmico.
O uso de interfaces padronizadas tem aumentado a possibilidade de reuso, sendo visto como uma característica habilitadora para projetos de SoC futuros.
Uma NoC com uma interface entre núcleos IP e chave tal como a proposta por, é menos habilitada a agregar núcleos IPs fornecidos por terceiros.
As duas principais interfaces padronizadas, VCI e OCP são utilizadas por duas das propostas de NoCs apresentadas na Tabela 3.
As NoCs Proteo e o SPIN utilizam interfaces VCI, enquanto a NoC de Sgroi e a Hermes empregam a interface OCP.
Estes padrões hoje evoluem para se integrarem, OCP se tornando o padrão físico para núcleos IP.
A quinta coluna da Tabela 3 coleta resultados sobre o tamanho da chave.
É interessante observar que duas abordagens alvo para ASICs, ambas com tamanho de flit igual a 32 bits, tem dimensões similares, em torno de 0,25mm para tecnologias similares.
Adicionalmente, sistemas prototipados produziram resultados de área similares em LUTs de FPGA.
Este dado indica a necessidade de estabelecer uma relação entre o tamanho da chave e consumo excessivo de área na parte de comunicação em projetos de SoC.
É razoável esperar que a adoção de NoCs por projetistas de SoCs esteja vinculado ao ganho de desempenho na comunicação intrachip.
Por outro lado, baixo consumo de área quando comparado com arquiteturas de barramento padrão é outra importante questão.
Uma especificação de um projeto de SoC normalmente irá determinar um consumo máximo de área permitido para a comunicação intrachip, assim como o desempenho mínimo esperado.
Esta especificação será baseada em características da comunicação entre núcleos IP, no tamanho da chave, no tamanho do flit (i.
e largura do canal de comunicação) e na cardinalidade das portas da chave.
Estes valores são fundamentais para permitir uma estimativa do consumo de área e do pico de desempenho para comunicação intrachip.
A adoção de NoCs está assim vinculada à avaliação quantitativa e à facilidade com a qual os projetistas farão uso da abordagem de NoCs em projetos reais.
O pico de desempenho estimado, apresentado na sexta coluna da Tabela 3, é um parâmetro que necessita análise adicional para prover uma comparação significativa entre diferentes NoCs.
Desta forma, esta coluna apresenta diferentes unidade de desempenho para diferentes NoCs.
Esta coluna deve ser considerada como meramente ilustrativa para possíveis valores de desempenho.
A maioria das estimativas é derivada da produção de três valores:
Número de portas da chave, tamanho do flit e estimativa da freqüência de operação.
Nenhuma medida de desempenho de dados foi encontrada em publicações revisadas.
O valor associado à NoC proposta por deve ser isto com cautela.
A razão é que os dados refletem um limite de tecnologia, que pode ser alcançado por o envio de múltiplos dados através de um fio em cada ciclo de relógio.
QoS). A forma mais comum de QoS em NoCs é através da implementação de chaveamento por circuito.
Esta é uma maneira de garantir a vazão e assim a QoS por um dado caminho de comunicação.
A desvantagem desta abordagem é que a largura de banda pode ser desperdiçada se o caminho de comunicação não for utilizado a todo o momento durante a avaliação de uma conexão.
Adicionalmente, visto que a maioria das abordagens combina o chaveamento por circuito com técnicas de melhor esforço, isto traz como conseqüência o aumento do consumo de área da chave.
Este é o caso de propostas de NoCs apresentadas em.
Canais virtuais são uma forma de atingir QoS sem comprometer a largura de banda, especialmente quando combinado com técnicas de multiplexação por divisão de tempo (em inglês, time division multiplexing, TDM).
A última técnica, exemplificada em evita que pacotes permaneçam bloqueados por um longo tempo, desde que flits de diferentes entradas de uma chave sejam transferido de acordo com uma alocação de fatias de tempo pré-definida, associada com cada saída da chave.
É esperado que a utilização de SoCs atuais e futuros sejam dominados por aplicações que trabalham com grandes fluxos de dados.
Conseqüentemente, suporte a QoS é considerada uma característica fundamental por autores de NoCs.
Finalmente, é possível constatar que os resultados obtidos com implementações de NoCs permanecem ainda muito escassos.
Nenhuma das quatro implementações ASIC encontradas na literatura fornecem informações se o projeto corresponde a CIs realmente funcionais.
Adicionalmente, três abordagens são apenas projetos esboçados.
Por outro lado, duas NoCs foram relatadas como tendo sido prototipadas em FPGA, as propostas por e.
Tendo sido apresentado o panorama atual de projetos de NoCs, esta Seção tem por objetivo descrever a proposta de NoC adotada neste trabalho, denominada Hermes.
As características básicas desta NoC aparecem na última linha da Tabela 3.
O principal objetivo da chave numa NoC é proporcionar um mecanismo de transferência de mensagens confiável entre núcleos IP.
Para tanto, chaves são formadas por lógica de arbitragem, um algoritmo de roteamento, portas e armazenamento de entrada e/ ou saída.
As portas conectam- se a núcleos IP e/ ou a outras chaves para formar a rede de interconexão.
A chave Hermes contém um bloco de controle centralizado e cinco portas bidirecionais denominadas NORTH, SOUTH, EAST, WEST, Local.
A porta Local é dedicada ao núcleo IP local e as demais portas são utilizadas para conexão a outras chaves, de acordo com a topologia adotada.
O diagrama de blocos da chave Hermes é mostrado na Figura 13.
Em a lógica de controle são implementados o algoritmo de arbitragem (centralizado) e o algoritmo de chaveamento de pacotes.
O modo de chaveamento utilizado é wormhole, por proporcionar baixa latência e menor consumo de área, quando comparado aos demais modos de chaveamento por pacote.
Associado ao uso de wormhole, inclui- se filas de armazenamento temporário em cada porta de entrada, com tamanho parametrizável.
Esta abordagem contribui para a redução de chaves que ficam bloqueadas para um único pacote que está sendo transmitido por a rede, o que permite maior velocidade de transmissão de dados.
Para ser transmitido por a rede de interconexão, o pacote é dividido em flits, que são as menores unidades de transmissão.
O tamanho do flit é parametrizável, todavia a alteração de tamanho representa necessidades de mudança na forma como os dados devem ser avaliados para roteamento.
Atualmente os tamanhos de flit com que se trabalha são 8, 16, 32, e 64 bits.
A organização do pacote foi definida da como segue, tendo em vista flits tamanho igual a 16 bits:
O primeiro flit do pacote armazena os endereços de origem do pacote e de destino;
O segundo flit contém o tamanho do corpo da mensagem, expresso em flits;
Os demais flits representam o corpo da mensagem.
A lógica de controle é composta por dois módulos, arbitragem é centralizada e roteamento.
Quando um novo pacote chega a chave, o cabeçalho da mensagem é armazenado e uma requisição de roteamento é realizada.
A arbitragem é definida com prioridade rotativa (round robin) para atendimento das requisições de roteamento.
Assim, de acordo com a prioridade das portas que estão requisitando roteamento seu pedido é atendido.
O algoritmo de roteamento básico é o XY puro.
O endereçamento na rede é dado por as coordenadas XY de cada chave.
O cabeçalho do pacote possui endereço XYalvo do destino e a chave onde se encontra o cabeçalho do pacote contém o endereço XYlocal.
Assim, o roteamento com o algoritmo XY puro é realizado da seguinte forma:
Ainda referente a o algoritmo de roteamento, a reserva de portas somente é possível se a porta destino estiver livre, ou seja, se a porta por a qual o pacote será enviado não estiver reservada.
Por serem portas bidirecionais, estas podem receber e enviar flits ao mesmo tempo, conforme mostra a Figura 14.
A forma como as chaves se interconectam define a topologia da rede de interconexão.
Para a proposta da NoC Hermes original foi utilizada a topologia malha, onde cada chave está ligada a um núcleo IP por a porta Local e, dependendo da posição da chave na rede, a outras chaves com as demais portas, conforme a Figura 15.
Apesar de esta topologia ter sido definida, a chave Hermes permite que outras topologias também sejam implementadas tais como toro e hipercubo.
Para tanto, as chaves têm de ser interconectadas de forma a representar tais topologias e o algoritmo de roteamento tem de ser adequado.
Modelagem TL e RTL ­ Um estudo de caso comparativo O padrão de descrições de entrada suportado hoje por as ferramentas de síntese automáticas de hardware é denominado de nível RTL.
Uma interpretação formal do nível de abstração denominado RTL aparece em.
Em esta referência, Bailey e Gajski definem o modelo máquina de estados com dados (FSMD) e usam- no como base para estabelecer uma semântica de interpretação precisa para modelos RTL.
Ainda naquela referência, também é proposto um método de refinamento de descrições RTL em 5 fases, gerando 5 estilos RTL com níveis de abstração decrescente.
O primeiro estilo denomina- se RTL não mapeado, os três seguintes são RTLs mapeados e o último é RTL com exposição de controle.
Assim, ao ser analisada mais detalhadamente percebe- se que a própria definição RTL pode incluir um conjunto de níveis de abstração.
Informalmente, RTL consiste na descrição de módulos de hardware em termos de um bloco de dados e uma unidade de controle.
O bloco de dados é composto estruturalmente usando um conjunto de elementos de memórias (registradores), elementos de processamento (ULA, multiplicadores, etc) e suas interconexões.
A unidade de controle é uma descrição comportamental de como o fluxo de dados é comandado.
A modelagem RTL utiliza precisão em nível de ciclos de relógio para a descrição de blocos de dados e unidades de controle.
Atualmente, a maior parte das ferramentas de síntese aceita modelos RTL como entrada para produção de projetos de alta qualidade.
Apesar de não sintetizáveis, descrições de sistemas partindo de níveis de abstração mais abstratos permitem ter uma visão geral do sistema mais rapidamente.
Diminuir a quantidade de detalhes dos passos de implementação e centrar na funcionalidade a ser atingida tende a diminuir a complexidade de descrição, validação e gerenciamento de um sistema.
A proposta adotada neste trabalho é a de implementação de projetos iniciando em nível de transação, conforme detalhamento fornecido no ciclo de relógio, e a comunicação é descrita de forma abstrata sem detalhamento de protocolos.
A partir de esta descrição abstrata, um conjunto de passos deve ser adotado até alcançar uma descrição sintetizável.
A Seção a seguir apresenta uma proposta de fluxo de projeto partindo de descrições Tl.
Modelagem TL é considerada importante para análise de desempenho, particionamento de hardware e software, geração de testes de padrões para vários níveis de abstração, entre outras possibilidades.
O uso de modelagem Tl permite simplificar o esforço de projeto e aumentar da velocidade de validação dos modelos.
Conforme discutido no Capítulo anterior, os principais desafios ao se empregar modelagem Tl para projetistas RTL são os de abstrair o emprego do sinal de relógio e protocolos de comunicação específicos.
Quando se parte de descrições em mais alto nível de abstração, como as descrições em Tl, um conjunto de passos se faz necessário para alcançar uma descrição RTL sintetizável.
Atualmente, assim como não há consenso sobre a modelagem Tl, o conjunto de passos que leve esta modelagem a uma descrição sintetizável também é ausente.
Em o presente trabalho o ponto inicial da modelagem é Tl, sendo a computação descrita de modo funcional sem precisão no ciclo de relógio e a comunicação descrita através de requisição de serviços.
Para alcançar uma descrição RTL sintetizável, um conjunto de passos é proposto neste Capítulo.
Para ilustrar o conjunto de passos propostos para o refinamento do modelo Tl, um estudo de caso genérico entre um processador e uma memória é apresentado.
Este exemplo foi adotado, pois o processador se comunica com a memória apenas para realizar operações de leitura ou escrita.
Esta abordagem elimina a representação de refinamento de interfaces mais complexas, que envolvem mais operações, e objetiva a ilustração da estratégia de refinamento.
Através de um conjunto de combinações possíveis de serem alcançadas com as diferentes camadas de abstração definidas para a computação e comunicação, conforme apresentadas no Capítulo anterior, um conjunto de quatro passos de refinamento é aqui proposto.
As possíveis combinações citadas e os passos de refinamento são ilustrados na Figura 16.
O primeiro passo no fluxo de projeto Tl, captura de projeto, consiste em descrever o sistema como um conjunto de componentes de alto nível de abstração usando, por exemplo, diagramas de blocos.
Componentes são descritos como módulos que contêm processos, portas e canais abstratos de comunicação.
Processos definem o comportamento de um módulo particular e provêem um método para expressar concorrência.
Portas disponibilizam interfaces de comunicação entre outros módulos, interfaces estas que definem quais serviços estão disponíveis em cada módulo.
As portas dos diferentes módulos que se comunicam estão conectadas por canais abstratos de comunicação.
Um canal abstrato de comunicação implementa uma ou mais interfaces, onde uma interface é simplesmente um conjunto de métodos que definem os serviços disponíveis para os módulos.
Canais abstratos de comunicação encapsulam protocolos de comunicação abstratos, tal como protocolos baseados em filas.
Para que diferentes módulos possam se comunicar, é necessário que haja um canal abstrato conectando os dois.
Este canal deve implementar as interfaces de comunicação de cada módulo.
Para concretizar a comunicação entre os módulos, dentro de um processo é necessário chamar um método, situação esta ilustrada na Figura 17, onde um processador requisita uma leitura/ escrita numa memória.
Após garantir o correto funcionamento do projeto descrito, seguem os passos de refinamento do sistema, o passo 2, representado na Figura 16.
A a parte de computação do módulo é inserida a característica de temporização.
São definidas características tal como a pressuposição do tempo de execução de alguns algoritmos descritos na parte computacional.
Para garantir uma maior precisão, pode ser inserido o sinal de relógio.
Apesar de incluir características de tempo a descrição da computação ainda não é sintetizável.
O passo 2 de refinamento, no que se refere a comunicação, mantém o canal abstrato, porém sendo que este apenas implementa métodos de envio e recebimento de dados.
Diferentemente do passo 1 de refinamento, onde havia requisições de serviços por parte de os módulos, agora os dados são transferidos entre os módulos e lá são interpretados.
O resultado é ilustrado na Figura 18.
Em esta situação, por exemplo, ao solicitar uma escrita em memória, o processador envia 3 informações que representam a operação a ser realizada, o endereço e o dado, sendo esta última informação sendo enviada no caso de uma escrita.
Outra proposta possível para esta operação é a transferência de tipos estruturados (e.
g struct em C+).
Para este último caso, o tipo estruturado deve conter três campos, um com o tipo de operação a ser realizada, um com a posição e um com o dado.
Em este refinamento há o detalhamento das informações que devem ser trocados entre os diferentes módulos o que permite um refinamento mais fácil.
O resultado do refinamento realizado no passo 2 pode ser apontado na Figura 20 no ponto B1.
Sendo novamente validado o projeto, de acordo com um plano de validação previamente elaborado, segue passo 3 de refinamento conforme Figura 20.
Em o passo 3 o protocolo de comunicação entre os módulos e os sinais utilizados para isto são detalhados, sendo eliminado o canal abstrato.
Há necessariamente a inclusão de um sinal de sincronismo na descrição dos módulos neste passo de refinamento, conforme ilustrado na Figura 19.
A computação dos módulos faz uso deste sinal de sincronismo, sendo esboçada uma primeira versão da máquina de estados de controle da comunicação.
Este nível de abstração difere do RTL por ainda permanecer abstraído o tipo de dado que será compartilhado entre os módulos, o que facilita o uso de alguns passos adicionais de refinamento, caso necessário.
O passo final de refinamento, o passo 4, leva a uma descrição RTL sintetizável.
Os protocolos de comunicação são definidos e a temporização das ações é definida com precisão em ciclos de relógio.
A computação é descrita de forma sintetizável, assim como os tipos de dados que serão compartilhados.
A validação do sistema neste nível é realizada por simulação RTL, sendo utilizado, preferencialmente, o mesmo padrão de teste é projetado para o modelo Tl.
Esta abordagem garante a coerência do projeto desde a fase inicial de modelagem.
Os passos seguintes no fluxo de projeto podem ser executados automaticamente por ferramentas hoje disponíveis e pressupõem:
Síntese lógica do modelo RTL e síntese física.
O restante deste Capítulo tem por objetivo demonstrar a utilidade do uso da linguagem SystemC para implementar a estratégia de refinamento proposta usando uma seqüência de descrições executáveis do sistema.
Adicionalmente, mostra- se que a linguagem possui características que a tornam adequada para lidar com descrições abstratas e concretas de sistemas digitais complexos.
Apresenta- se a seguir um estudo de caso de sistemas de hardware.
A linguagem SystemC é usada aqui para modelagem das diversas descrições do nível Tl ao nível RTL (sintetizável).
Para comparações de tamanho de hardware ocupado e desempenho em simulação, é utilizado um modelo equivalente, descrito em VHDL.
Para a síntese lógica do modelo descrito em SystemC RTL foram utilizadas as ferramentas CoCentric SystemC Compiler da Synopsys, para traduzir a descrição SystemC RTL para VHDL, e Leonardo Spectrum, para síntese lógica.
Para a síntese física é utilizada a ferramenta ISE da Xilinx onde o dispositivo alvo é um FPGA da família VirtexII.
Com relação a a validação funcional para modelos Tl e RTL, é utilizada a ferramenta Synopsys CoCentric System Studio para captura de projeto e simulação.
O projeto VHDL RTL é validado utilizando o simulador Modelsim.
Este estudo foi inicialmente descrito em.
O estudo de caso escolhido é um processador load-store de 16 bits denominado R8.
Este processador apresenta um formato de instruções regular:
Todas as instruções têm o mesmo tamanho, ocupando apenas uma palavra memória de 16 bits.
As instruções contêm o código da operação e a especificação de operandos, caso existam.
Há poucos modos de endereçamento.
Este processador é quase uma máquina RISC mas lhe faltam características arquiteturais comuns a processadores RISC tal como organização pipeline.
As principais características organizacionais do processador são:
Endereços e dados têm tamanho de 16 bits;
O endereçamento de memória é realizado a palavra;
O banco de registradores contém 16 registradores de propósito geral;
Há 4 sinalizadores de estado chamados negative, zero, carry, e overflow;
A execução de uma instrução é realizada no mínimo em 2 e no máximo em 4 ciclos de relógio, ou seja, a média de ciclos de relógio por instrução (em inglês average clock per instruction, CPI) para qualquer programa executado é sempre um valor entre 2 and 4.
O processador R8 já foi prototipado em hardware e atualmente é utilizado em vários projetos internos ao grupo de pesquisa GAPH.
Maiores informações sobre este processador podem ser obtidas em.
Em esta Seção será apresentada a descrição do estudo de caso em dois níveis de abstração, usando SystemC corresponde ao primeiro passo de refinamento apresentado na Seção 3.1, em o qual a computação é descrita de modo funcional e a comunicação é realizada através de requisições de serviço, sem fazer uso de um sinal de sincronismo como relógios, por exemplo.
O modelo RTL também é apresentado nesta Seção pode ser obtido por o refinamento do modelo Tl.
Em este nível de abstração, o foco não está na descrição precisa da interface entre a memória e o processador ou no número e natureza dos registradores disponíveis.
O foco está na funcionalidade e na comunicação interna e externa de forma abstrata.
Esta abordagem permite análise do projeto logo nos primeiros estágios, o que facilita encontrar gargalos de arquitetura que venham a comprometer a eficiência do sistema.
Para alcançar isto, processos descrevem a funcionalidade arquitetural dos componentes de processamento e canais são responsáveis por descrever a semântica de comunicação entre os componentes.
Os canais abstraem a complexidade de protocolos, permitindo a transmissão de tipos de dados desejados, que compreendem desde bits até estruturas complexas.
O estudo de caso foi implementado com três módulos e três canais, interconectados segundo o diagrama de blocos mostrado na Figura 21.
Os módulos descrevem o comportamento das principais unidades funcionais do processador, da memória e do banco de registradores.
Os canais descrevem a comunicação entre o processador e a memória, o processador e o banco de registradores e o processador e os flags.
Register_ Bank and Memory_ Unit) três canais (FlagsChannel, RegsChannel e MemoryChannel) e cinco interfaces.
Os nomes em negrito são nomes de instâncias, os restantes são nomes de classes na descrição SystemC.
O módulo Top representa o processador enquanto Tb_ R8 representa o testbench.
Baseado na especificação do estudo de caso, o processador é modelado para buscar instruções da memória, decodificar- las e executar- las.
A comunicação entre o processador e a memória é mapeada no canal Memory Channel e sincronizada por eventos.
Este canal contém métodos para requisitar instruções à memória e enviar as instruções ao processador.
Métodos são definidos por as interfaces, que são classes contendo objetos virtuais.
Interfaces também são usadas para definir as portas do módulo.
Por exemplo, quando o processador busca uma nova instrução, ele faz a chamada do método getNxtWord através da porta que está conectada ao canal.
O método é executado por o canal, que contém a funcionalidade do registrador PC para endereçar a memória.
Assim como o processador, a memória está conectada ao canal por uma porta, onde aguarda uma requisição de leitura.
Quando o processador requer a próxima palavra da memória, o canal notifica à memória que o endereço contido em PC terá de ser lido através da chamada do método getAddress.
A instrução é lida por a memória e enviada de volta para o canal, através da chamada do método sendWord.
O canal notifica ao processador que a instrução está disponível através de um evento e entra em estado de aguardo de nova requisição.
A Figura 22 ilustra a estrutura de métodos usada na comunicação entre o processador e a memória.
O nível de abstração de transação permite descrever a funcionalidade do processador, ocultando detalhes dos mecanismos de comunicação.
A descrição Tl pode ser simulada, e o resultado pode ajudar os projetistas a ajustar, por exemplo, o tamanho da memória, o número de registradores e instruções.
Seguindo alguns passos de refinamento, tais como os propostos na Seção 3.1, após a validação de um modelo Tl, tal como o descrito na Seção 3.3.1, deve- se alcançar uma descrição RTL sintetizável.
Tomando- se como base o modelo Tl apresentado na Seção 3.3.1, algum detalhamento sobre um possível refinamento é apresentado a seguir.
Como primeiro passo, para a descrição da parte computacional dos módulos, a inclusão do sinal de relógio permite que a implementação do comportamento passe de uma característica algorítmica não temporizada para um comportamento algorítmico temporizado.
No entanto, esta descrição permanece não sintetizável, pois as características arquiteturais no módulo não foram ainda implementadas.
A comunicação não faz uso do sinal de relógio, todavia há uma substituição da comunicação baseada em serviços para uma baseada em troca de mensagens.
Após serem validados os módulos, o protocolo de comunicação pode ser novamente refinado.
Refinamentos e simulações sucessivos permitem que se alcance uma descrição sintetizável.
As simulações sobre um sistema que está sendo refinado devem ser cada vez mais demoradas quando comparadas as simulações executada sobre o modelo Tl inicial, devido principalmente ao aumento do nível de detalhamento e maior precisão em ciclo de relógio.
Em o passo seguinte de refinamento, o protocolo de comunicação é detalhado em portas e sinais.
Podem ser destes módulos.
O protocolo de comunicação passa da sincronização baseada em eventos para um conjunto de sinais que possivelmente se baseam no sinal de relógio.
A exemplo do refinamento adotado no modelo Tl do processador apresentado anteriormente, o canal que implementa a comunicação entre o processador e a memória contém o registrador PC.
Todavia, na prática este é um registrador interno ao processador.
Logo, este registrador é movido do canal para o módulo processador deixando de fazer parte do canal.
O canal de comunicação é substituído por um conjunto de sinais que implementam um protocolo muito similar ao handshake.
Finalemente, a computação é descrita de forma a atingir uma característica arquitetural.
A descrição de flip-flops, tamanho de registradores e máquinas de estados finitos com precisão em nível de ciclo de relógios são definidos.
O foco agora muda da modelagem da funcionalidade para a implementação, visto que o que se deseja é uma descrição sintetizável.
Não existem regras finais para conduzir o processo de refinamento.
Todavia, nota- se que o uso de uma abordagem hierárquica baseada em refinamentos sucessivos é um método eficiente.
Para comparar as modelagens Tl e RTL, foram elaborados alguns experimentos descritos nesta Seção.
Como ponto de partida para os experimentos, utilizou- se três implementações equivalentes do processador R8.
Duas destas são as descrições Tl e RTL realizadas no contexto deste trabalho, descritas na Seção 3.3.
A outra é a descrição dita &quot;Gold «do processador R8, implementada em VHDL RTL sintetizável, disponível na página do grupo de pesquisa GAPH.
Em a Seção 3.4.1 é apresentada uma questão teórica sobre o uso dos níveis de abstração superiores ao RTL a partir de descrições em SystemC e em VHDL, enquanto que nas Seções 3.4.2 e 3.4.3 são apresentados resultado quantitativos da comparação dos diferentes níveis de abstração e linguagens, SystemC e VHDL, tendo como base um programa descrito em assembly e executado sobre os as diferentes descrições do processador R8, apresentado anteriormente.
Comparou- se o tempo de simulação das versões Tl e RTL executando o mesmo programa, com os mesmos dados de entrada.
Também se comparou o tamanho do hardware gerado por a síntese automática das versões RTL SystemC e VHDL.
A Seção 3.4.1 apresenta uma comparação qualitativa entre VHDL, uma linguagem tipicamente usada para modelagem RTL, e SystemC, voltada sobretudo, mas não exclusivamente, para níveis de abstração acima de RTL.
A seguir, estuda- se a relação de desempenho de simulação de modelos Tl e RTL, na Seção 3.4.2.
Isto é feito à luz de o estudo de caso do processador R8.
Finalmente, a Seção 3.4.3 compara os resultados de síntese obtidos a partir de as versões RTL nas duas linguagens.
VHDL é uma linguagem desenvolvida para permitir descrição de hardware.
Ela contém características específicas para modelar estruturas do nível de abstração RTL, bem como o comportamento de máquinas de estados finitos (em inglês, Finite State Machine, FSMs), incluindo estruturas de controle de fluxo e tipos de dados específicos.
Realizada a descrição em VHDL, uma ferramenta de simulação, e que obviamente interprete a descrição de hardware, pode ser utilizada.
Como normalmente hardware e software interagem num sistema, co-simulação de hardware-- software pode ser necessária durante o projeto de um SoC.
Com VHDL este processo é possível, mas tem de ser feito através do uso de ferramentas que explicitamente suportam a integração da simulação VHDL com depuradores de software, através do sistema operacional de um computador.
O simulador Modelsim é um exemplo de ferramenta que tem este suporte.
Além deste inconveniente, a descrição de um módulo topo (testbench) para validação de um projeto tem de ser realizada usando bibliotecas e comandos específicos de VHDL.
Outra opção é novamente recorrer a técnicas de cossimulação para usar uma linguagem com maior capacidade de processar estímulos, tal como C/ C+.
Para iniciar o trabalho com VHDL, um grande esforço de aprendizagem precisa ser realizado, caso o usuário não conheça a linguagem.
Além deste inconveniente, o usuário tem de dominar o conjunto de ferramentas específicas usadas para capturar e validar projetos descritos em VHDL.
SystemC é um conjunto de classes e um núcleo de suporte à simulação que estende a linguagem C+, para permitir modelar hardware nesta.
SystemC utiliza tipos de dados e controle de fluxo de C+.
Adicionalmente, SystemC permite e emprega características de C+ tal como a definição de templates que facilitam a declaração e manipulação de variáveis e o uso de herança para definir modelos de hardware.
O código que descreve o sistema é compilado num arquivo executável utilizando- se ferramentas tais como Gnu gcc\ g+ e Microsoft Visual C+.
Como um ambiente C+ é utilizado, o esforço para descrever uma simulação envolvendo software e hardware é muito menor comparado a VHDL, pois a mesma linguagem pode- se descrever tanto hardware quanto software, sem a necessidade de prover interação entre ferramentas heterogêneas para executar uma cossimulação.
Sendo possível utilizar todo o poder de C+ para a simulação, testbenches podem ser criados para validar ambos hardware e software.
C+ é uma linguagem muito mais difundida do que VHDL.
A análise do tempo de simulação foi adotada para comparar a eficiência relativa de modelagens Tl na descrição de hardware.
A descrição VHDL RTL é executada com um simulador VHDL com precisão a ciclos de relógio, enquanto a descrição SystemC é um código compilado gerado por o compilador Gnu uma estação Sun Blade 2000, com um processador de 900 MHz de freqüência e 1 Gbyte de memória.
Para este processo, o mesmo testbench foi utilizado para ambas as descrições, que compreende a execução de uma versão em código objeto do algoritmo de ordenação Bubble Sort, gerado a partir de fonte em linguagem de montagem, processado por o programa montador do processador R8.
O tamanho dos vetores variou de 32 a 1024 palavras de 16 bits.
A Figura 23 apresenta a comparação dos tempos de simulação necessários para executar o algoritmo de ordenação (em segundos).
Como mostrado na Figura 23, o tempo de simulação da descrição SystemC é aproximadamente uma ordem de magnitude mais rápido do que a simulação VHDL.
A informação é relevante, visto que o tempo necessário para simular grandes circuitos descritos em VHDL (como ocorre em projeto de SoCs) é extremamente alto e constitui o principal fator no caminho crítico de projetos de CIs complexos no tangente a time- to-- market.
Desta forma, a adoção de SystemC pode reduzir significativamente o tempo de validação de projeto, se a validação no nível Tl reduzir o esforço de validação no nível RTL ou se a síntese puder proceder diretamente deste ponto para procedimentos de geração de hardware.
A última análise realizada foi a comparação do tamanho de hardware gerado a partir de descrições SystemC RTL e VHDL RTL fornecidas como entrada de ferramentas automatizadas de síntese.
O objetivo principal desta análise é verificar se é possível descrever módulo em SystemC que tenham um tamanho de hardware competitivo com descrições equivalentes em VHDL.
Desta forma, a descrição do processador R8 em SystemC RTL baseou- se na descrição VHDL do mesmo processador.
Esta abordagem não desqualifica o trabalho desenvolvido, pois como dito anteriormente, o objetivo é garantir que se pode chegar a descrições SystemC com tamanho de hardware comparável ao gerado a partir de ferramenta Leonardo Spectrum e os resultados da síntese obtidos do mapeamento do projeto para dispositivos Virtex II da Xilinx são mostrados na Figura 24.
O FPGA destino utilizado foi um VirtexII XC2 V1000.
A métrica de tamanho utilizada foi a quantidade de LUTs necessária para implementar o hardware.
como se pode perceber da observação da Figura 24, o tamanho obtido para cada módulo é similar para VHDL e SystemC.
A última barra mostra o tamanho total do hardware alcançado por ambos os processos de síntese.
A diferença de tamanho entre implementações obtidas a partir de SystemC e VHDL está dentro de 1% do menor resultado.
Os resultados apresentados na Seção 3.4 fortalecem o ponto de vista da vantagem de descrições de hardware utilizando SystemC, por apresentar melhor desempenho de simulação e viabilizar a obtenção de hardware competitivo em termos de tamanho com descrições VHDL.
O ganho do tempo de simulação chegou a aproximadamente uma ordem de magnitude para o tamanho de hardware usado, que representam circuitos de pequeno porte.
Como a relação de crescimento é não-linear na complexidade do software e no tamanho de hardware, ganhos muito maiores podem ser esperados no projeto de SoCs.
O tamanho de hardware obtido da descrição SystemC RTL é comparável ao obtido a partir de a síntese de uma descrição equivalente em VHDL RTL.
A descrição completa do processador R8 em VHDL está disponível juntamente com a especificação do processador R8.
De acordo com os resultados apresentados, SystemC é considerada aqui como uma opção de linguagem interessante para descrição de hardware em altos níveis de abstração e descrições sintetizáveis.
SystemC é eficiente para simular e validar hardware quando comparado com VHDL, e potencialmente permite uma comunidade maior acessar mais facilmente o processo de projeto integrado de hardware e software.
Modelagem e validação da rede Hermes em nível de transação tendência emergente na academia e na indústria.
Em particular comparam- se alguns aspectos de modelagem nestes níveis usando as linguagens SystemC e VHDL.
Com base nas vantagens apresentadas das comparações apresentadas na Seção anterior sobre o uso de diferentes níveis de abstração para projeto de SoCs propõem- se aqui a modelagem e validação da NoC Hermes a partir de sua descrição Tl em SystemC.
O objetivo é a validação funcional da NoC em alto nível de abstração.
Este objetivo deve permitir a detecção de possíveis erros de projeto antes da implementação no nível RTL.
O processo também deve prover um ou mais modelos que possa (m) ser empregado (s) na validação eficiente da comunicação em SoCs contendo a NoC Hermes.
O presente Capítulo descreve a implementação e validação da NoC Hermes em nível de transação nas Seções 4.1 e 4.2.
A presente Seção apresenta o modelo da NoC Hermes implementado em nível Tl em linhas gerais.
É interessante relembrar que uma NoC é formada por chaves e por elementos que interconectam estas chaves, conseqüentemente definindo uma topologia.
Tais elementos que interconectam a chave são canais, os quais implementam um protocolo de troca de dados como, por exemplo, handshake.
A chave possui uma estrutura mais complexa quando comparada ao canal que a conecta a outra chave.
Ela é composta por N portas, um módulo de arbitragem, um de roteamento e meios de armazenamento temporário que pode ou não estar associados a portas de entrada ou de saída.
Em a NoC Hermes TL cada chave possui 5 portas de entrada e de saída.
O armazenamento temporário está diretamente associado apenas a portas de entrada.
Sendo uma modelagem Tl, cabe detalhar que o nível de abstração utilizado para computação é não temporizado e para a comunicação é o de serviços.
Esta abordagem permite a visualização de eventuais problemas de modelagem logo nos primeiros passos do projeto.
A implementação em alto nível de abstração permite, por exemplo, a validação de algoritmos de roteamento quanto a a propensão para apresentar situações de deadlock.
Obviamente, este problema também é visível em níveis mais baixos de detalhamento, todavia pode não ser tão fácil de detectar- lo e/ ou corrigir- lo nestes.
As Seções a seguir apresentam as características gerais da NoC Hermes implementada no nível Tl, seguido de um extenso detalhamento sobre o projeto da chave Hermes e de seus componentes.
Finalmente, apresenta- se os níveis de parametrização do projeto da rede Hermes, bem como a forma de interação entre chaves Hermes e entre uma chave e um IP processador numa implementação de SoC que use a NoC Hermes como meio de comunicação.
Em esta Seção apresenta- se as características gerais da descrição da NoC Hermes em nível de transação.
Estes se referem a itens apresentados no Capítulo 1: Pilha de protocolos de comunicação, chaveamento, memorização e arbitragem.
O item roteamento é tratado em Seção a parte durante a discussão da implementação da chave.
Com relação a pilha de protocolos de comunicação, a modelagem arquitetural da chave possui as seguintes características:
Nível físico:
Definição das interfaces físicas da rede externa (ou seja, entre um núcleo IP e uma chave) e interna (ou seja, entre chaves).
Em a implementação Tl, uma transação é suficiente para transmitir exatamente um flit em qualquer interface física, modelando a situação pressuposta da rede Hermes, onde &quot;phits «e flits são idênticos;
Nível de enlace dados:
Implementação dos tratamentos realizados sobre os dados.
Assim, tarefas como o armazenamento em filas circulares e controles de pacotes são realizados internamente a cada chave.
Não foram implementados algoritmos para detecção e correção de erros ou de coerência de dados, apenas reenvio de flits em casos de insucesso no envio de um flit entre chaves ou entre uma chave e um núcleo IP;
Nível de rede:
Foi definida a estrutura do pacote que trafega por a NoC.
Esta estrutura é interpretada e um determinado comportamento é adotado em cada instante na chave, visando a comunicação entre chaves, ou chave e núcleo IP;
Nível de transporte:
Com a finalidade de prover a comunicação entre chaves, foram definidos endereços para cada chave.
Baseado neste endereçamento, pacotes que trafegam na rede são roteados para que saiam de uma chave fonte e cheguem a uma chave destino.
Esta abordagem provê comunicação fim-a-fim.
O modo de chaveamento adotado foi o chaveamento de pacotes.
Em este modo, não é reservado um caminho para a transmissão de um pacote antes de ser transferido.
O modo de armazenamento adotado para a transmissão do pacote é o wormhole, pois consome menos área em hardware, visto que pacotes não precisam ser totalmente armazenados numa chave e que a área de armazenamento temporário tende a dominar o consumo de área numa chave.
Ainda associada à questão de armazenamento, a estratégia adotada foi a de filas na entrada da chave, por ser mais simples de controlar.
As chaves descritas atendem a estas escolhas, pois o critério para recebimento de um pacote na porta de entrada de cada chave é a existência de uma posição livre na fila.
Com esta abordagem, o critério para transmissão do pacote não está na garantia do armazenamento total do pacote em cada chave, mas sim na possibilidade de receber cada flit.
Além de isto, um pacote pode estar espalhado por diversas chaves no caminho de transmissão.
As cinco portas de uma chave podem estar requisitando roteamento ao mesmo tempo.
Por este motivo foi definido que cada chave deveria possuir controle de acesso ao mecanismo de roteamento.
Quanto a o algoritmo de arbitragem, como dito anteriormente, para a NoC Hermes foi adotado o round robin.
Este algoritmo foi adotado por representar uma forma simples e justa de alternância de prioridade.
Em ele a prioridade é passada da porta NORTH à SOUTH, da SOUTH à EAST, da EAST à WEST, da WEST à Local, da Local à NORTH, conforme requisição de roteamento.
A o iniciar a execução da arbitragem, a porta Local ganha prioridade sobre as demais.
Caso esta não esteja requisitando roteamento, a próxima porta a ganhar prioridade será a que está requisitando roteamento, segundo a ordem de atribuição de prioridade apresentada anteriormente, ou finalmente a porta Local, se nenhuma porta estiver requisitando roteamento.
Caso a porta EAST esteja requisitando roteamento, por exemplo, a prioridade de acesso ao mecanismo de roteamento é garantida a esta e a definição da próxima porta a ganhar prioridade de acesso somente ocorrerá após a execução do algoritmo de roteamento.
O pacote que transita por as chaves foi organizado conforme mostra a Figura 25, baseado na proposta original da NoC Hermes.
O primeiro flit do pacote contém o endereço de destino na NoC.
Em este flit, os quatro bits menos significativos representam a coordenada Y e os quatro bits seguintes representam a coordenada X da chave destino.
O segundo flit representa o número de flits com dados válidos disponível no pacote.
O tamanho máximo do pacote é 2 (número de bits para representar um flit)+ 2 e o tamanho mínimo é igual a 2.
Pacotes com tamanho 2 não transportam payload e podem ser utilizados para operações de controle, tais como ativar ou disparar um dispositivo na rede, por exemplo.
Para permitir a transmissão de pacotes por a NoC Hermes, definiu- se endereços para cada uma das chaves, como apresentados na proposta da NoC Hermes.
A topologia adotada inicialmente para o trabalho foi malha, com tamanho parametrizável.
Assim, cada chave possui como endereço um valor obtido por a concatenação das posições relativas ao plano cartesiano XY.
A finalidade da chave Hermes é prover um serviço de transferência de pacotes de uma porta de entrada para uma porta de saída baseado num critério de roteamento.
A modelagem Tl da chave expressa esta finalidade sem fazer uso de maiores detalhes de implementação, quando comparada ao modelo RTL.
Como dito anteriormente, a interconexão entre as chaves define a topologia de uma NoC.
A modelagem Tl implementa esta interconexão entre as chaves através de canais, os quais abstraem detalhes de protocolos, tornando a comunicação entre as chaves abstrata.
Em a NoC Tl modelada, cada chave possui 5 portas.
Uma porta é composta por uma entrada e uma saída, sendo que cada chave possui então 5 portas de entrada e 5 de saída.
As portas são denominadas NORTH, SOUTH, EAST, WEST e Local, e são representadas respectivamente por os números 0 (zero), 1 (um), 2 (dois), 3 (três) e 4 (quatro), conforme ilustra a Figura 26.
Como a topologia adotada nesta modelagem Tl da NoC Hermes foi a malha, a cada chave podem estar conectadas no máximo 4 (quatro) outras chaves, por qualquer uma das portas com da exceção da porta Local.
A a porta Local pode- se conectar um núcleo IP que pode ser uma fonte geradora de pacotes, um consumidor de pacotes ou ambos.
Os mecanismos utilizados para a conexão de duas chaves ou entre uma chave e um núcleo IP são idênticos.
Ambas utilizam o mesmo tipo de canal de comunicação abstrato.
Cada chave Hermes TL é composta por dois tipos de elemento, quais sejam:
Portas e lógica de controle, conforme ilustrado na Figura 26.
As portas são responsáveis por controlar o recebimento e o envio de pacotes que chegam à chave, sendo compostas por uma entrada, para o recebimento de pacotes, e uma saída, para o envio de pacotes.
A lógica de controle implementa, de forma centralizada à chave, a arbitragem e o roteamento de pacotes armazenados em cada porta da chave.
A Figura 27 ilustra a modelagem Tl da chave Hermes.
Em esta Figura é representada a chave, composta por cinco portas e uma lógica de controle, que é um canal de comunicação entre as portas.
Cada transferência de pacotes entre uma porta de entrada e uma de saída passa por a lógica de controle.
Como esta operação pode estar ocorrendo em paralelo entre vários pares de entrada e saída, cada transferência necessita de uma identificação das portas envolvidas para evitar colisão de pacotes, detalhes estes abordados na Seção 4.1.2.4.
A chave Tl não implementa nenhuma computação diretamente, ou seja, não há nenhuma descrição algorítmica implementada na chave Tl.
A chave Tl é um módulo hierárquico que interconecta portas e lógica de controle.
A o receber um pacote, por uma de suas cinco portas, uma requisição de roteamento é realizada por a porta que armazenou o pacote.
Internamente à chave, a porta que recebeu o pacote aguarda ganhar direito para tentar ser ter seu flit roteado.
A o receber direito de acesso ao roteamento, a porta que está armazenando o pacote é atendida por a lógica de controle.
Caso não seja possível rotear o pacote, este fica aguardando ganhar novamente direito de acesso.
Caso tenha sido possível rotear o pacote, este é repassado para a porta de destino que lhe foi atribuída, criando assim uma ligação entre uma porta de entrada e uma porta de saída.
Detalhes do comportamento de cada um dos módulos que compõem a chave são apresentados nas Seções a seguir.
Assim como a chave, a porta (door.
H e door.
Cpp) é um módulo hierárquico que instancia outros dois módulos.
Estes módulos descrevem o recebimento e a saída de um pacote e sendo detalhados a seguir.
Um pacote entra por uma das cinco portas de uma chave, após autorização concedida por o processo controle de fluxo.
Como dito anteriormente, a porta é composta por duas partes, a que trata do recebimento de um pacote e a que controla o envio para a próxima chave.
A o receber o pacote, o módulo inDoor, que trata o recebimento de um pacote, armazena em filas circulares os flits que compõem este, até que a porta de saída seja determinada, ou até esgotar o espaço de armazenamento disponível na porta, o que acontecer primeiro.
O processo é ilustrado na Figura 29.
A o ser definida e alocada a porta de saída da chave, inicia- se o envio de flits até que todos sejam transmitidos.
Dentro de a porta de entrada encontra- se uma fila circular de armazenamento dos flits recebidos (buffer), ilustrada com aproximadamente 70% das posições ocupadas.
Internamente à porta de entrada é realizado o controle de repasse do pacote onde o primeiro flit representa o cabeçalho (header), o segundo o tamanho (size), os demais representando a carga útil (payload).
Para a modelagem da porta de entrada, as filas circulares têm o número de posições parametrizável e tamanho de palavra equivalente ao tamanho de um flit.
Cada porta de entrada apresenta comportamento seqüencial para recebimento e para requisição de roteamento e envio de flits, ou seja, apenas um flit pode ser armazenado por vez em cada porta de entrada e apenas uma requisição de roteamento e envio de flits pode ser realizada por vez na porta de entrada.
Todavia, internamente à porta de entrada estas atividades ocorrem em paralelo, ou seja, flits podem estar sendo recebidos ao mesmo tempo em que está sendo realizada uma requisição de roteamento ou envio de flit.
Sendo a chave composta por 5 portas, as operações de controle de recebimento e envio de flits nas cinco portas de entradas da chave ocorrem em paralelo.
A implementação do recebimento de pacotes é algorítmica e sem precisão em nível de ciclos de relógio.
O comportamento interno do módulo inDoor para recebimento de pacotes é ilustrado na Figura 30, sendo que a comunicação com a fonte geradora do pacote ocorre de forma abstrata através da chamada de serviços.
Tais serviços são implementados com os métodos SystemC definidos na Tabela 4.
Quanto a o comportamento de recebimento de um pacote, inicialmente a chave aguarda que um novo flit seja enviado a partir de uma chave fonte.
A o receber este flit, o espaço em buffer é verificado.
Se todas as posições do buffer estiverem ocupadas, é informada à chave fonte que o flit não pode ser recebido.
Caso haja espaço no buffer, o flit é armazenado numa posição controlada por o módulo inDoor e a chave fonte é informada que o flit foi recebido com sucesso.
Início Informa que não pôde receber Aguarda chegada de um Informa que pôde receber o Tem espaço no buffer?
Hermes este comportamento é replicado cinco vezes, criando independência entre as portas, para que ocorra o paralelismo de recebimento e envio de flits.
A comunicação entre as chaves ou entre uma chave e um núcleo IP se dá através de canais SystemC.
Os canais implementam métodos definidos por interfaces além de poder implementar métodos próprios.
As interfaces definem os métodos que são utilizados para implementar os serviços a serem disponibilizados por os módulos.
Para a comunicação da porta de entrada através de um canal de comunicação abstrato, foi definida uma interface de comunicação chamada inToRouterIf.
Em esta interface foram definidos 3 métodos para comunicação durante o recebimento de flits, denominados haveNewFlit, couldNotAcceptFlit e flitAccepted.
O método haveNewFlit é chamado e aguarda a notificação de um evento que ocorrerá quando um novo flit for enviado por a chave vizinha.
A o receber o flit, a porta de entrada verifica a taxa de ocupação do buffer circular.
Caso o buffer esteja totalmente ocupado, o método couldNotAcceptFlit é chamado, do contrário o método flitAccepted é chamado.
Estes dois últimos métodos são chamados para que a chave vizinha, que enviou o flit, possa realizar o tratamento da transmissão do flit.
O envio de flits para a lógica de controle a partir de a porta de entrada tem o comportamento representado na Figura 31.
Início Verifica buffer Há FLIT (s) no buffer?
Verifica buffer size é igual a zero?
M arca FLIT com o header e libera espaço no buffer size $= size 1 Há FLIT (s) no buffer?
Arm azena valor de size Disponibiliza FLIT para lógica de controle Lógica de controle enviou roteado?
M arca FLIT com o payload e libera espaço no buffer Disponibiliza FLIT para lógica de controle Envia FLIT para lógica de ctrl Verifica buffer Tem FLIT no buffer?
M arca FLIT com o size e libera espaço no buffer Lógica de controle enviou FLIT?
Inicialmente, verifica- se a disponibilidade de flits na fila de entrada.
Havendo flits na fila, a porta de entrada marca o primeiro destes como header e o envia para a lógica de controle a fim de que seja roteado.
Enquanto o roteamento não for realizado a porta de entrada não envia novos flits à lógica de controle.
Quando o header flit for roteado, uma nova verificação do buffer é realizada.
Caso haja algum flit, este é marcado como size, armazenado para controle do pacote e enviado para a porta de saída através da lógica de controle.
Quando a porta de entrada for informada que o flit pôde ser enviado, o valor de size é verificado.
Caso o valor seja zero, o pacote foi totalmente enviado e o próximo flit representa o header de um novo pacote, caso contrário, uma nova verificação de flit no buffer é realizada, o flit capturado é marcado como payload e enviado à lógica de controle.
Quando o flit for enviado, o valor de size é decrementado de uma unidade e este é novamente verificado.
Se o valor de size for zero, o pacote foi totalmente enviado.
Caso contrário, o buffer será analisado, flits serão capturados e o size será decrementado até assumir valor zero, para que um novo pacote seja transmitido.
Os métodos utilizados para a comunicação entre a porta de entrada, a lógica de controle e a porta de saída são definidos por a interface outToInternalIf e definidos na Tabela 5.
Quando o primeiro flit é enviado para o roteamento, o método sendHeader é chamado, o que define o início da transmissão de um pacote.
Este método fica bloqueado até que o header seja roteado.
Quando o método sendHeader é liberado o segundo flit é enviado através da chamada do método sendSize.
O sucesso da transmissão do size flit é informado através da variável Booleana passada por referência para o método sendSize.
Caso o valor desta variável seja true, um novo flit será capturado no buffer, do contrário o size flit terá de ser retransmitido.
Quando os payload flits forem enviados, o método sendPacketBody é chamado.
O sucesso da transmissão e o tratamento dos flits ocorrem como no método sendSize.
Apesar de todos os métodos terem a mesma funcionalidade, ou seja, a transmissão para a chave destino, o comportamento da lógica de controle é diferenciado para cada um dos tipos de flit, o que será mais bem explorado adiante no detalhamento da lógica de controle. (
BOOL*) ­ Variável boolean para saber se o flit foi enviado:
O módulo outDoor, representado na Figura 32, é responsável por enviar flits para o núcleo IP, no caso de a porta Local, ou para uma das chaves vizinhas, no caso de as demais portas.
Em este módulo, o flit recebido é armazenado temporariamente até que a chave vizinha, ou núcleo IP, conectado à porta de saída, informe o sucesso ou insucesso do recebimento do flit transmitido.
Em o módulo outDoor não há controle do tipo do pacote, ou seja, para a porta de saída é irrelevante se o flit que está sendo enviado é do tipo header, size ou payload.
As operações de envio e recebimento de flits por o módulo outDoor não ocorrem em paralelo, ou seja, após o recebimento de um flit, o próximo somente será recebido depois que a chave ou núcleo IP conectado a esta porta informar se foi possível receber- lo.
Esta abordagem define o comportamento da chave sem armazenamento de saída, conforme a especificação da Seção 2.4.1 para a chave Hermes.
O comportamento do módulo é representado na Figura 33.
Inicialmente, o módulo aguarda a recepção de um flit para a transmissão.
A o receber- lo, é realizada a tentativa de transmissão para a chave ou núcleo IP conectado.
Caso o flit tenha sido enviado, o módulo outDoor informa à lógica de controle que conseguiu transmitir- lo, do contrário informa que não foi possível realizar a operação.
Início Aguarda Informa que não pôde enviar Informa que pôde enviar Envia FLIT à chave conectada Chave recebeu?
Para o recebimento de flits vindos da lógica controle, o módulo outDoor utiliza os métodos definidos por a interface inFromInternalIf, conforme mostra a Tabela 6.
Quando método ogFlit é chamado, o módulo outDoor fica aguardando o recebimento de um flit enviado por a porta de entrada.
A o ser recebido este flit, procede- se à tentativa de transmissão do flit, através do método try2SendFlit, definido por a interface outFromRouterIf, conforme mostra Tabela 7 e implementado por a lógica de controle.
Este método fica bloqueado até que a chave ou núcleo IP receptor do flit informa o sucesso, ou não, na operação.
A seguir, a informação sobre o sucesso, ou não, da transmissão é repassada à porta de entrada, através da chamada dos métodos flitSent, caso tenha sido transmitido o flit, ou couldntSendFlit, caso não tenha sido transmitido o flit.· (
BOOL*) ­ Resposta do aceite ou não do flit enviado A lógica de controle é descrita sob a forma de um canal e é denominada intraRouterChl, sendo sua estrutura geral apresentada na Figura 34.
O canal intraRouterChl implementa os métodos definidos por as interfaces outToInternalIf e inFromInternalIf, interconectando as portas da chave além de alguns métodos próprios.
Para o presente trabalho, cinco portas foram conectadas ao canal, porém essa quantidade de portas é parametrizável.
Além de implementar os métodos definidos nas interfaces, o canal intraRouterChl possui outros dois métodos, um para arbitragem e outro para roteamento.
Para a arbitragem, foi utilizado o algoritmo de prioridade rotativa (round robin) e para o mecanismo de roteamento o algoritmo é parametrizável.
O comportamento da lógica de controle é apresentado na Figura 35.
Inicialmente, o canal aguarda a chegada de um flit do tipo header, que representa uma requisição de roteamento.
A o receber este flit, a porta de entrada é identificada e o acesso ao mecanismo de roteamento é solicitado.
Com a execução do algoritmo de arbitragem dá- se acesso a um dos solicitantes.
Quando o acesso é dado a uma das portas que solicitou roteamento, o flit que representa o endereço de destino é repassado para o método responsável por realizar o roteamento.
O objetivo deste método é definir qual porta de saída será utilizada por o pacote que está sendo transmitido por a chave.
Inicialmente o algoritmo de roteamento utilizado neste trabalho foi o XY Puro.
Porém, observou- se ser interessante dispor de outros métodos de roteamento, o que se tornou então uma opção parametrizável.
Caso a porta de saída definida no algoritmo de roteamento já esteja em uso, nenhuma saída é atribuída ao pacote.
A o concluir o roteamento, caso não tenha sido atribuída porta de saída ao pacote, a porta de entrada perde a prioridade e tem de aguardar que o algoritmo de arbitragem lhe conceda acesso ao roteamento no futuro.
Início Libera a porta de saída Informa à porta de entrada que não foi possível enviar o flit Aguarda requisição de roteamento Informa à porta de entrada que flit foi transferido flit pôde ser enviado?
Recebeu requisição?
Analisa o valor de size Aguarda resposta da porta de saída size é igual a zero?
Identifica porta que requisitou, armazena o header flit e solicita acesso ao mecanismo de roteamento Armazena size flit para controle do pacote, e o envia à porta de saída Aguarda acesso ao mecanismo de roteamento Aguarda recebimento de flit payload Recebeu flit payload?
Recebeu flit size?
Acesso condedido?
Aguarda resposta da porta de saída Roteamento realizado?
Informa à porta de entrada que flit header foi roteado Reserva porta de saída e envia flit header flit pôde ser enviado?
Transmite flit header Aguarda resposta da porta de saída Envia flit à porta de saída Aguarda recebimento do size flit Solicita roteamento flit pôde ser enviado?
A perda e ganho de acesso ao mecanismo de roteamento ocorrerão até que a porta de saída possa ser alocada.
A o se alocar a porta de saída ao pacote, esta é reservada e o header flit é enviado, aguardando- se a resposta do sucesso da transação.
Caso a transferência não ocorra, o header flit é novamente, enviado, sendo repetida esta operação até que a porta de saída informe que conseguiu repassar o flit.
Como já apresentado, o controle de envio de flits é realizado por a porta de saída. Quando
uma porta de entrada é a associada a uma porta de saída, o primeiro flit a ser enviado é o header, sendo esta requisição de envio solicitada por a lógica de controle.
Quando a transferência ocorrer com sucesso, o canal informa à porta de entrada que o header flit foi roteado e transferido com sucesso.
O canal fica aguardando que a porta de entrada repasse o size flit.
O valor deste flit é armazenado para controle do pacote.
Novamente a transferência para a porta de saída é realizada.
Contudo, o modelo definido para o canal não se responsabiliza mais por a retransmissão do flit, sendo que a lógica de controle apenas repassa a informação sobre o sucesso ou insucesso da transmissão do flit à porta de entrada.
A seguir, caso o flit tenha sido enviado por a porta de saída, o size flit é verificado e caso o seu valor seja zero, a porta de saída é liberada e o novo flit que se aguarda é do tipo header.
Caso o size flit armazenado não seja igual a zero, aguarda- se o envio de payload flits.
A o receber cada um destes, o flit é repassado à porta de saída e, assim como o tratamento realizado para o size flit, caso não seja possível transmitir- lo, isto é informado à porta de entrada.
Caso o payload flit tenha sido transferido, a cópia armazenada do size flit é decrementada, o valor é então verificado.
Se o valor for igual a zero, a porta de saída é liberada e o novo flit que se aguarda é do tipo header.
De o contrário, a porta de saída permanece reservada e o flit que se aguarda é do tipo payload.
A operação de transferência de payload flits repete- se até que o size flit armazenado assuma o valor zero.
Em este trabalho, foram descritas algumas versões da NoC Hermes TL.
Cada versão adiciona uma nova característica ou corrige algum erro de implementação.
Em a primeira versão da NoC Hermes TL, notou- se a ocorrência de um erro na transmissão de pacotes por a rede.
Em alguns momentos a transmissão por a rede congestionava e nenhum pacote era entregue.
Foram depurados os elementos que compunham cada chave, bem como a interconexão entre estes.
Constatou- se que o problema não estava relacionado a algum erro de implementação, mas sim a um erro de projeto.
O algoritmo de roteamento que estava sendo utilizado não era livre de deadlock.
O algoritmo adotado inicialmente foi o XY adaptativo mínimo, o qual executa um caminhamento em linha e coluna segundo um quadrado envolvente, como mostra a Figura item parametrizável, ao invés de criar diferentes versões da NoC Tl para cada algoritmo de roteamento.
Esta abordagem permite flexibilidade ao projeto, além de facilitar explorar e comparar qualitativa e quantitativamente diferentes algoritmos para resolver o mesmo problema.
Foram descritos oito algoritmos de roteamento para a NoC Hermes, sendo que, o XY adaptativo mínimo é propenso a deadlock e o XY adaptativo não mínimo é propenso a deadlock e livelock.
Os outros seis algoritmos de roteamento descritos foram o XY puro, North Last mínimo, North Last não mínimo, West First não mínimo e o Negative First não mínimo, todos comprovadamente livres de deadlock.
Estes últimos algoritmos foram descritos por dois motivos.
O primeiro foi validar a funcionalidade da NoC Hermes TL sem que erros causados por os algoritmos de roteamento comprometessem esta tarefa.
O segundo motivo foi testar a parametrização do algoritmo de roteamento da NoC Hermes, através de o qual diferentes tipos de roteamentos são assumidos em situações de congestionamento da rede.
Os algoritmos descritos atenderam as seguintes características para roteamento:
Quanto a o momento de realização do roteamento:
Dinâmico (realizado em tempo de execução);
Quanto a o número de destinos:
Unicast (apenas um destino);
Quanto a o local onde a decisão de roteamento é tomada:
Distribuída (realizada em cada chave);
Quanto a a implementação:
Máquina de estados (baseado em algoritmo);
Quanto a a adaptatividade:
Determinístico para o algoritmo XY puro e adaptativo para os demais, sendo os adaptativos classificados ainda como:
Quanto a a progressividade:
Progressivo (reserva caminho durante a transmissão);
Quanto a a minimalidade:
Mínimo para os algoritmos XY adaptativo mínimo, west-- first mínimo.
Não mínimo para os algoritmos XY adaptativo não mínimo, west-- first não mínimo, north-last não mínimo e negative-first não mínimo.
Quanto a o número de caminhos:
Completo para o algoritmo XY adaptativo não mínimo e parcial para os demais.
Os algoritmos de roteamento mínimo fazem uso de quadrado envolvente que limita o caminhamento possível.
Os algoritmos não mínimos não são limitados a caminhos dentro de o quadrado envolvente.
A seguir são apresentados os comportamentos de cada algoritmo utilizado, com exceção do algoritmo XY puro, visto que este já foi apresentado na proposta da NoC Hermes.
A implementação dos algoritmos de roteamento é apresentada no Apêndice A. O algoritmo XY adaptativo procura selecionar portas que se aproximam da chave destino do pacote.
Assim, caso o endereço XY da chave destino seja maior que o endereço XY da chave local as portas selecionadas para saída são a EAST ou a SOUTH.
Para a versão com caminhamento mínimo do algoritmo, estas duas portas são a única alternativa de roteamento.
Para a versão com caminhamento não mínimo, se nenhuma das duas portas puder ser usada, a porta NORTH ou a WEST são analisadas como alternativas de roteamento.
O algoritmo west-- first seleciona o caminhamento por a porta WEST antes das demais direções, caso este seja viável.
Sempre que um pacote começa a ser transferido por a NoC Hermes que emprega este algoritmo, a seguinte regra é adotada:
Um pacote poderá seguir no sentido WEST apenas se nunca seguiu em nenhum dos outros sentidos (EAST/ NORTH/ SOUTH).
Este caminhamento para WEST necessariamente ocorre quando o endereço XY da chave destino é menor que o endereço XY da chave local.
Os demais casos dependem do tipo de caminhamento, se for mínimo ou não mínimo.
Em o não mínimo o pacote pode caminhar para WEST mesmo que o endereço XY da chave destino não seja maior que o endereço XY da chave local, já no mínimo isto não ocorre.
O algoritmo north-last usa inicialmente qualquer sentido de deslocamento.
Contudo, tendo ido uma vez para NORTH movimentos subseqüentes serão apenas para NORTH.
O comportamento deste algoritmo é similar ao XY adaptativo quanto a a liberdade de caminhamento nas direções antes da utilização da porta NORTH pela primeira vez.
O algoritmo negative-first necessariamente utiliza caminhamento na direção negativa (portas WEST e SOUTH) da rede sempre que seu destino for menor a origem.
Em o momento em que o pacote evoluir numa direção positiva (ou seja, passando por uma das portas EAST ou NORTH em alguma chave), a negativa não pode mais ser utilizada.
O caminhamento inicialmente na direção negativa pode não ser utilizado quando a origem do pacote está num ponto cujo endereço contém somente coordenadas menores que aquelas do destino do pacote.
Inicialmente os algoritmos de roteamento descritos foram validados a partir de teste de mesa.
Todavia, esta prática mostrou- se tediosa e propensa a erros para NoCs de maior dimensão e para pacotes acima de determinado tamanho.
Foram gerados arquivos com detalhamento dos caminhos percorridos por pacotes durante a simulação da NoC para a validação dos algoritmos.
Contudo esta prática, apesar de mais eficiente que a anterior, também se mostrou complicada e trabalhosa.
Finalmente, foi utilizada a ferramenta de simulação2 de algoritmos de roteamento para topologia malha, que permitiu a validação visual dos algoritmos descritos.
Esta ferramenta permite verificar se o algoritmo de roteamento adotado para o caminhamento de um pacote por a rede está correto e se a condição de parada de um pacote, no caso de um bloqueio, está correta.
Entende- se por condição de parada correta de um pacote a situação em que, ao chegar a uma chave, o pacote não pode ser roteado, por a aplicação do algoritmo, por nenhuma das portas livres, ficando assim o pacote parado nesta chave.
O mecanismo de interconexão entre chaves na NoC Hermes, e entre uma chave e um núcleo IP local é um canal denominado interRouterChl.
Este canal implementa os métodos definidos por as interfaces intoRouterIf e outFromRouterIf, apresentados na Tabela 4 e na Tabela 7.
Em este canal não há controle sobre o tipo de flit que está trafegando entre as chaves, tampouco mecanismos mais complexos de gerenciamento dos dados.
O canal interRouterChl implementa o controle de envio e confirmação de recebimento de dados transmitidos, como ilustrado na Figura 37.
Este canal de fato implementa a estratégia de controle de fluxo da rede.
Para a transferência de dados, são utilizados dados do tipo sc_ event para sincronismo de comunicação entre chaves, ou entre chave e núcleo IP.
A cada porta de uma chave são associados dois canais do tipo interRouterChl, um para a entrada e outro para a saída de dados.
Em a construção da NoC Hermes alguns parâmetros podem ser informados para alterar algumas características da rede.
A primeira característica é a forma como a NoC Hermes pode ser construída.
A interconexão das chaves define a topologia da rede.
Apesar de possível, a descrição de diferentes topologias da NoC Hermes exige um processo trabalhoso de descrição.
Há alguns outros parâmetros que podem ser alterados e que não representam um trabalho tão grande, tal como ao tipo de dado adotado para o flit, o tamanho do flit, o número de portas adotado em cada chave na rede, profundidade das filas de armazenamento temporário e o algoritmo de roteamento.
Com exceção do algoritmo de roteamento, os parâmetros citados são informados no arquivo doordefs.
H. O algoritmo de roteamento a ser adotado deve ser informado à NoC Hermes no construtor do módulo que interconecta as chaves, como apresentado no apêndice E, onde uma NoC 2x2 está descrita.
A ferramenta de simulação do algoritmo de roteamento para topologia malha foi desenvolvida por a bolsista Aline Viera Mello.
A validação da NoC Hermes foi dividida em validação da funcionalidade e análise do desempenho.
Quanto a a funcionalidade, inicialmente validou- se a transmissão de pacotes por a rede.
Para tanto, foram inseridos pacotes com fontes e destinos aleatórios na NoC.
Esta validação permite garantir o correto funcionamento da rede e de sua interconexão em linhas gerais.
A segunda característica de funcionalidade validada refere- se ao paralelismo na transmissão de pacotes.
Para este segundo critério de validação, dois conjuntos de pacotes, com fontes aleatórias na rede, foram utilizados.
O primeiro com destinos aleatórios e o segundo concentrado numa mesma chave destino.
Com isto pode- se garantir a funcionalidade da concorrência na transmissão dos pacotes.
Para a validação do desempenho uma forma alternativa de análise teve de ser adotada, pois a ausência de um sinal de relógio para ser usado como referência, comum em projetos RTL, não está presente.
A necessidade de uma métrica diferenciada para avaliar a simultaneidade ou não do funcionamento da NoC faz- se necessária.
A métrica utilizada foi uma ponderação do número de vezes que cada pacote ganhou a prioridade em cada chave até ser roteado e do número de chaves que passou até atingir seu destino.
Estas informações permitem analisar detalhes como a carga da rede, se o mecanismo de arbitragem que está sendo utilizado é eficiente e comparar abstratamente algoritmos de roteamento, por exemplo.
Para a geração de pacotes para a validação da NoC, foi utilizada a ferramenta TrafficGen3, pois esta permite a geração de pacotes com tamanhos e destinos aleatórios, a partir de diferentes fontes.
Com esta ferramenta, é gerado um arquivo para cada chave da NoC, onde cada linha do arquivo representa um pacote.
Complementar a esta ferramenta, dois núcleos IP em SystemC denominados flitGenerator e flitConsumer foram descritos, os quais são conectados a cada chave da NoC através da porta Local.
O flitGenerator conecta- se à porta Local na entrada da rede associada a uma chave.
Ele lê o arquivo gerado por o trafficGen, referente a sua posição na rede, interpreta cada linha e gera o pacote a ser transmitido, conforme mostra a Figura 38.
Como previamente citado, o trafficGen gera diferentes arquivos que podem ser lidos por o flitGenerator.
Estes arquivos recebem o nome de in0.
Txt, in1.
Txt, in.
Txt, sendo N o número de chaves que compõem a NoC.
A cada flitGenerator é atribuído um número identificador que vai de zero à N-1.
Esta identificação é utilizada como base para a leitura dos arquivos gerados por o trafficGen.
O flitConsumer conecta- se à porta Local na saída da rede associada a uma chave.
Ele simplesmente consome o pacote que chega a ele.
A primeira funcionalidade a ser testada foi a de entrega dos pacotes.
Para esta tarefa foi desenvolvida uma NoC 6x6, onde foram conectados 36 flitGenerators e 36 flitConsumers, um par destes em cada chave.
A ferramenta trafficGen gerou 36 arquivos com conteúdos aleatórios.
A visualização na tela da partida de um pacote e depois de algum tempo a visualização da chegada no destino mostrou- se uma tarefa complexa.
Para superar esta dificuldade a descrição da NoC foi alterada para informar a cada chave a porta que estava requisitando roteamento, o endereço de destino do pacote e a porta destinada a este pacote, a partir de a geração de um arquivo de resultados de execução.
Esta abordagem facilitou o trabalho de detecção dos pacotes que entravam e saíam da rede.
Durante esta validação, foram encontrados problemas de transmissão dos pacotes.
Inicialmente alguns comportamentos não haviam sido levados em A ferramenta TrafficGen foi desenvolvida por o bolsista Leandro Heleno Möller para validação da NoC Hermes descrita em consideração tais como pacotes com tamanho zero e pacotes cujo endereço destino era igual ao endereço origem.
Esta validação permitiu a correção destes problemas e a garantia de funcionamento da NoC.
Obviamente a linguagem SystemC por si só não apresenta vantagens específicas para a detecção dos problemas anteriormente citados.
O ganho está em ter descoberto tal erro ainda nos primeiros passos de desenvolvimento e perceber- lo como um item a ser analisado ao longo de o processo de refinamento do projeto.
Assim sendo, a implementação em alto nível de abstração suportado por a linguagem SystemC permitiu a detecção do problema logo nos primeiros passos do projeto.
Início Abre arquivo Vai para próxima linha Fim de operação size é igual a zero?
Não Monta payload e envia Tem linha?
Analisa size Ainda tem linha?
Chaveador recebeu?
Monta header e envia Chaveador recebeu?
Decrementa size Chaveador recebeu?
Monta size e envia.
A segunda funcionalidade a ser validada foi a de paralelismo de transmissão de pacotes na rede.
Com base nos arquivos de resultados de execução gerados por a descrição da NoC mencionados anteriormente, foi possível analisar que havia paralelismo na transmissão dos pacotes.
Os pacotes que trafegavam na NoC possuiam, em média 20 flits por pacote, o que poderia bloquear em média 3 a 4 chaves durante o caminhamento por a rede, visto que a profundidade da fila utilizada era de 8 posições.
Pôde- se observar, que em determinadas ocasiões um pacote chegava ao seu destino e logo começava a ser consumido por o flitConsumer.
Alguns instantes depois, outro pacote chegava a mesma chave para ser consumido por o flitConsumer, porém permanecia ocupando as posições no buffer das portas de entrada e aguardando a liberação da porta Local, conforme ilustra a Figura 39.
Com tal mecanismo foi possível detectar que no mesmo instante que um pacote está sendo consumido num determinado endereço, os demais podem estar trafegando por a rede.
Conforme o trecho do arquivo de log apresentado na Figura 39, é pode- se determinar que há dois pacotes trafegando por a rede tendo como origem as chaves 0x0 e 5x2, ambos com destino à chave 4x1.
Com base na Figura 39, o caminhamento de ambos os pacotes é ilustrado na Figura 40.
Em a Figura 39, a primeira linha representa a partida do pacote PCK1 e a segunda representa a partida do pacote PCK2.
Em a quinta linha, o pacote PCK2 chega ao destino tendo este pacote percorrido as chaves 5x1 e 4x1.
Em a última linha o pacote PCK1 chega ao destino, tendo este pacote percorrido as chaves 0x0, 0x1, 1x1, 2x1, 3x1 e 4x1.
Como dito anteriormente, na modelagem Tl da NoC Hermes não há o sinal de relógio para ser utilizado como referência para avaliação de desempenho da NoC.
Assim sendo, a modelagem da NoC TLM exige o uso de métricas alternativas para a análise de desempenho.
Em este trabalho foram definidas duas métricas ambas utilizando como base o número de tentativas de transmissão de um pacote de uma chave para outra.
A primeira reporta o número de vezes que cada porta ganhou acesso ao recurso de roteamento antes de enviar o pacote para a porta destino.
Esta métrica foi denominada &quot;tentativas de roteamento».
A segunda reporta o número de vezes que uma porta competiu por acesso ao recurso de roteamento antes de enviar o pacote.
Esta métrica foi denominada &quot;concorrência por roteamento».
De posse destas duas definições de métricas para avaliação de desempenho a descrição da NoC Hermes TL foi alterada para que a informação pudesse ser capturada.
Estas informações então foram incluídas no arquivo de resultados de execução gerado por a descrição da NoC Hermes TL.
A métrica de &quot;tentativas de roteamento «permite avaliar critérios que facilitem o fluxo de informações por a rede.
Quanto menor forem os valores capturados para esta métrica mais livre está a rede, ou seja, menos canais estarão ocupados.
Parâmetros que venham a contribuir para uma rede mais livre podem ser obtidos com o uso de algoritmos de roteamento que não permitam grande liberdade de caminhamento por a rede e filas de armazenamento temporário mais profundas, por exemplo.
A métrica de &quot;concorrência por roteamento «permite avaliar se a latência interna em cada chave está coerente.
A entrega de pacotes que respeitam um tempo máximo para transitarem por a rede é interessante.
Pacotes que excedam este tempo máximo podem representar latência muito grande na rede.
Esta latência pode estar principalmente vinculada a concorrência por o recurso de roteamento quando muitos pacotes trafegam por a rede.
A presente métrica permite avaliar se o algoritmo de arbitragem que está sendo utilizado é o mais eficiente.
De posse destas duas métricas diferentes algoritmos de roteamento e arbitragem podem ser comparados.
Em alto nível de abstração é obtido o algoritmo que permite o maior ganho de desempenho.
De posse dos algoritmos mais eficientes, uma relação custo-benefício para o tamanho de hardware descrito e o ganho de desempenho pode ser realizada.
O critério a ser adotado fica a cargo de os projetistas.
Recursos adicionais:
Interfaces OCP e ferramentas de apoio NoCs são recursos de comunicação para SoCs complexos.
Assim, a padronização de suas interfaces com IPs procesadores do SoC que as contém é recomendável.
A implementação descrita nas Seções dotados de IPs processadores com interfaces padronizadas, forma desenvolvidos módulos adaptadores da interface nativa para o protocolo padrão OCP.
A descrição do projeto e validação destes módulos é alvo da Seção 5.1.
Como se escolheu implementar estes módulos detalhando o protocolo OCP no nível físico como precisão em nível de ciclos de relógio, lançou- se mão do conceito de transatores, que convertem transações em nível Tl em sinais com precisão RTL.
Tais transatores implementam interface padronizada OCP permitindo o reuso e a validação de núcleos IP descritos em SystemC RTL/ TL com a NoC Hermes descrita em SystemC Tl.
O processo de validação de projeto da NoC Hermes TL revelou- se complexo e propenso a erros.
Para aliviar estas dificuldades, foram desenvolvidas duas ferramentas específicas.
A primeira permite gerar descrições de NoCs em nível Tl de forma automatizada, a partir de parametrização do usuário.
A segunda auxilia no processo de identificação de caminhos percorridos por pacotes durante a execução de simulações de sistemas contendo NoCs.
A descrição destas ferramentas está contida na Seção 5.2.
O objetivo da NoC Tl é prover uma implementação abstrata da comunicação entre diferentes núcleos IP, e eficiente em termos de velocidade de simulação.
Os núcleos IP em si não precisam ser descritos no mesmo nível de abstração que a NoC Hermes, ou seja, núcleos IP TLM podem estar sendo simulados juntamente com núcleos IP RTL, utilizando como meio de comunicação a NoC Hermes TLM.
Em a implementação da NoC Hermes TL não foram utilizadas interfaces detalhadas através de sinais, o que para projetos que venham a utilizar tal detalhamento pode representar um complicador principalmente para projetos baseados em componentes.
Para integrar núcleos IP de diferentes níveis de abstração, fez- se necessário implementar módulos transatores que recebam sinais e convertam os mesmos em comunicação abstrata ou recebam uma comunicação abstrata e a convertam em sinais detalhados.
Há duas possibilidades de implementação de interface detalhada.
A primeira é a representação da mesma interface da NoC Hermes RTL descrita em VHDL.
A segunda era a implementação de uma interface padronizada, tal como a interface OCP.
Em projetos que visam reuso, o uso de interfaces padronizadas ao invés de interfaces proprietárias é vantajoso.
De o ponto de vista de implementação, estas interfaces representam apenas uma adaptação externa da NoC Hermes TLM.
Internamente, a comunicação da NoC, ou seja, entre as chaves, permanece ocorrendo de forma abstrata.
A descrição de interfaces padronizadas baseadas no padrão OCP provê duas contribuições.
A primeira é a possibilidade de validação mista de modelos descritos em RTL e Tl, facilitando a garantia da funcionalidade do sistema que se deseja implementar.
A segunda contribuição diz respeito ao reuso de projeto e os ganhos que se pode obter frente a a eficiência de simulação com a NoC Tl.
A presente Seção tem por finalidade descrever a implementação dos transatores OCP e uma semântica de comunicação adotada para a NoC Hermes TL.
A interface OCP Slave disponibiliza um mecanismo de comunicação entre núcleos IP mestres e dispositivos escravos.
Através desta interface, tanto comandos de escrita quanto de leitura podem ser requisitados por o núcleo IP mestre, conforme ilustra a Figura 41.
O transator NoC OCP Slave é uma interface escrava conectada à NoC Tl através de uma chave específica via a porta Local desta, como mostra a Figura 42.
Internamente a este transator não há a implementação de uma máquina de estados, apenas a interpretação dos sinais ou da comunicação abstrata que chega até o transator.
A implementação é predominantemente comportamental e não sintetizável.
O transator NoC OCP Slave tem duas funcionalidades básicas.
A primeira é capturar e repassar comandos de leitura ou escrita do núcleo IP mestre, passados através da interface OCP Master, para a chave vinculada.
A segunda é repassar ao núcleo IP mestre os dados solicitados numa operação de leitura.
Para implementar a primeira funcionalidade, o transator provê um mecanismo de interpretação de sinais detalhados e gera comunicação abstrata para a rede.
Para a interpretação de sinais detalhados, o transator NoC OCP slave aguarda comandos provenientes de um núcleo IP mestre.
Um exemplo de núcleo IP mestre pode ser um dispositivo MP3 que faz leitura numa memória remota.
Em o momento em que o dispositivo MP3 requisitar a leitura, um conjunto de sinais OCP Master é gerado, sendo estes sinais capturados por o transator NoC OCP Slave.
Tais sinais são interpretados e a um pacote é gerado, sendo enviado à NoC através da comunicação abstrata entre o transator NoC OCP slave e a NoC.
Note que a memória pode estar descrita em Tl ou RTL, estando conectada a outra chave da NoC.
O transator NoC OCP Slave possui uma interface OCP slave que emprega um mínimo de sinais, e duas interfaces abstratas (inToRouterIf e outFromRouterIf) definidas para a NoC, conforme ilustrado na Figura entre o transator e o wrapper OCP master do núcleo IP master ocorre através de compartilhamento de sinais.
A comunicação entre o transator e a interface OCP master ocorre de forma sincronizada através do uso de um sinal de relógio e um sinal de reset.
O comportamento do transator NoC OCP slave é dividido em envio de requisições de leitura ou escrita para a um núcleo IP disponível num determinado endereço na rede, e o recebimento da resposta, sendo esta definida de acordo com uma semântica de comunicação.
Para a implementação da interface detalhada, os parâmetros apresentados na Tabela 8 foram definidos.
Foram utilizados os sinais básicos OCP, como mencionados anteriormente.
Sobre estes sinais foi definida uma semântica de comunicação, o que é mais bem detalhado a seguir.
A semântica de comunicação corresponde ao envio do endereço destino da requisição, do tamanho da mensagem que será enviada e da mensagem em si.
O comando é interpretado por o transator e um pacote é gerado para ser transmitido por a rede.
Caso seja gerada uma requisição de leitura, o transator libera o núcleo IP mestre logo que a mensagem pode ser transmitida por a rede, o que evita o bloqueio da execução do núcleo IP mestre.
A o receber a resposta proveniente do endereço solicitado, o transator informa ao wrapper OCP Master que a resposta à requisição está disponível.
A interface OCP Master disponibiliza um mecanismo de comunicação entre núcleos IP escravos e dispositivos mestres.
Através desta interface, tanto comandos de escrita quanto de leitura podem ser recebidos por o núcleo IP escravo, conforme ilustra a Figura 43.
O transator NoC OCP Master é uma interface mestre conectada à NoC Tl por uma chave, através da porta Local, como mostra a Figura 44.
Internamente a este transator, não há a implementação de uma máquina de estados, apenas a interpretação dos sinais ou da comunicação abstrata que chega até o transator.
A implementação é predominantemente comportamental e não sintetizável, assim como ocorre com o transator NoC OCP Slave.
O transator NoC OCP Master tem duas funcionalidades básicas, assim como o transator NoC OCP Slave.
São elas:
Repassar para o núcleo IP escravo os comandos de leitura e escrita recebidos através da NoC e enviar através da NoC a resposta a uma requisição de leitura.
A primeira funcionalidade é obtida através da interpretação do pacote que trafega por a rede e a conseqüente geração de sinais detalhados por a interface OCP com um núcleo IP escravo conectado a este transator.
Assim sendo, a comunicação abstrata através da NoC gera estímulos através da interface OCP.
A segunda funcionalidade é obtida a partir de os sinais OCP de resposta gerados por o núcleo IP escravo.
A partir de esta resposta um pacote é enviado à rede através da interface abstrata.
Um exemplo de núcleo IP escravo pode ser uma memória que recebe comandos de leitura e escrita.
Sempre que algum dispositivo mestre ou mestre/ escravo conectado à NoC Hermes requisitar uma operação com esta memória, um pacote contendo um comando será recebido por o transator NoC OCP Master.
A partir de esta comunicação abstrata, um conjunto de sinais OCP será gerado.
Para a implementação da interface detalhada, os parâmetros apresentados na Tabela 9 foram definidos.
Este conjunto de sinais segue o padrão OCP também definido para o transator NoC OCP Slave.
Assim como naquele transator, sobre estes sinais foi definida uma semântica de comunicação, detalhado a seguir.
A semântica de comunicação adotada na rede define que ao receber um pacote, o transator descarta o primeiro flit, armazenando apenas o endereço de retorno.
O segundo flit contém o tamanho do payload da mensagem, incluindo o comando.
O terceiro flit contém o comando que será gerado.
Caso o valor deste flit seja 1, o transator está recebendo uma requisição de escrita, e caso seja 2 o transator está recebendo uma requisição de leitura.
No caso de uma requisição de escrita, os dois próximos flits representam o endereço de escrita e o dado.
Para esta requisição, o tamanho mínimo que deve ter sido recebido no flit size é 3.
Caso este valor seja maior que 3, mais de uma escrita está sendo requisitada no mesmo pacote, caracterizando uma escrita em rajada.
Para o caso de uma requisição de leitura, o tamanho mínimo do size flit é 2, um flit de comando e um de endereço.
Caso este valor seja maior que 2, mais de uma requisição de leitura estará sendo realizada no mesmo pacote, caracterizando uma leitura em rajada.
A interpretação destes pacotes faz com que um conjunto de estímulos obedecendo ao protocolo OCP seja gerado.
Estes estímulos são enviados ao wrapper OCP slave, que se responsabiliza por a comunicação com o núcleo IP slave.
A interface OCP Master/Slave disponibiliza um mecanismo de comunicação entre núcleos IP mestre escravo e qualquer outro dispositivo da rede.
Núcleos IP mestre escravo têm como característica poder ser acionadores ou dispositivos que respondem a requisições de outros dispositivos.
Através desta interface solicitações de leitura podem ser executadas por estes ou recebidas.
De a mesma forma, respostas podem ser recebidas ou enviadas, conforme ilustra a Figura 46.
O transator NoC OCP Master/Slave é uma interface mestre conectada à NoC Tl através de uma chave específica via a porta Local, como mostra a Figura 46.
Assim como os demais transatores, internamente este transator não implementa uma máquina de estados, apenas realiza a interpretação dos sinais OCP ou da comunicação abstrata que chega até este transator.
A implementação é predominantemente comportamental e não sintetizável, assim como ocorre com os demais transatores da NoC.
O transator NoC OCP Master/Slave tem quatro funcionalidades.
Isto se deve ao fato de que este transator une as funcionalidades dos transatores Master e Slave.
Tais funcionalidades são:
Recebimento de comandos e repasse de resposta de uma leitura, no lado escravo deste transator, e o repasse de comandos OCP e recebimento de resposta de leitura, no lado mestre deste transator.
Tais funcionalidades são alcançadas da mesma forma que as especificadas em ambos transatores Master e Slave.
Um exemplo de núcleo IP Master/Slave é um processador que aguarda receber uma requisição de execução, e, ao receber tal requisição, inicia atividades de leitura e escrita através da NoC.
Inicialmente, este processador tem um comportamento escravo, pois aguarda um comando, e logo em seguida assume um comportamento mestre, visto que realiza comandos de leitura e escrita com os demais dispositivos na NoC.
O projeto do transator NoC OCP Master/Slave é a união duas interfaces, uma interface OCP Master e uma OCP Slave (descrita com sinais) e duas interfaces abstratas inToRouterIf e outFromRouterIf definidas para o lado da NoC, conforme ilustrado na Figura 46.
A interface OCP é conectada ao núcleo IP mestre escravo e as interfaces abstratas são conectadas à NoC, uma para envio de pacotes à rede e outra de recebimento de pacotes da rede.
Para a implementação da interface OCP, os parâmetros apresentados na Tabela 10 foram definidos.
Este conjunto de sinais segue o padrão OCP também definido para o transator NoC OCP Master/Slave, e assim como naquele transator, sobre estes sinais foi definida uma semântica de comunicação, detalhada a seguir.
A o receber um pacote, o transator descarta o primeiro flit (endereço de destino do pacote) armazenando apenas o endereço de retorno.
O segundo flit contém o tamanho do payload da mensagem, incluindo o comando.
O terceiro flit contém o código do comando a ser gerado na interface OCP.
Caso o valor deste flit seja 1, o transator está recebendo uma requisição de escrita.
Caso seja 2, o transator está recebendo uma requisição de leitura, e caso seja 8 o transator está recebendo uma resposta de uma requisição realizada por o núcleo IP Master/Slave.
No caso de uma requisição de escrita, os dois próximos flits representam o endereço de escrita e o dado.
Para esta requisição, o tamanho mínimo que deve ter sido recebido no flit size é 3.
Caso este valor seja maior que 3, mais de uma escrita está sendo requisitada no mesmo pacote, caracterizando uma escrita em rajada.
Para o caso de uma requisição de leitura, o tamanho mínimo do flit size é 2, um flit de comando e um de endereço.
Caso este valor seja maior que 2, mais de uma requisição de leitura estará sendo realizada no mesmo pacote, caracterizando uma leitura em rajada.
A interpretação destes pacotes faz com que um conjunto de estímulos obedecendo ao protocolo OCP seja gerado.
Estes estímulos são enviados ao wrapper OCP Slave, que se responsabiliza por a comunicação com o núcleo IP slave.
Para o caso em que o comando é uma resposta de requisição anterior, o size flit informa quantos dados estarão sendo recebidos.
Para validação das interfaces padronizadas, foram definidos dois núcleos IP, um implementando um módulo descrevendo o algoritmo de cálculo da série de Fibonacci, a partir de aqui denominado Fibonacci, e um descrevendo o comportamento de um núcleo IP memória, a partir deste ponto denominado Memória.
Fibonacci é um módulo mestre, que requisitam comandos de leitura e escrita, enquanto Memória é um módulo escravo que responde as requisições do núcleo IP mestre.
O núcleo IP Fibonacci calcula os 100 primeiros números da série de Fibonacci.
Em o núcleo IP Fibonacci foi definido um processo para realizar o cálculo da série.
Inicialmente este processo escreve o primeiro e segundo valores da série.
Após isto, são executadas duas requisições de leitura da memória e uma de escrita.
Em as duas leituras, os dados capturados da memória são utilizados como base para o cálculo da série de Fibonacci.
Em a escrita, o resultado da soma dos dois valores lidos é armazenado na memória.
Para validar os transatores NoC OCP Master e NoC OCP Slave a estrutura ilustrada na Figura 47 foi empregada.
Em esta validação, a NoC Hermes inicialmente não está presente.
Este modelo serve exclusivamente para validar funcionalmente os transatores NoC OCP Master e NoC OCP Slave.
Conforme a funcionalidade do transator NoC OCP Slave, sempre que uma requisição é gerada por Fibonacci, um pacote é gerado e enviado na NoC Hermes.
Este pacote é transmitido ao transator NoC OCP Master onde é interpretado.
Para a validação do funcionamento dos transatores, foram utilizadas duas estratégias.
A primeira foi a apresentação dos valores lidos e o resultado do cálculo na própria tela.
A segunda forma foi a validação através de formas de onda, tendo então sido gerado um arquivo com formato VCD e utilizado o software gtkWave.
A cada execução do ambiente de validação, foram realizadas 196 requisições de leitura e 100 requisições de escrita.
Através deste ambiente de validação, pôde- se constatar que o funcionamento tanto do transator NoC OCP Master quanto do NoC OCP Slave estava correta.
Os estímulos gerados por o núcleo IP Fibonacci foram corretamente capturados por o transator NoC OCP Slave, repassados sob a forma de pacotes para o transator NoC OCP Master, ali interpretados e transmitidos para a Memória.
Finalizada a validação destes dois transatores, iniciou- se a validação do transator NoC OCP Master/Slave.
Para a validação do transator NoC OCP Master/Slave, foi utilizado um ambiente de validação similar ao descrito anteriormente.
A NoC Hermes inicialmente não foi utilizada no ambiente de validação, o que permitiu concentrar- se na validação dos transatores.
O ambiente de validação é ilustrado na Figura 48.
Foram utilizados dois núcleos IP Fibonacci e dois núcleos IP Memória.
Foi assim definido que o núcleo IP Fibonacci_ 1 executaria operações de leitura e escrita sobre o núcleo IP Memória_ 2, e o núcleo IP Fibonacci_ 2 realizaria operações de leitura e escrita sobre o núcleo IP Memória_ 1.
O objetivo deste ambiente é validar tanto o funcionamento de cada uma das partes do transator NoC OCP Master/Slave separadamente (a mestre e a escrava) quanto as operações concorrentes de requisição (quando há o envio e o recebimento de comandos por a interface OCP).
Para a validação em separado do transator NoC OCP Master/Slave, o núcleo IP Fibonacci_ 1 requisitava operações de leitura e escrita sobre o núcleo IP Memória_ 2.
Foram utilizados impressão na tela e arquivos com formas de onda para a validação da execução do ambiente.
Assim como na validação dos transatores NoC OCP Master e NoC OCP Slave, o repasse de requisições ocorreu sem problemas, o que demonstrou que numa situação onde não há concorrência entre as diferentes partes do transator NoC OCP Master/Slave, sua funcionalidade é correta.
Memória_ 1.
Para a validação do ambiente com concorrência, o ambiente apresentado na Figura 48 foi utilizado, sendo que os núcleos IP Fibonacci_ 1 e Fibonacci_ 2 operavam sobre os núcleos IP Memória_ 2 e Memória_ 1 respectivamente.
Este ambiente permitiu simular uma situação em que requisições eram enviadas e recebidas por os transatores simultaneamente.
Durante a execução deste ambiente de validação, foi eventualmente detectado bloqueio do processo descrito neste transator.
O problema ocorreu porque no mesmo instante em que uma requisição de leitura chegava a um dos transatores Master/ Slave, o núcleo IP Fibonacci conectado a este poderia estar gerando requisições de leitura para a memória no transator vizinho.
Foram detectados dois problemas advindos desta situação.
O primeiro foi a perda de contexto durante a operação com a memória.
O segundo problema foi a ocorrência de deadlock entre os transatores, porque os dois transatores estavam recebendo requisições de leitura ao mesmo tempo e para evitar perda de contexto, nenhum dos transator respondia ao outro, ficando ambos aguardando que o outro responde- se.
A solução encontrada consistiu em modificar o módulo de forma a garantir que a partir de a chegada de uma requisição, seja do núcleo IP mestre ou de um pacote da rede, esta tinha seu atendimento garantido, independente da chegada de novas requisições.
Para validar a funcionalidade dos transatores NoC OCP Master/Slave, foram utilizados novamente dois mecanismos.
O primeiro foi através da impressão na tela das requisições de leitura e escrita e da verificação do sucesso destas operações.
O segundo mecanismo consistiu da análise de formas de onda capturada durante a execução do ambiente de validação em arquivo VCD.
Depois de detectado e corrigido o problema de bloqueio da execução dos transatores NoC OCP Master/Slave, o ambiente foi validado funcionalmente.
O resultado final foi a validação dos 3 transatores, NoC OCP Master, Slave e Master/ Slave.
Estes foram funcionalmente validados para serem utilizados em projetos.
Com esta garantia, núcleos IP descritos em diferentes níveis de abstração podem ser validados juntamente com a NoC abstrata, levando em consideração apenas aspectos funcionais, onde o uso de um sinal de relógio não seja necessário.
O desenvolvimento e a validação dos transatores contribuíram para o entendimento da conversão de comunicação detalhada em abstrata e vice-versa.
A partir destes, outros transatores foram desenvolvidos e utilizados em projetos de SoCs, tal como aquele desenvolvido no contexto do projeto Fênix4.
Esta abordagem permitiu o desenvolvimento de aplicações que mesclavam núcleos IP em diferentes níveis de abstração, o que facilita encontrar eventuais problemas de projeto logo nos primeiros passos de desenvolvimento e com tempo de simulação muito menor, dado o baixo grau de detalhamento possível de ser utilizado.
Durante o desenvolvimento deste trabalho, algumas versões da NoC Hermes TL foram descritas.
Todas as versões utilizaram apenas a topologia malha, tendo como dimensões mínimas uma rede 2x2, ou seja, quatro chaves interconectadas.
A maior rede descrita tinha dimensões 6x6, ou seja, trinta e seis chaves interconectadas.
A descrição de uma NoC não representa uma tarefa complexa em si, mas devido a a quantidade de núcleos IP envolvidos na descrição da mesma e a quantidade de canais utilizados para interconectar- los é uma atividade muito propensa a erros.
Assim, além de a mera descrição da rede consumir um tempo elevado, muitas vezes o processo deve ser revisado.
Para a validação da NoC Hermes TL, inicialmente foi utilizado um método simples de análise do caminhamento.
Era utilizada uma representação em papel da NoC descrita e, a partir de as informações impressas na tela, o caminhamento do pacote era rastreado.
Assim como a tarefa anterior, não se trata de tarefa complexa, mas devido a o volume de informações esta também é uma atividade propensa a muitos erros.
Por vezes, durante a execução do modelo a rede bloqueava.
Encontrar o pacote que havia bloqueado na rede era uma tarefa difícil devido a o volume de informações a manipular.
Devido as estas dificuldades, considera- se importante o desenvolvimento de ferramentas que facilitem tanto a descrição esta quanto a validação da NoC Hermes TL.
Foram desenvolvidas as ferramentas nocGen e nocLogView.
A primeira permite descrever uma NoC Hermes TL de forma automatizada.
A segunda gera relatórios a partir de a execução do modelo da NoC Hermes TL.
A presente Seção tem por finalidade apresentar a funcionalidade destas ferramentas.
Uma NoC 6x6 de topologia malha em SystemC, cria 36 instâncias do núcleo IP chave e 2 canais de comunicação externa para cada porta da chave.
Para cada instância da chave devem ser passados parâmetros específicos ou genéricos, tais como o endereço da chave na rede, o algoritmo de roteamento a ser utilizado e a dimensão total da rede.
Quanto a as interconexões, caso a ligação entre as chaves seja realizada de forma errada, o caminhamento por a rede fica comprometido.
Para superar os problemas derivados de erros oriundos de um processo manual de descrição foi desenvolvida a ferramenta nocGen.
Esta ferramenta possui duas funcionalidades.
A primeira é a capacidade de geração de um arquivo intermediário contendo a informação de interconexão da rede.
A segunda é a geração da NoC descrita em SystemC a partir deste arquivo intermediário.
Estas duas funcionalidades são fornecidas de forma separada para evitar a limitação da ferramenta de apenas gerar uma descrição fixa da NoC Hermes TL e também para permitir o uso futuro de outras linguagens.
O arquivo intermediário provê informações sobre a interconexão da rede, podendo ser utilizado como entrada para ferramentas, de geração de descrições de redes.
O arquivo intermediário é estruturado conforme ilustrado na Figura 49 (a).
A primeira linha representa a definição de uma chave.
A linha começa com os caracteres &quot;C:».
A seguir são informados o nome da chave e a posição XY desta na rede.
As linhas seguintes, que iniciam por &quot;P:»
representam as portas desta chave.
Há três tipos de descrição diferente para as portas, quais sejam:
Ou não está conectada a alguma chave, ou está conectada a outra chave ou é uma porta Local.
Quando a porta está não conectada a alguma chave, aparece o valor 1 na linha, como aparece na segunda linha.
Quando a porta está conectada a outra chave, aparece o nome da chave a qual ela está conectada e a qual porta desta chave é realizada a conexão, exemplificado por a terceira linha.
Caso a porta seja Local, nenhum valor é informado visto que ela é utilizada como entrada da NoC, conforme ilustra a sexta linha da Figura 49 (a).
Para gerar o arquivo intermediário por a ferramenta, basta digitar o comando».
/ nocgen topology mesh size 2 2».
A o executar este comando será solicitado o nome do arquivo de saída.
O resultado da geração de um arquivo intermediário de uma NoC 2x2 pode ser visto na Figura 49 (a), correspondendo à NoC na Figura 49 (b).
A geração de um modelo de NoC Hermes a partir de um arquivo intermediário permite tanto que descrições manuais de interconexões das chaves sejam elaboradas como que se descreva a rede de forma automática.
As informações deste arquivo intermediário são interpretadas e um modelo pronto para ser utilizado é produzido.
O uso da ferramenta NoCGen permite a geração da NoC Hermes em SystemC dois níveis de abstração.
O primeiro nível é a descrição totalmente em nível de transação, onde a rede é composta por chaves cuja computação é descrita de forma comportamental sem ciclos de relógio e a comunicação descrita de forma abstrata através da chamada de serviços.
O segundo nível é a descrição RTL.
As descrições neste nível estão atualmente limitadas ao uso do algoritmo de roteamento XY puro.
Esta ferramenta opera via linha de comando, informando ao final do processamento se tudo ocorreu como esperado ou se ocorreu algum erro.
Os comandos associados ao programa são apresentados na Figura 50.
O resultado obtido com esta ferramenta foi uma descrição de NoC em SystemC Tl confiável e realizada num tempo muito menor do que se o mesmo fosse produzido manualmente.
A NoC Hermes TL 6 x6 mencionada anteriormente foi gerada por esta ferramenta.
Uma NoC Hermes TL 2 x2 gerada a partir de esta ferramenta é apresentada no apêndice E deste trabalho.
Com o objetivo cobrir o máximo de situações de tráfego e bloqueios de canais possíveis de ocorrer na NoC, um número grande de pacotes deve estar trafegando simultaneamente por a rede.
Durante a execução do modelo da NoC Hermes TL, informações sobre a passagem de cada um dos pacotes em cada uma das chaves era impressa na tela.
Tais pacotes eram gerados com a ferramenta trafficGen, que permite a definição de pacotes para destinos aleatórios ou para um destino único.
Inicialmente, as informações eram utilizadas para avaliar se o algoritmo de roteamento estava sendo executado de forma coerente.
Para isto, um gráfico impresso em papel representando a NoC sob simulação, era utilizado para validar o caminho realizado por os pacotes durante a simulação.
Quando algum erro no envio de um pacote ocorria (e.
g um pacote que não chega ao destino) a detecção do primeiro pacote que ficou preso era uma tarefa complicada devido a a quantidade de pacotes que já trafegavam na rede.
Em uma das operações de validação utilizou- se uma NoC 6x6 e na ferramenta trafficGen foi definido que cada chave enviaria 50 pacotes à rede.
Pressupondo que cada pacote passaria por três chaves até chegar a seu destino, a quantidade média de linhas resultante da execução deste modelo era de aproximadamente 5400 linhas (36 chaves x 50 pacotes x 3 chaves por onde passam os pacotes).
Como alternativa para superar a dificuldade encontrada com a validação em papel planilhas eletrônicas foram utilizadas como mecanismo de validação.
Adicionalmente, o uso deste mecanismo permitia maior facilidade na análise de alguns parâmetros, tal como o atraso que um pacote sofre durante o caminhamento por a rede.
Apesar de mais eficiente que a validação em papel, esta tarefa ainda consumia tempo considerável, chegando a ocupar 2 horas para o mapeamento de um grupo de cinco pacotes.
Além deste problema, a possibilidade de erro ao rastrear um pacote permanecia elevada, o que por vezes punha em dúvida os resultados obtidos, tornando assim este um método pouco confiável de validação.
Para superar esta dificuldade na tarefa de validação foi desenvolvida a ferramenta nocLogView.
Esta ferramenta sofreu um processo evolutivo de desenvolvimento, atendendo inicialmente à validação dos algoritmos de roteamento, através do rastreamento de pacotes que trafegaram na NoC, e a seguir gerando relatórios sobre o tráfego de pacotes.
Como entrada desta ferramenta utiliza- se o mesmo arquivo empregado para validação em papel ou via planilha eletrônica.
Como saída, a ferramenta apresenta um conjunto de relatórios, conforme ilustra a Figura 51, que têm como objetivo contribuir para a validação da NoC.
Para chamar a ferramenta, basta digitar».
/ noclogview tl nome_ de o_ arquivo_ de_ log», e aguardar a apresentação das opções de relatório.
Para simulações de grande volume de informações, o processo de geração pode levar em torno de 30 segundos.
A opção -- Lista de chaves informa quantos pacotes foram enviados a partir de cada chave e quantos destes pacotes chegaram ao destino, conforme ilustra a Figura 52.
Em o final é apresentada uma sumarização de quantos pacotes foram enviados à rede e quantos chegaram ao destino.
Esta informação permite identificar se a funcionalidade da NoC foi atingida, ou seja, se todos os pacotes enviados a rede foram entregues.
Caso nem todos os pacotes tenham sido entregues, esta opção facilita identificar de quais chaves originaram os pacotes que não chegaram ao destino.
Com isto fica mais fácil e ágil encontrar os pacotes que trancaram na rede.
Em a Figura 52 é apresentado o final da lista de chaveadores de uma simulação ocorrida numa NoC 3x3.
A opção -- Lista de pacotes lista todos os pacotes que foram enviados através da rede, informando qual era seu destino e se este alcançou ou não seu destino.
Não há uma relação direta entre a chave de origem com o pacote, todavia esta informação permitiu, nos primeiros estágios de validação, encontrar quais eram os destinos que estavam tendo algum problema para o recebimento de pacotes.
Em a Figura 53 apresenta- se o resultado final da lista de pacotes.
A terceira opção do relatório, -- Lista de pacotes por chaves, permite uma visualização mais detalhada do percurso percorrido por pacotes enviados de cada uma das chaves.
Durante o processo de validação da NoC houveram pacotes que não foram entregues ao destino, ou seja, ficaram presos por algum motivo durante seu caminhamento por a rede.
A opção da ferramenta permite visualizar de quais chaves partiram os pacotes que pararam em seu caminhamento por a rede.
Em a opção o usuário pode detalhar informações sobre os pacotes que partiram de uma chave.
A o escolher uma chave específica, são listados todos os pacotes que foram enviados por esta, informando qual era seu destino, se alcançou o destino, por quantas chaves passou até chegar a seu destino e a latência que obteve até alcançar seu destino.
Em este contexto, latência significa quantas vezes o pacote ganhou prioridade para ser roteado.
Esta opção permite ainda detectar quais pacotes foram bloqueados em seu caminhamento por a rede.
A Figura 54 ilustra o resultado da escolha da opção Lista de pacotes por chaves para a chave 0x0.
Provavelmente a opção que mais contribuiu para detectar problemas no caminhamento de pacotes na rede tenha sido a -- Rastreamento de pacote específico.
A o detectar que um pacote havia parado na rede, utilizando a opção, e, esta nova opção permite detectar mais facilmente todos os pacotes que pararam na rede.
Utilizando esta opção da ferramenta foi possível detectar com maior facilidade a ocorrência de situações de deadlock para o algoritmo de roteamento XY adaptativo mínimo.
Adicionalmente, pôde- se validar se o caminhamento de pacotes na rede estava condizente com o algoritmo de roteamento que estava sendo empregado naquele momento.
A partir de o sucesso obtido com estes relatórios, foram definidos outros tipos de relatórios, que possibilitaram a medição do atraso relativo obtido com cada algoritmo de roteamento.
Esta análise de atraso, está diretamente vinculada à escolha do algoritmo de roteamento.
Apesar de isto, sabe- se que problemas de contenção estão principalmente relacionados ao algoritmo de arbitragem adotado.
A opção da ferramenta foi desenvolvida para permitir a análise das informações capturadas durante a execução do modelo da NoC Hermes TL, estendendo assim a ferramenta para uma característica adicional, a da validação.
Pode- se observar na Figura 55 algumas informações capturadas durante a execução do modelo e geradas por a ferramenta.
A primeira parte deste relatório fornece informações gerais sobre o tráfego total de pacotes por a rede.
A primeira linha informa quantos pacotes foram enviados através da rede.
A segunda linha informa o somatório do número total de vezes que cada pacote concorreu por prioridade, independente de ter ganhado ou não.
Esta informação permite avaliar, por exemplo, se o algoritmo de arbitragem que está sendo utilizado é o mais eficiente quanto a o tempo de espera de um pacote para ser roteado.
A terceira linha informa o somatório sobre todos os pacotes de quantas vezes um pacote ganhou prioridade dentro de cada chave, independente de ter sido roteado.
A quarta linha informa o percentual médio de vezes que o pacote ganhou direito de acesso ao roteamento sobre o total de vezes que concorreu.
No caso de a Figura 55, houve em média 85% de ganho de direito de acesso, ou seja, cada pacote concorreu poucas vezes para ser atendido por o algoritmo de roteamento, o que representa uma baixa concorrência por o recurso de roteamento.
A linha seguinte, a quinta linha, informa o percentual médio de vezes que um pacote pôde ser roteado após obter direito de acesso ao roteamento.
De o universo de 94595 ganhos de direito de acesso, apenas 8514 vezes os pacotes puderam ser roteados, ou seja, 9% das vezes.
A sexta linha informa o total de vezes que alguma chave utilizada durante o caminhamento dos pacotes.
Este dado permite comparar os diferentes algoritmos de roteamento para avaliar a relação custo-benefício do uso de cada um destes.
Para um mesmo volume de pacotes na rede, o uso de mais chaves durante o caminhamento indicar maior quantidade de bloqueio de canais e maior consumo de potência.
A sétima e oitava linhas são usadas apenas como parâmetro para avaliar os demais dados.
A nona linha faz uma média aritmética da quantidade de vezes que cada pacote concorreu por prioridade durante todo seu caminhamento na rede.
A décima linha apresenta uma média aritmética do número de chaves utilizadas por os pacotes em seu caminhamento na rede.
Finalmente, a 11ª linha apresenta a média aritmética do número de vezes que cada pacote tentou sair de cada uma das chaves em que entrou durante seu tráfego por a rede.
Após esta primeira parte do relatório, é apresentada uma seqüência de informações separando os pacotes por o número de chaves que passou até atingir seu destino.
O primeiro conjunto, o de pacotes que passaram por apenas uma chave, não tem sentido num sistema real, pois representam pacotes que saem de uma chave, por exemplo, a 0x0, e tem como destino a mesma chave.
Como os pacotes são gerados por a ferramenta trafficGen e seu destino é aleatório, a situação de uma chave enviar um pacote para ela mesma é possível de ocorrer.
Os demais conjuntos podem ser utilizados para distribuir de forma mais otimizada os núcleos IP por a rede de forma a diminuir o uso de chaves ou a latência.
Com base nos dados capturados, iniciou- se uma investigação sobre a relação da descrição em nível de transação com descrições de mais baixo nível.
Uma descrição da NoC Hermes RTL em VHDL foi desenvolvida anteriormente a este trabalho.
Em esta, a ferramenta trafficGen5 gera pacotes que alimentam a rede para validação da transmissão.
A validação é realizada por cosimulação C/ VHDL, em a qual os arquivos gerados por a ferramenta trafficGen são lidos, e ao final da execução é gerado um arquivo de saída para cada chave com a informação do momento em que o pacote entrou na rede, a origem do pacote e o momento em que este saiu.
Inicialmente, imaginou- se criar uma relação entre o arquivo de saída da cosimulação e o arquivo de resultados de execução gerado por a NoC Tl.
Esta abordagem permitiria comprovar que os resultados obtidos de forma abstrata poderiam prever uma relação direta entre as duas descrições, SystemC e VHDL.
Infelizmente, o resultado obtido não foi o esperado.
Em a maioria das vezes, uma grande latência detectada na descrição em nível de transação não se verificava na descrição VHDL.
O principal motivo para este problema é a diferença na arquitetura das linguagens.
Em o momento em que um pacote de uma determinada chave entra na rede descrita em SystemC não ocorre na mesma instante que o mesmo pacote no mesmo chave na descrição VHDL.
Assim, o resultado é o bloqueio de determinadas portas da chave descrita em SystemC que não necessariamente ocorre na descrição VHDL.
Conseqüentemente, o atraso em SystemC não necessariamente representa o atraso em VHDL, ou pelo menos, não há uma relação direta entre a simulação SystemC e a mesma em VHDL.
Apesar de isto, a ferramenta nocLogView contribuiu em muito para a análise e validação da NoC Tl, possbiilitando a diminuição do tempo necessário para rastrear pacotes, detectar erros e situações de deadlock no roteamento, capturar latência média, latência total, e medir percursos médio e total.
Considerações finais O presente trabalho foi o primeiro ao longo de o desenvolvimento da NoC Hermes a prover um modelo abstrato da NoC em nível de transação.
Este é parte de um esforço de modelagem abstrata da estruturas de comunicação em SoCs, tendo em vista a crescenete complexidade da parte de comunicação neste tipo de sistemas.
O trabalho aportou um conjunto de contribuições originais, cujas principais são detalhadas a seguir.
Devido a a necessidade de melhor detalhamento em níveis de abstração da denominação genérica nível de transação, e por não haver um modelo amplamente aceito para isto na comunidade de pesquisa, foi proposto um conjunto de níveis de abstração de captura de projeto, apresentados e justificados no discutidos naquele Capítulo.
Para corroborar a proposta de organização de níveis de abstração de projeto acima de o RTL, conduziu- se um experimento de modelagem e implementação de um processador especificado por o grupo GAPH, descrita no Capítulo 3.
Para estas atividades utilizou- se as linguagens de descrição de hardware SystemC e VHDL.
Comparou- se a área ocupada em hardware obtida com cada um dos modelos apresentados.
Ainda naquele Capítulo, os níveis de abstração de captura de projeto Tl e RTL foram comparados quanto a o desempenho de simulação.
Uma segunda contribuição do presente trabalho portou sobre a modelagem abstrata de comunicação em SoCs, usando como estudo de caso a NoC Hermes desenvolvida no escopo do grupo de pesquisa do Autor.
Este estudo de caso, descrito no Capítulo 4, permitiu estabelecer um método informal de descrição de modelos abstratos para a comunicação em SoCs, que vem desde então sendo utilizado por outros membros do grupo do Autor.
O modelo abstrato foi também empregado no escopo de um projeto cooperativo multi-institucional, onde desempenha o papel de meio de comunicação na descrição abstrata de uma plataforma de projeto para sistemas embarcados sem fio (plataforma Fênix, no projeto Brazil-IP).
Adicionalmente, os primeiros passos foram dados aqui para se obter métodos de avaliar o desempenho da comunicação em níveis de descrição abstratos, através da proposta de técnicas de estimativa do desempenho temporal da comunicação na rede Hermes TL.
A terceira contribuição foi o desenvolvimento das ferramentas de apoio ao projeto, validação e avaliação de NoCs, descrito no Capítulo 5.
Uma de estas (nocGen) automatiza parcialmente o processo de descrição de redes intra-chip no nível de transação, enquanto uma outra ferramenta (nocLogView) agiliza o processo de validação e avaliação dos modelos utilizados, conforme apresentado igualmente no Capítulo Finalmente, empreendeu- se o desenvolvimento de núcleos IP que convertem comunicação abstrata para comunicação detalhada compatível com o protocolo padronizado OCP, conforme descrito no Capítulo 5.
Estes núcleos são específicos para o estudo de caso de NoC abordado, mas o domínio de sua implementação é visto como uma contribuição importante.
Isto se deve ao fato de que o desenvolvimento dos transatores facilita o reuso de projeto e a validação mista de núcleos descritos nos níveis RTL e Tl que venham a utilizar a NoC Hermes TL como mecanismo de comunicação.
Estes transatores foram também utilizados na plataforma Fênix do projeto Brazil-IP citado anteriormente.
Pôde- se observar que não existe uma proposta de organização de níveis de abstração acima de o RTL universalmente aceita ou adequada para todo e qualquer contexto de projeto de SoC.
Julgou- se necessário definir um conjunto de níveis de abstração superiores ao RTL que fizessem uso da separação de aspectso de computação e comunicação para facilitar a modelagem.
Como trabalho futuro, sugere- se a caracterização mais detalhada destes níveis de abstração seguida da deinição de fluxos de projeto coerentes baseados numa seqüência destes níveis como processo de refinamento ao longo de o projeto de SoCs.
Dado a existência de um esfroço de automatização do processo de geração da comunicação através de redes intra-chip no grupo do Autor, concretizado através do arcabouço Maia, considera- se importante como trabalho futuro a integração das funcionalidades das ferramentas nocGen e nocLogView à este arcabouço.
Esta atividade habilitaria o arcabouço Maia a gerar e validar estruturas de comunicação descritas no nível Tl, uma vez que hoje este está limitado à geração/ validação de descrições no nível RTL.
Como benefício no sentido oposto, ou seja, do arcabouço Maia para o trabalho com níveis asbtratos de projeto, terá- se- a agregação da capacidade de geração de tipos de tráfego complexos, uma característica de relevância no processo de validação de NoCs.
Este trabalho modelou a NoC Hermes no nível de transação.
Tal NoC foi validada funcionalmente através do uso das ferramentas de apoio desenvolvidas especificamente para este fim.
Adicionalmente é permitida a parametrização da rede quanto a o dimensionamento e algoritmos de roteamento, através da ferramenta nocGen.
Contudo, não foram obtidos dados quantitativos detalhados, tais como a latência estimada ou o throughput da rede para tráfegos dados, sejam estes realistas ou não.
Desta forma, a obtenção de tais dados e sua análise constitui uma interessante sugestão para trabalho futuro.
Além de isto, divisa- se como relevante estender a capacidade de geração/ validação de NoCs para outras topologias (e.
g Finalmente, foi desconsiderada aqui a implementação de suporte à qualidade de serviço (em infglês, sistemas de alcance comercial, é importante poder gerar NoCs com garantia de QoS em diversos níveis.
Todavia, um trabalho anterior a este deve ser a definição de quais as formas de QoS implementar, como modelar QoS em níveis de abstratos.
Esta tarefa envolverá necessáriamente análise de como descrever abstratamente sistemas usando chaveamento de circuito e/ ou canais virtuais.
