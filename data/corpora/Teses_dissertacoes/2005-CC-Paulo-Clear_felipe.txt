A avaliação de desempenho de um software orientado a objetos, hoje, pode ser feita basicamente de três maneiras:
Com testes de desempenho, simulações ou utilizando métodos analíticos como Redes de Autômatos Estocásticos e Rede de Fifilas de espera.
Os teste de desempenho são eficientes, porém podem ser aplicados apenas nas fases finais do desenvolvimento de software, quando o produto está praticamente pronto.
As simulações podem ser realizadas nas etapas iniciais do processo de desenvolvimento de software porém, geralmente, são custosas, pois dependem da criação de um simulador.
Os métodos analíticos podem ser aplicados nas fases iniciais do desenvolvimento, mas exigem a criação de um modelo de avaliação de desempenho.
Em o desenvolvimento de software orientados a objetos já se constrói um modelo, o qual possui informações detalhadas sobre o sistema.
Estas informações podem ser utilizadas para gerar um modelo de avaliação de desempenho que represente o software já que muitas das informações contidas no modelo do software são comuns ao modelo de avaliação de desempenho.
Utilizando esta idéia foram criados alguns métodos de conversão de UML para formalismos de avaliação de desempenho como redes de&amp; filas de espera.
Porém, ainda inexistem métodos ou técnicas que convertem UML para formalismos como SAN, que é mais abrangente que, por exemplo, redes de&amp; filas de espera.
Este trabalho demonstra uma técnica de conversão de UML para SAN, onde explora- se a representação da arquitetura lógica de softwares orientados a objetos.
Com o aumento da complexidade dos softwares orientados a objeto e o crescimento do número de usuários dos mesmos, torna- se, cada vez mais, indispensável avaliar o desempenho destes e evitar surpresas em tempo de implantação, quando o software já foi concebido.
As avaliações de desempenho mais comuns, hoje, feitas são:
Testes de desempenho, o que ocorre após a codi' cação do software e simulações, que geralmente implicam num grande custo.
Uma alternativa não tão custosa, como simulações, e que pode ser feita nas fases iniciais do desenvolvimento de um software, e nem tão exploradas hoje em dia são os métodos analíticos.
Os métodos mais conhecidos são redes de filas de espera, redes de autômatos Estocásticos, cadeias de Markov.
Estes métodos utilizam- se de um modelo, que deve seguir as regras definidas em cada metodologia.
Em o desenvolvimento de um software, geralmente, é criado um modelo de especi' cação que será utilizado como base para a implementação e implantação do mesmo.
No caso de os orientados a objetos, os modelos são criados em UML que é a linguagem padrão de modelagem de softwares orientados a objeto, criada por Ivar Jacobson, James Rumbaugh e Grandy Booch, e aceita por a OMG.
Os modelos em UML contêm detalhes sobre a estrutura lógica do software (com representação de classes, métodos e seus relacionamentos), estrutura comportamental do usuário (com a modelagem de atores e casos de uso) e de estrutura física de implantação do sistema (nós e suas relações).
As informações compreendidas no modelo UML descrevem minúcias que podem ser utilizadas para criar modelos de avaliação de desempenho, como o relacionamento entre as classes e métodos, evitando a criação de um segundo modelo matemático, a'm de avaliar o desempenho por um método analítico, para o mesmo software.
Existem alguns métodos que utilizam esta ideologia e produzem modelos de avaliação de desempenho baseados nas informações contidas nos modelos em UML.
Entre estes métodos, o apresentado por Cortellessa e Mirandola se destaca por utilizar- se dos principais diagramas que abrangem o comportamento, estrutura lógica e física para gerar um modelo de avaliação de desempenho em redes de «filas de espera.
Em este trabalho, os autores propõem que sejam utilizados os diagramas de casos de uso e seqüência para gerar dados e o diagrama de implantação para gerar a estrutura do modelo de avaliação de desempenho.
Sua principal contribuição é a avaliação do desempenho em diferentes arquiteturas físicas (máquinas e suas ligações), pois a estrutura da rede de «filas de espera representa o hardware e a estrutura de rede que o liga.
O método de Cortellesa e Mirandola é bem e &quot;ciente para avaliar o desempenho do hardware e a necessidade de modi «carmos sua estrutura.
Porém, a arquitetura de software, 1 descrita por as estruturas lógicas do UML, também pode in3uenciar o desempenho do software.
Se os diagramas de seqüência, além de gerarem dados, forem utilizados para a criação da estruturas, há a possibilidade de se avaliar, também, o desempenho das estruturas lógicas.
Com isso, poderá- se- obter dados para decidir por uma arquitetura de software ou outra, e mesmo veri «car eventuais problemas de desempenho em arquiteturas de software.
A avaliação desta arquitetura facilita a revisão de estruturas de componente, pois deixa mais claras, ao analista do sistema, as potênciais chamadas a possuírem piores desempenhos e corrobora as decisões acertadas na estruturação dos componentes.
Em o método de Cortellessa e Mirandola, não há a preocupação em avaliar a estrutura lógica, a arquitetura de software é, somente, utilizada para gerar um execution graph (EG) 2 e a partir deste são extraídos dados para a rede de «filas de espera.
Um EG, no trabalho de eles, representa as seqüências de chamadas de métodos de um sistema, o qual por conseqüência representa a arquitetura lógica do software.
Portanto, o EG pode ser utilizado como base para representar as arquiteturas software.
Se for considerado que cada chamada de método representa um estado do sistema e cada nodo do EG representa uma chamada, neste caso o EG representa os estados do sistema.
Com esta abordagem o EG pode ser facilmente convertido num autômato de estados «nitos e adicionado a uma rede de autômatos estocásticos (Stochastic Automata Network -- SAN), e por conseqüência ser utilizado para avaliar o desempenho do software e dos detalhes de sua arquitetura lógica.
Para representar a arquitetura lógica de um software orientado a objetos, este trabalho propõe uma técnica de conversão de UML para SAN, onde serão utilizadas as estruturas 1 Arquitetura de software ou lógica neste trabalho representa a estrutura de classes e métodos que compõem um software.
Não representando estruturas físicas, como máquinas e redes.
Estas últimas sendo denominadas da Arquitetura do Sistema ou Física 2 os detalhes da notação do EG não serão demonstrados neste trabalho.
Estes detalhes podem ser obtidos nos trabalhos de Smith e de Cortellesa e Mirandola básicas do método de Cortellessa e Mirandola, gerando um resultado em SAN e não em Rede de Fifilas de espera.
Em a Sessão 2, serão detalhados a linguagem de modelagem UML, o método de Cortellesa e Mirandola e o método de Redes de Autômatos Estocásticos.
Em a Sessão 3, será apresentada a técnica proposta para a geração de uma SAN a partir de um modelo UML utilizando um exemplo) ctício de uma agência bancária.
Em a sessão 4, será apresentada uma breve veri) cação do método, através de um estudo de caso, com exemplos de alguns casos de uso de um sistema.
Em a Sessão 5, serão apresentadas as conclusões deste trabalho e os trabalhos futuros visionados.
Fundamentação Teórica A linguagem de modelagem de software UML foi especicado por Grandy Booch, James Rumbaugh e Ivar Jacobson baseada em metodologias existentes, são elas Object-Oriented Software Engineering -- OOSE, Object Modeling Technique -- OMT e Booch.
Esta linguagem foi aceita por a OMG (Object Management Group) como padrão para modelagem de software.
A UML procura unicar as vantagens de cada um das metodologias e apresenta inovações como novos diagramas, e na forma de como descrever o software atráves de várias visões ou níveis de abstração diferentes:
Comportamental, lógico e físico.
Cada visão pode ser projetada na fase mais adequada do desenvolvimento de software, enriquecendo assim o modelo ao longo de o projeto de software.
Um mesmo diagrama pode ser usado em diferentes visões e assim representar, em mais ou menos, detalhes as regras de negócio, a implementação e a implantação do software.
A UML dene nove tipos de diagramas:
Diagrama de casos de uso, de seqüência, de atividades, de estados, de classes, de objetos, de implantação, de colaboração e de componentes.
Para montar um modelo de avaliação de desempenho, este trabalho utiliza informações de apenas três deste conjunto de diagramas, os quais representam os níveis de abstração comportamental, lógico e físico e são eles:
Os diagramas de casos de uso, seqüência e de implantação.
Por este motivo somente esses serão denidos.
A denição dos demais diagramas, assim como os detalhes da modelagem em UML, podem ser encontrados em &quot;UML Guia do Usuário».
Em a modelagem comportamental de um software são descritas suas funcionalidades e as relações com elementos externos, na forma de casos de uso e atores.
Em esta modelagem, os principais elementos e diagramas utilizados são os casos de uso, atores, diagramas de casos de uso, digramas de estado e atividades.
Conforme mencionado anteriormente, apenas o diagrama de casos de uso e os elementos casos de uso e atores serão utilizados neste trabalho e, portanto, apenas estes serão descritos em detalhes.
Os atores modelam elementos externos ao sistema, os quais interagem com este.
Um ator pode representar uma pessoa, um outro sistema, ou um hardware.
Estes representam tudo o que troca informações, ou seja, entrada e saída de dados e estímulos.
Eles modelam os diferentes papéis assumidos por os usuários, que o compõem.
Um caso de uso é uma descrição de um conjunto de seqüências de ações executadas por um sistema para produzir um resultado de valor para um ator.
Um caso de uso, geralmente, é formado por:
Um nome:
É uma seqüência alfanumérico que é único no modelo.
Objetivo: É uma descrição textual da funcionalidade, que o caso de uso representa.
Pré-condições: São requisitos que devem ser satisfeitos antes da execução da funcional-idade do sistema, a qual o caso de uso representa.
Podem não existir pré-condições num caso de uso.
Pós-condições: São condições válidas após a execução da funcionalidade, a qual o caso de uso representa.
Fluxos de Execução:
Um fluxo de execução é uma seqüência de passos, descritos textualmente, que devem ser executados para se atingir o objetivo do caso de uso.
Um mesmo caso de uso pode possuir mais de um fluxo de execução, que descreve a funcionalidade que representa.
Estes são chamados fluxos alternativos.
O caso de uso pode conter, ainda, informações adicionais como, por exemplo, as exceções a serem tratadas.
Estas informações podem ser adicionadas em formas de novos elementos do caso de uso.
Um diagrama de casos de uso é a estrutura onde estão representados, gracamente, casos de uso, atores e as relações entre eles.
Podem existir relações entre casos de uso e atores, atores com atores ou casos de uso com casos de uso.
As relações entre caso de uso e ator são chamadas de associação.
As relações entre casos de uso pode ser de três tipos:
Inclusão, extensão e generalização.
Existe, ainda neste diagrama, a relação entre atores chamada generalização ou especialização.
A modelagem lógica em UML representa a estrutura em termos de classes, objetos e seus relacionamentos, agrupados em diagramas de classes, objetos e seqüências.
Uma classe é uma descrição de um conjunto de objetos que compartilham os mesmos atributos, operações, relacionamentos e semântica.
Diagramas de seqüência representam a relação entre classe, objetos e atores.
Estes diagramas podem ser utilizados em diversas partes do modelo UML representando diferentes visões.
Em a visão (ou modelagem) lógica, os diagramas de seqüência modelam as chamadas de métodos entre as classes, objetos e atores.
Cada chamada representa um método de uma classe ou objeto.
Estes métodos, na modelagem lógica são os mesmos implementados na linguagem de orientação a objeto alvo deste software.
Em a modelagem da arquitetura, são denidos sicamente como o software sendo modelado, estará disposto em termos de componentes do mesmo e sua distribuição em servidores e máquinas cliente.
Um nó é um elemento físico que existe em tempo de execução e representa um recurso Um componente é a parte física de um sistema, o qual se adapta e fornece a realização de um conjunto de interfaces.
Componentes representam bibliotecas, pacotes, etc, pertencentes ao sistema.
Os componentes são a realização física das abstrações lógicas representadas por classes.
Em a avaliação de desempenho, estes serão utilizados para identificar quais classes deverão ser executas e em quais nós do sistema.
Os diagramas de implantação são formados por nós e as ligações entre eles.
Este demonstra a arquitetura física do sistema, provendo informações de ligações existentes entre os nós.
Além disso, demonstra a relação entre componentes e os nós.
Em a Figura 2.1 são demonstrados os diagramas de Use Case, Seqüência e Componentes para um software de um microprocessador, que faz a leitura da temperatura de uma fornalha, através de um sensor e repassa esta a um controlador.
O método aqui apresentado está dividido em cinco passos que serão detalhados nas próximas seções deste capítulo:
Obter o Perl dos Usuários do Sistema:
Onde são associados dados probabilísticos, que identi (cam as chances de um usuário acessando o sistema ser de um determinado tipo e, também, as chances de cada funcionalidade do sistema (use case) ser executada.
Obter as linhas de execução do sistema (EG):
Neste passo, os diagramas de seqüência são analisados para se obter as possíveis linhas de execução do sistema e estas são representadas num Execution Graph.
Tipicamente, existirá uma linha de execução, saindo do nodo Init (nodo inicial do execution graph), para cada use case, já que os diversos diagramas de seqüência da mesma use case, na maioria das vezes, diferem em apenas algumas chamadas uns dos outros, como por exemplo, nas situações de falha de autenticação, onde a mudança ocorre, somente, no resultado apresentado.
Construir a topologia da Rede de Fifilas de espera:
O diagrama de deployement representa o hardware a ser utilizado para rodar a aplicação.
E, é deste que são obtidas as.
Las e as conexões entre elas da rede de.
La de espera.
Assinalar os tempos de processamento ao EG:
Em os passos anteriores, foram criadas as estruturas do EG e da rede de.
Filas de espera, neste devem ser assinalados os dados de tempo de comunicação das transferências de controle entre os módulos.
Resolver o EG e assinalar os valores obtidos a Rede de filas de espera:
O último passo, antes da resolução da rede de.
Filas de espera, é a obtenção dos dados de tempo de serviço das.
Las e comportamento dos clientes (dados dos terminais).
Estes são extraídos do execution graph.
O per.
L de um usuário, mencionado neste trabalho está relacionado a de.
Nição de quais são as probabilidades de um usuário ser de um tipo especí.
Com o (ator) ao utilizar o software e as probabilidades de ele acessar cada funcionalidade do sistema.
As relações entre o sistema e seus usuários são expressas por o diagrama de use cases.
Portanto, este é o diagrama onde os valores probabilísticos devem ser relacionados com funcionalidades (use cases), e usuários (atores).
Este passo do método consiste em obter estas probabilidades e enriquecer o diagrama de use cases com as mesmas.
As probabilidades dos tipos de usuários acessarem o sistema, ou seja, de um usuário acessando o sistema ser de um tipo, serão assinaladas aos atores do diagrama de use cases.
Sendo o número de atores no sistema A. P é a probabilidade do ator ser o usuário que está acessando o sistema.
O somatório de todas probabilidades p deve ser 1, ou seja, as probabilidades dos atores devem estar normalizadas.
Para cada ator no diagrama de i use cases existirá uma probabilidade Pij deste ator i acessar a funcionalidade contida na use case, caso não haja uma relação entre ator e use case, esta probabilidade é zero, mas caso haja o diagrama de use cases deverá ser enriquecido com estas probabilidades.
Sendo o número de u use cases do sistema, o somatório da probabilidades Pij, sendo j $ , é igual a 1, para um mesmo ator i, em outras palavras, estas probabilidades devem estar normalizadas para cada ator.
Em a Figura 2.2 podem ser observado um diagrama de use cases enriquecido com as probabilidades.
Ao lado de o ator, está a probabilidade do mesmo acessar o sistema.
Como ele é um ator único no sistema recebe a probabilidade igual a 1.
Em os arcos estão representadas as probabilidades do ator acessar as use cases com que se relaciona.
Como estes valores no diagrama de use cases pode- se obter, agora, a probabilidade consolidada de uma funcionalidade (use Case) ser executada (considerando todos os atores que a acessam), ou seja, vericar qual a chance de uma funcionalidade ser acessada, quando um usuário qualquer utilizar o sistema.
Essa probabilidade é calculada através do somatório das probabilidades dos i atores (p (i)), sendo i $= 1 até A, multiplicado por a probabilidade deste iésimo ator acessar a use case x (P (ix)).
Um execution graphs, como já mencionado, representa as diferentes linhas de execução de um sistema.
Neste passo, serão obtidas estas linhas, para tanto, serão utilizados os diagramas de seqüência, que expressam exatamente as relações entre as chamadas aos componentes do sistema.
Foi denido num algoritmo para montar a estrutura de um execution graph a partir de os diagramas de seqüência do UML.
O algoritmo cria um nodo de inicial chamado Init que é um nodo de laço de onde todas as linhas de execução do sistema partem.
Cada diagrama de seqüência irá contribuir com parte do EG, portanto para cada diagrama de seqüência o algoritmo irá avaliar as chamadas entre os elementos do sistema e transformar- las num nodo básico do execution graph.
Cada nodo básico será identicado por uma tupla, onde l é o nome da transação, A1 é o componente de origem da transação e A2 é componente de destino da mesma.
Existirá, ainda, um tupla que expressa o retorno de controle para o elemento A1.
Os diagramas de seqüência podem possuir dois tipos de transações:
As simples, onde apenas uma chamada é feita e um retorno é esperado e as múltiplas, onde mais de uma chamadas é realizada e então é aguardado o retorno das mesmas para continuar o processamento no componente de origem.
O algoritmo, em questão, é demonstrado na apêndice A. Em a primeira etapa do algoritmo 1 são considerados os nodos que ainda não foram traduzidos, ou seja ainda não apareceram em nenhum diagrama de seqüência já avaliado.
Em este caso deve ser avaliado se a transação é múltipla ou simples.
Caso seja uma transação simples é avaliado se existe uma conexão em aberto no EG, onde este novo nodo seria o próximo de a linha de execução.
Se existir, conecta- se a mesma ao novo nodo simples.
Caso não exista conexão em aberto, a única possibilidade é de uma seleção num linha de execução (uma nova sub linha de execução será criada).
No caso de novas chamadas múltiplas, o algoritmo se comporta de maneira semelhante ao caso da simples, com um principal ponto a ser adicionado que é os nodos de fork e join como A o nal do algoritmo, a topologia do Execution Graphs estará completa.
Em os passos a seguir, serão descritas as formas de se obter dados do mesmo e obter a estrutura da rede de filas de espera.
Após utilizar as informações dos diagramas de casos de uso e de seqüência nos passos anteriores chega o momento de extrair os dados do diagrama de implantação.
As informações retiradas deste diagrama são a topologia da rede de filas de espera e os dados de comunicação.
A topologia da rede de filas de espera é nada mais que a representação do hardware em filas de espera.
Os dados de comunicação serão tratados na seção 2.2.4.
A obtenção é relativamente simples, pois cada uma das unidades de processamento ou de armazenamento existentes no diagrama de implantação, e utilizadas por o sistema são mapeadas para uma la de espera que irá integrar a rede.
O caminho entre as las é determinado por as conexões do hardware no diagrama de deployment.
Se estas forem redes de computadores devem ser adicionados elementos delay na conexão, que representam o atraso provocado por a estrutura de rede de computadores entre os processadores (latência).
A topologia pode sofrer alguns ajustes, que são determinados de forma empírica por o projetista para melhor representar o hardware.
Por este mapeamento ser muito simples, ca facilitada a avaliação de outras estruturas de hardware para o mesmo sistema, bastando apenas criar- se novos diagramas de implantação.
Em a Figura 2.3 é demonstrado um diagrama de implantação a sua tradução, para uma rede de filas de espera.
Após gerar a topologia da rede de filas de espera o diagrama de implantação, também, fornece informações para preencher dados no EG.
Estes dados são os tempos médios gastos em comunicação e processamento de cada transação dos diagramas de seqüência (cada nodo básico do EG).
Para cada nodo básico será adicionado um tempo de comunicação e processamento que leva em conta o local físico onde cada componente envolvido na chamada está.
Se um componente X faz uma chamada a um componente Y no mesmo computador, o tempo de chamada é menor do que o mesmo componente X chamar um componente Z num computador remoto.
O diagrama de implantação vai auxiliar exatamente na denição dos tempos de cada chamada.
Os tempos em si são valores que o projetista terá que obter ou estimar.
Após assinalados os tempo de processamento devem ser agora assinaladas a probabilidades de cada linha de execução ocorrer.
Se cada linha de execução equivale a um diagrama de seqüência de uma use case pode- se, então, utilizar os dados probabilísticos obtidos no passo 1, para se obter as probabilidade de cada diagrama de seqüência ser executado.
Em o passo 1 foram identicadas as probabilidades consolidadas de cada caso de uso.
Para se obter as probabilidade de cada diagrama de seqüência o projetista deve avaliar a freqüência com que cada diagrama de seqüência ocorre no caso de uso.
Se essa freqüência for normalizada, dentro de um mesmo caso de uso, e assim conter valor onde sua soma seja 1, pode- se armar que, esta é a probabilidade do diagrama de seqüência ser executado quando a use case for executada.
A probabilidade consolidada de cada diagrama de seqüência será, então, a probabilidade consolidada da use case, obtida no passo 1, multiplicada por a freqüência normalizada (probabilidade) do diagrama de seqüência, recém assinalada.
Para assinalar estes valores ao EG deve- se observar, que os diagrama de seqüência de um mesmo caso de uso tem nodos básicos em comum nas linhas de execução, porém em algum ponto da linha de execução haverá uma seleção e é neste ponto onde serão assinaladas as probabilidade dos diagramas de seqüência.
Após assinaladas todas as probabilidades aos nodos de seleção, para cada nodo de seleção deve- se normalizar as probabilidades, para que se tenham de fato, probabilidades de um caminho ou os outros.
O ponto crítico a ser observado, nas seleções, é a seleção logo seguir do nodo Init, como haverão linhas que tem execuções iniciais em comum a probabilidade, que deve ser assinal ada a cada linha deste nodo de seleção, é o somatório da probabilidades consolidadas dos diagramas de seqüência que seguirão seu uxo por o ramo da seleção, e como mencionado no parágrafo anterior, nos próximos nodos de seleção esta probabilidade será novamente rami!
Cada e normalizada.
Com o Execution Graph podem- se obter, neste momento, os dados de tempo médio de serviço de cada fila da Rede de Filas de espera.
Para tanto o Execution Graph deve ser resolvido.
A resolução de execution graphs apresentada aqui pode ser encontrada em e consiste em verficar a ocupação de cada recurso (fila da rede de filas) por cada nodo básico do EG e somar- las ponderando os totais com as probabilidades de cada linha de execução (nodo de seleção), como será descrito a seguir.
O primeiro passo na resolução do EG é a criação de uma tabela, que contém a relação entre os nodos básicos e a ocupação de tempo de cada recurso modelado como uma fila na topologia da rede de filas de espera obtida no passo 2.2.3.
Note, que existirão nodos que utilizarão apenas alguns recursos, neste caso os tempos dos recursos não utilizados são zerados.
Em a Figura 2.4 pode- se observar um execution graph simples e a tabela de tempos relacionados a ele.
Com esta tabela, agora, deve- se percorrer os nodos básico de cada linha de execução, partindo do último nodo básico da linha, que é exatamente o nodo que conecta- se ao nodo Init, em direção a o nodo pai, o que passa o controle ao nodo atual, somando os valores de cada recurso na tabela, até chegar a um nodo de seleção, onde o somatório será ponderado ou ao nodo Init onde os valores estarão!
Namente calculados.
Quando é encontrado um nodo de seleção deve- se calcular todos os demais ramos da seleção antes de continuar, pois nestes pontos os valores de cada ramo são multiplicados por a probabilidade do ramo, o que gera um valor médio de ocupação dos recursos em todos os ramos da seleção.
O nodo Init contém todos os pontos de saída das linhas de execução, e portanto quando as iterações o alcançarem o somatório estará concluído chegando aos valores de taxa de serviço para cada fila da rede de filas de espera.
Assim são obtidos os tempos médios de serviço.
Os valores de delay e dos terminais são obtidos também EG e são exatamente os valores adicionados no passo anterior com atrasos provocados por a comunicação, com exceção do número de clientes dos terminais, onde este deve ser estimado por o projetista.
Em o exemplo da Figura 2.4 a taxa de serviço da única la da rede que representará o microprocessador teria um tempo de serviço média de 0.35 ms..
As taxas dos terminais (freqüência em que o usuário acessa) estimada por o projetista é 1 ms que é exatamente o valor do nodo logo a seguir do Init e o último nodo antes do retorno ao Init, que se for observado no diagrama de seqüência da Figura 2.1 são exatamente as iterações com o Sistema Controlador (usuário do sistema).
Em este caso o número de clientes dos terminais deve ser considerado igual a 1, pois só existe um sistema controlador.
Redes de Autômatos Estocásticos (SAN) é um formalismo baseado em cadeias de Markov.
O formalismo de SAN é capaz de modelar diversos problemas, e através dessa modelagem obter índices de desempenho sobre os mesmos.
Uma Rede de Autômatos Estocásticos é composta por um conjunto de autômatos que possuem dependências entre si.
Cada autômato é composto por um conjunto de estados e transições.
A composição dos estados locais de cada autômato da rede dene a corrente situação da rede, também chamado de estado global da rede.
Cada autômato da rede estará num e apenas um estado.
Transições denem a mudança de um estado para outro.
Uma transição é disparada por a ocorrência de um evento.
Os eventos podem ser de dois tipos:
Locais ou sincronizantes.
Os eventos locais afetam apenas o estado de um autômato da rede.
Os eventos sincronizantes sincronizam autômatos da rede, isto é, afetam estados de dois ou mais autômatos da rede.
Um evento sincronizante só pode acontecer, quando todos os autômatos envolvidos com este evento estiverem num estado de onde o evento possa ser disparado.
Cada evento tem associado uma taxa, em escala de tempo contínua, ou uma probabilidade em escala de tempo discreta.
Estas taxas ou probabilidades podem ser funcionais ou constantes.
As taxas e probabilidades funcionais são de&amp; nidas por uma função (que depende dos demais autômatos da rede), ou seja, a taxa varia conforme a situação em que a rede se encontra.
Um evento pode ser associado a duas ou mais transições partindo de um mesmo estado.
Em este caso, deve- se associar uma probabilidade de rotação ao par (evento, transição).
Se apenas um caminho é possível, a probabilidade de rotação é igual a 1.0 e pode ser omitida.
Uma SAN possui um conjunto de estados globais, onde cada estado global equivale a uma combinação de estados locais dos autômatos da rede.
Supondo que S (i) seja o conjunto de estados locais do autômato A(, o conjunto de estados globais de uma rede composta por N i) autômatos A(, onde i é dado por o produto cartesiano dos espaços de estados S(, ou i) seja:
S(. Porém, devido as taxas funcionais e eventos sincronizantes, alguns dos estados i) globais podem não ser atingíveis, por isso, define- se um subconjunto dos estados globais como atingíveis.
Em a Figura 2.5, pode- se observar um exemplo de uma SAN com dois autômatos.
O autômato A possui os estados 'a',' b` e'c` e o autômato A que possui os estados' x` e'y'.
Os eventos nesta rede são os seguintes:
e1, e2 e e3, eventos locais envolvendo somente A com taxas constantes 1, 2 e 3;
e4, um evento sincronizante envolvendo A e A, com um taxa constante 4;
e5, evento local envolvendo A com uma taxa funcional f:
Quando o evento e4 acontece com a taxa 4 existe uma probabilidade no autômato A de ocorrer a transição do estado c para o estado b, e uma probabilidade de ocorrer a transição do estado c para o estado a..
Redes de autômatos estocásticos é um formalismo de grande poder de representação e simples de ser construído, por não ser um único sistema, mas sim um conjunto de subsistemas que podem ou não possuir dependências entre si.
Metodologia A técnica aqui apresentada é baseada no método de conversão de UML para QN.
Em este método é utilizada uma estrutura intermediária chamada execution graph e um processo chamado Software Performance Engineering para resolver- la e gerar valores numéricos para a QN.
Em a técnica de conversão de UML para SAN aqui apresentada a estrutura EG será montada da mesma forma, que no método de conversão de UML para QN, porém sua finalidade é diferente.
O EG será utilizado para a criação de autômatos que compõem a SAN resultante.
A conversão de UML para SAN se dará por dez passos.
Alguns de eles serão total ou parcialmente reutilizados da conversão de UML para QN que são os casos da Obtenção de o Per+ l dos Usuários, Obtenção das Linhas de Execução e Adição dos Tempos de Processamento ao EG.
Os demais 7 passos adaptam o EG e o UML para a conversão específica para o formalismo SAN.
Em a próxima sessão, serão apresentadas as restrições com relação a a modelagem UML e com relação a a SAN gerada por esta técnica.
Em seguida, será apresentada uma modelagem hipotética obtida em, a qual será utilizada para exemplificar a técnica ao longo de seus passos.
Para a aplicação da conversão de UML para SAN a modelagem UML deverá seguir algumas regras e restrições descritas a seguir.
Em a modelagem comportamental, a primeira restrição que é com relação a generalização de atores.
O tratamento da generalização de atores não será demonstrada nesta técnica, e portanto não deve ser utilizadas para que se possa avaliar o desempenho com a técnica apresentado a seguir.
A generalização pode ser substituída por a inserção das relações entre o ator especialista e os casos de uso ligados ao ator generalista.
Em a modelagem lógica, os diagramas de seqüência deverão possuir apenas chamadas síncronas, pois chamadas assíncronas podem gerar EGs desconexos.
Ainda na construção dos diagramas de seqüência, algumas regras deverão ser seguidas no projeto destes diagramas.
Este é o caso dos casos de uso incluídos, estendidos e especialistas para que estes gerem EG com coerentes.
As seqüências dos casos de uso incluídos não deverão ser criados como diagramas de seqüência em separado, mas deverão ser inclusos nos diagramas de seqüência dos casos de uso base.
Assim, estes serão traduzidos em EG como parte constante dos casos de uso base inseridos em cada contexto dos mesmos.
Os diagramas de seqüência dos casos de uso estendidos deverão conter todo o cenário onde este se inserem, ou seja, deverão estar contidos nas interações dos diagramas de seqüência dos casos de uso base nos devidos pontos de extensão.
Se este caso de uso for estendido por mais de um caso de uso, cada diagrama de cada caso de uso que o estende, deve conter seus fluxos representados nos devidos diagramas de seqüência.
No caso de a generalização de casos de uso os diagramas de seqüência dos casos de uso especialistas, assim como na extensão, deverão conter interações dos diagramas de seqüência do casos de uso geral.
Assim, o caso de uso geral não possuirá um diagrama de seqüência, pois seus fluxos já estarão representados nos diagramas dos especialistas.
Em a modelagem física ou de implantação existe uma restrição com relação a os nós do diagrama de implantação.
Os nós, como máquinas clientes, na realidade não são apenas um recurso, mas um conjunto de recursos que, individualmente, podem gerar gargalos.
Em a técnica exposta estes serão representados apenas com dois estados, ocupado ou livre.
Considera- se a existência de apenas um recurso físico (conjunto processador e memória) para cada nó do diagrama de implantação, desconsiderando máquina multi processadas.
Para representar um nó multi-processado, o projetista do sistema deverá considerar o tempo compartilhado entre os processadores no cálculo dos tempos gastos por cada chamada neste tipo de recurso.
Com relação a os modelos SAN gerados por esta técnica podem haver limitações na capacidade de processamento devido a a quantidade de estados globais geradas.
A resolução SAN gerada por esta técnica está restrita aos recursos de hardware (processador e memória) disponíveis.
Não está no escopo deste trabalho um estudo em relação a esta limitação, porém sabe- se da existência desta limitação nas ferramentas de análise de modelos SAN.
A conseqüência disso poderá ser notada em arquiteturas lógicas e físicas muito complexas, pois estas podem gerar autômatos com muitos estados, gerando com isso muitos estados globais.
Para ilustrar os passos da metodologia será utilizado um exemplo de um sistema bancário.
Este sistema é um exemplo acadêmico simples, que será utilizado para exemplifica a técnica.
Este exemplo foi retirado da página da disciplina de Me o delagem Conceitual de Sistemas.
O diagrama de casos de uso é composto por 3 atores e 8 casos de uso.
Em a Figura 3.1 está a representação grá) ca do mesmo e a seguir está a descrição de cada caso de uso.
Caso de uso:
Sacar dinheiro Atores:
Cliente Pré-Condições:
O Cliente possui cartão do banco e senha cadastrada.
Pós-condições: Lançada a transação na conta do Cliente, atualizado o saldo da conta corrente e liberado o dinheiro.
Seqüência Básica: Este caso de uso começa quando o Cliente realiza a leitura do cartão do banco, no caixa eletrônico.
O Cliente informa a sua senha.
Include Validar Conta. O sistema autoriza o saque e lança o débito na conta corrente do Cliente.
O sistema libera o dinheiro.
Seqüência Alternativa: Fundos Insu0cientes:
O sistema não autoriza o valor solicitado para saque por o Cliente.
A operação é cancelada.
Caso de Uso:
Validar conta Atores:
Pré-Condições: Pós-condições:
Seqüência Básica:
O sistema valida a conta corrente e senha do Cliente, autorizando a operação.
Seqüência Alternativa: Cliente Inválido O sistema não reconhece a conta corrente e senha do Cliente como válida.
A operação é cancelada.
Caso de Uso:
Autorizar saque Atores:
Gerente Pré-Condições:
Pós-condições: Seqüência Básica:
O Gerente consulta informações da conta corrente de um cliente para deli-berar sobre a liberação de saque em valor elevado.
O sistema apresenta as informações sobre o cliente e suas movimentações bancárias.
O Gerente autoriza o saque no valor solicitado.
Seqüência Alternativa: Saque não autorizado O Gerente não autoriza o saque no valor solicitado.
O Sistema cancela a operação.
Caso de uso:
Consultar Saldo Atores:
Cliente Pré-Condições:
O Cliente possui cartão do banco e senha cadastrada.
Pós-condições: Seqüência Básica:
Este caso de uso começa quando o Cliente realiza a leitura do cartão do banco no caixa eletrônico.
O Cliente informa a sua senha.
Include Validar Conta. O Sistema Informa o Saldo.
Caso de uso:
Receber Pagamento Atores:
Caixa Pré-Condições:
O Caixa é identicado e autenticado.
Pós-condições: O pagamento recebido é registrado no sistema associado ao Caixa.
Seqüência Básica: Seção Principal Este caso de uso começa quando o Caixa registra o documento de cobrança bancária a ser pago.
O sistema valida a aceitação do documento de cobrança a ser pago.
O Caixa informa a opção desejada:
Se for pagamento em dinheiro, ver subseção Receber pagamento em di-nheiro.
Se for pagamento em cheque, ver subseção Receber pagamento em cheque.
O sistema registra o pagamento.
O sistema imprime o comprovante.
Subseção: Receber pagamento em cheque O Caixa recebe o cheque e o registra no sistema.
O sistema valida os dados do cheque.
Subseção: Receber pagamento em dinheiro O Caixa registra o valor em dinheiro recebido.
O sistema informa o troco a ser repassado ao pagante.
Caso de uso:
Depositar Dinheiro Atores:
Caixa Pré-Condições:
Pós-condições: Seqüência Básica:
Este caso de uso inicia quando um Caixa irá fazer um depósito em dinheiro numa conta de um cliente.
O Caixa informa a conta alvo.
Include Validar Conta. O Caixa informa a quantia a ser depositada.
O sistema deposita e imprime o comprovante.
O projeto das classes foi resumido ao diagrama de classes demonstrado na Figura 3.22.
As Classes de Conta e RealizaPgto são responsáveis por todo o processamento de servidor.
As classes iniciadas por telas são as classes que representam a interface com o usuário.
Este modelo foi criado com estruturas simples não utilizando nenhum padrão de projeto, a fim de produzir diagramas de seqüência pequenos e por conseqüência produzir um EG não muito extenso para a condução dos passos da conversão de UML para SAN apresentados nas próximas seções.
A complexidade da arquitetura lógica (modelo de classes) pode determinar produzir um EG com muitos nodos o que pode gerar uma SAN com muitos estados e inviabilizar a resolução da SAN.
A quantidade máxima de estados globais resolvíveis é dependente do hardware em o qual se está rodando o software de re-solução de SAN, como já mencionado na seção de restrições.
Os diagramas de seqüência gerados para implementar os casos de uso descritos no diagrama de casos de uso da Figura 3.1 são demonstrados em asguras a seguir.
Para a implementação do caso de uso UC1 -- Sacar Dinheiro foram criados três diagramas de seqüência:
A básica com a seqüência de sucesso;
A alternativa onde trata o caso de saldo não suficiente;
E a alternativa 2 com a falha, vinda de caso e uso incluído, na validação da conta.
Estes estão representados nas Figuras 3.3, 3.4 e 3.5 respectivamente.
Note que, conforme descrito nas restrições, as seqüências do caso de uso UC2 incluído foram adicionados nos diagramas de seqüência do caso de uso UC1.
O diagrama de classes não será utilizado na conversão de UML para SAN.
Este apresentado aqui apenas para melhor ilustrar o exemplo do sistema bancário.
Para implementar o caso de uso UC3 -- Autorizar Saque foram gerados dois diagramas de seqüência demonstrados nas Figuras 3.6 e 3.7.
O processo do banco para a autorização de saques com valor maior que 1000 assume, que sempre haverá um gerente disponível no terminal de saque para autorizar, de forma online, o saque.
Para o caso de uso UC4 -- Consultar Saldo foram gerados dois diagramas de seqüência demonstrados nas Figuras 3.8 e 3.9.
O diagrama de seqüência alternativo foi resultado da inclusão do caso de uso UC2 -- Validar Conta, assim como no caso de uso UC1 -- Sacar Dinheiro.
Para os casos de uso UC5 -- Receber Pagamento, UC5.
1 -- Receber Pagamento em Cheque e UC5.
2 -- Receber Pagamento em Dinheiro foram criados dois diagramas de seqüência, um para cada especialista.
Estes são encontrados nas Figuras 3.10 e 3.11 respectivamente.
A seqüência do caso de uso geral UC5 foi inserida nos diagramas de seqüência dos especialistas, conforme descrito nas restrições.
Para o caso de uso UC6 -- Depositar Dinheiro foram gerados dois diagramas de seqüência demonstrados nas Figuras 3.12 e 3.13.
O diagrama de seqüência alternativa foi resultado da inclusão do caso de uso UC2 -- Validar Conta, assim como no caso de uso UC1 -- Sacar Dinheiro e UC4 -- Consultar Saldo.
O sistema será implantado numa arquitetura física bem simples, composta por um terminal de atendimento e um servidor.
Estes nós são interligados por uma rede.
O diagrama de implantação com esta arquitetura é demonstrado na Figura 3.14.
Em este exemplo, existem dois componentes:
InterfaceUsuario, o qual contem todas as classes que começam por Tela e o componente ControladorBanco que contêm as classes Conta e RealizaPgto.
O componente InterfaceUsuario será implantado no nó Terminal, já o ControladorBanco será implantado no nó Servidor.
Cheque Em a avaliação do desempenho de um software, o comportamento do usuário é um fator de extrema importância, pois com este é possível focar em gargalos do sistema, onde realmente os usuários, do mesmo, irão utilizar- lo com mais freqüência.
Em UML, o comportamento dos usuários do sistema está demonstrado nas relações entre atores e casos de uso, no diagrama de casos de uso.
Em este, estão descritas todas as possíveis funcionalidades, representadas por os casos de uso, que os usuários, representados por atores, podem executar.
Porém, não estão especicadas quais as funcionalidades com maiores chances de serem acessadas e por conseqüência maiores chances de provocarem problemas de desempenho no software.
Dinheiro Para determinar as chances de acesso a um módulo, assim como no método de conversão de UML para QN, faz- se necessária a adição de probabilidades ao diagrama de casos de uso para descrever o comportamento mais provável dos usuários diante de o sistema.
Em a metodologia apresentada por Cortellessa e Mirandola eram descritos dois conjuntos de probabilidades:
O de probabilidades de usuários serem determinados atores;
E o de atores acessarem casos de uso.
Com estes conjuntos de probabilidades pode- se determinar a probabilidade consolidada de cada caso de uso ser executado.
Para isso, basta somar- se as multiplicações das probabilidades associadas a cada ator, que a acessa por as probabilidades deste atores acessarem o caso de uso, conforme foi demonstrado no método de conversão de UML para QN.
Este método, porém, não se faz menção ao tratamento das relações entre casos de uso (inclusão, generalização e extensão) e nem a generalização de atores.
Com isso, a metodologia acaba restringindo certos casos muito comuns.
A, m de eliminar algumas destas restrições, e assim aumentar a abrangência da técnica aqui apresentada, será demonstrado, além de a conversão de UML para SAN, o tratamento da inclusão, da extensão e da generalização de casos de uso.
A generalização de atores não será tratada, cando assim como um trabalho futuro, que será listado nas considerações, nais.
A relação inclusão entre casos de uso se trata de uma relação, onde os 1 uxos do caso de uso incluso são adicionados aos 1 uxos do caso de uso que o inclui, utilizada para, ns de reutilização de 1 uxos de casos de uso.
Em este tipo de relação, não existe qualquer condição, para que as seqüências inclusas sejam executadas, o que faz com que os 1 uxos incluídos sejam executados, tantas vezes quanto o caso de uso base executar.
Portanto, não se faz necessária a adição de uma nova probabilidade para relações de inclusão, já que estas são executadas juntamente com o caso de uso base.
No caso de a extensão, a funcionalidade estendida só será executada caso uma condição, associada a mesma, seja verdadeira.
Com isso, entende- se que haverá uma probabilidade desta condição ser verdadeira.
Conseqüentemente, existirá, também, uma probabilidade complementar, desta condição ser falsa indicando assim, a não execução da funcionalidade contida no caso de uso estendido.
Assim, diferentemente da inclusão, na relação de extensão faz- se necessária a adição de probabilidades de execução diferente do caso de uso base.
Logo, existirá mais um conjunto de probabilidades que deve ser adicionado ao diagrama de casos de uso:
As probabilidades das extensões serem executadas.
Um caso de uso estendido pode também possuir outras ligações com outros casos de uso ou mesmo com atores.
Em este caso, a probabilidade consolidada vista no método de conversão de UML para QN e aqui também utilizada não é afetada por a probabilidade da condição.
Isso se deve, por que a condição está associada a apenas uma relação de extensão, ou seja, determinará quando os diagrama da seqüência do casos de uso estendido serão executados no caso de uso base.
Assim, afeta apenas a execução das seqüências do caso de uso base.
A última relação entre casos de uso, a generalização ou especialização, é composta por condições de execução para cada caso de uso especialista.
Estas condições são com plementares, ou seja, uma funcionalidade de um especialista sempre será executada quando o caso de uso geral for acessado por um ator.
Isso remete a adição de probabilidades de execução de cada caso de uso especialista e ainda, as somas das probabilidades de todos os especialistas deverão ser igual a 1, ou seja devem estar normalizadas.
Obtendo assim um quarto, e último, conjunto de probabilidades relacionadas as condições das generalizações, que devem ser de&amp; nidos por o analista.
Em o exemplo do sistema bancário, o diagrama de casos de uso com as probabilidades está representado na Figura 3.15.
Note que as regras de somas descritas no método de conversão de UML para QN estão sendo seguidas com exceção da probabilidade 0,15 associada à condição da extensão do caso de uso UC3.
Existe uma probabilidade implícita e igual a 0,85 da condição ser falsa e assim a funcionalidade da extensão não ser executada no caso de uso base.
Esta probabilidade será utilizada na adição das probabilidades aos nodos de branch que será vista nas próximas seções.
Este é o segundo passo do método de conversão de UML para QN apresentado por Cortellessa e Mirandola.
Em este, é criada a estrutura do EG, o qual representa todos os cenários do sistema, obtidos dos diagramas de seqüência.
Em o método de conversão de UML para QN, este EG é utilizado segundo a metodologia SPE.
Porém, na técnica de conversão de UML para SAN, aqui apresentada, esta metodologia não será utilizada, mas o EG servirá de base para a criação de autômatos pertencentes a SAN.
O algoritmo apresentado por Cortellessa e Mirandola não será alterado para incluir os casos de inclusão, extensão e generalização.
Para isso, estes casos de-verão ser modelados, conforme descrito na seção de restrições.
Este algoritmo está descrito no apêndice A. Em este algoritmo, cada interação de cada diagrama de seqüência é identificada como uma tupla onde l é o método chamado ou a resposta, A1 é a classe ou objeto de origem da chamada e A2 é a classe ou objeto alvo.
As seqüências de casos de uso incluídos deverão ser incluídas nos diagramas de seqüência dos casos de uso base.
Conseqüentemente, serão traduzidos em nodos do EG, junto com os diagramas de seqüência dos casos de uso base.
Conforme descrito na seção de restrições, os diagramas de seqüência dos casos de uso estendidos deverão incorporar todo o cenário, onde estes se inserem, ou seja, todas as interações do casos de uso base serão inclusas nos diagramas de seqüência do caso de uso estendido.
Com isso, os diagramas de seqüência do casos de uso estendido conterão chamadas em comum com os diagramas de seqüência do nodo base.
Como cada interação só é traduzida um vez, conforme o algoritmo de Cortellessa e Mirandola, isso produzirá um caminho em comum na tradução dos diagramas de seqüência do caso de uso base, com o caso de uso estendido, com um nodo branch, ou de seleção, no ponto de extensão.
Note que, ao final da extensão as interações também serão comuns fazendo com que o último nodo básico gerado por a extensão seja ligado, novamente, ao nodo imediatamente posterior ao ponto de extensão do caso de uso base.
O EG equivalente aos diagrams do caso de uso UC1 e aos diagramas do caso de uso estendido UC3 são demonstrados na Figura 3.16.
Note que, o as interações dos diagramas de seqüência que são comuns e foram adicionados nos diagramas de seqüência do caso de uso estendido foram traduzidos em nodos básicos formando um caminho em comum que foi destacado na Figura 3.16.
Em a generalização, assim como a extensão, os diagramas de seqüência deverão conter as interações dos diagramas de seqüência do caso de uso geral.
Isso também produzirá caminhos comuns entre os casos de uso especialistas e o geral com nodos branch no EG, onde haverão opções de caminho para cada especialista.
Em a Figura 3.17 é demonstrado a estrutura do EG gerado para os diagramas de seqüência dos casos de uso UC5.
1 e UC5.
2. Em o exemplo do sistema bancário a estrutura do EG gerado por este algoritmo será o apresentado na Figura 3.18.
As probabilidades inseridas no diagrama de caso de uso, no primeiro passo desta metodologia, serão utilizadas para determinar os caminhos mais prováveis no software.
Como já mencionado, todos os caminhos do sistema estão representados no EG montado no passo anterior.
Em o EG, os diferentes caminhos podem ser facilmente identi «cados nos nodos de branch.
Serão adicionadas, aos ramos destes nodos, probabilidades referentes a cada caminho que estes representam.
Porém, assim como no método de Cortellessa e Mirandola, as probabilidades de cada caso de uso não são su «cientes para obter- se as probabilidades de cada caminho do EG.
Necessita- se de probabilidades de cada diagrama de seqüencia de um caso de uso ser executado, que devem ser informadas por o analista.
Se estas probabilidade forem multiplicadas por as probabilidades consolidadas dos casos de uso, geram a probabilidade consolidada de cada diagrama de seqüência ser executado, exceto nos diagramas de seqüência de casos de uso estendidos e de generalizações, ou quais serão demonstrados a seguir.
No caso de os diagramas de extensão e generalização as probabilidades conso-lidadas de cada caso de uso será de «na por a multiplicação da probabilidade consolidada do caso de uso base, da extensão ou generalização, por a probabilidade da condição de extensão ou especialização ser verdadeira.
Este resultado deve ser multiplicado por a probabilidade de cada diagrama de seqüência ser executado.
Ainda, como nas restrições, os diagramas de seqüência da extensão contêm todas as chamadas, entende- se que o caso de uso base desta extensão será executado apenas quando a extensão não ocorrer.
Com isso, as probabilidades dos diagramas de seqüência do caso de uso base devem ser revistas multiplicando as probabilidades de seus diagramas de sequência por a probabilidade da condição da extensão ser falsa.
4 Após de «nidas todas as probabilidades consolidadas de cada diagrama de seqüência, podese, então, iniciar a adição das probabilidades aos nodos de branch do EG.
A adição deve começar do nodo Init seguindo para o próximo nodo branch e deste para os próximos, em seus ramos até que todos os nodos branch contenham probablidades.
Para cada ramo do nodo branch deverão ser analisados que diagramas de seqüência formam este ramo, e deve- se somar as probabilidades dos diagramas de seqüência que o compõem.
Segue- se estes passos até que todos os ramos de todos os nodos branch estejam preenchidos.
Após isso, deve- se aplicar uma normalização em cada nodo branch para que o contenham, então, probabilidades, ou seja, o somatório dos ramos que partem do nodo branch seja igual 4O calculo da probabilidade da condição da extensão ser falsa consiste da seguinte subtração:
1 -- probabilidade da condição ser verdadeira a 1.
Em o exemplo do sistema bancário, com as probabilidades de cada diagrama de seqüência e o cálculo da probabilidade consolidada indicados na Tabela 3.1, a estrutura do EG com as probabilidades consolidadas não normalizadas é demonstrada na Figura 3.19.
Em agura, cada nodo Branch deve ser normalizado, para isso basta dividir o número de cada ramo do branch por o somatório dos números de todos os ramos deste mesmo nodo branch obtendo assim probabilidades.
Neste passo, serão identicados os recursos computacionais do sistema (Processadores, rede, etc).
Estes serão uma parte muito importante na avaliação do desempenho do software, já que podem produzir tempo de espera devido a uma super alocação, ou podem indicar uma sub utilização de recursos, ou ainda, podem indicar um desbalanceamento dos recursos de hardware.
Em UML, os recursos estão representados no diagrama de implantação em termos de nós e ligações entre eles.
Para transformar estes recursos em autômatos e representar- los em SAN é necessário identificar os possíveis estados dos mesmos.
Tipicamente, um nó possui um processador e uma memória e seus estados podem ser ocupado ou livre, onde no primeiro não aceita novos processos, no segundo estado aceita o processamento de novos processos.
Assumindo- se que a ocupação do processador representa a ocupação do nó, então tem- se apenas dois estados por nó.
Com isso, tem- se os estados dos autômatos que representam os recursos, faltam, portanto, as transições de estados possíveis e eventos e taxas.
As transições para estes dois estados são de livre para ocupado e de ocupado para livre.
Outras transições como livre para livre e ocupado para ocupado não fazem sentido aqui, pois uma vez ocupado o recurso, este pode apenas ser liberado e vice-versa.
Os eventos e taxas de ocupação e desocupação dos recursos, não dependem de eles próprios, mas do software que é executado nestes recursos, já que os diferentes algoritmos ou tarefas levam diferentes tempos para serem executados.
Os eventos e as taxas serão demarcados junto à definição dos autômatos que representam o software, que será visto nas próximas seções.
Após converter todos os recursos (nós) do diagrama de implantação em autômatos de dois estados está pronta a conversão.
As ligações entre estes recursos (rede) não serão representadas como autômatos, mas como eventos sincronizantes entre os recursos e as linhas de execução e sua latência será incluída em estados nos autômatos que representarão o software, como será visto nas próximas seções.
Após criada a estrutura do EG e identi&amp; cados quais os recursos estão disponíveis ao sistema, irá- se adicionar dos valores de tempo de execução nos nodos básicos do EG.
Os valores de tempo são os tempos médios de execução do método representados por o nodo básico do EG no recurso disponível ao sistema, ao qual o componente a que pertence a classe alvo está implantado.
Esta informação é obtida através do diagrama de implantação do modelo UML.
Este tempo diz respeito ao processamento executado por algoritmos dentro deste método, desconsiderando- se os tempos gastos por algoritmos em outros métodos chamados por este, já que os tempos de processamento de métodos por ele chamados serão considerados nos nodos básicos seguintes a este.
A coleta dos tempos de processamento deve- se dar da seguinte forma:
Para cada nodo básico deve existir um vetor, onde cada posição deste vetor representa o tempo de processamento num recurso do sistema.
O tamanho deste vetor é igual ao número de recursos do sistema (nós), identi' cados no quarto passo desta técnica, mais duas posições.
As duas posições extras do vetor representam o tempo de pensamento do usuário (thinking time) e a latência da rede.
Este vetor deve ser preenchido sempre com valores positivos e diferentes de zero quando a chamada de método em questão utilizar o recurso, ao qual a posição do vetor representa, e valores nulos ou iguais a zero para identi' car os recursos que não serão utilizados na chamada representada por o nodo básico.
A exceção a esta regras são os nodos básicos onde a chamada é disparada por o usuário.
Em estes casos, irão existir, além de os tempos dos recursos, o tempo de pensamento do usuário (thinking time) que é o tempo de reação do usuário ao sistema.
Como já mencionado este tempo deve ser indicado numa das duas posições extras, inseridas no vetor, a outra posição é referente a o atraso introduzido por a latência da rede que será tratada nas próximas seções.
Após criados e preenchidos todos os vetores para todos os nodos básicos do EG, deve- se, então, observar o nodo Init.
Diferentemente dos nodos básicos, este nodo conterá não um tempo de processamento num ou mais recursos, mas a taxa de chegada de usuários.
Em este nodo, não será necessária a criação de um vetor, mas apenas indicar o tempo médio com que os usuários chegam ao sistema.
Em o exemplo do sistema bancário, supõem- se que cheguem usuários a cada mi- nuto e que um usuário leva em média 5 segundos para reagir a uma mensagem na tela.
Com isso, e a análise de tempo de processamento de cada chamada do projetista, foi gerado o EG com os tempos em milisegundos demonstrados na Figura 3.21.
Para melhor visualização, foram demonstrados nesta figura apenas os nodos básicos do casos de uso UC6.
Os demais casos de uso seguirão a mesma abordagem.
Em SAN, diferentemente de QN, não existe o conceito de clientes trafegando através de uma rede.
Assim, a representação da quantidade de usuários no sistema em SAN não é tão claro e direta.
Em SAN, este conceito pode ser representado de diversas formas:
Por um autômato que representa sua quantidade e taxas funcionais, por a replicação de autômatos (um para cada cliente), agrupando clientes e calculando as novas taxas num único autômato, entre outras.
Em esta técnica, onde o EG se transformará num autômato, se for utilizada a forma de um autômato que representa a quantidade de usuários no sistema, teria- se um limitação no número máximo de usuários.
Além disso, não representaria a disputa por recursos do sistema, pois haveria apenas um autômato gerado a partir de o EG, o qual seria executado em seqüência evitando esta disputa.
Uma segunda alternativa viável ao problema seria com replicações dos autômatos gerados por o EG a nível de usuário.
Isso causaria uma disputa a nível de usuário individualmente por os recursos, porém causaria uma limitação na quantidade de usuários (autômatos), pois o autômato gerado por o EG possui muitos estados e causando a explosão de espaço de estados, o que pode inviabilizar a resolução do SAN por a grande quantidade de estados globais que seriam gerados.
A terceira alternativa seria agrupar usuários num único autômato gerado por o EG e recalcular as taxas de transição de estados de acordo com os usuários.
Entretanto, isso geraria o mesmo problema da primeira forma apresentada, sem disputa por recursos.
Porém, se forem avaliadas a segunda e a terceira forma, pode- se montar uma nova forma de representar os usuários onde alguns autômatos seriam replicados e cada um destes representaria um determinado conjunto ou pacote de usuários.
Assim a estrutura do EG será replicada num número denido de pacotes.
E cada pacote conterá um número de usuário que acessarão o sistema ao mesmo tempo.
Esta forma de representação produz uma concorrência por o recursos e uma representação de usuário sem a explosão de espaço de estados, tornando- se assim a melhor opção de representação para esta técnica.
Para replicação dos EG e agrupar os autômatos gerados, deve ser considerado que o tempo de execução indicado no passo Adição dos Tempos de Processamento ao EG de um nodo básico é o tempo para um usuário executar cada método, ignorando atrasos inseridos por a rede.
O que remete a um cálculo bruto, onde se num determinado momento o sistema tiver 100 usuários, o sistema ocupará o recurso por 100 vezes o tempo de processamento em cada nodo básico, já que os atrasos não são considerados neste tempo.
Com isso, se 100 usuários forem o número máximo de usuário concorrentes no sistema, poderá- se dividir- los em 5 pacotes de 20 usuários cada e assim replicar 5 EGs iguais com tempos dos nodos básicos multiplicados por 20.
De essa forma, estariam formados 5 pacotes representando o processamento de 20 usuários.
Quanto a o tempo de reação do usuário, entende- se que estes usuários estão utilizando o recurso ao mesmo tempo, e portanto cada um de eles em média leva o mesmo tempo de pensamento individualmente.
Com isso, reagem, em média, com o mesmo tempo e o tempo de pensamento é independente do número de usuários representados no EG.
A taxa de chegada de usuários associada ao nodo Init também sofrerá alterações devido a mudança na quantidade de usuário que chega ao mesmo tempo.
No caso de pacotes com 20 usuários deve- se recalcular- la para representar a taxa de chegada de 20 usuários ao mesmo tempo.
Em o exemplo do sistema bancário, suponha que em média chegam 2,5 usuário ao mesmo tempo com um máximo de 5 usuários.
Isto geraria dois pacotes de 2,5 usuários e mais uma réplica do EG com os tempos de processamento multiplicados por 2,5.
Os tempo de processamento do EG original, também, serão multiplicados por 2,5.
Em a Figura 3.22 pode ser observado que os tempos de processamento dos nodos básicos dos diagramas de seqüência do caso de uso UC6 foram multiplicados por 2,5 formando um ramo de um dos dois EGs destes exemplo.
Note que os tempos gastos por os usuários não foram multiplicados.
Com os EGs prontos e representando grupos de usuários, pode- se então adicionar o atraso introduzido por a latência da rede e de recurso que tragam atraso as chamadas de métodos.
A latência será representada por um tempo médio de atraso inserido por a rede na forma de um elemento no vetor de processamento dos nodos básicos do EG.
Por a latência representar um atraso, assim como o tempo de pensamento do usuário, este tempo não deve ser multiplicado por o número de usuários de cada pacotes, pois entende- se que a largura de banda é su/ ciente para suportar o número máximo de usuários e portanto, o atraso não é proporcional ao número de usuários, e sim, uma média de tempo em que os dados ou chamadas levam para atravessar a rede.
Em outras palavras, não estará representada disputa por a rede.
Para adicionar a latência nos tempos de processamento dos EGs deve- se observar o diagrama de implantação do UML, onde os componentes e nós se relacionam.
A latência deve ser introduzida quando houver uma chamada a um método de um componente localizado num nó diferente do componente chamador.
Em este caso, o tempo da latência da rede ou do recurso de comunicação deve ser introduzido na posição da latência no vetor do nodo básico, que contém a chamada ao método remoto.
Assim, este processo deve ser realizado em todas as réplicas do EGs.
A o fim o EG conterá todos os tempos de processamento e atrasos necessários para representar o software.
Em o sistema bancário, existe uma rede entre o nó Terminal e o Servidor.
Supondo que esta rede produz em média um atraso de 50 milisegundos nas chamadas do componente InterfaceUsuario para o componente ControladorBanco e em suas res-postas.
Portanto, devem ser adicionados 50 milisegundos para cada vetor dos nodos básicos onde há uma chamada feita por uma classe do componente InterfaceUsuario a um método numa classe no componente ControladorBanco ou vice-versa.
Em a Figura 3.23, são demonstrados os nodos básicos do EG para o caso de uso UC6 com a latência.
Como mencionado anteriormente, diferentemente da metodologia de Cortellessa e Mirandola, o EG será utilizado para a criação de um autômato e não para a execução da metodologia SPE.
Para a criação de um autômato com menos estados e com a mesma representação, evitando assim a explosão de espaço de estados, faz- se necessária a simplificação dos EGs.
Esta simplificação se dá através da diminuição do número total de nodos básicos de cada EG, os quais serão transformados em estados na conversão dos EGs para autômatos, vista a seguir.
Esta simplificação é feita de forma a agrupar os nodos básicos adjacentes com a utilização dos mesmos recursos, e sem um tempo de pensamento do usuário, pois não serão adicionados atrasos entre estes nodos e todos sincronizarão com os mesmo autômatos de recursos.
Note que nodos com latência de rede podem ser agrupados com nodos sem latência, pois a latência é introduzida antes do início do processamento da chamada e as chamadas no mesmo recurso não introduzem atrasos referentes à rede.
Os nodos adjacentes com a utilização de um mesmo recurso são agrupados num único nodo básico, que é nomeado com todas as tuplas que o compõem, e os tempos de processamentos de cada recurso são somados formando um novo vetor de recursos.
Em a Figura 3.24 é demonstrado o resultado da simpli/ cação aplicada ao exemplo do sistema bancário nos nodos básicos dos diagramas de seqüência do caso de uso UC6.
A o final desta operação, os EGs estarão com menos nodos básicos e gerarão, assim, autômatos com menos estados, mas com a mesma representação de disputa e ocupação de recursos.
Esta manobra é, simplesmente, para diminuição do número de estados globais da SAN gerada por essa técnica, a qual tente a viabilizar um número maior de casos que podem ser resolvidos.
Cada ligação do EG será transformada numa transição de um autômato, e conterá um evento que signica o nal do processamento de uma chamada e início de outro. Quanto
as taxas, se for considerado que uma transição de um nodo básico para outro depende do término de seu processamento, pode- se dizer que a taxa de saída de um nodo básico é proporcional ao tempo de processamento deste nodo.
Se consideramos que, quanto 5A partir dessa conversão os autômatos que foram gerados a partir de o EG serão chamados de Autômatos do EG.
Esta taxa pode ser facilmente calculada para nodos básicos, onde não há atrasos e nenhum tempo de pensamento ou reação do usuário.
Os nodos básicos com um tempo de pensamento do usuário serão divididos em dois estados.
O primeiro estado representará o estado de usuário pensando.
A taxa do evento de saída deste estado será dependente do tempo de pensamento, ou seja a taxa de cada evento de saída será o inverso do tempo de pensamento do usuário.
O segundo estado representará o processamento da chamada feita por o usuário.
As taxas de saída deste estado serão, portanto, o inverso do tempo gasto com o recurso utilizado.
Em a Figura 3.25, pode ser observada a transformação de um dos nodos básicos do caso de uso UC6 que está associado a um tempo de reação do usuário.
Os nodos básicos com valor de atraso provocado por a latência da rede são tratados da mesma forma, que os nodos com tempo de reação do usuário.
O nodo é convertido em dois estados, o primeiro representando o atraso introduzido, onde os evento de saída terão uma taxa que será o inverso do atraso.
O segundo estado representa a execução do método chamado e a taxa dos eventos de saída será o inverso do tempo gasto, com o recurso que este utiliza.
Os nodos de laço podem ser simplesmente suprimidos e as conexões, que chegam a ele, serem adicionadas ao nodo imediatamente posterior a ele.
Os nodos branch serão suprimidos e seus ramos serão ligados ao estado que representa o nodo básico ou Init imediatamente anterior a este branch.
Em o estado do nodo básico ou Init anterior continuará havendo apenas um evento de saída e a este devem ser aplicadas as probabilidades de cada ramo do branch, para decidir a transição a ser efetuada.
Em a figura 3.26 é demonstrado como o nodo branch é suprimido e suas probabilidades associadas ao evento de transição do nodo básico anterior.
Os nodos de fork e join, assim como cada ramo do fork, serão transformados em autômatos separados.
Cada autômato será composto por um nodo de fork seguido das seqüências de nodos do ramo do fork terminado por um estado de join.
Em a Figura 3.27 estes autômatos estão representados como FJ1 e FJ2.
O autômato gerado por o EG será composto por os estados que representam o nodo imediatamente anterior ao fork e posterior ao join ligados diretamente.
Os autômatos de Fork/ Join serão iniciados por o evento de saída do nodo anterior ao fork, ou seja, este evento sincronizará o autômato do EG e os autômatos deste Fork/ Join.
A sincronização do join dos autômatos ocorre na taxa do estado que representa o nodo básico posterior ao join.
Esta taxa é dependente dos autômatos de Fork/ Join, quando todos estiverem no estado join o evento passa a ter uma taxa diferente de zero.
Este evento também sincronizará o autômato EG com os autômatos de Fork/ Join retornando ao estado de fork e assim preparando para uma nova execução do Fork.
Em a Figura 3.27 é demonstrada esta conversão.
Mais detalhes sobre os eventos e taxas serão vistos a seguir.
Em o exemplo EG dos diagramas de seqüência do caso de uso UC6 do sistema bancário, a conversão é demonstrada na Figura 3.28.
Com os autômatos do EG e os autômatos dos recursos gerados têm- se, agora, que uni 3 car- los numa SAN.
Para isso, deve- se acertar as sincronizações entre os processamentos contidos nos estado que representam os nodos básicos com os recursos.
As informações referentes a qual recurso é utilizado em cada nodo está no EG nos vetores de cada nodo básico.
Como os atrasos provocados por a rede e por o usuário foram separados em estados distintos dos estados, que ocupam recursos computacionais, pode- se identificar, claramente, quais os estados que ocuparão recursos do sistema e quais os liberarão.
A chegada aos estados que ocupam recursos indicará, além de o início do processamento, a ocupação do recurso, onde as chamadas contidas neste estado serão processadas.
Logo, os eventos de chegada a um estado que ocupará um recurso do sistema deverão sincronizar o autômato do EG com o autômato do recurso na transição do estado livre para o ocupado.
De a mesma forma, os eventos de saída destes estado deverão sincronizar o autômato do EG com o autômato do recurso ocupado na transição de ocupado para livre, liberando assim, o recurso para ser utilizado por outras chamadas.
Os estados de atraso, (latência da rede ou tempo de pensamento do usuário) bem como, o estado que representa o nodo init não ocuparão recursos e portanto os eventos de chegada não sincronizarão com a utilização de um recurso nem os de saída, sincronizarão com a liberação de um recurso.
Em o exemplo do sistema bancário, para o autômato gerado do EG dos diagramas casos de seqüência do caso de uso UC6, a sincronização entre o autômato e os recurso gera a SAN demonstrada na Figura 3.29.
A o completar a sincronização para todos os estados com processamento, a SAN estará completa.
Para resolver- la, pode- se utilizar ferramentas de resolução de SAN, como por exemplo o PEPS.
De esta SAN podem ser obtidos resultados como tempo médio de processamento, utilização média de recursos, etc..
Estudo de Caso Para vericar a técnica apresentada no Capítulo 3, será realizado um estudo de caso.
Para este estudo, será utilizada uma modelagem em UML de uma aplicação já implementada e implantada1.
De esta serão obtidos os tempos de processamento médios e tempos de latência médios.
Com estes dados será medida a utilização média de cada recurso do sistema, através da SAN gerada por a técnica.
Este será aplicado com diferente congurações de pacotes para vericar o impacto da concorrência por os recursos na utilização dos mesmos.
A modelagem do software será apresentada apenas em termos de diagramas de casos de uso, seqüência e implantação.
Os demais diagramas não serão apresentados aqui.
O diagrama de casos de uso deste software é composta por um ator e três casos de uso:
UC01 -- View Information, UC02 -- View Details e UC05 -- Help conforme demonstrado na Figura 4.1.
Entre estes casos de uso, dois relacionam- se diretamente com o ator e um é estendido.
Por ser o único ator, o SystemUser tem probabilidade de ator igual a 1.
A probabilidade de um SystemUser acessar o caso de uso UC01 é de 95% e o SystemUser tem 5% de chance de consultar o help num acesso.
No caso de uso UC01 o Ator tem 80% de chance de necessitar de mais informações e, assim, acessar o caso de uso UC02.
O diagrama de casos de uso com as probabilidades é demonstrado na Figura.
A intenção inicial deste estudo era de avaliar os resultados da aplicação da técnica com resultados reais desta aplicação, porém por restrições de tempo esta comparação cará para trabalhos futuros.
Este software está implantado numa plataforma bem simples, composta por uma máquina cliente e um servidor interligados por uma rede.
O diagrama de implantação é demonstrado na Figura 4.5.
Em este sistema existe dois componentes:
Cliente e servidor.
O componente servidor compreende as classes hrhttp e dosrvr.
As demais classes pertencem ao componente cliente.
O componente cliente está implantado na máquina cliente e o servidor na máquina servidor.
Para aplicar a técnica descrita no Capítulo 3, são necessários, ainda, outros dados a serem informados.
Estes dados são:
As probabilidades de cada diagrama de seqüência dentro de cada caso de uso, o tempo médio de cada chamada, a latência média da Rede, o tempo médio de reação do usuário, tempo de médio de chegada de usuário, a quantidade de pacotes e a quantidade de usuários em cada pacote.
Como existe apenas um diagrama de seqüência para cada caso de uso, as pro-babilidades de cada diagrama de seqüência ser executado, quando o caso de uso for acessado é de 100%, ou seja igual a 1.
O tempo médio de cada chamada foi medido no sistema na implantação atual.
Estes tempos já simpli3cados e multiplicados por a quantidade de usuários de cada pacote é demonstrada na SAN gerada por a técnica vista na Figura 4.6.
Em este, estão representados 3 pacotes com 25 usuário em cada um, como será demonstrado a seguir.
O tempo médio de latência da rede, assim como os tempos de processamento, foi medido no ambiente onde o sistema está implantado.
O resultado obtido foi de 200 milisegundos em média de atraso introduzido por a rede.
Em a vericação a ser realizada considera- se um tempo médio de reação do usuário igual a 3 segundos.
Em esta mesma vericação será considerado, que os usuários chegam ao sistema em média de 1 em 1 segundo, após os usuários correntes terem deixado o sistema.
A quantidade de usuário utilizados na vericação será de 75 usuários.
Estes serão divididos em 5 congurações de pacotes diferentes:
Um pacote com 75 usuários;
Dois pacotes com 37,5 usuário em cada um;
Três pacotes com 25 usuário em cada um;
Quatro pacotes com 38,75 usuário em cada um;
Cinco pacotes com 15 usuário em cada um.
Com estas informações, e após aplicar os passos descritos no Capítulo 3, obtém- se, para o cenário com 3 pacotes, a SAN demonstrada na Figura 4.6.
Note que o passo da simplicação reduziu, drasticamente, o número nal de estados na SAN em relação a a quantidade de chamadas nos diagramas de seqüência.
Isso se deve por o grande número de chamadas realizadas entre classes em componentes na mesma máquina, ou, como no caso, no mesmo componente, como já mencionado.
Para resolver esta SAN será utilizada a ferramenta PEPS.
Em esta ferramenta a SAN é descrita através de um arquivo texto.
Este arquivo é demonstrado no anexo C. Em este, está representando, assim com a SAN da Figura 4.6, o cenário com três pacotes contendo 25 usuários cada.
Para medir a utilização dos recursos do sistema na SAN gerada por a técnica, basta vericar a probabilidade de cada recurso estar no estado ocupado.
Em a ferramenta PEPS adicionam- se funções na seção de resultados, uma para cada recurso.
Em este caso, foram adicionadas as funções clntUtilização e srvrUtilização demonstradas no Apêndice C. Note que a SAN contém além de as funções de utilização, as funções que resultam na ociosidade dos recursos.
A análise da utilização dos recursos depende muito da concorrência por estes recursos.
Conforme mencionado anteriormente, o número de pacotes dene a concorrência por os recursos.
Em esta vericação, o mesmo cenário descrito na seção anterior será resolvido nas 5 congurações diferentes descritas na seção anterior.
Os resultados obtidos para as utilizações do cliente e servidor em cada um dos cinco testes da SAN são demonstrados na Tabela 4.1.
Com estes resultados pode- se notar que, com o aumento no número de pacotes os percentuais de utilização parecem em via de conversão a um número que melhor representa a utilização dos recursos.
Observando as diferenças entre as porcen-tagens, estas diminuem, conforme aumenta- se os números de pacotes.
Isto pode indicar a convergência ao número mais próximo de a real utilização dos recursos.
Levando a interpretar que, quanto maior o número de pacotes, mais preciso é o resultado.
Outra interpretação válida, é que estes números vem decrescendo devido a o aumento do atraso introduzido por a concorrência.
Sendo a chegada de usuários dependente da saída de usuário, isto pode causar a diminuição da quantidade de usuários, que acessaram o sistema num mesmo período de tempo.
Isso causaria uma redução na utilização dos recursos, pois menos usuários os utilizam num mesmo espaço de tempo.
Portanto, a baixa quantidade de pacotes pode não representar a realidade, pois não pressupõem atrasos por disputa de recursos.
Por outro lado, a grande quantidade de pacotes pode introduzir atraso em demasia aumentado o erro embutido nos resultados da utilização dos recursos.
Com este trabalho, foi possível demonstrar a existência de uma relação de implicação entre alguns modelos em UML e o formalismo SAN, e ainda, que esta implicação pode ser utilizada para obter medidas de desempenho do software modelado em UML.
A principal contribuição deste é a demonstração da técnica de conversão de UML para SAN.
Esta foi obtida a partir de duas técnicas existentes:
Software Preformance Engineering (SPE) e método de conversão de UML para Redes de Fifilas de espera (QN).
De o SPE foi herdada a estrutura Execution Graphs (EG), a qual também é utilizada por Cortellessa e Mirandola na conversão de UML para QN.
De o método de conversão de UML para QN foram utilizados os passos de preparação dos diagramas UML e o algoritmo de conversão de diagramas de seqüência para EG.
A partir desses, foi possível modi5car passos existentes e adicionar novos, para gerar uma SAN ao invés de uma QN.
Entre os passos mo di5cados podem ser citados como a obtenção do per5l do usuário e a identi5cação dos recursos de sistema, e entre passos adicionados estão a conversão de EG em Autômatos e Simpli5cação do EG.
Além de a técnica de conversão de UML para SAN, este trabalho demonstrou a forma de tratamento de inclusões, extensões e generalizações nos diagramas de casos de uso.
Com isso, o método de Cortellessa e Mirandola e a técnica aqui apresentada passaram a viabilizar a conversão de uma maior quantidade de modelos em UML, tornando- os mais abrangentes.
Foi demonstrada a conversão de UML para SAN e eliminadas algumas restrições existentes em métodos similares, porém ainda existem restrições em relação a o UML requerido para gerar a SAN.
Estas restrições podem ser tratadas em futuros trabalhos sobre metodologias e técnicas de conversão de UML para modelo de avaliação de desempenho.
Entre, estes trabalhos, está a de-monstração do tratamento de generalização de atores, conforme mencionado ao longo de a técnica aqui apresentada.
Existem ainda, trabalhos futuros nos diagramas de seqüência, para demonstrar como tratar chamadas assíncronas.
Em o modelo SAN gerado existem alguns estudos futuros a serem considerados.
A técnica atual pressupõem que os recursos possuem apenas um processador.
Isso é expresso na visão, de que existem apenas dois estados por recurso:
Livre e ocupado.
A técnica deve ser melhorada para melhor representar recursos multi-processados.
Com isso, será possível veri' car, não só a utilização de um recurso, mas também a de cada processador que o compõem.
Outra melhoria a ser efetuada na SAN gerada é um melhor controle da chegada de usuário, pois, conforme comentado no estudo de caso, se houver um grande atraso devido a recursos indisponíveis a taxa de chegada de usuários será afetada diretamente, já que a chegada está diretamente relacionada a o'm do processamento dos usuários correntes.
Assim, a técnica pode gerar um percentual de erro grande nos resultados.
Além de as reduções de restrições com relação a o UML e melhorias na SAN gerada, existe um trabalho de validação desta técnica.
Um último estudo futuro visionado, a partir deste, é a conversão da UML 2.
0 para SAN, já que neste foi utilizado o padrão UML 1.
5. Porém, este trabalho promove um nova frente de estudos na avaliação de desempenho de softwares orientados a objeto.
