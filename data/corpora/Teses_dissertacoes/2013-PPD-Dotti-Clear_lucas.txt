O emprego de sistemas complexos e críticos para automação de tarefas do cotidiano faz crescer a dependência das pessoas, gerando desconforto em relação a a segurança de tais sistemas.
Em os últimos anos algumas técnicas têm sido desenvolvidas visando facilitar as atividades relacionadas à validação de projetos nos estágios iniciais do ciclo de desenvolvimento.
Verificação de modelos é uma técnica formal automática que permite a verificação de sistemas concorrentes de estados finitos sob propriedades descritas em lógicas temporais através do emprego de algoritmos que avaliam exaustivamente o sistema sob consideração.
Entretanto, esta técnica é custosa no que tange ao armazenamento em memória e processamento, justificando o desenvolvimento de algoritmos paralelos e distribuídos para poderosos agregados computacionais.
Esta dissertação relata o estudo e desenvolvimento de algoritmos de verificação de modelos descritos em Redes de Autômatos Estocásticos e propriedades descritas na lógica temporal Computation Tree Logic para ambientes que endereçam espaços de memória de maneira distribuída.
Palavras Chave: Redes de Autômatos Estocásticos, Lógica Temporal Ramificada, Verificação Formal, Verificação de Modelos Paralela e Distribuída.
Trabalho parcialmente suportado por os projetos FAPERGS PqG 1014867 e CNPq 560036/2010-8 &quot;Verificação de Modelos Descritos em Redes de Autômatos Estocásticos».
O emprego de sistemas complexos e críticos para automatização de tarefas traz grandes benefícios para a sociedade.
Entretanto, a dependência das pessoas nestes sistemas gera desconforto em relação a a corretude e segurança dos mesmos.
Erros em sistemas de hardware e software críticos são conhecidos e têm causado danos tanto de cunho financeiro como à integridada humana.
Um exemplo clássico de erro de projeto de tais sistemas é o erro de software no foguete Ariane 5 o qual causou sua destruição logo após a decolagem gerando um prejuízo em torno de US$ 500 milhões No decorrer de os anos, algumas técnicas têm sido desenvolvidas visando amenizar as dificuldades relacionadas à validação de complexos sistemas.
Model Checking (Verificação de Modelos) é uma técnica formal que permite a verificação de sistemas concorrentes de estados finitos através de exaustiva exploração do conjunto de estados que representa uma realidade, tal como o funcionamento de um algoritmo ou protocolo de comunicação.
Um atrativo interessante que a técnica apresenta é permitir a condução dos passos relacionados à verificação de forma automática sem necessidade de intervenção do usuário.
Devido a os interessantes aspectos apresentados, alguns formalismos de modelagem têm recebido ferramental de suporte, como Cadeias de Markov (verificador PRISM), Redes de Petri Estocásticas (verificador SMART) e Álgebra de Processos (verificador FDR).
Redes de Autômatos Estocásticos (Stochastic Automata Networks -- SAN) é um formalismo Markoviano estruturado focado na modelagem de sistemas concorrentes com grandes espaços de estados primeiramente voltado à avaliação de desempenho.
Em SAN, complexas realidades podem ser modeladas através de um conjunto de subsistemas que ocasionalmente interagem.
Cada subsistema é definido através de autômatos os quais são compostos por estados e as respectivas transições entre estes estados que podem ser guiadas por eventos locais ou sincronizantes.
Como principal diferencial em relação a outros formalismos de modelagem, SAN oferece a vantagem de permitir o uso de funções para avaliação de estados globais de um modelo, habilitando a definição de dependências entre autômatos e a descrição de comportamentos complexos de maneira compacta.
O formalismo é empregado para modelagem de diferentes realidades, como escalonamento de processos em arquiteturas Em uma, programas paralelos mestre/ escravo, redes wireless Ad Hoc, modelos de linhas de produção, de entre outros1.
Apesar de os interessantes aspectos de modelagem fornecidos e a existência de ferramental especializado para avaliação de desempenho, a ausência de ferramentas de verificação dificulta a validação de modelos SAN.
Visando suprir tal carência, esforços foram investidos através de um trabalho cooperativo na construção de um verificador de propriedades descritas na lógica temporal Computation Tree Logic (CTL), tendo os primeiros resultados gerados discutidos em.
Embora algumas técnicas tenham sido desenvolvidas ao longo de os anos permitindo a verificação de complexos sistemas, tal como uso de simetrias, redução de ordem parcial e representação e manipulação simbólica de espaços de estados, um fator limitante à técnica de verificação de modelos é a conhecida explosão do espaço de estados.
Este problema se deve ao crescimento exponencial na estrutura que representa o sistema sob consideração e a falta de recursos computacionais para manipular grandes quantidades de informação.
Devido a os constantes avanços por a indústria, o acesso à agregados computacionais têm permitido o desenvolvimento de algoritmos paralelos para ambientes que endereçam espaços de memória de forma distribuída ou compartilhada.
De esta maneira, construir algoritmos que permitam a verificação de complexas realidades motiva o estudo e desenvolvimento de novas pesquisas na área.
Motivação e Objetivos Grande parte das abordagens de verificação paralela foca em ambientes com processamento e memória distribuídos onde atribui- se pequenos conjuntos disjuntos de estados para diferentes máquinas para computação em paralelo.
Entretanto, a exploração de espaços de estados distribuídos pode sofrer de sobrecarga de comunicação, uma vez que estados que sejam relacionados através de transições podem estar localizados em diferentes partições.
De esta maneira, o cálculo de estados sucessores ou antecessores de um dado estado pode ser um gargalo, uma vez que sejam geradas partições do espaço de estados sem considerar as relações entre os estados, configurando uma distribuição de pouca qualidade.
Embora o emprego de ambientes com memória distribuída permita o armazenamento de abstrações relativas à complexas realidades, representar o espaço de estados de um modelo em sua íntegra possibilita conduzir localmente o cálculo de estados antecessores/ sucessores de um dado estado.
A o se considerar que a verificação de determinados operadores que compõem a lógica temporal CTL possuem algoritmos de verificação extremamente custosos devido a a necessidade de cálculo de ponto fixo, o qual é obtido através de exaustiva avaliação do conjunto de estados que representa uma realidade, estando o espaço de estados integralmente disponível num conjunto de máquinas habilita- se as mesmas a explorar conjuntos de estados distintos de maneira quase independente, de modo que comunicação e sincronismo são necessários somente para obtenção de ponto fixo.&amp;&amp;&amp;
De outro lado, ferramentas de verificação de modelos que aceitam como entrada propriedades da lógica temporal Computation Tree Logic normalmente implementam algoritmos de verificação para fórmulas representadas num formato mínimo, o qual permite derivação de toda e qualquer fórmula CTL válida.
Apesar de esta vantagem simplificar a implementação de ferramentas de verificação, a transcrição de fórmulas para este formato aumenta consideravelmente o tamanho da fórmula em questão, consequentemente aumentando o tempo de verificação.
A adoção de ambientes distribuídos aliado às características da lógica temporal adotada motiva a pesquisa e desenvolvimento de novas técnicas de verificação.
Em este contexto, esta dissertação de mestrado objetiva a proposta, implementação, validação e experimentação de duas abordagens para estes ambientes, sendo:
Distribuição da verificação dos operadores de maior custo computacional pertencentes a um formato mínimo de escrita de fórmulas CTL válidas.
O ganho de desempenho é focado na condução distribuída de cada iteração necessária à obtenção de ponto fixo, onde cada máquina empregada é responsável por a computação de um subconjunto de estados do conjunto em consideração;
Desenvolvimento de um algoritmo de análise e escolha de particionamento da árvore sintática que representa propriedades CTL escritas no formato aceito por o algoritmo de verificação adotado e posterior distribuição das partições para computação em paralelo.
Para cada partição identificada, um grupo de máquinas conduz a verificação distribuída dos operadores de maior custo computacional presentes na partição através do emprego da primeira abordagem paralela.
Para ambas as abordagens, réplicas da estrutura simbólica que representa o espaço de estados gerado por o formalismo SAN e respectiva função de transição são feitas, possibilitando a condução de computações distribuídas de maneira a realizar troca de mensagens somente para obtenção de ponto fixo.
Embora esta abordagem pareça pouco eficiente quanto a a consumo de memória, ganhos são discutidos no decorrer de o trabalho em razão de a distribuição das tarefas relacionadas à computação dos operadores de lógica temporal, estando estas tarefas diretamente relacionadas ao consumo.
Organização do Trabalho Após a introdução do trabalho, o Capítulo 2 apresenta o embasamento teórico necessário ao entendimento dos conceitos que compreendem a pesquisa em si, detalhando Redes de Autômatos Estocásticos, Lógicas Temporais, Diagramas de Decisão, Verificação de Modelos e Verificação de Modelos Paralela e Distribuída.
O Capítulo 3 se limita a descrever a arquitetura da ferramenta de verificação para modelos SAN inicialmente desenvolvida, bem como, detalhar o algoritmo sequencial de verificação adotado.
Em a sequência, o Capítulo 4 descreve detalhadamente as abordagens paralelas propostas neste trabalho.
O Capítulo 5 descreve os experimentos conduzidos sob diferentes modelos SAN e discute os ganhos de desempenho obtidos.
Por fim, o Capítulo 6 apresenta as considerações finais acerca de o trabalho desenvolvido.
Este capítulo apresenta a fundamentação teórica necessária ao entendimento dos conceitos que compreendem este trabalho.
Sendo assim, Redes de Autômatos Estocásticos, Diagramas de Decisão, Lógicas Temporais, Verificação de Modelos e Verificação de Modelos Paralela e Distribuída são descritos.
Redes de Autômatos Estocásticos Redes de Autômatos Estocásticos -- Stochastic Automata Networks (SAN) -- é um formalismo Markoviano estruturado para modelagem de sistemas com grandes espaços de estados.
A idéia central deste formalismo é permitir a modelagem de sistemas como um conjunto de subsistemas que possuem comportamento independente e ocasional interação.
Possui equivalência de descrição com Cadeias de Markov de forma que é possível representar toda Cadeia de Markov através de um modelo SAN.
Em SAN, modelos são descritos através de um conjunto de autômatos os quais possuem um número finito de estados, chamados estados locais, e as respectivas transições entre estes estados.
As transições entre estados possuem uma lista de eventos que podem disparar estas transições, podendo ser eventos locais ou sincronizantes.
Os eventos que ocorrem num único autômato, ou seja, eventos que alterem somente o estado de um determinado autômato não interferindo nos demais autômatos da rede, são chamados eventos locais.
De outro lado, eventos sincronizantes alteram simultaneamente os estados locais dos autômatos envolvidos permitindo a construção de dependência entre estes.
Um evento é disparado de acordo com a definição de uma taxa de ocorrência ou taxa de transição.
A taxa de ocorrência de um determinado evento é classificada de duas maneiras distintas:
O uso de funções é a principal característica que difere SAN em relação a outros formalismos de modelagem, tais como Redes de Petri e Cadeias de Markov.
O estado global de um modelo SAN é dado por a concatenação dos estados locais dos autômatos da rede.
Conforme descrito anteriormente, devido a a presença de dependência entre autômatos gerada por a existência de eventos sincronizantes e taxas funcionais, há a possibilidade de haver estados globais que não possam ser atingidos dentro de o espaço produto (Product State parcial de atingibilidade ou partial reachability que é usada para definição dos estados iniciais do modelo os quais são utilizados como ponto de partida para geração do Espaço de Estados Atingíveis ou Reachable State Space (RSS).
Para ilustrar o formalismo SAN, considere a Figura 2.1 a qual apresenta um modelo simples com dois autômatos, A1 e A2.
As transições L2 e L3 são guiadas por eventos locais alterando somente os estados locais destes autômatos de maneira independente, possuindo taxas constantes t3 e t4, respectivamente.
A transição S1 é guiada por um evento sincronizante e altera simultaneamente o estado dos dois autômatos, com taxa t1.
Por fim, a transição identificada por L1 é guiada por um evento local possuindo taxa funcional sendo disparada com taxa t2 caso o autômato A2 esteja num estado diferente de E. Caso contrário, a transição não ocorrerá.
Exemplos de modelos SAN os quais serão utilizados na condução dos experimentos (Capítulo 5) podem ser encontrados no Apêndice A. Diagramas de Decisão O uso de diagramas de decisão tem ganhado bastante atenção no contexto de modelagem e verificação de circuitos digitais e software.
A representação e manipulação de espaços de estados utilizando estas estruturas de dados, de entre outras técnicas de redução do problema da explosão do espaço de estados, levou ao surgimento do conceito de Verificação de Modelos Simbólica.
De entre os tipos de diagramas de decisão pode- se citar os Binary Decision Diagrams (BDD) ou Diagramas de Decisão Binária, Multivalued Decision Diagrams (MDD) ou Diagramas de Decisão Multi--valorada, entre outros.
De outro lado, Diagramas de Decisão Multi--valorada (MDD) são multi-grafos acíclicos dirigidos com arestas rotuladas as quais aceitam múltiplos valores para ligação entre os nodos.
A diferença básica comparada aos diagramas de decisão binária é permitir a representação de um conjunto mais abrangente de informações, possuindo as seguintes propriedades:
Nodos são organizados em N+ 1 níveis, onde N é o número de componentes do sistema podendo ser o número de autômatos de um modelo SAN, por exemplo;
Nível N possui apenas um nodo não-terminal r (nodo root), enquanto do nível N -- 1 até o nível 1 há um ou mais nodos não-terminais;
Nível 0 tem dois nodos terminais:
0 e 1;·
Um nodo não-terminal p num nível l contém nl arcos apontando para nodos no nível l -- 1;·
Não há duplicação de nodos com características semelhantes.
As propriedades acima descritas podem ser visualizadas tomando a Figura 2.3 como base, a qual representa a codificação do espaço de estados atingível de um modelo SAN do problema do Jantar dos Filósofos para três filósofos, sendo este último detalhado no Apêndice A. 1.
Entretanto, como os estados são armazenados de maneira simbólica, é necessário conhecer o significado dos dados que os compõe:
O valor 0 indica que o filósofo i está no estado P ensando, 1 indica que o filósofo está no estado QuerComer e 2 indica que o filósofo está no estado Comendo, respectivamente.
Conforme descrito na Seção 2.1, um estado global de um modelo SAN é dado por a concatenação dos estados locais dos autômatos do modelo.
De essa maneira, para representação de um estado global para este modelo, como por exemplo, todos autômatos estarem no estado P ensando, o respectivo estado estaria codificado na estrutura MDD da seguinte maneira:,
onde cada valor de índice i corresponde ao estado local de um autômato que representa um filósofo j.
SAN do Jantar dos Filósofos para três filósofos.
Lógicas Temporais Lógica temporal é um formalismo matemático que pode ser utilizado para descrição de sequências de transições entre estados em sistemas reativos sem fazer menção explícita ao tempo.
Basicamente, uma fórmula da lógica temporal define uma relação de ordem entre estados globais de um sistema que obedecem certas propriedades.
O seu emprego para expressão de propriedades sobre modelos de estados finitos tem ganhado importância no decorrer de os anos.
Inúmeras ferramentas de verificação de modelos têm sido desenvolvidas trazendo o benefício do uso de lógicas temporais para eficiente verificação de sistemas e um conjunto muito importante de propriedades.
De entre as lógicas temporais pode- se citar a Linear Temporal Logic (LTL), Computation Tree Logic (CTL) e Extended Computation Tree Logic (CTL), as quais diferem basicamente por a noção de tempo que abrangem.
Em resumo, a LTL trabalha sobre uma perspectiva de tempo linear apresentando a vantagem de expressar propriedades sobre um único caminho de computação.
A CTL, por sua vez, apresenta a vantagem de permitir a expressão de propriedades sobre um ou todos os caminhos de uma estrutura de estados ramificada.
Por fim, a CTL possui comportamento similar à CTL, porém é mais abrangente no que tange a expressão de propriedades permitindo a combinação de características de ambas as lógicas, LTL e CTL.
Este trabalho adota a lógica temporal Computation Tree Logic para expressão de propriedades sobre modelos SAN, sendo detalhada a seguir.
A Computation Tree Logic é uma lógica temporal baseada na lógica proposicional que abrange uma noção ramificada de tempo e tem por objetivo permitir a expressão de propriedades sobre o comportamento de sistemas.
Quanto a a escrita de propriedades, as fórmulas CTL permitem que se expresse propriedades de algumas ou todas as computações que iniciem num determinado estado de um sistema, sendo compostas por quantificadores de caminho, operadores temporais e proposições atômicas.
Quantificadores de caminho são utilizados para determinar o ramo da árvore de estados que será abrangido.
Há dois quantificadores de caminho distintos: (pronunciado &quot;para todos os caminhos&quot;) também representado por A, indicando que todos os caminhos de computação possíveis devem respeitar determinada condição, e (pronunciado &quot;existe um caminho&quot;) também representado por E, que indica que determinada condição será atendida em pelo menos um ramo da estrutura ramificada de estados.
Os operadores temporais, por sua vez, têm por objetivo indicar a ordenação temporal de ocorrência de eventos sobre um ramo da árvore de estados.
Basicamente, a CTL é composta por quatro operadores temporais, sendo:
Chamado Next, simbolizando &quot;em o próximo estado», também representado por X. Este operador indica a ocorrência de determinada condição num estado sucessor ao estado em que se encontra o sistema em determinado momento; --
Chamado Eventually, simbolizando &quot;em um estado futuro», também representado por F.
Este operador indica a ocorrência de determinada condição num estado futuro ao estado em que se encontra o sistema em dado momento;
Chamado Globally, simbolizando &quot;globalmente», também representado por G. Este operador indica a ocorrência de determinada condição globalmente, ou seja, em todos os estados sucessores do estado atual do sistema; --
Chamado Until, simbolizando &quot;até que».
Este operador indica a precedência entre eventos num dado momento, indicando que determinada condição deve ser verdade até o momento em que outra condição venha a ser satisfeita.
Por fim, as proposições atômicas -- Atomic Propositions (AP) -- são usadas para formalizar condições de interesse nos estados do sistema sob consideração podendo ser definidas como expressões as quais tem o objetivo de descrever um determinado comportamento sobre um modelo.
Além de os quantificadores de caminho, operadores temporais e proposições atômicas, a composição Uma fórmula CTL válida possui sintaxe mínima definida:
A gramática acima define o que se chama de fórmulas estado (state formulae) que são afirmações sobre as proposições atômicas nos estados e suas estruturas ramificadas, onde:
A pertence ao conjunto das proposições atômicas AP.
Simboliza fórmulas caminho (path formulae) as quais expressam propriedades temporais de caminhos, sendo formadas de acordo com a seguinte gramática mínima:
Onde:, 1 e 2 são fórmulas estado.
Intuitivamente, fórmulas estado expressam propriedades de um único estado, enquanto fórmulas caminho expressam propriedades de um caminho o qual pode ser uma sequência infinita de estados.
Exemplos de fórmulas CTL e seus comportamentos temporais sobre estruturas ramificadas de tempo podem ser visualizados na Figura 2.4.
Mais detalhes sobre a sintaxe e semântica da lógica temporal Computation Tree Logic são encontrados em.
De acordo com Baier e Katoen e Clarke, Grumberg e Peled, fórmulas CTL são interpretadas sobre estados e caminhos de um sistema de transição T S. A relação de satisfação para CTL é definida da seguinte maneira:
Sendo TS $= (S, Act, I, AP, L) um sistema de transição de estados sem estados terminais tal que:
S é um conjunto de estados;
Act é um conjunto de ações;
I S é um conjunto de estados iniciais;
AP é o conjunto de proposições atômicas;
L: S 2 AP é a função de rotulação.
E tendo- se uma proposição atômica a tal que a AP, um estado s S, e sendo fórmulas CTL válidas, e sendo uma fórmula CTL caminho, a relação de satisfação| $= para fórmulas estado é definida por:
Para um caminho, a relação de satisfação| $= para fórmulas caminho é definida por:
Isto é, $= si.
A Figura 2.4 apresenta algumas fórmulas CTL simples, sendo semanticamente assim descritas: (
p) -- Para todos os caminhos, em todos os estados, p deve ser satisfeito.
Esta propriedade denota um comportamento global em todos caminhos e estados possíveis da computação. (
p) -- Para todos os caminhos, no futuro, p deve ser satisfeito.
A propriedade denota a existência de um ou mais estados que satisfaçam p em dado momento, para todos caminhos de computação. (
p) -- Para todos os caminhos, no próximo estado, p deve ser satisfeito.
A propriedade descreve um comportamento num estado sucessor de um dado estado para todos caminhos de computação. (
p c) -- Para todos os caminhos, p é verdade até que c seja satisfeito.
A propriedade demonstra a precedência na ocorrência de um evento p para que o evento c ocorra, sendo c um estado sucessor de p..
A sintaxe deste operador indica ainda que, sendo c válido em todos os caminhos, não é necessária a ocorrência de p nestes mesmos caminhos para que a fórmula seja válida. (
p) -- Existe um caminho na árvore de estados em que em todos estados p é satisfeito.
A propriedade demonstra a ocorrência de pelo menos um caminho de computação onde p é sempre verdade. (
p) -- Existe um caminho onde, no futuro, em pelo menos um estado p é verdade.
Para a propriedade ser válida, deve haver pelo menos um estado que satisfaz p na árvore de estados, não importando o ramo. (
p) -- Existe um caminho onde, no próximo estado, p deve ser satisfeito.
Propriedade válida somente para os estados que possuam como sucessores estados que satisfazem p. (p c) -- Existe um caminho onde p é satisfeito até que c venha a ser válido.
Fórmula válida em pelo menos um caminho da árvore onde, para c ser satisfeito, p deve ser satisfeito em pelo menos um estado antecessor direto de c..
A CTL possui formatos de equivalência para escrita de propriedades.
A Existential Normal Form (ENF) ou Forma Normal Existencial, a qual é um formato comumente aceito por ferramentas de verificação, permite a escrita de toda fórmula CTL válida através do emprego do quantificador de caminho existencial e leis de equivalência e operadores da lógica proposicional.
Segundo Baier e Katoen, os operadores básicos, e são suficientes para definir toda a sintaxe desta lógica temporal.
Tendo a pertencendo ao conjunto das proposições atômicas AP, o conjunto de fórmulas CTL em Forma Normal Existencial pode ser definido através da seguinte sintaxe:
Para cada fórmula CTL, existe uma fórmula equivalente em ENF.
Para prova deste teorema é necessário levar em consideração algumas leis de dualidade que permitem a eliminação do quantificador universal:
Quando se implementa a tradução de uma fórmula CTL para ENF também pode- se usar regras análogas para os operadores derivados, tais como:
Quando de a transcrição de uma fórmula CTL para Forma Normal Existencial através das regras acima, a fórmula resultante apresenta crescimento quase que exponencial aumentando consideravelmente o tempo de verificação de um modelo, sendo este linear ao tamanho da fórmula.
Para exemplificação deste comportamento, basta considerar a tradução da fórmula () a qual Verificação de Modelos Em as últimas décadas algumas técnicas tem sido empregadas para minimizar o trabalho relacionado a garantir correta especificação de sistemas nos estágios iniciais do ciclo de desenvolvimento, tais como:
Simulação, testes e verificação formal de hardware e software.
Enquanto simulação e testes exploram alguns comportamentos possíveis e cenários desejados de um sistema, porém não provando a ausência de erros, técnicas de verificação formal como Model Checking conduzem exaustiva exploração de todos os comportamentos possíveis de um sistema.
Comparada à outras abordagens, esta técnica apresenta a vantagem de ser totalmente automática não requerendo supervisão do usuário nem conhecimentos matemáticos avançados.
Ainda, a possibilidade de geração de contra-exemplos e testemunhas é outra característica interessante da mesma, as quais descrevem importantes informações para depuração do modelo sob verificação.
Em este contexto, falhando a verificação de uma propriedade, um contra-exemplo é gerado para o usuário demonstrando um comportamento inadequado (error- trace) presente no modelo.
Segundo Clarke, utilizando- se a lógica temporal CTL para descrição de propriedades e sendo a fórmula composta por um quantificador de caminho universal, a ferramenta deve gerar um caminho de computação em que a negação da fórmula é verdade.
Em outras palavras, por exemplo, se a verificação da fórmula f retornar falso, a ferramenta deve produzir um caminho onde¬ f é satisfeito.
Caso a verificação retorne um resultado positivo, uma testemunha é gerada demonstrando um caminho de computação que ratifica a propriedade.
Similarmente, sendo verdadeira a verificação de uma fórmula quantificada existencialmente como, por exemplo, f, a ferramenta deve produzir um caminho para um estado em que f seja satisfeito.
O trabalho do usuário/ especificador de uma ferramenta de verificação pode ser descrito num conjunto bem definido de passos:
Modelagem, especificação e verificação, conforme demonstrado na Figura 2.5.
Como primeira tarefa, a modelagem tem o objetivo de que se converta uma determinada realidade, tal como o funcionamento de um algoritmo, para um formalismo que seja aceito por uma ferramenta de verificação, podendo esta etapa ainda ser conhecida como uma tarefa de compilação.
Após a modelagem, é necessário que sejam elencadas propriedades as quais se deseja verificar.
Esta especificação normalmente é feita em algum formalismo lógico.
Para sistemas de hardware e software, comumente usa- se lógicas temporais, já abordadas na Seção 2.3, que permitem a descrição de afirmativas sobre a evolução do comportamento de um sistema no decorrer de o tempo, sem a necessidade de introduzir tempo explicitamente.
Por fim, algoritmos de verificação avaliam exaustivamente os estados do modelo de entrada em busca de estados que satisfaçam as propriedades elencadas na fase de especificação.
A verificação, apesar de ser automática, envolve assistência humana para análise dos resultados gerados, sendo esta etapa a interpretação das testemunhas e contra-exemplos gerados por a ferramenta adotada.
Para melhor entendimento desta fase, a descrição de um algoritmo de verificação de propriedades CTL é feita no Capítulo 3.
Model Checking é uma técnica que pode ainda ser descrita de maneira formal.
Dada uma estrutura de Kripke M $= onde:
Verificação de Modelos Paralela e Distribuída A a medida que se aumenta a complexidade do design de um modelo a sua verificação se torna uma tarefa custosa tanto em termos de tempo quanto espaço.
Em os últimos anos, grandes esforços têm sido empregados no que tange ao desenvolvimento de técnicas que venham a lidar com o problema da explosão do espaço de estados, possibilitando a verificação de modelos com grandes quantidades de atributos.
De entre estas técnicas é possível citar o uso de verificação de modelos simbólica utilizando- se diagramas de decisão, métodos que explorem simetria, redução de ordem parcial e técnicas de verificação paralelas e distribuídas, sendo estas últimas o foco deste trabalho.
Abordagens de verificação de modelos paralelas e distribuídas têm sido utilizadas com o intuito de lidar com o problema da explosão do espaço de estados empregando máquinas poderosas e consideráveis quantidades de memória.
Devido a o crescente avanço na concepção de máquinas com essas características, o surgimento de algoritmos que explorem ambientes computacionais com memória e processamento distribuídos além de ambientes que usufruam de memória compartilhada são alternativas viáveis aos tradicionais algoritmos sequenciais de verificação.
O uso de máquinas com processamento e espaços de memória distribuídos é relacionado a lidar com o problema da explosão do espaço de estados utilizando- se abordagens baseadas em particionamento de espaços de estados.
Entretanto, o principal desafio da construção de ferramentas de verificação que explorem estes ambientes é criar conjuntos disjuntos de estados com certo grau de qualidade os quais serão atribuídos a diferentes processadores para conduzir computações em paralelo.
Mecanismos propostos para ambas técnicas existentes de representação e manipulação de espaços de estados (explícitas e simbólicas) dependem da função de particionamento adotada.
Estas funções tem como objetivo gerar conjuntos de estados balanceados reduzindo a presença de transições que atravessam as partições geradas, também conhecidas como cross-partition transitions.
Uma transição com estas características pode ser descrita como uma transição entre estados localizados em partições distintas.
Como consequência, o cálculo de estados sucessores ou antecessores de um dado estado pode requerer comunicação, uma vez que o espaço de estados é representado em pequenos conjuntos distribuídos.
Técnicas de particionamento basicamente diferem por a natureza da função de particionamento adotada visando prover balanceamento e localidade.
Balanceamento pode ser classificado em:
Espacial -- Cada processador na rede receberá porções de estados com o mesmo número de estados;
Temporal -- Cada processador estará ocupado a maior parte do tempo, isto é, realizando a verificação de estados, passando pouco tempo bloqueado e/ ou trocando mensagens.
Localidade pode ser definida como a atribuição de estados que sejam relacionados durante uma verificação ao mesmo processador.
Tipicamente, estados sucessores de um dado estado devem ser manipulados por o mesmo processador visando diminuir a troca de mensagens.
De entre as técnicas de particionamento de espaços de estados pode- se citar a existência de funções de particionamento estáticas, dinâmicas e guiadas por o usuário, as quais serão brevemente relatadas a seguir.
Funções estáticas são baseadas numa função matemática a qual tem o objetivo de particionar o espaço de estados sem levar em consideração informações estruturais acerca de o modelo, somente entregando partições balanceadas espacialmente.
De essa maneira, as partições geradas podem possuir um número elevado de transições entre as mesmas sofrendo de sobrecarga de comunicação entre as diferentes máquinas empregadas durante a fase de verificação.
Funções de particionamento estáticas são as mais utilizadas podendo se confirmar por a grande quantidade de ferramentas disponíveis (Divine, Mur e UPPAAL), entre outras.
De outro lado, funções dinâmicas de particionamento de espaços de estados tentam distribuir porções de estados para diferentes processadores sem a necessidade de conhecimento prévio do sistema.
Geralmente, uma função dinâmica de particionamento inicialmente atribui um subconjunto de estados do espaço para cada nodo e, quando certas condições se tornam verdade como, por exemplo, por falta de memória principal, o algoritmo reatribui alguns estados para nodos diferentes.
Em contraste, para Lerda, a função de particionamento é adaptada em tempo de verificação usando informações sobre as relações entre os estados colhidas durante execução para melhor atender o sistema que está sendo verificado.
Ainda, esta técnica de particionamento possui como benefício ser eficiente no que tange a balanceamento de memória, entretanto requerendo altos níves de comunicação e complexidade de implementação, embora permitindo balanceamento de carga e versatilidade.
Por outro lado, minimizar o número de transições entre as partições geradas também é importante.
Alguns trabalhos relacionados computam uma pequena aproximação do espaço de estados possibilitando a extração de informações acerca de as relações entre os estados, facilitando assim a escolha dos conjuntos de estados a serem distribuídos.
Por fim, funções de particionamento de espaços de estados guiadas por o usuário dependem da experiência do mesmo sobre o sistema.
Em, Ciardo Propõe uma função de particionamento baseada na estrutura de Redes de Petri visando prover balanceamento e localidade levando em consideração apenas um conjunto de estados, chamado por os autores de conjunto controle P.
Em geral, qualquer transição que seja disparada e não involva um dado em P corresponde a uma transição entre estados que estão atribuídos ao mesmo processador, caso contrário, a respectiva transição corresponde a estados atribuídos à diferentes partições.
Para Lerda e Sisto, quando um nodo computa um novo estado, primeiramente verifica se este estado pertence ao seu subconjunto de estados ou ao subconjunto de outro nodo.
Sendo local, o nodo prossegue a verificação normalmente, caso contrário uma mensagem contendo o estado é enviada ao respectivo &quot;dono «do estado.
A desvantagem desta abordagem é a não-existência de uma forma automática de seleção do conjunto de controle, dependendo fortemente da intuição do usuário em selecionar- lo.
Algumas abordagens similares são apresentadas em e.
De outro lado, o desenvolvimento de processadores multi-core, ou seja, que possuam mais de um núcleo de processamento encapsulado no mesmo chip, tem recebido amplos esforços nos últimos anos, uma vez que o seu emprego é uma alternativa viável devido a a barreiras atingidas por a indústria de semicondutores, tais como:
Aumento de frequência dos processadores, dificuldade para eficiente dissipação de calor e diminuição do tamanho de determinados componentes.
Seguindo esta evolução do hardware, ferramentas de verificação as quais usufruam de ambientes multi-core e memória compartilhada têm sido amplamente estudadas buscando alternativas a ambientes que endereçam espaços de memória distribuídos.
A principal vantagem que ambientes com memória compartilhada oferecem sobre memória distribuída é justamente prover estruturas de dados compartilhadas para manipulação concorrente, sem a necessidade de troca de mensagens e evitando o desenvolvimento de algoritmos complexos de particionamento de espaços de estados.
A diferença entre os algoritmos paralelos para memória compartilhada reside na estrutura de dados adotada e a estratégia de balanceamento de trabalho escolhida para distribuir trabalho entre os processadores.
Consequentemente, técnicas de sincronismo se fazem necessárias de serem implementadas, uma vez que garantir acesso concorrente de maneira mutuamente exclusiva é, obviamente, de fundamental importância.
Mesmo o foco deste trabalho visando ambientes com memória distribuída, uma breve descrição acerca de técnicas de verificação para ambientes que compartilham memória é feita a seguir.
De entre os trabalhos que exploram ambientes com memória compartilhada pode- se citar, Diferentemente de outras abordagens, os autores utilizaram árvores balanceadas para armazenamento de dados compartilhados entre os processos participantes ao invés de hash tables, as quais são a estrutura comumente utilizada na maioria das abordagens de verificação para ambientes com estas características.
Existem três abordagens para distribuição de trabalho que são adotadas quando de o uso de soluções compartilhadas baseadas em hash tables:
Static-slicing, work stealing e stack-- slicing.
Conforme anteriormente mencionado, a ferramenta DiVine é baseada numa estratégia de particionamento estático (static-slicing), possuindo ainda uma versão para máquinas com memória compartilhada, a qual segue as mesmas linhas da implementação distribuída.
Esta estratégia distribui os estados para cada processador participante sem levar em consideração informações sobre as relações entre os mesmos apresentando ganhos de tempo satisfatórios sendo vantajosa no que tange à simplicidade de implementação.
Inggs Propõe um algoritmo paralelo para exploração de estados baseado num paradigma de escalonamento work-- stealing o qual visa garantir balanceamento dinâmico de trabalho sem fases de bloqueio.
O conceito básico deste algoritmo permite que processadores sub-utilizados possam &quot;roubar «trabalho de outros processadores, ou seja, a estratégia permite um processador ocioso realizar algumas das tarefas que estejam na fila de trabalho de um processador sobrecarregado.
Esta implementação utiliza duas estruturas de filas em cada processo participante, sendo uma fila privada e outra compartilhada que são utilizadas para armazenar estados não-expandidos (&quot;unexpanded «segundo o autor, ou não visitados).
Toda vez que um processo ou thread não mais possuir estados a serem explorados em sua fila privada, tem de adquirir acesso mutuamente exclusivo a sua fila compartilhada e verificar a existência de estados disponíveis.
Não encontrando estados, o processo inicia a busca em todas as filas compartilhadas dos outros processos envolvidos até achar uma fila não-vazia ou verificar que todas as filas estão vazias, o que indica o final da computação.
Por fim, Holzmann E Laarman Empregaram o paradigma stackslicing para distribuição de trabalho entre processadores.
Em estes trabalhos, os autores utilizam filas compartilhadas para &quot;conectar «os processadores de maneira que se crie uma estrutura em forma de anel onde cada processador tem a capacidade de entregar trabalho ao seu vizinho à direita.
Como vantagem, os autores citam a possibilidade de que cada fila de trabalho possua apenas um processo realizando leitura e um realizando escrita ao mesmo tempo, facilitando assim a implementação de mecanismos de bloqueio e atingindo bons resultados de tempo.
Conforme anteriormente descrito, SAN conta com interessantes aspectos em relação a outros formalismos como, por exemplo, possibilidade de criação de dependência entre autômatos através de eventos sincronizantes e taxas funcionais.
Entretanto, a inexistência de ferramental de verificação para tal formalismo acaba dificultando a verificação de propriedades sobre modelos SAN.
De esta maneira, através de um trabalho cooperativo, esforços foram investidos na construção de um verificador de propriedades escritas na lógica temporal Computation Tree Logic, tendo os primeiros resultados discutidos em e.
Este capítulo foca na descrição da arquitetura da ferramenta de verificação inicialmente desenvolvida, a qual é base para discussão das abordagens paralelas neste trabalho propostas, sendo estas a contribuição do autor no escopo do projeto de pesquisa.
Para armazenamento e manipulação do espaço de estados gerado por modelos descritos em SAN empregou- se diagramas de decisão multi-valorada, os quais são abordados na Seção 2.2, tendo sua implementação detalhada em e.
A Figura 3.1 apresenta os processos (representados por retângulos) e dados (representados por paralelogramos) necessários à verificação de propriedades com a ferramenta, os quais são descritos da seguinte maneira:
Modelo SAN -- o modelo SAN a ser verificado descrito em formato textual;
Estado Inicial -- um ou mais estados iniciais devem ser definidos na função partial reachability.
Esta função é o ponto de partida para a geração do espaço de estados atingível (RSS);
Proposições atômicas -- conforme descrito na Seção 2.3, proposições atômicas são asserções sobre o modelo que avaliam verdadeiro ou falso sob dado estado global do modelo.
Em a arquitetura da ferramenta, uma proposição atômica é uma expressão de SAN a qual não possui operadores da lógica temporal;
Propriedades CTL -- propriedades descritas em CTL em que as proposições atômicas sejam definidas como expressões SAN.
Exemplos são apresentados no Capítulo 5;·
Compilador -- o compilador é responsável por gerar o Descritor Markoviano o qual representa implicitamente uma Cadeia de Markov.
Um Descritor Markoviano é composto por um conjunto de tensores que, ao ser operado por álgebra tensorial permite que sejam alcançados todos os elementos da Cadeia de Markov de forma implícita, sendo extremamente eficiente no que tange à armazenamento em memória.
As operações (soma tensorial ou produto tensorial) reproduzem as interações e como os autômatos sincronizam o disparo de eventos de um modelo SAN;
Geração do Espaço de Estados atingível -- uma vez que o Descritor Markoviano é usado como a função de transição do sistema, dado um estado inicial do modelo, o algoritmo responsável por a geração do RSS verifica nos tensores do descritor se há algum evento habilitado a ser disparado.
Havendo evento e possuindo taxa constante, o sucessor do respectivo estado pode ser alcançado e este estado é computado no RSS o qual é codificado como um MDD.
Como a técnica de geração do RSS é baseada em saturação, a política de disparo de eventos é guiada por o algoritmo de saturação o qual dispara eventos por nodo, de maneira bottom-up (de baixo para cima), exaustivamente, em vez de disparar por níveis um por iteração.
Um nodo do MDD é dito saturado quando codifica um conjunto de estados que caracterizam um ponto fixo com respeito a o disparo de qualquer evento neste nível ou nos níveis abaixo;
Função de rotulação -- esta função rotula os estados atingíveis com o conjunto de proposições atômicas que são verdade em cada estado.
Dado o conjunto de proposições atômicas e o RSS, a função cria um MDD para cada proposição atômica codificando os estados que são verdade na referida proposição;
Analisador CTL -- este módulo é responsável por manipular e armazenar a fórmula CTL de entrada numa árvore sintática;
Conversor ENF -- este módulo é responsável por manipular a árvore sintática e transcrever a fórmula CTL para Forma Normal Existencial.
Para tanto, utilizou- se as regras de equivalência de fórmulas descritas em (página 332), as quais foram apresentadas na Seção 2.3;·
Algoritmo de Satisfação de Fórmulas CTL (SAT) -- este algoritmo executa a verificação da fórmula de entrada sobre o modelo.
A sua implementação é baseada no algoritmo de satisfação de fórmulas CTL em ENF apresentado em, o qual é detalhado a seguir;
Entrada: Sistema de transição finito T S com conjunto de estados S (RSS) rotulado para L (s) e fórmula em ENF true:
Para melhor entendimento do algoritmo de verificação adotado, considere a Figura 3.2 que o descreve em alto nível.
Conforme mencionado anteriormente, o algoritmo somente aceita como entrada fórmulas escritas em ENF, sendo um formato suficiente para representar toda e qualquer fórmula CTL válida.
O algoritmo Sat é executado recursivamente através da árvore sintática que passos são executados:
Caso a:
No caso de proposições atômicas, o algoritmo retorna o conjunto de estados que satisfazem a proposição a..
Caso¬: Caso negação(¬), o algoritmo realiza a diferença entre o conjunto de estados S, ou os estados que não satisfazem.
Caso: Se a fórmula for, o algoritmo avalia os estados pertencentes ao RSS retornando como resultado o conjunto de estados tal que a intersecção dos sucessores destes estados com o conjunto de estados que satisfaz a fórmula seja diferente de vazio.
Caso contrário, o estado em avaliação não satisfaz.
Caso: Partindo da semântica deste operador é necessário que 2 seja verdade para que o operador seja satisfeito sob um conjunto de estados.
Essa definição estabelece o menor ponto fixo para este operador.
Após as execuções de Sat e Sat (2), a diferença entre os conjuntos de estados resultantes é realizada tendo o resultado armazenado em T.
Para cada estado pertencente a este conjunto, o algoritmo realiza a intersecção dos estados sucessores com o conjunto de estados que satisfaz 2 e, caso não-vazia, adiciona o estado em avaliação no conjunto 2.
Estes passos são executados repetidas vezes até que o conjunto T atinja um ponto fixo, ou seja, o momento em que não sejam adicionados mais estados ao conjunto 2.
T é avaliado executando- se estes mesmos passos repetidas vezes até atingir um ponto fixo, ou seja, um conjunto de estados em que não mais se removam estado.
O retorno do algoritmo será o conjunto de estados restantes em T.
Considerando o problema da verificação de modelos o qual visa o desenvolvimento de ferramentas eficientes no que tange a uso de memória e tempo para verificação de propriedades sobre complexas realidades, o emprego de máquinas poderosas e algoritmos paralelos e distribuídos é de fundamental importância.
Devido a a redução do custo de produção dessas máquinas o acesso a tais recursos tem sido facilitado à comunidade científica, impulsionando o desenvolvimento de algoritmos paralelos e distribuídos para ambas técnicas de representação de espaços de estados, explícitas e simbólicas.
Apesar de o ganho em memória provido por o emprego de estruturas de dados simbólicas, a medida que se aumenta a complexidade da realidade modelada é natural que recursos computacionais de máquinas simples venham a se esgotar.
Embora estas estruturas permitam representar eficientemente grandes conjuntos de estados, as tarefas relacionadas à computação dos operadores de lógica temporal necessitam de estruturas auxiliares para obtenção do resultado da verificação, o qual é consideravelmente inferior em consumo de memória em relação a a estas estruturas.
Conforme descrito na Seção 2.5, ferramentas de verificação de modelos que se utilizam de ambientes providos com espaços de memória distribuídos são projetadas a lidar com o problema da explosão do espaço de estados distribuindo conjuntos disjuntos de estados para diferentes máquinas empregando- se considerável poder computacional e espaços de memória.
Embora o emprego destes ambientes permita a representação de grandes espaços de estados, algoritmos que dependam de técnicas de particionamento podem sofrer sobrecarga de comunicação durante a fase de verificação.
Sendo o espaço de estados representado de maneira distribuída, estados relacionados através de transições podem estar localizados em diferentes processadores requerendo comunicação durante a computação, possivelmente implicando em perda de desempenho.
Conforme anteriormente mencionado, representar consideráveis conjuntos de estados de forma simbólica requer pequenos espaços de memória, de modo que a representação do RSS em sua íntegra em máquinas empregadas para verificação de propriedades habilita as mesmas a calcular estados sucessores de um dado estado localmente.
De esta maneira, comunicação acaba sendo necessária somente para cálculo de ponto fixo no âmbito da verificação.
Considerando estas características, duas abordagens paralelas são propostas visando ambientes com processamento e memória distribuídos, sendo:
Primeira abordagem:
Possuindo cada máquina uma réplica do espaço de estados e respectiva função de transição, a verificação dos operadores de maior custo computacional, isto é, aqueles em que seja necessária avaliação iterativa de um conjunto de estados até obtenção de ponto fixo, pode ser conduzida de maneira distribuída, de forma que as máquinas empregadas estejam habilitadas a explorar frações distintas do conjunto de estados em consideração.
De esta maneira, comunicação é necessária somente para cálculo de ponto fixo.
A Seção 4.1 detalha os algoritmos desenvolvidos para esta abordagem;
Segunda abordagem:
Conforme relatado na Seção 2.3, a transcrição de uma fórmula CTL para Forma Normal Existencial pode aumentar exponencialmente seu tamanho, implicando no aumento do tempo de verificação, o qual é linear ao tamanho da fórmula.
De esta maneira, considerou- se como segunda abordagem, além de a distribuição da verificação de conjuntos de estados para os operadores mais custosos da lógica temporal adotada, a distribuição de determinadas partições da árvore sintática que representa a fórmula computacionalmente.
A tarefa de verificar uma propriedade consideravelmente grande é realizada através de um algoritmo que analisa e escolhe as partições da árvore sintática ENF equivalente e as distribui para computação em paralelo.
Para cada partição, grupos de máquinas são empregadas para computação das tarefas relacionadas à verificação dos operadores mais custosos presentes, através da primeira abordagem descrita.
Para esta abordagem, replicação do espaço de estados e respectiva função de transição também se faz necessária.
A Seção 4.2 detalha os algoritmos desenvolvidos.
Além de a redução no tempo de execução de uma verificação, reduzir o consumo de memória é esperado em algoritmos distribuídos.
Embora as abordagens propostas por este trabalho pareçam pouco eficientes uma vez que réplicas do espaço de estados são feitas, ganhos em consumo são possíveis devido a a distribuição das operações relacionadas à verificação.
Conforme anteriormente mencionado, estando o aumento do consumo de memória por a estrutura simbólica adotada unicamente ligado à computação dos operadores de lógica temporal, a distribuição das tarefas relacionadas à computação dos mesmos permite considerável diminuição no consumo de memória de cada máquina empregada.
Exemplos deste comportamento serão discutidos no Capítulo 5.
Distribuindo a computação de operadores CTL Em esta seção são descritos os algoritmos desenvolvidos para distribuição das tarefas relacionadas à computação de operadores da lógica temporal Computation Tree Logic utilizando- se a abordagem de programação mestre/ escravo.
Vale destacar que o algoritmo de verificação adotado somente aceita como entrada fórmulas escritas em Forma Normal Existencial.
Sendo assim, foram desenvolvidos algoritmos paralelos para os operadores, e, os quais em conjunto com operadores da lógica proposicional(¬ e) formam a base para derivação de qualquer operador da CTL.
Não foram desenvolvidos algoritmos distribuídos para verificação dos operadores da lógica proposicional, uma vez estas operações são mapeadas para simples operações sobre conjuntos de algoritmos em que troca de mensagens se faz necessária.
Tarefas do Processo Mestre Antes de introduzir os algoritmos para cada operador, é importante que fiquem claras as tarefas delegadas ao processo mestre, sendo:
Compilar o modelo SAN gerando o Descritor Markoviano e calcular o espaço de estados atingível.
Este último é armazenado na estrutura MDD a qual possui as propriedades descritas na Seção 2.2;·
Transcrever a fórmula CTL de entrada para Forma Normal Existencial e amazenar- la numa árvore sintática;
Executar a função de rotulação (Labelling Function);
Replicar o Descritor Markoviano, RSS e proposições atômicas rotuladas para os processos escravos.
O algoritmo trabalha de maneira bottom-up e divide o trabalho de verificar os operadores, e entre máquinas escravas.
Conforme mencionado no Capítulo 3, o algoritmo de verificação adotado é recursivo.
De este modo, o processo mestre é também responsável por executar a recursão através da árvore sintática computando as operações¬ e sequencialmente.
A tarefa de unir os conjuntos de estados resultantes das computações das máquinas escravas é também por este executada.
A verificação de determinados operadores requer que se atinjam conjuntos de estados que respeitem um ponto fixo, ou seja, conjuntos de estados que não são alterados por a execução de um algoritmo.
De esta maneira, quando se verificam os operadores ou, um ponto fixo é atingido num dado momento em que nenhum processo escravo detecte a remoção ou adição de um estado no conjunto de estados que está sendo verificado.
Mais detalhes sobre os algoritmos para estes operadores são encontrados nas Seções 4.1.4 e 4.1.3.
Para troca de estados, estruturas simbólicas são utilizadas a fim de codificar conjuntos que possuam consideráveis números de estados, de maneira compacta.
Estas estruturas não são trafegadas através de mensagens, sendo armazenadas em arquivos em disco os quais sofrem operações de leitura e escrita durante a verificação.
Em as seções seguintes são descritos os algoritmos paralelos para os operadores anteriormente mencionados, bem como, as tarefas executas por ambos processos, mestre e escravos.
A Seção e execução de operações.
Computação Paralela de A característica principal do algoritmo para o operador é avaliar o conjunto de estados pertencente ao RSS buscando por estados em que a intersecção de seus posteriores com o conjunto de estados que satisfaz a sub-fórmula seja não-vazia.
Para a computação paralela deste operador, a qual é descrita em alto nível no Algoritmo 1, a tarefa de avaliar os estados pertencentes ao RSS é particionada em N -- 1 processos escravos, os quais executam os seguintes passos:
Recebem o conjunto de estados que satisfaz do processo mestre;
Avaliam conjuntos de estados do RSS de igual tamanho respeitando o algoritmo para, conforme descrito no algoritmo nas linhas 10 à 16;·
Retornam o conjunto de estados resultante (T2) ao processo mestre.
A avaliação deste operador não necessita o alcance de um ponto fixo o que permite a adoção de um número escalável de processos os quais podem trabalhar separadamente sem necessidade de rodadas de sincronia.
De esta maneira, a troca de mensagens fica limitada à ditar o início e fim da computação, compreendendo este último o retorno dos estados resultantes ao processo mestre, o qual é responsável por unir- los.
Entrada: P/ M estre -- sistema de transição finito T S com conjunto de estados S (RSS) rotulado para L (s) e fórmula em ENF Entrada:
P/ Escravos -- sistema de transição finito T S com conjunto de estados S (RSS) rotulado para L (s) e conjunto de estados que satisfazem tal que RSS e fórmula em ENF Saída:
P/ M estre -- conjunto de estados que satisfazem Saída:
P/ Escravos -- conjunto de estados avaliados por o processo j na partição k de S que satisfazem Dados:
MDD T, T2;
Dados: Estado s;
Início caso selecione faça se mestre então/* Início de computação distribuída para DisparaComputacaoP aralela (T);
Sincroniza (T);
Senão/* Processo escravo j avalia partição k do RSS seja s k se P ost (s) T! $=
então fim se fim para/* Processos escravos retornam T2 ao mestre fim se break;
DisparaComputacaoP aralela (T):
Envio de mensagem aos escravos indicando início da verificação do operador para conjunto T Sincroniza (T):
Recebimento e união dos estados resultantes vindos dos escravos P ost (s):
Recupera estados posteriores (sucessores) de um estado s L (s):
Conjunto de rótulos (labels) de um estado s, ou seja, proposições atômicas que são satisfeitas em s Computação Paralela de Tendo-se o RSS e o conjunto de estados resultante da diferença entre os conjuntos 1 e 2, o algoritmo para o operador realiza exaustiva busca por estados que possuam sucessores pertencendo ao conjunto 2 e, satisfeita esta regra, adiciona- os a este conjunto.
Estes passos são executados repetidas vezes até que se atinja um ponto fixo e o resultado para este operador é o conjunto de estados armazenado em 2.
O algoritmo executado por ambos processos mestre e escravos é descrito no Algoritmo 2.
Para obtenção de paralelismo na avaliação do operador, os processos escravos executam os seguintes passos:
Recebem do processo mestre os conjuntos de estados que satisfazem 1 e 2.
Cada conjunto é carregado em memória uma única vez;
Calculam a diferença entre 1 e 2 (R\ T), conforme descrito na linha 18 do algoritmo;
Avaliam uma partição de estados que pertence a diferença acima mencionada respeitando o algoritmo para o operador;
Enviam ao processo mestre o conjunto de estados locais resultantes, ou seja, estados adicionados ao conjunto 2.
Em este caso, retorna- se o conjunto saída local T2 (linha 26);
Aguardam o momento em que o processo mestre executa uma rodada de sincronia enviando o conjunto global de estados adicionados;
Adicionam os estados em 2 vindos do processo mestre por a respectiva rodada de sincronia.
Este passo é executado juntamente com o algoritmo de tratamento de mensagens (Message Handler), detalhado na Seção 4.1.5;·
Repetem do passo dois em diante a avaliação de estados em seus conjuntos locais de estados até o processo mestre detectar a obtenção de um ponto fixo, ou seja, não mais se adicionam estados em 2.
Entrada: P/ M estre -- sistema de transição finito T S com conjunto de estados S (RSS) rotulado para L (s) e fórmula em ENF Entrada:
P/ Escravos -- sistema de transição finito T S com conjuntos de estados que satisfazem 1 e 2 tal que 1 RSS e 2 RSS e fórmula em ENF Saída:
P/ M estre -- conjunto de estados que satisfazem Saída:
P/ Escravos -- conjunto de estados adicionados em T por o processo de índice j Dados:
MDD R, T, T2, D;
Dados: Estado s;
Início caso selecione faça se mestre então enquanto true faça/* Envia mensagem aos escravos indicando início de computação DisparaComputacaoP aralela (R, T2);
DisparaComputacaoP aralela (R, T2):
Envio de mensagem aos escravos indicando início da verificação do operador para conjuntos R e T2 Sincroniza (T2):
Recebimento e união dos estados resultantes vindos dos escravos e detecção de ponto fixo P ost (s):
Recupera estados posteriores (sucessores) de um estado s L (s):
Conjunto de rótulos (labels) de um estado s, ou seja, proposições atômicas que são satisfeitas em s Computação Paralela de Como característica do algoritmo de verificação adotado para este operador, é necessário avaliar o conjunto de estados em que a sub-fórmula é satisfeita buscando por estados que possuam sucessores pertencendo a este conjunto.
Os estados que não respeitarem esta regra são removidos do conjunto sendo necessária sua reavaliação até a obtenção de um ponto fixo.
O Algoritmo 3 descreve em alto nível os passos necessários para obtenção de paralelismo para o operador.
Os processos escravos são responsáveis por a execução de um conjunto de passos, sendo:
Inicialmente recebem o conjunto de estados que satisfaz.
Segundo a descrição do algoritmo deste operador realizada no Capítulo 3, o conjunto que inicialmente satisfaz é considerado o maior ponto fixo para o operador;
Avaliam um intervalo específico de estados respeitando o algoritmo para até que este conjunto atinja um ponto fixo intermediário, ou seja, significa que existe um ponto fixo local para uma partição de estados k do conjunto sendo avaliado por o escravo j, entretanto não há um ponto fixo global no que diz respeito a computação como um todo do conjunto, incluindo todas as partições distribuídas em N -- 1 processos.
Este comportamento pode ser visualizado no algoritmo nas linhas 17 à 29;·
Retornam o conjunto de estados removidos do conjunto para o processo mestre (conjunto· Aguardam até o momento da execução de uma rodada de sincronia;
Recebem o conjunto global de estados removidos os quais foram unidos por o mestre e removem estes estados de seu conjunto local.
Este passo e o anterior são executados juntamente com o algoritmo de manipulação de mensagens, descrito na Seção 4.1.5;·
Repetem do passo dois em diante a avaliação de estados em seus conjuntos locais de estados;
Executam estes passos até o momento que o processo mestre detecte um ponto fixo global, isto é, uma rodada em que os escravos não mais removam estados de (conjunto T).
A o final da computação dos operadores e, é percebível que os processadores envolvidos terão atingido um conjunto igual de estados.
Em um dado momento, disparando o processo mestre a computação de um dos operadores, ou, permanece bloqueado aguardando o retorno da computação dos escravos para execução de uma rodada de sincronia, no caso de os operadores ou, ou a união das computações para o operador.
Entrada: P/ M estre -- sistema de transição finito T S com conjunto de estados S (RSS) rotulado para L (s) e fórmula em ENF Entrada:
P/ Escravos -- sistema de transição finito T S com conjunto de estados que satisfazem tal que RSS e fórmula em ENF Saída:
P/ M estre -- conjunto de estados que satisfazem Saída:
P/ Escravos -- conjunto de estados removidos da partição k de T sendo avaliada por o processo j Dados:
MDD T, T2;
Dados: Estado s;
Início caso selecione faça se mestre então enquanto true faça/* Mensagem aos escravos indicando início de computação para DisparaComputacaoP aralela (T2);
DisparaComputacaoP aralela (T2):
Envio de mensagem aos escravos indicando início da verificação do operador para conjunto T2 Sincroniza (T2):
Recebimento e união dos estados resultantes vindos dos escravos e detecção de ponto fixo P ost (s):
Recupera estados posteriores (sucessores) de um estado s L (s):
Conjunto de rótulos (labels) de um estado s, ou seja, proposições atômicas que são satisfeitas em s Algoritmo para Manipulação de Mensagens (Message Handler) Devido a a adoção de ambientes que usufruam de espaços de memória distribuídos o uso de mecanismos de troca de mensagens se fez necessária para desenvolvimento dos algoritmos neste capítulo relatados.
Para tanto, adotou- se uma implementação open-source do ambiente MPI (Message Passing Interface) -- OpenMPI versão 1.4.5 -- a qual provê funções síncronas e assíncronas de comunicação entre máquinas.
Funções síncronas de comunicação foram utilizadas uma vez que os algoritmos possuem grande dependência de dados.
Cada máquina escrava, ao receber uma mensagem, executa uma rotina de tratamento descrita em alto nível por o Algoritmo 4 a qual indica as operações a serem executadas, sendo:
Dados: Este identificador indica aos processos escravos que estão aptos à carregar em memória o Descritor Markoviano e RSS, possuindo este último os conjuntos de estados que são válidos para cada proposição atômica definida.
EX: Este identificador indica início de computação distribuída do operador (EX).
Em este momento os processos escravos possuem em memória o conjunto de estados que satisfaz, vide algoritmo descrito na Seção 4.1.2.
Eu: Este identificador indica início da computação distribuída do operador (Eu).
Em este momento cada processo escravo possuirá em memória os conjuntos de estados que satisfazem 1 e 2, vide algoritmo descrito na Seção 4.1.3.
EG: Este identificador indica o início de computação distribuída para o operador (EG).
Após o recebimento desta mensagem, processos escravos possuirão em memória o conjunto de estados que satisfaz, conforme algoritmo descrito na Seção 4.1.4.
Eu_ sinc:
Este identificador indica a execução de uma rodada de sincronia para o operador.
Processos escravos carregam em memória e adicionam o conjunto global de estados vindo do processo mestre ao conjunto de estados que satisfaz 2 (conjunto T).
EG_ sinc:
Este identificador indica a execução de uma rodada de sincronia para o operador.
Processos escravos carregam em memória o conjunto de estados vindo do mestre e o removem de seu conjunto de estados local (conjunto T).
Toda vez que a função CarregaDados é executada, uma leitura em disco é feita carregandose em memória a estrutura simbólica que representa a referida computação (conjunto de estados) no conjunto dado como parâmetro na função.
Não serão detalhadas as operações executadas na estrutura MDD para codificação e carregamento de conjuntos de estados de forma simbólica.
Algoritmo 4: Método de tratamento de mensagens Entrada:
Mensagem MPI Dados:
MDD RSS; CarregaDados (RSS);
Break; Sat ();
Break; CarregaDados;
CarregaDados (2);
Sat); Break;
Sat ();
Break; CarregaDados (T2);
Sat); CarregaDados (T2);
Sat ();
Markoviano o qual é utilizado como função de transição do sistema e foi gerado no momento da compilação do modelo SAN simbolicamente representado num arquivo Distribuindo a computação de fórmulas CTL Conforme descrito no início deste capítulo, além de a distribuição da computação de operadores CTL, considerou- se o desenvolvimento de um algoritmo de distribuição de determinadas partes da árvore sintática que representa a propriedade computacionalmente, uma vez que a transcrição da mesma para o formato aceito por o algoritmo de verificação pode aumentar consideravelmente seu tamanho.&amp;&amp;&amp;
Sendo o tempo de verificação do algoritmo adotado linear ao tamanho da fórmula dada como entrada, a adoção de distribuição de tarefas (partições da árvore sintática) para computação em paralelo permite ganhos de desempenho.
Anteriormente à descrição do algoritmo, alguns pontos devem ser considerados.
A verificação de determinados operadores CTL é mais custosa e requer um conjunto maior de passos a para simples operações sob conjuntos, sendo eficientemente executados como simples operações de características, empregar algoritmos paralelos para computação destes operadores acaba tornando- se inviável pois o tempo necessário à computação sequencial dos mesmos é baixa, não justificando o desenvolvimento de algoritmos distribuídos onde troca de mensagens entre máquinas se faz necessária.
Partindo destas regras, particionar uma fórmula ENF fica condicionado à encontrar ramos da árvore que possuam operadores em que sua verificação seja computacionalmente custosa, tais como:,
e. Para a verificação destes operadores foram empregados os algoritmos descritos na Seção 4.1.
Desta forma, a verificação de uma fórmula CTL é conduzida distribuindo- se partições da árvore sintática que representa a fórmula em ENF para diferentes máquinas.
Cada máquina dona de uma partição da árvore, por sua vez, executa a recursão através da partição e computa sequencialmente as operações da lógica proposicional presentes(¬ e), disparando a verificação dos operadores mais custosos para um grupo de máquinas, participando conjuntamente na verificação destes operadores.
Para construção deste algoritmo, também adotouse o padrão mestre/ escravo.
É importante descrever os passos executados por ambos processos mestre e escravos antes da introdução do algoritmo de particionamento de fórmulas propriamente dito.
Tarefas do Processo Mestre O processo mestre é responsável por a execução de um conjunto de passos antes e durante a verificação distribuída de uma propriedade CTL.
Os passos que dizem respeito à compilação do modelo SAN (geração do Descritor Markoviano), geração do espaço de estados atingível, execução da função de rotulação, transcrição da fórmula de entrada para ENF e replicação destes dados para todos processos escravos envolvidos são os mesmos descritos no algoritmo da Seção 4.1.
Para o algoritmo em questão, o processo mestre é responsável por a execução de mais algumas tarefas, sendo:
Execução do algoritmo de escolha de particionamento de fórmulas ENF.
Este algoritmo, o qual é detalhado na Seção 4.2.3, tem como objetivo estudar e escolher quais partes da fórmula são suscetíveis à verificação em paralelo.
Como saída o algoritmo gera uma pilha de trabalho contendo índices que são utilizados para identificação das partições das fórmulas a serem distribuídas;
Distribuição das partições para os processos escravos e controle da computação;
Recepção e armazenamento dos estados resultantes das verificações.
Conforme as computações vão sendo finalizadas, o processo mestre recebe os estados resultantes e, por fim, manipula a sua árvore sintática local removendo as partições já verificadas.
A o se remover ramos da árvore sintática, eventuais ramos restantes podem estar suscetíveis à verificação em paralelo, sendo necessária nova execução do algoritmo de escolha de particionamento por o processo mestre;
Execução da verificação das operações restantes na árvore sintática.
O processo mestre, ao receber todas as computações oriundas das verificações das partições da árvore sintática, possui em memória apenas algumas operações restantes na sua árvore local, as quais não configuram duas ou mais partições.
Em este caso, a verificação dos operadores restantes na árvore sintática é conduzida exatamente de acordo com os algoritmos descritos na Seção 4.1, onde distribui- se a verificação dos operadores, e, na presença destes.
Tarefas dos Processos Escravos Uma vez que o processo mestre seja responsável por entregar trabalho aos processos escravos, a tarefa de conduzir rodadas de sincronia para cálculo de ponto fixo, no caso de os operadores e, ou união das computações resultantes no caso de o operador, fica delegada aos próprios processos escravos.
Desta forma, dois grupos de escravos foram definidos, processos escravos coordenadores e processos escravos que obedecem aos coordenadores, os quais diferem por as tarefas atribuídas.
Para a computação de cada partição da fórmula são definidos grupos de trabalho compostos por um processo coordenador e N processos escravos, onde o tamanho de cada grupo é fixo e definido por o usuário da ferramenta e vai do processo i até N -- 1, onde i é o identificador do processo coordenador do grupo em questão.
Os processos escravos coordenadores são responsáveis por a execução de rodadas de sincronia e detecção de ponto fixo.
De outro lado, processos escravos que obedecem aos coordenadores são responsáveis somente por a computação distribuída das operações recebidas do processo coordenador do grupo de trabalho corrente, e executam as mesmas tarefas já descritas nos algoritmos da Seção 4.1.
Abaixo são detalhadas as tarefas delegadas aos processos escravos coordenadores:
Após recebimento do identificador da partição da árvore a ser verificada, o coordenador corrente busca na sua árvore local a referência à respectiva partição.
Após este passo, invoca o presentes na partição;
A o final da verificação das sub-fórmulas dos operadores, ou, o processo coordenador dispara a verificação do operador ativo para o conjunto de processos pertencentes ao seu grupo de trabalho, participando conjuntamente com estes na exploração de estados, isto é, assumindo neste momento o papel de escravo;
A execução das rodadas de sincronia necessárias por os algoritmos para cálculo de ponto fixo ficam delegadas aos processos coordenadores, sendo executados os mesmos passos descritos para os algoritmos da Seção 4.1;·
A o final da computação da partição recebida, cada coordenador retorna o conjunto de estados resultante da verificação da partição da árvore sintática em questão ao processo mestre e aguarda a atribuição de novo trabalho.
Processos escravos que obedecem os coordenadores, por sua vez, executam as seguintes tarefas:
Aguardam a atribuição de trabalho do processo coordenador.
Recebendo mensagem a qual contém a operação a ser executada, carregam em memória os dados relativos ao conjunto de estados à ser verificado.
Após este passo, executam uma estados conforme descrito na Seção 4.1.
Após execução do algoritmo de verificação, retornam os estados resultantes simbolicamente codificados ao processo coordenador, o qual executa as respectivas rodadas de sincronia e detecta ou não a obtenção de um ponto fixo para a operação que está sendo verificada.
Aguardam novamente a atribuição de trabalho.
Sem fazer distinção, processos escravos estão suscetíveis ainda a receber trabalho vindo diretamente do processo mestre.
Conforme mencionado no início desta Seção, num dado momento, após a verificação de todas as partições identificadas da árvore sintática ter sido concluída, cabe ao processo mestre conduzir a verificação das operações que restarem na árvore sintática, a qual pode ser guiada de maneira paralela, na presença de operadores que possuam algoritmo distribuído ou), ou sequencial, no caso de operações de negação e conjunção lógica.
Algoritmo de Escolha de Particionamento de Fórmulas ENF Conforme anteriormente mencionado, somente serão consideradas partições de uma fórmula ENF aptas à verificação em paralelo as quais possuem pelo menos um operador onde sua verificação é computacionalmente custosa.
Estes operadores conduzem iterativamente exploração exaustiva de conjuntos de estados, sendo:,
e. O algoritmo desenvolvido percorre a árvore de maneira top-down realizando a busca e contagem das operações que podem configurar uma sub-árvore como uma partição à ser distribuída.
De esta maneira, todos os ramos da árvore sintática ENF necessitam ser avaliados.
Para busca e contagem dos operadores acima listados, foi desenvolvido um algoritmo de busca em profundidade o qual progride partindo do nodo dado como referência e é executado de maneira não-recursiva, utilizando- se uma pilha para controle de nós não-visitados.
Em conjunto com o algoritmo de busca das operações de interesse, um algoritmo que avalia a disposição dos operadores na árvore sintática foi desenvolvido.
Para cada sub-árvore, o algoritmo considera um conjunto de regras e executa os seguintes passos:
Realiza a busca e contagem das operações, e;
Havendo somente uma operação de interesse, o algoritmo adiciona o identificador do nodo pai da sub-árvore que está analisando numa lista de partições a serem verificadas em paralelo;
Havendo a presença de mais de uma operação de interesse, o algoritmo consulta todos os ramos presentes na sub-árvore em questão, em virtude de analisar a disposição dos operadores nos ramos.
Para cada ramo as mesmas regras são consideradas.
Um ramo é considerado por o algoritmo como uma sequência de operadores em que não existam operações binárias;
Havendo mais de um operador de interesse, entretanto estando dispostos em ramos que possuam dependência, ou seja, a verificação de um operador num nível superior depende do resultado da verificação de um operador num nível inferior, o ramo é assinalado como uma partição apta à verificação em paralelo.
Um exemplo deste comportamento pode ser visualizado na partição de índice 2 da Figura 4.4.
O algoritmo desenvolvido também identifica este comportamento em sub-árvores inteiras.
O algoritmo não permite que se assinale como uma partição apta à verificação em paralelo uma sub-árvore em que existam operações de interesse dispostas em ramos ou lados distintos, estes não possuindo dependência na verificação.
O particionamento é feito de modo a criar o maior número possível de partições distintas para verificação em paralelo.
Pilhas são utilizadas para controle das sub-árvores e ramos a serem visitados por o algoritmo, bem como, para armazenamento temporário dos nodos pais de cada sub-árvore e/ ou ramo em análise.
Para exemplificação do algoritmo de escolha de particionamento pode- se considerar as seguintes fórmulas CTL1:¬ (
p¬ q) As árvores sintáticas em Forma Normal Existencial que representam as fórmulas acima podem ser visualizadas nas Figuras 4.1, 4.2, 4.3 e 4.4, respectivamente.
Cada partição escolhida por o algoritmo é representada num tom de cinza.
Para facilitar a identificação, além de a operação a ser executada, cada nodo presente na árvore sintática possui um valor inteiro.
O restante deste capítulo se limita a demonstrar o particionamento das fórmulas acima listadas e os passos executados por ambos processos mestre e escravos durante a verificação.
No caso de a partição identificada por o índice 1, o processo coordenador do grupo, vide algoritmo descrito na Seção 4.2.2, busca a referência ao operador correspondente na sua árvore sintática ENF local e invoca o algoritmo Sat sendo responsável por a execução sequencial das operações de índice 3 à 9.
Finalizado este passo, o coordenador dispara a computação do operador para os processos que fazem parte de seu grupo de trabalho, participando este conjuntamente da computação, sendo responsável por a detecção de ponto fixo para o operador.
A o final, o processo coordenador executa a operação de índice 1 e retorna o conjunto de estados resultante ao processo mestre, ficando disponível novamente à receber trabalho.
Para a partição identificada por o índice 10, o coordenador que a recebe executa os seguintes passos:
Após buscar a referência ao respectivo nodo na árvore sintática, invoca o algoritmo de verificação executando as tarefas relacionadas às operações de índices 12 e 13.
Como próximo passo, o coordenador dispara e participa da computação do operador juntamente com os processos escravos pertencentes ao seu grupo de trabalho.
A o final, executa as tarefas relacionadas à operação de índice 10 e retorna os estados resultantes da computação desta partição ao processo mestre.
O mestre, por sua vez, após receber os respectivos conjuntos de estados resultantes da verificação das duas partições, manipula a árvore sintática removendo as partições e invoca o algoritmo de verificação sendo responsável por a execução da operação de índice conforme a descrição do algoritmo, avaliando- se a disposição destes operadores na fórmula pode- se assinalar apenas 2 partições a serem verificadas em paralelo.
Os nodos de índice 9 e 23 representam os nodos mais altos (nodos pai) para as respectivas partições, as quais somente possuem a presença de 1 operador de interesse cada, sendo e, respectivamente.
A verificação das partições desta fórmula procede de maneira semelhante à fórmula anterior (p U q).
Entretanto, ao final da etapa de computação realizada para cada partição, o processo mestre executa a verificação do restante da fórmula de maneira igualmente descrita no algoritmo da Seção 4.1, executando- se os seguintes passos:
O mestre, após recebimento das computações relativas às partições identificadas por os índices 9 e 23 e manipulação da sua árvore sintática local, invoca o algoritmo de verificação para o restante da fórmula.
A verificação das operações de índices 2 à 8 é executada sequencialmente por o próprio processo mestre, disparando a computação do operador de índice 1 para os processos escravos que, por sua vez, executam de maneira distribuída as tarefas relacionadas à verificação deste operador.
As rodadas de sincronia necessárias para atingir um conjunto de estados que caracterizam um ponto fixo para o operador são executadas por o processo mestre, vide algoritmo descrito na Seção de índice 0, finalizando a verificação da fórmula.
Após recebimento do identificador de partição e busca da respectiva referência na árvore executa as operações de índice 12 e 14.
Finalizada esta etapa, a computação do operador 13 () é distribuída entre o coordenador e o conjunto de processos escravos que fazem parte do respectivo grupo de trabalho.
Finalizada a verificação de, as operações 10 e 11 são executadas por o respectivo coordenador, finalizando a verificação desta partição ao retornar os estados resultantes para o processo mestre.
Para as demais partições demarcadas na fórmula, passos semelhantes são executados por os respectivos coordenadores e grupos de trabalho.
O número de partições que podem ser avaliadas em paralelo são dependentes, obviamente, da quantidade de processos empregados para computação e o tamanho escolhido por o usuário para cada grupo de trabalho.
A o final da computação de todas as partições da fórmula o processo mestre computa as é distribuída para todos os processos escravos, vide algoritmo descrito na Seção 4.1.
A verificação da partição identificada por o índice 2 é realizada através da execução das operações de índices 3 () e 5 () distribuindo- se a computação destes operadores entre coordenador e respectivo grupo de trabalho.
A computação das operações 2, 4 e 6 é realizada por o próprio coordenador, conforme já descrito para as propriedades anteriores.
Para verificação da partição identificada por o índice de número 7, o algoritmo procede de maneira semelhante onde o coordenador executa as operações de negação e conjunção exploração dos estados que satisfazem as sub-fórmulas 1 e 2.
Os experimentos para medição de desempenho com as abordagens paralelas neste trabalho descritas foram planejados utilizando uma abordagem estatística para validação dos resultados obtidos.
Em este sentido, este capítulo apresenta a descrição do ambiente utilizado para condução dos experimentos (Seção 5.4), a abordagem de intervalos de confiança para estimar uma média do tempo de execução, determinação do tamanho amostral de dados a serem coletados (Seção 5.2), medidas para avaliação de desempenho (Seção 5.3), as propriedades CTL utilizadas nos experimentos (Seção 5.5) e, por fim, a discussão acerca de os resultados obtidos (Seção 5.6).
Intervalos de Confiança Uma estimativa pontual, ou seja, baseada num único valor tal como a média de n execuções de um algoritmo, não fornece um dado confiável acerca de a exatidão deste dado para aproximação de um parâmetro populacional.
Uma vez que o tempo de execução de programas paralelos tende a sofrer variações as quais podem ser causadas por diversos fatores tais como latência de rede, interferência por execução de rotinas padrão do sistema operacional, de entre outros, é importante a adoção de estimativas intervalares que garantam a qualidade dos dados coletados.
Para Triola e Flores, adotando- se um nível de confiança é possível identificar uma taxa de sucesso para um procedimento experimental a fim de calcular um intervalo de confiança.
Para este procedimento adotou- se um nível de confiança de 95%, para o qual o valor crítico (z/ 2) é 1.96.
Um valor crítico é um número na fronteira que separa estatísticas amostrais que têm chance de ocorrer daquelas que não têm.
Para cálculo do intervalo de confiança é necessário calcular anteriormente o desvio padrão (x -- µ) 2 Conhecido o desvio padrão, é possível calcular a margem de erro (E) para a média populacional (µ), utilizando- se a seguinte fórmula:
E $= z/ 2.
Conhecida a margem de erro, o intervalo de confiança pode ser estimado através da seguinte fórmula:
Tamanho Amostral O tamanho de uma amostra é relacionado com a quantidade necessária de dados a serem coletados para determinar uma média.
Seu emprego visa garantir maior confiabilidade da média e reduzir o tempo gasto coletando dados desnecessários (neste caso realizando execuções desnecessárias do algoritmo).
Uma vez que, para construção dos intervalos de confiança lidou- se com (desvio padrão populacional) desconhecido, uma das alternativas é calcular- lo através de um estudo piloto, com base nos 31 primeiros valores amostrais selecionados aleatoriamente.
Assim, para cada amostral (n) é calculado utilizando- se a seguinte fórmula:
Medidas para Avaliação de Desempenho Para análise de programas paralelos, uma comparação com o tempo de execução da implementação sequencial é especialmente importante para ver o benefício obtido através do paralelismo.
Tal comparação é muitas vezes baseada na redução relativa do tempo de execução sendo expressada por a noção de Speed-up (fator de aceleração).
O cálculo do fator de aceleração (Sp) de um programa paralelo é dado por a seguinte fórmula:
Sp $= Tp onde p é o número de processadores utilizados para solução do problema, T1 é o tempo gasto por o algoritmo sequencial e Tp é o tempo gasto por o algoritmo paralelo para p processadores, sendo este último normalmente construído a partir de a implementação sequencial.
O conceito de Speed-up é utilizado tanto para uma análise teórica de algoritmos quanto para a avaliação prática de programas paralelos.
Instrumentação e Ambiente Utilizado Para condução dos experimentos adotou- se uma máquina integrada ao Laboratório de Alto Desempenho da PUCRS.
A máquina utilizada (atlantica) é um cluster composto por 16 máquinas Dell PowerEdge R610 possuindo dois processadores Intel Xeon Quad-Core E5520 de 2.27 GHZ com tecnologia Hyper--Threading cada.
Conta com sistema operacional Ubuntu Linux 10.04 server 64 bits e interface de troca de mensagens (Message Passing Interface) -- OpenMPI versão Conforme descrito no Capítulo 4, a troca de estados entre as máquinas empregadas é feita através de acesso à disco onde armazena- se a estrutura simbólica que representa o conjunto de estados a ser trafegado.
Por questões de disponibilidade, utilizou- se um disco compartilhado para armazenamento de tais dados.
Embora o uso de discos com estas características possa apresentar interferências afetando operações de entrada e saída, variações significativas foram detectadas somente quando de a execução de grandes quantidades destas operações.
Resultados que comprovam este comportamento serão discutidas na Seção 5.6.
Apesar de ser possível o tráfego de tais estruturas simbólicas através de mensagens evitando- se operações de acesso à disco, operações intermediárias de manipulação e armazenamento em estruturas que possam ser trafegadas por o ambiente MPI necessitariam ser executadas.
Além deste fator, à medida que se aumenta a complexidade do modelo a ser verificado, é natural que as estruturas utilizadas para armazenamento dos estados venham a crescer, possivelmente pesando o tráfego de mensagens contendo tais informações.
Por razões de disponibilidade e concorrência com os demais usuários do laboratório, apenas dois nodos da máquina foram utilizados durante os experimentos.
De esta maneira, devido a a presença de processadores que encapsulam mais de um núcleo de processamento no mesmo chip em tais nodos, processos MPI acabam sendo alocados dentro de um mesmo processador, entretanto em núcleos distintos.
Em a condução dos experimentos foram gerados intervalos de confiança com nível de confiança de 95% para 40 execuções para ambos os algoritmos, paralelos e sequencial.
Foram utilizados 1, 3, 5, 7, 9, 11, 13, e 15 processos relativos à 1 processo mestre e N -- 1 escravos.
Propriedades CTL para Modelos SAN Para demonstrar o comportamento dos algoritmos neste trabalho propostos, propriedades CTL foram escritas para os modelos apresentados no Apêndice A. Para definição do conjunto de proposições atômicas que compõe uma propriedade, expressões SAN são utilizadas.
Propriedades CTL para o modelo do Jantar dos Filósofos Para o modelo do clássico problema do Jantar dos Filósofos, cinco propriedades foram escritas.
Para expressar o comportamento desejado, as seguites proposições atômicas foram definidas:
A proposição P hili N ãoCome denota que o autômato que representa a situação do filósofo i está num estado diferente de Lef t/ Right, representando que não está comendo, de acordo com sua orientação.
A proposição P hili Comendo denota a situação contrária.
A proposição V izinhosComendo denota que os autômatos que representam a situação dos filósofos vizinhos i e i+ 1 estão no estado Lef t, representando que estão comendo ao mesmo tempo.
Com a definição e descrição das proposições atômicas acima, pode- se descrever algumas propriedades a serem verificadas sobre este modelo:
Existe um caminho possível onde, em todos os estados, o filósofo P hili não come.
A propriedade CTL representada por a Equação 5.6 verifica a possibilidade do filósofo P hili nunca atingir o estado Lef t, ou seja, nunca comer, caracterizando Postergação Indefinida (Starvation).
Esta propriedade respeita naturalmente a Forma Normal Existencial. (
V izinhosComendo) Existe um caminho onde, futuramente, filósofos vizinhos comem ao mesmo tempo.
A Propriedade 5.7 testa se o modelo em questão é mutuamente exclusivo.
Sendo falsa, garante este comportamento.
Esta fórmula é representada em ENF da seguinte maneira: (true V izinhosComendo).
Existe um caminho possível onde, no próximo estado, o filósofo P hili está num estado diferente de Lef t..
A Propriedade 5.8 não possui sentido semântico e não visa a verificação de comportamentos sobre o modelo.
Entretanto, foi definida visando cobrir a implementação paralela para o operador.
Esta propriedade respeita naturalmente a Forma Normal Existencial.
Para todos os caminhos, o filósofo P hili come até que os filósofos vizinhos estejam num estado diferente de Lef t..
A propriedade 5.9 visa verificar se em todos os caminhos possíveis um filósofo i come até que, ou melhor, enquanto que, seus vizinhos i -- 1 e i+ 1 não atinjam o estado que indica que estão comendo.
Ainda, a propriedade foi definida visando medição de desempenho através do algoritmo de distribuição de partições da árvore sintática, conforme descrito na Seção 4.2.
Sua fórmula equivalente em ENF é representada da seguinte forma:
P hili+ 1 N ãoCome))¬ (P hili-1 N aoCome P hili+ 1 N ãoCome).
A Figura 4.1 representa a árvore sintática equivalente.
Para todos os caminhos, em todos os estados, caso o filósofo i esteja no estado Lef t, isto implica em, para todos os caminhos, no futuro, o filósofo vizinho i+ 1 não atingir o estado que lhe permite comer.
Esta propriedade testa a possibilidade do filósofo i+ 1 ficar bloqueado indefinidamente não sendo possível comer.
Equivalência em ENF para a fórmula:¬.
Propriedades CTL para o modelo Ad Hoc Wireless Networks Propriedades foram escritas para o modelo de uma rede de nodos wireless Ad Hoc, apresentado no Apêndice A. 2.
Para tanto, as seguintes proposições atômicas foram definidas:
A proposição atômica N odoi T ransmite denota que o autômato que representa a situação do nodo i na cadeia de nodos está no estado T, o qual simboliza a transmissão de pacotes.
A proposição atômica N odoi Recebe denota que o autômato i está no estado R, indicando a recepção de pacotes por o nodo que está sendo representado.
A proposição atômica IntervaloT ransmissão denota que o número de autômatos que estão no estado T (transmitindo) no intervalo que vai de i -- 2 até i+ 3 é igual a 1.
Com as proposições acima definidas, as seguintes propriedades CTL foram escritas:
Para todos os caminhos, em todos os estados, caso o nodo de índice 1 transmitir pacotes, isto implica em, para todos os caminhos, no futuro, o nodo N (último nodo da cadeia) receber- los.
Esta propriedade visa verificar se, caso o primeiro nodo da cadeia transmitir pacotes, os mesmos serão recebidos por o último nodo da cadeia.
Vale destacar que a propriedade não garante recepção total dos pacotes enviados uma vez que não há uma forma de controlar a quantidade de pacotes gerados por o primeiro nodo e recebidos por o último nodo da cadeia.
Esta fórmula é representada em ENF por a seguinte fórmula:¬.
Para todos os caminhos, o último nodo da cadeia não atinge o estado R, ou seja, não recebe pacotes, até que pelo menos uma transmissão seja realizada por o primeiro nodo.
Esta propriedade testa a precedência na recepção de pacotes onde, o último nodo da cadeia pode atingir o estado R (recebendo) se e somente se o primeiro nodo da cadeia ter anteriormente realizado transmissões.
Sua fórmula equivalente em ENF é representada da seguinte forma:¬(¬
N odo1 T ransmite)¬ N odo1 T ransmite.
Para todos os caminhos, em todos os estados, caso um nodo i esteja no estado transmitindo (T), então o número de nodos que estão transmitindo no intervalo entre i -- 2 e i+ 3 é igual a um.
Esta propriedade testa se a transmissão de pacotes respeita as regras de interferência do protocolo de comunicação adotado.
Caso haver mais de um nodo realizando transmissões no intervalo acima citado, isto indica a possibilidade de perda de pacotes, a qual é ocasionada por a interferência MAC.
Para maiores detalhes acerca de o protocolo e do modelo adotado, recomendase a leitura de.
Equivalência em ENF para a propriedade:¬ (
true (N odoi T ransmite¬ IntervaloT ransmissão).
Propriedades CTL para o modelo Linha de Produção Para o modelo que representa uma linha de produção, apresentado no Apêndice A. 3, duas propriedades foram definidas:
Uma para verificar a vivacidade parcial do modelo, e outra a vivacidade do modelo em sua totalidade.
Para expressar os comportamentos desejados, algumas proposições atômicas foram definidas:
Apêndice A. 3.
A proposição atômica Estaçãoi Bloqueada denota que o autômato que representa o comportamento da estação i está no estado 1, 2.
A proposição Estaçãoi Desbloqueada, por sua vez, denota o contrário, o que indica que a estação não está bloqueada.
Tendo as proposições atômicas acima definidas, as seguintes propriedades CTL podem ser escritas:
Para todos os caminhos, em todos os estados, caso a estação Mi bloquear isto implica em, para todos os caminhos, no futuro, a estação desbloquear.
Como descrito no Apêndice A. 3, uma estação bloqueada não permite que uma estação precedente prossiga.
Desta forma, a Propriedade 5.14 verifica a possibilidade de uma estação bloquear indefinidamente a estação anterior.
Equivalência em ENF para a fórmula CTL:¬ (
true (Estaçãoi Bloqueada¬ Estaçãoi Desbloqueada).
Para todos os caminhos, em todos os estados, caso a estação Mi bloquear, isto implica em, para todos os caminhos, no futuro, a estação Mi desbloquear.
Para testar a vivacidade no modelo em sua totalidade, é necessário verificar para cada estação i, partindo de i $= 2, se a referida estação não está bloqueando a estação precedente.
Para exemplificação, pode- se considerar um modelo para três estações.
A propriedade representada por a Equação 5.15 verificará se, para todos os caminhos, em todos os estados, a conjunção de (Estaçãoi Bloqueada (Estaçãoi Desbloqueada)) para todo 2 i N é verdade.
Conforme informado na descrição deste modelo (Apêndice A., o índice i inicia em 2 uma vez que a estação M1 não é modelada.
A fórmula ENF equivalente para esta propriedade pode ser visualizada na Figura 4.3, para N $= 8.
Para condução dos experimentos com este modelo, as estações foram modeladas com buffer com capacidade 1.
Para maiores detalhes sobre o problema e respectivo modelo SAN recomenda- se a leitura de.
Resultados Obtidos Em esta seção os resultados obtidos para as propriedades definidas na Seção 5.5 são tabelados e posteriormente discutidos.
Os resultados estão dispostos nas tabelas da seguinte forma:
A coluna Processadores apresenta a quantidade de processadores utilizados para verificação da propriedade em questão.
As colunas µTempo, e Confiança de 95% apresentam a média de tempo, desvio padrão e intervalo de confiança ambos calculados para as amostras de tempo coletadas.
A coluna speed-up apresenta o valor do fator aceleração obtido para p processadores.
Por fim, as colunas Pico Memória e µMemória apresentam o valor de memória relativo à máquina (processo) que mais consumiu e a média de consumo, respectivamente.
A Seção 5.7 apresenta possíveis causas identificadas para os ganhos de desempenho elevados obtidos.
Os tempos relativos à compilação do modelo SAN, geração do espaço de estados atingível e execução da função de rotulação (Labelling Function) estão incluídos nos valores de tempo apresentados, portanto não serão mostrados separadamente, pois não representam dados significativos em relação a o tempo de verificação.
Resultados para o modelo do Jantar dos Filósofos Os resultados obtidos para as propriedades definidas para o modelo do Jantar dos Filósofos são descritos abaixo.
Os resultados obtidos para a Propriedade 5.6 (st P hili! $=
Comendo) -- starvation) são apresentados por a Tabela 5.1.
Ganhos extremamente elevados para esta propriedade foram obtidos com a implementação paralela.
As causas para este comportamento derivam da natureza da propriedade e modelo aliados à aspectos de implementação.
Uma vez que foram identificadas as execuções de apenas duas iterações para obtenção de ponto fixo para o operador em questão, habilita- se o algoritmo paralelo à coordenar Speed-up para Propriedade 5.6 Ideal 13 Fil.
É possível conduzir testes para a propriedade em questão com tamanhos maiores de modelo tal como 16 filósofos, o qual possui espaço de estados atingível de 1.136.689 estados.
Devido a a grande quantidade de estados a ser verificada foram utilizados 30 processos (distribuídos homogeneamente em quatro nodos da máquina) na condução deste experimento, tendo tempo médio de verificação (cinco amostras) em torno de 61,14 segundos, e pico e média de consumo de memória de 415,40 MB e 355,24 MB, respectivamente.
Não foram geradas estimativas intervalares e cálculo de fatores aceleração para tais testes devido a o tempo necessário para execução por a ferramenta sequencial.
A Tabela 5.2 apresenta os resultados obtidos para a Propriedade 5.7 (exclusão mútua).
Sua equivalência em ENF é representada através da seguinte fórmula: (
true). Como descrito na Seção 4.1, o algoritmo para o operador tem como característica avaliar o conjunto de estados pertencente à diferença entre 1 e 2 buscando por estados em que a intersecção de seus sucessores com 2 seja diferente de vazio.
Sendo esta condição verdadeira, os respectivos estados são adicionados ao conjunto que satisfaz 2.
Estes passos são executados repetidas vezes até que se obtenha um ponto fixo.
Figura 5.2 ­ Gráfico de speed-up para a Propriedade 5.7 (Exclusão Mútua).
Comunicação para verificação em paralelo é necessária somente para ditar o início e término do paralelismo, de forma que os ganhos sejam elevados.
Os ganhos se mostraram mais favoráveis para 9, 11 e 13 processos.
Estando o ganho de aceleração posicionado acima de o ideal, ou seja, apresentando speedups superlineares[ 42], um comparativo pode ser feito visando melhor analisar este comportamento para a referida propriedade.
Tomando como referência o modelo com 13 filósofos, a verificação sequencial da propriedade para| S| $= 80.782 estados apresenta média de tempo posicionada entre 26,17 e 26,22 segundos.
A o se considerar o modelo com 15 filósofos o qual possui| S| $= 470.832 estados, proceder a verificação com 15 processos leva entre 24,07 e 25,55 segundos, para uma amostra de 40 execuções do algoritmo, uma vez que cada processo escravo conduz a verificação de uma porção em torno de 33.000 estados.
Havendo comunicação somente para início e término da verificação para este operador, ganhos elevados podem ser esperados.
Testes foram conduzidos para o modelo com 16 filósofos.
O tempo obtido para verificação com a implementação paralela leva em torno de 64,96 segundos empregando- se 30 processos distribuídos em quatro nodos da máquina, tendo pico e consumo médio de memória de 578,96 MB e 514,13 MB, respectivamente.
O comportamento da implementação paralela deste operador apresentado por a Tabela 5.3 sugere que o aumento do grão para verificação implica em obtenção de elevados fatores aceleração.
Os resultados obtidos para a Propriedade 5.10 são apresentados por a Tabela 5.4 e os respectivos fatores aceleração na Figura 5.4.
Apesar de o ganho obtido ser relativamente alto, é perceptível que, em comparação com outras propriedades para o mesmo modelo, o fator aceleração reduziu consideravelmente.
Apesar de o algoritmo executar um número relativamente baixo de rodadas Speed-up para Propriedade 5.10 Ideal 13 Fil.
A Tabela 5.5 apresenta os resultados de tempo e memória obtidos para a propriedade permite ser quebrada em duas partições para verificação em paralelo através do algoritmo descrito na Seção 4.2.
Para um comparativo justo, os respectivos experimentos foram realizados também utilizando- se o algoritmo de distribuição da computação relativa aos operadores de lógica temporal, tendo os resultados apresentados na referida Tabela por as informações contidas na parte superior (Sem quebra da árvore sintática).
Vale destacar que o número de processos empregados na segunda abordagem (Com quebra da árvore sintática) representa a existência de 1 processo mestre e N 1 processos escravos, sendo os últimos dispostos em 2 grupos para computação das partições da árvore.
Por os resultados apresentados por a tabela e respectivo Gráfico de speed-up (5.5), a abordagem de verificação sem particionamento da árvore sintática se mostrou mais favorável para esta propriedade.
Este comportamento é obtido devido a maior quantidade de processos empregada na verificação dos operadores de maior custo computacional aliado à necessidade de execução de poucas rodadas de sincronia para obtenção de ponto fixo para tais operadores.
A média de memória apresenta valores muito inferiores aos valores de pico de memória.
Este comportamento se justifica uma vez que o processo mestre realiza poucas operações sobre a estrutura MDD durante a verificação de propriedades, de forma que seu consumo de memória seja relativamente baixo em comparação aos processos escravos.
Embora o consumo total de memória englobando- se todas as máquinas utilizadas seja relativamente alto em relação a a implementação sequencial, as abordagens paralelas permitem distribuir o consumo, de maneira que os recursos computacionais em cada máquina possam ser melhor aproveitados.
Vale destacar que devido a o emprego de quantidades maiores de processos para computação dos operadores de maior custo computacional para a Propriedade 5.9 quando de o emprego da implementação sem quebra da árvore sintática o consumo de memória por a primeira abordagem naturalmente tende a ser inferior em relação a a segunda implementação.
Resultados para o modelo Ad Hoc Wireless Networks Em esta seção são apresentados e discutidos os resultados obtidos para as propriedades definidas para o modelo Ad Hoc Wireless Networks (Seção 5.5.2).
A Tabela 5.7 apresenta os resultados obtidos através do experimento para a Propriedade (N odoi T ransmite IntervaloT ransmissão) (5.13).
Os ganhos se mostraram mais favoráveis para 9, 11 e 13 processadores.
Este comportamento é justificado uma vez que foram identificadas apenas duas rodadas de troca de mensagens entre processos mestre e escravos durante a verificação do operador (), sendo uma para início e outra para término da computação.
Isto indica que o conjunto de estados que provém da diferença entre e a ser avaliado já representa um ponto fixo.
De esta maneira, apenas uma iteração é realizada por o algoritmo de mananeira distribuída para o operador em questão, não necessitando sincronismo entre os processos envolvidos e constante acesso a disco para troca de estados.
Apesar de o aumento do tamanho do modelo fornecer maiores conjuntos de estados a serem avaliados, isto implica no aumento do número de iterações de avaliação necessárias para obtenção de ponto fixo.
Este comportamento foi identificado para propriedades em que as proposições atômicas definidas fazem referência à comportamentos de autômatos que não possuam relação de dependência direta e, também, autômatos que possuem baixa influência sobre o modelo.
Este comportamento também pode ser visualizado para a propriedade representada por a Equação 5.11 (Tabela 5.6).
Entretanto, quando de o emprego de apenas um processo na computação de cada partição da árvore sintática por a segunda abordagem paralela (resultados apresentados nas linhas correspondentes a três processos) pequenos ganhos de desempenho são obtidos.
Este comportamento é justificado devido a baixa comunicação necessária durante a computação uma vez que não são executadas rodadas de sincronia entre as máquinas empregadas.
O gráfico apresentado por a Figura 5.9 demonstra o pico de consumo de memória para as propriedades verificadas sobre o modelo Ad Hoc Wireless Networks.
O consumo de memória para as propriedades 5.11 e 5.12 tende a aumentar consideravelmente em relação a a implementação sequencial quando de o emprego de um número baixo de processadores.
Devido a a grande quantidade de operações de sincronia e iterações executadas por o algoritmo, o crescimento das estruturas intermediárias necessárias à obtenção do resultado na estrutura MDD acaba sendo elevado.
No caso de a Propriedade 5.12, para ambas as implementações quedas semelhantes são obtidas.
A abordagem de distribuição de partições da árvore sintática apresenta maior consumo devido a o emprego de grupos menores de processos para verificação de cada partição, consequentemente distribuindo grupos maiores de estados para verificação para cada máquina empregada.
Entretanto ao se considerar as execuções com três processos, quedas significativas são obtidas devido a a concentração da computação uma vez que se emprega apenas um processo na verificação de cada partição da árvore sintática, o que possivelmente permite maior reuso de estruturas no MDD presente em cada processo.
Por fim, o consumo de memória para a Propriedade 5.13 apresenta comportamento semelhante ao obtido para as propriedades verificadas sobre o modelo do Jantar dos Filósofos, tendo este último consumo detalhado por a Figura 5.6, devido a a execução de um número baixo de iterações e comunicação para obtenção de ponto fixo.
Resultados para o modelo Production Line Em esta seção são apresentados e discutidos os resultados obtidos para as propriedades definidas para o modelo Production Line (Seção 5.5.3).
A Tabela 5.9 apresenta os resultados obtidos com a implementação descrita na Seção 4.1 para a propriedade representada por a Equação 5.14.
Foram identificadas as execuções de um número considerável de iterações para verificação dos operadores que dependem de cálculo de ponto fixo para a propriedade em questão.
A abordagem se mostrou mais favorável para 11, 13 e 15 processos, embora apresentando ganhos pouco significativos.
Embora seja esperado que o aumento do número de processadores para verificação permita obter maior desempenho, o pequeno número de estados atingíveis dos modelos aliado à grande quantidade de comunicação e acesso à disco necessários não permite ganhos expressivos.
Experimentos foram conduzidos para o modelo com 10 nodos, entretanto ganhos expressivos não foram obtidos.
O emprego de rotinas assíncronas de comunicação e otimizações relacionadas ao tráfego de estados habilita os processos escravos à evitar bloqueios, de forma que ganhos maiores podem ser obtidos mesmo quando se verificam conjuntos pequenos de estados.
A Figura 5.10 apresenta o consumo de memória (pico) para as Propriedades 5.14 e 5.15, ambas verificadas sobre o modelo Linha de Produção para 9 estações.
É notório um aumento de consumo quando de o emprego de poucos processos para verificação de ambas as propriedades, de forma que a execução de grande quantidade de rodadas de sincronia influi para este comportamento e, principalmente, devido a a grande quantidade de iterações de avaliação dos conjunto de estados em consideração.
À medida que se aumenta o número de processos para verificação, para ambas as propriedades e abordagens utilizadas, a distribuição das tarefas relacionadas à computação dos operadores de lógica temporal permite que as estruturas simbólicas intermediárias necessárias à obtenção do resultado sejam melhor distribuídas, de maneira que o pico de consumo de memória em cada caso seja muito inferior ao valor atingido por a implementação sequencial.
Fatores Aceleração Elevados Embora a ocorrência de fatores aceleração acima de o ideal em ambientes distribuídos não seja frequente, comportamentos com estas características em abordagens paralelas de verificação são encontrados em alguns trabalhos.
Bell e Haverkort apresentam algoritmos explícitos para geração do espaço de estados e verificação de propriedades CTL para modelos descritos em Redes de Petri.
Os resultados gerados apresentam fatores aceleração acima de o esperado para os operadores e para o problema do Jantar dos Filósofos.
Como causa para este comportamento, os autores citam o uso de múltiplos processadores o que disponibiliza maiores espaços de cache, permitindo a obtenção de melhor performance e, também, a função de particionamento adotada a qual reduz a presença de arcos de transição entre as partições, consequentemente reduzindo a comunicação entre as máquinas.
Behrmann, Hune e Vaandrager apresentam uma abordagem distribuída de verificação simbólica do formalismo Timed Automata.
Cada nodo computacional recebe porções do espaço de estados após a sua geração de acordo com uma função de mapeamento e distribuição.
Os resultados obtidos mostram ganhos de desempenho próximos ao dobro do ideal para alguns casos, sendo justificados por os autores devido a o acesso à grandes quantidades de memória cache local por as máquinas empregadas.
Este trabalho é baseado na implementação apresentada por Stern e Dill, onde utiliza- se uma tabela de estados para armazenar os estados atingíveis do modelo, sendo particionada entre os nodos empregados os quais possuem uma fila de trabalho para armazenamento dos estados ainda não-explorados.
Boukala e Petrucci implementaram um algoritmo de geração de espaços de estados explícitos e verificação de propriedades CTL, ambos distribuídos, para o formalismo Redes de Petri.
Fatores aceleração acima de o esperado foram obtidos para o operador para o modelo do Jantar dos Filósofos.
Entretanto, os autores não argumentam sobre possíveis causas para este comportamento.
Os resultados mostram números consideravelmente altos de troca de mensagens durante a geração do RSS, verificação e geração de contra-exemplos.
Ambos os trabalhos acima descritos adotam o modelo de programação mestre/ escravo e comunicação assíncrona para tráfego de estados entre as máquinas.
Para os autores Rauber e Runger, fatores aceleração superlineares (Sp\&gt; p) podem ser observados em alguns casos.
A razão para este comportamento frequentemente encontra- se em efeitos de cache:
Um programa paralelo típico atribui somente uma fração do conjunto de dados para cada processador.
A fração é selecionada de forma que o processador realize as suas computações no seu conjunto de dados.
Em esta situação, pode ocorrer do conjunto de dados como um todo ser maior que a área de cache disponível de um único processador executando o programa sequencialmente, assim levando à cache misses durante a computação.
Entretanto, quando muitos processadores executam um programa com a mesma quantidade de dados em paralelo, pode ocorrer da fração dos dados atribuídos à cada processador ser inferior à área local de cache do mesmo, evitando- se cache misses, ou seja, não sendo necessário acesso à memória principal, a qual é mais lenta.
Fatores aceleração superlineares não ocorrem com frequência, sendo uma situação típica que se alcance aceleração inferior ou próxima ao linear (Sp p).
Este comportamento é causado devido a as operações adicionais necessárias para gerência do paralelismo e troca de dados entre processadores e, também, devido a os longos tempos de espera causados por balanceamento desigual de trabalho entre os processadores.
Conforme descrito na Seção 5.6, os experimentos que apresentaram ganhos acima de o ideal são aqueles em que poucas iterações são necessárias para obtenção de ponto fixo, implicando na execução de poucas rodadas de comunicação, habilitando os processadores a seguir a verificação de estados de maneira quase independente.
Aliado à esses fatores, cada máquina empregada na verificação está habilitada a calcular estados sucessores de um dado estado localmente, devido a a replicação da estrutura MDD que representa o RSS rotulado para as proposições atômicas definidas, evitando- se troca de mensagens.
Apesar de a obtenção destes comportamentos estar ligada à estes fatores somado à possíveis efeitos de cache, algumas características do ambiente adotado foram consideradas para condução de experimentos visando avaliar o comportamento do algoritmo sob diferentes circunstâncias.
Devido a a presença de otimizações para troca de mensagens para uso em máquinas multicore por o ambiente MPI adotado, processos que estejam dispostos num mesmo nodo computacional terão benefícios na transferência de dados.
Através do uso da tecnologia Shared--Memory Byte Transfer Layer (SMBTL), a qual fornece um mecanismo de troca de mensagens de baixa latência e alta largura de banda, mensagens MPI em ambientes com estas características podem ser transferidas através de espaços de memória compartilhada entre os núcleos de processamento de um mesmo nodo.
Visando melhor avaliar os resultados que apresentam fatores aceleração superlineares, as seguintes abordagens para execução dos experimentos foram consideradas:
Experimento 1: Inicialmente, testes foram conduzidos utilizando- se apenas um nodo da máquina atlantica, de modo que não sejam trafegadas mensagens através da rede da máquina.
Em este caso, foram obtidos consideráveis ganhos de desempenho quando de o emprego de até 8 processos, o que de fato caracteriza o não uso da tecnologia Hyper--Threading, uma vez que se instanciam quantidades de processos iguais ao número de núcleos físicos disponíveis no nodo.
Entretanto, não há controle sobre a alocação interna de processos nos núcleos físicos dos processadores, sendo esta tarefa delegada aos algoritmos de escalonamento do sistema operacional da máquina.
À medida que se aumenta o número de processos, considerável redução do ganho de desempenho pôde ser visualizada.
Não serão tabelados os resultados obtidos através do Experimento 1 uma vez que não há troca de mensagens por a rede da máquina.
Experimento 2: Em uma tentativa de medir o impacto causado por o acesso à rede, testes foram conduzidos numa segunda máquina.
A máquina adotada (cluster gates) é composta por 16 máquinas Rackable Systems.
Cada nodo possui 2 processadores AMD Opteron 246 de 2 GHz e 8 GB de memória e estão interligados por redes Gigabit-Ethernet chaveadas.
A o conduzir os experimentos relativos às implementações sequencial e paralelas, posterior cálculo de speed-up demonstrou comportamentos semelhantes ao Experimento 1.
Entretanto, à medida que se aumenta o número de processadores, o ganho de desempenho se mantém crescente, de modo que comunicação entre os nodos não afete o desempenho da aplicação para tais casos.
Este comportamento reforça as razões dadas para os ganhos demonstrados na Seção 5.6.
O Apêndice B apresenta os resultados de tempo obtidos para o Experimento 2.
Experimento 3: Por fim, utilizando- se a máquina atlantica, experimentos foram conduzidos distribuindo- se processos MPI entre dois nodos da máquina.
Os resultados apresentados na Seção 5.6 dizem respeito a este experimento, detalhado anteriormente na Seção 5.4.
Para os três experimentos relatados, estimativas intervalares foram geradas para amostras de 40 execuções.
Realizando- se um comparativo entre os resultados colhidos através dos Experimentos 2 e 3, é perceptível que ambas as abordagens de execução apresentam comportamentos similares no que diz respeito ao cálculo de fatores aceleração.
Este comportamento indica e reforça os argumentos para tais ganhos, de forma que devido a a baixa quantidade de comunicação necessária para cálculo de ponto fixo, latência de rede não é fator impactante para tais casos.
Conforme relatado na Seção 4, os dados inicialmente presentes na estrutura MDD, os quais dizem respeito ao espaço de estados atingível rotulado para as proposições atômicas definidas, apresentam consumo de memória extremamente baixo.
Embora este seja um requisito para possível ocorrência de efeitos de cache em processadores, o crescimento da estrutura MDD durante a verificação de propriedades tende a ser extremamente elevado em ambas as máquinas empregadas, conforme detalhado na Seção 5.6.
Apesar de ganhos de desempenho relacionados à ocorrência de efeitos de cache ser uma interferência positiva, sua ocorrência é de difícil detecção.
De outro lado, possíveis efeitos relacionados à estrutura MDD adotada podem afetar o desempenho do algoritmo sequencial.
Tais efeitos podem ser provenientes das implicações causadas por o aumento do número de informações intermediárias criadas na estrutura MDD para obtenção do resultado da verificação.
Embora não se tenha feito estudos acerca de possíveis ocorrências destes efeitos na estrutura MDD em questão, alguns autores detectaram comportamentos de tal natureza.
Um exemplo deste comportamento é demonstrado por Joubert and Mateescu num algoritmo de verificação simbólico distribuído para µ-calculus.
Os autores citam como causa da ocorrência de speed-ups superlineares o uso de hash tables para armazenamento de conjuntos colisões tendem a ocorrer, sendo um fenômeno frequente para a versão sequencial da ferramenta desenvolvida, a qual usa uma única hash table para armazenamento, ao contrário de a implementação paralela, a qual endereça p tabelas menores, de modo que o balanceamento de variáveis em cada nodo empregado não apresente tal impacto.
Considerando este cenário e respectivos resultados elevados obtidos, uma abordagem que permita avaliar uma possível inteferência conforme acima relatada se fez necessária.
Para tal feito, algoritmos que visam a coleção de estruturas desnecessárias presentes na estrutura MDD foram empregados para ambas as abordagens, paralelas e sequencial.
De esta maneira, tais algoritmos realizam a liberação da memória alocada não mais necessária para a computação e posterior reordenação das hash tables utilizadas para armazenamento de variáveis da estrutura MDD.
Considerável redução do pico de consumo de memória e tempo de verificação são esperados.
Para exemplificação do impacto causado por a adoção de tais algoritmos, experimentos foram conduzidos para as Propriedades 5.6, 5.7 e 5.13, tendo os resultados apresentados nas Tabelas através das implementações inicialmente desenvolvidas é perceptível que a adoção dos algoritmos acima descritos interfere consideravelmente tanto na redução de tempo como consumo de memória para a implementação sequencial.
Este comportamento reforça a hipótese inicial de que o crescimento de estruturas intermediárias na estrutura MDD tende a interferir no desempenho da execução de operações necessárias a verificação de propriedades CTL.
De outro lado, analisando- se os tempos obtidos com a implementação paralela, um pequeno aumento no tempo de verificação é visualizado.
De fato, tal comportamento é causado por a execução das rotinas de liberação de memória anteriormente descritas, as quais apresentam uma pequena interferência durante a verificação.
Embora os resultados apresentem um pequeno aumento de tempo em relação as implementações inicialmente desenvolvidas, os ganhos de desempenho obtidos continuam sendo interessantes.
Entretanto, não mais se atingem speed-ups superlineares, podendo estes comportamentos ser visualizados nos gráficos de speed-up apresentados para as propriedades em questão.
Apesar de a queda de tempo de verificação sequencial o qual foi causado por a adoção dos algoritmos acima descritos, é interessante destacar que os ganhos de desempenho obtidos ainda são consideráveis, o que demonstra que os algoritmos paralelos desenvolvidos são eficientes.
Através da execução de tais experimentos, uma avaliação concreta dos ganhos de desempenho pôde ser obtida.
Embora ganhos em questão de tempo sejam de extrema importância, redução do consumo de memória também é esperado.
Conforme anteriormente descrito, a adoção dos algoritmos de coleção acima descritos permitem que sejam liberados espaços de memória alocados por a estrutura MDD os quais não sejam necessários num dado momento da computação.
A Figura 5.14 apresenta um gráfico com o pico de consumo de memória e consumo médio entre os processadores empregados para as propriedades em consideração.
Tomando como base os resultados apresentados na Seção 5.6, é percebido considerável redução do consumo de memória por a aplicação sequencial.
De outro lado, considerando- se os resultados obtidos com a implementação paralela, é notável que houve pequena redução no consumo de memória se comparado aos experimentos inicialmente conduzidos, demonstrando que os algoritmos de coleção pouco influenciam a implementação paralela.
Este comportamento pode ser explicado levando em consideração a distribuição da computação entre as máquinas, de maneira que haja distribuição das estruturas simbólicas intermediárias necessárias à obtenção do resultado da verificação e, desta maneira, a execução do algoritmo de liberação de tais espaços de memória tende a apresentar pouca influência.
Este trabalho integra um projeto de pesquisa que objetiva o desenvolvimento de um verificador de modelos para o formalismo Redes de Autômatos Estocásticos e propriedades descritas através da lógica temporal Computation Tree Logic (CTL).
Estão também em andamento o desenvolvimento de algoritmos de geração de contra-exemplos e testemunhas, algoritmos otimizados de verificação e tradução de modelos SAN para a sintaxe aceita por outras ferramentas de verificação.
O objetivo da pesquisa desenvolvida nesta dissertação é discutir, implementar e validar abordagens de verificação de propriedades para ambientes que usufruem de espaços de memória distribuídos.
Este trabalho apresentou duas propostas de algoritmos paralelos de verificação.
O primeiro passo da pesquisa compreendeu o desenvolvimento de um algoritmo que distribui a computação relacionada à verificação dos operadores mais custosos da lógica temporal adotada.
Após este passo, um algoritmo de análise e escolha de particionamento foi desenvolvido em virtude de permitir a verificação em paralelo de ramos independentes da árvore sintática que representa uma propriedade CTL escrita em Forma Normal Existencial.
Aplicou- se então a primeira abordagem paralela para distribuição das tarefas relacionadas à verificação dos operadores mais complexos presentes em cada partição identificada.
Para desenvolvimento das abordagens paralelas e posterior validação das mesmas, foi utilizada como base a implementação sequencial inicialmente desenvolvida a qual implementa os algoritmos descritos em.
Uma metodologia para condução dos experimentos e coleta de dados foi utilizada em conjunto com diferentes abordagens de execução visando avaliar os ganhos de desempenho obtidos.
Mesmo que os experimentos conduzidos tenham mostrado que ambas as implementações paralelas são favoráveis à verificação de determinadas propriedades, os objetivos da pesquisa foram alcançados.
O trabalho demonstrou que é possível reduzir o tempo de verificação de propriedades CTL através do algoritmo básico de satisfação descrito por Baier e Katoen, sem necessidade de emprego de técnicas complexas de particionamento de espaço de estados simbolicamente representados.
Para ambas as abordagens, é viabilizada boa escalabilidade de máquinas permitindo a verificação de complexas realidades modeladas em SAN, formalismo que inicialmente não contava com ferramental de verificação.
Embora a replicação da função de transição e da estrutura simbólica que representa o espaço de estados referente a a modelos SAN parecer pouco eficiente no que tange à consumo de memória, o trabalho demonstrou significativos ganhos em relação a a implementação sequencial.
A distribuição da computação relacionada à verificação de operadores da lógica temporal CTL permite que sejam distribuídas as estruturas simbólicas intermediárias relacionadas à obtenção do resultado da verificação, de forma que o consumo médio e pico de memória das máquinas empregadas seja consideravelmente inferior à implementação sequencial.
Apesar de a redução do consumo em cada máquina ser um ponto positivo, o uso de ambientes que endereçam espaços de memória distribuídos aliado à replicação de estruturas simbólicas gera redundância, sendo este um fator limitante à adoção destes ambientes.
Entretanto, esta técnica habilita as máquinas empregadas a realizarem o cálculo de estados sucessores/ antecessores de um dado estado localmente, permitindo exploração de conjuntos distintos de estados em cada máquina, de modo que comunicação é necessária somente para obtenção de ponto fixo.
Embora ganhos de desempenho relativamente baixos tenham sido obtidos para propriedades que exigem várias iterações sobre conjuntos de estados para obtenção de ponto fixo, o emprego de rotinas assíncronas de comunicação e otimizações na transferência de estados entre as máquinas empregadas tende a amenizar a sobrecarga de comunicação nestes casos.
Em casos que apresentam o comportamento inverso, ganhos de desempenho extremamente elevados são obtidos, de modo que ambas as abordagens possam contribuir na verificação de complexas realidades.
Trabalhos Futuros Considerando os benefícios e/ ou possibilidades de aprimoramento apresentados, são identificados os seguintes trabalhos futuros:
Otimizar a execução de rodadas de sincronia através do emprego de rotinas assíncronas de comunicação e desenvolver algoritmos de detecção de ponto fixo e término de computação necessários a esta abordagem;
Otimizar a troca de estados codificando- se estruturas simbólicas em formatos que permitam ser trafegados através de mensagens;
Empregar algoritmos de coleção de estruturas intermediárias desnecessárias presentes na estrutura de diagramas de decisão adotada;
Integrar uma abordagem de geração de contraexemplos e testemunhas;
Comparar o desempenho dos algoritmos descritos no trabalho com outras abordagens de verificação para sistemas distribuídos;
Otimizar a exploração do paralelismo através do emprego de opções de balanceamento de carga e escalonamento;
Implementar algoritmos de verificação e técnicas já conhecidas de agrupamento e particionamento de espaços de estados;
Implementar algoritmo paralelo de rotulação (Labelling Function) do espaço de estados.
