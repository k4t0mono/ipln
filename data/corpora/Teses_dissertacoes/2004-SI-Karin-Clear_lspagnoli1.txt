O Desenvolvimento Baseado em Componentes (DBC) é uma importante abordagem para o desenvolvimento de software com reuso.
Enquanto existe uma maior preocupação com o desenvolvimento de componentes, identifica- se uma grande carência de suporte ao desenvolvimento com componentes, que é baseado na seleção, adaptação e composição de componentes existentes.
A definição da arquitetura de componentes representa um aspecto crítico em DBC, pois define como os componentes selecionados serão integrados para atender os requisitos da aplicação.
Incompatibilidades entre os componentes selecionados podem comprometer sua utilização, de modo que devem ser descobertas e tratadas já durante a definição da arquitetura de componentes.
Com isso, adaptação e composição representam importantes atividades para a especificação da arquitetura de componentes, evidenciando a necessidade de suporte para sua realização já em nível arquitetural.
Em este trabalho é proposto um conjunto de funcionalidades próprias a um ambiente de DBC voltadas para a definição da arquitetura de componentes e suporte à realização das atividades de adaptação e composição de componentes através do emprego de padrões de projeto.
O emprego de padrões para a realização destas atividades representa a possibilidade de estabelecer a estrutura de solução para as incompatibilidades identificadas, que é incorporada à arquitetura de componentes.
Estas estruturas de solução serão detalhadas e implementadas nas fases subseqüentes do desenvolvimento de software.
A modelagem da arquitetura de componentes é desenvolvida neste trabalho a partir de o uso da notação UML 2.
0. Palavras-chave:
Desenvolvimento com componente, adaptação, composição, arquitetura de componentes, UML 2.
0, funcionalidades de apoio.
A Internet e suas tecnologias associadas têm mudado a forma como clientes, fornecedores e empresas interagem, conduzem seus negócios e colaboram.
Influenciado por esta realidade, o atual contexto do desenvolvimento de software compreende a definição de grandes e complexos sistemas para atender as mais diferentes demandas.
Além de prover funcionalidades cada vez mais complexas, estes sistemas não podem negligenciar as constantes mudanças nas empresas e no mercado, o que faz com que exista também uma necessidade iminente de desenvolver sistemas capazes de serem alterados rapidamente para se adequar às mudanças e novas exigências.
As exigências de qualidade e produtividade confrontam- se com o aumento da complexidade dos sistemas.
A competitividade exige que os sistemas sejam desenvolvidos num período de tempo cada vez mais curto e que apresentem, ao mesmo tempo, uma qualidade cada vez maior.
Atender e suportar estas exigências representa um desafio a mais no desenvolvimento de software.
Dirigidas por os atuais desafios do desenvolvimento de software, muitas empresas têm repensado sua abordagem de projetar, implementar e manter sistemas.
Entre as novas direções do desenvolvimento de software se tem reiterado o interesse em abordagens orientadas ao reuso, onde se destaca o Desenvolvimento Baseado em Componentes (DBC).
DBC enfatiza o desenvolvimento de aplicações através da composição planejada de componentes de software pré-existentes.
O interesse nesta abordagem está centrado nas suas potenciais vantagens, que incluem:
Melhoria na gerência da complexidade do sistema;
Redução do tempo de entrega do produto;
Possibilidade de reusar as melhores soluções de cada área;
Aumento da produtividade;
Aumento da qualidade;
Suporte ao desenvolvimento em paralelo e distribuído;
E redução de custos de manutenção.
DBC é uma abordagem que também se caracteriza por apresentar inúmeras questões em aberto, como a falta de consenso quanto a definições e nomenclatura utilizada.
Componente, elemento chave de DBC, é um exemplo de termo que apresenta uma falta de consenso quanto a sua definição.
Inúmeras definições de componentes são encontradas na literatura, e elas se diferenciam quanto a o que consideram ser um componente, os aspectos do componente que procuram ressaltar, bem como a etapa do ciclo de vida de desenvolvimento a qual se referem Atualmente, existe uma maior ênfase em considerar componentes apenas como componentes de código, ao invés de considerar- los como qualquer parte do sistema de software que possa ser identificada e reusada.
Em esta visão mais ampla, componentes são considerados o estado seguinte de abstração depois de funções, módulos e classes.
Dentro de a visão de componentes de código, a definição de estabelece que um «componente de software é uma unidade de composição com interfaces contratualmente especificadas e apenas explícitas dependências de contexto.
Componente de software pode ser usado independente e combinado com outras partes».
Esta definição delimita o que é um componente, estabelecendo as características a serem atendidas por os artefatos para que sejam considerados como tal.
No entanto, esta definição não impõe restrições quanto a as possíveis formas em as quais um componente pode estar disponibilizado.
Com esta abertura, é possível considerar a existência de componentes em diferentes níveis de abstração, de modo que eles podem tanto assumir a forma de um artefato manipulado em tempo de projeto, como de código fonte e/ ou executável utilizados na fase de implementação.
A possibilidade de se ter componentes em diferentes níveis de abstração é importante para permitir que as preocupações com componentes estejam presentes desde as fases iniciais do ciclo de vida de desenvolvimento, visando garantir a manutenção dos potenciais ganhos esperados com o reuso.
Em termos de modelagem, a atual preocupação com componentes também está quase que exclusivamente restrita à fase de implementação.
Por exemplo, identifica- se na UML 1_ X (Unified Modeling Language) uma tardia preocupação com componentes, os quais são tratados exclusivamente como artefatos de implementação.
Entretanto, o OMG (Object Management Group) vem realizando uma extensa revisão visando a definição da UML 2.
0, que entre outras características está voltada a oferecer um suporte mais adequado a DBC, possibilitando que componentes sejam modelados ao longo de todo o ciclo de vida DBC caracteriza- se por enfatizar tanto o desenvolvimento de software visando a construção de componentes reusáveis (desenvolvimento de componentes), quanto desenvolvimento a partir de o reuso de componentes (desenvolvimento com componentes).&amp;&amp;&amp;
O primeiro enfoque preocupa- se com a concepção e implementação de componentes, e o segundo está voltado para o desenvolvimento de aplicações a partir de o reuso de componentes préexistentes.
Este trabalho enfoca esta segunda abordagem de DBC.
O desenvolvimento com componentes apresenta um conjunto de atividades voltadas à procura e aplicação dos componentes, entre as quais se destacam as atividades de adaptação e composição, por serem aquelas que efetivamente viabilizam a definição das aplicações baseadas em componentes pré-existentes.
Adaptação representa o processo de alteração comportamental e/ ou estrutural de um componente para se adequar aos requisitos de uma aplicação em particular.
Composição é a atividade de integração de diferentes componentes para o desenvolvimento de uma aplicação.
Embora caracterizadas como duas atividades distintas, muitas adaptações surgem em virtude de dificuldades na composição dos componentes, o que acaba estabelecendo um forte relacionamento entre estas atividades e criando uma dificuldade adicional na distinção entre qual atividade está sendo efetivamente realizada.
A preocupação com as atividades de adaptação e composição também se encontra centrada na fase de implementação.
A grande parte dos trabalhos relacionados a estas atividades as considera como sendo realizadas em componentes na forma de código fonte e/ ou executável, de modo que as técnicas estão em muitos casos vinculadas a paradigmas e linguagens de programação.
De uma maneira geral, estas duas atividades envolvem um conjunto repetitivo de ações visando a correção das incompatibilidades existentes e integração dos componentes.
O uso de padrões de projeto é uma possível alternativa para o suporte à realização de adaptações e composições.
Além de a existência de técnicas de adaptação análogas a determinados padrões, a motivação para o uso dos padrões está relacionada à possibilidade de usar soluções bem sucedidas para a execução destas importantes atividades, evitando o trabalho repetitivo.
Com a intenção de antecipar as preocupações com componentes para as fases iniciais do ciclo de desenvolvimento, este trabalho explora a visão lógica de componente de código e foca na definição de arquitetura de componentes.
Em DBC, o termo arquitetura assume uma forma mais restrita como arquitetura de componentes, a qual é estabelecida por um grupo de componentes, seus relacionamentos estruturais e suas dependências comportamentais.
Em o âmbito do desenvolvimento com componentes, a definição da arquitetura de componentes envolve a realização das atividades de adaptação e composição.
Diferenciando- se do enfoque centrado na fase de implementação, neste trabalho, adaptação e composição são tratadas em nível arquitetural, sendo realizadas em componentes lógicos.
A possível existência de implementações para estes componentes lógicos é indiferente, pois o interesse está centrado na especificação das interfaces providas e requeridas dos componentes.
Tratar as adaptações e composições em nível arquitetural representa a possibilidade de estabelecer a arquitetura de componentes já considerando estruturas de soluções que corrijam as incompatibilidades prematuramente detectadas.
A proposta deste trabalho é utilizar padrões de projeto para a definição de um esqueleto de solução incorporado à arquitetura de componentes.
As diferentes etapas e atividades de DBC instituem a necessidade de ambientes que forneçam funcionalidades que apóiem a sua execução, seja facilitando ou automatizando a realização das tarefas.
Entretanto, verifica- se uma carência bastante acentuada de ambientes para DBC, em especial que suportem a realização das atividades de adaptação e composição.
Além de a existência destes ambientes ser bastante restrita, os existentes enfatizam o desenvolvimento de componentes oferecendo suporte às questões de implementação e mantendo vínculos com tecnologias específicas, ao invés de o projeto de aplicações com componentes.
Igualmente, o uso de padrões está restrito a ambientes que os utilizam como elementos base para o desenvolvimento de componentes.
Partindo deste panorama, este trabalho visa a identificação e definição de funcionalidades próprias a um ambiente de DBC que permitam o desenvolvimento de aplicações com componentes, focando a definição de arquitetura de componentes, e que suportem as atividades de adaptação e composição de componentes neste nível através do uso de padrões.
Além de a identificação e definição destas funcionalidades, este trabalho também irá estabelecer o contexto de aplicação destas funcionalidades dentro de o ciclo de desenvolvimento, bem como especificar e implementar um ambiente de apoio que incorpore e exemplifique o uso das funcionalidades definidas.
Com o desenvolvimento deste trabalho espera- se contribuir para minimizar as carências relativas ao desenvolvimento com componentes, suas principais atividades, e aos ambientes de DBC, bem como contribuir para antecipação da preocupação com componentes para as fases iniciais do ciclo de vida de desenvolvimento de software.
O estudo realizado nesta dissertação tem como objetivo geral a definição de um conjunto de funcionalidades para ambientes de DBC que suportem o desenvolvimento de aplicações com componentes.
Frente a este objetivo geral, foram definidos os seguintes objetivos específicos:
Antecipar a preocupação com componentes para as fases iniciais do ciclo de desenvolvimento;
Atuar frente a a carência de ambientes de apoio a DBC;
Fornecer suporte ao desenvolvimento com componentes;
Prover auxílio à execução das atividades de adaptação e composição de componentes em nível arquitetural;
Utilizar padrões de projeto como mecanismo auxiliar para o tratamento das atividades de adaptação e composição de componentes;
Empregar as definições para modelagem de componentes em nível lógico da UML 2.
0; Especificar e implementar um ambiente de apoio que incorpore as funcionalidades definidas;
Demonstrar a aplicação das funcionalidades através do protótipo implementado.
A elaboração deste trabalho teve como ponto de partida um primeiro levantamento e estudo da base teórica.
Através deste levantamento, foi identificada uma carência de suporte ao desenvolvimento com componentes e, em especial, às atividades de adaptação e composição de componentes.
A carência identificada motivou a definição dos objetivos geral e específicos do trabalho, e a identificação das atividades subseqüentes.
Como seqüência do trabalho foram realizados estudos sobre as atividades alvo (adaptação e composição) e levantamento da potencialidade do uso de padrões como mecanismo auxiliar a sua realização.
Identificou- se um conjunto de situações que caracterizam a necessidade de adaptação e/ ou composição de componentes e, para cada uma das situações, realizou- se a análise de possíveis padrões que poderiam ser aplicados.
Como resultado desta atividade definiu- se a viabilidade do uso de padrões e quais seriam utilizados no contexto deste trabalho.
Foram selecionados os padrões Adapter, Proxy e Facade, de modo a ilustrar a aplicabilidade de padrões como mecanismo auxiliar ao tratamento das atividades de adaptação e composição de componentes.
Durante esta etapa também foram estudadas as versões preliminares da especificação UML 2.
0, visando analisar o suporte oferecido à especificação lógica de componentes.
Este estudo da UML 2.
0 também procurou analisar o emprego da notação de componentes para a modelagem das adaptações e composições através do uso de padrões.
Estas atividades permitiram conferir as alterações existentes na UML 2.
0 e a viabilidade de sua utilização neste trabalho.
Também foram estudados métodos de DBC, através de os quais se procurou identificar o contexto de ocorrência das atividades de adaptação e composição de componentes, bem como análise do suporte dos métodos ao desenvolvimento com componentes e definição da arquitetura de componentes.
Ainda foi realizado um levantamento de ambientes de apoio a DBC, que embora tenha apontado a existência de um número bastante restrito de ambientes, possibilitou a identificação de um conjunto de requisitos a serem considerados por os ambientes para o efetivo apoio a DBC, e a análise de como os padrões são utilizados nos ambientes existentes.
A execução destas atividades levou a identificação e definição do conjunto de funcionalidades propostas neste trabalho.
Como última etapa foi especificado e implementado um protótipo do ambiente de apoio a DBC, o qual incorpora as funcionalidades definidas e permite exemplificar como elas podem ser aplicadas.
A Figura 1 apresenta o desenho de pesquisa deste trabalho exploratório centrado na revisão da literatura.
Esta figura não segue nenhuma notação específica e tem por objetivo ilustrar as atividades desenvolvidas ao longo de o trabalho, descritas anteriormente.
Esta dissertação está dividida em 9 capítulos, assumindo a seguinte organização.
O Capítulo 2 discute os conceitos de DBC necessários a este trabalho e apresenta as definições da UML 2.
0 para a modelagem de componentes.
O Capítulo 3 aborda as perspectivas de desenvolvimento em DBC, com especial atenção para o desenvolvimento com componentes, e analisa alguns métodos de DBC existentes.
As atividades de adaptação e composição de componentes são discutidas no apoio a adaptação e composição de componentes propostas neste trabalho são apresentadas no de apoio.
Este trabalho finaliza com a apresentação das conclusões, limitações e trabalhos futuros no Capítulo 9.
Este capítulo discute o conceito de componentes, considerando as diferentes definições e visões existentes na literatura.
Além de a definição, são discutidas propriedades que caracterizam um componente, o que são interfaces e modelos de componentes, a diferença entre componentes e objetos, o relacionamento entre componentes e arquitetura de software, e as definições da UML 2.
0 para modelagem de componentes.
O propósito é fornecer uma visão geral de componentes e dos conceitos relacionados.
Componentes são elementos fundamentais de DBC e seu entendimento é um requisito para compreender esta abordagem.
Entender este e outros termos básicos de DBC representa um desafio em virtude de a falta de consenso em torno de sua definição.
Inúmeras definições de componentes são encontradas na literatura e muitas falham por fornecerem uma definição apenas intuitiva e destacarem aspectos gerais, o que não ajuda a delimitar e esclarecer o que são componentes.
Além de existirem diferenças quanto a os aspectos que estas definições ressaltam, também existem visões bastante distintas quanto a o que pode ser considerado um componente.
Em é apresentado que componentes podem ser vistos como alguma parte do sistema de software que é identificável e reusável, ou como o estado seguinte de abstração depois de funções, módulos e classes.
Desta forma, enquanto apresenta uma visão bastante ampla do que pode ser um componente, outras definições encontradas na literatura (e.
g) são bem menos genéricas, voltadas para uma visão de componentes como elemento de código.
Observa- se na preocupação com o reuso em todas as etapas do processo de desenvolvimento de software, por isso sua definição é intencionalmente genérica quanto a o que é um componente, de forma a permitir o maior grau de reuso possível.
Enquanto isso, e não apresentam uma ampla preocupação com o reuso e tratam componentes num âmbito mais restrito, considerando componentes como apenas um tipo de artefato.
Embora mais restrita, as definições de e representam o aspecto mais maduro de DBC, por ser a visão que recebe maior ênfase atualmente.
Este trabalho adota a definição proposta em, que estabelece como propriedades características dos componentes o fato de serem unidades de atuação independente, de poderem ser combinados a outras partes e não apresentarem persistência de estado.
A análise abaixo de cada uma destas propriedades permite um melhor entendimento de componentes.
O fato do componente ser identificado como uma unidade de atuação independente exige que ele seja bem separado do ambiente e dos demais componentes, inclusive fazendo com que o componente encapsule suas propriedades constituintes e suas interações ocorram apenas através de interfaces bem definidas.
Para que o componente possa ser alvo de combinação com outras partes, é necessário que ele seja autocontido, bem como possua uma especificação clara do que o componente requer para o seu reuso e o que ele provê.
Além disso, os componentes não devem apresentar persistência de estado, ou seja, não devem manter dados que são específicos da aplicação em que são utilizados, de forma que não existam diferenças entre cópias de um mesmo componente.
Além de as propriedades apresentadas anteriormente, uma importante característica dos componentes é o fato de possuírem interfaces.
As interfaces são as especificações dos pontos de contanto entre os componentes, e compreendem o conjunto de operações que estabelecem o comportamento do componente.
Além disso, as interfaces determinam a separação entre especificação e implementação, permitindo a mudança da implementação sem alteração da interface, o que possibilita que os componentes sejam substituídos, desde que atendam à mesma especificação de interfaces.
As interfaces estão voltadas à expressão de propriedades funcionais, as quais incluem a assinatura das operações providas por o componente, bem como a especificação do comportamento do componente.
Verifica- se, entretanto, que muitas técnicas para descrever interfaces (e.
g IDL ­ Interface Definition Language) estão voltadas apenas para a parte de assinatura das operações.
Um maior detalhamento da especificação do comportamento do componente pode ser alcançado através da noção de contratos.
Contratos determinam as restrições gerais que o componente irá manter.
Para cada operação do componente, o contrato relaciona as definições a serem obedecidas por os clientes do componente (pré-condições) e aquelas que o componente se compromete em estabelecer como retorno (pós-condições).
Além de especificarem o comportamento de um único componente, os contratos também podem ser usados para especificar a interação entre grupos de componente, definindo, por exemplo, quem são os componentes participantes e o papel de cada um através das obrigações contratuais.
A definição de componentes de retrata a visão de componente preocupada com componentes de código, mas não limita os componentes a serem considerados apenas na forma de elementos físicos.
Em razão de esta ausência de restrição quanto a a forma de disponibilização dos componentes, entende- se que a definição de permite caracterizar componente tanto como sendo um artefato que pode ser manipulado em tempo de projeto através de suas interfaces, como representando código fonte e/ ou executável na fase de implementação.
Assim como os componentes podem assumir diferentes formas, de acordo com o nível de abstração, não existe a obrigatoriedade dos componentes em nível de projeto possuírem alguma implementação correspondente.
Ou seja, o importante neste nível é a especificação das interfaces, independente de elas serem ou não implementadas por componentes físicos.
Esta visão dual de componente (lógico e físico) torna- se importante na medida em que existe a intenção de antecipar as preocupações com componentes para as fases iniciais do ciclo de vida, visando preservar os potenciais ganhos do reuso, e estabelecer a relação dos componentes para formar a arquitetura em tempo de projeto.
Modelo e Framework de Componentes Os componentes, segundo, combinam duas distintas perspectivas:
Implementações e abstrações arquiteturais, podendo assumir a forma de implementações arquiteturais.
Vistos como implementações, os componentes representam artefatos de software que podem ser disponibilizados e usados para compor grandes (sub) sistemas.
Por outro lado, vistos como abstrações arquiteturais, os componentes expressam regras de projeto que impõem um modelo padrão de coordenação para todos os componentes.
Estas regras de projeto assumem a forma de um modelo de componente, ou de um conjunto de padrões e convenções com as quais os componentes devem estar em conformidade.
Modelos de componentes especificam padrões e convenções impostas aos desenvolvedores de componentes, de modo a descrever a função de cada componente e como eles interagem entre si.
Com isso busca- se expressar restrições de projeto arquitetural ou global.
A obediência ao modelo de componentes é uma das propriedades que distinguem componentes de outros pacotes de software.
O framework de componentes, conforme, é a implementação de serviços que dão suporte ou reforçam o modelo de componentes.
A função do framework é gerenciar os recursos compartilhados por os componentes e prover um mecanismo que possibilite a comunicação (interação) entre eles.
A infra-estrutura oferecida por os frameworks de componentes impõem restrições e regras no projeto e implementação, as quais devem ser consideradas por o modelo de componentes.
Por esta razão, existe na literatura uma certa confusão relacionada aos termos modelo de componentes e framework de componentes.
Embora não exista ainda um consenso sobre o que deve ou pode estar incluído num modelo de componentes, é esperado que através de ele sejam definidos os seguintes padrões e convenções:
Tipos de componentes:
Definidos em termos de as interfaces que implementam, onde cada interface num componente corresponde a um tipo.
Caso um componente implemente as interfaces A e B, então ele é do tipo A e B, o que lhe garante uma capacidade polimórfica em relação a estes tipos.
Isto permite que estes diferentes tipos de componentes desempenhem diferentes papéis no sistema, bem como participem de diferentes formas de interação.
Formas de interação:
Definição de formas de interação entre componentes e o framework de componentes, através da especificação de como os componentes são localizados, o protocolo de comunicação usado e como a qualidade dos serviços é alcançada.
A classe de interação entre componentes compreende restrições quanto a os tipos de componentes que podem ser clientes de outros tipos, o número de possíveis clientes simultâneos e outras restrições topológicas.
A classe de interação entre componentes frameworks inclui definições relacionadas gerenciamento de recursos, como o ciclo de vida de um componente (ativação, desativação), formas de gerência, persistência e assim por diante.
As formas de interação podem dizer respeito a todos os tipos de componentes ou apenas a tipos particulares.
Definição de recursos:
A composição dos componentes é realizada por a ligação dos componentes a um ou mais recursos, onde um recurso pode ser tanto provido por um framework de componentes como por algum componente utilizado no framework.
O modelo de componentes descreve quais recursos estão disponíveis a cada componente e como e quando eles são associados a estes recursos.
Em contrapartida, o framework vê os componentes como recursos a serem gerenciados.
A Figura 2 permite identificar o framework de componentes como a infra-estrutura de suporte a comunicação e ligação dos componentes, através do fornecimento de serviços de coordenação.
Já o modelo de componentes identifica as definições quanto a tipos de componentes, formas de interação e recursos necessários.
Os componentes definidos para executarem determinadas funcionalidades, devem estar em conformidade com as definições do modelo de componentes, pertencendo a um dos possíveis tipos e respeitando as formas de interação definidas, além de utilizarem os serviços disponibilizados.
Sendo assim, a utilização dos componentes caracteriza a ligação entre modelo e framework de componentes.
Arquitetura de Software Existe em DBC um relativo consenso quanto a a impossibilidade de separar componentes e arquitetura de software.
Segundo, um componente não pode ser visto de forma completamente independente dos outros componentes com os quais se relaciona e de seu ambiente.
A arquitetura de software assume um importante papel por ser a partir de ela que é possível especificar de forma mais detalhada como se dá a interconexão entre os componentes.
Detalhar como é o relacionamento dos componentes é necessário para permitir a substituição ou adição de novos componentes.
Além disso, a definição desta arquitetura estará relacionada ao modelo de componentes, pois ela terá de observar as definições e convenções impostas por o modelo de componentes em uso.
Em DBC o termo arquitetura de software assume um sentido mais restrito sob a forma de arquitetura de componentes.
A arquitetura de componentes é definida por como o &quot;conjunto de componentes de software, seus relacionamentos estruturais e suas dependências comportamentais».
Em esta definição, os relacionamentos estruturais compreendem associações e heranças entre especificações de componentes e as interfaces dos componentes, bem como o relacionamento de composição entre componentes.
Já as dependências comportamentais, correspondem a relacionamentos de dependência entre componentes e outros componentes, entre componentes e interfaces, e entre interfaces.
Esta visão mais restrita da arquitetura de componentes mantém a preocupação centrada nas especificações de componentes e interfaces, ao invés de todos os elementos do sistema de software, possivelmente organizados em diferentes camadas.
Existem inúmeras definições para arquitetura de software na literatura.
No entanto, de uma maneira geral, as definições remetem a idéia de arquitetura como a estrutura ou estruturas de um sistema, incluindo os elementos de software e seus relacionamentos.
Diferente da arquitetura de componentes, na arquitetura de software, os elementos não estão restritos a serem componentes.
Além disso, as definições de arquitetura de software incluem uma preocupação com a definição de princípios e diretivas que governem o projeto e evolução dos elementos ao longo de o tempo.
Com estas diferenças de escopo e preocupações, a arquitetura de componentes pode ser vista como uma das partes da arquitetura de software de um sistema, voltada exclusivamente ao detalhamento do relacionamento dos componentes.
Orientação a Objetos Freqüentemente DBC é considerado o passo seguinte após a programação orientada a objetos.
Com isso, não é surpreendente que componentes sejam freqüentemente relacionados com objetos e que algumas vezes o termo componente seja usado como sinônimo de objeto.
Entretanto, os conceitos de componentes e objetos são independentes.
Conforme apresentado em, a tecnologia de objetos é útil e um conveniente ponto de partida para DBC.
No entanto, ela não expressa todo o grau de abstração necessária para DBC e é possível realizar o desenvolvimento de componentes sem empregar- la.
Desta forma, ressalta que a tecnologia de objetos não é nem necessária, nem suficiente para DBC.
Contudo, uma das tendências exploradas tem sido a combinação destas duas técnicas.
A maior granularidade dos componentes em relação a as classes favorece a modularidade e reuso buscados por a modelagem de objetos.
Em contrapartida, a rigorosa disciplina de especificação da modelagem de objetos auxilia o projeto baseado em interfaces e a possibilidade de substituição pretendida por os componentes.
Em este sentido, a análise, projeto e desenvolvimento da orientação a objetos constituem o conjunto de tecnologias e métodos naturalmente usados em A sinergia entre estas duas técnicas pode ser vista na próxima seção, através da discussão das definições da UML 2.
0 para modelagem de componentes.
A UML representa uma importante alternativa para possibilitar a modelagem dos componentes e suas interfaces, e permitir a definição da arquitetura de componentes.
Entretanto, voltada originalmente para a orientação a objetos, ela apresenta diferentes restrições em seu uso mais voltado a DBC, além de problemas de ordem geral.
Segundo, entre os problemas das versões 1_ X estão:
Tamanho excessivo, complexidade desnecessária, semântica imprecisa, implementações não padronizadas, customização limitada, incapacidade de intercâmbio de modelos de diagramas e, principalmente, suporte inadequado para o desenvolvimento baseado em componentes.
Atento à carência de suporte a DBC, bem como buscando atender às inúmeras solicitações de melhoria da UML, o OMG vem realizando uma extensa revisão para a definição da UML 2.
0. Inúmeras alterações já podem ser verificadas nas especificações preliminares desta nova versão.
A UML 2.
0 apresenta duas especificações complementares:
Infra-estrutura (Infrastructure) e Superestrutura (Superstrucutre), sendo que esta segunda tem foco nas propriedades comportamentais da UML.
As definições quanto a notação e semântica de componentes estão descritas na especificação Superestrutura, e são alvo de discussão nesta seção.
Ambas as especificações da UML 2.
0 já passaram por a revisão do OMG e estão em fase de finalização, o que indica que muito em breve estarão sendo oficializadas.
A UML 2.
0 estabelece componentes como uma unidade autocontida que encapsula o estado e comportamento de um número de classifiers1, e que pode ser substituída em seu ambiente.
A definição de componentes da UML 2.
0 suporta tanto a especificação de componentes lógicos (e.
g componentes de negócio), como de componentes físicos (e.
g componentes EJB,_ Net e WSDL).
Com isso um componente passa a poder ser modelado por todo ciclo de vida de desenvolvimento.
Coleção de instâncias que apresentam alguma coisa em comum, sendo que as instâncias são caracterizadas por as propriedades apresentadas por o classifier.
São exemplos de classifier:
Interfaces, classes e componentes.
Os componentes na UML 2.
0 apresentam uma especificação externa na forma de uma ou mais interfaces providas e requeridas, e uma implementação interna que consiste de um ou mais classifiers que realizam o seu comportamento.
Interfaces compreendem um conjunto nomeado de operações que caracterizam o comportamento do componente, e são usadas para a especificação de características estruturais, como atributos e associações, e de características comportamentais, como operações e eventos.
As interfaces providas representam os serviços oferecidos por o componente e as interfaces requeridas, os serviços que o componente requer de outros componentes ou serviços do sistema.
A Figura 3 ilustra a notação estabelecida na UML 2.
0 para componentes e interfaces providas e requeridas.
Um componente é modelado como um retângulo com o estereótipo Opcionalmente um ícone de componente pode ser apresentado no canto superior direito.
As interfaces são definidas através de retas com os símbolos ball (provida) ou socket (requerida) em sua extremidade.
As interfaces (providas e requeridas) podem ser, opcionalmente, organizadas através de portas, que possibilitam a definição de conjuntos nomeados de interfaces que são tipicamente (mas nem sempre) endereçados em tempo de execução.
Podem ser definidas múltiplas portas para um mesmo classifier, possibilitando distinguir diferentes pontos de interação, sendo que a natureza destas interações é definida de acordo com as interfaces associadas.
A UML 2.
0 define duas distintas visões para componentes.
A visão externa (black-box) torna visíveis publicamente propriedades e operações dos componentes através da apresentação das interfaces para fora de o componente.
Como exemplo desta visão é apresentado o componente CestaCompra na Figura 4 (a), em que estão apresentadas as interfaces iPedido e iConversão, externas ao componente.
Alternativamente, as interfaces e/ ou operações individuais e atributos podem ser listadas em compartimentos internos do componente, como apresentado por o componente CestaCompra na Figura 4 (b) que tem em seu segundo compartimento a lista de interfaces e alguns métodos de uma destas interfaces.
As interfaces providas e requeridas formam o básico para a conexão (wiring) dos componentes através de conectores.
Em a UML 2.
0 estão definidos dois tipos de conectores para a ligação dos componentes e destes com seus classifiers:
Conector de delegação e conector de montagem.
O conector de delegação liga o contrato externo do componente, como especificado por suas interfaces (ou portas), e a realização interna do comportamento estabelecida por as partes (classifiers) do componente.
Este conector representa a passagem de sinais, ou seja, operações requisitadas e eventos.
Desta forma, o conector de delegação permite que um sinal que é recebido numa interface/ porta seja repassado para ser tratado por seu destino, que pode ser uma das partes do componente ou outra interface/ porta.
A Figura 5 (b) ilustra a utilização dos conectores de delegação (linhas com setas numa das extremidades) para a ligação das interfaces e partes internas do componente CestaCompra.
Já o conector de montagem é estabelecido entre interfaces de dois componentes, definindo que um componente provê serviços que outro componente requer.
Este conector é nomeado como ball- and-- socket na UML 2.
0, em virtude de caracterizar a ligação de uma interface provida (ball) e uma interface requerida (socket).
A Figura 6 ilustra a utilização deste conector para a ligação da interface provida iConversaoMoeda do componente ConversaoDolar, com a interface requerida iConversão do componente CestaCompra.
Opcionalmente, o conector de montagem pode ser substituído por a notação usada para dependência (uma reta tracejada com uma seta numa das extremidades).
O uso da notação de dependência representa unicamente uma alternativa de notação, pois não existem diferenças de semântica ou vantagens/ desvantagens de uma notação em relação a a outra.
A notação de dependência é utilizada na Figura 6 para ligar as interfaces iPedido do componente CestaCompra com a interface iPedido do componente GerenciaPedido.
Os conceitos e notações apresentados permitem identificar na UML 2.
0 um suporte mais adequado à modelagem de componentes, se comparado ao fornecido por as versões 1_ X. A inclusão dos conceitos de interfaces providas e requeridas, e conectores são questões chave, pois possibilitam a modelagem de aspectos próprios dos componentes, como a diferenciação entre o que é oferecido e o que é necessário para o funcionamento de um componente, bem como a conexão de componentes e suas partes internas.
Igualmente, os novos conceitos e notação viabilizam a modelagem de componentes em diferentes níveis de complexidade.
Os componentes deixaram de ser um conceito exclusivo da fase de implementação, como ocorria nas versões 1_ X, e se tornaram na UML 2.
0 um conceito que se desenvolve por todo o ciclo de vida.
Este capítulo buscou apresentar diferentes e importantes conceitos de DBC.
Em este sentido, foram discutidas a falta de consenso quanto a a definição de componentes e as diferentes visões encontradas na literatura.
Este trabalho trata componentes em nível lógico, onde se considera que os componentes possuem especificações de suas interfaces e são representados seguindo a notação da UML 2.
0. Esta visão lógica é derivada a partir de a definição de componentes propostas por que caracteriza componente dentro de a visão de código, mas mantém aberta a possibilidade de considerar- los em diferentes níveis de abstração.
A possibilidade de considerar componentes numa abordagem lógica, em oposição aos componentes na forma de código fonte/ executável, permite a antecipação das preocupações com componentes para as fases iniciais do ciclo de desenvolvimento de software.
Esta antecipação visa garantir os ganhos esperados com o reuso, e viabiliza a definição de arquitetura de componentes.
Em DBC, arquitetura assume um sentido mais restrito na forma de arquitetura de componentes, ou seja, o conjunto de componentes, seus relacionamentos estruturais e suas dependências comportamentais baseados nas interfaces.
Diferente das versões 1_ X, a UML 2.
0 representa uma importante alternativa para a modelagem da arquitetura de componentes por o suporte que oferece.
Como visto, a UML 2.
0 permite a modelagem dos componentes, suas interfaces e as ligações existentes entre interfaces/ componentes, oferecendo um suporte mais adequado à modelagem dos componentes e de arquitetura de aplicações baseadas em componentes.
Este capítulo inicia com a discussão do processo de desenvolvimento em DBC e suas duas possíveis perspectivas:
Desenvolvimento de componentes e desenvolvimento com componentes.
Com enfoque no desenvolvimento com componentes, na seqüência uma abordagem genérica para modelagem de DBC é apresentada, alguns métodos de DBC existentes são analisados e o método UML Components é discutido em detalhes.
O propósito é fornecer uma visão das duas possíveis perspectivas de DBC e de seu suporte metodológico.
DBC endereça desafios e problemas similares aos verificados na Engenharia de Software de uma maneira geral quanto a o desenvolvimento de software.
Com isso, muitos métodos, ferramentas e princípios da engenharia de software usados em outros tipos de sistema são usados ou da mesma forma ou de forma similar em DBC.
Apesar de as semelhanças, DBC se diferência por focar especificamente em componentes, e por distinguir o desenvolvimento dos componentes, do desenvolvimento de sistemas a partir de o seu uso.
Desta forma, DBC se caracteriza por abranger duas perspectivas:
Desenvolvimento de componentes e desenvolvimento com componentes.
O desenvolvimento de componentes se preocupa com a concepção e implementação de componentes.
Estes componentes devem ser desenvolvidos observando todas as premissas que permitam o seu posterior reuso, o que representa desafios adicionais.
Ou seja, existe uma maior dificuldade em gerenciar os requisitos, o esforço para projetar componentes reusáveis é maior, e é necessária uma especificação clara e completa do componente.
Com a ênfase no posterior reuso, o desenvolvimento de componentes tem como produto não apenas o componente, mas também toda a documentação que viabilize o seu reuso.
Enquanto isso, o desenvolvimento com componentes representa o desenvolvimento de sistemas a partir de a integração planejada de componentes pré-existentes, envolvendo atividades de busca e uso de componentes.
O foco desta dissertação recai sobre esta segunda perspectiva.
O desenvolvimento com componentes busca o reuso de componentes, os quais integrados darão origem ao sistema pretendido.
A ênfase não está diretamente na implementação do sistema projetado, mas sim no reuso de componentes pré-existentes.
Desta forma, é primordial que já existam componentes disponíveis para serem selecionados e reutilizados para composição dos sistemas.
Enquanto esta abordagem congrega muitas das potenciais vantagens de DBC, existem também inúmeras desvantagens, como:
A dificuldade de encontrar componentes que atendam aos requisitos e se enquadrem no projeto do sistema;
A quantidade de esforço extra para integrar componentes;
Perda de desempenho por a combinação de diferentes componentes;
E questões relativas à confiabilidade dos componentes.
Segundo, as atividades essenciais para o desenvolvimento com componentes são:
Encontrar componentes com potencial de serem usados no desenvolvimento da aplicação;
Selecionar os componentes que atendam os requisitos de uma aplicação específica;
Realizar adaptações;
Realizar a composição dos componentes;
Atualizar os componentes.
Seleção: Esta primeira atividade consiste em pesquisar e selecionar componentes que apresentam potencial de serem usados no desenvolvimento do sistema.
Os componentes podem ser procedentes de diferentes origens, incluindo componentes já desenvolvidos para outros projetos e componentes desenvolvidos e comercializados por diferentes empresas.
Esta atividade compreende um processo de investigação das propriedades e da qualidade do componente, embora nesta etapa ainda saiba- se pouco das características dos componentes.
As informações disponíveis podem incluir apenas nome do componente, seus parâmetros e uma breve descrição das exigências operacionais para a execução do componente (e.
g configurações de ambiente, sistema operacional, etc).
O objetivo desta atividade é gerar uma relação de componentes candidatos, os quais serão avaliados na próxima etapa para a determinação daqueles que realmente serão utilizados.
As dificuldades intrínsecas desta atividade de seleção correspondem à definição do que pode ser visto como um componente por parte de a aplicação e, com isso, qual componente, entre os existentes, é apropriado para ser utilizado.
Caso nenhum candidato a componente venha a ser selecionado nesta etapa, se torna necessário desenvolver o componente ao invés de reutilizar um já existente, partindo assim para a perspectiva de desenvolvimento de componentes.
Qualificação: Esta etapa consiste em garantir que o componente candidato executa as funcionalidades necessárias, ajusta- se ao estilo arquitetural definido para o sistema e apresenta qualidades que são necessárias para a aplicação (e.
g desempenho, confiabilidade, usabilidade).
Em esta etapa são verificadas as interfaces que podem ser fonte de conflito e são identificadas as sobreposições entre componentes.
A qualificação geralmente envolve uma análise detalhada de toda a documentação ou especificação disponível, discussão com os desenvolvedores dos componentes e usuários, e teste de execução do componente em diferentes cenários.
Quanto mais rigorosas forem as descrições dos componentes disponíveis, mais a atividade de qualificação pode ser reduzida a validar o funcionamento através de experiências e do uso temporário do componente.
Adaptação: Atividade que busca corrigir potenciais fontes de conflito entre os componentes selecionados e qualificados para compor o sistema.
Esta é uma atividade importante pois, conforme, na maioria das vezes o reuso de um componente está relacionado a alguma forma de adaptação para que ele atenda aos requisitos da aplicação.
Composição: Em esta etapa é realizada a composição dos componentes através de uma infraestrutura comum.
Para uma composição consistente dos componentes, a infra-estrutura deve prover a ligação dos componentes, bem como um conjunto de convenções conceituais compartilhadas por os componentes.
Atualização: Como última atividade é estabelecida a atualização dos componentes, onde novas versões são implementadas e substituem as antigas, ou novos componentes, com comportamento e interface similares, são desenvolvidos ou adquiridos de terceiros para serem incluídos na aplicação.
Esta atividade tem importantes implicações, pois sem um cuidadoso planejamento, uma alteração num componente pode provocar inúmeras e inesperadas repercussões em muitos outros componentes da aplicação.
As cinco atividades propostas por e descritas anteriormente, representam possíveis etapas no desenvolvimento de software com componentes, não existindo uma ordem para sua realização ou mesmo a obrigação de serem realizadas.
As etapas necessárias, bem como a importância e o esforço empregados em cada uma, correspondem a uma decisão relacionada ao processo de desenvolvimento com componentes específicos da aplicação.
A preocupação deste trabalho está centrada exclusivamente nas atividades de adaptação e composição.
Em esta seção elas foram apenas caracterizadas, sendo discutidas detalhadamente no Por suas características, DBC representa mudanças significativas na forma como o software é projetado e desenvolvido.
Embora os métodos para análise, projeto e implementação da orientação a objetos representem um começo natural para DBC, afirma que para se obter todas as vantagens de DBC são necessários novos métodos de análise e projeto, que estejam muito mais alinhados com os princípios de DBC.
Esta falta de alinhamento pode ser verificada por o suporte inadequado dos métodos existentes, por exemplo da orientação a objetos, às características chave de DBC, como a falta de suporte à noção de interfaces.
Voltado a ilustrar as principais etapas de modelagem, apresenta uma abordagem genérica de modelagem para DBC, composta de três fases:
Entender o Contexto, Definir a Arquitetura e Prover a Solução, as quais podem ser suportadas por muitos métodos e ferramentas comerciais.
A. Entender o Contexto O objetivo desta primeira fase é capturar os requisitos da aplicação, identificar os usuários e as tarefas realizadas por cada um, assim como os principais elementos do negócio e seus relacionamentos.
Estas informações são obtidas através da execução das atividades de Definição dos Requisitos, Modelagem dos Casos de Uso e Modelagem dos Tipos do Negócio.
A partir de o entendimento e documentação dos requisitos do sistema, o próximo passo é o projeto dos componentes que irão suportar o comportamento esperado do domínio.
B. Definir a Arquitetura Em esta segunda fase, o objetivo é estabelecer um conjunto de definições coerentes de interfaces a serem oferecidas por elementos existentes (e.
g componentes ou outros sistemas), ou que serão implementadas.
Ela envolve a execução das atividades de Modelagem da Arquitetura de Componentes, Modelagem do Contexto, Modelagem das Interfaces, e Definição das Interfaces.
B1. Modelagem da Arquitetura de Componentes Esta atividade tem por objetivo identificar todos os componentes que serão usados para construir a aplicação, bem como todas as dependências entre eles.
Um diagrama de arquitetura de componentes é usado para ilustrar os componentes e suas dependências.
Com o progresso da atividade de análise, a arquitetura de componentes será refinada e expandida para incorporar novidades que levem a um melhor entendimento do domínio.
B2. Modelagem do Contexto Esta atividade pode ser considerada como a continuação lógica da atividade de análise do domínio iniciada por a Modelagem dos Tipos do Negócio durante a fase de entendimento do contexto.
O modelo do contexto descreve a colaboração entre tipos do negócio e o sistema a ser implementado em termos de uma ou mais interfaces.
Esta atividade irá permitir um melhor conhecimento do comportamento esperado para os componentes.
B3. Modelagem das Interfaces O objetivo desta atividade é obter um conjunto de interfaces candidatas e descrever- las detalhadamente.
Um bom ponto de partida para esta atividade é reconsiderar os resultados da Modelagem do Contexto, em conjunto com cada um dos tipos de negócio previamente definidos como interfaces candidatas.
B4. Definir Interface As atividades anteriores possibilitaram o entendimento dos papéis e responsabilidades de cada uma das interfaces.
Com isso, esta atividade tem por objetivo completar os detalhes das interfaces, envolvendo a execução de três tarefas:
Definição dos parâmetros para cada uma das operações, incluindo a indicação dos tipos apropriados, e descrição do comportamento das operações através de pré e pós-condições;
Adicionalmente podem ser incluídas constantes para ajudar a simplificar a descrição do comportamento das operações;
O modelo de tipo de interfaces é concluído, estando em conformidade com os parâmetros das operações, constantes e pré e pós-condições.
Embora estas tarefas completem a definição das interfaces, elas ainda poderão ser refinadas a partir de as informações recebidas dos responsáveis por a implementação do sistema.
C. Prover a Solução O conjunto de definições quanto a interfaces e componentes obtidas com as fases anteriores são usadas nesta última fase para a implementação do sistema.
Esta fase envolve quatro principais atividades:
Implementação dos Componentes, Adaptação dos Componentes, Integração dos Componentes e Utilização do Sistema.
C1. Implementação dos Componentes Esta atividade tem como objetivo a conversão da especificação do componente numa implementação correspondente.
Esta conversão irá envolver diferentes tarefas, principalmente observando detalhes da tecnologia alvo.
C2. Adaptação dos Componentes A o invés de implementar todas as funcionalidades definidas na especificação do componente, muitas de elas já podem ser oferecidas por sistemas existentes, ou por componentes disponíveis em diferentes fontes.
Em muitos casos será uma alternativa reusar as funcionalidades existentes, embora elas possam não combinar totalmente com as funcionalidades necessárias.
Esta atividade está voltada para o uso de funcionalidades existentes, tendo como tarefas:
Verificar o que deve ser alterado (a especificação do componente ou a funcionalidade existente);
Realizar as adaptações que possibilitem que a funcionalidade existente possa ser utilizada.
As decisões tomadas nesta fase têm diferentes implicações na arquitetura de componentes, a qual deverá ser revisada.
C3. Composição dos Componentes Esta atividade está direcionada para a integração dos componentes para formar a aplicação, apresentando diferentes atividades de acordo com a tecnologia alvo.
C4. Utilização do Sistema Esta atividade compreende a disponibilização da aplicação em determinada infra-estrutura e plataforma.
A tecnologia alvo tipicamente irá fornecer alguma forma de auxilio à disponibilização da aplicação.
A Figura 9 sintetiza a abordagem genérica de modelagem proposta por, identificando as três fases e suas respectivas atividades.
Considerações A abordagem genérica de modelagem para DBC de se apresenta alinhada aos princípios de DBC, estando centrada na descoberta e especificação de componentes/ interfaces e definição da arquitetura de componentes.
Entende- se que esta abordagem abrange as duas perspectivas de DBC (desenvolvimento de e com componentes), pois considera tanto a definição de novos componentes/ interfaces, como o reuso dos existentes.
Entretanto, o maior suporte está direcionado para o desenvolvimento de componentes.
O reuso está limitado à indicação das etapas e respectivos elementos que podem ser reusados, não existindo a definição de uma sistemática que efetivamente o viabilize.
Além disso, a abordagem se caracteriza por tratar as atividades de adaptação e composição de componentes na fase de provisão, de modo que a arquitetura de componentes é estabelecida sem considerar os possíveis conflitos entre os elementos especificados e reusados.
A abordagem de é uma visão genérica que potencialmente, segundo o próprio autor, pode ser suportada por muitos métodos e ferramentas comerciais.
Com objetivo de posteriormente contextualizar a proposta deste trabalho dentro de uma abordagem de DBC foram estudados algumas propostas apresentadas na literatura:
RUP (Rational Unified Process), KobrA, COMET (Component Based Methodology) e UML Components.
Estas propostas foram selecionadas por se apresentarem como métodos de DBC e por partirem do uso da notação UML.
Embora as propostas selecionadas sejam classificadas na literatura de diferentes formas (e.
g processos, metodologias, métodos), neste trabalho elas são tidas unicamente como métodos.
A opção por esta unificação da nomenclatura se dá em virtude deste trabalho se preocupar apenas com as fases e artefatos necessários para a modelagem e construção de uma aplicação, o que segundo se caracteriza como um método.
Trabalhos como e estão voltados para a definição de critérios e análise de métodos de DBC num escopo mais amplo.
O levantamento realizado neste trabalho está centrado na investigação do suporte a DBC, através da análise da preocupação em estabelecer uma arquitetura de componentes, como na proposta de, bem como o suporte oferecido ao desenvolvimento com componentes e suas atividades de adaptação e composição.
A seguir, cada um dos métodos estudados é caracterizado.
RUP: Método amplamente utilizado que enfatiza que tem DBC como uma de suas melhores práticas, mas que na prática não oferece um suporte adequado a DBC.
Componentes são considerados prioritariamente como uma forma de implementação do sistema.
As fases de análise e projeto estão mais voltadas à definição da arquitetura de software, sem grande ênfase na identificação de componentes e definição das interfaces.
Em nível arquitetural, foca de forma genérica na identificação de subsistemas e seus relacionamentos.
Comet: Método que tem como ênfase o levantamento dos conceitos do negócio, e que não se preocupa com a identificação de interfaces e definição da arquitetura de componentes.
Componentes são estabelecidos como a forma de realização dos objetos do negócio.
KobrA: Enfatiza a definição das especificações dos componentes e como estes serão realizados.
O objetivo do método é obter de forma recursiva uma árvore de componentes organizada de acordo com sua hierarquia de composição, visando a definição de linha de produtos.
UML Components: Tem foco detalhado nas fases de análise e projeto segundo a ótica de DBC e se caracteriza por estar voltado para a identificação das interfaces, definição dos componentes e arquitetura de componentes.
Este método detalha a especificação dos componentes e seus relacionamentos, ao invés de sua implementação interna.
Entretanto, assim como os métodos anteriores, também tem maior preocupação com o desenvolvimento de componentes.
Como resultado do estudo identifica- se que os métodos RUP e COMET apresentam uma falta de suporte à identificação dos componentes e interfaces.
O método KobrA, embora possibilite a identificação dos componentes e interfaces, não tem preocupação com a definição da arquitetura de componentes visando a estruturação da aplicação quanto a os componentes necessários e como se dá o relacionamento destes.
A falta de suporte à definição da arquitetura de componentes também é verificada nos métodos RUP e COMET.
Além disso, todos os quatro métodos analisados têm sua preocupação centrada no desenvolvimento de componentes.
Embora COMET tenha como característica o suporte ao reuso, o método não sistematiza como este reuso ocorre, apenas identifica a existência de um repositório a ser consultado.
Igualmente, UML Components indica a possibilidade de reusar interfaces e elementos (componentes) existentes, mas não auxilia efetivamente este reuso.
A Tabela 2 sumariza as informações dos métodos discutidos nesta seção, identificando a perspectiva de DBC enfatizada, bem como os aspectos que são ou não suportados por os respectivos método.
Considerando os métodos analisados, este trabalho adotará como base o método UML Components, descrito em detalhes na Seção 3.5.
A escolha por este método ocorreu por ser, entre os estudados, o que oferece suporte à definição da arquitetura de componentes, suportando inclusive a abordagem de.
UML Components será empregado para contextualizar onde as funcionalidades propostas neste trabalho (descritas no Capítulo 6) são empregadas, bem como quais são as entradas necessárias para a sua execução.
UML Components é proposto como um processo de desenvolvimento de sistemas voltado para DBC que se apóia na linguagem UML para a modelagem.
Os conceitos de componentes e idéias do processo são derivados de diversas fontes, principalmente RUP, Catalysis e UML.
Com forte influência de RUP, as etapas do processo de desenvolvimento de UML Components são chamadas de workflows, e as semelhanças vão além de a nomenclatura.
A o total, UML Components compreende seis workflows:
Requisitos, Especificação, Provisão, Montagem, Teste e Utilização.
Os workflows de Requisitos, Teste e Utilização correspondem diretamente àqueles com mesmo nome no RUP, e por isso não são discutidos em, com exceção de pequenas elaborações no workflow de Requisitos.
Já os workflows de Especificação, Provisão e Montagem substituem os workflows de Análise, Projeto e Implementação do RUP.
A Figura 10 identifica os workflows de UML Componentes e o fluxo de artefatos entre eles.
UML Components estabelece a organização das aplicações em camadas de modo a permitir a separação das definições relativas à interface com o usuário da semântica da aplicação.
São definidas quatro possíveis camadas:
Interface do Usuário, Comunicação com o Usuário, Serviços do Sistema e Serviços de Negócio, sendo que as duas primeiras representam a interface com o usuário, e as duas últimas, a semântica.
UML Components mantém sua preocupação centrada nas camadas relacionadas à semântica.
Com isso, as atividades executadas em cada um dos workflows estão voltadas à definição dos componentes do sistema (camada Serviços do Sistema) e dos componentes de negócio (camada Serviços de Negócio).
Os quatro workflows discutidos em são caracterizados a seguir.
Workflow de Requisitos: Preza por o levantamento e definição dos requisitos, ou seja, entendimento do problema e definição das entradas necessárias para a especificação do sistema.
Workflow de Especificação: Tem por objetivo a identificação dos componentes necessários e definição da arquitetura de componentes.
Em esta fase é considerado o reuso de interfaces e elementos existentes (componentes), embora não exista um maior detalhamento de como isso é realizado.
Este workflow é discutido em detalhes na Seção 3.5.1.
Workflow de Provisão: O objetivo desta etapa é garantir a disponibilização dos componentes que formam a arquitetura de componentes.
Esta disponibilização irá considerar tanto o desenvolvimento, como a compra e reuso de componentes.
Considerando o possível reuso de componentes existentes, UML Components também estabelece esta etapa como o momento para realização de adaptações dos componentes.
Além de caracterizar as adaptações sobre componentes físicos, UML Components não oferece um suporte efetivo para a realização destas adaptações.
Workflow de Montagem: Em este workflow os componentes são integrados para formar a aplicação, representando tanto a integração dos componentes selecionados e/ ou desenvolvidos anteriormente, como também a integração dos componentes com sistemas e componentes já existentes (em uso).
A Figura 11 apresenta a correlação entre as fases de UML Components com as estabelecidas na abordagem genérica de modelagem para DBC de.
Por estar voltado para identificação dos componentes e definição da arquitetura de componentes, o que representa o cerne para o desenvolvimento de aplicações em DBC, UML Components dá maior ênfase ao workflow de Especificação.
De a mesma forma, este trabalho também enfatiza este workflow em virtude de o interesse na etapa de definição da arquitetura de componentes, estabelecida como o cenário de realização das atividades de adaptação e composição.
Workflow de Especificação O workflow de Especificação apresenta três diferentes estágios:
Identificação de Componentes, Interação de Componentes e Especificação de Componentes.
As diferentes atividades realizadas nestes estágios levam à definição da arquitetura de componentes a partir de os requisitos levantados, e detalhamento dos componentes, interfaces e operações necessárias para atender às funcionalidades estabelecidas.
A Figura 12 ilustra os três estágios do workflow de Especificação, sendo importante ressaltar que as atividades deste workflow são interativas, e embora muitos artefatos apresentem dependências, o seu desenvolvimento é incremental, com inclusões e modificações a cada estágio.
A. Identificação de Componentes Este primeiro estágio tem como objetivo a criação de uma especificação inicial de interfaces e componentes, bem como colocar estas definições juntas para estabelecer a arquitetura inicial de componentes.
A ênfase está na descoberta de quais informações devem ser gerenciadas, quais interfaces são necessárias para permitir este gerenciamento, quais componentes são necessários para prover as funcionalidades, e como isso é combinado na definição da arquitetura de componentes.
Como resultado do estágio são definidos o Modelo de Tipo de Negócio, as Interfaces de Negócio, as Interfaces de Sistema, a Especificação de Componentes e Arquitetura.
Além de a descoberta de novos componentes, este estágio também considera elementos existentes:
Interfaces, sistemas, banco de dados ou componentes para os quais será necessário possuir interface e que podem precisar de adaptação.
Igualmente, este estágio também privilegia a tentativa de uso de Padrões Arquiteturais e critérios de projeto apropriados.
Este estágio é considerado o cenário de contextualização das funcionalidades propostas neste trabalho, em virtude de a sua ênfase voltada para a definição da arquitetura de componentes e possibilidade de considerar elementos (componentes) e interfaces existentes nesta definição.
Este reuso de elementos existentes é importante para atender a ênfase deste trabalho na perspectiva de desenvolvimento com componentes.
Em a Figura 12 são ressaltadas as entradas e atividades deste estágio que definem o contexto de ocorrência das funcionalidades descritas no Capítulo 6.
B. Interação de Componentes O objetivo do segundo estágio é definir como os componentes irão trabalhar juntos para atender às funcionalidades necessárias.
Visando atender este objetivo será necessário reexaminar e refinar a arquitetura de componentes.
Como resultado deste estágio serão geradas a especificação das Interfaces e a Especificação de Componentes e Arquitetura.
C. Especificação de Componentes O último estágio compreende o detalhamento das operações e restrições.
Em este sentido são especificadas pré e pós-condições para as operações e regras de negócio capturadas como restrições.
Adicionalmente a este detalhamento da especificação das Interfaces, neste estágio também são privilegiadas definições de restrições que são particulares à especificação de componente e independente de cada interface.
A arquitetura de componentes não deve sofrer alterações significativas neste estágio, pois estes detalhamentos só devem acontecer quando a arquitetura estiver estável e todas as operações das interfaces tiverem sido descobertas.
Organização dos Artefatos Os workflows de Requisitos e Especificação são responsáveis por a definição de diferentes artefatos, os quais são organizados em UML Components numa estrutura de pacotes, como apresentado na Figura 13 (adaptada de).
Cada um dos artefatos gerados por os workflows de UML Components assume a forma de um diagrama UML, também identificado na Figura 13.
UML Components parte do uso da UML 1_ X e propõe um conjunto de extensões para suportar o processo.
Considerando as limitações da UML 1_ X para componentes, pode- se assumir que elas são as responsáveis por o uso de diagrama de classes para a modelagem da arquitetura de componentes, ao invés de o diagrama de componentes.
Com as definições da UML 2.
0, muitas das extensões da UML previstas em UML Components tornam- se desnecessárias, bem como passa a ser possível empregar o diagrama de componentes em nível lógico para a representar a arquitetura de componentes.
Um estudo complementar quanto a a adoção da UML 2.
0 no método UML Components pode ser verificado em.
Por utilizar as definições da UML 2.
0, este trabalho assume que a arquitetura de componentes pode ser modelada em UML Components utilizando o diagrama de componentes, ao invés de o diagrama de classes.
O uso deste diagrama não tem impacto sobre o método em si, de modo que a mudança é apenas quanto a a forma de representação dos componentes e interfaces.
Este capítulo explorou as duas possíveis perspectivas de DBC, onde foi enfatizado o desenvolvimento com componentes por ser a perspectiva tema deste trabalho.
Ilustrando as atividades envolvidas nesta perspectivas, foram apresentadas as atividades propostas por.
Por serem consideradas as principais atividades no desenvolvimento com componentes, em virtude de efetivamente permitirem e realizarem a integração dos componentes, este trabalho tem seu escopo limitado às atividades de adaptação e composição de componentes.
Identifica- se como uma constante a preocupação com as atividades de adaptação e composição de componentes centradas nas fases finais do ciclo de desenvolvimento.
A abordagem de, discutida na Seção 3.3, identifica a preocupação com estas atividades apenas na etapa de Provisão do sistema.
Igualmente, o método UML Components, discutido na Seção 3.5, identifica que adaptação e composição são atividades do workflow de Provisão, embora assinale o reuso de interfaces e componentes existentes no workflow de Especificação.
Em ambos os casos, adaptação e composição são consideradas explicitamente apenas no final do ciclo de desenvolvimento e realizadas em componentes na forma de código fonte e/ ou executável.
Isto significa que a arquitetura de componentes, se definida através do reuso de componentes, é estabelecida sem considerar os possíveis conflitos entre os elementos especificados.
Esta tardia consideração pode levar a um retrabalho em razão de a dificuldade de adaptar e compor os componentes selecionados.
As dificuldades podem gerar a necessidade de uma maior demanda de implementação do que a inicialmente prevista para integrar os componente, em virtude de problemas tardiamente identificados ou, até mesmo, a necessidade de buscar novos componentes por a impossibilidade de compor ou realizar as adaptações nos componentes definidos.
A proposta deste trabalho é antecipar a preocupação com a realização destas atividades para as fases iniciais, e tratar- las durante a modelagem da arquitetura de componentes.
Adaptação e composição realizadas em nível arquitetural correspondem à definição da estrutura de uma solução, a ser detalhada e efetivamente implementada nas fases de provisão do sistema.
Esta antecipação tem como vantagens o reuso da especificação de componentes desde as fases iniciais, a possibilidade de identificar e tratar os problemas existentes entre os componentes mais cedo, bem como viabilizar a definição da arquitetura de componentes incluindo as composições e as adaptações para a resolução das incompatibilidades detectadas.
Considerando o método UML Components, esta antecipação representa considerar as atividades de adaptação e composição de componentes como parte do estágio Identificação dos Componentes do workflow de Especificação.
Durante a definição da arquitetura e reuso de especificações de componentes existentes já seriam identificados e tratados os problemas para enquadrar os componentes na arquitetura, bem como para permitir a sua composição.
Em os workflows seguintes (Provisão e Montagem), a estrutura da solução para a resolução dos problemas seria então refinada e implementada.
Este trabalho parte do emprego de padrões de projeto para tratar as adaptações e composições durante a definição arquitetura.
Este capítulo aborda as atividades de adaptação e composição de componentes.
O propósito é caracterizar cada uma das atividades, identificar as situações que estabelecem a necessidade de adaptações, bem como os possíveis padrões que podem ser aplicados para tratar as incompatibilidades e permitir a composição dos componentes.
Uma das características de DBC é sua preocupação com o reuso, de forma que visa o desenvolvimento de aplicações através da integração planejada de componentes pré-existentes.
Embora o objetivo seja o uso do componente como ele é, ou seja, sem alterações de seu comportamento e estrutura, pesquisas relacionadas ao reuso de software têm mostrado que raramente um componente é reutilizado como foi originalmente desenvolvido, fazendo com que ele geralmente necessite de alguma forma de alteração para se adequar à arquitetura da aplicação ou aos demais componentes.
Entre as justificativas para essa dificuldade de reuso está o fato dos projetistas de componentes não terem condição de prever todos os possíveis usos que um componente pode vir a assumir.
Frente a esta dificuldade de reuso do componente em sua forma original, a atividade de adaptação de componentes passa a assumir um papel importante em DBC.
Em conjunto com a atividade de composição de componente, estas atividades passam a ser as principais responsáveis por viabilizar a integração dos componentes para a construção de aplicações, seja por permitir a composição dos componentes ou por prover alguma mudança que viabilize esta composição.
Apesar de serem duas atividades distintas, adaptação e composição possuem um forte relacionamento, pois muitas adaptações surgem em virtude de a dificuldade de composição dos componentes.
Por muitas vezes, este estreito relacionamento dificulta distinguir se o que está sendo realizado é uma adaptação ou uma composição.
Adaptação e composição dispõem de diferentes técnicas para sua resolução.
As técnicas mais freqüentemente empregadas correspondem a padrões de projeto, representando portanto soluções de qualidade comprovada, que justificam sua documentação com vistas a o reuso.
Tanto adaptação como composição podem ser auxiliadas por o uso de padrões de, assim como por propostas de linguagens de padrões voltadas especificamente para estas atividades, como os padrões propostos em voltados para a composição de componentes.
Este trabalho explora o uso dos padrões de.
Adaptação de componente é o processo de alteração de um componente para o uso numa aplicação específica.
As adaptações podem ocorrer em virtude de a necessidade de mudanças do funcionamento de um componente através da inclusão, alteração ou remoção de uma funcionalidade.
Igualmente, também podem ocorrer em virtude de a necessidade de alterações estruturais que viabilizem a utilização do componente numa determinada arquitetura de software, ou permitam que o componente seja composto com outros componentes em particular.
Desta forma, as adaptações podem ser motivadas por incompatibilidades comportamentais (diferenças entre as funcionalidades oferecidas e necessárias), incompatibilidade estruturais (diferença quanto as interfaces providas e requeridas), ou ambas.
Embora adaptação, customização e evolução sejam termos empregados para indicar mudanças relacionadas a componentes, estes termos apresentam algumas diferenças.
Segundo, evolução diz respeito a mudanças realizadas nos componentes por seus projetistas e adaptação corresponde a alterações realizadas por um desenvolvedor de aplicação para um uso possivelmente bastante diferente do componente numa aplicação.
Adaptação também é diferenciada de customização, caracterizada em como a seleção de uma alternativa de uso entre um conjunto pré-estabelecido de possibilidades como, por exemplo, parametrização.
Com isso, tanto adaptação quanto evolução podem ser vistas como formas de estender as propriedades de um componente.
A adaptação pode ser alcançada de diversas formas, mas, segundo, as técnicas tradicionais podem ser classificadas como técnicas de caixa-branca (white-box) e caixa-preta (blackbox).
As técnicas de caixa-branca definem que a adaptação de um componente reutilizável ocorre através de mudanças, substituição ou exclusão de partes da sua especificação interna.
Em contrapartida, as técnicas de caixa-preta partem do reuso do componente como ele é, adaptando apenas as interfaces do componente.
Assim, esta segunda técnica exige unicamente o entendimento das interfaces do componente e não de sua especificação interna.
Requisitos Existe na literatura uma relação de requisitos que usualmente devem ser observados por as técnicas de adaptação de componentes.
Estes requisitos podem ser empregados para avaliar e selecionar uma técnica, bem como podem servir como base para a definição de novas técnicas.
A seguir são relacionados os requisitos para adaptação apresentados em e Caixa-preta:
O componente e sua adaptação são duas entidades separadas, o que exige que a técnica de adaptação não tenha acesso à implementação interna do componente, ficando limitado o acesso às interfaces do componente.
Transparência: A adaptação de um componente deve ser tão transparente quanto possível.
Em este contexto, transparência indica que tanto a aplicação que usa o componente adaptado como o componente propriamente dito, desconsideram a existência da adaptação entre eles.
Em este requisito é subdividido em:·
Homogêneo: A aplicação que usa o componente adaptado deve usar- lo da mesma forma como usava o componente original.·
Conservador: Aspectos do componente original que não tenham sido adaptados devem ser acessados sem um esforço explícito por o componente adaptado, ou seja, o componente original permanece atuando em conjunto ao componente adaptado, provendo as atividades que não tiverem sido adaptadas.·
Ignorante: O componente original não deve ter conhecimento da existência do componente adaptado.
Componível: As técnicas de adaptação devem ser facilmente compostas com o componente em os quais são aplicadas, ou seja, não devem ser necessárias redefinições do componente.
O componente adaptado deve poder ser composto com outros componentes assim como era sem as adaptações.
Desta forma, uma adaptação deve poder ser composta com outra adaptação e, com isso, possibilitar que um componente seja adaptado usando diferentes tipos de adaptações.
Reusável: Uma técnica de adaptação consiste geralmente de uma parte genérica (adaptação) e outra específica (componente).
As técnicas tradicionais de adaptação apresentam como problema o fato de nem a parte genérica, nem a parte específica serem reusáveis por não se conseguir separar- las.
Com isso a adaptação tem que ser implementada novamente sempre que necessária, ao invés de reutilizada.
Configurável: Para que a técnica seja útil e reusável ela deve prover suficiente formas de configuração da adaptação, de modo que esta possa ser aplicada a diferentes componentes.
Foco arquitetural:
Deve existir uma especificação global da arquitetura para a aplicação, em conjunto com especificações do componente original e do componente adaptado, de modo que as adaptações possam ser especificada em nível arquitetural.
Independente de framework:
A técnica de adaptação não deve ser dependente do framework de componentes de o qual o componente faz parte.
Com isso, uma técnica de adaptação deve funcionar igualmente com componentes que seguem os modelos CCM (CORBA Component Model), Com (Component Object Model) e EJB, por exemplo.
Independente de linguagem de programação:
A técnica de adaptação deve ser independente da linguagem usada para implementar o componente, podendo ser empregada da mesma forma em diferentes linguagens.
Em e estes requisitos são aplicados para avaliar um conjunto de técnicas existentes.
Como resultado desta avaliação, observa- se que Configurável, Foco Arquitetural e Independente de Linguagem de programação são os requisitos menos atendidos por as técnicas.
Em contrapartida, os requisitos Caixa-Preta, Transparência (Homogêneo e Conservador), Componível e Independente de framework, são atendidos por a grande maioria das técnicas.
Técnicas Os trabalhos de discutem diferentes técnicas de adaptação caixa-branca e caixa-preta.
As técnicas caixa-branca freqüentemente estão relacionadas a características específicas do paradigma de programação (e.
g uso do mecanismo de herança da orientação a objetos), ou mesmo de características das próprias linguagens de programação utilizadas para implementar o componente.
Já muitas técnicas caixa-preta são análogas a determinados padrões de projeto.
Por exemplo Wrapper e Proxy, duas das técnicas de adaptação respectivamente, aos padrões estruturais Adapter e Proxy de.
A seguir são descritas quatro técnicas que exemplificam estas duas categorias (caixa-branca e caixa-preta) proposta por.
Alteração de código Uma primeira alternativa que pode ser considerada é a modificação explícita e direta do código do componente.
Esta técnica apresenta- se como totalmente caixa-branca, permitindo ao desenvolvedor da aplicação realizar toda e qualquer adaptação que considerar pertinente no componente.
A aplicação desta técnica exige a acessibilidade ao código fonte do componente, de modo que a sua grande desvantagem está na exigência de um conhecimento detalhado do funcionamento interno do componente para proceder à adaptação.
Herança Esta técnica de adaptação caixa-branca está relacionada ao uso do mecanismo de herança da orientação a objetos.
De acordo com a linguagem orientada a objetos, todos os aspectos internos, ou apenas parte, estarão disponíveis ao componente adaptado.
Por exemplo, em Smalltalk todos os métodos e variáveis de instância são disponibilizados às subclasses, enquanto que em C+ e Java o uso dos modificadores de visibilidade private e protected é que determinarão o que será disponibilizado às subclasses.
Segundo, a vantagem importante desta técnica é que o código continua a existir num mesmo local.
Assim como a técnica de alteração de código, as adaptações através de herança são realizadas diretamente no código fonte, o que caracteriza como pré-requisito para o emprego da técnica a acessibilidade ao código do componente.
Com isso, a grande desvantagem da técnica está na necessidade de se ter um conhecimento funcional detalhado da superclasse para definir as subclasses necessárias na adaptação do componente.
Wrapping O funcionamento desta técnica, que pode ser descrita por o padrão Adapter (vide Anexo I), está baseado na definição de um componente, denominado de wrapper (adapter), que encapsula o componente original e atua como filtro para as requisições recebidas, definindo o comportamento do componente como desejado.
A principal aplicação desta técnica de caixapreta está relacionada à solução de interfaces incompatíveis.
O amplo uso desta técnica se dá por ela permitir o uso do componente como definido, sem exigir o conhecimento do seu funcionamento interno, já que todas as alterações são realizadas externamente ao componente.
Em contrapartida, segundo, a principal desvantagem da técnica está vinculada à existência de uma sobrecarga de implementação para o controle de todas as interfaces do componente, inclusive aquelas que não precisam ser adaptadas.
Proxy Em esta técnica de caixa-preta é criado um componente, denominado proxy, que intermedia a comunicação com um componente original, definindo como devem ser atendidas as requisições endereçadas ao componente.
Esta técnica, que pode ser descrita por o padrão de projeto Proxy (vide Anexo I), difere- se da técnica Wrapping por não encapsular o componente original, e sim posicionar um proxy entre o componente original e as requisições, de modo a filtrálas.
A manutenção da possibilidade de acesso direto ao componente original representa uma vantagem da técnica, pois elimina a sobrecarga de implementação característica da técnica Wrapping.
Além disso, o uso desta técnica também é motivado por a possibilidade de usar os componentes como definidos e não exigir o conhecimento detalhado do seu funcionamento interno, pois as adaptações são realizadas externamente através do componente proxy.
Causas para a Adaptação Os problemas que geram a necessidade de adaptações podem estar relacionados à estrutura ou ao comportamento do componente.
Os problemas quanto a a estrutura (incompatibilidades estruturais) estão diretamente relacionados às interfaces do componente, onde se identifica os seguintes conflitos:
Diferença no nome das interfaces (em situações que uma das interfaces não é subclasse da outra);
Diferença no nome das operações;
Número diferente de operações (a mais ou a menos);
Número diferente de parâmetros nas operações (a mais ou a menos);
Diferença nos tipos dos argumentos (de entrada e retorno).
Já os problemas de comportamento (incompatibilidades comportamentais) envolvem problemas com as funcionalidades oferecidas por os componentes, como:
Funcionalidade requerida por um componente não é atendida por um único componente no sistema, se fazendo necessária a combinação de dois ou mais componentes para prover- la;
Diferenças quanto a o comportamento das funcionalidades requeridas e providas, ou seja, o que é oferecido não é exatamente igual ao que é necessário (ou vice-versa).
Embora possam existir outras situações que também exijam a necessidade de realizar adaptações, este trabalho tem seu escopo restrito às incompatibilidades estruturais e comportamentais relacionadas anteriormente.
Assume- se ainda a possibilidade de diferentes combinações que dêem origem a problemas que denominamos híbridos, ou seja, que envolvem simultaneamente incompatibilidades comportamentais e estruturais.
Composição é o termo usado em DBC para definir como os sistemas são formados.
Segundo, não existem diferenças entre os termos composição e integração, entretanto composição é mais amplamente usado na literatura relacionada a DBC.
Os componentes são compostos de modo que possam interagir e, segundo, verifica- se dois tipos de entidades que podem ser compostas:
Componentes e frameworks de componente.
As três principais classes de interação nos sistemas baseados em componentes, segundo são:
Componente­Componente: Composição que possibilita interações entre componentes e define as funcionalidades da aplicação.
O compromisso que especifica estas interações pode ser classificado como contrato em nível de aplicação.
Framework­Componente: Composição que possibilita interações entre os frameworks de componentes e seus componentes.
Estas interações habilitam os frameworks a gerenciarem os componentes e o compromisso que especifica estas interações pode ser classificado como contrato em nível de sistema.
Framework­Framework: Composição que possibilita interações entre frameworks e permite a composição de componentes definidos em diferentes frameworks.
O compromisso que especifica estas interações pode ser classificado como contrato de interoperação.
Em estas três classes de interação foram identificados diferentes tipos de contratos, que conforme, podem ser descritos como formas de composição:
Utilização do componente:
Os componentes devem ser empregados através de um framework antes de serem compostos e executados.
A utilização envolve a definição da interface que o componente deve implementar de modo que o framework possa gerenciar seus recursos, implementando desta forma o contrato em nível de sistema.
Utilização do framework:
Frameworks podem ser utilizados dentro de outros frameworks, o que corresponde à concepção apresentada em em a qual os frameworks podem apresentar diferentes camadas.
O contrato é análogo ao contrato de utilização do componente.
Composição simples:
Componentes utilizados dentro de um mesmo framework podem ser combinados.
A composição expressa funcionalidades específicas dos componentes e da aplicação, implementando assim um contrato em nível de aplicação.
Os mecanismos necessários para esta interação são providos por o framework.
Composição heterogênea:
Composição de componentes através de diferentes frameworks, suportada por os frameworks em camadas.
Primeiramente devem ser estabelecidos compromissos entre os componentes e seus frameworks, e posteriormente é definida a composição.
Em este caso, além de a implementação de contratos em nível de sistema, também é necessário a implementação de contratos ponte de modo a possibilitar a interação de modelos de componentes bastante genéricos.
Extensão de framework:
Os frameworks podem ser tratados como componentes e, desta forma, serem compostos como outros componentes.
Esta forma de composição normalmente permite a parametrização do comportamento do framework através de seus conectores (plug-ins).
Contratos de conectores padrão para serviços providos são cada vez mais comuns em frameworks comerciais.
União de componentes:
Forma de composição em que são compostos componentes e outras uniões parciais de componentes, as quais podem conter um ou mais componentes.
Estas composições entre componentes implementam contratos em nível de aplicação.
Observando as tecnologias de componentes mais representativas tem- se claro que embora definam formas genéricas de composição, não existe um consenso de quais tipos de composição devem ser suportados por os modelos e frameworks de componentes.
Em este trabalho, componentes são tratados dentro de uma visão lógica a partir de a sua especificação e representação UML, sem possuir vínculos com tecnologias específicas.
Portanto, o foco está centrado na composição enquanto integração Componente-Componente, realizado na forma de uma Composição Simples, sem considerar os modelos e frameworks aos quais os componentes pertencem.
A proposta deste trabalho é considerar componentes em nível arquitetural e empregar padrões de projeto para apoiar a adaptação e/ ou composição dos componentes.
A aplicação dos padrões representa a definição do esqueleto de uma solução incorporada à arquitetura de componentes, o qual deverá ser refinado e implementado nas fases seguintes do ciclo de desenvolvimento.
Considerando que, freqüentemente, os projetistas não têm acesso ao comportamento interno do componente que irão reusar, e que a definição da arquitetura está voltada para as interfaces dos componentes, ao invés de a sua especificação interna, este trabalho foca nas técnicas de adaptação caixa-preta.
Embora existam propostas como a de linguagens de padrões voltadas especificamente para a composição de componentes, este trabalho está focado no emprego dos padrões de.
Além de se verificar uma equivalência entre os padrões de e de, os padrões de podem ser aplicados para auxiliar tanto as composições, como as adaptações de componentes.
O escopo deste trabalho está limitado ao emprego dos padrões Adapter, Proxy e Facade, representando as técnicas de Wrapping e Proxy descritas na Seção 4.2.2.
Estes padrões são detalhados no Anexo I a partir de a descrição fornecida em.
A seleção destes três padrões, frente a outros, se deve a sua aplicabilidade para a resolução das incompatibilidades identificadas na Seção 4.2.3, bem como por representarem as principais formas de composição de componentes, conforme.
Padrões Adapter e Proxy Durante a tentativa de compor os componentes A e B, o projetista responsável por a definição da arquitetura identifica a existência de incompatibilidade entre os componentes.
Esta incompatibilidade pode ser tanto de ordem estrutural, comportamental (i.
e comportamento requisitado é diferente do comportamento provido), ou híbrida, ilustrada na Figura 14 por a diferença de encaixe entre os componentes.
Considerando sua caracterização dentro de os problemas descritos na Seção 4.2.3, esta incompatibilidade impede a composição dos componentes e caracteriza a necessidade de uma adaptação.
Esta situação representa o cenário de aplicação dos padrões Adapter e Proxy.
Adapter e Proxy podem ser aplicados para solucionar as diferenças de sintaxe entre componentes (incompatibilidades estruturais), bem como podem manipular o comportamento do componente para atender às diferenças semânticas (incompatibilidades comportamentais).
Caberá ao projetista, que possui o conhecimento da aplicação e dos componentes, avaliar o problema arquitetural em questão e selecionar o padrão que melhor atende à incompatibilidade identificada.
A escolha entre Adapter e Proxy deve levar em conta a sua diferença característica:
Enquanto o uso de Proxy mantém a possibilidade de acesso direto ao componente original, Adapter encapsula o componente original e não permite que exista um acesso direto a ele.
A aplicação do padrão é realizada de forma a prover a adaptação das interfaces.
Em a situação de incompatibilidades estruturais e híbridas estes padrões podem ser aplicados tanto na interface provida, como na requerida, visando a resolução dos problemas sintáticos.
Contudo, no caso de incompatibilidades comportamentais, a aplicação dos padrões está restrita à interface provida.
Esta restrição se deve à definição deste tipo de incompatibilidade, que representa o não provimento de um serviço assim como requisitado.
De a mesma forma, o padrão Proxy poderia ser empregado para resolver a incompatibilidade entre os componentes A e B. Em este caso, o que ocorre é a criação de um novo componente que passa a intermediar a comunicação dos componentes.
É atribuída ao componente proxy a estrutura e/ ou comportamento que viabiliza a composição dos componentes envolvidos.
A Figura 16 ilustra a aplicação do padrão Proxy para a resolução da incompatibilidade entre os componentes A e B. Por estarem voltados à resolução dos mesmos tipos de incompatibilidade (estrutural, comportamental e híbrida), a opção entre Adapter e Proxy está fortemente relacionado ao cenário de ocorrência da incompatibilidade.
Cabe a projetista a decisão de qual padrão aplicar, devendo ser levado em conta, além de as características da incompatibilidade, as alterações decorrentes da aplicação de cada um dos padrões.
Padrão Facade O padrão Facade possibilita a composição de componentes através da resolução de incompatibilidade de comportamento num caso específico:
A funcionalidade necessária não é provida integralmente por um único componente.
Por sua característica de unificação, o padrão Facade permite a combinação de diferentes componentes para estabelecer a funcionalidade necessária, situação para a qual os padrões Adapter e Proxy não são indicados.
Enquanto Adapter e Proxy são aplicados em situações que envolvem dois componentes que possuem algum tipo de incompatibilidade que impede a sua composição, o padrão Facade é aplicado em situações que envolvem um número maior de componentes, em que a requisição de um componente é atendida por a combinação dos demais componentes.
Desta forma, a aplicação do padrão Facade está restrita às interfaces providas, de modo que sua aplicação permita a combinação destas interfaces para atender a funcionalidade requerida.
A aplicação do padrão Facade neste trabalho, assume duas possíveis formas, nomeadas de FacadeAdapter e FacadeProxy.
FacadeAdapter parte da estrutura de funcionamento do padrão Adapter, de modo que os componentes adaptados são englobados por um componente facade que controla o acesso às suas interfaces.
Já FacadeProxy baseia- se na estrutura de funcionamento do padrão Proxy, realizando a unificação através da definição de um componente facade que intermedia a comunicação dos diferentes componentes.
As duas formas de aplicação do padrão Facade, FacadeAdapter e FacadeProxy, apresentam as mesmas implicações que os padrões Adapter e Proxy, quanto utilizados individualmente.
Desta forma, a escolha entre uma forma ou outra de aplicação do Facade envolve a avaliação do projetista quanto a as implicações da forma selecionada.
A Figura 17 ilustra um cenário próprio para a aplicação do padrão Facade, em que o comportamento requisitado por o componente C é provido por a combinação dos componentes D e E. As diferenças dos encaixe dos componentes na Figura 17 podem representar tanto uma incompatibilidade comportamental (i.
e comportamento requerido não é atendido por um único componente), como pode representar a combinação desta incompatibilidade comportamental com uma incompatibilidade estrutural, ou seja, uma incompatibilidade híbrida.
Utilização e Análise dos Padrões Adapter, Proxy e Facade na Seção 4.2.3 foram relacionados os principais problemas que caracterizam a necessidade de adaptações.
A Tabela 3 relaciona estes problemas e os padrões adotados neste trabalho, identificando a aplicabilidade dos padrões para o tratamento dos respectivos problemas.
Considerando o contexto deste trabalho, onde se tem a preocupação com a definição da arquitetura de componentes e antecipação da preocupação com adaptação e composição para a fase de projeto, a técnica de adaptação aplicada deve atender aos requisitos caixa-preta, componível, foco arquitetural, independente de framework e independente de linguagem de programação.
Tabela 4 -- Análise dos padrões frente a os requisitos de adaptação Requisitos de adaptação Caixa-preta Transparência Componível Reusável Configurável Foco arquitetural Independente de framework Independente de linguagem de programação Adapter Proxy Facade* o reuso está limitado a situações idênticas.
Dando continuidade à caracterização das atividades do desenvolvimento com componentes, iniciada no Capítulo 3, neste capítulo foram discutidas as atividades de adaptação e composição de componentes.
Adaptação representa um processo de alteração comportamental ou estrutural do componente para que este componente atenda os requisitos de uma aplicação em particular.
Enquanto isso, composição representa a integração dos componentes para formar uma aplicação.
Muitas das adaptações são realizas em virtude de problemas e dificuldades para a composição dos componentes selecionados, de modo que o estreito relacionamento existente entre adaptação e composição acaba por dificultar a distinção de qual atividade está sendo realizada.
As adaptações podem ser realizadas visando a resolução de incompatibilidades comportamentais, estruturais ou híbridas entre os componentes.
As incompatibilidades comportamentais representam problemas quanto a as funcionalidades requeridas e providas por os componentes, considerando tanto casos em que um componente não fornece a funcionalidade exatamente como ela é requisita por outro, como também casos em que a funcionalidade requisitada é atendida através da combinação de dois ou mais componentes.
Enquanto isso, as incompatibilidades estruturais representam problemas entre as interfaces providas e requeridas dos componentes, envolvendo diferença de nome das interfaces e métodos, bem como diferença no número de métodos e parâmetros, ou ainda diferença no tipo dos parâmetros dos métodos.
Este dois tipos de incompatibilidades também podem ser combinados, estabelecendo incompatibilidades híbridas.
Em este trabalho, o tratamento destas incompatibilidades é realizado através do uso de padrões de projeto.
Considerando os tipos de problemas identificados (Seção 4.2.3), foram selecionados para serem utilizados neste trabalho os padrões Adapter, Proxy e Facade.
Sua adoção permite comprovar a viabilidade do emprego de padrões de projeto para tratar adaptações e composições de componentes, bem como analisar as vantagens decorrentes deste emprego.
Adapter e Proxy estão voltados a atender as incompatibilidades comportamentais, estruturais e híbridas;
Enquanto Facade está voltado à resolução de incompatibilidades comportamentais ou híbridas num caso específico (i.
e funcionalidade requerida é provida por um conjunto de componentes).
A escolha do padrão mais indicação para cada situação cabe ao projetista, que detém conhecimento sobre a aplicação e componentes.
Entretanto, a decisão entre o uso de Proxy ou Adapter deve levar em conta que o uso do primeiro mantém a possibilidade de um acesso direto ao componente original;
Enquanto isso, utilizando o segundo este acesso direto deixa de ser possível.
Dentro de a proposta deste trabalho, os padrões selecionados serão aplicados durante a definição da arquitetura de componente, de modo que a sua aplicação seja modelada como parte da arquitetura sendo definida.
A solução resultante da aplicação de um padrão representa apenas a estrutura de uma solução, que será refinada e implementada numa etapa posterior do ciclo de desenvolvimento.
Este capítulo apresenta propostas de ambientes de apoio a DBC.
O propósito é identificar as características destes ambientes, analisar o suporte oferecido às atividades do desenvolvimento com componentes, bem como ilustrar como os ambientes fazem uso de padrões de projeto.
Os ambientes de apoio representam uma importante alternativa de suporte ao desenvolvimento de software, fornecendo funcionalidades que auxiliem e minimizem os esforços de projetistas e desenvolvedores.
A atual geração de ambientes está direcionada a fornecer suporte ao desenvolvimento de artefatos, seguindo ou não um processo de desenvolvimento de software.
O advento de DBC, segundo, caracteriza a necessidade de uma nova geração de ambientes, que suportem também o desenvolvimento de aplicações a partir de a integração de componentes pré-existentes.
Com o uso de componentes, a ênfase dos ambientes deve passar da implementação para o projeto, visando que o reuso de componentes contribua para minimizar os esforços de implementação.
Voltados para integração de componentes, os ambientes de apoio a DBC devem prover auxílio à identificação, recuperação e integração dos componentes.
Propõe um conjunto de requisitos a serem observados por ambientes para o efetivo apoio a DBC, a saber:
Projeto Modular:
Os componentes devem ser divididos em duas partes, pública e privada.
Enquanto a parte privada contém a implementação e não é acessada externamente, a parte pública representa as interfaces através de as quais o componente pode ser acessado.
Estas interfaces podem ser especificadas independente do componente que as implementa, permitindo que os componentes sejam substituídos por outros que implementem a mesma interface.
Autodescrição: Os componentes devem estar aptos a fornecerem informações sobre si mesmos (serviços providos e requeridos) de uma forma sistemática, bem como os ambientes devem suportar e explorar o uso desta autodescrição.
Nomes Globais de Interfaces: Deve existir uma definição global de nomes de interfaces, de modo que os ambientes possam garantir a consistência entre componentes providos e requeridos.
Desenvolvimento de Componente e Processo de Composição de Aplicações: Os ambientes devem privilegiar o suporte à composição de aplicações (desenvolvimento com componentes), embora também possam suportar o desenvolvimento de componentes.
Conexão e Adaptação:
Os ambientes devem oferecer suporte à configuração dos componentes, ou seja, conexão dos diferentes componentes e possíveis adaptações, as quais devem ser realizadas externamente para não precisar interagir com o componente diretamente.
Múltiplas Visões: Os ambientes devem suportar a apresentação de múltiplas visões, que privilegiem tanto o desenvolvimento de componentes, como a composição de aplicações:·
Visão de Desenvolvimento e de Composição:
Os ambientes devem prover tanto visões para os desenvolvedores de componentes, como para os desenvolvedores de aplicação;·
Visão de Instância e de Tipo:
Definidas como subvisões da Visão de Composição, a visão de tipo irá apresentar os componentes usados e as dependências existentes (visualização da arquitetura da aplicação), enquanto que a visão de instância irá apresentar como estão configuradas instâncias de algum tipo de dado existentes no componente;
Diagramas de Arquitetura:
Visão através de a qual devem ser fornecidos diagramas que possibilitem a modelagem explícita da arquitetura da aplicação.
Reuso por Referência:
O reuso dos componentes deve ser realizado através de referência, onde o ambiente de DBC deve estabelecer uma conexão permanente entre a aplicação cliente, que usa um componente, e o repositório onde a cópia do componente é permanentemente armazenada.
Além de caracterizar a integração das duas abordagens de DBC (desenvolvimento de e com componentes), e enfatizar a importância da existência de diferentes visões dos componentes e seus relacionamentos, os requisitos de também ressaltam a importância das atividades de adaptação e composição de componentes.
Os requisitos complementares estão voltados para viabilizar o entendimento e localização dos componentes pré-existentes, i.
e Autodescrição, Nomes Globais de Interfaces e Reuso por Referência.
Em são identificados um conjunto de critérios para a avaliação e comparação de ambientes de composição de componentes.
Estes critérios estão voltados à avaliação do atendimento a aspectos como o reuso, busca, composição e adaptação de componentes, bem como suporte a múltiplas visões e geração de código.
A preocupação com a definição destes requisitos e critérios de avaliação se contrapõe à carência de ambientes de apoio a DBC.
Encontra- se na literatura um número bastante restrito de propostas destes ambientes, sendo que entre os encontrados estes requisitos são apenas parcialmente observados.
Os ambientes existentes estão na sua maioria voltados ao suporte de questões de implementação, identificado por as funcionalidades disponibilizadas e vínculo com tecnologias específicas.
Com a ênfase na implementação, o projeto de aplicações, aspecto crítico de DBC, encontra- se desprovido de suporte.
As diferentes ênfases dos ambientes de apoio existentes pressupõem a sua divisão em dois grupos distintos:
Um grupo voltado para apoiar à programação com componentes, e o outro grupo voltado para a modelagem de componentes e aplicações.
As duas próximas Seções discutem estes grupos, apresentando propostas de ambientes que ilustram cada uma das respectivas ênfases.
Os ambientes voltados à programação partem do uso de componentes para o desenvolvimento de aplicações.
Componentes são tratados nestes ambientes como elementos visuais que podem ser selecionados, customizados e compostos para a implementação de uma aplicação.
Além de estas funcionalidades, estes ambientes também se caracterizam por auxiliar a geração de código, mantendo vínculo com tecnologias e linguagens de programação específicas.
Os ambientes apresentados em se enquadram neste grupo, de o qual também fazem parte ambientes de programação como Bean
Box2, Visual Basic3, Visual Age4, JBuilder5, discutidos em A Figura 19 ilustra a proposta de, que utiliza o ambiente Visual Age for Java para implementar aplicações na área de comunicações utilizando um conjunto de componentes JavaBeans próprios deste contexto.
A ferramenta permite a seleção e customização dos componentes, e seus inter-relacionamentos visando à implementação de uma aplicação.
Não é oferecido por estes ambientes auxílio à adaptação, sendo que a única forma de alteração dos componentes é através da customização das suas propriedades, considerando as possibilidades previamente estabelecidas.
Os ambientes pertencentes a este grupo evidenciam a preocupação com componentes apenas na fase de implementação, sendo que seu emprego segue as diretivas de uma determinada linguagem de programação e tecnologia de componentes para a definição de aplicações com a geração do respectivo código fonte/ executável.
Este segundo grupo de ambientes representa propostas que tratam DBC em nível de projeto e modelagem, seja voltado à modelagem de componentes, como de aplicações com componentes.
Enquanto o grupo de apoio à programação com componentes contempla inúmeros exemplos de ambientes, este segundo grupo apresenta um grupo bem mais restrito de opções, confirmando a grande carência de ambientes de apoio a projeto.
De entre as propostas encontradas na literatura, apenas o ambiente Wren está voltado para desenvolvimento com componentes (composição de aplicações), tendo por objetivo facilitar a execução do processo apresentado na Figura 20 (extraída de).
O ambiente Wren atende parcialmente as três primeiras atividades do processo apresentado na Figura 20, pois seu suporte está restrito a busca e seleção de componentes em repositórios, e composição dos componentes na definição da arquitetura de componentes.
Mantendo vínculo com um ou mais repositórios, Wren possibilita a consulta dos componentes existentes, disponibilizados na forma de arquivos Java.
Os componentes selecionados são apresentados no ambiente seguindo uma notação baseada na UML com extensões, como apresentado na Figura 21 (extraída de).
Embora a notação utilizada em não seja padronizada, as extensões propostas se alinham às evoluções encontradas na UML 2.
0. Embora o ambiente Wren tenha sido desenvolvido visando a realização e avaliação dos requisitos para ambientes de DBC definidos por, o ambiente não apresenta um suporte integral a todos eles.
Além de o ambiente não oferecer nenhum suporte à adaptação, o requisito de apresentar diferentes visões está limitado a uma única forma de visualização, que apresenta os componentes e seus relacionamentos.
Ainda que voltado para o projeto e modelagem de aplicações com componentes, Wren mantém vínculo com uma tecnologia especifica, bem como está interligado a um ambiente de implementação que oferece suporte à geração de código.
Contrapondo- se à proposta de, voltada para modelagem de aplicações com componentes, as propostas de e estão voltadas para a modelagem de componentes, tendo como diferencial o emprego de padrões.
Não foram encontradas na literatura propostas de ambientes que incluam o uso de padrões como mecanismos auxiliares à realização das atividades do desenvolvimento com componentes.
O ambiente descrito em procura implementar os passos de um processo de composição baseado em padrões para a definição de aplicações, definido através de quatro dimensões:
Concretização, especificação, escopo e revisão.
Estas dimensões são realizadas através das seguintes atividades:
Definição dos padrões, seja de forma textual ou gráfica;
Instanciação dos padrões para a criação de um componente, graficamente representado como um componente de projeto;
Especialização dos componentes para atenderem requisitos específicos;
Adaptação dos componentes para adequar- los a certos requisitos da aplicação ou domínio;
Formar componentes através da composição de componentes básicos;
Realizar alterações devido a mudanças dos requisitos;
Disponibilizar os componentes definidos para que possam ser reusados em outras modelagens;
Traduzir a modelagem em código fonte ou executável.
Os componentes de projetos da proposta de são representações gráficas de padrões, que são especializados e compostos para a definição de uma aplicação.
O protótipo do ambiente de é apresentado na Figura 22, onde estão modelados e conectados diferentes componentes de projeto.
A notação empregada para a modelagem dos componentes é proprietária da ferramenta, e permite visualizar a estrutura do componente, definida por o padrão em que está baseado, junto com os relacionamentos existentes entre os componentes.
Mantendo foco apenas na modelagem, o ambiente não oferece nenhum suporte à geração de código, embora esta seja uma das atividades previstas no processo em que este ambiente está baseado.
Um segundo exemplo que emprega padrões é a ferramenta POD (Pattern-Oriented Design) descrito em, que permite a modelagem de componentes definidos a partir de o uso de padrões, como os de.
Os componentes são definidos seguindo a estrutura de um determinado padrão, instanciados a partir de uma base de dados.
Além disso, a ferramenta suporta diferentes níveis de visualização para facilitar a composição dos padrões.
A modelagem de uma aplicação é iniciada por a instanciação dos padrões que definem componentes.
Através da representação gráfica destes componentes, a ferramenta permite estabelecer as ligações entre eles.
A interdependências dos componentes representa uma primeira forma de visualização da aplicação sendo definida.
A ferramenta ainda disponibiliza duas outras visões que permitem o detalhamento destas ligações.
Em uma segunda forma é possível realizar o refinamento dos relacionamentos, inicialmente estabelecidos entre componentes, de forma que a ligação passa a ser definida entre as interfaces dos componentes (Figura 23, extraída de).
Em a terceira forma de visualização, a ferramenta possibilita que o comportamento interno do componente seja apresentado, sendo possível especificar, de acordo com o domínio, os nomes dos elementos que caracterizam o padrão que define o componente, bem como os nomes das operações do componente.
A ferramenta POD não tem suporte à geração de código, mas fornece como resultado da modelagem um diagrama de classes que pode ser utilizado em ambientes que suportem UML para um projeto detalhado e implementação.
Ambientes de apoio representam uma importante carência em DBC, principalmente quanto a o suporte de aplicações com componentes em nível de projeto, aspecto crítico de DBC.
A Tabela 5 sumariza as características dos ambientes apresentados nas Seções 5.2 e 5.3.
Considerando, em especial, os ambientes de apoio em nível de modelagem, a análise realizada permite confirmar a falta de suporte ao projeto de aplicações e definição da arquitetura de componentes.
Com ênfase em questões de implementação, é uma constante nos ambientes a dependência de tecnologias e linguagens de programação específicas, já que focam no suporte à geração de código.
A falta de uma notação padronizada também é uma característica comum dos ambientes que empregam, em sua grande maioria, uma notação proprietária.
Uma outra característica dos ambientes é a negligência em relação a a atividade de adaptação, que não recebe nenhum tipo de suporte para a sua realização.
Além disso, observa- se que o emprego de padrões está restrito a ambientes voltados para o desenvolvimento de componentes, não se verificando ambientes que os utilizem como mecanismo auxiliar ao desenvolvimento com componentes.
Os ambientes de apoio representam um importante auxílio para o desenvolvimento de software por a possibilidade de fornecer funcionalidades que automatizem atividades e minimizem os esforços.
O advento de DBC estabeleceu a necessidade de uma nova geração de ambientes que também forneçam suporte ao desenvolvimento de aplicações com enfoque na integração de componentes pré-existentes.
Este capítulo discutiu os requisitos para ambientes propostos por e apresentou diferentes propostas de ambientes de apoio a DBC encontradas na literatura.
Além de confirmar a carência de ambientes, a análise realizada possibilitou identificar as principais características dos ambientes existentes, bem como os pontos desprovidos de suporte.
As principais carências identificadas dizem respeito à falta de suporte ao projeto com componentes e definição da arquitetura de componentes, suporte a adaptação de componentes, utilização de notação padronizada, independência de tecnologias e linguagens de programação, e emprego de padrões dentro de o desenvolvimento com componentes.
As funcionalidades próprias a um ambiente de DBC apresentadas no próximo capítulo se propõem a atuar frente a estas carências identificadas e escassez de ambientes de apoio a DBC em nível de projeto.
Este capítulo descreve o conjunto de funcionalidades propostas para apoiar o projeto com componentes e atividades de adaptação e composição em nível arquitetural, com o apoio da notação UML 2.
0 e padrões de projeto.
Este trabalho está centrado no apoio à definição da arquitetura de componentes através do reuso de componentes pré-existentes, com especial atenção à realização das atividades de adaptação e composição.
Para tal, parte- se do seguinte contexto, explorado nos capítulos anteriores:
Foco na perspectiva de DBC de desenvolvimento com componentes;
Delimitação da atividade de composição como a integração dos componentes através de suas interfaces, independente de uma tecnologia alvo (Composição Simples);
Definição da atividade de adaptação para a identificação de incompatibilidades estruturais e/ ou comportamentais, com a definição de uma estrutura de solução incorporada à arquitetura de componentes;
Tratamento conjunto de adaptações e composições em virtude de o forte vínculo que existe entre estas atividades;
Utilização de padrões de projeto como técnicas comprovadas de adaptação/ composição visando a definição do esqueleto de uma solução incorporada à arquitetura de componentes, que permite ao projetista melhor refletir sobre a adaptação e o impacto de cada técnica, bem como elimina os aspectos repetitivos relacionado à realização desta atividade;
Adequado suporte oferecido por a UML 2.
0 para a modelagem de componentes e arquitetura de componentes;
Carência de ambientes de apoio a DBC centrados na definição da arquitetura de componentes.
Considerando este contexto, este trabalho propõe um conjunto de funcionalidades próprias a um ambiente de DBC que permitam o desenvolvimento de aplicações com componentes e suportem as atividades de adaptação e composição de componentes em nível arquitetural através do uso de padrões.
Com a definição destas funcionalidades busca- se contribuir para antecipação da preocupação com componentes para as fases iniciais do ciclo de vida de desenvolvimento de software, bem como minimizar as carências relativas ao desenvolvimento com componentes, suas principais atividades, e aos ambientes de apoio a DBC.
A arquitetura de componentes é um aspecto crítico de DBC por representar como os componentes selecionados são combinados para atender os requisitos da aplicação.
A definição desta arquitetura está a cargo de um projetista que seleciona e conecta os componentes, bem como tem responsabilidade de identificar e prover as adaptações necessárias.
As adaptações, neste contexto, envolvem um conjunto freqüente e repetitivo de atividades, que consistem basicamente da aplicação de soluções padronizadas (padrões), de modo que o projetista não desvie seu foco da aplicação, sua arquitetura e de como ela atende os requisitos funcionais e nãofuncionais, para a resolução de incompatibilidades entre os componentes.
O objetivo das funcionalidades de apoio propostas é atuar neste contexto, fornecendo auxílio ao projetista na definição da arquitetura, identificação e registro de incompatibilidades entre componentes, e a estruturação de sua resolução (adaptação e composição) através do emprego de padrões.
As seis funcionalidades propostas estão contextualizadas dentro de o método UML Components, como apresentado na Seção 3.5.1.
Esta contextualização representa a identificação da etapa do ciclo de desenvolvimento em que elas são realizadas e as entradas necessárias para a sua aplicação.
Contudo, é importante observar que o método UML Components representa um possível cenário de contextualização das funcionalidades, mantendo- se aberta a possibilidade de utilizar outros métodos.
A decisão por o emprego de um outro método exige o estudo e identificação da fase voltada para a definição da arquitetura de componentes, buscando identificar no método o contexto propício para a realização das funcionalidades apresentadas a seguir.
Modelagem da Arquitetura de Componentes Considerando a contextualização deste trabalho no método UML Components, o uso desta funcionalidade centra- se na modelagem dos diagramas de Especificação de Interfaces, Especificação de Componentes e Arquitetura de Componentes.
Este trabalho tem como foco este último diagrama por representar o momento de combinação dos componentes, especificados ou pré-existentes, para formar a aplicação, se caracterizando como o cenário de realização das composições e, possivelmente, de adaptações dos componentes.
Esta funcionalidade representa a aplicação da notação da UML 2.
0 para estabelecer o diagrama de Arquitetura de Componentes, tendo como principais conceitos modelados:
Com esta funcionalidade torna- se possível modelar componentes com suas interfaces, bem como os relacionamentos existentes entre os componentes/ interfaces.
Além disso, esta é uma funcionalidade básica para todas as demais funcionalidades propostas, pois as mesmas ou serão realizadas a partir de o diagrama da arquitetura de componentes, ou farão uso da notação UML 2.
0. Seleção e Inspeção de Componentes Como parte da definição da arquitetura de componentes é necessário buscar e selecionar os componentes que serão combinados.
A definição desta funcionalidade pressupõe a existência de um repositório que contenha especificações de componentes descrevendo as suas interfaces providas e requeridas.
A partir de a existência deste repositório, esta funcionalidade possibilita que o projetista inspecione os componentes existentes e defina os que farão parte da arquitetura de componentes.
Entretanto, esta funcionalidade não têm maiores preocupações com questões quanto a identificação e recuperação de componentes apropriados, aspectos enfatizados em trabalhos como os de e.
A inspeção representa a possibilidade de consultar detalhes de um componente, que podem incluir o nome de interfaces/ métodos/ parâmetros, tipo dos parâmetros, assim como todas as demais informações disponibilizadas, de modo que o projetista tenha subsídios para realizar a seleção dos componentes.
Como a preocupação está centrada na existência da descrição das interfaces, são desconsideradas informações quanto a existência de projeto detalhado do componente ou implementação.
Além de possibilitar ao projetista a inspeção dos componentes, esta funcionalidade também viabiliza a inserção e apresentação dos componentes selecionados no diagrama de arquitetura de componentes.
Composição e Identificação de Incompatibilidades Esta funcionalidade possibilita que o projetista relacione as interfaces providas e requeridas dos componentes selecionados visando a definição da arquitetura de componentes.
Em uma situação mais simples, esta funcionalidade possibilita que o projetista empregue o conector de montagem para ligar interfaces providas a requeridas dos componentes selecionados, efetivando a sua composição.
A Figura 24 ilustra a aplicação do conector de montagem, em sua notação alternativa de dependência, Produto.
IItemDisponivel. Contudo, a composição pode ser comprometida por a existência de incompatibilidades entre os componentes selecionados.
Este trabalho assume três possíveis tipos de incompatibilidades:
A o tentar relacionar uma interface requerida com uma interface provida, seja com um conector de montagem ou com uma das dependências de incompatibilidade, esta funcionalidade executa a análise quanto a a existência de incompatibilidades.
Em uma situação comum, o projetista seleciona uma interface provida e uma interface requerida e utiliza um conector de montagem para conectar- las.
Caso a funcionalidade não identifique a existência de nenhum tipo de incompatibilidade, este conector é estabelecido entre as interfaces confirmando a composição dos componentes.
As incompatibilidades identificadas por a funcionalidade são documentadas e apresentadas nos Relatórios de Incompatibilidade.
Estes relatórios são apresentados sempre que uma incompatibilidade é identificada, relatando o tipo de incompatibilidade identificada, o nome dos componentes e interfaces participantes, bem como a descrição de todos os problemas encontrados.
No caso de detecção de incompatibilidade, a funcionalidade também procede à substituição do conector de montagem empregado por uma dependência de incompatibilidade, de acordo com o tipo de incompatibilidade identificada.
Além de controlar a existência de incompatibilidades, a funcionalidade também controla o correto emprego do conector de montagem e das dependências de incompatibilidade, só permitindo que eles sejam estabelecidos nas situações apropriadas.
A. Incompatibilidade Comportamental.
A o inspecionar um componente o projetista pode detectar que o componente (ou alguma de suas interfaces) não provê a funcionalidade como esperada.
Em estes casos, o projetista emprega esta funcionalidade para marcar a interface provida como apresentando incompatibilidade comportamental.
Além de possibilitar a marcação das interfaces, esta funcionalidade permite que o projetista documente a incompatibilidade identificada nas Notas de Incompatibilidade, que são associadas a cada uma das interfaces marcadas.
Esta documentação segue um formato textual livre.
O componente Cliente da Figura 26 apresenta a sua interface iPessoa marcada por apresentar incompatibilidade comportamental, em oposição à interface iCredito que não está marcada.
A descoberta automática de incompatibilidades de comportamento poderia ser realizada a partir de a existência de uma especificação formal das interfaces dos componentes, incluindo a semântica das operações.
No entanto, este trabalho não enfoca a existência desta especificação formal e atribui ao projetista a responsabilidade por a detecção deste tipo de incompatibilidade.
A funcionalidade possibilita que a incompatibilidade comportamental de uma interface provida seja marcada diretamente no componente/ interface, ou através do uso da dependência de incompatibilidade comportamental ou híbrida para ligar dois componentes.
Com o uso destas dependências as interfaces providas são automaticamente marcadas como comportamentalmente incompatíveis.
Ainda, a condição da interface provida marcada como incompatível é considerada durante a análise realizada por a funcionalidade para identificar a existência de incompatibilidade, bem como garantir o correto emprego do conector de montagem e das dependências de incompatibilidade.
A Figura 27 ilustra a aplicação da dependência de incompatibilidade comportamental para ligar os componentes GerenciaPedido.
IPessoa e Cliente.
IPessoa e definição da interface provida Cliente.
IPessoa como incompatível.
B. Incompatibilidade Estrutural. As incompatibilidades estruturais são detectadas automaticamente através desta funcionalidade durante a tentativa de relacionar dois componentes através do uso de conector de montagem ou de alguma das dependências de incompatibilidade.
A funcionalidade compara as interfaces selecionadas buscando a detecção de diferenças estruturais, de modo que a dependência de incompatibilidade estrutural só é estabelecida nos casos em que a existência de diferenças é confirmada.
A funcionalidade oferece ao projetista uma documentação detalhada de todas as incompatibilidades detectadas no Relatório de Incompatibilidade.
Os componentes GerenciaPedido.
IPedido e CestaCompra.
IPedido estão ligados na Figura 28 por uma dependência de incompatibilidade estrutural.
C. Incompatibilidade Híbrida. A incompatibilidade híbrida combina características das duas incompatibilidades anteriores, de modo que a sua detecção está tanto a cargo de o projetista (incompatibilidade comportamental) quanto da funcionalidade (incompatibilidade estrutural).
Esta incompatibilidade é estabelecida diretamente por o uso da dependência de incompatibilidade híbrida, ou é detectada por a funcionalidade quando de a tentativa de relacionar uma interface provida marcada como comportamentalmente incompatível a uma interface requerida, sendo que além de isto estas interfaces apresentam incompatibilidades estruturais.
O Relatório de Incompatibilidade, além de reportar os problemas encontrados, incorpora aqueles documentados por o projetista nas Notas de Incompatibilidade.
Os componentes GerenciaPedido.
IEntregaPedido GerenciaEntrega.
IEntregaPedido estão relacionados por uma dependência de incompatibilidade híbrida na Figura 29.
Adaptação e Composição utilizando Padrões Esta funcionalidade possibilita que as incompatibilidades identificadas e marcadas sejam tratadas através da aplicação de padrões de projeto.
O escopo deste trabalho está restrito à aplicação dos padrões Adapter, Proxy e Facade.
Entretanto, outros padrões também podem ser utilizados, existindo apenas a necessidade de caracterizar os tipos de incompatibilidades que o padrão se propõe a atender, e os requisitos para sua aplicação.
O emprego dos padrões, além de minimizar o trabalho repetitivo de adaptação e viabilizar as composições, permite que o projetista reflita sobre a adaptação e o impacto da aplicação de cada técnica.
A aplicação do padrão representa a definição da estrutura de uma solução incorporada à arquitetura de componentes, que será refinada e efetivamente implementada posteriormente durante a provisão do sistema.
A Figura 30 ilustra um possível cenário para a aplicação desta funcionalidade, em o qual estão identificados diferentes problemas entre os componentes, selecionados e ligados por dependências de incompatibilidade para formar a arquitetura de componentes.
A funcionalidade possibilita que sejam tratadas as incompatibilidades marcadas por as dependências de incompatibilidade, mas cabe ao projetista selecionar as interfaces que deseja adaptar, bem como escolher o padrão que será aplicado em cada caso.
A funcionalidade tem influência nesta seleção dos padrões, pois restringe a escolha do projetista àqueles padrões voltados diretamente para a tratamento da incompatibilidade em questão.
Com isso, a funcionalidade visa garantir que o projetista irá fazer sua escolha de entre as opções de padrões apropriadas para o tipo de incompatibilidade que deseja tratar.
Além disso, a funcionalidade restringe que as dependências de incompatibilidade comportamental só possam ser tratadas por a adaptação da interface provida.
Entretanto, nos casos de dependências de incompatibilidade estrutural e híbrida, a funcionalidade permite que o projetista opte entre a interface provida e requerida para ser adaptada.
A aplicação dos padrões envolve um conjunto de ações que, de uma maneira geral, envolvem a criação de novos componentes, possivelmente substituindo os componentes originais, e substituição das dependências de incompatibilidade por conectores de montagem.
A aplicação dos padrões Adapter e FacadeAdapter levam à definição de componentes complexos, denominados desta forma por apresentarem outros componentes como suas partes internas.
Desta forma, com a aplicação de Adapter e FacadeAdapter, os componentes originais da arquitetura são substituídos por novos componentes, e estes componentes originais são incorporados como parte dos novos componentes, assim como os demais componentes criados como parte do padrão aplicado.
Enquanto isso, os padrões Proxy e FacadeProxy determinam a criação de novos componentes, os quais passam a intermediar a comunicação dos componentes anteriormente relacionados por uma dependência de incompatibilidade, mas sem alterar- los nem remover- los da arquitetura.
Todos os componentes alterados ou criados por a aplicação dos padrões são diferenciados dos demais, permitindo uma fácil distinção entre os componentes originalmente selecionados por o projetista e aqueles oriundos de adaptações e composições.
A partir de as definições do projetista quanto a interface e padrão a serem aplicados, a funcionalidade conduz a aplicação semiautomática do padrão.
Considerando o cenário da Figura 30 e a decisão do projetista em, por exemplo, proceder a adaptação do componente Cliente.
IPessoa usando o padrão Adapter, a Figura 31 ilustra o resultado da aplicação do padrão realizada por a funcionalidade.
Com a aplicação do padrão, o componente Cliente é substituído por um novo componente NewCliente, de modo que o componente Cliente passa a fazer parte do comportamento interno do novo componente (Figura 33).
Igualmente, a dependência de incompatibilidade é substituída por um conector de montagem confirmando a composição de GerenciaPedido e NewCliente.
Ainda considerando as incompatibilidades identificadas na Figura 30, o projetista decide aplicar o padrão Proxy para tratar a incompatibilidade estrutural existente entre os componentes GerenciaPedido.
IPedido e CestaCompra_ IPedido.
O resultado da aplicação deste padrão por a funcionalidade é apresentado na Figura 32.
À medida que as adaptações são realizadas, todas as mudanças e alterações provocadas por os padrões são imediatamente propagadas e modeladas como parte da arquitetura de componentes.
Igualmente, os componentes adaptados incorporam toda a documentação proveniente dos Relatórios e Notas de Incompatibilidades, que poderão ser usadas em etapas posteriores para guiar a efetiva implementação do componente adaptado.
Visualização Esta funcionalidade engloba diferentes propriedades quanto a a visualização dos componentes e arquitetura de componentes:
Os componentes adaptados, bem como aqueles criados em virtude de a adaptação são diferenciados visualmente através de cores dos componentes originalmente selecionados por o projetista;
Visualização das partes internas (componentes e conectores) que formam os componentes complexos;
Diferenciação visual das interfaces providas marcadas como comportamentalmente incompatíveis.
As propriedades visuais estabelecidas nesta funcionalidade são obtidas como resultado da execução de outras funcionalidades propostas.
Em a Figura 33 é apresentado o comportamento interno do componente NewCliente, resultante da adaptação ilustrada na Figura 31.
A funcionalidade de visualização além viabilizar a apresentação do comportamento interno, também está caracterizada na Figura 33 por a diferenciação dos componentes NewCliente e Adapter (resultantes da adaptação) do componente Cliente.
A Figura 26 ilustrada a funcionalidade de visualização aplicada para a diferenciação das interfaces com e sem incompatibilidades comportamentais.
Histórico de Atividades Esta funcionalidade caracteriza- se por o registro das atividades realizadas durante a definição da arquitetura de componentes.
A funcionalidade considera o registro das seguintes informações:
Componentes incluídos ou removidos;
Interfaces providas marcadas/ desmarcadas por apresentarem incompatibilidade de comportamento;
Componentes compostos através de conector de montagem ou relacionados através das dependências de incompatibilidade;
Incompatibilidades identificadas;
Aplicação dos padrões e suas respectivas alterações na arquitetura de componentes (e.
g Esta funcionalidade disponibiliza a relação de atividades executadas, possibilitando que a mesma seja consultada a qualquer momento por o projetista.
A consulta destas informações permite identificar que atividades foram realizadas para a definição da arquitetura e em que seqüência elas foram executadas.
Igualmente, esta funcionalidade representa um primeiro esforço visando a definição de uma funcionalidade que permita a rastreabilidade dos componentes presentes na arquitetura de componentes estabelecida.
Este capítulo descreve o ambiente de apoio desenvolvido e discute como ele disponibiliza as funcionalidades propostas, exemplificando a aplicação das mesmas num cenário exemplo.
O ambiente desenvolvido incorpora todas as funcionalidades propostas no Capítulo 6, possibilitando demonstrar a sua aplicabilidade, bem como uma posterior validação empírica do emprego destas funcionalidades.
Este capítulo está centrado na apresentação do ambiente e demonstração do emprego das funcionalidades num cenário exemplo.
Questões quanto a a implementação são discutidas no Capítulo 8.
A Figura 34 apresenta o diagrama de casos de uso UML que ilustra as principais funcionalidades do protótipo desenvolvido.
A Figura 35 apresenta a interface principal do protótipo do ambiente de apoio a DBC desenvolvido, que se encontra dividida em três principais áreas:
UML Components Window6 (a):
Relaciona todos os tipos de diagrama empregados no método UML Components, de acordo com a sua organização de workflows.
Através desta janela o usuário seleciona o tipo de diagrama que deseja editar.
Component Window (b):
Lista todos os componentes pré-existentes que podem ser inspecionados e utilizados no desenvolvimento da arquitetura de componentes.
Modeling Window (c):
Área em que o diagrama selecionado é criado e editado.
Como já mencionado, este trabalho tem seu escopo restrito à edição do diagrama de arquitetura de componentes.
Além de estas três janelas, a interface do ambiente de apoio também compreende um menu e uma barra de ferramentas (d).
A barra de ferramentas disponibiliza o conector de montagem e as dependências de incompatibilidade para relacionar os componentes, enquanto o menu oferece funcionalidades para abrir/ salvar os diagramas, visualização do Histórico de Atividades, entre outras funcionalidades de manipulação dos elementos gráficos providas por o framework JHotDraw utilizado na implementação do protótipo.
A maior parte das funcionalidades do ambiente é disponibilizada através de menus pop-up associados aos diferentes tipos de objetos, de modo que componentes, interfaces e ligações (dependências de incompatibilidade) apresentam seus respectivos menus.
A Figura 36 ilustra as O nome das janelas e operações são apresentados em inglês por ser o idioma em o qual a interface do protótipo foi baseada.
Dá acesso a uma janela onde podem ser documentadas informações sobre a incompatibilidade comportamental apresentada por a interface.
Permite que uma ligação seja excluída.
Incompatibility report Habilitado para as dependências de incompatibilidade.
Dá acesso a uma janela em que é apresentada a descrição das incompatibilidades detectadas entre as interfaces.
Adapt component Habilitado para os componentes que apresentem interfaces ligadas por dependências de incompatibilidade.
Dá acesso à janela em que são definidas as adaptações a serem realizadas num dos componentes ligados por a dependência.
Toggle incompatibility Ligação Habilitado para as interfaces providas.
Marca/ desmarca interface selecionada como apresentando incompatibilidade comportamental.
Disconnect Componente Toggle incompatibility Incompatibility notes Interface Adapt interface Habilitado para as interfaces ligadas por dependências de incompatibilidade.
Dá acesso à janela em que são definidas as adaptações a serem realizadas na interface.
Habilitado para os componentes que apresentam interfaces providas.
Marca/ desmarca todas interfaces providas como apresentando incompatibilidade comportamental.
Adapt component Habilitado para os componentes que apresentam interfaces ligadas por dependências de incompatibilidade.
Dá acesso à janela em que são definidas as adaptações a serem realizadas no componente.
Nested internal diagram Habilitado para os componentes adaptados (componentes complexos).
Dá acesso ao diagrama em que estão modelados seus elementos internos.
Rename Habilitado para os componentes adaptados.
Permite a alteração do nome do componente.
Adaptation notes Habilitado para os componentes adaptados.
Dá acesso à janela em que são apresentadas as informações provenientes dos Relatórios e Notas de Incompatibilidade.
Details Dá acesso à janela de inspeção do componente em que são apresentadas informações das interfaces e respectivas operações.
Delete Permite a remoção do componente do diagrama.
O ambiente assume a existência de um vínculo com repositórios que disponibilizem arquivos XML (Extensible Markup Language) com a descrição das interfaces dos componentes préexistentes.
Estes arquivos são obtidos através de wrappers anexados ao repositório.
Os arquivos XML seguem uma estrutura pré-definida.
A Figura 37 mostra o arquivo XML de descrição do componente Produto representado na UML 2.
0. A opção por o uso de arquivos no formato XML está relacionado ao melhor entendimento e organização das informações, de modo que foi definido uma estrutura XML que reflete a estrutura de um componente assim como proposto na Todos os componentes para os quais existem especificações de interfaces conforme este formatos são exibidos na Component Window (Figura 35 (b)), caracterizando os componentes que podem ser utilizados na modelagem da arquitetura de componentes.
Esta seção ilustra a aplicação do ambiente de apoio para a modelagem da arquitetura de componentes num cenário exemplo, detalhando como cada uma das funcionalidades propostas foi incorporada num ambiente de apoio.
Embora as atividades apresentadas a seguir sejam estabelecidas seqüencialmente, observa- se que elas podem ser realizadas interativamente e em qualquer ordem, bem como o número de vezes que se fizerem necessárias para realizar a modelagem da arquitetura de componentes.
A. Inspeção e Seleção de Componentes.
Considerando os requisitos a serem atendidos por a aplicação, o projetista irá inspecionar e selecionar componentes do repositório que serão utilizados na definição da arquitetura de componentes.
O ambiente relaciona os componentes pré-existentes na Component Window, e possibilita a inspeção destes componentes através do botão Details (Figura 35 (b)).
A funcionalidade de inspeção apresenta uma nova janela com informações sobre as interfaces do componente (nome e tipo), assinatura dos métodos (nome do método e nome e tipo dos atributosa) apresenta a janela de inspeção do componente CestaCompra.
Ainda como parte desta inspeção, é possível selecionar os métodos da interface e consultar sua descrição, como ilustrado na Figura 38 (b).
Os componentes selecionados são inseridos no diagrama por o projetista a partir de o botão Insert presente na Component Window (Figura 35 (b)).
Considerando um cenário exemplo, o projetista se vale desta funcionalidade e insere no diagrama de arquitetura de componentes os componentes:
CestaCompra, GerenciaPedido, Produto, Cliente, GerenciaEntrega, ConversaoDolar e ConversaoEuro.
Os componentes selecionados são disponibilizados na Modeling Window, de acordo com a notação UML 2.
0, como ilustrado na Figura 35 (c).
As mesmas informações consultadas durante a inspeção dos componentes podem ser consultadas a qualquer momento através do menu pop-up do componente, opção Details.
B. Incompatibilidade Comportamental e Notas de Incompatibilidade.
Durante a inspeção dos componentes, o projetista identificou que as interfaces Cliente.
IPessoa, Cliente.
ICredito e GerenciaPedido.
IEntregaPedido não oferecem as funcionalidades exatamente como esperado.
Acessando opção Toggle incompatibility do menu pop-up da interface GerenciaPedido.
IEntregaPedido, o projetista marca esta interface como comportamentalmente incompatível.
No caso de o componente Cliente, acessando a mesma funcionalidade no menu pop-up do componente, o projetista marca simultaneamente as interfaces iPessoa e iCredito como comportamentalmente incompatível.
As interfaces marcadas como incompatíveis são diferenciadas graficamente das demais, como ilustrado na Figura 39.
Para documentar os problemas comportamentais encontrados, o projetista seleciona a opção Incompatibility notes do menu pop-up da interface marcada como comportamentalmente incompatível.
A documentação segue um formato textual livre.
A Figura 40 apresenta a documentação provida por o projetista para a incompatibilidade comportamental da interface GerenciaPedido.
IEntregaPedido. D. Dependência de Incompatibilidade e Relatório de Incompatibilidade.
Também utilizando o conector de montagem, o projetista tenta compor os componentes GerenciaPedido.
IPedido e CestaCompra.
IPedido da Figura 39.
A o tentar relacionar estas interfaces, o ambiente detecta a existência de incompatibilidades estruturais e apresenta um Relatório de Incompatibilidade (Figura 42).
O relatório descreve o nome dos componentes, interfaces participantes da ligação, tipo da incompatibilidade identificada, e a descrição dos problemas.
Ainda em virtude de a incompatibilidade detectada, o ambiente procede à substituição do conector de montagem originalmente selecionado por o projetista por uma dependência de incompatibilidade estrutural, como ilustrado por a Figura 43.
O ambiente de apoio agirá de forma semelhante sempre que uma incompatibilidade for detectada entre duas interfaces ligadas por um conector de montagem, substituindo- o por a dependência de incompatibilidade apropriada.
O projetista também pode ligar as interfaces diretamente por dependências de incompatibilidade.
Caso o ambiente detecte que a dependência de incompatibilidade escolhida por o projetista não é a apropriada, ele fará a substituição adequada.
Sempre que o ambiente estabelece uma dependência de incompatibilidade, um Relatório de Incompatibilidade é apresentado.
As informações apresentadas neste relatório podem ser consultadas a qualquer tempo através da opção Incompatibility report do menu pop-up das ligações.
Tendo marcado interface GerenciaPedido.
IEntregaPedido como apresentando incompatibilidade comportamental, o projetista utiliza a dependência de incompatibilidade comportamental (ou mesmo o conector de montagem) para relacionar- la com a interface GerenciaEntrega.
IEntregaPedido. Contudo, o ambiente detecta que também existem incompatibilidades estruturais entre estas interfaces e, por isso, procede à substituição da dependência utilizada por uma dependência de incompatibilidade híbrida.
As informações sobre a natureza da incompatibilidade comportamental da interface GerenciaEntrega.
IEntregaPedido documentadas por o projetista anteriormente são incluídas como parte do Relatório de Incompatibilidade, como ilustrado na Figura 44.
Depois, o projetista relaciona as interfaces GerenciaPedido.
IPessoa e Cliente.
IPessoa utilizando o conector de montagem.
Durante a verificação de incompatibilidades o ambiente detecta que a interface Cliente.
IPessoa está marcada como comportamentalmente incompatível, e como não existem problemas estruturais entre estas interfaces, substitui o conector de montagem por uma dependência de incompatibilidade comportamental (Figura 45).
O projetista também poderia ter ligado estas interfaces usando diretamente a dependência de incompatibilidade comportamental.
Após marcar as interfaces dos componentes ConversaoDolar.
IConversaoDolar ConversaoEuro.
IConversão como comportamentalmente incompatíveis, o projetista finalmente utiliza a dependência de incompatibilidade híbrida para relacionar cada uma destas interfaces à interface CestaCompra.
IConversao. A detecção das incompatibilidades é confirmada por o ambiente e as dependências de incompatibilidade híbridas são estabelecidas (Figura 46).
A Figura 47 apresenta o diagrama da arquitetura de componentes resultante, com todas as dependências estabelecidas.
E. Adaptação e Composição Utilizando Padrões.
Entre as inúmeras incompatibilidades ilustradas na Figura 47, o projetista decide iniciar por o tratamento da incompatibilidade comportamental entre as interfaces Cliente.
IPessoa e GerenciaPedido.
IPessoa. O projetista seleciona a opção Adapt interface do menu pop-up da interface Cliente.
IPessoa para acessar a janela de adaptação, onde a adaptação será configurada.
A janela de adaptação apresenta as seguintes informações:
A definição de cada adaptação envolve a seleção de um componente, de uma das interfaces candidatadas a adaptação, bem como do respectivo padrão a ser aplicado.
Estas definições do projetista vão sendo adicionadas na forma de tarefas, permitindo que o projetista defina um conjunto de adaptações que serão realizadas simultaneamente, seja utilizando um mesmo padrão, ou padrões diferentes.
A janela de adaptação pode ser acessada através das interfaces ligadas por dependências de incompatibilidades, por os componentes que possuem estas interfaces, ou ainda por as próprias dependências de incompatibilidade.
Estas três opções se diferenciam por os componentes e respectivas interfaces relacionados como candidatos à adaptação:
Menu pop-up da interface:
Limita como única interface candidata à adaptação a própria interface a partir de a qual Adapt interface foi acionada;
Dependência de Incompatibilidade:
Permite a escolha entre os dois componentes e respectivas interfaces ligadas por a dependência;
Componente: Relaciona todas as interfaces deste componente que se apresentem ligadas por alguma das dependências de incompatibilidade.
No caso de a adaptação do componente Cliente, a janela de adaptação apresenta exclusivamente a interface iPessoa como candidata à adaptação.
Cabe ao projetista selecionar um dos padrões relacionados e adicionar esta definição como uma tarefa a ser executada.
O projetista pode ter mais informações sobre o padrão através do botão?
Considerando a decisão do projetista por o uso do padrão Adapter, a Figura 49 ilustra a definição da tarefa criada.
A execução da tarefa determina a aplicação do padrão no componente/ interface selecionado.
A Figura 50 apresenta o diagrama da arquitetura de componentes após a aplicação do padrão Adapter na interface Cliente.
IPessoa. Observa- se que o componente Cliente é substituído por um novo componente, denominado NewCliente, e que a dependência de incompatibilidade comportamental apresenta- se substituída por o conector de montagem.
O componente NewCliente é um componente complexo e o seu comportamento interno é apresentado na Figura 51, onde estão dispostos o componentes adapter1 e o componente Cliente original.
Os componentes adaptados ou resultantes da adaptação são apresentados na cor cinza, distinguindo- se dos demais.
Como parte da aplicação do padrão o ambiente atribui um nome padronizado para os componentes criados.
Entretanto, o projetista pode utilizar a opção Rename, presente no menu pop-up destes componentes, para alterar este nome.
Como próximo passo o projetista decide tratar as incompatibilidades do componente GerenciaPedido.
Acessando o menu pop-up do componente, o projetista abre a janela de adaptação.
Em este caso, o projetista define duas tarefas de adaptação (Figura 52) para aplicar o padrão Adapter para tratar tanto a incompatibilidade híbrida da interface iEntregaPedido, como a incompatibilidade estrutural da interface iPedido.
Durante a execução da primeira tarefa, a aplicação do padrão Adapter cria um componente adapter1 que é ligado ao componente GerenciaPedido como parte do comportamento interno do novo componente NewGerenciaPedido.
Com isso, a execução da segunda tarefa já ocorre sobre o componente NewGerenciaPedido, que apresenta como parte de seu comportamento interno um componente adapter.
Em casos como este, em o qual o componente já foi adaptado utilizando o padrão Adapter, é apresentada uma janela de diálogo para que o projetista selecione se esta nova aplicação do padrão Adapter deve utilizar um dos componentes adapter existentes ou criar um novo.
Assume- se neste exemplo que projetista opta por utilizar dois componentes adapter distintos, cada um manipulando uma das interfaces adaptadas.
Em este sentido, a Figura 53 apresenta a janela de diálogo em que o projetista seleciona a opção para criar um novo componente adapter, ao invés de selecionar um já existente.
A Figura 54 ilustra o diagrama de arquitetura de componentes após a aplicação do padrão Adapter para tratar as incompatibilidades do componente GerenciaPedido.
O próximo passo é a resolução das incompatibilidades híbridas existente entre o componente CestaCompra.
IConversão e os componentes ConversaoDolar.
IConversaoDolar e ConversaoEuro.
IConversão (Figura 54).
O projetista poderia proceder como nos casos anteriores, selecionado as interfaces, os componentes ou mesmo as ligações de incompatibilidade híbrida para adaptar ConversaoDolar.
IConversaoDolar ConversaoEuro.
IConversão individualmente.
Entretanto, o projetista deseja unificar os componentes ConversaoDolar e ConversaoEuro, já que juntos oferecem toda funcionalidade requerida por CestaCompra.
IConversao. O ambiente de apoio assume que as situações em que uma interface requerida apresenta mais de uma ligação de dependência caracterizam o cenário de aplicação do padrão Facade.
Por isso, nestas situações, o ambiente disponibiliza a opção Adapt interface no menu pop-up da interface requerida.
Com isso, a partir de o menu pop-up da interface CestaCompra.
IConversão o projetista tem acesso à janela de adaptação apresentada na Figura 56.
Assumindo a decisão do projetista de adaptar CestaCompra.
IConversão utilizando a implementação FacadeProxy do padrão Facade, a Figura 57 apresenta o diagrama de componentes resultante.
ConversaoDolarConversaoEuroFacadeProxy, criado por a aplicação do padrão FacadeProxy.
Este componente assume uma especificação que permite que ele seja ligado aos componentes ConversaoDolar e ConversaoEuro, bem como provenha a interface assim como requisitada por CestaCompra.
IConversao. F. Visualização A funcionalidade de Visualização proposta foi exemplificada ao longo deste cenário exemplo com a diferenciação das interfaces incompatíveis, conexões com e sem incompatibilidades (e.
g Figura 47) componentes originais e adaptados (e.
g Figura 54), bem como a visualização do comportamento interno dos componentes complexos (e.
g Figura 55).
G. Histórico de Atividades As atividades realizadas ao longo de a modelagem da arquitetura de componentes são registradas por o ambiente de apoio e podem ser consultadas a qualquer tempo através do menu do protótipo, opção View.
O ambiente registra as seguintes atividades:
Componente incluído/ excluído;
Interface marcada/ desmarcada como comportamentalmente incompatível;
Tentativa de relacionar componentes com dependência de incompatibilidade;
Tentativa de relacionar componentes com ligação inapropriada;
Dependências de incompatibilidades estabelecidas entre componentes;
Composição de componentes utilizando conectores de montagem;
Exclusão de uma dependência de incompatibilidade ou conector de montagem;
Detecção de incompatibilidade;
Aplicação de padrão;
Criação de componentes durante a adaptação;
Substituição de componente em virtude de a adaptação;
Alteração do nome de um componente;
Através das informações registradas, o projetista tem como saber quais foram os componentes selecionados e como ocorreu a definição das ligações até eles serem efetivamente compostos por os conectores de montagem.
A Figura 59 ilustra um trecho do relatório gerado por o ambiente com as informação das atividades realizadas ao longo de esta seção.
Este capítulo apresenta o framework JHotDraw usado na implementação do protótipo do ambiente de apoio a DBC, caracteriza a semântica dos elementos gráficos tratados e descreve as extensões realizadas no framework para a implementação destes elementos.
O protótipo foi desenvolvido integralmente utilizando a linguagem Java e o framework JHotDraw, este último para suportar o desenho e manipulação dos elementos gráficos relativos a notação UML 2.
0. JHotDraw é um framework para desenvolvimento de aplicações gráficas, baseadas na linguagem Java.
Originalmente desenvolvido por Erich Gamma e Thomas Eggenschwiler como um exercício de modelagem, atualmente JHotDraw é desenvolvido como um projeto de código aberto e encontra- se disponível na versão 6.1.
Segundo, JHotDraw apresenta- se como um framework maduro que oferece um suporte expressivo para o domínio gráfico, e que com um conhecimento básico da estrutura de funcionamento do framework é possível estender- lo e incorporar mais funcionalidades.
As classes e interfaces de JHotDraw são organizadas numa estrutura de oito pacotes, de acordo com seu propósito, os quais são descritos na Tabela 7.
Todas as aplicações que usam JHotDraw apresentam uma janela dedicada para o desenho de diferentes elementos gráficos.
A Figura 60 ilustra a arquitetura base de uma aplicação JHotDraw, que se caracteriza por estabelecer a janela principal (DrawApplication) como um coordenador dos elementos gráficos e ferramentas.
Uma aplicação JHotDraw é definida por uma janela principal que segue a estrutura padrão estabelecida por DrawApplication.
Esta janela principal está associada a janelas de visualização (DrawingView) que são responsáveis por apresentar e atualizar os desenhos (Drawing) as quais estão associadas.
Já os desenhos são containers de figuras que se encarregam de avisar à área de visualização sobre todas as mudanças que ocorrerem com as figuras.
Por sua vez, as figuras (Figure) são elementos gráficos, os quais podem ser formadas a partir de outras figuras.
Handle é o mecanismo previsto em JHotDraw para possibilitar a alteração das figuras por a manipulação direta do usuário.
As ferramentas (Tool) estão associadas à janela principal e provêem mecanismos que permitem o usuário manipular as figuras que se deseja criar.
Segundo, o desenvolvimento de uma aplicação com JHotDraw envolve um conjunto recorrente de atividades, as quais estão centradas na integração do framework com a aplicação que se deseja desenvolver.
Estas atividades podem ser organizadas nas seguintes etapas Criação dos elementos:
Representa a definição dos elementos gráficos e símbolos próprios à aplicação sendo desenvolvida.
JHotDraw disponibiliza algumas figuras pré-definidas através de classes como AbstractFigure e CompositeFigure, que podem ser refinadas através da definição de subclasses ou sobrescrita de métodos, buscando customizar o seu comportamento e representação gráfica.
Criação de ferramentas:
Representa a definição de ferramentas para criar e manipular figuras, de acordo com a semântica da aplicação.
JHotDraw disponibiliza algumas opções de ferramentas pré-definidas (e.
g ConnectionTool, SelectionTool), as quais também podem ser refinadas para atender algum tipo específico de interação e realizar tarefas próprias da aplicação sendo desenvolvida.
Criação da interface gráfica da aplicação:
A partir de uma estrutura padrão (DrawApplication) provida por JHotDraw, esta etapa está centrada na definição da janela principal da aplicação, incluindo menus e toda a estruturação da interface.
A Figura 61 apresenta um diagrama de classes UML representando a modelagem definida para atribuição da semântica aos elementos gráficos tratados por o protótipo.
O protótipo está voltado para a definição de diagramas de arquitetura de componentes (Diagrama Arquitetura Componente) que são agregações de componentes (Componente) e ligações (Ligação).
Os componentes se caracterizam por possuírem um nome e uma documentação, e por apresentar uma ou mais interfaces nomeadas (Interface Nomeada).
Um componente complexo pode estar associado a um diagrama de arquitetura (diagrama interno).
Enquanto Interface representa a descrição de uma interface que não apresenta vínculo com um componente específico, as interfaces nomeadas definem interfaces que assumem um tipo (provida ou requerida) e estão associadas a um componente.
As interfaces podem ter operações (Operação), descritas por um nome, e parâmetros de entrada e de retorno.
Ligação é a definição do relacionamento entre duas interfaces nomeadas, sendo que uma deve ser do tipo provida e a outra do tipo requerida.
As ligações estão caracterizadas por um tipo, que pode ser conector de montagem ou uma das três dependências de incompatibilidade (estrutural, comportamental e híbrida).
Considerando a descrição do framework JHotDraw apresentada na Seção 8.1 e a semântica dos elementos constituintes do protótipo do ambiente de apoio, apresentada na Seção 8.2, esta seção apresenta as extensões realizadas no framework JHotDraw e a arquitetura do protótipo.
Graficamente o protótipo se caracteriza por apresentar três tipos de elementos:
Interface (provida e requerida):
Definida por um elemento gráfico (circulo ou arco);
Componente: Definido por um elemento gráfico (retângulo) e dois elementos textuais (estereótipo e nome do componente);
Ligações (conector de montagem e dependências de incompatibilidade):
Linhas que ligam elementos e apresentam adornos nas extremidades.
Todos os elementos gráficos foram definidos a partir de a extensão da classe Figure de JHotDraw, sendo que as subclasses estendida foram definidas de acordo com o tipo do elemento, como descrito a seguir.
A. Interface A classe CompositeFigure de JHotDraw se caracteriza por permitir a composição de figuras com um comportamento único, e assumir a responsabilidade por a apresentação desta figura.
Enquanto elementos gráficos, as interfaces providas são consideradas como um círculo, e as requeridas como um arco.
As interfaces são definidas a partir de a extensão de CompositeFigure, em virtude de o suporte que esta classe oferece à definição de menus pop-up.
A linha que liga o círculo/ arco ao componente é desenhada separadamente, bem como o nome da interface é apresentado como um elemento textual separado, de modo a possibilitar que o usuário possa mudar- lo de posição.
B. Componente A subclasse GraphicalCompositeFigure de JHotDraw também está voltada para a composição de figuras, mas se diferência de CompositeFigure por possibilitar a composição de elementos que têm capacidade própria de se desenhar.
Esta característica de GraphicalCompositeFigure permite compor figuras através da combinação de elementos gráficos e textuais (e.
g classe TextFigure), já que os elementos textuais se responsabilizam por sua apresentação.
Um componente representa a composição de um retângulo com dois elementos textuais, sendo definido a partir de a extensão da classe GraphicalCompositeFigure.
Os componentes também herdam a possibilidade de apresentarem menu pop-up, já que GraphicalCompositeFigure é uma subclasse de CompositeFigure.
A extensões realizadas para definir componentes e interfaces são ilustradas na Figura 62.
As classes em cor cinza representam subclasses criadas a partir de as classes oferecidas por JHotDraw.
C. Ligações JHotDraw provê uma classe chamada PolyLineFigure que permite a definição de linhas que podem apresentar adornos em suas extremidades.
Complementarmente, apresenta a subclasse LineConnection que define linhas que conectam dois elementos.
Desta forma, a representação gráfica das ligações do protótipo foi estabelecida a partir de a extensão de LineConnection.
Cada um dos tipos de ligação é implementado por uma classe, onde é definida a forma da linha (e.
g linha, linha tracejada), a existência de seta nas extremidades, e o tipo desta seta (e.
g D. Outras Extensões Também foi necessário estender classes de JHotDraw responsáveis por o salvamento dos diagramas (StorableInput, StorableOutput e StandardStorageFormat), de modo que o protótipo permitisse o salvamento de todas as informações associadas aos elementos gráficos, bem como dos diagramas de comportamento interno.
Ainda, através da extensão da classe LineConnection, foi criada classe AssociationLineConnection que define a linha usada para ligar os elementos gráficos representativos de componentes e interfaces.
Igualmente, foi estendia a classe LineFigure (subclasse de PolyLineFigure) visando a definição de uma linha transparente (SeparatorFigure) para corrigir um problema na apresentação dos componentes, já que a apresentação dos dois elementos textuais do componente, um acima de o outro, gerava a definição de uma linha separatória entre eles.
Apesar de o esforço empregado, a utilização do JHotDraw minimizou significativamente os esforços com a definição e manipulação dos elementos gráficos.
Adicionalmente às extensões JHotDraw, foi implementado um conjunto de classes Java que definem a semântica dos elementos gráficos, bem como todos os demais mecanismos e funcionalidades do protótipo.
DBC é uma importante abordagem para o desenvolvimento de software com reuso.
Enquanto existe uma maior preocupação com o desenvolvimento de componentes, identifica- se uma grande carência de suporte ao desenvolvimento com componentes.
A ênfase deste trabalho está no desenvolvimento com componentes e suas duas principais atividades, adaptação e composição de componentes.
Com a intenção em antecipar as preocupações com componentes para as fases iniciais do ciclo de desenvolvimento, este trabalho também enfatiza a definição de arquitetura de componentes.
A convergência destas ênfases é estabelecida neste trabalho por a proposta de um conjunto de funcionalidades próprias a um ambiente de apoio a DBC, voltadas prioritariamente para a modelagem da arquitetura de componentes e suporte às atividades de adaptação e composição de componentes em nível arquitetural através do uso de padrões.
As funcionalidades propostas têm como características:
Antecipação da preocupação com componentes com a ênfase na modelagem da arquitetura de componentes;
Emprego da notação UML 2.
0 para componentes;
Realização das adaptações e composições em nível arquitetural;
Identificação e registro das incompatibilidades comportamentais, estruturais e híbridas entre os componentes;
Emprego de padrões de projeto como mecanismo para o tratamento de adaptações e composições;
Definição de uma estrutura de solução para as incompatibilidades incorporada à arquitetura de componentes.
A antecipação da preocupação com componentes procura minimizar o retrabalho decorrente da dificuldade de adaptar e compor os componente selecionados.
A tardia identificação de problemas entre os componentes pode gerar a necessidade de uma maior demanda de implementação do que a inicialmente prevista para integrar os componentes, ou, até mesmo, a necessidade de buscar novos componentes por a impossibilidade de compor ou realizar as adaptações nos componentes definidos.
As funcionalidades propostas priorizam a definição da arquitetura de componentes já incorporando a estrutura de uma solução para as incompatibilidades prematuramente detectadas.
Além disso, as funcionalidades possibilitam a identificação das partes da arquitetura provenientes de adaptações, e todas as atividades realizadas visando a definição da arquitetura são registradas permitindo que o projetista posteriormente identifique quais foram as atividades e a seqüência em que elas foram realizadas.
A definição das funcionalidades envolveu a sua contextualização dentro de o método UML Components, que se caracteriza por suportar a abordagem genérica de, estando voltado a especificação de interfaces e componentes, e definição da arquitetura de componentes.
Esta contextualização representa a definição do momento dentro de o processo de desenvolvimento em que as funcionalidades são aplicadas, bem como as entradas necessárias para que elas sejam utilizadas.
Contudo, as funcionalidades propostas não estão restritas ao método UML Components, já que este é apenas um possível contexto.
Outros métodos podem ser igualmente considerados, havendo apenas a necessidade de identificar no método a etapa mais adequada para contextualizar as funcionalidades.
A demonstração da aplicação das funcionalidades propostas foi realizada através da implementação do protótipo do ambiente de apoio.
Além de incorporar todas as funcionalidades, o protótipo também reforça a independência de tecnologia de implementação, de modo que os componentes pré-existentes são caracterizados através de arquivos XML com a descrição das suas interfaces.
A Tabela 8 confronta o suporte oferecido por o ambiente desenvolvido e por os ambientes voltados para o apoio a DBC em nível de modelagem discutidos no Capítulo 5.
Além de atender as principais carências levantadas no Capítulo 5, o ambiente de apoio inova na utilização de padrões de projeto no âmbito do desenvolvimento com componentes, bem como por empregar a notação padronizada UML 2.
0. Contudo, o ambiente não atende aos seguintes requisitos de:
Suporte às duas perspectivas de DBC (desenvolvimento de e com componentes);
Definição global de nomes de interfaces;
Reuso por referência.
O requisito de suporte às duas perspectivas não é atendido por o foco deste trabalho estar voltado exclusivamente para o desenvolvimento com componentes.
Igualmente, os dois outros requisitos não são observados por serem considerados como aspectos que devem ser atendidos por os repositórios de componentes.
Entre os ambientes estudados, apenas o ambiente Wren está voltado para o desenvolvimento com componentes.
O ambiente desenvolvido se diferência deste ambiente por os seguintes aspectos:
Não possui vínculo com tecnologia e linguagem de programação;
Oferece suporte à adaptação de componentes, através do emprego de padrões de projeto;
Permite a visualização do comportamento interno dos componentes adaptados;
Emprega a definição padrão da UML sem extensões.
A opção por o emprego do framework JHotDraw para a implementação do protótipo se deu com o objetivo de minimizar os esforços com a definição e manipulação dos elementos gráficos.
O custo para o entendimento e uso de JHotDraw é bastante alto.
A ausência de uma documentação apropriada exige com que o entendimento do framework seja obtido por o estudo do seu código fonte, através do rastreamento dos métodos e operações.
Embora tenha sido investido uma grande parte do tempo na compreensão do framework, a utilização do JHotDraw atendeu o objetivo inicial e possibilitou que o maior esforço de implementação fosse direcionado para a definição da semântica dos elementos gráficos, ao invés de a sua apresentação e manipulação.
O trabalho desenvolvido apresenta as seguintes limitações:
A identificação de incompatibilidades está restrita aos tipos de incompatibilidades estruturais e comportamentais descritos na Seção 4.2.3.
As situações consideradas abrangem os casos mais significativos de causas para adaptação.
O emprego de padrões de projeto está restrito aos padrões Adapter, Proxy e Facade.
Estes padrões são suficientemente representativos para comprovar aplicabilidade e benefícios de padrões de projeto para tratar adaptações e composições.
A inclusão de outros padrões contribui para a diversidade de possíveis técnicas a serem aplicadas.
O ambiente de apoio definido não apresenta suporte à detecção automática de incompatibilidades comportamentais.
Esta limitação representa uma decisão de projeto, onde não se teve interesse em considerar especificações formais das interfaces.
A preocupação com o desenvolvimento com componentes está centrada nas atividades de adaptação e composição de componentes.
A definição em considerar apenas estas atividades se deu como parte do escopo do trabalho, já que elas são consideradas as principais atividades do desenvolvimento com componentes.
Suporte restrito à definição do diagrama de arquitetura de componentes.
Limitação estabelecida por a definição do escopo do trabalho.
No entanto, se tem intenção em integrar o ambiente desenvolvido neste o trabalho com o de, que suporta a modelagem dos diagramas previstos no workflow de Especificação de UML Components seguindo a notação UML 2.
0. Visando a complementação e evolução do trabalho realizado, são considerados possíveis trabalhos futuros:
Validação empírica das funcionalidades propostas, através do ambiente implementado;
Melhor integração entre a definição da arquitetura com as fases de especificação de componentes e interfaces, e de provisão do sistema;
Adição de outros padrões de projeto;
Detecção automática de incompatibilidades comportamentais;
Implementação da rastreabilidade entre os diferentes diagramas;
Integração do ambiente desenvolvido a uma infra-estrutura de repositório;
Suporte às demais atividades do desenvolvimento com componentes.
