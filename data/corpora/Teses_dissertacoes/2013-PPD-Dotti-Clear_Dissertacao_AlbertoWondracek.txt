Redes de autômatos estocásticos (SAN) é um formalismo que permite a descrição de sistemas a fim de realizar avaliações quantitativas.
O objetivo deste trabalho é possibilitar avaliações qualitativas de modelos SAN através de sua tradução para a linguagem de um verificador existente.
O trabalho propõe, detalha e exemplifica o mapeamento de um subconjunto de modelos SAN para a linguagem de entrada do NuSMV.
Conforme o resultado observado, os modelos para o NuSMV gerados por o tradutor preservam a semântica dos respectivos modelos SAN originais pois apresentam sistemas de transição de estados isomórficos.
A verificação de propriedades em CTL (Computation Tree Logic) sobre os modelos SAN é exemplificada.
Palavras Chave: Verificação de modelos, SAN, NuSMV, Tradução de modelos Em os últimos anos tem crescido o desenvolvimento de sistemas digitais na maior parte do mundo, sendo de grande importância a validação da corretude de eles.
Por isso mais de 50% do tempo de desenvolvimento de um sistema é investido em testes.
As técnicas que são mais utilizadas na prática são:
A revisão em pares, que detecta cerca de 60% dos defeitos, e testes de execução de código, possuindo um custo entre 30% a 50% do orçamento do projeto.
Entretanto, a correção de uma falha identificada através destas técnicas é cerca de 500 vezes mais cara do que quando identificada na fase conceitual do projeto.
Uma técnica de verificação formal, aplicada na fase conceitual do projeto, é a verificação de modelos, conhecida como Model Checking.
Esta técnica permite verificar se um modelo, de estados finitos, respeita um conjunto de propriedades, tipicamente especificadas em lógica temporal, como por exemplo, (Computation Tree Logic).
Um grande atrativo desta técnica é o fato de que ela é completamente automática, mostrando contra exemplos caso o modelo não satisfaça alguma propriedade, portanto ela valida a ausência de defeitos para as propriedades especificadas.
Sua aplicação não se restringe apenas projetos de software, sendo aplicado também em projetos de hardware.
A modelagem de sistemas objetiva descrever de forma compacta o comportamento e características do sistema, podendo ser realizada através de diversos formalismos.
O formalismo que será abordado neste trabalho será as redes de autômatos estocásticos (Stochastic Automata Network ­ SAN), que possibilita a descrição de modelos de sistemas, com o objetivo de avaliar seu desempenho.
Um modelo SAN é estruturado em subsistemas, onde cada subsistema é modelado por um autômato estocástico, e por a interação de eles entre si.
O autômato estocástico é constituído por estados e transições, que são as mudanças de estado, ocasionadas por eventos locais ou sincronizantes.
Os eventos locais realizam uma transição em apenas um autômato, já os sincronizantes são responsáveis por uma transição em mais de um autômato ao mesmo tempo.
SAN conta com um conjunto de técnicas e ferramentas que possibilita a avaliação quantitativa de modelos descritos em SAN.
O objetivo deste trabalho é possibilitar a análise qualitativa de modelos descritos em SAN.
Este objetivo pode ser alcançado a partir de duas abordagens:
O desenvolvimento de um verificador de modelo SAN e o mapeamento de conceitos SAN para linguagem de entrada de uma ferramenta existente de verificação.
Este trabalho opta por a segunda abordagem.
Por a facilidade de modelar os conceitos de eventos sincronizantes, este trabalho propõe o mapeamento de conceitos SAN para a linguagem da ferramenta NuSMV, escolhidos entre outros ambientes de Model Checking.
Um conjunto de conceitos SAN foi mapeado para os conceitos da linguagem do NuSMV.
Baseado neste mapeamento foi desenvolvido um tradutor que aceita como entrada um conjunto de modelos SAN que possuem um determinado escopo de conceitos, explicados posteriormente.
Com os modelos resultantes desta tradução, é possível realizar verificações qualitativas através de propriedades CTL, sendo apresentado um contra exemplo caso tal propriedade seja falsa.
Este trabalho está estruturado da seguinte forma:
São apresentados os conceitos da linguagem SAN no capítulo 2;
a ferramenta NuSMV e alguns conceitos de sua linguagem são abordados no capítulo 3;
em seguida, no capítulo 4 é explicado o mapeamento de alguns dos conceitos SAN para a linguagem do NuSMV, a estrutura geral de um código gerado para o NuSMV, a exemplificação da tradução de um modelo SAN, a tradução das operações SAN, o algoritmo de tradução de expressões SAN;
Em o capítulo 5 é explicado o conceito de CTL, os seus operadores, sua sintaxe e a aplicação de propriedades CTL sobre modelos SAN;
Em o sexto capítulo é apresentado exemplos completos da tradução de modelos SAN para a linguagem do NuSMV assim como avaliações qualitativas sobre os modelos traduzidos;
Em o capítulo 7 é apresentada uma discussão sobre a corretude do tradutor SAN;
Em o oitavo capítulo é apresentado brevemente o processo que foi utilizado para o desenvolvimento do tradutor;
E por fim é apresentado os trabalhos relacionados e a conclusão do trabalho, nos capítulos 9 e 10, respectivamente.
De acordo com Fernandes e Plateau, SAN possibilita a descrição de modelos de sistemas com o objetivo de avaliar seu desempenho.
A o representar um sistema, SAN permite a descrição deste sistema através de um conjunto de subsistemas, onde cada subsistema é modelado por um autômato estocástico, e por a interação de eles entre si.
O autômato estocástico é constituído por estados e transições, que são as mudanças do estado atual, ocasionadas por eventos locais ou sincronizantes.
Os eventos modelam fenômenos aleatórios da realidade em questão, por exemplo, o tempo de serviço de um servidor, o intervalo de tempo entre as chegadas à fila 1.
Eles disparam transições, que mudam o estado de um ou mais autômatos.
Os eventos locais disparam uma transição em apenas um autômato, já os sincronizantes são responsáveis por transições simultâneas em todos os autômatos onde constam mais de um autômato, representando uma importante forma de comunicação entre autômatos.
Cada evento possui uma taxa de ocorrência, sendo um valor numérico ou o retorno de uma função.
Funções avaliam sobre o estado global da rede, retornando um valor.
Assim, um evento de um autômato pode ter uma taxa descrita por uma função cuja avaliação depende de outros autômatos, representando outra forma de comunicação ou dependência entre autômatos.
SAN possui operadores próprios de sua linguagem, tais como:
St, nb e rw.
A lista completa pode ser consultada em.
O operador st é aplicado sobre um autômato retornando o estado em que tal autômato se encontra.
A fim de saber quantos autômatos no modelo se encontram em determinado estado, é utilizado o operador nb informando o estado desejado.
O operador rw é aplicado sobre um autômato retornando o valor de reward que o estado atual daquele autômato possui.
As funções em SAN possuem grande capacidade de representação, sendo possível juntar operações de diferentes tipos na mesma expressão, como por exemplo, efetuar uma operação matemática com o resultado de uma operação lógica ao resultado de uma expressão SAN.
Elas podem avaliar o estado do modelo SAN, ou seja, expressões que dado um estado global avaliam e retornam um valor.
Um autômato pode possuir em sua especificação um número de replicações do autômato ou de um determinado estado, provendo à modelagem uma capacidade de representação poderosa, pois não será necessário reescrever todo o autômato ou um determinado estado diversas vezes, mas apenas indicar o número de vezes a ser replicado.
A o estado de um autômato é possível atribuir um valor numérico de reward, que é utilizado por o operador rw.
Caso não seja atribuído um valor de reward a algum estado, este assume um valor sequencial, de acordo com a ordem da listagem deste estado dentro de o autômato.
A o modelar uma realidade em SAN é necessário informar os estados atingíveis, sendo possível determinar todos os estados atingíveis ou apenas parte de eles através da função de alcançabilidade reachability ou alcançabilidade parcial partial reachability, respectivamente.
Dado um estado do espaço de estados produto, a função de alcançabilidade retorna verdadeiro ou falso caso o estado seja respectivamente alcançável ou não.
A função de alcançabilidade parcial retorna verdadeiro somente para um subconjunto dos estados alcançáveis por o modelo.
A o utilizar a seção partial reachability, o PEPS (Performance Evaluation Of Parallel Systems), ferramenta que avalia os modelos SAN, descobre os outros estados atingíveis a partir de o conjunto de estados definidos nesta seção.
Modelo SAN ­ Jantar dos Filósofos O Modelo SAN apresentado nesta seção representa o problema do jantar dos filósofos, modelado com quatro filósofos.
Este modelo foi retirado de.
Este modelo apresenta quatro autômatos, respectivos a cada filósofo:
P0, P1, P2 e P3.
Todos os autômatos deste modelo possuem os mesmos estados:
Thinking, Right e Left.
Entretanto alguns possuem transições diferentes e todas as transições são originadas por eventos diferentes.
Abaixo é apresentada a descrição textual deste modelo.
O NuSMV é um verificador simbólico de modelos (Symbolic Model Checker) desenvolvido a partir de a reestruturação da ferramenta SMV (Symbolic Model Verifier), o verificador original que utiliza o conceito de BDD (Binary Decision Diagrams) para efetuar a verificação de propriedades de lógica temporal CTL.
O NuSMV foi desenvolvido em parceria por as seguintes instituições:
Carnegie Mellon University (CMU), Instituto per la Ricerca Scientifica e Tecnologica (IRST), Linguagem do NuSMV Em esta seção são apresentados os principais conceitos da linguagem do NuSMV, com base no &quot;NuSMV 2.5 «e no &quot;NuSMV 2.5».
Um modelo na linguagem do NuSMV possui um ou mais módulos, sendo o módulo main obrigatório.
Cada módulo possui algumas seções especiais, tais como:
VAR, INIT, TRANS, Define, CTLSPEC, entre outras que não estão no escopo deste trabalho.
A declaração de variáveis dentro de um módulo é realizada dentro de a seção VAR.
Cada variável possui um nome e um tipo, seguindo a seguinte estrutura inteiros, enumeradores, array, módulos, entre outros.
Uma variável do tipo enumerador é composta por valores numéricos inteiros ou simbólicos, ou por alguns exemplos de valores possíveis do tipo enumerador.
&quot;var1 $= valor1&amp; var2 $= valor2&amp; var3 $= valor3 «é um exemplo que pode ser utilizado na seção INIT para determinar os valores iniciais de três das variáveis de um determinado modelo.
As transições de um modelo são descritas na seção TRANS através de do modelo.
A fim de verificar o próximo estado de uma determinada variável é utilizado o operador next da seguinte forma next (variavel) $= valor.
Desta forma a expressão &quot;var1 $= valor1&amp; next $= valor2 «descreve a transição do valor valor1 da variável var1 para o valor2.
A fim de utilizar a mesma expressão em diversos lugares do modelo atribui- se esta expressão a um identificador, que representa a expressão associada a ele, podendo ser utilizado quantas vezes forem necessárias descrendo a expressão somente uma vez.
Esta atribuição de expressão a um identificador é o conceito de um define, os quais são descritos na seção Define do módulo.
Os defines são avaliados em tempo de execução, portanto, eles não possuem um tipo de retorno fixo como as variáveis.
Assim como diversas linguagens de programação, a linguagem do NuSMV possui a expressão chamada If-Then-Else ou operador ternário.
Sua estrutura é representada da seguinte forma &quot;ExpressãoDeCondição ? Valor1 : Valor2».
Após avaliar o valor de ExpressãoDeCondição, esta expressão ternária retorna o Valor1 caso ExpressãoDeCondição for verdadeiro e em caso contrário retorna o Valor2.
A seção CTLSPEC serve para especificar as propriedades em lógica temporal CTL que realizam uma análise qualitativa do modelo.
A o verificar as propriedades CTL do modelo, caso alguma de elas não for verdadeira é apresentado por o NuSMV um contra exemplo.
Além de o módulo main, é possível criar outros módulos que possuam as mesmas seções anteriormente explicadas.
A o criar uma instância de um módulo é encapsulada toda a descrição do módulo ­ variável, defines, transições e outras características ­ e é criado um novo contexto para esta instância, não existindo conflito na estrutura de dados de duas instâncias diferentes.
Para instanciar um módulo, basta criar uma variável do tipo daquele módulo, conforme anteriormente explicado.
É possível acessar as variáveis e defines que uma instância de módulo possui através do operador». «(
ponto) para entrar no contexto daquela instância.
Por exemplo, dado um módulo X que possui a variável V e a instância A deste módulo, é possível acessar a variável V da seguinte forma &quot;A_ V».
Em o exemplo abaixo, retirado de, é possível verificar o uso de alguns dos conceitos acima explicados.
De acordo com a seção TRANS do módulo inverter o valor da variável output será a negação de input ou permanecerá o mesmo, sendo esta escolha não determinística.
O módulo inverter poderia ser escrito da forma apresentada abaixo, criando dois defines que possuem as expressões que estavam na seção TRANS.
Estes dois novos defines ­ changeOutputValue e unchanged ­ são utilizados na seção TRANS.
Desta forma o sentido semântico das transições deste módulo continua o mesmo, pois ao executar tais defines as expressões que eles contêm serão avaliadas.
A primeira versão do NuSMV foi atualizado em três dimensões, em relação a a ferramenta SMV.
De a perspectiva de funcionalidades do sistema, o NuSMV possui algumas funcionalidades a mais que aumentam a habilidade do usuário interagir com a ferramenta, além de prover heurísticas adicionais, como por exemplo, para alcançar a eficiência ou parcialmente controlar a explosão de estados.
A arquitetura do NuSMV é altamente modular e aberta, permitindo não somente a adição, substituição e edição de módulos como também a ordenação de execução de alguns dos módulos do sistema.
A terceira dimensão das atualizações é a qualidade do código, que além de ter aumentado existe uma documentação bem robusta, sendo considerado, por seus criadores, relativamente fácil de modificar.
A segunda versão do NuSMV contém adicionalmente a integração de técnicas proposicionais de satisfatibilidade (SAT).
BDD e SAT geralmente solucionam diferentes categorias de problemas de verificação de modelos, tornando assim o NuSMV uma ferramenta eficiente, pois possuem técnicas complementares.
O NuSMV permite a representação de modelos síncronos e assíncronos através de um conjunto de estados finitos, bem como suporta análise de propriedades expressas em CTL e LTL.
Além de isto, a licença da ferramenta foi modificada para ser OpenSource, permitindo que qualquer indivíduo possa utilizar livremente a ferramenta e participar no desenvolvido de ela.
Em a primeira parte desta seção são comparados conceitos análogos de SAN e NuSMV, indicando a estratégia da tradução, na segunda parte é apresentada e discutida a estrutura geral de um modelo traduzido, na terceira parte é detalhado e exemplificado cada uma das equivalências, na quarta parte é apresentado a tradução das operações SAN e por último é explicado o algoritmo de tradução de expressões SAN.
Conceitos Análogos Antes de detalhar o mapeamento feito entre SAN e a linguagem do NuSMV é necessário comparar os principais conceitos das linguagens.
A tabela abaixo apresenta as principais equivalências que as linguagens possuem.
Ambas as linguagens servem para a construção de modelos com um conjunto finito de estados.
Também ambas linguagens possuem abstrações para estruturar modelos, seja como autômato em SAN ou módulo na linguagem do NuSMV.
Outro aspecto que vale ressaltar é a possibilidade de representar explicitamente transições de estado.
Em SAN cada autômato tem transições e em alguns casos uma transição do modelo é dada por a composição de transições de autômatos que sincronizam no mesmo evento.
Em o NuSMV transições entre estados anterior e posterior podem ser explicitamente declaradas considerando estados de diferentes módulos.
O conceito de estados atingíveis é bastante peculiar de SAN, não se encontrando análogo em diversas outras linguagens.
SAN também permite a definição de um subconjunto de estados atingíveis (atingibilidade parcial).
O conceito mais próximo no NuSMV é o de estados iniciais.
Considerando- se estados iniciais como atingíveis, se uma declaração de estados iniciais do NuSMV especificar o mesmo conjunto de estados da declaração de atingibilidade parcial de SAN, então este conceito pode ser mapeado.
Como será visto em mais detalhe, é possível mapear uma declaração de atingibilidade numa declaração de estados iniciais no NuSMV.
SAN possui o conceito de autômatos e cada um de eles tem um conjunto de estados.
A estrutura considerada análoga em NuSMV é a do módulo.
Assim, cada autômato é representado num módulo.
Cada módulo tem uma variável de estado.
O intervalo de valores possível desta variável de estado cobre exatamente os estados possíveis do autômato.
A mudança de estados em SAN pode ser local, afetando apenas um autômato, ou sincronizante, afetando mais de um autômato.
Para representar estas possibilidades, especialmente a mudança simultânea de estado em mais de um autômato (módulo), optou- se por o uso da seção TRANS.
Em a seção TRANS especifica- se logicamente estados atuais e próximos estados possíveis, levando em consideração os eventos, suas probabilidades e taxas, sejam estas funcionais ou não.
Para eventos locais deriva- se as possíveis mudanças de estado de um autômato de forma direta a partir de a estrutura do autômato.
Dado um estado atual (verdade) e um evento habilitado (verdade), existe um próximo estado definido.
O não determinismo do NuSMV auxilia no caso onde um evento pode levar a mais de um estado, assim como no caso de mais de um evento habilitado.
Para eventos sincronizantes cuida- se para que todos autômatos que tenham um dado evento sincronizante habilitado em sua estrutura, que o evento sincronizante realize uma mudança de estado em cada um destes autômatos.
Em um dado autômato, um evento pode gerar diferentes mudanças de estado.
Assim, um evento sincronizante no NuSMV, utilizando a seção TRANS, se traduz numa conjunção entre as possibilidades de mudanças de estado de cada autômato que usa o evento considerado, onde cada possibilidade em cada autômato é dada por uma disjunção de condições que representam ocorrência de um evento num autômato.
Existem três tipos de operadores, que compõem expressões, em SAN:
Lógicos, matemáticos e operadores da linguagem SAN.
Os mesmos operadores lógicos e matemáticos existem na linguagem do NuSMV.
Já os operadores específicos da linguagem SAN, apesar de não existirem na linguagem do NuSMV, podem ser mapeados facilmente através da construção de macros que avaliam o estado da rede.
Os operadores SAN mapeados são:
St, nb e rw.
O operador st é diretamente representado por o acesso do valor da variável de estado de uma instancia de um módulo.
O operador nb é representado por uma expressão que verifica o estado atual de todos os módulos do modelo, somando numa unidade no valor que irá retornar para cada módulo em que se encontrar no estado determinado, ou seja, é uma soma de condições, havendo uma condição para cada módulo do modelo, onde cada condição retorna o valor numérico &quot;1 «quando o valor do estado atual do módulo for o valor verificado.
O operador rw é representado por uma expressão que verifica o estado atual do módulo e retorna o valor de reward associado ao estado atual.
O mapeamento do valor de reward é retirado da estrutura do autômato e caso não exista um valor associado é atribuído um valor numérico sequencial para cada estado que não possua o reward conforme a definição de SAN segundo a página 6 do manual do Em SAN, diferentemente da linguagem do NuSMV, os operadores lógicos e argumentos.
Além de isto, SAN possui uma peculiaridade:
A precedência implícita de uma expressão é sempre da esquerda para a direita, diferentemente da precedência comum matemática e lógica.
Para especificar em SAN qualquer outra precedência diferente da esquerda para a direita é necessário o uso dos parênteses.
Desta forma, foi necessário realizar um algoritmo de tradução de expressões SAN para a linguagem do NuSMV, o qual será explicado posteriormente.
Estrutura geral do código gerado por o tradutor para o NuSMV O código gerado por o tradutor para o NuSMV tem a seguinte estrutura:
A primeira parte do código é constituída por módulos, respectivos a cada autômato.
Em a segunda parte do código, o módulo main é definido, sendo composto por quatro seções:
VAR, INIT, TRANS e Define.
A primeira seção do módulo main, a VAR, é constituída por uma instância para cada módulo existente diferente do módulo main.
Cada uma destas instâncias é guardada por uma variável, sendo que os nomes destas variáveis seguem uma regra de formação que utiliza o do autômato correspondente.
A terceira seção do módulo main, a TRANS, é composta por uma disjunção de defines (entradas na seção define) que determinam as transições locais e sincronizantes do modelo.
Desta forma, a cada mudança de estado acontece uma transição local num autômato ou uma composição de transições locais de autômatos, rotuladas com mesmo evento sincronizante, que representam apenas uma transição no estado global do modelo.
A última seção, a Define, é composta por diversos defines, sendo que cada um de eles possui um nome e uma expressão.
Um define serve como uma macro de programação funcionando por a simples busca e substituição textual do seu conteúdo, que no caso de o define é uma expressão.
Portanto, se uma determinada expressão é utilizada mais de uma vez no modelo, pode ser descrita num define a fim de ser reutilizada quantas vezes forem necessárias, bastando utilizar o nome do define.
Visto que identificadores e eventos são conceitos de SAN que também são utilizados em mais de um lugar no modelo, tais conceitos são mapeados para o conceito de identificadores define.
Detalhamento da tradução e exemplificação O conjunto de modelos SAN possíveis é determinado por as regras de sintaxe em.
Este trabalho não mapeou os seguintes conceitos de SAN, significando que um subconjunto de modelos SAN, os quais não utilizam tais conceitos, são aceitos para o processo de tradução:
State, prod_ rw e prod_ rw state.
O único tipo numérico que o NuSMV contempla é o inteiro, por isso os números reais não estão mapeados.
Portanto é necessário ajustar os modelos SAN a fim de remover quaisquer valores numéricos que não sejam inteiros antes de utilizar o tradutor.
Os demais conceitos não foram mapeados por questões temporais.
Deve- se notar que esta limitação não invalida a demonstração de possibilidade de mapear modelos SAN para o NuSMV uma vez que todo modelo SAN com replicação pode ser convertido para um modelo SAN sem utilizar estruturas de replicação.
A gramática aceita por o tradutor SAN para a linguagem do NuSMV encontra- se no apêndice A. A seguir é detalhada a tradução de um modelo SAN para outro aceito por o NuSMV, seguindo a estrutura de um código gerado para o NuSMV apresentada na figura 2.
Todos os trechos de código SAN utilizados para a exemplificação abaixo são baseadas na tradução do modelo do jantar dos filósofos, retirado de.
A maior parte dos trechos são retirados do modelo phil04c.
San e alguns do modelo phil04f.
San. Ambos os modelos descrevem o jantar dos filósofos ­ modelados com quatro filósofos, entretanto o primeiro utiliza eventos sincronizantes e o segundo possui eventos com taxas funcionais.
Utilizando estes dois modelos como base para detalhamento da tradução e exemplificação, é possível cobrir todos os conceitos mapeados de SAN para a linguagem do NuSMV.
Cada autômato é representado por um módulo.
Este módulo possui a variável de estado state do tipo enumerador, onde são especificados todos os estados que o autômato que originou o módulo pode assumir.
Cada valor do enumerador state ­ que representa o nome de um estado ­ é constituído do prefixo &quot;s «seguido do nome do estado.
O nome do módulo possui o prefixo &quot;ad «­ automata definition ­ seguido do nome do autômato.
Além de esta variável, o módulo é composto por um atual do módulo é igual ao próximo estado do módulo na próxima transição de estado global do modelo.
Este define é amplamente utilizado nos defines do módulo main para determinar as transições locais e sincronizantes, explicadas nesta seção posteriormente.
Por exemplo, tome- se a definição SAN abaixo:
Aut P0 stt Thinking to stt Right to stt Left te o (Right) (Thinking) (Left) (Right) (Thinking) t_ r _0 r_ l_ 1 l_ r_ 3 r_ l _0 l_ r_ 3 l_ t _0 O autômato acima P0 resulta no módulo P0 abaixo:
A seção VAR do módulo main, possui uma instância para cada módulo anteriormente definido.
Desta forma, considerando existentes os módulos ad_ P0, ad_ P1, ad_ P2 e ad_ P3, esta seção resulta no exemplo abaixo, onde as instâncias destes módulos são a_ P0, a_ P1, a_ P2 e a_ P3 respectivamente:
Caso haja mais de um estado inicial válido o NuSMV escolherá, não deterministicamente um destes estados iniciais.
Considerando a expressão reachability acima, onde P é um identificador com um valor numérico, a seção INIT resultante se encontra abaixo.
Em este exemplo, esta expressão na seção INIT significa que qualquer estado global inicial do modelo que possuir o número P de autômatos no estado Thinking é um estado inicial válido.
INIT (nb_ Thinking $= P) A tradução e exemplificação dos operadores SAN que este trabalho aborda ­ st, nb e rw ­ serão detalhados posteriormente.
A seção TRANS é descrita por a composição da disjunção de defines que determinam as transições locais ­ um define para cada módulo que possuir pelo menos uma transição local ­ e sincronizantes ­ caso o modelo tenha pelo menos uma transição sincronizante.
Em este exemplo a seção TRANS utiliza cinco defines:
Quatro referentes aos módulos determinando transições locais e um define referente a todas as transições sincronizantes do modelo.
Como cada um destes defines são mutuamente exclusivos, como veremos adiante, e estão ligados por uma disjunção, consequentemente apenas uma destas transições ocorrerá em cada mudança de estados do modelo.
Note- se que na linguagem do NuSMV as possíveis transições de estado são definidas como relações entre estado atual e próximo estado.
Assim, como num dado momento somente uma transição pode acontecer, segundo a semântica de SAN, então esta relação que leva em conta estado atual e estado posterior tem somente uma transição aplicável.
Isto não significa que o não determinismo dos modelos SAN não está representado, pois tomando em consideração somente o estado atual, sem considerar o próximo estado, a tradução para a linguagem do NuSMV cobre todas possíveis transições para próximos estados desdobrando cada um dos casos possíveis.
A explicação da tradução das operações SAN e do algoritmo de tradução de expressões SAN serão explicados nas seções 4.4 e 4.5 respectivamente.
Em a seção Define são representados os conceitos de:
Identificadores, eventos, transições locais e sincronizantes.
Cada identificador do modelo SAN possui um nome e uma expressão associada.
Cada identificador é mapeado num define, o qual também possui o mesmo nome, acompanhado do prefixo &quot;i», e a expressão traduzida para a linguagem do NuSMV.
As expressões dos identificadores são sempre traduzidas para retornarem um valor numérico, a fim de manterem um padrão entre os defines que mapeiam os identificadores.
Os dois identificadores acima são traduzidos nos seguintes defines, ambos retornando valores numéricos:
Os eventos do modelo SAN possuem um nome, uma taxa, e um tipo ­ local ou sincronizante ­ e são representados por defines.
O nome do define é o mesmo utilizado por o evento acompanhado do prefixo &quot;e «e a expressão deste define é sempre estruturada de uma verificação ­ se a taxa do evento é superior a zero, indiferentemente se a sua taxa é uma valor numérico ou um identificador ­ ou seja, como explicado anteriormente, traduzido num define que sempre retorna um valor numérico, desta forma é possível estruturar desta maneira a tradução de todos os eventos, não existindo construção de expressões inválidas na linguagem do NuSMV.&amp;&amp;&amp;
Os eventos acima são traduzidos nos seguintes defines:
Para cada módulo que possuir pelo menos uma transição local existe um define que descreve todas as possíveis transições locais deste módulo.
Este define possui o seu nome composto do prefixo &quot;local_ step «concatenado ao nome do módulo em o qual as transições locais estão sendo descritas.
Em o exemplo abaixo, é possível verificar apenas uma transição local do módulo ad_ P0 descrita no define chamado local_ step_ ad_ P0, pois as outras transições deste módulo são sincronizantes.
Caso houvesse mais de uma transição local para este módulo, esta conjunção apresentada abaixo, que descreve apenas uma transição local, estaria ligada através de uma disjunção a outras conjunções, que descreveriam as outras transições deste módulo.
Esta transição local é referente a a mudança do estado s_ Left para o s_ Thinking.
Esta transição está sendo ocasionada por o evento local l_ t _0.
Conforme explicado anteriormente, o define e_ l_ t _0 que representa o evento l_ t _0 sempre Este define chamado local_ step_ ad_ P0 determina apenas as transições locais do módulo ad_ P0 e não representa uma mudança de estados global do modelo.
Por isso é criado outro define, para cada define que determina todos as transições locais de um determinado módulo.
Este outro define é composto por uma conjunção entre os defines unchanged de todos os outros módulos do modelo e o define que determina todas as transições locais de um determinado módulo.
Desta forma é possível descrever mudanças de estado globais e, consequentemente, utilizar tal define na seção TRANS.
Para todo modelo que possuir pelo menos um evento sincronizante, existe o define chamado synchronized_ steps que possui a descrição de todas as transições ocasionadas por eventos sincronizantes do modelo.
Tais transições são descritas através de uma conjunção entre as possibilidades de mudanças de estado de cada autômato usando o evento considerado, sendo estas uma disjunção de condições das aplicações do evento no autômato.
Considerando as transições do modelo phil04c.
San, o exemplo abaixo mostra apenas uma porção do define synchronized_ steps apresentando as possíveis transições resultantes obtidas somente a partir de os eventos sincronizantes t_ r _0 e r_ l _0.
Vale ressaltar que uma transição em SAN pode especificar o próximo estado igual ao estado anterior num determinado autômato.
Em o exemplo acima são apresentadas quatro possíveis mudanças de estados globais, sendo duas através do evento e_ t_ r _0 e as outras por o evento e_ r_ l _0.
A primeira, ocasionada por o evento e_ t_ r _0, a instância a_ P0 do módulo ad_ P0 transiciona do estado s_ Thinking para s_ Right, a instância a_ P1 do módulo ad_ P1 transiciona do estado s_ Thinking para s_ Thinking e as instâncias a_ P2 e a_ P3 permanecem no mesmo estado (utilização do define unchanged).
A segunda, ocasionada por o evento e_ t_ r _0, a instância a_ P0 transiciona do estado s_ Thinking para s_ Right, a instância a_ P1 transiciona do estado s_ Right para s_ Right e os as instâncias a_ P2 e a_ P3 permanecem no mesmo estado.
A terceira, ocasionada por o evento s_ r_ l _0, a instância a_ P0 transiciona do estado s_ Right para s_ Left, a instância a_ P3 transiciona do estado s_ Thinking para s_ Thinking e as instâncias a_ P1 e a_ P2 permanecem no mesmo estado.
A quarta, ocasionada por o evento e_ r_ l _0, a instância a_ P0 transiciona do estado s_ Right para s_ Left, a instância a_ P3 transiciona do estado s_ Left para s_ Left e as instâncias a_ P1 e a_ P2 permanecem no mesmo estado.
Tradução das operações SAN As operações SAN que foram mapeadas e traduzidas à linguagem do NuSMV são st, nb e rw.
O operador st é diretamente representado por o acesso do valor da variável de estado de uma instancia de um módulo.
Considerando a expressão SAN acima que verifica se o estado do autômato P1 é diferente do estado Left, a expressão traduzida resultante é:
Esta expressão na linguagem do NuSMV acessa o valor da variável state da instância a_ P1, que representa a instância do módulo ad_ P1, e verifica se o seu valor é diferente de s_ Left.
O operador nb é representado por uma expressão que verifica o estado atual de todos os módulos do modelo, somando numa unidade no valor que irá retornar para cada módulo em que se encontrar no estado determinado.
A expressão nb acima, que retorna um valor numérico referente a a quantidade de autômatos que se encontram no estado Thinking, é traduzida na seguinte expressão, considerando que o modelo possui as seguintes instâncias a_ P0, a_ P1, a_ P2 e a_ P3:
Esta representação é composta de verificações ternárias unidas por o operador da soma.
Desta forma é possível representar de forma correta o comportamento do operador nb de SAN.
O operador rw é representado por uma expressão que verifica o estado atual do módulo e retorna o valor de reward associado ao estado atual.
O mapeamento do valor de reward é retirado da estrutura do autômato e caso não exista um valor associado é atribuído um valor numérico sequencial para cada estado que não possua o reward, conforme a definição de SAN segundo o manual do PEPS 2003 apresentada na página 6.
A expressão que traduz o significado do operador rw é apresentada abaixo, considerando a aplicação do operador rw ao autômato P0 e que tal autômato possui os seguintes estados:
Thinking, Left e Right.
Essa expressão inicialmente verifica se o estado da instância a_ P0 é s_ Thinking, e em caso positivo retorna o valor de reward 0;
em caso negativo, ela realiza outra verificação:
Se o estado da instância a_ P0 é s_ Right, e em caso positivo retorna o valor de reward 1;
em caso negativo, ela realiza a terceira e última verificação:
Se o estado da instância a_ P0 é s_ Left, e em caso positivo retorna o valor de reward 2;
e em caso negativo retorna o valor 1, que não tem significado algum e nem é esperado que seja retornado tal valor, pois todos os estados do módulo ad_ P0 foram considerados e verificados, portanto não existe a possibilidade de tal instância não estar num dos estados verificados.
Algoritmo de tradução de expressões SAN A flexibilidade que SAN permite descrever uma expressão não é diretamente mapeada para a linguagem do NuSMV.
Tal flexibilidade permite que tanto os linguagem SAN.
A fim de representar uma expressão na linguagem do NuSMV que tenha o mesmo poder de expressão, como a descrita acima, foi necessário desenvolver um algoritmo que realizasse tal tradução.
Além deste objetivo, o algoritmo de tradução de expressões SAN para a linguagem do NuSMV também objetiva manter a precedência original da expressão SAN ­ visto que ambas as linguagens possuem conceitos de precedência diferentes.
Este algoritmo decompõe a expressão SAN de entrada, cria uma árvore binária que a representa e, a partir de ela, retorna uma expressão que é compatível a linguagem do NuSMV e que representa o significado da expressão de entrada.
A árvore correspondente àquela expressão SAN exemplificada é apresentada abaixo.
A tradução é realizada a partir de as folhas de maior profundidade desta árvore, verificando sempre qual o tipo dos argumentos que o operador necessita.
Caso o operador necessite de um argumento de um determinado tipo e pelo menos um de eles for de outro, é realizada a conversão de este (s) argumento (s) para possuir o é realizada, dentro de uma expressão, através de uma operação ternária.
Já a conversão inversa é realizada através de uma verificação ­ se o argumento é superior à zero.
Por exemplo, o operador\&gt; $= requer que ambos argumentos sejam do mesmo tipo, a fim de realizar a comparação.
Em este exemplo, ambos os argumentos são numéricos ­ valores &quot;2 «e &quot;3 «­ logo não há necessidade de conversão dos tipos dos argumentos.
Já no próximo caso o operador da soma necessita de dois argumentos e o outro um valor numérico ­ valor &quot;4».
Portanto, é necessário converter esta parte da expressão com o objetivo de manter o mesmo significado da expressão original e para a linguagem do NuSMV reconhecer como válida esta expressão.
A tradução da sub expressão &quot;resulta na seguinte expressão&quot;+ 4 «aceita por o NuSMV.
Continuando a traduzir esta árvore é verificado que o operador da conjunção exemplo, são numéricos, sendo necessário converter o tipo de ambos os na seguinte expressão&quot;+ 47\&gt; 0) «aceita por o NuSMV.
Seguindo este algoritmo até realizar por completa a tradução, aquela expressão utilizada como exemplo será traduzida para a linguagem do NuSMV na seguinte expressão.
CTL é uma lógica temporal que considera o conjunto de computações como uma estrutura ramificada, sendo o futuro não determinístico, a qual é suficientemente expressiva para formular um conjunto importante de propriedades de um sistema.
Cada uma destas ramificações representa uma das diversas possibilidades de estados futuros que existem a partir de um determinado estado do sistema.
Esta lógica foi originalmente definida por Clarke e Emerson e por Queille e Sifakis para realizar verificação de modelos.
Uma fórmula CTL é composta por proposições atômicas, operadores utilizadas para formalizar características do modelo e intuitivamente expressam fatos simples sobre o estado do sistema avaliado.
Há dois tipos de operadores CTL:
Operadores quantificadores:
O operador significa &quot;para todos os caminhos «(representado por o O operador significa &quot;existe pelo menos um caminho «(representado por &quot;E&quot;);
Operadores Temporais: O operador significa &quot;globalmente «(representado por &quot;G&quot;);
A sintaxe de uma fórmula CTL é apresentada abaixo.
Para mais informações sobre a sintaxe e sua semântica é possível verificar em.
Propriedades CTL sobre modelos SAN e suas traduções As propriedades CTL sobre um modelo SAN seguem a estrutura de uma propriedade CTL explicada anteriormente, com a única ressalva de que as proposições atômicas são descritas em SAN.
Tais proposições atômicas descritas em SAN seguem as regras de anteriormente apresentadas.
O mesmo ocorre para propriedades CTL sobre um modelo aceito por o NuSMV, conforme é possível verificar em, onde as proposições atômicas são, naturalmente, descritas na linguagem aceita por o NuSMV.
A fim de verificar uma propriedade CTL com o NuSMV num modelo traduzido é necessário seguir os seguintes passos:
Criar a propriedade CTL escrevendo as proposições atômicas em SAN;
Traduzir manualmente as proposições atômicas utilizando o mapeamento descrito na seção 4;
Adicionar uma seção CTLSPEC ­ para cada propriedade ­ no final do modelo traduzido juntamente com a propriedade CTL traduzida;
Executar o comando check_ ctlspec do NuSMV, após carregar modelo no NuSMV;
A tradução de dois modelos, retirados de, é apresentada abaixo em detalhes, bem como um conjunto de propriedades CTL para estes dois modelos.
Exemplos completos de tradução O modelo apresentado abaixo é resultado da tradução do modelo SAN apresentado na seção 2.1 e citado em diversas partes no capítulo 4.3.
Conforme explicado na seção 4 é necessário modificar os valores reais para que sejam valores inteiros.
Para realizar a tradução do modelo SAN da seção 2.1, é necessário alterar os valores de lambda e de mu para 1 e 2, respectivamente.
Abaixo está a tradução para a linguagem do NuSMV.
Module main (nb_ s_ Thinking $= i_ P) next_ local_ step_ ad_ P3| synchronized_ steps| next_ local_ step_ ad_ P2| next_ local_ step_ ad_ P1| next_ local_ step_ ad_ P0 a_ P3.
A cadeia de Markov equivalente ao modelo SAN apresentada abaixo foi obtida com através do San-Lite- Solver e do Graphviz.
O sistema de transição de estados do modelo traduzido para o NuSMV é apresentado por a imagem abaixo.
Esta imagem foi obtida através do algoritmo de caminhamento ­ que será explicado na seção 7 ­ juntamente com o Graphviz.
As taxas neste modelo não são relevantes visto que o NuSMV realiza uma análise qualitativa e não quantitativa.
Além deste exemplo completo de tradução, é possível verificar também a tradução de ad04f.
San. Este modelo foi utilizado no artigo.
Os comentários iniciais do modelo que informam como citar tal modelo foram retirados, como também a seção result.
Abaixo está a tradução para a linguagem do NuSMV do modelo acima:
Module main (nb_ s_ I $= 4) next_ local_ step_ ad_ MN_ 1| synchronized_ steps| next_ local_ step_ ad_ MN_ 2 a_ MN_ 1.
A cadeia de markov equivalente ao modelo SAN apresentada abaixo foi obtida com através do San-Lite- Solver e do Graphviz.
O sistema de transição de estados do modelo traduzido para o NuSMV é apresentado por a imagem abaixo.
Esta imagem foi obtida através do algoritmo de caminhamento ­ que será explicado na seção 7 ­ juntamente com o Graphviz.
As taxas neste modelo não são relevantes visto que o NuSMV realiza uma análise qualitativa e não quantitativa.
Avaliação qualitativa em modelos SAN Um conjunto de propriedades CTL foi desenvolvido para alguns modelos SAN a fim de realizar a análise qualitativa nos modelos equivalentes traduzidos.
Estas oito propriedades foram desenvolvidas para o modelo phil3.
San. Tais propriedades também foram executadas para modelos maiores, que modelam o mesmo problema do jantar dos filósofos, presentes na tabela 4.
As primeiras três propriedades possuem significado, já as demais foram desenvolvidas apenas para verificar o contra exemplo e testemunhas gerado por o NuSMV.
A primeira propriedade assegura que existe algum caminho onde o filósofo 0 sempre quer comer.
Esta propriedade também é verdadeira para todos os outros filósofos do modelo.
A segunda propriedade significa que enquanto o filósofo 0 está comendo os demais não estão.
Esta propriedade, da mesma forma que a primeira, também é verdadeira para os demais filósofos do modelo.
A terceira verifica se globalmente o filósofo 1 quer comer.
A fim de verificar estas propriedades com o NuSMV é necessário traduzir as proposições atômicas, que estão descritas em SAN, de forma que sejam compatíveis com a linguagem do NuSMV e com o modelo traduzido, conforme explicado na seção 5.1.
Em o NuSMV não é possível criar uma testemunha no NuSMV para uma propriedade CTL verdadeira.
Portanto a fim de obter uma testemunha para cada propriedade verdadeira, cada propriedade verdadeira foi negada ao ser verificada por o NuSMV.
Desta forma, foi possível obter um contra exemplo da negação de uma propriedade verdadeira, sendo equivalente a uma testemunha da propriedade verdadeira.
Abaixo é apresentado:
A tradução de cada uma das oito propriedades acima, bem como o contra exemplo ou testemunha de cada propriedade.
A primeira propriedade significa que para todos os caminhos no modelo sempre que ocorrer uma transmissão do nodo Mn_ 1 no futuro o nodo Mn_ 10 vai receber- la.
A segunda possui o mesmo significado da primeira com a única diferença que nesta ao gerar a testemunha apresenta um caminho onde um envio do nodo Mn_ 1 é recebido por o nodo Mn_ 10.
A terceira propriedade assegura que o nodo Mn_ 10 não receberá a transmissão até que ocorra uma transmissão do nodo A tradução destas três propriedades segue abaixo juntamente com os contra exemplos e testemunhas.
San foi desenvolvido a propriedade abaixo a fim de obter a sua testemunha.
Esta propriedade também foi executada para modelos maiores, que modelam o mesmo problema da linha de produção, presentes na tabela 4.
A tradução desta propriedade segue abaixo juntamente com sua testemunha.
Testemunha ­ contra exemplo da negação ­ desta propriedade é a mesma apresentada na quinta propriedade desta lista;
State $= s_ st_ 1.2 A argumentação de corretude da tradução acontece idealmente através de uma prova de que esta tradução está correta.
Para um exemplo de complexidade de tal prova, tome- se onde se demonstra que uma tradução de Gramática de Grafos para PROMELA é correta.
Devido a tal complexidade, uma prova de corretude da tradução não faz parte do escopo deste trabalho e se constitui trabalho futuro.
Entretanto, este trabalho reúne fortes indicativos da corretude da tradução proposta.
Estes indicativos se dão com base na experimentação de traduções de dezessete modelos.
Para todas estas traduções observou- se que o sistema de transição de estados definido por o modelo SAN (a Cadeia de Markov equivalente, desprezando- se informação quantitativa) tem a mesma topologia do sistema de transição de estados gerado por o modelo NuSMV.
A seguir, detalham- se estes experimentos.
Foram traduzidos quatro tipos de modelos:
O jantar dos filósofos, o protocolo de rede de sensor sem fio, linha de produção e o primeiro servidor disponível.
A partir destes quatro tipos foram derivados dezessete modelos SAN os quais foram todos traduzidos para modelos aceitos por o NuSMV.
A fim de verificar similaridade entre os modelos, foram verificadas as seguintes características dos modelos de entrada e de saída do tradutor:
A quantidade de estados totais, a quantidade de estados atingíveis e o número de transições.
O primeiro tipo de modelo descreve o problema do jantar dos filósofos.
Foram traduzidos sete derivações deste modelo, variando a quantidade de filósofos para cada modelo (philXX, onde XX é o número de filósofos) ou a sua estrutura interna.
De as sete variações, apenas dois modelos variam sua estrutura interna mantendo o mesmo número de filósofos ­ phil04f e phil04c, ou seja, um utiliza apenas eventos locais enquanto o outro utiliza, além de eventos locais, eventos sincronizantes O segundo tipo de modelo descreve um protocolo de uma rede de sensor sem fio (adXX, onde XX é o número de nodos).
Foram traduzidos três modelos derivados, sendo duas de elas com modificações no valor de identificadores e uma com um aumento no número de nodos.
O modelo da linha de produção é o terceiro tipo, variando apenas o número de estações em cada modelo (plXX, onde XX é o número de estações).
Foram traduzidos três variações deste modelo.
O modelo de primeiro servidor disponível é o quarto tipo, variando apenas o número de servidores em cada modelo (fasXXc, onde XX é o número de servidores).
Foram traduzidos quatro variações deste modelo.
Em a tabela abaixo é possível verificar as características coletadas de cada modelo.
As informações de estados totais e atingíveis dos modelos para o NuSMV foram obtidas através do comando print_ reachable_ states, o qual informa os valores de forma precisa até «107 ­ 1.
Qualquer valor que seja superior a este limite de precisão, o valor é informado em notação científica com cinco números após a vírgula.
Por isso os modelos Phil15, Phil20 e Pl10 apresentam as diferenças grifadas acima.
Por exemplo, o valor informado por o NuSMV de estados totais do modelo Phil20 é 3,48678 e+ 009.
Devido a o tamanho dos modelos, os resultados da quantidade de transições estão ainda sendo coletados. (
Nota a ser removida para homologação) Através do NuSMV não é possível obter o número de transições que determinado modelo possui, entretanto é possível realizar através de ele um caminhamento no modelo de forma interativa, ou seja, a partir de um estado atual o NuSMV mostra as próximas possibilidades de estados atingíveis permitindo que o usuário escolha o próximo estado.
Por isso foi necessário desenvolver um algoritmo que interagisse com o NuSMV a fim de explorar todas as possibilidades de transições que um modelo possui.
Através deste algoritmo de caminhamento é possível obter o sistema de transição completo gerado por o modelo, em o qual é consta o número exato de estados atingíveis bem como o número de transições.
Utilizando o Graphviz é possível criar uma imagem do sistema de transição a partir de as informações que o algoritmo de caminhamento retorna.
Desta forma é possível comparar a topológica da cadeia de Markov de um determinado modelo SAN com o sistema de transição da tradução deste modelo SAN, conforme é possível visualizar na seção 6.1, bem como nos apêndices B, C, D, E, F, G, H e I. Em todos estes exemplos a topologia de ambos é igual, tornando- se, cada uma destas comparações, mais um indício da corretude do mapeamento de conceitos e do tradutor desenvolvido.
Para desenvolver o tradutor da linguagem SAN para a linguagem do NuSMV foi utilizado duas ferramentas:
Um analisador léxico e um analisador sintático.
Considerando que a estrutura de dados interna do tratutor foi modelada para utilizarse do paradigma de programação orientado a objetos, foi escolhido as seguintes ferramentas para desenvolver o tradutor:
JFlex e o BYACC/ J, sendo o analisador léxico e o sintático respectivamente, pois ambos geram código em Java.
O processo utilizado de desenvolvimento do tradutor foi:
Criar um arquivo que contenha as regras léxicas de SAN ­ utilizado por o JFlex;
Criar um arquivo que contenha as regras sintáticas de SAN, bem como o código que contém a lógica do mapeamento de conceitos ­ utilizado por o Após criar tais arquivos, basta executar o JFlex e o BYACC/ J, informando os arquivos descritos acima, a fim de obter as classes em Java que, ao serem compiladas, constituem o tradutor SAN.
Conforme já citado na seção 4.3 a gramática aceita por o tradutor desenvolvido encontra- se no apêndice A. A tradução de expressões CTL dentro de um modelo SAN não é contemplado por o tradutor, de forma que a fim de aplicar alguma propriedade CTL no modelo traduzido deve- se seguir o procedimento explicado na seção 6.2.
Diversos formalismos para avaliação de desempenho contam com a possibilidade de Model Checking, como é o caso de Redes de Petri, Álgebra de Processos, e Cadeias de Markov.
Até o momento, além deste trabalho, apenas uma abordagem para verificação de Redes de Autômatos Estocásticos foi proposta, apresentando a primeira versão de um verificador de modelos construído para SAN que faz uso de técnicas de verificação simbólica para propriedades escritas em CTL.
Contudo, trata- se da primeira versão de um verificador, faltando a geração de contra exemplos.
A vantagem de utilizar o tradutor de SAN para a linguagem de entrada do NuSMV proposto por este trabalho, frente a um novo verificador próprio para SAN, é que parte- se da qualidade e do desempenho de duas décadas de experiências com este ambiente mantido por um grupo de universidades.
Diversos trabalhos realizaram o mapeamento e tradução de uma determinada linguagem para a linguagem do NuSMV, de entre eles estão.
O trabalho além de realizar a tradução de Redes de Petri para a linguagem do NuSMV, traduz diagramas de atividades da UML 2.
0 para um modelo de Redes de Petri.
Desta forma, através do é possível modelar um determinado sistema em mais alto nível através da UML ou especificar- lo diretamente em Redes de Petri para realizar análises qualitativas sobre o modelo traduzido para a linguagem do NuSMV.
Já o trabalho realiza o mapeamento entre Redes de Petri Temporais para a linguagem do NuSMV avaliando qualitativamente através de propriedades descritas em Real Time Computational Tree Logic (RTCTL).
O mapeamento de Abstract State Machines (ASM) para a linguagem do NuSMV é realizado por alguns trabalhos através de abordagens diferenciadas.
O trabalho apresenta uma destas abordagens e realiza um comparativo com as outras abordagens existentes.
Diferentemente dos outros trabalhos anteriormente citados, o trabalho traduz Promela, linguagem de entrada do model checker SPIN, para a linguagem do NuSMV.
Desta forma é possível especificar um sistema descrito em Promela, considerada uma linguagem de mais alto nível do que a do NuSMV, e obter possibilidade de realizar análises qualitativas através de propriedades CTL, visto que o SPIN apenas suporta o LTL.
Este trabalho apresenta um tradutor de modelos em Redes de Autômatos Estocásticos para modelos descritos na linguagem de entrada do NuSMV.
como se evidência, cria- se a possibilidade de raciocinar sobre comportamentos de modelos SAN de forma iterativa, usando lógica temporal.
Enquanto a análise quantitativa de permite derivar probabilidades de estados globais destes modelos, com Model Checking cria- se a possibilidade de avaliar os comportamentos dos mesmos.
Os indicativos de corretude do tradutor são apresentados na seção 7, mostrando para 17 modelos com características diferentes que a tradução de SAN para NuSMV gera modelos com semântica equivalente (mesmos sistemas de transição de estados).
Como afirmado na Seção 7, em trabalho futuro deve- se demonstrar formalmente a corretude da tradução apresentada.
