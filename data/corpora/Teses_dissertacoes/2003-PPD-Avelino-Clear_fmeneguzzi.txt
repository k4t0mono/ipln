A maioria das implementações de agentes BDI realiza o processo de raciocínio meios-fim utilizando bibliotecas de planos definidas de maneira estática, limitando, portanto, a sua flexibilidade em tempo de execução.
Uma das razões para esta escolha limitadora de implementação é a comprovada complexidade computacional de decidir se um agente é ou não capaz de atingir seus objetivos.
Em contrapartida, avanços na área de planejamento proposicional permitiram que uma classe maior de problemas possa ser tratada.
Desta forma, esta dissertação tem como objetivo descrever a relação entre agentes BDI e planejamento proposicional.
A fim de atingir tal objetivo, descreve- se um mapeamento entre os estados mentais usados no modelo BDI e formalismos de planejamento proposicionais.
O mapeamento assim definido é implementado numa extensão do modelo X-BDI de agentes que utiliza como algoritmo de planejamento proposicional o Graphplan.
Finalmente, o protótipo implementado é utilizado para modelar e executar alguns estudos de caso.
O aumento da complexidade e da necessidade de distribuição dos sistemas desenvolvidos atualmente têm motivado a utilização de uma modelagem em termos de agentes autônomos.
Este tipo de modelagem aproxima tais sistemas do desenvolvimento de sistemas multi-agentes cão deste tipo de abordagem é o resultado de uma melhor com. A utiliza¸ preensão do comportamento de sistemas complexos em termos de interações entre entidades independentes.
O aumento da utilização de agentes como mecanismo de abstração motivou uma série de trabalhos voltados ao desenvolvimento de sistemas que utilizam agentes em coabstraindo seu mecanismo de funcionamento, tamb´ nhecido como nível macro.
Em contrapartida, diversas questões relativas ao funcionamento interno dos agentes, também conhecido como nível micro, receberam menos atenção nos últimos anos, tendo seu interesse sido revigorado recentemente.
O desenvolvimento de agentes racionais, isto é, agentes capazes de realizar ações úteis considerando a sua percepção de mundo, tem sido um dos principais objetivos de pesquisas em Ciência da Computação desde o seu início.
Tal desenvolvimento deu origem a diversas abordagens para a implementação de raciocínio computacional, iniciando com o General Problem Solver (GPS) e os algoritmos genéricos de resolução de problemas, e evoluindo nos Algoritmos de Planejamento.
Apesar destes sistemas serem capazes de definir como os objetivos do agente serão atingidos, eles não lidam com o problema de quais objetivos devem ser perseguidos.
Ou seja, eles são capazes de realizar raciocínio meios-fim mas não lidam com o problema do a criação do modelo raciocínio prático.
Sistemas que realizam planejamento levaram` de raciocínio baseado em agentes deliberativos como meio de tratar o raciocínio prático.
Estes sistemas utilizavam, inicialmente, uma série de mecanismos de tomada de decisão, como teoria da decisao.
Apesar destes mecanismos serem bem-definidos teoricamente, eles se mostraram inadequados para implementação, uma vez que assumem agentes com recursos computacionais e de tempo ilimitados.
A fim de resolver a questão dos recursos limitados, um modelo filosófico de raciocínio prático foi formalmente definido e implementado, que, em teoria, permite a um agente limitar o tempo gasto em deliberação.
Nao obstante, as implementações destes agentes tendem a evitar a complexidade do raciocínio meios-fim através do uso de bibliotecas de planos, definidas para o agente antes de sua execução.
Conseqüentemente, esta abordagem resolve o problema de limitação de recursos de um agente, entretanto, ela delega a responsabilidade da construção dos planos para o seu desenvolvedor.
Um dos mais importantes problemas em nível micro atualmente é a prova da existência de um agente capaz de realizar uma determinada tarefa num determinado ambiente.
Este problema é denominado Agent Design Problem.
Se considerarmos que a descrição de um ambiente consiste de um conjunto de estados válidos, um estado inicial e um conjunto de ações e seus significados, e que o resultado de uma tarefa é representado por um estado alvo, podemos facilmente relacionar a verificação da capacidade de um agente de cumprir uma tarefa com um problema de planejamento.
O objetivo deste trabalho é demonstrar como incorporar planejamento proposicional num modelo de agentes BDI de modo a prover- lo com a habilidade de realizar tanto raciocínio prático como raciocínio meios-fim em tempo de execução.
A abordagem utilizada neste trabalho consiste em, tomando um modelo de agentes BDI específico como base, estender- lo com um algoritmo e o Xde planejamento proposicional.
O modelo de agentes utilizado neste trabalho´ 99 bBLU 97] como mecanismo de raciocínio meios-fim.
Considerando o fato de que o X-BDI já realiza uma forma de planejamento no seu raciocínio meios-fim, um dos resultados esperados da sua extensão é o aumento da classe de problemas tratáveis por o X-BDI.
Este aumento deve ser na direção da classe de problemas para os quais o Graphplan apresenta bom desempenho.
Este trabalho é dividido em duas partes:
A primeira parte contém o embasamento teórico necessário ao desenvolvimento deste trabalho.
A segunda parte contém a descrição do trabalho desenvolvido.
Em a primeira parte deste trabalho, os Capítulos 2 e 3 contêm, respectivamente, o material teórico sobre agentes BDI e sobre planejamento proposicional;
Em o final desta parte, o das respectivas seções de considerações a respeito de o material apresentado, sendo o restante dos cões capítulos de leitura opcional.
Em a segunda parte do trabalho, o Capítulo 5 descreve as modificações realizadas no X-BDI para que este comporte a utilização de algoritmos de planejamento proposicional como processo de raciocínio meios-fim;
O Capítulo 6 descreve a implementação realizada para verificar a aplicabilidade do trabalho apresentado;
A seguir, o Capítulo 7 descreve um conjunto de estudos de caso desenvolvidos utilizando a implementação descrita no Capítulo 6 a fim de observar o funcionamento dos agentes desenvolvidos em ela.
Finalmente, o Capítulo 8 contém as considerações finais a respeito deste trabalho.
Parte I Embasamento Teórico Agentes BDI Este capítulo visa fornecer os subsídios teóricos relacionados a agentes computacionais.
A na definição informal de agentes que irá caracterizar tais entidades ao longo Seção 2.1 cont´ deste trabalho.
A Seção 2.2 descreve o modelo de agentes deliberativos utilizados neste trabalho.
A Seção 2.3 reúne os principais modelos formais criados para caracterizar o modelo BDI.
A Seção do capítulo são apresentadas considerações a respeito de as teorias estudadas e sua relação com o restante do trabalho.
Agentes de Software Um número crescente de sistemas têm utilizado a noção de agentes autônomos como abstração na descrição de seus componentes, aproximando o desenvolvimento de sistemas computacionais complexos ao desenvolvimento de sistemas multi-agentes.
Esta abordagem pode ser atribuída à melhor compreensão do comportamento de um sistema quando este é descrito em termos de interações entre agentes autônomos.
Apesar de o aumento da sua utilização como mecanismo de abstração, ainda existem questões fundamentais em relação a a construção de sistemas orientados a agentes que permanecem sem resposta.
Em particular, questões relacionadas a metodologias de desenvolvimento de sistemas multi-agentes.
Além de isto, a comunidade de pesquisa em sistemas multi-agentes não atingiu um consenso em relação a uma definição precisa para o que é um agente.
Apesar de a possibilidade de que esta questão nunca seja respondida de forma definitiva, alguns autores utilizam a Definição 2.1, que será utilizada ao longo deste trabalho.
Definição 2.1 (Agente) Um agente é um sistema computacional encapsulado situado num ambiente onde é capaz de agir de maneira flexível e autônoma a fim de atingir seus objetivos de projeto.
Esta definição deixa implícitas uma série de características de agentes, que são:
Agentes são entidades de resolução de problemas claramente identificáveis e com interfaces e limites bem definidos;
Agentes estão situados num ambiente em particular e recebem entradas relacionadas ao estado deste ambiente e agem sobre ele através de atuadores;
Agentes são projetados com um propósito específico, de forma que eles possuam objetivos próprios a alcançar;
Agentes são autônomos na medida que eles têm controle sobre o seu estado interno e seu comportamento;
Agentes são capazes de exibir comportamento flexível na resolução de problemas quando estão tentando satisfazer seus objetivos.
Eles devem ser reativos no sentido de responder a mudanças no ambiente de maneira temporalmente aceitável e pró-ativos no sentido de agir na expectativa de alcançar objetivos futuros.
O Modelo BDI Durante a evolução de sistemas baseados em agentes, um dos mais importantes modelos a ter sido criado é o modelo baseado na interação dos estados mentais Crenças, Desejos e Intenções cão de estados mentais para descrever o comportamento.
O modelo BDI se baseia na noção de um agente.
Esta noção foi descrita inicialmente nos trabalhos de Searle e Dennet.
Juntamente com a teoria de ações intencionais de Davidson], a utilização de estados mentais foi refinada por Bratman, resultando no modelo BDI.
O modelo BDI é um dos mais conhecidos e estudados modelos de agentes deliberativos, com o qual foram realizados diversos estudos teóricos e implementações visando a prova de sua utilidade na resolução de diversos problemas[ BRA 88, GEO 89a, RAO 96, POL 90].
A evolução do modelo BDI no contexto de ciência da computação pode ser traçada através da análise destes trabalhos, uma vez que cada um de eles contribuiu para reduzir a distância entre o modelo filosófico que o originou até um modelo de raciocínio prático concreto.
Alguns destes trabalhos são descritos nas Seções 2.3 e 2.4.
A validade do modelo BDI já foi questionada em relação a abordagens mais recentes de descrição de sistemas.
Entretanto, diversos autores continuam utilizando o modelo De a sigla em inglês Beliefs, Desires and Intentions.
BDI como modelo base de agentes deliberativos[ SCH 01, HOE 03, WOO 99, NI D02, BOR 02, BOR 03], buscando o aprimoramento do modelo através da construção de novas teorias que embasem o modelo BDI num sistema unificado ou da extensão de teorias´ 99 a, NI D02, BOR 02, NAI 03].
Máquinas, Intenções e Estados Mentais A utilização de estados mentais na descrição de sistemas computacionais remete aos trabalhos de Dennet.
Estes trabalhos descrevem sistemas intencionais como entidades cuja conduta pode ser prevista através da atribuição de Crenças, Desejos e perspicácia racional.
Estes sistemas se dividem em níveis onde um sistema intencional de primeira ordem é um sistema onde as entidades têm crenças e desejos a respeito de qualquer objeto que não outras crenças e desejos.
Um sistema de segunda ordem pode ter crenças e desejos a respeito de outras crenças e desejos, e assim por´ 99 a, WOO 00b].
Descrevendo máquinas como estados mentais A motivação para a atribuição de estados mentais a sistemas computacionais pode ser analisada´ leg´ do ponto de vista da sua utilidade e legitimidade.
E itimo atribuir estados mentais a máquinas quando tal atribuição possibilita que seja compreendida a mesma informação a respeito de a máquina que seria compreendida de uma pessoa.
Esta atribuição é útil quando facilita o entendimento da estrutura da máquina, seu comportamento passado e futuro, e maneiras de consertar- la ou melhorar- la.
Esta atribuição talvez não seja fundamental nem para descrever seres humanos, mas a utilização de algum tipo de qualidade mental possibilita que uma descrição sucinta de um e possível e estado em particular de determinada máquina seja feita.
Desta forma çorreto descrever sistemas extremamente simples com estados mentais, porém é mais útil fazer- lo para descrever sistemas cuja estrutura interna não é completamente conhecida.
Esta seção irá detalhar as teorias relacionadas ao uso de estados mentais para descrever comportamento, inicialmente descrevendo a teoria de Davidson de Crenças e Desejos, seguindo para a descrição da teoria consolidada de Bratman de Desejos, Crenças e Intenções.
A teoria de Crenças e Desejos de Davidson Em o trabalho &quot;Actions Reasons and Causes&quot;], Davidson apresenta as bases de uma teoria sobre o raciocínio prático.
Tal trabalho define ações intencionais como sendo ações que são explicáveis através das razões do agente para ter- las realizado, razões estas que podem ser traçadas até pares de crenças e desejos.
Assim sendo, o autor pressupõe que é possível realizar uma avaliação total (all-out evaluation) das crenças e desejos para se gerar cada ação.
Esta avaliação total é baseada numa função de utilidade máxima que, levando em consideração as crenças do agente, determina a cada momento qual é a ação mais eficiente a ser realizada de modo a satisfazer seus desejos.
Um esquema básico deste funcionamento pode ser visto na Figura Alguns problemas em relação a esta teoria puderam ser verificados, em particular, relacionados ao funcionamento deste mecanismo de raciocínio num contexto com tempo e recursos limitados.
Isto motivou a criação de um modelo de raciocínio que contemplasse o tratamento destas limitações.
Este problemas serão descritos a seguir:
O primeiro problema relacionado à função de avaliação total é chamado de Problema de cões do asno são idênticas, ele não Buridan2.
Considerando que todas as op¸ será capaz de estabelecer qual de elas é a melhor.
Este problema ilustra o fato de que a teoria de pensamento e ação de Davidson enfrentaria sérios problemas em situações com opções igualmente desejáveis, situações estas que seres humanos são eficazes em solucionar.
Problema 2.2 (Problema do Raciocínio Parcial) Considere que o Agente Smith tem o desejo de comprar um jogo de computador em particular.
O Agente também tem a crença de que isto pode ser alcançado indo para a loja X, mas o agente não sabe se a loja X tem ou não uma cópia do jogo no seu estoque.
Também deve haver uma maneira de se gerar estados mentais (desejos/ intenções) parciais a fim de se avançar na direção do cumprimento de objetivos cuja viabilidade teórica ainda não é completamente conhecida.
Se a ação necessária para se cumprir o desejo do Agente Smith depender somente de suas crenças e desejos, não fica claro se o agente deve ir à loja para verificar a existência do jogo ou nao.
A fim de solucionar este problema, é necessário um estado mental intermediário que permita ao agente iniciar o movimento em direção à satisfação do seu desejo.
Em contrapartida, este estado mental deve permitir sua revisão durante a sua execução de modo que ele possa refletir os dados que vão se completando à medida que a informação completa é preenchida.
Por ser atribuído ao filósofo Jean Buridan, mesmo que tal problema nunca tenha sido encontrado entre seus escritos.
Problema 2.3 (Problema da Desconsideração do Tempo) Se o tempo que o Agente Smith leva para considerar todas as suas opções é relevante em relação a o tempo necessário para que o mundo mude de estado, então, quando o agente terminar seu processo de raciocínio, suas decisões podem estar desatualizadas.
A o realizar uma avaliação total das crenças e desejos do agente, o modelo de Davidson assume que o tempo necessário para realizar tal operação é irrelevante em relação a a taxa de mudança do estado de mundo.
Desta forma o principal problema em relação a este modelo é que ele desconsidera o tempo decorrido entre a deliberação e a ação.
Este problema se torna mais claro quando se consideram agentes com recursos limitados, tais como seres humanos e programas de computador, num mundo dinâmico.
Em este caso, o tempo gasto no processo de deliberação deve ser o menor possível, dado que o estado atual do mundo pode mudar durante este processo, caso contrário as decisões tomadas durante a deliberação podem não mais ser válidas no final do processo.
Desta forma, mesmo que o modelo de Davidson seja interessante do ponto de vista teórico, ele falha em diversos aspectos quando utilizado para descrever o funcionamento de agentes no mundo real.
A importância das intenções Apesar de ser uma base interessante para uma teoria completa de raciocínio prático, a teoria de desejos e crenças descrita por Davidson possui limitações.
Estas limitações estão ligadas ao uso da o obstante, apenas dois estados mentais para lidar com cursos de ação conflitantes.
N~ seria possível realizar o processo de deliberação apenas com estes estados mentais, mesmo que este processo seja extremamente limitado, em particular em relação a limitações de tempo e recursos.
A deliberação, neste caso, sofreria de um problema onde o agente reconsideraria seus cursos de ação constantemente levando- o a possivelmente nunca levar seus desejos longe o suficiente para satisfazer- los, visto que cada ação seria o resultado de uma avaliação completa dos desejos e crenças.
Em contrapartida, se o agente gastar algum tempo planejando um curso de ações consistente que leve a um dado objetivo e se comprometer com a sua execução, o agente apenas re-consideraria suas ações quando algo for alcançado.
Considerando que o planejamento é uma peça fundamental da inteligência, três habilidades são fundamentais para agentes que planejam:
Agir intencionalmente, criar e executar planos e um requisito para a segunda, visto que é necessário um.
A primeira habilidade ésforço ativo do agente para que ele crie um plano.
Este esforço descreve de maneira apropriada o modo como a mente humana funciona, dado que estamos constantemente refletindo em relação á nossas ações e intenções, no passado e no futuro.
E este mecanismo de raciocínio que nos permite ponderar sobre cursos de ação complexos a priori, evitando a necessidade de decidir todas as ações no momento em que são executadas.
Desta forma, Bratman propõe o uso de intenções como estados mentais distintos e com a mesma importância dos desejos e crenças no processo deliberativo.
Este modelo é esquematizado na Figura 2.2.
O papel das intenções não é apenas complementar o modelo de crenças e desejos como outro elemento que associa racionalidade aos atos de um agente, mas prover ao agente a habilidade de estruturar seu planejamento, participando do processo do raciocínio meios-fim do agente.
O planejamento ao qual Bratman se refere não é necessariamente o mesmo que ocorre em sistemas ivel onde as intenções guiam o planecomo o STRIPS, mas um processo de mais alto n´ jamento em si.
As intenções se distinguem dos desejos na medida em que são pró-atitudes que controlam a ação do agente enquanto os desejos apenas a influenciam.
Intenções constituem planos de alto nível, que serão refinadas e modificadas quando necessário.
Estes planos permitem ao agente iniciar o movimento em direção aos seus objetivos cuja viabilidade ainda não está definida.
Em o contexto desta teoria, são definidas três características fundamentais no processo de raciocínio.
Intenções têm um efeito mais direto nas ações do agente no sentido de que elas controlam a sua conduta.
Além de isto, elas possuem uma característica denominada inércia, que significa que, apesar de revogáveis, as intenções resistem à reconsideração.
Finalmente, intenções servem de entrada na geração de novas intenções.
A possibilidade de revogação de intenções durante o processo de raciocínio suscita uma das principais questões do modelo BDI, que é o balanço entre a estabilidade das intenções e a sua reconsideração.
Este problema foi identificado na criação da arquitetura IRMA.
Um agente que reconsidera suas intenções muito freqüentemente é chamado de cauteloso, e um agente que se apega demais às suas intenções é chamado de audacioso.
Diversos autores estudaram este problema e suas soluções potenciais.
Quando utilizadas como entrada na geração de novas intenções, as intenções restringem quais estados serão considerados no raciocínio futuro, i.
e elas estabelecem padrões de relevância para as opções que serão consideradas na deliberação futura.
Estes padrões criam um filtro de admissibilidade para as soluções de um dado problema.
Conseqüentemente, esta pré-deliberação que limita o espaço de busca por soluções provê uma maneira de superar as limitações de tempo e recursos mencionada anteriormente.
Em este sentido, estas características das intenções as tornam uma solução mais apropriada do que um função de utilidade máxima.
Além de isto, este filtro de admissibilidade resolve o Problema de Buridan na medida em que fornece uma justificativa para desconsiderar certas ações, quando um curso de ação for estabelecido.
A utilização de intenções permite a coordenação do agente tanto interna quanto externamente.
De o ponto de vista interno, o agente saberá que ao se comprometer com a realização de uma intenção, quando o momento chegar, ele irá, pelo menos, tentar fazer aquilo a que se propunha.
Além de isto, o esforço despendido no planejamento de como cumprir o que se pretende, definindo os passos preliminares, irá deixar o agente numa posição apropriada para realizar as ações necessárias e ter melhores condições de sucesso.
De o ponto de vista externo, uma vez que os demais agentes de um sistema tenham sido informados das intenções de um determinado agente, eles poderão planejar suas ações baseados na expectativa de que este irá cumprir as suas intenções.
A possibilidade de realimentação das intenções no processo de raciocínio (i.
e intenções podem gerar outras intenções) também acarreta dificuldades.
A principal de elas é chamada de Problema escolher uma intenção para satisfazer um dado objetivo, e posteriormente durante a utilização desta intenção na geração de novas intenções, esta gerar uma nova intenção no sentido de fazer algo que não representa os desejos do agente (Problema 2.4).
Problema 2.4 (Problema do Pacote) Se o Agente Smith tem o desejo de obter o grau de Mestre com um bom trabalho (m na Figura 2.3), ele terá a intenção de trabalhar muito como conseqüência (w na Figura 2.3).
Esta intenção de trabalhar muito pode resultar na intenção de não dormir algumas noites a fim de aumentar o seu tempo de trabalho(¬ s na Figura 2.3), mesmo que seus desejos afirmem que ele gosta de dormir bem (s na Figura 2.3).
Em este caso, a intenção de trabalhar muito gerou uma intenção conflitante com os seus desejos pois ela &quot;veio com o pacote».
Conseqüentemente, a intenção de não dormir algumas noites não é utilizada como entrada para outras intenções, visto que ela não representa os desejos do Agente Smith.
Saber como diferenciar intenções que podem gerar novas intenções daquelas que não podem é uma das dificuldades inerentes a este problema.
A teoria de Bratman fornece uma alternativa de solução não apenas para os problemas do modelo de Davidson, mas também introduz um modelo onde é possível que as intenções de um agente, e em última instância suas ações, possam ser motivadas por outros elementos que não pares de desejos e crenças.
Esta característica possibilita a geração de intenções sem uma relação direta com os desejos, o que permite ao agente se aproveitar de oportunidades surgidas no ambiente, o que é uma característica importante do comportamento inteligente.
Principais componentes do modelo BDI O modelo BDI é, essencialmente, uma transposição computacional do modelo de raciocínio proposto por Bratman.
Este modelo é baseado na utilização de crenças, desejos e intenções como estados mentais fundamentais e necessários na descrição do raciocínio prático.
Apesar de o modelo BDI ter sido originado por uma teoria em comum, existem várias interpretações para ele, de modo que atualmente nenhuma arquitetura ou modelo formal o representa em sua totalidade.
Desta forma, a operação do modelo BDI pode ser descrita de modo abrangente como o balanço racional de crenças, desejos, intenções e demais componentes auxiliares como planos, comprometimentos e ações.
Os componentes do modelo BDI podem ser descritos da seguinte forma:
Crenças representam a expectativa do agente em relação a o estado atual do mundo e a possibilidade de um dado curso de ações levar a outro estado de mundo.
Tal estado é normalmente modelado através de uma semântica de mundos possíveis, porém, nem todas as instâncias do modelo BDI utilizam uma semântica tão complexa.
Crenças podem ser representadas de maneira mais simples, como por exemplo, proposições ou variáveis num programa.
Desejos são uma abstração que especifica preferências em relação a estados de mundo ou cursos de ação.
Um ponto em comum de vários trabalhos é o fato de que desejos não são necessariamente.
Por exemplo, um agente pode ter o desejo consistentes de avançar contra um inimigo para atacar- lo e ao mesmo tempo fugir de ele a fim de garantir a sua sobrevivência.
O que determinará qual dos dois desejos será adotado por o agente será o estado de mundo onde o agente se encontra.
Desejos são facilmente representáveis em programas de computador, tal como as crenças.
Eles podem simplesmente representar estados de mundo, de maneira semelhante a sistemas de planejamento.
A utilização de desejos torna um sistema orientado a objetivos, o que é vantajoso na medida em que o sistema possui um senso de propósito em suas ações.
Isto permite que o agente, ao descobrir que suas ações não tiveram o resultado desejado, possa tentar algum tipo de ação corretiva.
Intenções são utilizadas para superar a limitação de recursos do agente no processo de raciocínio focando o processo de deliberação num subconjunto dos seus desejos, com cuja realização o agente se compromete.
O processo de seleção dos desejos que irão constituir intenções é chamado de formação das intenções.
A função das intenções não se limita a um conjunto de comprometimentos, podendo também fazer parte do processo de raciocínio meios-fim.
Em este sentido, intenções podem funcionar como planos parciais, de modo que, caso o mundo mude de maneira sutil, seja possível adaptar o plano ao invés de se fazer um re-planejamento total.
Outros estados mentais:
Alguns autores sugerem a utilização de outros estados mentais além de crenças, desejos e intenções.
De entre estes diferentes estados mentais, alguns são propostos visando facilitar a compreensão e otimizar o funcionamento dos modelos para os quais foram feitos, e comprometimentos definidos.
Exemplos disto são os objetivos e planos do InterRAP e capacidades da programação orientada a agentes, entre outros.
Devido a o fato de que o conjunto de desejos de um agente é potencialmente inconsistente, alguns autores sugerem a utilização de um estado mental auxiliar entre desejos e intenções.
Este estado intermediário poderia, por exemplo, representar um subconjunto internamente consistente dos desejos do agente (i.
e cada desejo no conjunto é consistente com os demais) e possivelmente externamente consistente (i.
e os desejos são consistentes com as crenças do agente).
A habilidade de um agente em decidir como atingir seus objetivos é essencial no processo deliberativo.
Conseqüentemente, alguns autores modelam os planos de um agente como uma seqüência de intenções adotadas num determinado momento.
A origem destas intenções geralmente é uma biblioteca de planos, porém, nada impede que o planejamento das intenções ocorra em tempo de execução dando mais flexibilidade ao agente.
Teorias BDI Esta seção resume as principais teorias utilizadas no embasamento de modelos computacionais de agentes BDI.
Especificamente, descreve- se a teoria de intencionalidade de Cohen e Levesque ógica BDI de Arvores Computacionais de Rao e Georgeff, em ordem e a Lévolucionária.
Modelo de Cohen e Levesque Bratman definiu conceitos filosóficos que buscam explicar por que os seres humanos se comportam de maneira eficiente no mundo real através de três estados mentais, definindo informalmente as relações entre estes estados e enumerando diversas características que tais estados devem possuir.
Estes conceitos foram utilizados por pesquisadores em Ciência da Computação na tentativa de emular este processo no sentido contrário, isto é, definir processos centrados em Crenças, Desejos e Intenções que permitiriam que um agente operasse no mundo real de modo satisfatório.
A fim de utilizar de modo preciso este modelo de raciocínio em Ciência da Computação, uma definição formal de como funcionam estes conceitos filosóficos foi criada por Cohen e Levesque cões que satisfizessem.
O objetivo principal dos autores foi definir formalmente intenúm conjunto de papéis funcionais tal como definido por Bratman e tratar alguns dos possíveis efeitos colaterais previstos por o mesmo autor.
Além de isto, os autores buscam estabelecer os fundamentos de uma teoria de interação entre agentes baseada em atos de fala.
Definições Básicas A teoria descrita por os autores é fundamentada numa forma de lógica modal que utiliza semântica de mundos possíveis, com quatro operadores modais principais, os conectivos da lógica clássica(¬,,), modalidades temporais.
Os principais operadores modais são descritos abaixo:
Bel é utilizado para descrever crenças, onde (Bel Agt P) significa que a fórmula P é conseqüência das crenças do agente Agt.
GOAL é utilizada para representar objetivos, que por sua vez são utilizados para representar desejos, onde (GOAL Agt P) significa que a fórmula P é conseqüência dos objetivos do agente Agt.
Alternativamente, considerando a semântica de mundos possíveis, isto significa que a fórmula P é verdadeira em todos os mundos acessíveis a partir de o mundo atual que são compatíveis com os objetivos do agente;
HAPPENS é utilizado em conjunto com DONE no raciocínio temporal, onde (HAP P EN S ActExpression) significa que ActExpression3 acontece a seguir;
DONE complementa HAPPENS no raciocínio temporal, onde (DON E ActExpression) significa que ActExpression acabou de acontecer.
Além de os operadores básicos, a noção de tempo é representada por números que denotam o momento onde uma determinada fórmula é verdadeira para o agente, por exemplo, a proposição (At Smith Brazil) 3 significa que o &quot;agente Smith estar no Brazil «somente é verdadeira no tempo 3.
Outra característica do raciocínio temporal nesta teoria é que são permitidos eventos ou uma expressão de ação, que pode ser:
Uma variável de ação;
A ação seqüencial, ActExpression1;
ActExpression2, que significa que a primeira expressão de ação ocorre e a segunda expressão de ação ocorre logo a seguir (HAP P EN S);
A ação de escolha não determinística, ActExpression1| ActExpression2, que significa que ou a primeira ou a segunda expressão de ação ocorrerá a seguir (HAP P EN S);
A ação de teste, P?,
que é utilizada para restringir o raciocínio de um agente aos mundos possíveis onde a fórmula P é verdadeira;
A ação de iteração, ActExpression, que significa que ActExpression ocorre múltiplas vezes como se diversas ocorrências da ação seqüencial&quot;;»
tivessem sido utilizadas, ActExpression irá ocorrer pelo menos uma vez.
Estas construções relativas a ações são utilizadas no raciocínio sobre uma variedade de fenômenos do mundo real relacionados aos atos do agente e a eventos ocorrendo fora de a esfera de influência do próprio agente.
Onde ActExpression pode ser qualquer expressão de ação.
Crenças As crenças do agente caracterizam aquilo em que o agente acredita implicitamente, isto significa que se tudo em que o agente acredita é verdadeiro, então as crenças do agente representariam completamente o estado do mundo num dado momento.
Outra característica da natureza implícita das crenças nesta teoria é que o agente acredita em todas as ramificações das suas crenças, sem a necessidade de raciocinar explicitamente a fim de inferir as conseqüências de suas crenças.
Esta definição de crenças é utilizada por os autores para definir as noções de conhecimento e competência, representadas por os operadores modais KNOW e COMPETENT.
Diz- se que um agente A conhece a fórmula P (representado na forma (KN OW A P)), se o agente acredita que P é verdadeira e P é, de fato, verdadeira.
Além de isto, diz- se que um agente Aé competente a respeito de uma fórmula P (representado na forma (Com P ET EN T A P)), se sempre que o agente acredita que P é verdadeiro, P é realmente verdadeiro.
Objetivos Os autores constroem as noções de objetivos e intenções de Bratman refinando o conceito básico de objetivo (GOAL).
Este conceito é definido de maneira similar às crenças na medida em que o operador GOAL define o que é implícito em relação a os objetivos do agente.
De maneira semelhante às crenças, um agente tem como objetivo todas as conseqüências de seus objetivos explícitos.
Considerando a natureza implícita de ambos os operadores Bel e GOAL, e o fato de que um agente escolhe o mundo onde ele se encontra, então quando o agente acredita que uma propriedade P é verdadeira ele também escolheu P como sendo verdadeira.
Utilizando esta definição de objetivo, os autores refinam a noção de objetivo definindo um objetivo de realização (A -- GOAL A P) como sendo uma propriedade P que atualmente é falsa, mas que eventualmente será verdadeira.
O objetivo de realização captura uma propriedade importante dos desejos definidos por Bratman que diz que um agente não pode desejar algo que ele já saiba que é verdadeiro ou que nunca irá se tornar verdadeiro.
Os autores prosseguem na definição de um objetivo que implica comprometimento, que é chamado de objetivo persistente, onde (P -- GOAL A P) significa que o agente A tem P como um objetivo persistente até que o agente satisfaça P ou acredite que P é impossível.
Um aspecto importante da definição de objetivos persistentes é que eles são fechados em relação a a equivalência lógica, o que será importante quando os autores tiverem que tratar do Problema do Pacote (Problema da implicação, então seria possível que, um agente que possui um objetivo com conseqüências indesejadas tivesse como objetivo, por implicação lógica, as conseqüências indesejadas.
Sendo os objetivos persistentes fechados apenas em relação a a equivalência lógica, não é possível que novos objetivos sejam derivados apenas por propriedades lógicas.
Intenções Tendo formalizado diversas noções de objetivos e analisando suas conseqüências lógicas, os autores definem dois tipos de intenções:
Significa que o agente A está comprometido, através de um objetivo persistente, a acreditar que ele está prestes a realizar P, e então irá realizar- lo; (
In T EN D2 A P) significa que o agente A está comprometido, novamente através de um objetivo persistente, a acreditar que ele irá fazer algo (ele pode não ter nenhum conhecimento do que ele irá fazer além de o primeiro passo) que irá resultar em P sendo verdadeiro como conseqüência.
Estas duas definições capturam os dois propósitos das intenções previstos por Bratman.
In T EN D2 representa as intenções como componentes de planos de alto-nível, que serão utilizados por o agente para iniciar a sua ação na direção de um determinado objetivo mesmo que a maneira exata de como alcançar tal objetivo não seja completamente conhecida.
In T EN D1 representa os componentes dos planos de baixo nível, que estão mais próximos de ações concretas.
Até a definição básica das intenções, objetivos e intenções são definidos de uma forma dita fanática, isto é, o agente irá querer realizar algo até que ele tenha conseguido realizar- lo ou até que ele acredite que é impossível tornar- lo verdadeiro.
Relativizando os objetivos (GOAL) através da dependência por uma condição, os autores especificam um critério além de a impossibilidade para que um agente desista de um objetivo.
Desta forma, estas definições capturam a maioria, senão todas, as propriedades antevistas por Bratman, entretanto, os autores não especificam o processo por o qual um agente decide quais desejos ele irá perseguir, e como ele lida com desejos conflitantes.
Lógica BDI de Rao e Georgeff Diversos autores propuseram uma série de sistemas lógicos visando a construção de agentes racionais.
Entretanto a maioria destes sistemas captura apenas um subconjunto das propriedades de racionalidade necessárias para um agente, carecendo, portanto, de uma axiomatização completa.
De entre estes sistemas, aqueles definidos a fim de descrever o funcionamento de agentes BDI também partilham destas limitações.
A fim de enfrentar a falta de uma axiomatização correta e completa para agentes BDI, Rao e Georgeff definiram uma família de lógicas e procedimentos de decisão para descrever agentes BDI.
Estas lógicas são chamadas de Lógicas de Arvores Computacionais BDI (BDI Computation Tree Logics), sendo suas instâncias mais importantes chamadas de BDICT L e BDICT L.
Este conjunto de lógicas foi largamente utilizado na pesquisa sobre agentes BDI tendo recebido o nome de Lógicas BDI.
De Estruturas Temporais Ramificadas a Mundos Possíveis Os sistemas lógicos assim definidos tinham o objetivo de relacionar métodos clássicos de definição de racionalidade como teoria da decisao.
Desta forma, os autores criaram um mapeamento de a partir de a Lógica Temporal Ramificada (Branching Temporal Logic) e de Arvores Decisão num modelo representando crenças, desejos e intenções na forma de relações de acessibilidade num conjunto de mundos possíveis.
Ínformalmente, Arvores de Decisão são compostas de vértices representando estados de mundo, arcos nesta árvore representam caminhos de execução alternativos.
Transições de estado podem ser ações realizadas por o sistema ou eventos primitivos ocorrendo no ambiente, ou mesmo ambos.
Vértices resultantes de ações são chamados de Vértices de Escolha e vértices resultantes de eventos são chamados de Vértices de Acaso.
As folhas na árvore são chamadas de vértices terminais.
Vértices de Acaso podem ser rotulados com probabilidades representadas com valores em R. Uma função de recompensa atribui valores de recompensa em R a vértices terminais.
Uma função de deliberação escolhe o caminho a partir de a raiz até Vértices terminais com recompensa maior.
Sintaxe e Semântica çonsiderando que as Lógicas de Arvores Computacionais BDI são extensões da Lógica Temporal Ramificada de Emerson, elas incluem um conjunto de proposições primitivas $= e um conjunto de conectivos básicos e operadores de os quais outros podem ser definidos.
Os conectivos proposicionais utilizados nesta lógica são e¬, de os quais são definidos, e.
Os Operadores Temporais Lineares utilizados nesta lógica são X (a seguir), U (até) e F (em algum momento no futuro (eventually), similar ao operador).
A partir destes operadores temporais são definidos G (em todos os momentos no futuro ou sempre, equivalente ao operador) eB (antes de).
Um quantificador de caminho utilizado nesta lógica é E (algum caminho no futuro ou opcionalmente), de o qual é definido A (todos os caminhos no futuro ou inevitavelmente).
Finalmente, a lógica é estendida com os operadores modais Bel (o agente acredita), Des (o agente Fórmulas bem formadas nesta lógica são definidas utilizando proposições atômicas e os conectivos e operadores definidos anteriormente.
Estas fórmulas são divididas em dois tipos:
Fórmulas de estado, que expressam a verdade num estado ou mundo em particular, e fórmulas de caminho, que expressam a verdade num mundo em particular ou ao longo de um caminho em árvores de mundos possíveis.
Um conjunto de regras para a definição da classe de fórmulas válidas na linguagem é definido abaixo:
S1 cada proposição atômica é uma fórmula de estado;
S2 se e são fórmulas de estado, então¬ e também o sao;
S3 se é uma fórmula de caminho então A e E são fórmulas de estado;
De estado;
P0 se e são fórmulas de estado então X e U são fórmulas de caminho;
P1 cada fórmula de estado é também uma fórmula de caminho;
P2 se e são fórmulas de caminho então¬ e também o sao;
P3 se e são fórmulas de caminho então X e U também o sao.
A classe de fórmulas válidas para a BDICT L é definida utilizando as regras S 1-S4 e P0, limitando portanto a composição de fórmulas de caminho a declarações em relação a fórmulas de estado (utilizando especificamente os operadores X e U).
A classe de fórmulas válidas para BDICT L é definida utilizando as regras S 1-S4 e P 1-P3.
A atribuição de valores verdade nesta lógica é dada por uma semântica de mundos possíveis onde cada mundo possível é uma estrutura de árvores com um passado linear infinito e um futuro ramificado.
O futuro ramificado representa os cursos de evento os quais o agente pode escolher quando num mundo em particular.
A relação de acessibilidade das crenças mencionada anteriormente mapeia um estado de mundo possível em outros mundos possíveis.
As relações de acessibilidade de desejos e intenções também fazem um mapeamento semelhante.
Além de isto, os autores provêem uma série de procedimentos de decisão para a verificação da validade e satisfação de fórmulas nesta lógica.
Estes procedimentos são baseados na prova da existência de uma propriedade chamada de propriedade de modelo pequeno (small model property) para uma dada fórmula.
Propriedades Modais BDI Além de as definições semânticas, este framework lógico provê uma série de axiomatizações possíveis de modo que diferentes tipos de lógicas BDI possam ser definidas.
Além de os axiomas herdados da Lógica Temporal Ramificada, diversos axiomas modais aplicados às modalidades BDI podem ser incluídos no sistema lógico resultando em diferentes propriedades para o sistema lógico correspondente.
O conjunto mínimo de axiomas nesta lógica é resultado da aplicação do axioma K para cada uma das modalidades.
O axioma K é similar à regra de implicação lógica, aplicado à um operador modal.
Este axioma estipula que, se um operador modal aplicado a uma implicação é verdadeiro e o mesmo operador aplicado à condição desta implicação também é verdadeiro, então o operador modal aplicado à conseqüência da implicação é verdadeiro por implicação.
Isto resulta nos seguintes axiomas:
Além destes axiomas, os autores fizeram experiências com a inclusão do axioma D, 4, 5 e a regra da generalização, resultando em diversas propriedades do modelo BDI definido por Cohen e Levesque.
Em particular, a regra da generalização estipula que qualquer fórmula válida é necessariamente acreditada, desejada e almejada, resultando em:
Gen If then D-Gen If then I-Gen If then O sistema modal weak-S5 (axiomas D, 4 e 5) é utilizado nas crenças para proporcionar ao agente respectivamente, consistência e introspecção positiva e negativa.
O axioma D de consistência estipula que se um agente acredita que uma propriedade é verdadeira, então ele não acredita que esta propriedade é falsa.
O axioma 4 de introspecção positiva estipula que, se um agente acredita numa propriedade, ele está ciente de sua crença, i.
e ele acredita que acredita na propriedade.
A introspecção negativa funciona de forma semelhante, i.
e se um agente não acredita numa propriedade, ele acredita que não acredita na propriedade.
Finalmente o axioma D para consistência também é utilizado em relação a os desejos e intenções.
BDICT L e LORA O framework lógico BDICT L foi expandido posteriormente num novo sistema chamado de LORA.
Este framework introduz diversas mudanças e extensões, não obstante, diversas características da lógica BDICT L foram mantidas.
Em relação a a representação do tempo, a LORA utiliza uma noção similar de tempo discreto, ilimitado e ramificado no futuro, e linear no passado, entretanto o tempo passado é limitado por um ponto inicial.
Em relação a a expressividade, a LORA estende o conjunto de operadores temporais com o operador W, onde W significa a não ser que.
Ela também acrescenta a noção de ações e sua execução de forma similar ao sistema lógico de Cohen e Levesque.
Especificamente, ela utiliza as construções de ação seqüencial, (a;
A), ação de escolha não determinística (a| a), ação de iteração (a) e ação de teste (a?),
onde o seu significado é o mesmo descrito na Seção Arquiteturas BDI Como visto na Seção 2.2, a teoria de raciocínio prático de Bratman levou ao desenvolvimento do modelo BDI de agentes.
Este modelo foi utilizado na criação de um série de trabalhos visando a sua implementação em sistemas computacionais reais.
Esta seção descreve duas das mais notórias implementações de agentes BDI.
A primeira é uma proposta do autor do modelo filosófico de como um agente BDI deve ser implementado.
A segunda implementação foi utilizada como referência no desenvolvimento de diversos outros trabalhos, em particular trabalhos que lidam com a utilização de lógicas modais na descrição de comportamento de um sistema.
Em o final desta seção, descreve- se um terceiro modelo teórico de agente BDI que utiliza uma abordagem diferente dos anteriores ao implementar o raciocínio nao-tonotônico do agente utilizando Programação em Lógica Estendida.
A Intelligent Resource--bounded Machine Architecture (IRMA) foi definida com o objetivo de demonstrar a viabilidade do modelo de raciocínio prático de Bratman.
O objetivo da IRMA é prover um mecanismo de raciocínio para um agente que leva em consideração seus recursos limitados.
Outro aspecto desta arquitetura é ser uma das primeiras4 a incorporar intenções como estado mental fundamental no processo de raciocínio prático.
O papel das intenções nesta arquitetura é estabilizar o processo de cumprimento de objetivos de longo prazo, além de isto as intenções mantém um registro do progresso das atividades do agente, permitindo a ele modificar passos de um plano em execução sem ter que recomeçar as suas atividades.
A Figura 2.4 representa a organização interna da IRMA e contém dois tipos básicos de entidades:
Processos (denotados por retângulos) e entidades de armazenamento (denotadas por elipses).
As intenções de um agente IRMA são estruturadas em planos de alto nível que guiam a escolha dos planos propriamente ditos (ou planos como receitas), que estão armazenados numa biblioteca de planos.
O Analisador de Oportunidades reage a mudanças no ambiente criando opções de ação baseado em eventos não previstos por o planejamento convencional, que Junto com o PRS (Seção 2.4.2).
O Raciocinador Meios-fim e o Analisador de Oportunidades sugerem opções para o processo de filtragem, representado por o Filtro de Compatibilidade e por o Ignorador do Filtro.
O Filtro de Compatibilidade verifica se as opções geradas são consistentes com as intenções adotadas atualmente, e as opções sobreviventes são passadas para o Processo de Deliberação, que pesa as novas opções entre si e as incorpora aos planos do agente.
O Ignorador do Filtro foi incorporado ao processo de filtragem devido a a possibilidade do agente ter conhecimento limitado, que cria situações onde certas alternativas seriam interessantes apesar de a base de crenças indicar que há inconsistência nestas alternativas.
Desta forma, mesmo que uma determinada opção seja eliminada por o Filtro de Compatibilidade, é possível que ela ative uma regra do Ignorador do Filtro que a torne uma regra sobrevivente.
A arquitetura IRMA, apesar de ser bastante abstrata, serviu para delinear alguns dos problemas que as demais arquiteturas BDI deveriam resolver, tais como a falta de procedimentos para· Propor novas opções em virtude de a percepção de mudanças no ambiente;
Avaliar opções conflitantes;
Ignorar o filtro de compatibilidade.
Alguns dos conceitos definidos no trabalho original da IRMA foram testados no sistema Tileworld, cujo objetivo principal era prover uma plataforma de testes de arquiteturas de agentes para estratégias de raciocínio em meta-nível.
Essencialmente, o sistema Tileworld consiste de um agente robô simulado e um ambiente simulado, que é dinâmico e imprevisível.
Tanto ambiente como agente foram projetados para serem altamente parametrizáveis de modo que diversas situações em as quais o agente poderia se encontrar pudessem ser testadas, e o comportamento de pares agente/ ambiente pudesse ser avaliado.
Os principais componentes examinados no agente Tileworld foram o Mecanismo de Filtragem (Filtering Mechanism), composto do Filtro e responsável por decidir se uma de Compatibilidade e do Ignorador do Filtro (Figura 2.4), que´ mudança no ambiente deve causar a reconsideração das intenções atuais do agente, e o processo de deliberação.
Diversas estratégias de deliberação com complexidades crescentes foram testadas contra diferentes composições de ambientes, que variavam em diversos aspectos, a fim de testar a adequação do agente a diversas situações de ambiente.
Os experimentos realizados na plataforma de testes Tileworld levaram à conclusão de que um Mecanismo de Filtragem que permite apenas que oportunidades claras cheguem ao processo de deliberação é mais desejável tanto quanto o ambiente é mais dinâmico.
Utilizando a noção de Cautela e Audácia, um agente Audacioso tende a apresentar um melhor desempenho que um agente Cauteloso num ambiente dinâmico.
Apesar de estas conclusões concordarem com as hipóteses apresentadas em trabalhos anteriores, os autores são cautelosos em não afirmar sua generalidade em relação a aplicações do mundo real, visto que o ambiente onde o agente foi embutido é altamente controlado.
O Procedural Reasoning System (PRS) foi criado visando uma arquitetura BDI que pudesse ser utilizada em aplicações do mundo real.
Ele também objetivava suportar raciocínio tanto orientado a objetivos quanto reativo.
O sistema foi utilizado inicialmente na implementação de um sistema de controle de tarefas num simulador de espaçonaves da NASA.
Esta seção irá descrever os componentes da arquitetura do PRS e o processo utilizado por o interpretador do PRS nestes componentes.
Componentes do PRS O PRS é organizado numa série de componentes arquiteturais cujo controle é delegado ao odulo PRS consiste interpretador, como pode ser visto na Figura 2.5.
Um agente ou m´ de um banco de dados contendo as crenças atuais do sistema em relação a o mundo, um conjunto de objetivos correntes, uma biblioteca de procedimentos ou planos cujos elementos descrevem seqüências de ações e testes que objetivam o cumprimento de determinados objetivos ou a reação a situações específicas.
O PRS utiliza uma estrutura de intenções que consiste de um conjunto de planos escolhidos para execução, e um interpretador que funciona como mecanismo de inferência.
O mecanismo de inferência manipula estes componentes e seleciona um plano adequado baseado nas crenças e objetivos do sistema, inserindo- o na estrutura de intenções e o executando.
Objetivos (Desejos).
Os Objetivos (Goals) de um agente PRS são expressos na forma de e o equivalente a uma seqüência condições sobre um intervalo de tempo, que no de estados de mundo, descritos como operações temporais sobre descrições de estado (ver estados de mundo e operações temporais em).
Objetivos descrevem tarefas e comportamentos desejados, que podem ser expressos na lógica do PRS com os seguintes tipos de objetivo Atingir uma determinada condição(!
Testar uma determinada condição(?
Esperar até que um determinada condição seja verdadeira(^ C);
Manter uma condição verdadeira(&amp; C);
Declarar (Assert) uma condição como verdadeira (C);
Cancelar (Retract) uma condição(\&gt; C);
Concluir que uma determinada condição é verdadeira ($ \&gt; C).
Objetivos são divididos em dois tipos:
Intrínsecos e operacionais.
Objetivos intrínsecos são aqueles que advêm do processo de execução de planos na estrutura de intenções, isto é, não são objetivos intermediários de um objetivo principal.
Em contrapartida, objetivos operacionais são aqueles que representam passos intermediários no cumprimento de um objetivo principal.
De a mesma forma que as crenças, no PRS é possível se estabelecer objetivos de meta-nível, permitindo que se especifique objetivos em relação a o comportamento interno do sistema.
Conhecimento (Knowledge Areas).
Estas especificaáo representadas por um corpo e uma condição de conhecimento procedural.
ACs sativação.
O corpo de uma AC pode ser visto como um plano ou um esquema de plano.
Tal componente é representado por um grafo direcionado com um vértice de início e um ou mais vértices de final.
Os arcos do grafo são rotulados com sub-objetivos a serem atingidos ao longo de a execução do plano.
A execução de uma AC é dita com sucesso quando os arcos que conectam um vértice de início a um vértice de final são percorridos e, no decorrer deste caminho, todos os sub-objetivos especificados foram satisfeitos.
Desta forma, temos que o caminhamento do grafo de uma AC é multi-dimensional, uma vez que os sub-objetivos podem implicar na execução de´ possóutras ACs.
E ivel que algumas ACs não tenham um corpo, neste caso elas são chamadas de ACs primitivas, pois elas têm algum tipo de ação primitiva associada que é diretamente executável por o sistema.
O formalismo de construção de grafos utilizado por os autores permite a criação de estruturas de controle do fluxo de execução, tais como desvios condicionais, iterações e recursões A condição de invocação de uma AC é dividida em duas partes, a Parte Gatilho (Triggering Part) e a Parte de Contexto (Context Part).
A Parte Gatilho de uma condição de invocação é uma expressão lógica que descreve os eventos que devem ocorrer para que a AC seja executada.
Estes eventos podem consistir da aquisição de novos objetivos, caso em que o raciocínio utilizado é orientado a objetivos, ou da modificação das crenças, no caso em que o raciocínio utilizado é orientado a dados ou reativo.
A parte de contexto da condição de invocação especifica as condições que devem ser verdadeiras em relação a o estado atual do sistema para que a AC associada seja executada.
ACs, da mesma forma que crenças e desejos, não se limitam a operar sobre o ambiente que cerca o agente, elas também podem ser utilizadas na manipulação de crenças, desejos e intenções do próprio PRS.
Estas ACs são, portanto, chamadas de ACs de MetaNível.
Um dos objetivos de tais ACs é a modificação do comportamento padrão do interpretador do PRS no tratamento do raciocínio do agente.
Isto pode incluir a modificação de planos durante a execução, o estabelecimento de novos objetivos ou mesmo a modificação das crenças durante a execução de uma AC de meta-nível.
Estrutura de Intenções.
A estrutura de intenções contém todas as tarefas que o sistema escolheu para execução imediata ou posterior, estas tarefas são chamadas de intenções[ Geo 89 a, GEO 89b].
Uma intenção é composta de uma AC escolhida para cumprir um objetivo, junto com todas as sub-ACs que forem necessárias para que se complete a execução da AC inicial.
As intenções na estrutura de intenções podem estar ativas, suspensas ou serem adiadas, esperando, por exemplo, que uma condição se torne verdadeira.
Existe uma intenção propriamente dita para cada objetivo intrínseco que está sendo perseguido, e para cada intenção existe uma pilha de ACs a serem executadas de modo a atingir- la.
As ACs incluídas na estrutura de intenções estão parcialmente ordenadas com, possivelmente, mais de uma AC ocupando a raiz da estrutura de intenções.
A ordem estabelecida para execução das ACs escolhidas é obedecida de forma que, para que ocorra a execução de uma AC subseqüente na estrutura, é necessário que as ACs anteriores sejam cumpridas ou retiradas.
Nao há diferenciação quanto a a natureza das ACs dentro de a estrutura de intenções, desta forma, ACs de meta-nível não são tratadas de modo diferente das ACs regulares no processamento.
O comprometimento com as intenções é implementado no PRS na medida em que, uma vez escolhida uma determinada AC para o cumprimento de um objetivo, não serão consideradas outras ACs cuja condição de ativação for satisfeita, a não ser que a AC atual se torne inviável.
Ou seja, o PRS se compromete com o plano de ação determinado por uma AC escolhida, sendo que ele só irá considerar outras maneiras de cumprir com o objetivo caso a maneira inicial se torne impossível.
Interpretador do Sistema.
O interpretador é o responsável por a interação dos componentes do PRS, sendo o seu processo de operação o mais simplificado possível de modo a garantir o menor tempo de reação possível no sistema.
Considerando os objetivos e as crenças existentes num dado momento, uma ou mais ACs podem se tornar passíveis de execução, sendo que uma ou mais destas serão escolhidas para serem adicionadas à estrutura de intenções (i.
e serem escolhidas para execução).
Para verificar se as ACs serão executadas, o interpretador utiliza apenas o processo de unificação das suas condições de execução com as crenças do sistema.
Os autores salientam que, caso fosse utilizado qualquer outro processo de inferência mais complexo, não seria mais possível provar que o tempo de execução do processo de escolha de ACs é limitado.
Para realizar processos de inferência mais complexos, i.
e Funcionamento do PRS O funcionamento do PRS foi projetado para ser o mais simples possível, permitindo um funcionamento pré-definido mesmo sem qualquer informação de alto-nível sobre o seu processo de raciocínio.
Em contrapartida, é possível adicionar informações de meta-nível ao sistema a fim de refinar o comportamento do sistema, ao mesmo tempo em que se mantém o limite do tempo de reação do processo básico.
Ciclo do Interpretador.
O principal processo que norteia o funcionamento do PRS é determinado por o interpretador do sistema visto no centro da Figura 2.5.
Este processo é responsável por a seleção de ACs de modo a reagir a mudanças no ambiente, cumprir com os objetivos estabelecidos por o processo de aquisição e abandono de intenções, ou ainda para avançar na execução de uma AC previamente selecionada.
Um esquema do processo de funcionamento do interpretador do PRS pode ser visto na Figura 2.6.
O interpretador do PRS inicia o seu ciclo de execução utilizando como base o conjunto de objetivos e crenças contidas na sua base de dados.
As ACs conhecidas por o sistema são analisadas tentando- se unificar as condições de invocação destas com as crenças e os objetivos estabelecidos;
ACs, algumas são selecionadas para serem de fato executadas.
Estas ACs são inseridas na estrutura de intenções com base no seguinte critério:
Se a AC foi selecionada devido a aquisição de um novo objetivo intrínseco ou de uma nova crença, então esta AC será inserida na estrutura de intenções como uma nova intenção, caso contrário (i.
e a AC foi selecionada como resultado de um objetivo operacional), ela será inserida na pilha de ACs que compreendem a intenção correspondente.
O passo seguinte é a escolha de uma intenção na raíz da estrutura de intenções para que seja executado mais um passo da mesma.
Este passo pode ser o estabelecimento de um ou mais novos objetivos ou a execução de uma ação primitiva.
A execução de uma ação primitiva pode resultar na mudança da base de crenças do sistema tanto por ser uma ação de meta-nível como 1 Objetivos e Fatos Novos Eventos externos Inserindo Sub-- Objetivo Novo AC Grafo:
AC Ação Biblioteca de Procedimentos Inserindo Meta--Fatos Ação Primitiva Ativação e Unificação (overpressurized FRCS)(! (
position valve close) Parte de Invocação:
Parte de Invocação: (overpressurizedx) Parte de Invocação:
Parte de Invocação:
Invocation Part: Parte de Invocação:(! (
position switchx) Action Part:
Estados das Intenções. Uma intenção no PRS pode estar em três estados possíveis:
Ativa, suspensa ou suspensa condicionalmente.
Uma intenção suspensa pode ser executada assim que ela se tornar uma raiz na estrutura de intenções.
Uma intenção suspensa foi adotada por o sistema, mas não há definição de quando ela deve ser executada, portanto ela deve ser ativada explicitamente antes de ser executada.
Uma intenção suspensa condicionalmente está suspensa temporariamente até que uma dada condição de ativação seja atingida.
A suspensão de uma intenção pode ser realizada através de ACs de meta-nível.
Quando uma intenção suspensa é reativada, é necessário que o sistema decida se a estrutura de intenções deve ser reorganizada ou nao.
Esta reorganização pode ser feita através de ACs de meta-nível, porém o comportamento padrão do interpretador do PRS é priorizar a execução das intenções reativadas a fim de minimizar o tempo de reação ao evento que causou tal reativação.
Estabelecimento e Abandono de Objetivos.
Como descrito anteriormente, as intenções são inseridas na estrutura de intenções devido a mudanças nos objetivos ou nas crenças.
Como resultado desta inserção, outros sub-objetivos também podem ser inseridos na estrutura de intenções.
A possibilidade de falha destes objetivos deve ser tratada.
Desta forma´ determinar como o sistema deve reagir caso uma falha ocorra, decidindo que curso de ação alternativo deve ser tomado a fim de se atingir o objetivo.
Em contrapartida, deve- se determinar quando um objetivo que falhou se tornou impossível de ser atingido, i.
e que não existe outra maneira de atingir- lo.
Dificilmente será possível provar em tempo de execução que um objetivo se tornou ivel devem ser incluídas no agente a fim de tratar impossível, portanto ACs de meta-n*´ da questão de caminhos de execução alternativos.
Em a falta destes, o PRS executará exatamente uma vez cada uma das ACs que poderiam cumprir um dado objetivo.
Em este caso, ainda é possível incluir ACs de meta-nível para lidar com a falha de todos os planos disponíveis para cumprir um determinado objetivo, talvez re-considerando um plano específico cuja re-execução pareça mais promissora numa segunda vez.
O PRS foi utilizado como base para uma variedade de implementações do modelo BDI.
Ele também evoluiu em diferentes trabalhos visando a resolução de suas limitações iniciais.
Dois dos descendentes diretos mais notáveis do PRS são o dMARS e o AgentSpeak, cujos objetivos principais são, respectivamente, criar uma definição formal de um sistema baseado em agentes que fosse adequada para implementação, e definir formalmente uma linguagem de especificação de agentes e sua semântica.
Estes trabalhos são descritos resumidamente nas Seções 2.4.3 e 2.4.4.
O distributed Multi-Agent Reasoning System (dMARS) é uma implementação do PRS utilizada como referência para a criação de uma especificação formal do sistema na linguagem Z.
Esta especificação modela uma implementação ideal do dMARS, declarando implicitamente que não existe garantia de equivalência entre a especificação e a implementação utilizada como base.
O sistema descrito em utiliza a mesma noção de crenças do PRS, ou seja, a utilização de literais rasos (ground) da lógica de primeira ordem clássica.
O dMARS reduz o número de tipos possíveis de objetivos dos sete presentes no PRS para objetivos de realização(!
E consulta (ou teste)(?,
redefinindo os objetivos de declaração e cancelamento na forma de ações internas (internal actions), chamadas, respectivamente, de ação de adição (add) e remoção (remove).
Em o dMARS também é formalizada a interação com o ambiente através da noção de ações externas (external actions), que são utilizadas para realizar operações arbitrárias definidas por o programador do sistema.
De a mesma forma que o PRS original, as intenções no dMARS são representadas por os planos adotados atualmente, i.
e as ACs escolhidas para execução.
Os eventos que desencadeiam a adoção de uma nova intenção foram expandidos, além de a adição e remoção de crenças e do estabelecimento de um novo objetivo o dMARS também considera a recepção cão de planos no de uma mensagem como evento de inclusão de intenções.
A defini¸ dMARS é realizada através de uma versão formalizada dos grafos de planos do PRS, sendo que os dois componentes da condição de invocação de um plano no PRS foram refinados em noções de relevância e aplicabilidade.
Uma das maiores contribuições da formalização do dMARS é a definição sem ambigüidade de um algoritmo de interpretação.
AgentSpeak A linguagem AgentSpeak (AgentSpeak (L)) foi criada a fim de diminuir a distância entre a teoria e a prática de agentes BDI.
Esta distância é resultante de diversos fatores[ RAO 96, D'I 98 b], como por exemplo o enfraquecimento da base teórica de um agente resultante da simplificação das implementações, ou a tênue relação entre as lógicas utilizadas nas teorias com problemas reais.
Desta forma, o objetivo de diminuir esta distância deveria ser alcançado através de uma especificação formal dos agentes que seria utilizada para embasar uma implementação dos mesmos.
Tal funcionamento deveria corresponder ao funcionamento das implementações do PRS e uma linguagem de programação baseada em e do dMARS.
AgentSpeak (L) ém um linguagem de primeira-ordem restrita que contém eventos e ações, onde os componentes do modelo BDI não são representados na forma de fórmulas modais explícitas.
Apesar de AgentSpeak (L) ter sido concebida com o intuito de prover um embasamento teórico mais forte para sistemas já implementados como o PRS e o dMARS, este objetivo não pode ser considerado completamente alcançado, visto que AgentSpeak (L) contém diversas simplificações em relação a o PRS.
Estas simplificações também foram aplicadas ao dMARS, como pode ser observado na em disto, quando o dMARS foi posteriormente especificado, sua especificação formal.
Al´ nenhum esforço para relacionar- lo com o AgentSpeak (L) pôde ser percebido.
Desta forma, estes dois trabalhos podem ser considerados mais como trabalhos paralelos do que formalismos equivalentes, como pode ser verificado numa especificação refinada do AgentSpeak (L).
As simplificações mais significativas observadas no AgentSpeak (L) em relação a o PRS sao:
Tipos de objetivos:
Em AgentSpeak (L) é possível declarar objetivos de alcance e teste de condições no mundo, além de isto, é possível declarar e cancelar condições no mundo através das ações básicas do AgentSpeak (L).
O que resulta na diminuição da expressividade da linguagem relacionada ao modelo formal de AgentSpeak (L), visto que não estão mais presentes objetivos de manutenção e espera por uma condição;
Componentes de Meta--nível: Em AgentSpeak (L) não é possível especificar componentes de meta-nível como é feito no PRS, limitando a flexibilidade de definição do comportamento de um determinado agente.
O modelo X-BDI de agentes foi proposto com o objetivo de ser simultaneamente uma fer´ 99 b, Mor´ 99 a].
Tal motivação se deve ao fato de que os modelos formais de agentes BDI são tradicionalmente especificados através de lógicas modais, as quais não possuem procedimentos de derivação corretos e completos.
Além de isto o tratamento computacional destas lógicas, apesar de decidível é um problema de alta complexidade.
Apesar de também ser uma ferramenta de desenvolvimento de agentes, o X-BDI é antes de tudo, um modelo formal de agentes.
O fato deste modelo ser também uma ferramenta é um efeito colateral da sua implementação utilizando PROLOG, o resultado disto é que ambiente de execução (i.
e o PROLOG), também funciona como um ambiente de especificação de agentes.
Desta forma o autor optou por a utilização da programação em lógica estendida com negação explícita (ELP -- Extended Logic Programming) com a semântica bem-fundada estendida com a negação explícita (WSFX -- Well--Founded Semantics Extended for the explicit negation) como´ 99 a].
A construção do sistema numa linguagem interpretada com uma implementação de referência significa que a especificação dos agentes também é executável, o que elimina o problema das discrepâncias na transposição dos modelos formais para uma implementação.
Além de isto a WSFX possui um procedimento de derivação correto e top-down chamado de derivação seletiva linear para programas estendidos (SLX -- Selected Linear resolution for extended programs).
Para uma explanação mais detalhada da ELP veja.
O X-BDI utiliza uma variedade de propriedades da ELP para a construção do seu modelo BDI.
Em especial a capacidade que este modelo lógico tem de lidar com contradições permite diversas formas de raciocínio nao-tonotônico, de as quais são destacados o raciocínio revogável e o raciocínio abdutivo.
Estes dois modelos de raciocínio são utilizados na construção das crenças, no caso de o raciocínio revogável, e dos desejos e intenções, no caso de o raciocínio abdutivo.
A representação do agente e suas propriedades é feita através de uma variante do Cálculo de Eventos (Event Calculus) adaptada para a ELP e modificada para permitir eventos simultâneos.
As crenças do agente são definidas como um programa consistente B. Os desejos de um agente são representados através de uma cláusula temporal suportada por uma conjunção de cláusulas que funciona como uma pré-condição para o desejo.
As intenções do agente são geradas em tempo de execução e são divididas em dois tipos:
Intenções primárias e intenções relativas.
Estas intenções estão relacionadas respectivamente com o comprometimento do agente e com a execução de um plano de ações, resultado do planejamento.
A principal contribuição do X-BDI é a especificação de um modelo executável de agente.
Entretanto, O X-BDI não foi implementado com preocupações de performance e sua utilização em situações com tempo restrito é limitada.
Considerações Este capítulo descreveu de maneira cronologicamente ordenada algumas teorias e implementações de agentes BDI.
Pode- se dizer que o modelo BDI como teoria computacional foi proposto inicialmente com o trabalho descrito na Seção 2.3.1, que estabeleceu diversas propriedades e relações entre os componentes filosóficos da teoria de Bratman, sem no entanto desenvolver as especificidades da descrição do funcionamento contínuo de um agente BDI ao longo de o tempo.
Tal trabalho fez uso extensivo de lógica modal e suas propriedades no embasamento do formalismo e na ponderação sobre ele, uma característica que foi herdada por a lógica BDICT L, descrita na ogica estendeu a anterior no raciocínio temporal utilizando um modelo infinito Seção 2.3.2.
Esta l´ de tempo ramificado no futuro e adicionando a noção de utilidade utilizada em teoria da decisao.
Em a lógica BDICT L, o agente analisa a possibilidade de alcançar os seus desejos e a recompensa que eles trarão ao agente antes de escolher o conjunto de desejos que irá gerar as suas intenções.
Desta forma a BDICT L diverge do modelo de Cohen e Levesque, na medida em que o agente irá ter o conhecimento do seu plano de ação antes de iniciar a execução das ações na direção de um objetivo.
Esta abordagem, entretanto, assume que o agente irá ponderar sobre todos os caminhos de ação possíveis antes de tomar uma decisão através de um procedimento baseado ntableau, o que é claramente indesejável considerando- se um agente com recursos limitados, tornando- a portanto inadequada para implementação, fato este corroborado por os seus autores.
Um ponto importante explorado por ambas as teorias apresentadas na Seção 2.3 é a condição de adoção e abandono dos desejos.
Desejos são adotados quando o agente acredita que o desejo é possível e são abandonados quando a agente acredita que eles são impossíveis.
A noção a ligada ao code possibilidade de um desejo na teoria de Cohen e Levesque est´ nhecimento do agente da primeira ação que deve ser tomada na direção do cumprimento deste desejo.
Esta noção deixa implícito que, ou o agente tem conhecimento das ações necessárias para o cumprimento de um desejo, ou o agente dispõe de uma maneira de &quot;prever «que uma ação qualquer eventualmente irá concretizar um desejo.
A noção de possibilidade na lógica BDICT L está associada a um caminhamento na árvore temporal do mundo onde o agente se encontra que leve o agente do estado de mundo atual até o estado onde o desejo do agente está satisfeito.
Esta noção parte do pressuposto que o agente tem o conhecimento de todos os estados de mundo possíveis e do resultado de seqüências das suas ações na criação destes estados, o que é conhecido como onisciência do agente.
Considerando as arquiteturas descritas neste capítulo, observa- se que tanto IRMA (Seção derivados formalmente das teorias apresentadas na Seção 2.3.
Entretanto, sua implementação serviu de base para a verificação empírica dos aspectos considerados na definição das teorias e descrito o X-BDI, que subseqüentes, e.
g a de Cohen e Levesque e a BDICT L.
Em a Seção 2.4.5, çonsiste de uma teoria e sua descrição no formalismo utilizado em sua implementação.
Uma característica presente nas arquiteturas IRMA, PRS, dMARS e AgentSpeak (L) é a presença de uma biblioteca de planos utilizada na formação das intenções.
Em a IRMA esta biblioteca &quot;é considerada parte das crenças do agente, e especifica que ações o agente acredita serão úteis cão deixa implícito para atingir quais efeitos sob determinadas condições».
Esta defini¸ que o agente será capaz de selecionar ações a fim de concretizar seus objetivos, subentendendo um processo de planejamento e, ou o agente será capaz de seqüenciar- las para atingir objetivos de longo prazo, ou o agente já tem o conhecimento das seqüências de ações que ele irá utilizar na sua interação com o ambiente.
Em o PRS a biblioteca de planos ou ACs &quot;descreve como certas seqüências de ações e testes podem ser executadas para atingir determinados objetivos ou reagir a situações específicas».
A definição do PRS é mais restrita no sentido da capacidade de planejamento do agente, o que é resultado da crença dos seus autores de que a formação de planos em tempo de execução é inviável, e do seu objetivo de ter um limite de tempo definido para o processo de deliberação.
O X-BDI parte de uma abordagem diferente para a formação das intenções utilizando um processo de abdução para formar uma teoria de ações em Cálculo de Eventos que irão constituir a base para as intenções adotadas por o agente.
Este processo é análogo a um processo de planejamento, uma vez que ele encadeia ações para estabelecer a ligação da situação atual do agente com os seus desejos.
A noção de possibilidade dos desejos em ambos os sistemas está ligada a existência de um plano em suas bibliotecas de planos que o satisfaça, considerando a situação atual do ambiente onde o agente se encontra.
Um outro aspecto em comum é que a impossibilidade de um desejo sóé considerada uma vez que o plano escolhido para satisfazer- lo falha, sendo que na definição original do PRS os autores afirmam que é extremamente difícil para o agente provar que um determinado objetivo é impossível com o conhecimento que o agente tem em tempo de execução.
Em contrapartida, no X-BDI, a possibilidade de um desejo é validada por o seu processo de geração de intenções, atrelando- à a existência de uma teoria de ações que corrobore com a validade do desejo num futuro determinado.
A impossibilidade de um desejo está ligada ao surgimento de alguma inconsistência na teoria de ações inferida por o agente, o que pode ocorrer quando de a modificação das crenças do agente em relação a o estado atual do mundo.
Analisando os trabalhos descritos neste capítulo e as conclusões estabelecidas nesta seção, pode- se observar que a formação de planos é um processo importante no contexto dos agentes BDI.
Esta importância independe do momento em que estes planos são gerados, pois tanto no momento da criação do agente (e.
g IRMA e PRS), quanto no momento da execução do agente (e.
g X-BDI) a sua consistência é de importância fundamental para que o agente possa atingir os objetivos para o qual foi projetado.
A prova de que um agente será capaz de atingir seus objetivos é um dos principais problemas em aberto na pesquisa em agentes deliberativos, tendo o problema sido descrito por Wooldridge como Agent Design Problem.
Este problema é notório por sua alta complexidade para o caso geral, resultando em modelos de agente que, ou delegam esta verificação para o seu projetista, ou realizam esta verificação antes da execução do agente.
Entretanto, a pesquisa na formação de planos utilizando o cão de algoritmos com formalismo de planejamento proposicional tem observado a criaéxcelente desempenho em diversos domínios.
Desta forma se for possível utilizar tal formalismo no processo de raciocínio meios-fim de agentes deliberativos, é possível aproximar a classe de problemas tratáveis por estes formalismos.
Planejamento Proposicional Como visto no Capítulo 2, o raciocínio meios-fim, i.
e a habilidade de decidir que ações executar a fim de realizar um conjunto de objetivos, é um componente fundamental de qualquer agente racional.
Este tipo de raciocínio envolve a formação de planos que serão utilizados por o agente a fim de atingir seus objetivos.
A formação dos planos pode ocorrer de maneira estática, antes da execução do agente, ou em tempo de execução.
Em ambos os casos é necessário que estes planos estejam corretos no sentido de permitir ao agente atingir seus ao é um problema trivial, objetivos, o que é chamado de Agent Design Problem.
Este n~ tendo complexidade PSPACE para o caso geral.
O processo de formação de planos é comumente realizado por sistemas de planejamento em sua origem reconhecida no sistema STRIPS (Stanford Research Institute Para o, que t^ blem Solver), cuja contribuição mais perene é a linguagem de especificação de problemas.
Este tipo de sistema representa uma abordagem bastante utilizada na implementação de agentes em de ser útil na resolução de problemas em diversas outras áreas, por deliberativos, aléxemplo escalonamento.
Algoritmos de planejamento têm sido um dos principais objetivos da pesquisa em Ia pois o processo de formação e execução de planos é considerado fundamental no funcionamento de agentes inteligentes.
Genericamente, um problema de planejamento é definido por três componentes:
Uma descrição formal do estado inicial;
Uma descrição formal dos objetivos que se deseja concretizar;
Uma descrição formal das ações que podem ser realizadas.
Estes componentes serão fornecidos ao sistema de planejamento, que deverá gerar um conjunto de ações com alguma relação de ordem, que, quando aplicadas a um mundo onde a descrição do estado inicial é verdadeira, deverão tornar a descrição de objetivo verdadeira.
O formalismo utilizado para representar problemas de planejamento neste trabalho será melhor explorado na Seção 3.1.
Apesar de as características de complexidade provadas para o caso geral dos problemas de planejamento, avanços recentes na pesquisa em planejamento levaram à criação de algoritmos de planejamento cujo desempenho para diversas classes de problemas é significativamente melhor do que aproximações anteriores.
Os algoritmos referidos pertencem a duas classes:
Algoritmos baseados no Graphplan;
Algoritmos baseados na compilação do problema de planejamento numa fórmula cuja satisfação é testada (SAT).
Este trabalho irá se concentrar na extensão de um modelo de agentes BDI, a fim de dotar- lo da capacidade de utilizar sistemas de planejamento proposicionais para a realização do raciocínio meios-fim utilizado no processo de seleção de intenções.
A utilização de planejadores proposicionais é motivada por os avanços em termos de algoritmos de planejamento ocorridos recentemente.
O algoritmo escolhido para a implementação do protótipo é o Graphplan.
Sua escolha se deve ao fato de que até onde se sabe, existe uma variedade maior de trabalhos relacionados ao seu encia de mais informações no aprimoramento, e.
g planejamento em tempo real, infer^ grafo de planejamento, entre outros, que podem ser incorporadas numa implementação do algoritmo.
Este capítulo aborda os algoritmos de planejamento utilizados na implementação realizada para este trabalho.
A Seção 3.1 descreve o formalismo que foi utilizado para definir o domínios dos problemas tratados por o Graphplan.
A Seção 3.3 descreve o algoritmo Graphplan básico, suas principais fases de processamento e estruturas de dados, e é finalizada com algumas definições em relação a garantias que o Graphplan fornece para o término do algoritmo.
Formalismos de Planejamento Proposicional Esta seção descreve o formalismo utilizado por os planejadores considerados neste trabalho.
Este formalismo é baseado na descrição presente em, sendo, de acordo com o referido autor, um formalismo SIL, isto é, o formalismo STRIPS básico acrescido da possibilidade de especificações incompletas do estado inicial e da utilização de literais na descrição dos estados de mundo.
A fim de manter este trabalho auto-contido, as definições relevantes serão replicadas a seguir.
E importante salientar que o formalismo definido por Nebel é mais abrangente, porém, como o objetivo deste trabalho não é um estudo detalhado de formalismos de planejamento, utilizaremos uma versão mais simples de tal formalismo.
Em especial, utiliza- se uma linguagem de lógica proposicional com variáveis apenas nas especificações de operadores, além de não permitirmos efeitos condicionais nos mesmos.
Considera- se inicialmente o alfabeto do formalismo.
Define- se como o conjunto contável infinito de átomos proposicionais ou variáveis proposicionais e qualquer subconjunto finito de^ o conjunto de literais sobre, i.
e´. A partir de isto define- se como atomos e átomos negados.
A linguagem de lógica proposicional sobre o conectivo lógico e os átomos proposicionais é denotada por L, desta forma, consistindo apenas de conjunções de literais.
Considerando um conjunto L de literais, neg (L) e pos (L) são respectivamente o subconjunto de literais negativos e positivos de L. Um estado s é uma atribuição-verdade para os átomos em, e uma especificação de estado S é um subconjunto de, ou seja, é uma teoria lógica composta apenas de literais.
S é dita consistente se ela não contém literais complementares, e dita completa se p (p S¬ p S).
Uma especificação de estado representa todos os estados s tais que S| $= s, ou seja, estes estados são os modelos possíveis para S;
Quando uma especificação de estado é completa, ela possui apenas um modelo.
Operadores são pares o $= pre, post, onde pre (o) L e post (o) L denotam respectivamente as pré-condições e as pós-condições (ou efeitos) do operador o.
Em o Exemplo 3.1 um domínio simples é descrito com este formalismo.
Exemplo 3.1 (Robô-Carteiro) Consideramos um domínio onde existe um robô-carteiro, que, quando recebe pacotes, os envia ao local correto, e quando está sem bateria, se recarrega.
O estado do mundo gira em torno de a presença ou não de pacotes e da carga do robô.
Como conjunto de átomos, temos:
Como operador de envio dos pacotes temos:
Que essencialmente significa que ao enviar um pacote, o robô gasta sua bateria.
Como operador de recarga do robô temos:
O resultado da aplicação de um operador num estado de mundo é dado por a função de cão define que, se as pré-condições de transição de estado descrita na Definição 3.1.
Esta fun¸ um operador são válidas e seus efeitos não resultam em contradição, então os literais declarados como negativos nos efeitos do operador se tornam falsos e os literais declarados como positivos se tornam verdadeiros logo após a aplicação do operador ao estado.
Definição 3.1 (Função de Transição de Estado) Uma Função de Transição de Estado o, induzida por o operador o é definida da seguinte forma:
S --¬ neg (post (o)) pos (post (o)) se s| $= pre (o) e post (o)| $= indefinido caso contrário o:
A aplicação de operadores sobre especificações de estado resulta em novas especificações de estado, como definido por a função R (Definição 3.2), que define o resultado da aplicação de um operador o de um conjunto de operadores O sobre uma especificação de estado.
Definição 3.2 (Função R) O resultado da aplicação de um operador o sobre uma especificação de estado S é definido por:
R (S, o) S --¬ neg (post (o)) pos (post (o)) se S| $= pre (o) e S| $= e post (o)| $= caso contrário A aplicação de um operador o sobre uma especificação de estado S é caracterizada por uma função R, cujo resultado é S --¬ post (o), se as pré-condições pre (o) forem verdadeiras em S. Ou seja, a aplicação de um operador o sobre uma especificação de estado resulta num novo estado onde as pós-condições negativas do operador deixam de ser verdadeiras e as póscondições positivas passam a ser verdadeiras.
Utilizando- se a função R e considerando- se O como o conjunto de seqüências finitas de operadores, tem- se que os elementos de O são chamados de planos.
Desta forma, é possível definir recursivamente uma função da aplicação de sobre uma descrição inicial de estado S da seguinte forma:
Definição 3.3 (Resultado de um plano) O resultado da aplicação sucessiva de operadores sobre um estado inicial é definido por:
Res (S,) Res Utilizando-se a função Res, define- se:
Definição 3.4 (Instância de Planejamento) Uma instância de planejamento é uma tupla $ , I, G, onde: $ ,
O é a estrutura do domínio, que consiste de um conjunto finito de átomos proposicionais e um conjunto finito de operadores O;
Definição 3.5 (Plano) Uma seqüência de operadores é dita um plano para, ou a solução de, sse Res (I,)| $= e Res (I,)| $= G. Uma seqüência de operadores é dita um plano para, ou a solução de, sse Res (I,) não for inconsistente e suportar G. De esta forma, tem- se que uma função de planejamento é definida como:
Definição 3.6 (Função de Planejamento) Uma função de planejamento é definida por:
P lan:
Se e é solução de caso contrario Observando- se as definições desta seção, percebe- se que os planejadores considerados tratam apenas de átomos.
Porém no contexto deste trabalho é desejável maior expressividade, em es´ poss´ pecial, a possibilidade de utilizar literais de, pelo menos primeira ordem.
E ivel evitar estas limitações.
Para tanto utiliza- se transformações sintáticas, a fim de que tais planejadores operem sobre domínios descritos com literais de primeira ordem, desde que observando as seguintes restrições:
As especificações de estado I e G só podem ser feitas através de literais ground 1;
As descrições de operadores não podem criar novos literais através das suas pós-condições.
Compilação para SAT As primeiras abordagens de planejamento se baseavam no conceito de planejamento como prova de teoremas, entretanto, esta abordagem não obteve resultados promissores de início.
Desta forma, consideravam- se necessários algoritmos específicos para a realização de planejamento na Literais sem variáveis livres.
O funcionamento básico deste tipo de algoritmo inicia com um compilador recebendo um problema de planejamento como entrada.
Este compilador supõe um tamanho de plano, e gera uma fórmula em lógica proposicional, que, se satisfeita, implica na existência de um plano que representa a solução do problema proposto.
Uma tabela de símbolos guarda a correspondência entre as variáveis proposicionais criadas na compilação e a instância de planejamento recebida como entrada.
Um processo de simplificação utiliza técnicas rápidas (de complexidade linear) para reduzir a fórmula em CNF (Conjunctive Normal Form) criada por o compilador, tais como propagação de cláusulas unitárias (Unit- Clause propagation) e eliminação de literais puros (Pure Literal Elimination).
O resolvedor utiliza métodos sistemáticos ou estocásticos para encontrar uma atribuição satisfatória para as variáveis da fórmula compilada.
Se esta atribuição for encontrada, o decodificador traduz esta atribuição de variáveis, utilizando a tabela de símbolos, para um plano proposicional.
Se o resolvedor determina que a fórmula é insatisfatível, então o compilador gera uma nova codificação refletindo um plano mais longo.
Este processo de criação sistemática de codificações proposicionais mais longas é análogo ao processo de expansão do grafo de planejamento do Graphplan.
Em este algoritmo o planejamento é baseado no conceito de Grafo de Planejamento, que é uma estrutura de dados onde é armazenada informação a respeito de o problema de planejamento de forma que a busca por a solução possa ser acelerada.
O Grafo de Planejamento não é um grafo do espaço de estados, o qual pode ser extremamente grande.
Diferentemente do grafo do espaço de estados, onde um plano é um caminho através do grafo, um plano no Grafo de Planejamento é essencialmente um fluxo, no sentido de um fluxo numa rede.
Grafos de Planejamento podem ser construídos rapidamente, sendo a complexidade de tamanho do grafo e do tempo de construção polinomial em relação a o tamanho do problema.
Este grafo é então utilizado por o planejador na busca por uma solução para o problema de planejamento utilizando os dados armazenados no grafo para acelerar o processo.
O algoritmo básico do Graphplan (i.
e sem as otimizações adicionadas por outros autores) é dividido em duas fases distintas, expansão do cão da solução (Seção 3.3.2), como visto na Figura 3.2.
Em as próximas grafo e extra¸ seções utilizaremos como base o problema descrito no Exemplo 3.2.
Exemplo 3.2 Problema do Robô-Carteiro em STRIPS start(¬ batt, package) goal (batt,¬ package) operator post preconds (batt, package) effects(¬ batt,¬ package) operator recharge preconds(¬ batt) effects (batt) Em o problema do Exemplo 3.2, criado utilizando o domínio do Exemplo 3.1, tem- se no estado inicial o robô-carteiro sem bateria e um pacote que deve ser encaminhado, e no estado final deseja- se que o robô encaminhe o pacote e esteja com a sua bateria carregada.
Expansão do Grafo O Grafo de Planejamento é direcionado e nivelado, ou seja, os nodos do grafo podem ser divididos em conjuntos disjuntos de modo que as arestas conectem apenas nodos em níveis adjacentes.
Considerando o fato de que um plano é composto por ações organizadas temporalmente, e, entre estas ações existem estados de mundo, os níveis no grafo são divididos em níveis de proposições e de ações, alternadamente.
Níveis de proposições são compostos por nodos de proposição rotulados com proposições.
Estes nodos são conectados aos nodos de ação no nível de ação subseqüente através de arcos de pré-condição.
Nodos de ação são rotulados com operadores e são conectados aos nodos do nível de proposição subseqüente por arcos de efeito.
Cada nível de proposição denota os literais possivelmente verdadeiros num dado momento, de modo que o primeiro nível de proposição representa os literais possivelmente verdadeiros no tempo 1, o nível de proposição seguinte representa os literais possivelmente verdadeiros no tempo 2 e assim por diante.
Os níveis de ação denotam os operadores que podem ser executados num dado momento no tempo de modo que o primeiro nível de ação representa os operadores que poderiam ser executados no tempo 1, e assim por diante.
Os níveis de ação podem conter qualquer um dos operadores definidos no domínio de planejamento.
Além destes operadores, um conjunto de operadores de manutenção de proposições é gerado automaticamente para as proposições do problema;
Estes operadores têm um único literal como pré-condição e o mesmo literal como efeito.
Estes operadores são chamados de no op ou frame.
O primeiro nível L0 num Grafo de Planejamento é um nível de proposição equivalente à especificação do estado inicial.
Em a primeira expansão do grafo, o nível L1 será composto dos operadores que poderiam ser executados dadas as proposições de pré-condição presentes no nível anterior.
Em o nível L2 são incluídas todas as proposições presentes nos efeitos dos operadores no nível L1.
Expansões subseqüentes do grafo ocorrem da mesma maneira, isto é, tomando um nível de proposição Li, tal que i é par, como referência, é adicionado um nível de ação Li+ 1 contendo todos os operadores cujo conjunto de pré-condições está presente no nível Li, os nodos de proposição no nível Li são conectados aos nodos de ação apropriados através de arcos de pré-condição.
A seguir, é adicionado um nível de proposição Li+ 2 contendo todas as proposições presentes nos efeitos de cada operador em Li+ 1.
Os nodos de ação em Li+ 1 são´ importante salientar conectados às proposições apropriadas em Li+ 2 através de arcos de efeito.
E que, dado o conjunto de operadores de manutenção inseridos no conjunto de operadores, cada proposição presente num dado nível de proposição Li estará presente no nível de proposição Li+ 2 subseqüente através do operador no op criado para aquela proposição.
Um efeito desta propriedade do Grafo de Planejamento é que o número de proposições nos níveis pares aumenta monotonicamente, uma vez que as proposições ou serão adicionadas através dos operadores do domínio de planejamento ou serão trazidas do nível anterior por operadores de manutenção.
Além de isto, dada a monotonicidade no número de proposição, é trivial concluir que o número de operadores nos níveis de ação também aumenta monotonicamente.
Suporte Inconsistente Além de informação relativa a pré-condições e efeitos, o grafo de planejamento contém relações de exclusão mútua (mutex) entre os nodos num mesmo nível do grafo.
As relações de exclusão mútua têm um papel fundamental na eficiência do algoritmo.
Uma relação de exclusão mútua entre dois nodos significa que estes (i.
e seus operadores ou proposições correspondentes) não podem estar presentes simultaneamente num dado nível do grafo na mesma solução, isto é, duas proposições não podem ser verdadeiras no mesmo ponto no tempo, ou dois operadores não podem ser executados simultaneamente no mesmo passo do plano.
Operadores podem ser mutuamente exclusivos por dois motivos (Figura 3.3):
Interferência: Se um operador possui uma pré-condição ou efeito que representa a negação de uma pré-condição ou efeito de outro operador, então eles são mutuamente exclusivos devido a interferência;
Necessidades Concorrentes: Se existe um operador A com uma pré-condição Pa e um operador B com uma pré-condição Pb que é mutuamente exclusiva de Pa num nível de proposição anterior, então A e B são ditas mutuamente exclusivas.
Nodos de proposição também podem ser mutuamente exclusivos por dois motivos básicos.
Primeiro, uma proposição é mutuamente exclusiva com sua negação.
Além de isto, uma proposição pé mutuamente exclusiva de uma proposição q se todas as maneiras de se atingir p são exclusivas de todas as maneiras de se atingir q..
Mais especificamente, se não existem dois operadores, ou um único operador que satisfaça ambas as proposições, que possam ser executados para satisfazer p e q, então estas duas proposições são mutuamente exclusivas devido a Suporte Inconsistente (Figura 3.3).
Um exemplo de grafo de planejamento pode ser visto na Figura 3.4.
Retângulos representam ações e elipses representam proposições, arcos representam relações de exclusão mútua e linhas representam os vértices do grafo.
A Figura 3.4 contém exemplos de relações de exclusão mútua.
O operador post é mutuamente exclusivo em relação a o operador recharge por interferência, pois post resulta em¬ batt e recharge resulta em batt.
Além de isto, no nível 3 do grafo, os operadores nop-batt e nopbatt possuem necessidades concorrentes.
Isto é, um de eles necessita que¬ batt seja verdadeiro no nível de proposição anterior e o outro que batt seja verdadeiro e estas proposições são mutuamente exclusivas.
Em o nível 4 do grafo da Figura 3.4 tem- se um exemplo de proposições mutuamente excludentes por suporte inconsistente entre as proposições batt e¬ package.
Isto ocorre pois não existem dois operadores que possam ser executados no nível 3 do grafo e que resultem em ambas as proposições.
A importância das relações de exclusão mútua não reside simplesmente na sua aplicação a cada nível do grafo no processo de extração de solução, mas também no fato de que propriedades importantes sobre o problema analisado são propagadas através do grafo durante a sua expansao.
Um dos principais fatores aos quais é atribuída a efiCiência do Graphplan é a complexidade polinomial da fase de expansão do grafo tanto em tempo de execução como em tamanho do grafo.
Isto é provado através do Teorema 3.1.
Este teorema foi modificado a fim de se adequar ao formalismo utilizado neste trabalho, uma vez que o formalismo utilizado originalmente no Graphplan é o STRIPS e neste trabalho utiliza- se o STRIPS com literais nas definições de estado.
Apesar de esta mudança no formalismo, as propriedades do algoritmo permanecem válidas.
Teorema 3.1 Considerando um problema de planejamento com n objetos, p proposições no estado inicial e m operadores cada um com um número constante de parâmetros formais.
Seja l o tamanho da maior lista de efeitos positivos de qualquer um dos operadores do problema.
Então, o tamanho de um grafo com t níveis criado por o Graphplan, e o tempo necessário para criar- lo são polinomiais em n, m, p, l e t..
Extração da Solução Após a expansão do grafo, ocorre a segunda fase do Graphplan, chamada de extração da solução.
Ela utiliza uma estratégia de encadeamento reverso que atravessa o grafo nível por nível tentando encontrar um fluxo a partir de os objetivos que leve às condições iniciais.
Um fator de otimização importante aplicado a esta fase é nunca buscar uma solução a não ser que todas as proposições do objetivo estejam presentes e sejam consistentes, i.
e que não sejam mutuamente exclusivas, no último nível do grafo.
O algoritmo de extração da solução tenta, recursivamente, encontrar para cada nível, um conjunto de proposições ou ações consistentes que leve ao nível anterior do grafo até que a condição inicial no nível zero do grafo seja alcançada.
Especificamente, o algoritmo inicia a busca no último nível Li do grafo utilizando os objetivos do problema como objetivos daquele nível.
Então, para cada objetivo, é escolhido um operador em Li-1 que o satisfaça, e que seja consistente com os demais operadores escolhidos, este operador é chamado de ponto de suporte.
No caso de um objetivo sob análise já ter sido alcançado por um operador previamente escolhido, não é necessário adicionar um novo operador para satisfazer- lo.
Quando pontos de suporte para todos os objetivos num nível forem selecionados, as précondições destes operadores são utilizadas como objetivos a serem alcançados no nível Li-2, até que o algoritmo tenha atingido o nível zero do grafo, caso em que o algoritmo encontrou um plano válido.
Uma vez que o algoritmo é chamado recursivamente sempre que um ponto de suporte para um objetivo for selecionado, se um plano incluindo um dado ponto de suporte não for encontrado, outros operadores são escolhidos até que todos os operadores possíveis num dado nível de ação tiverem sido tentados.
Quando todas os operadores possíveis para um dado objetivo tiverem sido tentados sem sucesso, o algoritmo retorna falso.
Se esta falha ocorreu no último nível i do grafo, então o algoritmo provou que nenhum plano com ou menos níveis de ação existe para o dado problema.
A fim de acelerar o processo de busca por uma solução, os conjuntos de ações utilizadas como ponto de suporte só são utilizados nas recursões do algoritmo se eles forem conjuntos mínimos de ações (minimal action sets).
Um conjunto de ações não exclusivas A no tempo t-1 é dito mínimo para o cumprimento de um conjunto de objetivos G em tempo t, se e somente se:
Além de isto, uma das principais otimizações adicionadas ao algoritmo de extração de solução descrito na Figura 3.5 é a utilização da técnica de memoização, que é uma técnica algorítmica que consiste no armazenamento de uma resposta previamente computada para reuso posterior, ao invés de re-computar- la.
Esta técnica é utilizada no Graphplan da seguinte forma:
Quando um conjunto de objetivos num dado nível do grafo é provado insolúvel, ele é memoizado numa tabela antes do retorno da recursao.
O algoritmo, então, antes de tentar chamar a função recursiva de extração de solução para um dado conjunto de objetivos, irá consultar esta tabela para verificar se o conjunto em questão já não foi provado insolúvel.
Caso este conjunto seja encontrado na tabela, o algoritmo retorna falso ao invés de continuar a busca.
O algoritmo modificado com todas estas otimizações é mostrado na Figura 3.6.
No caso de o problema do Exemplo 3.2, o algoritmo de extração de solução irá concluir que o plano-solução é composto por a seqüência de ações recharge, post e recharge.
O primeiro teste se baseia no aumento monotônico do número de nodos de proposição a cada nível do grafo e da redução monotônica do número de relações de exclusão mútua entre eles.
Devido a as operações de manutenção, sempre que uma proposição ocorrer num nível do grafo, ela necessariamente irá ocorrer em todos os níveis futuros.
Também devido a as operações de manutenção, sempre que um par de proposições não for marcado como mutuamente exclusivo num nível, ele nunca será marcados como tal em níveis futuros.
Isto ocorre pois a única maneira de proposições serem marcadas como exclusivas, além de serem logicamente opostas, seria a inexistência de ações que pudessem alcançar- las simultaneamente.
Entretanto, sempre que duas proposições forem marcadas como nao-exclusivas, as operações de manutenção utilizadas para transpor- las para o nível seguinte não poderão ser exclusivas, sendo que esta propriedade irá se manter no grafo ad infinitum.
Desta forma, estas propriedades de monotonicidade, aliadas ao tamanho finito da base de Herbrand dos problemas de planejamento considerados, garantem que existirá um ponto no processo de expansão do grafo onde os níveis de proposição serão sempre iguais a cada nova expansao.
Em este ponto, diz- se que o grafo se estabilizou, o que pode ser visto como um ponto fixo da operação de expansão do grafo.
Em o momento em que o grafo se estabilizou, se uma proposição contida nos objetivos do problema não estiver presente no último nível do grafo, ou se duas proposições dos objetivos estiverem marcadas como mutuamente exclusivas, é possível afirmar que não existe nenhum plano que cumpra os objetivos propostos para o problema proposto.
Esta propriedade é facilmente observada na medida em que, se os nodos de proposição nunca irão conter mais proposições ou menos relações de exclusão mútua, então não poderá ocorrer uma expansão do grafo que gere os objetivos necessários ou elimine as relações de exclusao.
Considerando as condições de início da extração de solução, nenhuma tentativa de executar- la irá ocorrer neste caso, pois o grafo nunca terá atingido um ponto onde ela pudesse ser executada.
O primeiro teste permite que se determine de maneira extremamente rápida a inexistência de solução para um grande número de problemas, mas não garante que o algoritmo irá determinar a insolubilidade para todos os problemas possíveis.
A fim de resolver esta limitação, os autores utilizam a tabela de memoização para postular o Teorema 3.2 Teorema 3.2 O Graphplan retorna &quot;Nenhum plano existe «se e somente se o problema é insolúvel.
Considerações A escolha do Graphplan como algoritmo de planejamento neste trabalho se deu por a existência, até onde se sabe, de uma quantidade maior de trabalhos relacionados ao Graphplan e sua extensãostress 98, SMI 98, SMI 99, WEL 99, LON 00].
Tais trabalhos subseqstress uentes aperfeiçoaram o algoritmo original do Graphplan, incorporando a ele diversos avanços no campo de planejamentostress 98, LON 00], em especial através do pré-processamento dos problemas de proposicional[ KOH planejamento para eliminar informação irrelevante e da inferência de mais informações dentro de o grafo de planejamento.
A versão do Graphplan implementada neste trabalho não incorpora todos estes aperfeiçoamentos, entretanto é importante salientar que o desempenho obtido empiricamente na implementação proposta pode ser melhorado através de versões mais avançadas do Graphplan.
Além de isto, o Graphplan possui uma série de características que o destacam dos outros algoritmos de planejamento considerados em relação a a sua aplicabilidade em sistemas multi-agentes.
Uma das principais características dos planos gerados por o Graphplan é a representação da possibilidade de execução de ações em paralelo.
Esta possibilidade é resultado da análise das relações de exclusão mútua nível-a-nível na fase de extração de solução.
Desta forma, um agente que tenha condições de executar múltiplas ações simultaneamente pode se beneficiar deste tipo de plano.
Além de isto, o algoritmo de extração de solução não apenas é correto e completo, mas também fornece a garantia de que o plano gerado é o mais curto possível, considerando a ocorrência de ações em paralelo.
Além de a exploração do paralelismo num agente, o grafo de planejamento e a tabela de memoização podem ser armazenados por o agente entre as execuções do planejamento.
A informação contida nestas estruturas permite que o agente possa reaproveitar- las caso ele deseje verificar a existência de planos para múltiplos objetivos dada uma mesma situação inicial, evitando a reconstrução do grafo atéoúltimo nível verificado na execução anterior do algoritmo.
Uma possibilidade levantada por o autor é que tal informação também poderia ser utilizada por o agente em algum tipo de processo de aprendizado sobre o domínio onde ele opera.
Finalmente, acredita- se que o Graphplan tem o potencial de prover um procedimento eficiente no processo de construção da árvore temporal utilizada na lógica BDICT L.
Esta hipótese leva em consideração a noção de Conformant Plans definida numa extensão do Graphplan que considera a incerteza do agente em relação a a sua situação em múltiplos estados de mundo.
BDI é um modelo de agentes BDI definido com o intuito de criar um modelo formal de´ 99 aMOR ancias entre definição e implementação.
A fim de atingir este objetivo, utilizou- se um formalismo chamado de Extended Logic Programming (ELP), o qual possui uma implementação de referência que provê um ambiente operacional para a execução de programas definidos neste formalismo.
Este capítulo irá descrever o modelo X-BDI de agentes definido por Móra et al.[
Mor numa descrição resumida do Framework Lógico utilizado no embasamento do Seção 4.1 cont´ modelo X-BDI e a Seção 4.2 descreve o modelo de agentes propriamente dito, sendo o processo de deliberação do agente descrito na Seção 4.3.
Em o final do capítulo uma breve discussão sobre as limitações do modelo de agente original e possíveis melhorias é apresentada.
Framework Lógico A programação em lógica tem sido utilizada largamente em implementações na área de Ia devido a sua natureza declarativa, o que a torna bastante adequada no processo de transposição de modelos teóricos para implementações.
A implementação do modelo de agentes X-BDI foi realizada utilizando uma extensão da programação em lógica chamada de Programação em Lógica Estendida com Negação Explícita, ou ELP, que estende a lógica normal ao permitir a representação de fatos explicitamente falsos.
Este formalismo possui um modelo semântico próprio, descrito na Seção 4.1.1, e um procedimento de derivação e prova de predicados diferenciado, descrito Seção de lidar com a contradição de um programa.
Semântica WFSX A semântica W SF X (Well--Founded Semantics EXtended) objetiva dar significado a programas em ELP.
Este modelo semântico estende a semântica WFS (Well--Founded Semantics) incluindo a negação explícita.
A característica principal da W F SX é a definição do significado de qualquer programa não contraditório em ELP através da noção de stable models.
Procedimento SLX lógica normal, desta forma, as noções de derivação, refutação e falha são bastante semelhantes a este procedimento.
Entretanto, a SLX trata do problema das derivações infinitas presente na Revisão de Cláusulas na SLX Como visto na Seção 4.1.1, a W SF X é capaz de executar programas nao-contraditórios.
Entretanto, a utilização de uma lógica com negação explícita pressupõe a possibilidade de contradições num programa, visto que um programa pode, num dado momento, conter em seu modelo o mesmo literal na sua forma positiva e negativa.
Desta forma, não é suficiente poder executar programas nao-contraditórios, também é necessário encontrar e tratar as contradições possíveis num programa.
Conseqüentemente, os autores da SLX propõem um procedimento de detecção de contradição que utiliza uma versão paraconsistente da semântica W SF X, chamada de W F SXP.
A W F SXP tem o objetivo de calcular de forma coerente todas as conseqüências de um programa, inclusive aquelas que levam a contradição, ou resultam de ela.
Através deste cálculo é gerado um conjunto de literais ditos básicos, os quais são considerados a origem da contradição num programa.
A este conjunto de literais é aplicado um procedimento que altera os valores-verdade de alguns dos literais pertencentes ao conjunto de modo que a contradição é removida.
Além de modificar o programa para remover contradições relacionadas com o uso da negação explícita, a SLX define um mecanismo para especificar contradições relacionadas com determinados estados de um programa em lógica.
Este mecanismo é baseado em restrições de integridade que, quando violadas, causam a revisão do programa de modo que o programa não contenha mais o estado de programa declarado como contraditório.
Modelo do Agente´ 99 aMOR e um modelo formal de agentes, a implementação de seus processos de funcionamento pode ser concretizada de múltiplas maneiras.
Entretanto, a maneira escolhida por o autor foi a utilização do formalismo ELP descrito na Seção 4.1.
A união da especificação formal com a implementação do framework lógico empregado resulta num conjunto de processos que implementam a lógica BDI formulada para o modelo X-BDI.
Esta seção tem por objetivo apresentar as principais definições formais que descrevem o comportamento de um agente X-BDI.
O X-BDI é um modelo de agentes baseado na teoria de raciocínio prático de Bratman, utilizando as intenções como componente necessário para o raciocínio em agentes com recursos limitados.
Desta forma, o processo de raciocínio de um agente neste formalismo é centrado na construção de um conjunto de intenções que irá, em última instância, definir que cursos de ação ele utilizará para cumprir seus objetivos.
Um esquema de funcionamento do processo de formação de intenções e seus estados intermediários pode ser visto na Figura 4.1.
Os estados intermediários presentes na Figura 4.1 são formados a partir de uma descrição do agente que é utilizada para compor a estrutura cognitiva de um agente X-BDI, que é descrita por a Definição 4.1:
Definição 4.1 (Estrutura Cognitiva do Agente) A estrutura cognitiva de um agente X-BDI é uma tupla Ag $= B, D, I, T Ax, onde:
Bé o conjunto de crenças do agente;
Dé o conjunto de desejos do agente;
Ié o conjunto de intenções do agente;
T Ax é o conjunto de axiomas de tempo;
Um agente X-BDI possui os componentes tradicionais de um agente BDI, i.
e um conjunto de Crenças, Desejos e Intenções.
Além de isto, dada a sua definição em lógica estendida, ele possui também um conjunto de axiomas de tempo definidos a partir de uma variação do Cálculo de éventos.
A versão do Cálculo de Eventos utilizada no X-BDI é descrita na Definição 4.2.
Definição 4.2 (Axiomas de tempo T Ax) Predicados básicos:
Em este contexto o predicado holds at (P, T) indica que uma propriedade P é verdadeira no tempo T, o predicado happens (E, Ti, Tf) indica que um evento E ocorre entre o tempo Ti e o tempo Tf.
O predicado initiates (E, TP, P) denota que uma propriedade P passa a ser verdadeira a partir de o tempo TP através de um evento E. O predicado persists (TP, P, T) denota que uma propriedade P é verdadeira a partir de o tempo TP até pelo menos o tempo T.
O predicado clipped (TP, P, T) significa que ocorre um evento qualquer entre o tempo TP e o tempo T que torna uma propriedade P falsa.
O predicado sense (E, Ti) indica que um evento E ocorre no tempo Ti, representando o sensoriamento por o agente de alguma mudança no ambiente.
O X-BDI utiliza um processo de raciocínio abdutivo para verificar a possibilidade de um determinado conjunto de desejos.
Este processo é muito semelhante a um processo de planejamento backward chaining, visto que o processo de abdução tenta encontrar uma teoria de ações em cálculo de eventos que torne as propriedades especificadas nos desejos verdadeiras.
A fim de encadear os predicados do cálculo de eventos, um conjunto de regras de integridade é fornecido na Definição 4.3.
Definição 4.3 (Regras de integridade para abdução de predicados) -- happens, happens (E, T2i, T2f), not.
O conjunto de crenças que compõe a estrutura cognitiva do agente é definido da seguinte:
Definição 4.4 (Conjunto de Crenças) As crenças de um agente são o programa consistente em lógica estendida B, i.
e B| $= P.
Um agente A acredita que uma propriedade P é válida no tempo Desta forma, o conjunto de crenças é simplesmente uma formalização de fatos em programação lógica individualizados para um agente em específico.
Além de a definição do conjunto de crenças, é relevante a definição do processo de manutenção da consistência na base de crenças.
Revisão de Crenças A revisão de crenças no X-BDI está ligada ao processo de revisão de literais na SLX, uma vez que é assumido que a base de crenças esteja sempre consistente como decorrência do funcionamento da SLX.
Desta forma, assim que um evento modifique a base de crenças de forma que esta se torne inconsistente, o processo de revisão de literais da SLX irá garantir que a base de crenças seja modificada de forma que se torne consistente e realizando o menor número de modificações possível.
Este processo está diretamente associado aos predicados happens/ 3 e sense/ 2, uma vez que estes são os únicos predicados associados a modificação da base de crenças do agente através dos atos do agente e de eventos percebidos do ambiente, respectivamente.
Desta forma, a revisão de literais da SLX será ativada sempre que um destes dois predicados estiver envolvido numa derivação.
O componente seguinte na estrutura cognitiva do agente é o conjunto de desejos, que é definido da seguinte forma:
Definição 4.5 (Conjunto de Desejos) O conjunto de desejos de um agente é o conjunto de sentenças na forma:
T é um ponto no tempo, Ag é o identificador do agente, e Atr é uma lista de atributos.
Body é qualquer conjunção de literais.
Um agente deseja no tempo T que uma propriedade P seja verdadeira no tempo TD sse:
Observando a forma das sentenças que definem os desejos, pode- se notar que os desejos, representados em regras de programação em lógica, são condicionados por o corpo da regra (Body).
Desta forma, os literais componentes de Body podem ser vistos como pré-condições para que um agente deseje uma determinada propriedade, uma vez que tais literais devem ser verdadeiros para satisfazer a implicação Body Desejo1.
No caso de Body ser vazio, temos que o agente deseja que a propriedade P seja verdadeira incondicionalmente, já que, neste caso, o desejo será um fato (i.
e Desejo) do ponto de vista de programação em lógica.
Além de isto, o agente pode desejar alguma propriedade num ponto específico de tempo no caso de a variável TD estar associada a um ponto no tempo.
A variável Atr corresponde a um lista de atributos que especificam a prioridade do desejo, que é utilizada no processo de escolha dos desejos.
A viabilidade de um desejo é verificada através de raciocínio abdutivo.
Utilizando uma teoria T, composta por as crenças do agente, e um conjunto de observações O representando as propriedades que se deseja concretizar, o processo de abdução tenta encontrar uma teoria tal que T| $= O, e tal que T seja consistente.
Esta teoria é formada utilizando um conjunto de literais marcados como abdutíveis por a ELP, que no caso de o X-BDI são as ações do agente.
Desta forma, a possibilidade de um conjunto de desejos é comprovada por a existência de um conjunto de ações que possa justificar a validade das propriedades desejadas por o agente.
Definição 4.6 (Conjunto de Intenções) As intenções de um agente no tempo T são o conjunto:
Onde Desejo equivale a holds at (des (D, Ag, P, TD, Atr), T) onde I é o identificador da intenção, P é a propriedade que se deseja tornar verdadeira, Ag é um agente, Atr é uma lista de atributos, Act é uma ação, e Ti é o tempo em que a intenção deve ser concretizada, e tal que:
O item 1 da Definição 4.6 apresenta os dois tipos possíveis de intenção no X-BDI, que sao:
A o pode querer algo no exploradas na Seção 4.3.2.
Os itens 2 e 3 estipulam que um agente n~ passado.
O item 4 estipula que um agente não pode ter a intenção de realizar algo que já seja verdadeiro.
A última restrição sobre o conjunto de intenções é que um agente não tem intenções as quais ele acredita serem impossíveis.
Uma propriedade importante desta definição é que ela evita o problema do pacote (Problema 2.4) ao não permitir que efeitos colaterais de uma intenção afetem a adoção futura de novas intenções ou causem a reconsideração do conjunto de intenções.
Processo de Deliberação no X-BDI Esta seção contém as definições relativas ao processo deliberativo de um agente X-BDI.
Este processo inicia com a seleção dos desejos que o agente irá tentar satisfazer, os quais irão determinar as intenções com as quais o agente irá se comprometer (Seção 4.3.2).
Estas intenções irão guiar as ações do agente até que o agente as tenha satisfeito, ou até que ele tenha que reconsiderar- las (Seção 4.3.3).
Seleção dos Desejos O processo de raciocínio dos agentes X-BDI inicia na escolha dos desejos elegíveis.
Desejos elegíveis são os desejos que o agente acredita não estarem satisfeitos e que são possíveis.
O conjunto de desejos de um agente (vide Definição 4.6) não está sujeito a nenhuma restrição, e, portanto, pode conter desejos contraditórios;
O conjunto dos desejos elegíveis também não está sujeito a este tipo de restrição.
Definição 4.7 (Desejos Elegíveis) Seja D o conjunto de desejos de um agente.
O seguinte conjunto é chamado de desejos elegíveis no tempo T:
N ow T (B| $= P Body) A definição dos desejos elegíveis estipula restrições de racionalidade semelhantes às estabelecidas para as intenções no sentido de que um agente não irá desejar nada no passado, e nem algo que o agente acredite que irá se concretizar sem a sua interferência.
Além de isto, as crenças do agente devem suportar a pré-condição do desejo estabelecida no corpo (Body) da definição do mesmo.
No decorrer de o processo de raciocínio do agente, este irá utilizar o conjunto dos desejos elegíveis (que podem ser mutuamente contraditórios) para gerar subconjuntos de desejos mutuamente consistentes.
Para possibilitar ao agente a escolha de um destes conjuntos, uma relação´ 99 b].
Definição 4.8 (Relação de Preferência dos Desejos ref) Seja D o conjunto de desejos de um agente, D o conjunto de desejos elegíveis de D, P (D) o conjunto potência2 de D e R, S P (D).
Diz- se que R ref S (R é menos preferido do que S) se o maior valor de importância que ocorre em S e não ocorre em R é maior do que o maior valor de importância que ocorre em R e não ocorre em S;
Se não existir tal valor maior em S, então R é menos preferido do que S se S possuir mais elementos do que R. Exemplo 4.1 (Escolha de Desejos) Considere o seguinte conjunto de desejos elegíveis:
Então a ordem de preferência dos elementos do conjunto potência de D é:
Ou seja, a relação de preferência de desejos coloca o conjunto com o desejo mais importante antes dos demais conjuntos. Como
critério secundário de organização dos elementos na relação é utilizado o tamanho dos conjuntos.
Entretanto, esta relação não organiza os sub-conjuntos de desejos elegíveis de modo que nenhum conjunto tenha a mesma importância que todos os outros.
Logo, tem- se que a relação de preferência de desejos não é uma relação de ordem total, isto é, não é possível estabelecer uma relação entre qualquer par de elementos do conjunto, por exemplo, os mostrado na Figura 4.2.
Uma vez que há a possibilidade de nem todos os desejos serem mutuamente consistentes, é necessário uma forma de marcar no programa quais serão os desejos válidos em determinado momento, após estabelecido o sub-conjunto dos desejos que serão utilizados por o agente.
Para realizar isto, cada desejo tem associado a si um literal default chamado de unsel (D), onde D é o identificador do desejo associado a este literal.
Estes literais serão revisados no momento da escolha dos desejos candidatos.
Definição 4.9 (Grafo de Preferência dos Desejos) Sejam D o conjunto de desejos de um agente, D o conjunto de desejos elegíveis de D, a função de sucessor.
Seja Revisable o conjunto:
O grafo de preferência dos desejos é utilizado na geração de um grafo de revisões preferidas.
A raiz deste grafo propõe revisões apenas nos literais act/ 3 e happens/ 3, ou seja, ele dá preferência para as revisões advindas da abdução dos planos para concretizar todos os desejos simultaneamente.
Entretanto, como visto anteriormente, o conjunto de todos os desejos pode não ser mutuamente consistente, desta forma a relação de preferência dos desejos é utilizada para gerar os níveis subseqüentes deste grafo, estabelecendo que os desejos menos preferidos devem ser eliminados antes através do posicionamento dos literais unsel (D) associados aos desejos menos preferidos, isto é, aqueles com número de importância menor, ou pertencentes a um conjunto com menos desejos, mais próximos da raiz do grafo de preferência de revisões.&amp;&amp;&amp;
Além de isto, o fato da relação de preferência dos desejos não ser uma relação de ordem total requer a definição de método determinístico para determinar quais serão os desejos escolhidos no processo de raciocínio.
O processo de seleção dos desejos candidatos no X-BDI objetiva escolher de entre os desejos elegíveis, um conjunto cujos desejos são mutuamente consistentes e viáveis.
Um desejo viável é um desejo que apresenta um conjunto de ações cujo resultado seja a validade de uma propriedade P associada a um desejo.
Definição 4.10 (Conjunto dos Desejos Candidatos) Sejam D o conjunto de desejos de um agente e D o conjunto de desejos elegíveis de D com um grafo de preferência associado a ele.
Chama- se conjunto de desejos candidatos qualquer conjunto:
Onde· as restrições IC geradas por as intenções (vide definição 4.6) A seleção dos desejos candidatos é o processo mais complexo do modelo X-BDI.
A fim de escolher um subconjunto de desejos elegíveis que seja mutuamente consistente é utilizado o processo de revisão de literais da SLX.
Utilizando o grafo de revisões preferidas (Definição provar sistematicamente a possibilidade de satisfação dos conjuntos com maior prioridade até que se obtenha a prova de que um destes conjuntos é possível.
Em este caso, os desejos pertencentes a este conjunto irão constituir o conjunto de desejos candidatos.
Se todos os conjuntos forem testados, e a possibilidade de nenhum de eles puder ser provada, então o conjunto de desejos candidatos será vazio.
Os literais da teoria gerados por o processo de abdução constituem um plano de alto nível que indicam ao agente como satisfazer as propriedades P associadas aos desejos candidatos.
Estes literais não levam em consideração o refinamento do plano de alto nível até o nível de ações concretas, nem as contradições que podem ser geradas por a execução deste plano.
O X-BDI evita o problema do efeito colateral descrito por Bratman em.
O problema é evitado na medida em que as ações produzidas por o processo de abdução não são consideradas contraditórias caso seus efeitos se cancelem.
Em a realidade, uma revisão do programa só irá ocorrer se uma ação a necessária para satisfazer uma intenção i cancelar uma propriedade P que também é uma intenção (i.
e é a propriedade associada a uma intenção), uma vez que ao cancelar esta propriedade, a restrição de integridade utilizada para abduzir o curso de ação para se chegar a P, em específico a restrição P será violada.
Formação das Intenções Uma vez definido o conjunto de desejos candidatos, o agente irá se comprometer em tentar satisfazer- los.
Este comprometimento é representado através de intenções, que no X-BDI são divididas em dois tipos:
Intenções primárias e intenções relativas.
As intenções primárias são essencialmente a transposição do conjunto de desejos candidatos escolhidos DC para novos predicados que representam as intenções do agente.
As intenções primárias serão utilizadas no processo de refinamento das intenções até que o agente possua um plano de ações concreto, que quando executado, resulta no cumprimento das propriedades desejadas.
Intenções primárias são definidas´ 99 b]:
Definição 4.11 (Intenções Primárias) Sejam D o conjunto dos desejos do agente, D C o conjunto de desejos candidatos de D. As intenções primárias de um agente é o conjunto:
As intenções primárias podem ser vistas como planos de alto nível representando o comprometimento do agente com um determinado curso de ação.
Conseqüentemente, o agente irá limitar o seu esforço de raciocínio ao cumprimento destes objetivos ao invés de reavaliar os seus desejos constantemente.
A maneira de concretizar este comprometimento sofrerá refinamentos atéo ponto onde o agente possui um conjunto de ações ordenadas no tempo, representando um plano concreto para a realização de um objetivo.
O resultado final do processo de refinamento das intenções primárias é representado por as intenções relativas.
As intenções relativas correspondem aos passos de planos concretos e ordenados no tempo visando a satisfação das intenções primárias estabelecidas anteriormente.
Definição 4.12 (Intenções Relativas) Seja IP o conjunto de intenções primárias.
O processo de planejamento é um procedimento que, para cada i IP, irá gerar um conjunto Ir de ações ordenadas temporalmente que alcança i, tal que B T Ax IP Ir é nao-contraditório.
O conjunto Ir são as intenções relativas do agente.
Em a definição observa- se que as intenções relativas compõem os sub-planos relativos ao cum´ 99 b].
A noção do comprometimento do agente com as primento das intenções primárias[ Mor intenções primárias escolhidas é atingida através da necessidade que as intenções relativas têm de serem não contraditórias em relação a as intenções primárias.
Revisão de Intenções Os processos de raciocínio utilizados por a implementação em ELP do X-BDI são muito custosos na medida em que se baseiam fortemente na revisão de literais, cuja ênfase na implementação foi facilitar a prova de propriedades ao invés de obter eficiência computacional.
Desta forma, é interessante que a reconsideração do curso de ação de um agente X-BDI não ocorra constantemente´ 99 b].
A alternativa proposta por o autor foi a utilização de restrições de integridade que, geradas no momento da definição das intenções, funcionam como gatilhos para a sua revisao.
Conseqüentemente, o agente não precisará re-avaliar seu curso de ação de maneira constante, sendo que esta re-avaliação irá ocorrer automaticamente no momento que as restrições de integridade forem violadas.
Definição 4.13 (Restriço~ es-Gatilho das Intenções) Sejam B o conjunto de crenças do agente e I suas intenções.
Sao adicionadas a B as seguintes restrições-gatilho:
N ow T, not rev intRestriço~ es-Gatilho dos Desejos) Sejam D o conjunto dos desejos do agente e D o conjunto dos desejos elegíveis de D. Define-se restrições-gatilho dos desejos como:
Para cada (des (D, Ag, P, TD, Atr) Body) D e não pertencente a D com importância A maior do que a maior importância nas intenções, define- se a restrição-gatilho Body, not rev int;
Dado o conjunto de ações abduzido por o agente, para cada A partir de as definições 4.13 e 4.14 tem- se que a reconsideração das intenções é baseada em gatilhos, que são representados na forma de restrições de integridade na base de crenças.
Uma vez que a base de crenças sofre um processo de revisão sempre que for atualizada através dos predicados happens/ 3 e sense/ 2 (Seção 4.2), tem- se que a cada revisão de crenças é possível que uma destas restrições seja violada.
Em o momento em que uma restrição de integridade relacionada aos gatilhos das definições 4.13 e 4.14 for violada, o processo de deliberação será reiniciado.
Considerações O objetivo inicial do X-BDI de constituir um modelo de agentes que pudesse ser diretamente executado foi atingido na medida em que a sua especificação em ELP pode ser interpretada por a implementação da ELP em Prolog.
Desta forma, teoricamente elimina- se as possíveis discrepâncias entre especificação e implementação.
Entretanto, a possibilidade de falhas na implementação da ELP significa que nem todas as propriedades definidas no modelo teórico podem ser verificadas na implementação do X-BDI.
Uma das características mais importantes do X-BDI é a sua capacidade de formar planos em tempo de execução a fim de satisfazer os desejos do agente.
Esta característica está presente num número muito pequeno de trabalhos conhecidos.
Entretanto, a utilização do processo de revisão de literais inúmeras vezes durante a formação de planos resulta na limitação da classe de problemas para os quais o X-BDI é capaz de gerar planos num tempo aceitável.
Esta limitação é resultado, em grande parte, do fato da implementação da SLX não ter sido focada em eficiência, mas sim em facilitar a prova de teoremas sobre as suas propriedades lógicas.
Conseqüentemente, a substituição do processo de planejamento presente no X-BDI original por um processo mais eficiente é desejável na medida que permitirá ao agente tratar um número maior de problemas.
Parte II Descrição do Trabalho X-BDI Estendido Considerando o objetivo deste trabalho de definir um mapeamento entre o raciocínio meios-fim de agentes BDI e planejamento proposicional, escolheu- se o X-BDI como modelo de agentes para a implementação de um protótipo da utilização deste mapeamento.
Desta forma, este capítulo descreve as extensões criadas no modelo X-BDI no sentido de que ele possa utilizar um algoritmo de planejamento proposicional que realize o processo de raciocínio meios-fim.
A Seção 5.1 descreve as modificações realizadas na estrutura cognitiva de um agente X-BDI;
A Seção 5.2 descreve as modificações realizadas no processo de raciocínio do agente para permitir a utilização de um módulo de planejamento externo;
E a Seção 5.3 descreve as alterações necessárias para adaptar os gatilhos de reconsideração do agente às modificações descritas nas seções anteriores.
Finalmente, a Seção 5.4 contém considerações sobre o que foi desenvolvido neste capítulo.
Estrutura Cognitiva do Agente A estrutura cognitiva de um agente X-BDI possui os componentes tradicionais de um agente BDI, i.
e um conjunto de Crenças, Desejos e Intenções.
Além de isto, dada a sua definição em lógica estendida, ele possui também um conjunto de axiomas de tempo definidos a partir de uma´ 99 b, KOW 86].
Em a extens~ variação do Cálculo de Eventos[ Mor ao proposta neste trabalho, as definições de crenças e desejos na estrutura do agente permanecem as mesmas do X-BDI original.
Entretanto, a estrutura cognitiva do agente é alterada para que a mesma acomode a existência de um módulo de planejamento externo.
Definição 5.1 (Estrutura Cognitiva do Agente) A estrutura cognitiva modificada de um agente X-BDI é uma tupla Ag $= B, D, I, T Ax, P lan, onde:
Bé o conjunto de crenças do agente;
Dé o conjunto de desejos do agente;
Ié o conjunto de intenções do agente;
T Ax é o conjunto de axiomas de tempo;
P lan é uma função de planejamento proposicional (Definição 3.6).
Considerando- se que as intenções são o resultado do processo de raciocínio meios-fim de um agente, sua definição deve acomodar a sua origem num plano proposicional (Definição 5.2).
Definição 5.2 (Conjunto de Intenções) As intenções de um agente no tempo T formam o conjunto:
Cálculo de Eventos que a tornasse verdadeira (Definição 4.6).
Este processo essencialmente realizava o planejamento de um curso de ações para realizar a propriedade.
Em a extensão definida neste trabalho, modifica- se o processo de planejamento a fim de abstrair- lo da definição operacional do X-BDI, permitindo que qualquer processo de planejamento que satisfaça as condições da Definição 3.6 seja utilizado no X-BDI.
Processo de Raciocínio do Agente. O processo de raciocínio realizado por o X-BDI é iniciado com a seleção dos Desejos Elegíveis, que representam os desejos cuja pré-condição foi satisfeita e que ainda não estão satisfeitos.
A seguir, são gerados os Desejos Candidatos, que representam um conjunto consistente e possível de Desejos Elegíveis, que serão adotados como Intenções Primárias.
A fim de satisfazer as Intenções Primárias, o processo de planejamento cria uma seqüência de ações ordenadas no tempo que constituem as Intenções Relativas.
Desejos Elegíveis possuem restrições de racionalidade similares àquelas impostas sobre as intenções no sentido de que um agente não desejará algo no passado ou algo que o agente acredite que ocorrerá sem sua interferência.
As crenças do agente também devem suportar as pré-condições do desejo definidas no Body.
Em o processo de raciocínio do agente, estes desejos darão origem a subconjuntos mutuamente consistentes organizados segundo uma relação de ordem parcial.
O processo de seleção de Desejos Candidatos busca escolher de entre os Desejos Elegíveis, um subconjunto contendo apenas desejos possíveis e internamente consistentes.
Um desejo possível é aquele que possui uma propriedade P que pode ser satisfeita através de uma seqüência de ações.
A fim de escolher entre múltiplos conjuntos de Desejos Candidatos, o X-BDI faz uso de construções da ELP que permitem definir revisões preferidas.
Desta forma, o X-BDI define uma relação de preferência dos desejos a partir de um conjunto de revisões preferidas gerado com base nas prioridades dos desejos.
Através desta relação de preferência, um grafo de preferência de desejos é gerado relacionando todos os sub-conjuntos de Desejos Elegíveis.
Definição 5.3 (Conjunto dos Desejos Candidatos) Sejam D o conjunto de desejos de um agente e D o conjunto de desejos elegíveis de D com um grafo de preferência associado a ele.
Chama- se conjunto de desejos candidatos qualquer conjunto:
Onde $ , PB, Pd é um problema de planejamento criado a partir de as crenças e desejos do agente da seguinte forma:
T (Definição 4.4);
Elegíveis com maior valor de preferência no grafo de preferência de desejos para qual um plano (Definições 3.5 e 3.6) puder ser gerado.
A formação dos Desejos Candidatos é a modificação mais significativa realizada neste traba´ 99 a], onde a possibilidade de um determinado desejo era lhe&amp;lhes o em relação a o X-BDI original[ Mor verificada através da abdução de uma teoria em Cálculo de Eventos onde a crença na validade da propriedade P desejada possa ser verdadeira.
Este processo de abdução é, na realidade, uma forma de planejamento.
Como o objetivo principal deste trabalho é a separação do processo de planejamento antes embutido no X-BDI, a noção de possibilidade de um desejo teve que ser re-definida.
Desta forma, tem- se que um conjunto de Desejos Candidatos é o subconjunto de Desejos Elegíveis com valor de preferência mais alto e cujas propriedades podem ser satisfeitas.
A satisfatibilidade é verificada através da execução de um planejador proposicional tendo como estado inicial do planejamento as propriedades acreditadas no momento do planejamento.
Conseqüentemente, o processo de planejamento é realizado entre a geração dos Desejos Elegíveis e dos Desejos Candidatos, o que pode ser visto na Figura 5.1.
As propriedades P presentes nos Desejos Candidatos são utilizadas na geração do conjunto de Intenções Primárias, que representam o comprometimento do agente com a satisfação das propriedades escolhidas na formação dos desejos (Definição 5.4).
Definição 5.4 (Intenções Primárias) Sejam D o conjunto dos desejos do agente, D C o conjunto de desejos candidatos de D. As intenções primárias de um agente é o conjunto:
Uma vez tendo o agente se comprometido com o cumprimento de determinados objetivos, ele deverá se comprometer com o curso de ações que irão cumprir tais objetivos.
Este comprometimento visa evitar o problema de Buridan, e garantir a execução de um curso consistente de ações por parte de o agente.
Considerando a realização prévia do planejamento proposicional, os passos do plano utilizado por o agente para levar a cabo seus objetivos devem simplesmente ser mapeados do plano proposicional para os estados mentais do agente, como visto na Definição 5.5.
Revisão de Intenções O esforço computacional e o tempo necessário para re-considerar todo o conjunto de intenções de um agente com recursos limitados normalmente é significativo em relação a a taxa de mudança do ambiente.
Desta forma, a reconsideração das intenções não deve ocorrer constantemente, mas apenas quando o mundo muda de forma que seus planos estejam ameaçados, ou quando uma oportunidade de satisfazer objetivos mais importantes se apresenta.
Conseqüentemente, o X-BDI utiliza um conjunto de &quot;gatilhos «de reconsideração gerados no momento da seleção das intenções, e que causam a reconsideração do agente quando ativados.
Estes gatilhos também tiveram que ser atualizados para comportar as novas noções de possibilidade de desejos e intenções, como pode ser visto nas Definições 5.6 e 5.7.
Definição 5.6 (Restrições-Gatilho das Intenções) Sejam B o conjunto de crenças do agente e I suas intenções.
E seja PI um conjunto de propriedades PI sse· N ow T, pPI (holds· N ow\&gt; T, pPI (not at (bel (Ag, P, N ow), T);
As alterações realizadas nos gatilhos de reconsideração do X-BDI visaram permitir a manutenção das condições de reconsideração estabelecidas por Bratman.
Em especial, se todas as Intenções Primárias do agente forem satisfeitas antes do tempo planejado para elas, então o agente irá reiniciar o processo deliberativo, já que atingiu seus objetivos.
Em contrapartida, se uma das Intenções Primárias não tiver sido atingida no tempo planejado, o agente deverá re-considerar suas intenções pois seus planos falharam.
Definição 5.7 (Restrições-Gatilho dos Desejos) Sejam D o conjunto dos desejos do agente e D o conjunto dos desejos elegíveis de D. Define-se restrições-gatilho dos desejos como:
Para cada (des (D, Ag, P, TD, Atr) Body) D e não pertencente a D com importância A maior do que a maior importância nas intenções, define- se a restrição-gatilho Body, not rev int;
Dado o conjunto de ações gerado por o agente (vide Definição 5.3), para cada Ci são as condições que o agente não conseguiu realizar quando de a seleção do conjunto de desejos candidatos.
Se um desejo de prioridade maior do que os desejos escolhidos se tornar possível através de sua pré-condição, então o agente irá re-considerar seus desejos para aproveitar a oportunidade surgida.
A reconsideração é completamente baseada em restrições de integridade sobre as crenças.
Desta forma, na medida em que as crenças são revisadas a cada ciclo de sensoriamento, é possível que uma reconsideração ocorra devido a a ativação dos &quot;gatilhos «de reconsideração.
Considerações O mapeamento entre os estados mentais descritos no formalismo do X-BDI e formalismos de planejamento proposicional tem o potencial de ser aplicado a outros formalismos de agentes BDI.
Uma hipótese levantada ao longo deste trabalho é a utilização deste mapeamento no sentido de implementar a construção da árvore de mundos possíveis utilizadas em sistemas derivados do PRS de maneira computacionalmente aceitável.
O formalismo de planejamento proposicional pode ser utilizado também como uma interface para acesso a uma biblioteca de planos.
Isto significa que, ao invés de o algoritmo de planejamento tentar encadear as ações do agente em tempo de execução, ele pode simplesmente possuir um repositório de planos acessados através de um algoritmo de busca que utilize o estado inicial e o estado final como chaves de busca.
Esta possibilidade representa um possível ponto de intersecção entre os formalismos do PRS e do X-BDI.
Além de isto, a utilização deste tipo de &quot;algoritmo «de planejamento também pode ser utilizada como um método de aprendizado do agente, na medida em que os planos gerados por o agente puderem ser armazenados neste repositório, evitando que o agente tenha de realizar o planejamento em situações que o agente já enfrentou pelo menos uma vez.
Um aspecto da interação do Graphplan com o X-BDI levantado no decorrer deste trabalho é a utilização por o agente das informações sobre o domínio do problema inferidas ao longo de o planejamento.
Mais especificamente, o agente poderia aproveitar de alguma forma as informações deduzidas por o Graphplan e representadas no grafo de planejamento para ampliar o seu conhecimento sobre o domínio de problema onde está agindo.
Em um nível mais básico, o agente poderia guardar este grafo entre as múltiplas execuções do planejamento no momento da escolha dos desejos candidatos, e assim saber que conjuntos de desejos são impossíveis ou mutuamente exclusivos.
Estas informações estão armazenadas na forma de relações de exclusão mútua no grafo de planejamento e dos conjuntos de no--goods na tabela de memoização.
As modificações realizadas no X-BDI alteraram o seu funcionamento de modo que este utilize planejadores proposicionais como base do processo de raciocínio meios-fim e como verificadores de possibilidade no processo de raciocínio prático, como pode ser visto na Figura 5.1.
No decorrer de estas modificações, novas definições de desejos e intenções foram criadas a fim de que o X-BDI mantivesse as propriedades teóricas presentes na sua versão original, em especial no tocante a a definição de possibilidade de desejos e intenções.
Além de isto, foi necessário definir um mapeamento entre os componentes estruturais de um agente BDI e problemas de planejamento proposicionais.
O resultado destas modificações pode ser observado na prática através da implementação descrita no Capítulo 6, e dos estudos de caso descritos no Capítulo 7.
Implementação do Protótipo Considerando o objetivo deste trabalho de integrar uma ferramenta BDI com um algoritmo de planejamento proposicional, e a escolha do X-BDI e do Graphplan, respectivamente, como representantes destes componentes para a implementação de um protótipo, foi necessária a criação de uma arquitetura que comportasse as suas implementações individuais.
Em este sentido, tomouse como base uma implementação em Prolog do X-BDI, que foi modificada com a inclusão dos mecanismos de mapeamento entre os estados mentais do agente para problemas de planejamento proposicional e de planos proposicionais de volta para os estados mentais do agente (Capítulo 5).
Além de isto, uma versão do algoritmo Graphplan foi implementada segundo a descrição original do cão 3.1.
Arquitetura da Implementação O protótipo implementado neste trabalho é composto essencialmente de três partes, o kernel do X-BDI, implementado em Prolog, uma biblioteca de planejamento contendo uma implementação em C+ do Graphplan, e uma interface gráfica em Java utilizada para facilitar a operação do X-BDI e a visualização da interação do mesmo com o ambiente;
Esta arquitetura é esquematizada na Figura 6.1.
Durante o processo deliberativo de um agente X-BDI, é necessário que o agente gere um conjunto de desejos candidatos cuja viabilidade é verificada por um algoritmo de planejamento a realizar o mapeamento das suas crenças e de os (Definição 5.3).
Em este momento o X-BDI ir´ desejos cuja viabilidade deve ser verificada gerando um problema de planejamento que é escrito num arquivo do sistema operacional.
Quando este mapeamento for completado, o X-BDI irá invocar a biblioteca de planejamento, ativando o Graphplan, que tentará encontrar um plano para o problema especificado no arquivo.
Esta invocação é realizada através de um predicado em Prolog que, ao ser consultado, inicia a execução do planejador.
A consulta ao predicado de planejamento tem sucesso no caso de o algoritmo de planejamento encontrar um plano para o problema proposto e falha caso o algoritmo determine que não há solução para tal problema.
Além de isto, quando o algoritmo encontra uma solução para o problema proposto por o X-BDI, o plano resultante é escrito em outro arquivo do sistema operacional.
O X-BDI irá gerar sub-conjuntos de desejos elegíveis consistentes e verificar a existência de um plano que os satisfaça sistematicamente, até que a consulta ao predicado de planejamento tenha sucesso, ou que todos os sub-conjuntos de desejos elegíveis tenham sido provados impossíveis.
Quando um conjunto de desejos elegíveis for gerado, o processo de deliberação do agente procede até a geração das intenções relativas, momento em que o plano gerado por a biblioteca de planejamento é utilizado num processo de mapeamento na geração das intenções relativas (Definição 5.5).
Implementação do Graphplan A versão do Graphplan utilizada neste trabalho usa um formalismo diferente do STRIPS cão básico presente na sua versão original, especificamente, o formalismo da implementa¸ realizada neste trabalho está descrito na Seção 3.1.
A principal diferença deste formalismo em relação a o STRIPS básico é a presença de literais de primeira ordem ao invés de átomos.
A maior expressividade do formalismo não incorre em perda de eficiência do algoritmo, visto que é possível converter os literais de primeira ordem utilizados no formalismo em átomos através de transformações sintáticas, desde que as seguintes restrições sejam observadas:
As especificações de estado I e G só podem ser feitas através de literais ground 1;
As descrições de operadores não podem criar novos literais através das suas pós-condições.
Uma outra modificação da linguagem de descrição do problema utilizada neste trabalho é a atribuição de tipos aos objetos utilizados no problema.
Em o Graphplan original a descrição de problemas permite que os termos num predicado sejam identificados com tipos, permitindo que proposições irrelevantes sejam desconsideradas durante a criação do grafo de planejamento, resultando em aumento de velocidade no algoritmo de extração de solução.
Em a versão do Graphplan implementada para este trabalho os termos de um problema não podem ser tipados, visto que a linguagem utilizada por o X-BDI, i.
e a lógica de primeira ordem do Prolog, não os utiliza.
Entretanto, é possível definir tipos para termos de maneira implícita utilizando o mesmo formalismo do X-BDI, o que resulta num ganho de desempenho do planejador muito semelhante àquele que pode ser obtido com tipos explícitos na linguagem.
Esta técnica de definição de tipos consiste em especificar proposições com o nome do tipo desejado e aplicar- las aos objetos cujo tipo se deseja definir, e então especificar estas propriedades no estado inicial e nas pré-condições dos numa descrição de problema onde os tipos são representados operadores.
O Exemplo 6.1 cont´ desta forma.
Em este exemplo o objeto a é representado como sendo do tipo typeA por o predicado typeA (a), e o parâmetro A do operador typedOper é declarado como sendo do tipo typeA através da pré-condição typeA (A).
Literais sem variáveis livres.
Exemplo 6.1 Utilização de tipos no formalismo de planejamento start (typeA (a), typeB (b), someprop (a), anotherprop (b)) operator typedOper (A, B) preconds (typeA (A), typeB (B), someprop (A), anotherprop (B)) effects (not someprop (A)) O efeito desta solução é delegar a análise de tipos previamente realizada por um pré-processador para o algoritmo de expansão do grafo.
Considerando o fato de que o algoritmo de expansão do grafo tem complexidade linear, o decréscimo em desempenho resultante desta mudança em relação a o Graphplan original não é grande.
Além de isto, o algoritmo de extração de solução não será afetado por a presença de proposições irrelevantes no modelo do problema pois a informação de tipos denotada nos predicados irá evitar que o algoritmo de expansão introduza proposições irrelevantes no grafo de planejamento, ou, pelo menos, irá evitar a introdução de proposições irrelevantes que poderiam ter sido evitadas utilizando a análise de tipos explicitamente definidos.
Avaliações empíricas mostram que a atribuição de tipos a objetos em domínios de planejamento abrevia fortemente o tempo de busca por solução, o que pode ser observado numa comparação cão do realizada com problemas do domínio Rockets sendo processados por a implementa¸ Graphplan usada neste trabalho.
A Figura 6.2 mostra os tempos de execução de problemas tipados e nao-tipados, com um número cada vez maior de objetivos a serem alcançados no domínio citado anteriormente.
Em um problema com três objetivos, o tempo de processamento do problema tipado é inferior a um segundo enquanto que o tempo para o mesmo problema modelado sem a representação de tipos se aproxima de dez segundos.
Na medida em que o número de objetivos aumenta para oito, o tempo de execução para o problema sem representação de tipos ultrapassa um minuto enquanto que a sua versão tipada continua abaixo de um segundo.
As principais funcionalidades do AgentViewer são o controle da execução do X-BDI, descrito na Seção 6.3.1, a comunicação com um agente X-BDI via sockets, descrita na Seção 6.3.2 e a representação de um modelo de mundo com o qual um agente X-BDI interage, descrita na Seção executando sob o seu controle são apresentadas por a janela Console.
Controle do X-BDI A ferramenta X-BDI é capaz de controlar uma instância do Prolog executando num processo subordinado à máquina virtual Java.
Em esta instância do Prolog o X-BDI é carregado, juntamente com um agente especificado através do AgentViewer.
O controle sobre o X-BDI é feito através de consultas Prolog realizadas por a ferramenta, sendo que o usuário do AgentViewer pode, a qualquer momento fazer consultas quaisquer na instância Prolog subjacente.
Estas funcionalidades podem ser acessadas através dos seguintes botões na janela X-BDI Control (Figura 6.4):
Start/ Restart:
Inicia ou reinicia um processo do sistema operacional que executa uma instância do SICStus Prolog, onde o X-BDI é carregado e executado;
Load Agent: Instrui o X-BDI subjacente a carregar um agente de um arquivo no sistema operacional;
Run Server: Instrui o X-BDI a executar no modo kernel, onde o agente interage com o ambiente através de uma conexão de rede usando sockets do sistema operacional, recebendo informações sobre o ambiente e enviando suas decisões através desta conexao.
Run Choreography: Instrui o X-BDI a carregar uma seqüência pré-definida de entradas do ambiente, que é chamada de coreografia, sendo o resultado da deliberação do agente apresentado por a janela Console;
Run Query: Permite ao usuário executar uma consulta no Prolog sob execução subordinado ao AgentViewer.
Comunicação com o X-BDI Quando uma instância do X-BDI executando no modo kernel está disponível na rede (ou foi criada na máquina local através do AgentViewer), é possível ao usuário conectar- se a ela e realizar a interação com o agente X-BDI através de uma conexão utilizando a interface de sockets do sistema operacional.
Esta funcionalidade é acessível através do botão Connect na janela X-BDI Client.
Quando o AgentViewer for conectado a uma instância do X-BDI, as janelas Sensor Input e Actuator Output de interação com o agente se tornarão disponíveis para o usuário.
As janelas de interação com o agente disponibilizam, respectivamente, informações a respeito de o envio de entradas para os sensores do agente e da recepção de ações de seus atuadores.
Em a janela Sensor Input, o usuário pode carregar um arquivo de coreografia e gerenciar o envio das suas informações para o agente.
Em a janela Actuator Output o usuário pode visualizar o resultado da deliberação do agente, sendo que esta informação é apresentada para o usuário tanto na forma exata como o agente a envia para o ambiente, como de forma formatada, destacando as propriedades presentes em intenções primárias (em azul) das ações presentes nas intenções relativas (em vermelho).
A janela Actuator Output também é utilizada por a funcionalidade de controle do modelo de mundo descrita na Seção 6.3.3.
Modelo de Mundo Além de facilitar a interação com o X-BDI, o AgentViewer é capaz de manter e manipular uma descrição de modelo de mundo que o usuário pode modificar livremente, enviar para o XBDI, e interferir nos resultados da atuação do agente a fim de verificar seu comportamento.
Esta funcionalidade é controlada através da janela World Model, que contém uma representação das propriedades verdadeiras (em azul) e falsas (em vermelho) no estado atual do mundo.
O modelo de mundo mantido por o AgentViewer é inferido no momento em que este se conecta a um agente X-BDI.
Em este momento o AgentViewer carrega o último arquivo contendo um problema de planejamento criado por o X-BDI na sua comunicação com o seu algoritmo de planejamento.
Em esta descrição de problema de planejamento, o estado inicial representa todas as propriedades acreditadas por o agente no momento da deliberação, que são utilizadas para construir o modelo de mundo inicial armazenado por o AgentViewer.
Caso a carga deste arquivo não seja possível, o modelo de mundo deverá ser definido por o usuário.
Uma vez que o AgentViewer tenha uma representação de modelo de mundo, o usuário pode modificar- lo, e enviar- lo para o agente X-BDI.
Estas funcionalidades podem ser acessadas através dos seguintes botões (Figura 6.4):
Add Predicate: Adiciona um predicado especificado por o usuário ao modelo de mundo, este predicado pode ser tanto positivo quanto negativo (indicado por o símbolo, ou a palavra reservada not), sendo que todos os demais predicados são considerados falsos por default;
Read Model: Substitui o modelo de mundo atual por um outro presente num arquivo de descrição de problema STRIPS especificado por o usuário;
Time/ Set:
Especifica um valor inteiro denotando o momento atual no modelo de mundo representado por o AgentViewer.
A cada envio do modelo para o agente este valor é incrementado a fim de denotar o aspecto temporal da evolução do modelo de mundo;
Além destes botões o usuário pode apagar predicados no modelo de mundo ou inverter o seu valor verdade, o que é realizado através de Context Menus acessíveis com o botão direito do mouse;
A o receber o resultado da deliberação do agente por a janela Actuator Output, o usuário pode, através de Context Menus, executar as aço~ es especificadas nas intenções relativas do agente sobre o estado de mundo mantido por o AgentViewer, notificando ou não o sucesso de sua execução para o agente.
Através desta funcionalidade, a ferramenta AgentViewer não apenas provê maior flexibilidade no teste de um agente X-BDI, como também provê um mecanismo de injeção de falhas bastante útil no teste de um agente.
Em o próximo capítulo esta ferramenta será utilizada na descrição de dois estudos de caso.
Um de eles descreve uma célula de produção responsável por escalonar o processamento de peças em seus componentes.
O outro estudo de caso descreve uma célula de produção onde é prevista a ocorrência de falhas, que são inseridas utilizando o AgentViewer.
Estudos de Caso Este capítulo descreve os estudos de caso utilizados no teste da implementação realizada para este trabalho.
Além de demonstrar a aplicabilidade da abordagem proposta na resolução de problemas práticos, os estudos de caso visam demonstrar características importantes da implementação desenvolvida.
Em particular, a célula de produção descrita na Seção 7.1 foi utilizada para mensurar o tempo de execução e a escalabilidade do algoritmo de planejamento utilizado neste trabalho.
Em contrapartida o estudo de caso da Seção 7.2 visa demonstrar a capacidade do agente em tratar falhas ocorridas no sistema ou na comunicação deste com o agente.
Célula de Produção A utilização racional de equipamentos em instalações industriais é um problema complexo, em especial o escalonamento da utilização destes equipamentos.
Este problema é potencializado quando as instalações são utilizadas a fim de se produzir múltiplos tipos de componentes, onde cada um utiliza um subconjunto dos equipamentos disponíveis.
Em este trabalho utilizaremos um agente baseado no modelo BDI a fim modelar uma célula de produção como estudo de caso.
Diferentes tipos de componente têm prioridades de processamento diferentes.
O controle desta célula de produção será delegado a um agente BDI implementado utilizando o X-BDI, que deverá escalonar o trabalho da célula de produção através de suas crenças e desejos, re-escalonando o trabalho da célula quando ocorrer alguma mudança do estado do sistema.
O primeiro passo na modelagem de qualquer problema num formalismo baseado em lógica de predicados é a escolha dos predicados utilizados para representar os tipos de objetos do problema e seus estados.
Desta forma temos os seguintes predicados representando objetos:
Bloc (B) denota que B é um Componente a ser processado;
ProcUnit (P) denota que P é uma Unidade de Processamento, Unidades de Processamento também são Dispositivos;
Device (D) denota que D é um Dispositivo;
FeedBelt representa a Esteira Alimentadora;
DepositBelt representa a Esteira do Depósito.
De a mesma forma temos os seguintes predicados representando estados do sistema:
Over (B, D) denota que o Componente B está sobre o Dispositivo D;
Empty (P) denota que a Unidade de Processamento P está vazia, isto é, não possui nenhum Componente sobre ela;
Processed (B, P) denota que o Componente B já foi processado por a Unidade de Processamento P;
Finished (B) denota que o Componente B já foi processado por todas as Unidades de Processamento apropriadas e foi removido da célula de produção.
A seguir são definidas as ações que o agente é capaz de realizar no contexto do problema analisado:
A ação process (B, P) tendo como pré-condições procUnit (P), bloc (B) e over (B, P), e como efeito processed (B, P).
Esta ação representa o processamento que uma Unidade de Processamento P realiza num Componente B depositado sobre ela;
A ação consume (B) tendo como pré-condições bloc (B) e over (B, depositBelt) e como efeitos¬ over (B, depositBelt), empty (depositBelt) e finished (B).
Esta ação representa a remoção do componente B da célula de produção através da Esteira Depósito;
A ação move tendo como pré-condições over, empty (D2), bloc (B), device (D2) e como efeitos over (B, D2),¬ over (B, D1),¬ empty (D2) e empty.
Esta ação representa a movimentação do Componente B do Dispositivo D1 para o Dispositivo D2.
Os requisitos de processamento dos componentes e suas prioridades são modelados através dos desejos do agente.
Desta forma, podemos modelar a necessidade do agente pCell de processar o Componente bloc1 por as Unidades de Processamento procUnit1, procUnit2 e procUnit3 assim que este bloco é inserido na célula de produção através dos seguintes desejos, onde Tf éo tempo de validade do desejo, e o valor especificado a seguir é a prioridade do desejo:
De a mesma forma, podemos modelar a necessidade do agente de processar o Componente bloc2 por as Unidades de Processamento procUnit3 e procUnit4 através dos seguintes desejos:
Finalmente modela- se o conhecimento constante do agente em relação a o domínio do problema, em especial a classe dos objetos e o estado inicial do mundo com as seguintes crenças:
Bel). A chegada de um novo componente na célula de produção é sinalizada por os sensores através da inclusão na base de dados do agente das crenças bloc e over, ativando o processo de re-consideração do agente.
Dadas as pré-condições dos desejos descritos anteriormente, apenas os desejos relacionados às seguintes propriedades se tornam Elegíveis:
Processed. Processed.
Cabe ressaltar que o desejo relacionado à propriedade finished não se torna elegível pois suas pré-condições ainda não são verdadeiras no momento da deliberação.
Os desejos elegíveis são então analisados por o processo de seleção dos Desejos Candidatos.
Em este processo, os Desejos Elegíveis e as crenças do agente são utilizados para a criação de problemas de planejamento e enviados para resolução com o Graphplan.
O resultado do processamento do Graphplan é um plano que satisfaz todos os Desejos Elegíveis, com os seguintes passos:
A existência deste plano indica para o X-BDI que o conjunto especificado de Desejos Elegíveis é possível, logo tornando estes desejos Candidatos, que se tornarão Intenções Primárias, representando o comprometimento do agente.
A seguir, as Intenções Relativas são geradas com base no plano gerado, uma para cada item, que conduzirão o agente a realizar as ações respectivas.
Uma vez executadas estas ações, os Desejos Candidatos resultantes da deliberação anterior, i.
e processed, processed processed, são satisfeitos.
Além de isto, a pré-condição do desejo de realizar finished se torna verdadeira, ativando novamente o processo deliberativo do agente e gerando o seguinte plano:
Novamente, este plano irá dar origem às intenções do agente e, eventualmente, levar- lo a agir.
Uma situação possível durante o funcionamento do agente seria a entrada de um novo componente na Célula de Produção, isto poderia ocorrer logo após a deliberação do primeiro plano, sinalizada por os sensores do agente através da inclusão das crenças bloc (bloc2) e over (bloc2, feedBelt) na base de crenças, o que modificaria o conjunto de Desejos Elegíveis escolhidos no segundo ciclo de deliberação para:
Finished. Processed (bloc2, procUnit3).
Processed (bloc2, procUnit4).
Estes desejos se tornam Desejos Candidatos pois o Graphplan é capaz de gerar um plano que satisfaz todos os desejos mutuamente, que seria:
Assim, os passos deste plano geram Intenções Relativas, eventualmente levando o agente à execução das ações.
Injeção de Falhas utilizando o AgentViewer Injeção de Falhas é um processo empírico de verificação de sistemas baseado na introdução deliberada de falhas num sistema.
Este processo de verificação da confiabilidade de sistemas na presença de falhas é considerado uma ferramenta importante no desenvolvimento de sistemas tolerantes a falhas.
Um processo de verificação por injeção de falhas consiste na introdução de estados errôneos no ambiente onde um sistema trabalha e/ ou nos dados disponíveis para o sistema.
Considerando a representação de mundo na ferramenta AgentViewer, é possível modificar arbitrariamente o estado atual do mundo, ou mesmo enviar uma descrição errada do estado atual do mundo para o agente.
Desta forma, é possível inserir falhas tanto no estado atual do mundo quanto na percepção do mundo por o agente, permitindo que se verifique a capacidade do agente de agir corretamente na presença de falhas.
A fim de verificar a capacidade de funcionamento na presença de falhas de um agente X-BDI, modelou- se uma célula de produção onde é prevista a ocorrência de falhas nos seus componentes.
A célula de produção proposta é composta por uma Esteira Depósito , duas Prensas para o processamento de Placas de metal, um Robô com dois Braços perpendiculares utilizados para a movimentação dos componentes na célula e uma Mesa onde os componentes que entram na elula é passível de falha.
Failed denota que o componente X falhou;
Empty denota que o componente X está vazio;
Plate (P) denota que P é uma placa de metal a ser processada por a célula;
Robot (R) denota que R é um Robô na célula;
Arm (A, R) denota que A é um braço do robô R;
Table (T) denota que T é uma mesa de alimentação;
Press (P) denota que P é uma prensa de placas de metal;
DepositBelt (D) denota que D é uma esteira depósito;
Loaded (X, P) denota que o componente X está carregado com a placa P;
Done (P) denota que a placa P está pronta.
As ações permitidas neste domínio são as seguintes:
A ação unloadTable (R, A, T, P), com pré-condições plate (P), robot (R), arm (A, R), empty (A), table (T), loaded (T, P),¬ failed (A),¬ failed (R) e¬ failed (T) e efeitos empty (T),¬ loaded (T, P),¬ empty (A) e loaded (A, P), representa a descarga da placa P da mesa T por o braço A do robô R;
A ação loadPress (R, A, Pr, P), com pré-condições plate (P), robot (R), arm (A, R), loaded (A, P), press (Pr), empty (Pr),¬ failed (A),¬ failed (R) e¬ failed (Pr), e efeitos¬ loaded (A, P), empty (A), loaded (Pr, P),¬ empty (Pr), representa a carga da placa P na prensa Pr por o braço A do robô R;
A ação unloadPress (R, A, Pr, P), com pré-condições plate (P), robot (R), arm (A, R), empty (A), press (Pr), loaded (Pr, P),¬ failed (A),¬ failed (R) e¬ failed (Pr), e efeitos loaded (A, P),¬ empty (A),¬ loaded (Pr, P) e empty (P), representa a descarga da placa P da prensa Pr por o braço A do robô R;
A ação usePress (Pr, P), com pré-condições plate (P), press (Pr), loaded (Pr, P) e¬ failed (Pr), e efeito done (P), representa a utilização da prensa Pr sobre a placa P;
A ação loadDepositBelt (R, A, D, P), com pré-condições plate (P), robot (R), arm (A, R), loaded (A, P), depositBelt (D), empty (D),¬ failed (A),¬ failed (R) e¬ failed (D), e efeitos¬ loaded (A, P), empty (A), loaded (D, P) e¬ empty (D), representa a carga da placa P na esteira depósito D por o braço A do robô R. Os objetivos do agente neste contexto são bastante simples, a finalização de uma placa P qualquer assim que ela entrar na célula e a sua carga na esteira depósito uma vez pronta.
Isto é modelado com os seguintes desejos:
O conhecimento do agente sobre este domínio é modelado com as seguintes crenças iniciais:
Bel (fzi, table (table)).
A deposição de uma nova placa de metal na Mesa de chegada na célula é representada por a inclusão das propriedades plate e loaded na base de crenças do agente.
Esta modificação irá desencadear o início do processo deliberativo do agente.
Em este processo, é verificado que a pré-condição do desejo de concretizar done (P) foi satisfeita, tornando este desejo elegível.
Para satisfazer este desejo, o algoritmo de planejamento do agente gera o seguinte plano:
Este plano comprova, portanto, a possibilidade de satisfazer o desejo elegível escolhido anteriormente, logo, este desejo se torna candidato.
Este desejo candidato irá então dar origem as intenções primárias e relativas, levando o agente a executar as ações especificadas.
Durante o processo de execução das ações, é possível que ocorra uma falha num dos componentes, por exemplo, a prensa número um, denotado através da crença na propriedade failed.
Em este caso, a ação loadPress irá se tornar impossível pois uma de suas pré-condições agora é falsa.
A o perceber esta falha, o agente irá ter que re-planejar o seu curso de ação.
Supondo que o agente já tenha executado a ação unloadTable, o novo plano gerado por o agente é:
Como o agente foi capaz de gerar um novo plano para satisfazer o desejo inicial, este desejo permanece como candidato, modificando apenas as intenções relativas do agente para refletir o comprometimento com um curso de ação diferente.
Em este novo curso de ação o agente irá utilizar a prensa de número dois (press2), ao invés de a de número um, para processar a placa de metal.
Se nesta mesma situação o componente falho for o braço de número um, denotado por a crença na propriedade failed o cumprimento do desejo de finalizar a placa de metal se torna impossível, visto que a placa estará presa a um braço defeituoso.
Diversas outras combinações de falhas em diversos dos componentes da célula foram testadas, onde pode ser verificada a capacidade do agente de verificar se ações de correção eram possíveis ou se a falha impedia o agente de atingir seus objetivos.
Considerações Finais Em este trabalho foi descrita a relação entre algoritmos de planejamento proposicional e o raciocínio meios-fim de agentes BDI.
Para testar a viabilidade desta abordagem foram realizadas modificações no modelo X-BDI de agentes a fim de que este pudesse utilizar um módulo de planejamento externo dotado de uma implementação do Graphplan.
Durante este processo de modificação, foram criadas novas definições de desejos e intenções de modo a manter as propriedades teóricas presentes na sua versão original, em particular relativas à definição de impossibilidade de desejos e intenções.
Além de isto, foi necessário definir um mapeamento entre os componentes estruturais de um agente BDI e problemas de planejamento proposicional, e de planos proposicionais de volta para os estados mentais do agente.
O resultado destas modificações foi implementado une tanto uma versão modificada do X-BDI quanto num protótipo descrito no Capítulo 6, que reúma implementação do Graphplan, além de prover uma ferramenta de operação e teste dos agentes criados com este sistema.
Através da junção de agentes BDI e algoritmos de planejamento rápidos, espera- se que a classe de problemas cuja resolução em tempo de execução é viável possa ser expandida na direção dos algoritmos de planejamento proposicionais utilizados em conjunto com o agente, sejam estes quais forem.
Os resultados da aplicação prática da implementação desenvolvida foram observados numa série de estudos de caso descritos no Capítulo 7, sendo que o problema da Seção 7.1 foi executado por o X-BDI original ininterruptamente por 48 horas sem produzir resultados, enquanto que a versão atual do mesmo levou menos de um segundo.
Considerando o fato de que a maioria das implementações de agentes BDI de que se tem conhecimento utilizam uma biblioteca de planos no processo de raciocínio meios-fim a fim de evitar a complexidade inerente à realização de planejamento em tempo de execução, o X-BDI oferece uma maneira inovadora de implementar agentes mais flexíveis.
Considerando ainda o fato de que o X-BDI original era limitado por o seu processo de planejamento ineficiente, uma importante contribuição deste trabalho reside na definição de um mecanismo de mapeamento entre o raciocínio meios-fim de agentes BDI e algoritmos rápidos de planejamento, como o Graphplan.
Além de os resultados na área de Ia obtidos por este trabalho, a ferramenta construída se mostrou útil para o processo de desenvolvimento de sistemas tolerantes a falhas baseados em agentes.
Esta contribuição é representada por a aplicabilidade do AgentViewer como ferramenta de injeção de falhas para sistemas modelados em termos de agentes BDI.
Trabalhos Futuros Algumas ramificações deste trabalho podem ser visualizadas como trabalhos futuros, em especial, a incorporação dos diversos aprimoramentos no Graphplan, além de a realização de testes com outros algoritmos de planejamento proposicionais, como por exemplo os algoritmos baseados em SAT.
Além de isto, a determinação da classe de problemas os quais as combinações de Agente BDI e demais algoritmos de planejamento são capazes de tratar representa uma extensão teórica muito interessante a este trabalho.
Em a área de tolerância a falhas, os estudos de caso desenvolvidos permitem intuir que o Agent Design Problem está relacionado à questão de Dependability Testing, que consiste em verificar o grau de confiabilidade de um sistema frente a falhas.
Este relacionamento é justificado na medida em que a prova da capacidade ou não de um agente em realizar uma tarefa num ambiente onde falhas são possíveis é um indicador bastante preciso da confiabilidade do agente.
