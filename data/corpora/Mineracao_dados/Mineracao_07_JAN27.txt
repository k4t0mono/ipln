A descoberta de padrões freqüentes em bancos de dados constitui um importante problema do domínio da descoberta de conhecimentos e sua importância é justicada pela diversidade de áreas onde pode ser empregada, como no varejo, no mercado nanceiro, na medicina, na agricultura, na agropecuária, em empresas de telecomunicações, etc.

O problema de mineração de padrões freqüentes em bancos de dados temporais, conhecido também como mineração de padrões temporais, tem sido amplamente estudado.

Em alguns trabalhos os padrões temporais propostos são especicados por formalismos da Lógica Temporal Proposicional, em outros, eles são mais expressivos, por isso, são especicados por formalismos da Lógica Temporal de Primeira Ordem.

Os padrões temporais existentes na literatura representam o tempo em termos de pontos, onde, seus eventos ocorrem em determinados instantes, ou em termos de intervalos, onde, seus eventos ocorrem durante períodos de tempo.

Esta distinção faz com que alguns fatos não sejam reconhecidos, como por exemplo fatos relacionados ao histórico clínico de um paciente, onde o paciente tomou determinado medicamento durante um intervalo e sofreu uma determinada cirurgia, em uma certa data, durante o tempo em que estava tomando o medicamento.

Nesta dissertação esta sendo proposto um novo padrão temporal, chamado padrão temporal híbrido ou simplesmente pth, que representa o tempo explicitamente em termos de pontos e/ou intervalos.

Este padrão é bastante expressivo, por isso, a Lógica Temporal de Intervalos de Allen foi adaptada para especificá-lo.

Está sendo proposto também um algoritmo, chamado MILPRIT*, para minerar os pth's freqüentes em bancos de dados temporais com relação a um suporte mínimo e a uma restrição especicada pelo usuário através de uma expressão regular.

Isto permite ao usuário um maior controle sobre o processo de mineração.

A performance e a escalabilidade do MILPRIT* foi avaliada através de um conjunto de testes em bancos de dados sintéticos e real.

Nas últimas décadas, com o grande crescimento do uso de computadores, o tamanho dos bancos de dados existentes nas mais variadas instituições aumentou consideravelmente impossibilitando a interpretação e a compreensão humana dos dados armazenados.

Na maioria dos casos, depois que supostamente estes dados já serviram a seus propósitos eles cam inutilizados, pois, as instituições não sabem o que fazer com eles.

Para suprir a incapacidade humana de analisar enormes quantidades de dados e melhor aproveitá-los surgiu a mineração de dados (data mining), como uma poderosa ferramenta para a descoberta de informações importantes que não estão explícitas nos bancos de dados.

A mineração de informações interessantes ocultas em bancos de dados é uma área de pesquisa muito abrangente que engloba várias tarefas de mineração, das quais podem ser destacadas a mineração de regras de associação, classicação, agrupamentos (clusters) e mineração de padrões seqüenciais.

O problema de mineração de padrões seqüenciais freqüentes em bancos de dados temporais, conhecido também como mineração de padrões temporais, tem sido amplamente estudado e sua importância é justicada pela diversidade de áreas onde esse tipo de mineração pode ser empregada.
Tais como, no varejo (pode-se ter interesse em minerar padrões que expressam a evolução de compras de clientes), no mercado financeiro (pode-se ter interesse em minerar padrões que expressam a evolução de cotações de ações).
Na medicina (pode-se ter interesse em minerar padrões que expressam a evolução de sintomas de pacientes), em telecomunicações (pode-se ter interesse em minerar padrões que expressam seqüências de disparos de alarmes), etc.

Já foram propostos vários tipos de padrões juntamente com inúmeros formalismos e algoritmos que possibilitam a mineração dos mesmos.

Alguns dos padrões propostos são especicados por formalismos da Lógica Temporal Proposicional.

Por exemplo, considere um padrão seqüencial clássico da forma que são conjuntos de itens comprados por um cliente.

Este padrão pode ser expresso na Lógica Temporal Proposicional pela fórmula.
O símbolo é o operador temporal em algum momento no futuro.

Outros padrões propostos, como os que modelam comportamentos de usuários do sistema Unix, necessitam de uma maior expressividade, por isso, são especicados por formalismos da Lógica Temporal de Primeira Ordem.

Por exemplo, considere a seguinte seqüência de comandos utilizados por usuários do Unix, vi texto,mv texto,rm texto,ls.

Esta seqüência pode ser representada por uma seqüência de átomos de primeira ordem da forma, vi(texto), mv(texto), rm(texto), ls, permitindo a descoberta de padrões freqüentes da forma vi(X) rm(Y), onde, vi rm é uma seqüência de comandos (predicados) freqüentemente usados pelos usuários, e X e Y representam nomes de arquivos (parâmetros).

Os padrões temporais existentes na literatura representam o tempo em termos de pontos, onde os eventos ocorrem em determinados instantes, ou em termos de intervalos, onde os eventos ocorrem durante períodos de tempo.

Esta distinção faz com que alguns fatos não sejam reconhecidos pelos processos de descoberta de padrões, como por exemplo, fatos relacionados ao histórico clínico de um paciente, onde, o paciente tomou um medicamento X por um período de tempo e durante um período de tempo f em que apresentou um sintoma Y, e após ter interrompido o uso do medicamento X e antes do sintoma Y ter desaparecido sofreu uma cirurgia Z em um instante t.

Nesta dissertação está sendo proposto um novo tipo de padrão temporal, chamado padrão temporal híbrido ou simplesmente pth, que representa o tempo explicitamente em termos de pontos e/ou intervalos.

Este padrão é bastante expressivo, por isso ele é especicado por formalismos da Lógica Temporal de Intervalos de Allen que foi adaptada para esta nalidade.

Está sendo proposto também um algoritmo chamado MILPRIT* para minerar este novo padrão temporal.

O padrão temporal híbrido proposto nesta dissertação pode aparecer em bancos de dados temporais relacionais onde o tempo é representado em termos de pontos e/ou intervalos, e tem como objetivo representar os relacionamentos entre eventos ocorridos em instantes ou períodos ao longo do tempo.

A mineração de padrões temporais híbridos pode ser empregada em vários domínios de aplicações, como por exemplo na agricultura (pode-se ter interesse em descobrir se o uso de agrotóxicos durante determinados períodos de tempo tem inuência na evolução de determinadas plantações).
Na agropecuária (pode-se ter interesse em descobrir se o uso de determinadas rações durante um determinado período de tempo e a aplicação de vacinas em alguns instantes inuenciam na evolução de doenças ou no desenvolvimento de rebanhos), na medicina (pode-se ter interesse em descobrir se pacientes que tomam um medicamento X e entram na menopausa durante o tempo em que estão tomando esse medicamento irão apresentar um sintoma Y no futuro).

A seguir, será apresentado um exemplo onde a mineração de padrões temporais híbridos é empregada na medicina.

Suponha que o objetivo seja descobrir como o estilo de vida e casos clínicos de pacientes do sexo feminino inuencia ou não no surgimento de lesões, malignas ou benignas, na mama.

Considere o banco de dados simplicado de uma clínica que realiza exames mamográcos.

A tabela Paciente armazena os nomes de todas as pacientes que realizaram exames mamográcos.

A tabela Birads armazena os resultados dos exames mamográcos de cada paciente.

Na classicação Bi-Rads os laudos mamográcos são divididos em sete categorias, quanto maior a categoria maior é a chance da paciente ter uma lesão maligna.

As tabelas Gravidez, Fumo e Hormonio armazenam os instantes de cada gravidez, períodos em que fumou e períodos em que usou hormônios, respectivamente.

Os atributos Tit e Tpt representam respectivamente o período (intervalo) e o instante (ponto) no qual determinado evento aconteceu.

Os números que aparecem nestas colunas são mapeados em datas de acordo com a linha do tempo, portanto, neste banco de dados os eventos aconteceram em um ponto (uma dat ou em um intervalo (durante o período entre duas datas).

Exemplo de um banco de dados de uma clínica de mamograa.

Considere os seguintes comportamentos, Pacientes tiveram lho em um instante e futuramente apresentaram Bi-Rads 3.

Pacientes fumaram 10 cigarros por dia e após terem parado de fumar iniciaram o uso do hormônio progesterona.

Pacientes fumaram uma quantidade de cigarros por dia e após terem parado de fumar apresentaram alguma categoria de Bi-Rads.

Note que o comportamento 1 é compatível com o das pacientes Maria e Paula e envolve somente tabelas onde o tempo é representado por pontos (Gravidez e Birads).

Note também que o comportamento é compatível com o das pacientes Priscila e Paula e envolve somente tabelas onde o tempo é representado por intervalos (Fumo e Hormonio).

Já, o comportamento é compatível com o das pacientes Paula e Cintia e envolve uma tabela que representa o tempo por intervalos (Fumo) e uma tabela que representa o tempo por pontos (Birads).

É importante enfatizar que este último comportamento não pode ser expresso diretamente por nenhum dos padrões existentes na literatura.

No entanto, padrões temporais híbridos são especicados por um conjunto de fórmulas atômicas onde o tempo é expresso por variáveis que representam pontos ou intervalos e estas variáveis são relacionadas pelos predicados temporais before, meets, overlaps, starts, during ou finishes.


As principais contribuições desta dissertação são, A proposta de um novo padrão temporal, chamado padrão temporal híbrido, que representa o tempo explicitamente em termos de pontos e/ou intervalos e é especicado pelos formalismos da Lógica Temporal de Primeira Ordem.

O desenvolvimento do algoritmo MILPRIT*1, que é o resultado de otimizações e extensões de um protótipo, chamado MILPRIT, desenvolvido para mineração de padrões temporais onde o tempo é representado unicamente em termos de intervalos.

Otimizações, Uma das otimizações foi realizada com o objetivo de aperfeiçoar as relações entre a etapa de geração dos padrões, a etapa de poda dos padrões e o consumo de memória, uma vez que os padrões gerados pelo MILPRIT preenchem rapidamente a memória principal.

Outra otimização foi realizada com o objetivo de corrigir uma falha na etapa da geração, uma vez que o MILPRIT não gera determinados padrões ou gera padrões que não interessam ao usuário.


Extensão, A extensão foi realizada com o intuito de permitir que o MILPRIT* além de minerar padrões temporais que representam o tempo por intervalos minere também padrões temporais que representam o tempo por pontos.



Extensão dos fundamentos teóricos do protótipo MILPRIT para o contexto do algoritmo MILPRIT Durante o processo de mineração, o protótipo MILPRIT gera somente padrões completos e consistentes, assim, eles podem ser vistos como seqüências, o que possibilita que sejam especializados de modo que satisfaçam uma expressão regular.

O protótipo MILPRIT utiliza dois operadores (instanciação e extensão) para a especialização dos padrões.

Esses operadores são completos e optimais.

Assim, a eficiência do método é garantida, pois, são gerados todos os padrões possíveis a partir de um dado padrão e não são gerados padrões duplicados.

Todos esses fundamentos foram estendidos para o problema de mineração proposto e implementados no algoritmo MILPRIT A incorporação de restrições especicadas através de expressões regulares como uma ferramenta para incorporar ao processo de mineração o foco do usuário, promovendo assim a redução do espaço de busca dos padrões.

O desenvolvimento de um gerador de dados sintéticos2, que permite que diferentes tipos de bancos de dados contendo informações temporais representadas por pontos e/ou intervalos sejam criados de acordo com as necessidades do usuário.

A construção de um banco de dados real3, cuja modelagem foi baseada na classicação Bi-Rads, padrão publicado pela ACR Colégio Americano de Radiologi.

O banco de dados real é um banco de dados temporal que contém informações sobre pacientes do sexo feminino, como estilo de vida e histórico clinico.

Como o aumento dos bancos de dados surgiu o interesse e a necessidade de estudar maneiras de extrair conhecimentos automaticamente dos mesmos.

Com a extração de conhecimentos, os grandes bancos de dados passaram a ser vistos como valiosas fontes de informações que podem auxiliar em tomadas de decisões, marketing, nanças e em muitas outras tarefas.

A Mineração de Dados (Data Mining) é apenas uma etapa, entre várias, do processo de descoberta (extração) de conhecimentos em grandes bancos de dados.

De maneira supercial, mineração de dados corresponde em aplicar a uma base de dados pré-processada de forma adequada algoritmos de técnicas de descoberta de informações interessantes.

Atualmente existe uma necessidade urgente de se criar novas teorias e ferramentas para auxiliar os seres humanos na extração de informações importantes dos crescentes volumes de dados armazenados em todos os tipos de bancos de dados.

O desenvolvimento dessas teorias e ferramentas é o objetivo da Descoberta de Conhecimento em Bancos de Dados Knowledge Discovery in Databases KD.

KDD é o processo de extração de padrões interessantes, não triviais, implícitos, de antemão desconhecidos e potencialmente úteis em grandes bancos de dados.

Os dados são um conjunto de fatos (casos nas bases de dados), e o padrão é uma expressão em alguma linguagem descrevendo um subconjunto de dados.

Processo informa que KDD é constituído de várias etapas, envolvendo a preparação dos dados, a busca por padrões, a avaliação do conhecimento, e o renamento, e todas essas etapas podem ser repetidas em múltiplas iterações.

Não trivial indica que o processo não é direto e pode envolver o uso de técnicas de busca e algoritmos.

O processo KDD é divido em etapas bem denidas,seleção dos dados,pré-processamento e transformação, mineração de dados e interpretação e avaliação dos resultados.

Passos do KDD.

Na seleção, são selecionados os dados que interessam ao usuário, sobre os quais o processo de descoberta de conhecimentos será executado.

Depois que os dados foram selecionados, a etapa de pré-processamento e transformação é executada, nessa etapa é realizada a limpeza dos dados, ou seja, ruídos são removidos dos mesmos, um exemplo de limpeza pode ser descartar registros contendo atributos incompletos ou nulos.

Ainda nesta fase os dados são transformados em um formato apropriado para a aplicação de algoritmos de mineração.

O objetivo principal do processo KDD é realizado na terceira etapa, a mineração de dados, onde os algoritmos de mineração como os de regras de associação, classicação, clusterização, padrões seqüenciais, entre outros, são executados.

A última etapa é a de interpretação e validação dos resultados, nesta etapa os padrões extraídos são mostrados de maneira compreensível ao usuário.

Resumidamente, uma tarefa de mineração de dados consiste na especicação do que esta sendo procurado, que tipo de regularidades ou padrões devem ser encontrados, por exemplo, comportamentos dos clientes de um supermercado, sintomas apresentados por pacientes antes ou após o uso de algum medicamento, gastos exagerados por um cliente de um banco, etc.

Até hoje foram propostas várias tarefas de mineração de dados, e para cada tipo de tarefa vários algoritmos e formalismos foram criados para possibilitar a mineração.

As principais tarefas de mineração são, Mineração de Regras de Associação, Corresponde à descoberta de associações entre objetos.

Dado um banco de dados de transações onde cada transação é um conjunto de objetos, uma regra de associação é uma expressão da forma X Y, onde, X e Y também são conjuntos de objetos.

De um modo intuitivo, essa regra signica que transações do banco de dados que contém X tendem a conter Y.

Por exemplo, é possível descobrir um conjunto de produtos de um supermercado que é freqüentemente vendido com outro conjunto de produtos, assim, uma regra de associação que reete o comportamento dos clientes de um supermercado poderia ser, Clientes que compram pão também compram leite.

As informações que as regras de associação transmitem podem ser utilizadas, por exemplo, para melhorar a distribuição dos produtos nas prateleiras.

Classicação, Consiste em encontrar modelos de classicação (regras) que separam os dados em classes distintas, os modelos de classicação são criados com base nas características dos dados de um banco de dados de treinamento, cujos elementos são chamados de amostras, onde se conhece as classes de cada objeto.

Um conjunto de regras é gerado a partir do modelo de classicação com o propósito de classicar objetos que ainda não foram classicados.

Por exemplo, se o objetivo fosse descobrir se um cliente é bom ou mau pagador, um modelo de classicação poderia conter a regra, Clientes que pertencem a classe econômica B, com menos de lhos são bons pagadores, esta conclusão é obtida com base em casos já conhecidos no banco de dados de treinamento e generalizada para novos casos.

Agrupamento (Cluster), Consiste em agrupar em classes objetos que possuem características semelhantes.

A diferença deste tipo de mineração com a classicação é que na classicação os dados (objetos) de treinamento estão devidamente classicados, ou seja, distribuídos em classes pré-denidas.

No agrupamento, as classes são criadas no decorrer do processo, objetos com maior similaridade são agrupados em uma mesma classe, enquanto que objetos com pouca similaridade são agrupados em classes distintas.

Por exemplo, o agrupamento pode ser aplicado a um banco de dados de um supermercado para identicar grupos de clientes com algumas características em comum, como por exemplo clientes de determinada região da cidade vão ao supermercado uma vez por semana, enquanto que clientes de outra região vão ao supermercado duas ou mais vezes por semana.

Mineração de Padrões Seqüenciais, Tem como principal objetivo encontrar seqüências de eventos (fatos) que ocorrem freqüentemente em bancos de dados.

Por exemplo, em um banco de dados de transações de clientes, onde cada transação é constituída pelo identicador do cliente, data da transação e objetos envolvidos na transação, um padrão seqüencial é uma expressão da forma, onde, cada si é um conjunto de objetos e a ordem dos conjuntos de objetos deve reetir a ordem cronológica em que os fatos ocorreram.

Assim, a seqüencia signica que clientes que compram TV em uma transação, posteriormente compram DV DPlayer e HomeTheater em outra transação.

A mineração de padrões seqüenciais sobre bancos de dados temporais, conhecida também como mineração de padrões temporais, é a tarefa de mineração destacada como foco desta dissertação.

Algumas das propriedades e técnicas utilizadas na mineração de padrões temporais derivaram de um trabalho apresentado em 199por Agrawal e Srikant, onde eles apresentaram o clássico algoritmo Apriori para descoberta de itemsets freqüentes (conjuntos de itens freqüentes) em bancos de dados de transações de clientes.

Com o objetivo de minerar padrões freqüentes de forma eficiente eles introduziram uma propriedade antimonotônica chamada propriedade Apriori.

Propriedade Apriori.

Um conjunto de itens não é freqüente se possui pelo menos um sub-conjunto de itens que não é freqüente, ou seja, todo sub-conjunto de itens freqüentes também é freqüente.

O algoritmo Apriori é um algoritmo iterativo que em cada iteração produz itemsets candidatos maiores a partir de itemsets freqüentes da iteração anterior.

Em cada iteração são executadas três etapas bem denidas, Geração, onde são gerados todos o padrões candidatos com base na iteração anterior.

Poda, onde são podados todos os padrões candidatos que não satisfazem a propriedade Apriori e Avaliação, onde o banco de dados é percorrido e o suporte de todos os padrões que satisfazem a propriedade Apriori é calculado.

Os padrões que possuem suporte superior a um suporte mínimo estipulado pelo usuário são considerados freqüentes.

Como será notado neste capítulo, a técnica de mineração desenvolvida para o algoritmo Apriori constitui a base de muitos algoritmos de mineração de padrões temporais.

Está técnica é comumente referenciada como técnica Apriori.

A maioria dos algoritmos de mineração de dados restringem de alguma forma seus padrões.

Existem vários tipos de restrições que podem ser introduzidas no processo de mineração, como por exemplo restrições de geração, que são incorporadas na etapa de geração dos algoritmos visando diminuir o espaço de busca dos padrões e restrições de validação, que são incorporadas na etapa de avaliação dos algoritmos e os padrões que não satisfazem essas restrições são eliminados.

Nesta dissertação tem destaque as restrições de expressões regulares que são incorporadas tanto na etapa de geração quanto na etapa de poda dos algoritmos de mineração.

Nas próximas seções serão descritos alguns dos principais trabalhos relacionados a mineração de padrões temporais.

Serão apresentados diversos enfoques referentes a diferentes técnicas de mineração de padrões temporais e para cada um desses enfoques serão introduzidos os conceitos necessários, de acordo com os autores, para seu entendimento.

É importante salientar que às vezes conceitos são definidos de forma diferente em cada enfoque, portanto, para não deixar o leitor confuso foram introduzidas referências em todas as denições de outros autores apresentadas nesta dissertação.

Para facilitar o entendimento, os padrões temporais foram divididos em dois grupos principais, os que representam o tempo por pontos e os que representam o tempo por intervalos.

Padrões temporais que representam o tempo por pontos são aqueles em que os eventos ocorrem em determinados instantes uma hora, uma data, et e podem ser vistos como uma seqüência de eventos respeitando uma ordem cronológica.

Esses padrões são conhecidos historicamente como padrões seqüenciais.

Existem padrões seqüenciais especicados pela Lógica Temporal Proposicional (LTP), chamados de padrões seqüenciais proposicionais, e padrões seqüenciais mais expressivos, especicados pela Lógica Temporal de Primeira Ordem (LTPO), chamados de padrões seqüenciais de primeira ordem.

O problema de mineração de padrões seqüenciais proposicionais será abordado formalmente na próxima seção, já, o problema de mineração de padrões seqüenciais de primeira ordem será abordado.

O problema de mineração de padrões seqüenciais tem sido amplamente estudado e é aplicado com sucesso em diversos setores, tal como no varejo (os padrões minerados podem representar seqüências de compras de clientes), no mercado nanceiro (os padrões minerados podem representar a evolução de cotações de ações), na Internet (os padrões minerados podem representar os caminhos de páginas da web freqüentemente percorridos por usuários), etc.

Um exemplo clássico da aplicação da mineração de padrões seqüenciais proposicionais pode ser dado como segue.

Suponha que o gerente de um supermercado esteja interessado em descobrir a evolução de compras de seus clientes ao longo do tempo.

Ele quer saber quais produtos são comprados por um mesmo cliente em diferentes momentos.

Se ele descobre que a seqüência de produtos < {p1,p2} p> é freqüentemente comprada nessa mesma ordem, ou seja, clientes compram os produtos p1 e pem um mesmo momento e o produto pem um momento futuro, então poderá realizar uma campanha de marketing colocando o produto pem promoção para os clientes que comprarem os produtos p1 e p2.

Com isso ele terá grandes chances de não desperdiçar recursos em vão, pois sabe que os clientes têm grandes chances de comprar o produto p3.

O padrão seqüencial < {p1,p2} p>, apresentado no parágrafo anterior, pode ser expressado na LTP pela fórmula (Cp Cp) Cp, onde, para cada pi com i {1, 2, 3}, Cp é um símbolo proposicional que signica clientes compram o produto pi.

O símbolo é o operador temporal em algum momento no futuro.

O problema de mineração de padrões seqüenciais proposicionais foi introduzido em 1995 por Agrawal e Srikant em.

Nesse trabalho foram propostos vários algoritmos para a mineração de padrões seqüenciais sobre um banco de dados de transações de clientes.

Serão definidos a seguir alguns conceitos fundamentais para o entendimento deste problema de mineração.

Uma seqüência s é uma lista ordenada denotada por <s1 s sn>, onde si é um itemset denido sobre um conjunto de itens I.

O comprimento de uma seqüência s, corresponde ao número de itens na seqüência.

Uma seqüência de comprimento k é referenciada como uma k-seqüência.

Se um item ocorre múltiplas vezes em diferentes elementos de uma seqüência, cada ocorrência contribui para o valor de k.

Exemplo 231 Considere o conjunto I = {TV,DV D,V ideo,HomeTheater,V entilador, Fogao} e uma seqüência s = <{TV,V ideo}{V entilador}{TV,DV D}>.

A seqüência s possui comprimento 5, pois, possui 5 itens.

Nesse caso os itemsets representam itens comprados em uma mesma transação.

Sub-seqüência.

Uma seqüência a = <a1 a an> é uma sub-seqüência de uma seqüência b = <b1 b bm>, com m n, denotado por a v b, se existe inteiros i1 < i< < in tal que a1 bi, a bi, an bi.

Também pode-se dizer que b contêm a ou que a está contida em b.

Exemplo 23Considere as seqüências s = <{TV,V ideo} {V entilador} {TV,DV D, Fogao}>, s1 = <{TV } {V entilador} {TV,DV D}>, s= <{TV,V ideo} {TV,DV D, Fogao}> e s= <{TV } {Fogao} {DV D}>.

As seqüências s1 e ssão sub-seqüências de s, enquanto que, a seqüência snão é.

Seqüência maximal.

Seja S um conjunto de seqüências, uma seqüência s S é maximal se não existe nenhuma seqüência s0 S{s}, tal que, s v s0.

Exemplo 23Considere o conjunto de seqüências S = {< {TV } {V entilador} {DV D, Fogao} >, < {TV,DV D} {Fogao} >, < {V entilador} {Fogao} >}.

A seqüência < {TV,DV D} {Fogao} > é maximal, pois, ela não está contida em nenhuma outra seqüência de S.

A seqüência < {V entilador} {Fogao} > não é maximal, pois, está contida na primeira seqüência de S.

Banco de dados de seqüências.

Um banco de dados de seqüências BD é um conjunto de tuplas < ids,s >, onde s é uma seqüência e ids é o identicador da seqüência s.

Uma tupla < ids,s > em BD contém uma seqüência a, se a é uma sub-seqüência de s, ou seja, a v s.

Exemplo 23Considere o banco de dados BD de seqüências, constituído de quatro tuplas.

Nesse caso o identicador das seqüências é o próprio código do cliente que comprou os itens pertencentes a seqüência.

Exemplo de um banco de dados de seqüências de clientes 235 (Suporte).

O suporte de uma seqüência a em um banco de dados de seqüências BD é denotado por sup= |{s | ids, <ids,s> BD e a v s}|, ou seja, supé a porcentagem de tuplas em BD que contém a.

Seqüência freqüente.

Dado um suporte mínimo, uma seqüência s é freqüente em um banco de dados BD se sup(s) é maior ou igual a, ou seja, sup(s).

Uma seqüência freqüente é chamada de padrão seqüencial.

O suporte da seqüência < {TV }{Fogao}> é 05 (50%), pois, ela está contida nas seqüências dos clientes 01 e 03.

Se for considerado um suporte mínimo de 50% (duas tuplas), então, <{TV }{Fogao}> é considerada uma seqüência freqüente.

Com os principais conceitos apresentados, a formulação geral do problema de mineração de padrões seqüênciais proposicionais é dada por, Dado, Um banco de dados de seqüências BD e um suporte mínimo.

Encontrar, Todas as seqüências freqüentes em relação a BD e.

Vários pesquisadores contribuíram e ainda estão contribuindo para tornar a mineração de padrões seqüenciais proposicionais cada vez mais eficiente.

Uma grande variedade de algoritmos já foram propostos, entre eles se destacam o AprioriAll, o SPADE.

O GSP foi apresentado por Srikant e Agrawal em e minera os mesmos tipos de padrões seqüênciais minerados pelo algoritmo AprioriAll, embora com performance bem superior.

Por este motivo, as principais idéias do algoritmo GSP serão apresentadas a seguir.

O Algoritmo GSP.

O algoritmo GSP é baseado na técnica Apriori, portanto, trabalha em iterações e em cada iteração k gera k-seqüências freqüentes.

Em cada iteração são executadas três etapas, geração, poda e avaliação (cálculo do suporte).

Na primeira iteraço são encontrados todos os padrões freqüentes contendo apenas um item seqüênci.

Estes padrões são utilizados na segunda iteração para o gerar as seqüências candidatas.

Se < { TV } > e < { DV D } > são seqüências freqüentes, então as seqüências <{TV,DV D}>, <{TV }{DV D}> e <{DV D}{TV }> são seqüências candidatas.

A seguir, o banco de dados é percorrido e o suporte de todas as seqüências candidatas é calculado.

Todas as seqüências com suporte inferior a um suporte mínimo estipulado pelo usuário são podadas e as seqüências restantes são consideradas freqüentes.

A partir da segunda iteração as seqüências são geradas pela combinação das seqüências freqüentes da iteração anterior, em seguida as seqüências que possuem sub-seqüências que não são freqüentes são podadas (propriedade Apriori), então, o suporte das seqüências que restaram é calculado.

Resumidamente, cada etapa do algoritmo GSP funciona assim, Geração, Considere os conjuntos Fk e Ck, que denotam o conjunto das k-seqüências freqüentes e o conjunto das k-seqüências candidatas, respectivamente.

Dado um conjunto Fk 1 constituído por duas (k-1)-seqüências (s1,s2), se essas duas seqüências podem ser combinadas para dar origem a uma k-seqüência, então a k-seqüência resultante da combinação são inseridas em Ck.

As duas seqüências podem ser combinadas se a retirada do primeiro item de s1 e do último item de sresulta em seqüências iguais.

Neste caso, o último item de sé acrescentado em s1 formando uma seqüência em Ck.

Se o último item de sestava em um itemset separado, ele será inserido em um itemset separado em s1, caso contrário, ele fará parte do último itemset de s1.

Por exemplo, seja F= {<{TV,V ideo}{DV D}>, <{V ideo}{DV D,Fogao}>}, as duas seqüências de F podem ser combinadas, pois, retirando o item TV da primeira e Fogao da segunda seqüência, as seqüências resultantes são iguais.

Assim, a seqüência obtida é a seqüência <{TV,V ideo}{DV D,Fogao}> que é inserida em C4.

Poda, São podados todas as seqüências de Ck que possuem pelo menos uma subseqüência não pertence a Fk, ou seja, que não é freqüente, restando somente seqüências potencialmente freqüentes em Ck.

Continuando o exemplo apresentado na Geração, a seqüência <{TV,V ideo}{DV D,Fogao}> será podada, pois, a sub-seqüência <{TV }{DV D,Fogao}> não pertence a F3.

Avaliação, O suporte das seqüências que restaram em Ck após a poda é calculado percorrendo o banco de dados uma vez.

As seqüências candidatas que possuírem suporte maior ou igual a um suporte, denido pelo usuário, são inseridas em Fk.

Nos algoritmos de mineração esta é a etapa mais cara computacionalmente, por isso, deve ser otimizada.

O GSP utiliza recursos como uma árvore hash para otimizá-la.

Detalhes dessa árvore hash podem ser encontrados em.

Grande parte dos algoritmos de mineração de padrões seqüenciais utilizam um suporte mínimo denido pelo usuário como única forma de restringir o espaço de busca dos padrões.

Estes algoritmos não permitem que os tipos dos padrões sejam especicados, assim, muitos dos padrões minerados são irrelevantes para o usuário.

As restrições de expressões regulares são introduzidas no processo de mineração com o objetivo de reduzir o espaço de busca dos padrões e servir como ferramenta para que o usuário possa informar os tipos de padrões que ele deseja obter, diminuindo assim o tempo gasto na mineração de padrões que não o interessam.

Suponha que o usuário esteja interessado somente em padrões que começam com o item TV e terminam com o item DVD.

Para isso, ele pode denir a expressão regular (TV) (s) DV, onde, s representa uma seqüência qualquer de itens e é um símbolo que indica que a seqüência s pode não aparecer ou aparecer uma ou mais vezes.

A maioria dos algoritmos para mineração de padrões seqüenciais com restrições de expressões regulares também utilizam a técnica Apriori.

Em uma iteração k, é obtido um conjunto Ck constituído por k-seqüências candidatas a partir das (k-1)-seqüências do conjunto Fk, obtido na iteração anterior.

Em seguida, são podadas de Ck as k-seqüências que possuem pelo menos uma (k-1)-seqüência não pertencente a Fk.

A diferença entre o problema clássico de mineração de seqüências e o problema de mineração em questão, é que neste são geradas somente k-seqüências candidatas que satisfazem uma expressão regular R.

Na etapa de poda, não são podadas diretamente de Ck as k-seqüências que possuem pelo menos uma (k-1)-seqüência não pertencente a Fk, pois, o conjunto Fk m seqüências freqüentes e que satisfazem a expressão regular R.

Esta restrição é considerada porque a condição de ser freqüente é antimonotônica, e a condição de satisfazer a expressão regular R não é antimonotônica.

Por exemplo, a seqüência <{TV }{DV D}{DV D}> satisfaz a expressão regular (TV)DV, mas, a sub-seqüência <{DV D}{DV D}> não satisfaz.

Portanto, uma seqüência s só pode ser podada de Ck se ela possui uma sub-seqüência s0 que satisfaz R e que não pertence a F = F1 FFk, 1 pois, nesse caso com certeza s não é freqüente.

Com base no que foi que foi dito anteriormente é possível armar que quanto maior for a seletividade de R menos padrões são gerados e menos padrões são podados, o que não é interessante, uma vez que um dos objetivos deste tipo de restrição é diminuir a quantidade de padrões que serão levados para a etapa de avaliação, etapa esta, considerada a mais cara computacionalmente na maioria dos algoritmos de mineração de dados.

Para tentar achar um equilíbrio entre a quantidade de padrões gerados e a quantidade de padrões podados, alguns algoritmos, como por exemplo, os da família SPIRIT e SPIRIT-Log, consideram um relaxamento de R, ou seja, uma restrição R0 mais fraca que R, durante o processo de mineração.

A formulação geral do problema de mineração de padrões seqüenciais proposicionais com restrições de expressões regulares é dada por, Dado, Um banco de dados BD, um suporte mínimo e uma expressão regular R.

Encontrar, Todas as seqüências freqüentes com relação a BD, e que satisfazem R.

Garofalakis e Shim foram os primeiros a introduzirem restrições de expressões regulares no processo de mineração.

Eles desenvolveram os algoritmos da família SPIRIT para mineração de padrões seqüenciais proposicionais e incorporam este tipo de restrição no processo de mineração.

Os Algoritmos SPIRIT.

A família de algoritmos SPIRIT é constituída por quatro algoritmos que exploram diferentes graus de seletividade de uma expressão regular utilizada nas etapas de geração e poda dos padrões candidatos.

Os quatro algoritmos da família SPIRIT são, SPIRIT(N), SPIRIT(L), SPIRIT(V) e SPIRIT(R).

Cada um deles considera um relaxamento R0 cuja seletividade aumenta na seguinte ordem, SPIRIT(N) < SPIRIT(L) < SPIRIT(V) < SPIRIT(R).

Estes algoritmos associam um autômato AR à expressão regular R no processo de mineração.

SPIRIT(N), não impõe nenhuma restrição às seqüências, apenas exige que todos os itens de uma seqüência s apareçam em R.

SPIRIT(L), considera somente seqüências legais com respeito a algum estado do autômato AR.

Uma seqüência s =< s1 s sn > é legal com respeito a um estado q de AR se existe um caminho no autômato que começa no estado q e percorre a palavra s1 s sn.

SPIRIT(V), considera somente seqüências válidas com respeito a algum estado do autômato AR.

Uma seqüência s =< s1 s sn > é válida com respeito a um estado q de AR se existe um caminho no autômato que começa no estado q e termina em um estado nal e que percorre a palavra s1 s sn.

SPIRIT(R), não considera relaxamentos, corresponde exatamente a R.

Considera somente seqüências válidas, ou seja, aquelas que começam no estado inicial e terminam em um estado nal de AR.

Estes quatro algoritmos encontram seqüências freqüentes que satisfazem o relaxamento R0 da expressão regular R.

Em uma etapa de pós-processamento, eles eliminam de F = F1 Fk os padrões que não satisfazem a expressão regular R original.

O SPIRIT(R), por não considerar um relaxamento de R, não realiza a etapa de pós-processamento.

Garofalakis e Shim avaliaram os quatro algoritmos e chegaram a conclusão de que o algoritmo SPIRIT(V) é o mais eficiente dos quatro, por esse motivo, ele será o único a ser detalhado.

Detalhes dos outros algoritmos podem ser encontrados em.

O Algoritmo SPIRIT(V).

Considere um autômato AR associado a uma expressão regular R.

Ck(q) e Fk(q) correspondem, respectivamente, ao conjunto das k-seqüências candidatas e das k-seqüências freqüentes e válidas com respeito ao estado q de AR.

Geração, Para que uma seqüência s = <s1 s sk> seja válida com respeito a algum estado q1 de AR, é preciso que seu suxo <s sk> seja válido com respeito a algum estado qde AR e que exista um transição q1 q(indo de q1 para q2, com rótulo s1) em AR.

Portanto, o conjunto Ck é constituído como segue.

Para cada estado q de AR, onde q q0, para cada seqüência <s1 sk > de Fk (q0), a seqüência <si s1 sk > é inserida em Ck(q).

O conjunto Ck é a união desses conjuntos para cada estado q de AR.

Considere o autômato AR associado a uma expressão regular R e um conjunto de seqüências, freqüentes e válidas com respeito aos estados de AR, F= F2(q0) F2(q1) F2(q, onde, F2(q0) = {<a c>, <a e>}, F2(q1) = {<b c>}, F2(q2) = {<d e>} e F2q = {}.

O conjunto Cdas seqüências candidatas e válidas com relação a AR é calculado da seguinte forma, Autômato AR associado a uma expressão regular R.

Poda, Para cada seqüência s de Ck são calculadas todas as sub-seqüências maximais de s que são válidas com respeito a algum estado de AR, ou seja, as maiores sub-seqüências possíveis menores que k.

Se algumas dessas seqüências não está em Padrões seqüenciais de primeira ordem são mais expressivos que padrões seqüenciais proposicionais e podem ser minerados em diversos domínios de aplicação.

Por exemplo, padrões minerados podem representar seqüências de comandos de usuários UNIX ou seqüências de páginas Web acessadas por usuários ou seqüências de compras de clientes ao longo do tempo.

Um exemplo da mineração deste tipo de padrão pode ser o seguinte, Suponha que o administrador de um departamento de Tecnologia da Informação (TI) de uma companhia esteja interessado em descobrir seqüências de comandos do Unix que são freqüentemente utilizados pelos funcionários do departamento.

O administrador de TI pode considerar o log do Unix que armazena seqüências de comandos do tipo ls,vi artigo, mv artigo,latex artigo, rm artigo e converter cada seqüência de comandos em uma seqüência de átomos de primeira ordem da forma ls, vi(artigo), mv(artigo), latex(artigo), rm(artigo).
Possibilitando a descoberta de padrões da forma <vi(X) rm(X)>, onde, vi rm é uma a seqüência de comandos (predicados) freqüentemente requerida pelos usuários e X é uma variável representando nomes de arquivos (parâmetro).

O problema de mineração de padrões seqüenciais de primeira ordem foi amplamente estudado por Jacobs e Blockeel em, onde propuseram formalismos para mineração destes padrões sobre logs de usuários do sistema Unix.

Outro importante trabalho que contribuiu no estado da arte de mineração de padrões seqüenciais de primeira ordem foi desenvolvido em 200por Lee e Raedt.

Neste trabalho eles apresentaram um formalismo lógico baseado em Programação Lógica Indutiva (PLI), chamado SeqLog, para especicar padrões seqüenciais de primeira ordem.

A seguir serão descritos alguns conceitos, apresentados em, fundamentais para o entendimento deste problema.

Neste caso são consideradas terminologias tradicionais da lógica de primeira ordem e como norma, as variáveis são designadas por letras maiúsculas e as constantes por letras minúsculas.

Átomo.

Um átomo denido por p(t1,t2,tn), consiste em um predicado p seguido por n termos ti, onde, ti é uma variável ou uma constante.

Seqüência simples.

Uma seqüência simples s é uma lista ordenada de átomos denotada por <s1 s sn>, onde, si é o i-ésimo elemento de s.

O comprimento de uma seqüência s corresponde ao número de átomos de s.

Esse tipo de seqüência é conhecida como seqüência lógica.

Exemplo 237 Uma seqüência simples de comprimento pode ser dada por <vi(artigo) mv(artigo) latex(artigo)>, onde, vi,mv e latex são predicados e artigo é uma constante e o átomo latex(artigo) ocorre após o átomo mv(artigo) que ocorre após o átomo vi(artigo).

Seqüência complexa.

Uma seqüência complexa s é uma lista ordenada de átomos separados por operadores denotada por <s1 op1 sopopn1 sn>.

Os dois operadores empregados são o operador sucessor direto ¡ (que é freqüentemente omitido) e seu fecho transitivo <.

As seqüências complexas são utilizadas para representar padrões seqüenciais.

Exemplo 238 Uma seqüência complexa (padrão seqüencial) pode ser dada por <vi(artigo) < mv(artigo)>, que signica que o átomo mv(artigo) ocorre em algum lugar após o átomo vi(artigo).

Sub-seqüência.

Uma seqüência a = <a1 a an> é uma sub-seqüência de uma seqüência b = <b1 b bm>, com m n, se existe inteiros i1 < i< < in tal que a1 = bi,a= bi,an = bi.

Exemplo 239 A seqüência s1 = <ls vi(X)> é uma sub-seqüência de s= <ls vi(X) mv(X) latex(X)> e s= <ls vi(X) mv(X)> é uma sub-seqüência de s2.

Entretanto, snão é uma sub-seqüência de s= <ls vi(X) latex(X) rm(X)>, pois, mv(X) 6= latex(X) e mv(X) 6= rm(X).

Substituição.

Uma substituição é um conjunto da forma {v1 7 t1,vn 7 tn}, onde, vi são variáveis e ti são variáveis ou constantes.

Seja s = <s1 sn> uma seqüência, s denota a aplicação de em s, assim, s = <s1 sn>.

Exemplo 2310 A forma = {X 7 z}, é uma substituição.

Já a forma = {z 7 X}0 não é uma substituição, pois, z não é uma variável.

Quando a substituição é aplicada em um seqüência s = <vi(X) mv(X)> obtemos uma seqüência s0 = <vi(z) mv(z)>.

Subsunção.

É dito que uma seqüência a subsume uma seqüência b, denotado por a v b, se existe uma substituição, tal que, a é uma sub-seqüência de b.

É dito que a é mais geral que b, ou que b é mais especíca que a.

Exemplo 2311 Considere as seqüências s1 = <vi(X) mv(Y)> e s= <vi(z) mv(t) mr(w)>, s1 subsume s2, se for considerada a substituição = {X 7 z,Y 7 t}.

Banco de dados de seqüências.

Em um banco de dados de seqüências BD cada seqüência é uma lista ordenada de átomos com constantes em todos os termos.

Essas seqüências são chamadas de seqüências de entrada, diferente das seqüências dos padrões, chamadas de seqüências lógicas.

As denições de suporte e seqüência freqüente são similares as apresentadas nas denições 235 e 236, respectivamente.

Exemplo 231Considere a seqüência s = <vi(X) < mv(Y)> e o banco de dados BD = {<vimvrm>,<virmmv>,<virm>}.

Note que a seqüência s subsumes (está contid duas seqüências de BD, portanto, sup(s) = = 066%.

Se for considerado um suporte mínimo = 50%, a seqüência s é freqüente.

Com os principais conceitos entendidos, a formulação geral do problema da mineração de padrões seqüenciais de primeira ordem é denida por, Dado, Um banco de dados de seqüência BD e um suporte mínimo.

Encontrar, Todas as seqüências freqüentes em relação a BD e.

O SeqLog.

O SeqLog é um formalismo para expressar padrões seqüenciais de primeira ordem freqüentes em bancos de dados de seqüências.

Como denido, Lee e Raedt distinguem seqüências simples (não possuem operador) de seqüências complexas (cujos átomos são relacionados pelo operador <) que são utilizadas para representar padrões seqüenciais.

As seqüências podem ser constituídas por átomos, por exemplo, da forma p(f(a,X),b,Y), onde, p é um predicado, f é uma função de aridade 2, a e b são constantes e X e Y são variáveis.

Uma característica desse formalismo é o uso restrições de freqüência da forma am, onde, a é uma restrição antimonotônica, e m é uma restrição monotônica.

Maiores detalhes sobre estas propriedades do SeqLog podem ser encontradas em.

Ainda em, Lee e Raedt apresentaram um algoritmo, chamado MineSeqLog, desenvolvido com base no SeqLog para a mineração de padrões seqüenciais de primeira ordem.

O Algoritmo MineSeqLog.

O algoritmo MineSeqLog foi desenvolvido para minerar seqüências freqüentes expressas em SeqLog e também trabalha em iterações, gerando padrões mais específicos a cada iteração.

Além do banco de dados e das restrições de freqüncia, o algoritmo MineSeqLog exige como entrada um conjunto SF com nomes de predicados e suas aridades.

Na primeira iteração é gerado um conjunto de padrões candidatos C1, constituído por átomos gerados a partir de SF.

Então o suporte de cada elemento de C1 é calculado percorrendo o banco de dados.

Na iteração k são aplicados operadores de renamento nos padrões de Fk gerando assim padrões mais específicos que são inseridos em Ck.

O suporte dos padrões de Ck é calculado e os padrões freqüentes são inseridos em Fk.

No nal da execução o conjunto F = F0 Fi, onde, i é a última iteração, contém todos os padrões freqüentes.

O algoritmo retorna todos os padrões maximais de F, para isso, são podados todos os sub-padrões de padrões em F.

A fase da geração é executada como segue.

Geração, Na iteração k são gerados padrões mais específicos a partir dos padrões contidos em Fk, gerado na iteração anterior.

Para renar (especializar) os padrões, são utilizados quatro operadores, Lengyhening, Promotion, UniVar e Instantiation.

Esses operadores foram criados de forma que sejam optimais, ou seja, os padrões são gerados por um único caminho, isso evita que sejam gerados padrões duplicados, e completos, ou seja, dado um padrão p, são gerados todos os padrões aos quais p é sub-seqüência, garantindo que não seja perdido nenhum padrão que possa satisfazer as restrições de freqüncia.

Em cada iteração, somente um dos quatro operadores de renamento é aplicado sobre um padrão, garantindo que ele seja renado iteração por iteração aumentando em um seu tamanho.

Cada padrão q tem associado a ele um vetor v(q) denido como um vetor dimensional da forma (l,p,u,i), onde, l é o número de predicados em q, p é número de operadores ¡ em q, u é o número de argumentos em q menos o número de variáveis distintas (sem considerar argumentos constantes) em q menos o número de constantes em q e i é o número de constantes em q.

O nível de renamento de q é |v(q)| = l + p + u + i.

Por exemplo, se |v(q)| = 1, então, q pertence a iteração 1, se |v(q)| = 2, então, q pertence a iteração 2.

Os quatro operadores devem obedecer algumas restrições para que as duas propriedades (optimal e completo) sejam garantidas.

O operador Lengthening é aplicado em um padrão q somente se v(q) = (l, 0, 0, 0).

Ele insere um novo átomo com o operador < no m da seqüência resultando em v(q0) = (l + 1, 0, 0, 0).

O operador Promotion é aplicado em um padrão q somente se v(q) = (l,p, 0, 0).

Ele promove um operador < em ¡ (que é freqüentemente omitido), resultando em v(q0) = (l,p + 1,0,0).

O operador UniV ar é aplicado em um padrão q somente se v(q) = (l,p,u,i).

Ele unica duas variáveis, mas a variável escolhida para ser unicada não pode ser seguida por nenhuma outra variável que já tenha sido unicada, resultando em v(q0) = (l,p,u + 1,i).

O operador Instantiation é aplicado em um padrão q somente se v(q) = (l,p, 0,i).

Ele substitui uma variável por uma constante, mas nenhuma variável pode ser instanciada a esquerda de outra variável já instanciada, resultando em v(q0) = (l,p, 0,i + 1).

Exemplo 231Considere um padrão q7 = a(X) b(Y,g) < c(h,X), onde, v(q= (3,1,2,1).

Esse padrão pode ser obtido a partir de um padrão q0 =, onde, v(q0) = (0,0,0,0).

Primeiramente o operador Lengthening é aplicado em q0 obtendo q1 = a(X1), onde, v(q1) = (1,0,0,0).

Aplicando Lengthening em q1 pode-se obter q= a(X1) < b(Y,G), onde v(q2) = (2,0,0,0).

Aplicando-se novamente Lengthening em qpode-se obter q= a(X1) < b(Y,G) < c(H,X2), onde v(q = (3, 0, 0, 0).

O padrão q= a(X1) b(Y,G) < c(H,X2), onde v(q4) = (3, 1, 0, 0), pode ser obtido aplicando Promotion em q3.

Aplicando Instantiation em qpode-se obter q5 = a(X1) b(Y,g) < c(H,X2), onde v(q= (3,1,1,0).

Aplicando Instantiation em q5 pode-se obter q6 = a(X1) b(Y,g) < c(h,X2), onde v(q= (3, 1, 2, 0).

Aplicando UniV ar em q6 obtem-se q7 = a(X) b(Y,g) < c(h,X), onde v(q= (3,1,2,1).

Este problema de mineração é bem parecido com o apresentado na seção anterior.

A diferença é que aqui são consideradas restrições de expressões regulares introduzidas no processo de mineração.

Sua formulação geral é dada por, Dado, Um banco de dados BD, um suporte mínimo e uma expressão regular R.

Encontrar, Todas as seqüências freqüentes em relação a BD, e que satisfazem Contribuindo para a mineração de padrões seqüenciais de primeira ordem com restrições, um importante trabalho foi apresentado em 200por Masson e Jacquenet, onde foram introduzidos os algoritmos da família SPIRIT-Log que mineram os mesmos tipos de padrões que o MineSeqLog, mas, utilizam restrições de expressões regulares no processo de mineração.

Os algoritmos SPIRIT-Log.

O algoritmo MineSeqLog utiliza restrições monotônicas e antimonotônicas no processo de mineração.

Masson e Jacquenet não utilizaram esta aproximação porque queriam incorporar restrições sintáticas para minerar seqüências lógicas e estas restrições não necessariamente são monotônicas e antimonotônicas.

Por esse motivo adaptaram os algoritmos SPIRIT para a mineração de padrões seqüenciais de primeira ordem.

Similar à família SPIRIT, a família SPIRIT-Log é constituída por quatro algoritmos que trabalham em iterações e também exploram diferentes graus de seletividade de uma expressão regular R utilizada nas etapas de geração e poda dos padrões candidatos.

A expressão regular R é denida pelo usuário.

Durante o processo de mineração, um autômato AR é associado a R e são consideradas somente seqüências aceitas por AR.

Uma seqüência s é aceita por AR se a lista de predicados de s, correspondente a uma string, é aceita por AR.

Por exemplo, considere o autômato associado a expressão regular R = mv cd emacs|gcc gc.

A seqüência < mv(F,cd(emacs(F)gcc(F,E) > é aceita por AR.

Automato AR associado a expressão regular mv cd emacs|gcc gc.

Os quatro algoritmos principais da família SPIRIT-Log são SPIRIT-Log(N), SPIRIT-Log(L), SPIRIT-Log(V) e SPIRIT-Log(R).

Cada um deles considera um relaxamento R0 cuja seletividade aumenta na seguinte ordem, SPIRIT-Log(N) < SPIRIT-Log(L) < SPIRIT-Log(V) < SPIRIT-Log(R).

As restrições de cada um desses algoritmos são as mesmas dos da família SPIRIT e detalhes de cada uma foram apresentados na seção 232.

Masson e Jacquenet avaliaram esses quatro algoritmos e chegaram a conclusão de que o algoritmo SPIRIT-Log(L) é o mais eficiente, por isso, ele será o único que ser detalhado.

Caso o leitor tenha interesse nos outros três algoritmos, consulte.

O Algoritmo SPIRIT-Log(L).

Considere um autômato AR associado a R.

Ck(q) e Fk(q) correspondem, respectivamente, ao conjunto das k-seqüências candidatas e das k-seqüências freqüentes que são legais com respeito ao estado q de AR.

Geração, As k-seqüências lógicas candidatas para um estado q são construídas como segue.

Para toda seqüência s Fk (q), se existe uma transição q q0 (indo de q para q0, onde p é o predicado no qual s1 é construído) em AR, então, para toda seqüência t em Fk (q0), <s sk > e <t1 tk > devem ser unicáveis, ou seja, deve existir uma substituição, tal que tj = sj +1 para 1 j k 2.

São adicionadas em Ck todas as seqüências da forma <s 0 tk >, onde 0 são todas as substituições possíveis das variáveis de tk-1 por algumas variáveis de s1.

Considere o autômato AR e as seqüências s = <p(X,R) q(Y) r(X,S)> F3(q0) e t = <q(L) r(N,T) s(J,T)> F3(q1).

Con-siderando a substituição = {Y 7 L,X 7 N,S 7 T}, o suxo <q(Y) r(X,S)> e o prexo <q(L) r(N,T)> podem ser unicados.

Sendo assim, todas as substituições possíveis entre (J,T) e (X,R) são, {², {J 7 X}, {T 7 X}, {J 7 R}, {T 7 R}, {J 7 X,T 7 X}, {J 7 R,T 7 R}, {J 7 X,T 7 R}, {J 7 R,T 7 X}}, onde ² é a substituição identidade.

Finalmente, o conjunto C4(q0) é constituído por, Automato AR.

Poda, Para cada seqüência s de Ck são calculadas todas as sub-seqüências maximais de s que são legais com respeito a algum estado de AR.

Se algumas dessas seqüências não unica com nenhuma seqüência de F = F1 Fk, s é podada de Ck.

Padrões temporais que representam o tempo por intervalos são aqueles em que os eventos ocorrem em determinados períodos de tempo durante o período entre duas horas, durante o período entre duas datas, et.

Estes padrões são chamados de padrões intervalares.

Grande parte dos autores de trabalhos sobre mineração de padrões intervalares se baseiam em um formalismo lógico, chamado de Lógica Temporal de Intervalos (LTI), desenvolvido por Allen.

Os aspectos dinâmicos do mundo, principalmente os que dizem respeito a estados, fatos ou acontecimentos, têm sido motivo de grande interesse nas mais variadas disciplinas.

Em 1983, Allen desenvolveu a Lógica Temporal de Intervalos (LTI), posteriormente aprimorada em, que é signicantemente mais expressiva e mais natural para representar o tempo que outras aproximações, como por exemplo em Inteligência Articial.

Esta lógica considera períodos de tempo, relacionamentos entre estados e seus efeitos e é denida como uma LTPO ordenada com tempo e dados ordenados, onde o tempo é representado por períodos ou intervalos, diferente da Lógica Temporal Linear (LTL), onde o tempo é representado por instantes ou pontos.

Na LTI, Allen considera um período de tempo como sendo o tempo associado a algum evento e propõe representações e considerações para descrever a estrutura temporal básica usada na lógica.

Para Allen, períodos de tempo são intervalos e os limites que denem o início e o m dos intervalos são considerados pontos, por isso, ele não faz relacionamentos entre pontos (não períodos) e intervalos (períodos).

Para relacionar dois intervalos, Allen deniu 1relacionamentos possíveis, através de predicados temporais (gura 25).

Por exemplo, before(i,j) signica que o intervalo i ocorre antes do intervalo j e after(j,i) é o relacionamento inverso, meets(i,j) signica que o intervalo i termina no mesmo instante em que o intervalo j começa e metby(j,i) é o relacionamento inverso, e assim por diante.

Possíveis relacionamentos entre dois intervalos (adaptação de).

Assim como os padrões seqüenciais, os padrões intervalares também podem ser proposicionais ou de primeira ordem.

Nas próximas seções serão apresentados estes problemas.

A mineração de padrões intervalares proposicionais pode ser aplicada com sucesso em diversas áreas como medicina, agropecuária, agronomia, etc.

Os padrões minerados por este tipo de problema têm como objetivo representar relacionamentos temporais existentes entre eventos que ocorreram durante algum período de tempo para que futuros comportamentos possam ser preditos com base em acontecimentos passados.

Em 2001, Frank Höppner usou a LTI de Allen pela primeira vez para tratar o problema de descoberta de padrões intervalares sobre bancos de dados temporais.

Nesta seção serão descritas sucintamente as principais idéias propostas por Höppner.

Caso o leitor tenha interesse em maiores informações consulte denição 241 (Banco de dados de seqüências de estado).

Seja BD um banco de dados de seqüências de estados.

Um estado s BD acontece durante um período de tempo, onde, a representa o inicio e b representa o m do estado s.

Uma seqüência de estados em BD é uma serie de triplas representando intervalos de estados da forma (a1,s1,b1), (a2,s2,b2), (an,sn,bn), onde, ai ai +1 e ai < bi.

Höppner não exige que um estado termine antes do início de outro, entretanto, todo estado deve ser maximal.

Estado maximal.

Um estado (ai,s,bi) é maximal se não existe nenhum (aj,s,bj) na seqüência, tal que, sobreponha (overlaps) ou encontre (meets) um ao outro.

Se o estado não for maximal, então ele é unido com o outro em um único intervalo, ou seja, (min(ai,aj),s,max(bi,bj)), onde, min(ai,aj) retorna o menor valor, ai ou aj, e max(bi,bj) retorna o maior valor, bi ou bj.

Exemplo 241 Considere a seqüência s = (1,fluoxetina, (2,paracetamol,6), (3,fluoxetina,6).

O estado fluoxetina não é máximal.

Portanto, os estados fluoxetina devem ser unidos, resultando em s = (1,fluoxetina, 6), (2,paracetamol, 6).

Relacionamentos entre os estados.

Dados n estados, a posição de cada intervalo com relação ao outro é representada por uma matriz n × n, representada por R, cujos elementos R descrevem os relacionamentos entre os estados si e sj.

O estado A é sempre seguido por B, e o espaço entre A e B é coberto por C.

A matriz que relaciona os intervalos é mostrada, onde, b = before, a = after, o = overlaps e ob = overlappedby.

Um padrão é um par (s,R), onde, s é uma seqüência de estados da forma (a1,s1,b1), (an,sn,bn) e R representa o relacionamento entre.

O tamanho de um padrão P, denotado por dim(P), é o número de intervalos de P.

Se dim(P) = k, então, P é um k-padrão.

Sub-padrão.

Um padrão (sA,R é um sub-padrão de (sB,R, denotado por (sA,R v (sB,R, se dim(sA,R dim(sB,R e existe um mapeamento, tal que, i,j {1,dim(sA,R}, sA(i)=sB((i))RA.

Höppner considera somente os padrões que podem ser observados por um usuário dentro de uma janela de deslocamento de largura tmax.

O suporte de um padrão P denido por sup(P) é o tempo total em que P pode ser observado dentro desta janela.

Dado um suporte mínimo, P é freqüente em um banco de dados de seqüências de estados BD se sup(P).

Este problema de mineração é dado em linhas gerais por, Dado, Um banco de dados de seqüências de estados BD e um suporte mínimo.

Encontrar, Todos os padrões freqüentes em relação a BD e.

Algoritmo de Mineração Padrões Temporais Intervalares Proposicionais.

Para encontrar os padrões freqüentes (F1) é calculado o suporte de todos os padrões do banco de dados.

Na iteração k são gerados padrões candidatos (Ck) a partir dos padrões freqüentes de Fk.

A seguir são removidos de Ck todos os padrões candidatos que não 1 satisfazem a propriedade Apriori.

Os padrões restantes são avaliados e os que possuírem suporte maior ou igual ao suporte mínimo estipulado pelo usuário são inseridos em Fk.

Este procedimento é repetido até que mais nenhum padrão freqüente possa ser encontrado.

Geração, Para gerar um k-padrão, são unidos dois (k-1)-padrões freqüentes que possuem um prexo de tamanho k-em comum.

Considere dois (k-1)-padrões S e T, que possuem as seqüências de estados 0,k-2,s e 0,k-2,t, respectivamente.

Um k-padrão P = (sP,RP) é gerado, onde RP = r representa o relacionamento entre s e t.

Note que a sub-matriz A é igual em RS,RT e RP.

Em RP, os relacionamentos entre os primeiros k-estados são os mesmos de RS e RT, e r pode ser um dos 1relacionamentos definidos por Allen para relacionar s e t, ir é o inverso de r.

Gerando um k-padrão P a partir de dois (k-1)-padrões S e T Poda, Além de usar a propriedade Apriori para podar os padrões que possuem sub-padrões não freqüentes, Höppner usa outra técnica de poda baseada na transitividade dos relacionamentos temporais.

Maiores detalhes sobre essa técnica de poda podem ser encontrados em.

Avaliação, Para calcular o suporte dos padrões candidatos, a seqüência estados é percorrida pela janela de deslocamento.

Cada estado da seqüência do padrão possui um contador que é incrementado sempre que o estado é visível dentro da janela.

No nal, o suporte dos padrões é a soma dos contadores.

Detalhes sobre o cálculo do suporte podem ser encontrados em.

Nesta seção será abordado o problema de mineração de padrões intervalares de primeira ordem.

Esses padrões possuem grande expressividade e podem ser aplicados com sucesso em diversas áreas como medicina (pode-se descobrir se o uso de determinados medicamentos durante certos períodos de tempo inuenciam na evolução de sintomas em pacientes).
Agropecuária (pode-se descobrir se determinados períodos de vacinação inuenciam ou não no desenvolvimento de rebanhos), agricultura (pode-se descobrir a relação entre o uso de fertilizantes e agrotóxicos para um bom desenvolvimento de plantações), etc.

Lattner e Herzog deniram uma avaliação um pouco diferente da apresentada na maioria dos trabalhos sobre mineração de padrões temporais baseados na técnica Apriori.

Cada padrão é avaliado em 5 funções diferentes, tamanho relativo, freqüência relativa, coerência, restritividade temporal e preferência dos predicados.

O suporte de um padrão q é obtido multiplicando os valores de cada uma das 5 funções por pesos diferentes, os resultados são somados é divididos pela soma dos pesos.

Detalhes destas funções podem ser encontrados em.

Um padrão q é considerado freqüente se seu suporte for maior que um suporte mínimo.

A formulação geral deste problema de mineração é dada por, Dado, Um banco de dados BD e um suporte mínimo.

Encontrar, Todos os padrões freqüentes em relação a BD e.

Para minerar o padrão denido anteriormente, Lattner e Herzog criaram alguns algoritmos apresentados em.

Embora mais complexos, são mais detalhados os algoritmos apresentados em, por isso eles são os únicos a serem descritos.

Algoritmo de Mineração de Padrões Intervalares de Primeira Ordem.

O algoritmo principal desenvolvido por Lattner e Herzog também é baseado na técnica Apriori, portanto trabalha em iterações.

Na primeira iteração é gerado um conjunto C1 constituído por padrões candidatos.

Em uma iteração k são gerados k-padrões (Ck) através de algoritmos específicos e em seguida todos são avaliados.

Os padrões que não possuem suporte maior ou igual a um suporte mínimo são podados de Ck e os que restaram são inseridos em um conjunto Fk de padrões freqüentes.

Na iteração k + 1 são gerados (k+1)-padrões a partir dos padrões freqüentes de Fk.

Geração, Lattner e Herzog desenvolveram quatro algoritmos para a geração de novos padrões.

Um primeiro algoritmo especializa um padrão inserindo um novo átomo com variáveis que ainda não foram usadas no padrão.

Um segundo algoritmo especializa um padrão inserindo uma nova relação temporal para qualquer par de predicados do padrão que ainda não foram relacionados.

Um terceiro algoritmo especializa um padrão unicando um par de variáveis.

Um quarto e último algoritmo substitui um predicado mais geral por um predicado mais específico.

Detalhes sobre esses quatro algoritmos podem ser encontrados.

Poda, A única poda utilizada por Lattner e Herzog diz respeito a um suporte mínimo.

Portanto o algoritmo não utiliza a propriedade Apriori, o que faz com que seja desperdiçado processamento em padrões que certamente não serão freqüentes.

Avaliação, Em cada iteração, após a etapa da geração, o banco de dados é percorrido e para cada padrão são obtidos cinco valores que no m da avaliação resultam em uma porcentagem que é o suporte total do padrão.

Esse problema ainda foi pouco explorado no meio acadêmico.

Um dos principais trabalhos relacionado a esta abordagem foi publicado em 2005 por Sandra de Amo.

O trabalho de Sandra de Amo é parecido com o de Lattner e Herzog, sendo que a diferença fundamental entre eles é que em a única forma de restrição dos padrões é um suporte mínimo estipulado pelo usuário, e em, além do suporte mínimo foram introduzidas restrições de expressões regulares similares às utilizadas nos algoritmos da família SPIRIT.

Para facilitar o entendimento serão apresentados agora alguns dos principais conceitos definidos em.

Considere três conjuntos disjuntos de símbolos P (predicados), V (variáveis de dados) e C (constantes de dados).

Considere também um conjunto de predicados temporais PT = {before, meets, overlaps, starts, during, finishes} (predicados definidos por Allen), um conjunto Vt (variáveis temporais) e um esquema de banco de dados R = {K, R1, Rn}, onde cada esquema relacional Ri tem aridade ki e K tem aridade m 1.

A partir deste ponto, variáveis serão representadas por letras minúsculas e constantes simplesmente pelos seus valores.


Um padrão é uma tripla (K,D,T), onde K é um átomo de dados especial da forma K(x1,xn), chamado de referência, com xi V, D = {p1(s1,sn,e1),pk(s1,sn,ek)} é um conjunto de átomos de dados, onde pi P, s1,sn V C e ei Vt.

T é um conjunto de átomos temporais da forma r(e,f), onde r PT e e,f Vt e são avaliadas em intervalos, onde a representa o início e b representa o m do intervalo.

Exemplo 246 Considere um padrão P = (K,D,T), onde, K = Paciente(x), D = {Medicamento(x,y,e),Sintoma(x,z,f)} e T = {before(e,f)}.

Intuitivamente esse padrão nos diz que um paciente x que tomou um medicamento y durante um período e apresentou um sintoma z em um período futuro f.

Note que o interesse é sempre em analisar o comportamento dos pacientes registrados na tabela Paciente, e por isso Paciente(x) é chamado de referência.

Neste problema de mineração as expressões regulares R são denidas sobre um conjunto de modos e devem ser satisfeitas pelos padrões.


Um modo sobre R é uma expressão da forma R(u1,us,#), onde cada ui V ou é um símbolo $.

O símbolo # é um novo símbolo e R é um dos predicados Ri R.

Um átomo de dados A é de acordo com um modo R(u1,us, #) se A = R(y1,ys,e) e para cada i = 1,s tem-se,Se ui V, então yi = ui.

Se ui =, então yi V C e Vt.

Exemplo 247 Considere o modo Medicamento(x,$,#) e os átomos de dados Medicamento(x,fluoxetina,e) e Medicamento(y,fluoxetina,e), o primeiro átomo é de acordo com modo, já, o segundo não é, pois, a condiçãonão é satisfeita.

Seja um conjunto de modos sobre R.

Em são consideradas linguagens regulares, (conjunto de string) sobre o alfabeto, especicadas por expressões regulares.

Um padrão temporal P = (K, D, T), onde, D é visto como uma seqüência de átomos da forma < p1(t1,t1,e1),pk(t1,t1,ek >, com e1 < < ek, satisfazendo uma expressão regular R se,Existe uma string w1,w2,wn R, onde wi = pi(ui, ul,#) tal que, pi(t1,t1,ei) é de acordo com wi.

Para todo átomo de dados pi(t1,t1, ei) D, se uj = $ e xj é uma variável, então sj tem somente uma ocorrência em D.

Dado, Um banco de dados BD, um suporte mínimo e uma restrição R.

Encontrar, Todos os padrões freqüentes em relação a BD, e que satisfazem R.

Um protótipo chamado MILPRIT foi desenvolvido em com o objetivo de minerar padrões temporais definidos para este problema de mineração.

Este protótipo foi uma implementação preliminar muito ineficiente e possui algumas falhas.

Uma delas é o fato de não realizar gerenciamento de memória.

Com isso, é possível executá-lo somente sobre bancos de dados muito pequenos, uma vez que quando executado sobre bancos de dados grandes a memória principal é preenchida logo nos primeiros níveis (iterações) pelos padrões gerados fazendo com que a execução seja abortada.

Outra falha ocorre na etapa de geração dos padrões candidatos, uma vez que determinados padrões não são gerados ou são gerados padrões que não são interessantes para o usuário.

MILPRIT.

O MILPRIT foi desenvolvido baseado na técnica Apriori e contêm idéias básicas para a mineração de padrões temporais intervalares.

Diferentemente do algoritmo apresentado em, na etapa da poda o MILPRIT utiliza a propriedade Apriori, garantindo que somente padrões potencialmente freqüentes sejam levados para a etapa da avaliação, onde é empregado o cálculo de suporte tradicional.

É vericado por quantas tuplas do banco de dados um padrão é satisfeito e este valor é dividido pela quantidade total de tuplas da tabela de referência.

Na etapa de geração são gerados somente padrões válidos com respeito a R0.

Em linhas gerais, na iteração k é gerado um conjunto de padrões candidatos Ck a partir dos padrões freqüentes e válidos contidos em Fk, obtido na iteração anterior.

São podados de Ck todos os padrões que possuem sub-padrões válidos e que não estejam em Fk, ou seja, não são freqüentes.

O banco de dados é percorrido para calcular o suporte de todos os padrões de Ck, os padrões que possuem suporte maior ou igual a um suporte mínimo estipulado pelo usuário são considerados freqüentes e são inseridos em Fk.

A seguir, descrevemos a etapa de geração.

Geração, Na fase da geração da iteração k são gerados padrões mais específicos a partir dos padrões contidos em Fk.

Para especializar os padrões são utilizados dois operadores de especialização, o operador de extensão e o operador de instanciação que possuem as mesmas propriedades (optimais e completos) dos operadores definidos em e apresentados na seção 233.

Somente um deles é aplicado de cada vez em um padrão de uma determinada iteração, garantindo que ele seja especializado iteração por iteração aumentando em um seu tamanho.

Cada padrão P = (K, D, T) tem associado a ele um vetor de renamento, denido por v(P) = (n, onde n é o tamanho (número de átomos de dados) de D e c é o número de constantes qua aparecem em D.

O nível de renamento de P, denotado por l(P) é denido como n + c.

Por exemplo, o padrão P = (Paciente(x), {Medicamento(x,fluoxetina,e),Sintoma(x,y,f)} tem v(P) = (2,1), portanto, l(P) = 3.

Com isso, P pertence a iteração 3.

Para garantir as duas propriedade do primeiro parágrafo, os dois operadores de especialização devem obedecer algumas condições.

O operador de extensão só pode ser executado sobre um padrão P se v(P) = (n, 0), ou seja, se P não tem nenhuma constante.

O operador de extensão produz um conjunto de padrões P0 a partir de P inserindo um novo átomo de dados no m de D e uma nova variável temporal em T.

O operador de instanciação executado sobre P produz um conjunto de padrões P0 a partir de P substituindo algumas variáveis de D por uma constante c de modo que não exista nenhuma constante após a variável instanciada em D, no mesmo átomo ou nos átomos que o seguem.

Exemplo 249 Considere a expressão regular R = Medicamento(x,$,#) Sintoma(x,$,#) e um padrão P1 = (Paciente(x),{Medicamento(x,y,e1)},T1).

Esse padrão pode ser especializado por extensão, resultando em um padrão P= (Paciente(x),{Medicamento(x,y,e1),Sintoma(x,z,e2)},T2), e por instanciação, resultando no padrão P= (Paciente(x), {Medicamento(x,fluoxetina,e1)}, T1).

O padrão Ppode ser especializado por extensão e por instanciação resultando em P= (Paciente(x),{Medicamento(x,y1,e1), Medicamento(x,y2,e2), Sintoma(x,z,e}, T e P5 = (Paciente(x),{Medicamento(x,fluoxetina,e1),Sintoma(x,z,e2)}, T2), respectivamente.

O padrão Pnão pode ser especializado por extensão, pois ele já tem uma constante e poderia gerar um padrão igual ao P5.

Neste capitulo foram abordadas as principais tarefas existentes na abrangente área de mineração de dados e foram detalhadas os principais conceitos e algoritmos desenvolvidos com o objetivo de possibilitar a mineração de padrões sobre bancos de dados temporais.

Como descrito, na literatura existem vários padrões temporais que são especicados por formalismos da Lógica Temporal Proposicional e recentemente muitos estudos têm sido focados em descobrir conhecimentos expressados pela Lógica Temporal de Primeira Ordem.

Por exemplo, pesquisas em Programação Lógica Indutiva (PLI), que propõem formalismos mais expressivos que aqueles usados até então para representar padrões temporais.

Tais formalismos são expressivos o suciente para especicar muitos padrões, como por exemplo para modelar logs de usuários do sistema Unix.

É preciso ter em mente que novos problemas surgem a todo momento.

Conseqüentemente, novos padrões devem ser modelados e novos formalismos e métodos elaborados para tornar possível sua mineração.

No próximo capítulo será formalizado o problema de mineração do padrão temporal híbrido que esta sendo proposto nesta dissertação.

Serão apresentados os principais tópicos necessários para a compreensão da solução proposta da mineração de padrões temporais híbridos em bancos de dados temporais.

O problema de mineração de padrões temporais híbridos ou pth's, que são padrões temporais de primeira ordem que representam o tempo explicitamente em termos de pontos e/ou intervalos, será amplamente abordado neste capítulo.

Uma das propostas deste trabalho é a criação de um novo padrão temporal, chamado padrão temporal híbrido ou pth, especicado por formalismos da Lógica Temporal de Intervalos.

Nesta seção primeiramente serão introduzidos os conceitos básicos desta lógica e as adaptações realizadas para especicar o pth.

Depois será especicado o banco de dados onde o pth pode ser minerado e em seguida denido formalmente o pth juntamente com o cálculo do suporte.

Finalizando a seção, será apresentada a tarefa de mineração básica deste problema de mineração.

Como dito na seção 241, Allen considera que períodos de tempo são intervalos e os limites que denem o início e o m dos intervalos são pontos, por este motivo ele não deniu relacionamentos entre pontos (não períodos) e intervalos (períodos) na LTI.

Como uma das propostas deste trabalho é especicar o pth por formalismos da LTI de Allen, ela teve que ser adaptada para tratar também casos onde o tempo é representado por instantes ou pontos e não somente por períodos ou intervalos.

A adaptação da LTI, realizada neste trabalho, considera um ponto como sendo um período de tempo sem duração, ou seja, um período de tempo que tem duração nula.

Assim, como pontos e intervalos são considerados períodos de tempo, a LTI adaptada considera relacionamentos entre eles.

Antes de denir formalmente a LTI adaptada para este trabalho, serão detalhadas as adaptações realizadas na estrutura temporal da lógica, que é de fundamental importância para o entendimento da mesma.

Estrutura Temporal.

Considere uma estrutura temporal Ttemp constituída pelos conjuntos disjuntos descritos a seguir, Vtemp, conjunto de variáveis do tipo tempo, chamadas de variáveis temporais.

Ctemp, conjunto de constantes do tipo tempo, chamadas de constantes temporais.

Ptemp, conjunto de predicados temporais (binários).

Os termos temporais são variáveis ou constantes temporais e são relacionados pelos predicados temporais Ptemp = {before, meets, overlaps, starts, during, nishes}.

Esses predicados foram definidos por Allen na LTI apresentada na seção 241.

O predicado equals, que também foi denido por Allen, não foi considerado na adaptação da LTI.

Assim, são considerados somente pth's representados por conjuntos de eventos.

O predicado temporal equals implica que um mesmo intervalo pode ser associado a eventos diferentes, e portanto, se ele fosse considerado, pth's representados por conjuntos de conjuntos de eventos também deveriam ser tratados, o que tornaria mais complexa a denição do problema.

Isto irá car claro após a proposição 311.

O conjunto Vtemp é constituído por dois conjuntos, Vit, conjunto de variáveis do tipo tempo chamadas de variáveis temporais intervalares e Vpt, conjunto de variáveis do tipo tempo chamadas de variáveis temporais pontuais.

No restante desta dissertação, para evitar confusão, as variáveis temporais de Vit serão denotadas por (e,f,g,e1,), e as variáveis temporais de Vpt serão denotadas por (s,t,u,s1,).

Os símbolos (,1,) serão utilizados para representar, sem distinção de tipo (intervalar ou pontual), as variáveis temporais de Vtemp = Vit Vpt.

O conjunto Vit tem como domínio o conjunto I = { | i,j N e i < j}.

Os elementos de I são intervalos, onde, i e j são números naturais mapeados em datas com i representando o inicio e j representando o m do intervalo.

O conjunto Vpt tem como domínio o conjunto N.

Os elementos de Vpt são números naturais também mapeados em datas.

É importante ter em mente que naturalmente um ponto pode ser visto como um intervalo, onde, i = j, assim, na LTI adaptada, um ponto é um período de tempo com início igual ao m, ou seja, um intervalo nulo.

Para representar os possíveis relacionamentos entre duas variáveis temporais, a LTI adaptada para este trabalho considera três casos, Caso 1 Possíveis relacionamentos entre dois intervalos São considerados doze possíveis variações de relacionamentos intuitivos que podem ocorrer entre dois intervalos, sendo seis primitivos e seis inversos.

O predicado equals é omitido.

Considerando as variáveis temporais intervalares e e f, onde e representa o intervalo, os seis predicados temporais primitivos são interpretados da seguinte maneira, Os seis predicados temporais inversos são interpretados da seguinte maneira.

Ilustra a semântica dos predicados primitivos definidos anteriormente.

Possíveis relacionamentos entre dois intervalos Caso Possíveis relacionamentos entre dois pontos Somente um predicado primitivo e um inverso é considerado para relacionar dois pontos.

Considerando as variáveis temporais pontuais s e t, onde, s representa o intervalo nulo, o único predicado temporal primitivo que relaciona dois pontos é interpretado da seguinte maneira, O único predicado temporal inverso é interpretado da seguinte maneira, Nos relacionamentos entre dois pontos os predicados meets, starts e finishes têm as mesmas propriedades do equals, ou seja, meets(s,t) starts(s,t) finishes(s,t) equal(s,t), por esta razão não são considerados.

Para que o overlaps seja considerado as duas variáveis temporais envolvidas devem representar intervalos, uma vez que por overlaps subentende-se que um determinado acontecimento X inicou em algum momento anterior a um determinado acontecimento Y ter iniciado, continuou ocorrendo durante algum tempo e terminou após Y ter iniciado e antes de Y ter terminado.

Como neste caso as duas variáveis envolvidas são pontos, o predicado overlaps não é considerado.

Para que o during seja considerado, a última variável envolvida (t) deve representar um intervalo, uma vez que por during subentede-se que um determinado acontecimento X ocorreu durante um determinado acontecimento Y.

Portanto, Y obrigatóriamente deve ser um intervalo.

Como neste caso a variável t é um ponto, o predicado during não é considerado.

Caso Possíveis relacionamentos entre ponto e intervalo e entre intervalo e ponto Oito predicados, sendo quatro primitivos e quatro inversos, são considerados.

Neste caso, é de fundamental importância a ordem de uma variável temporal em relação a outra, pois, isto restringe o uso de determinados predicados.

Considerando a variável temporal pontual s e a variável temporal intervalar e, onde s representa o intervalo nulo, os predicados temporais primitivos são interpretados da seguinte maneira, Os predicados temporais inversos são interpretados da seguinte maneira, Nos relacionamentos entre ponto e intervalo, respectivamente, o predicado meets não é considerado, pois meets(s,e) starts(s,e) e para evitar redundância optou-se por descartar o meets e considerar o starts.

Para que o predicado overlaps seja considerado, todas as variáveis temporais envolvidas devem ser intervalos, o que não acontece neste caso.

Nos relacionamentos entre intervalo e ponto, respectivamente, os predicados meets, overlaps, starts, during e finishes não são considerados para manter uma ordem sobre as variáveis temporais.

Esta ordem será explicada na proposição 312.

Outros motivos pelos quais os predicados meets, overlaps e during não são considerados são, meets(e,s) finishes(s,e) e o predicado finishes já é considerado no relacionamento entre ponto e intervalo, respectivamente.

O predicado overlaps não pe considerado pelo mesmo motivo do parágrafo anterior e para que o predicado during seja considerado, a última variável temporal envolvida (s) deve ser um intervalo, o que não acontece neste caso.

Possíveis relacionamentos entre um ponto e um intervalo acima da linha pontilhad, e entre um intervalo e um ponto abaixo da linha pontilhad Nesta dissertação são considerados somente os predicados temporais primitivos, uma vez que eles são sucientes para representar todos os possíveis relacionamentos entre variáveis temporais de qualquer tipo.

Lógica Temporal de Intervalos (LTI) Adaptad.

Considere a linguagem temporal LT constituída pelos conjuntos de símbolos Vtemp, Ctemp e Ptemp descritos acima, e pelos seguintes símbolos, Um conjunto de predicados Pred com aridade 1, cuja última entrada é do tipo tempo e as outras entradas são do tipo dado (dado,dado,tempo).

Dois símbolos de igualdade =t e =d.

Um conjunto Var de variáveis e Const de constantes disjuntos dos conjuntos Vtemp, Ctemp, e Ptemp, ambos do tipo dado.

Um termo de dado é uma variável ou uma constante do tipo dado.

A LTI adaptada também é um lógica de primeira ordem ordenada sobre a linguagem LT cujas fórmulas são denidas do seguinte modo, Se P Pred com aridade n+1, s1,sn são termos de dados e é um termo temporal, então, a expressão P(s1,sn,) e s1 =d ssão fórmulas da LTI adaptada.

Essas fórmulas são chamadas de átomos de dados.

Se r Ptemp e, são termos temporais, então r(,) e =t são fórmulas da LTI.

Essas fórmulas são chamadas de átomos temporais.

Se F e G são fórmulas da LTI adaptada, então F G,F G e ¬F são fórmulas da LTI adaptada.

Se F é uma fórmula da LTI adaptada e é uma variável temporal e x uma variável de dado, então eF e xF são fórmulas da LTI adaptada.

Os átomos de dados e os átomos temporais são chamados de fórmulas atômicas ou simplesmente átomos.

Exemplo 311 Considere Pred = {Hormonio, Birads} um conjunto de predicados com aridade 3, definidos do seguinte modo, Hormonio(x,y,e), a paciente x tomou o hormônio y durante o intervalo e.

Birads(x,z,s), a paciente x apresentou birads z no ponto s.

A seguinte expressão é uma fórmula da LTI adaptada, (x)(Hormonio(x,progesterona,e) (s)Birads(x,3,s) before(e,s)) Esta fórmula intuitivamente signica que para qualquer intervalo e, onde uma paciente x faz o uso do hormônio progesterona, existe um ponto s posterior, onde essa mesma paciente apresenta birads 3.

As seguintes fórmulas, derivadas das relações que interpretam os predicados temporais na estrutura temporal Ttemp, são válidas na LTI adaptada, A primeira fórmula expressa o fato de que os predicados temporais representam todas as possibilidades de relacionamentos entre intervalos e/ou pontos e, de acordo com as restrições descritas na estrutura temporal.

A segunda fórmula expressa o fato de que existe uma e somente uma relação entre e, ou seja, os predicados temporais não podem ser satisfeitos simultaneamente.

Nesta seção será apresentado o banco de dados temporal sobre o qual os pth's são minerados.

Considere o esquema de banco de dados R = {K,R1,Rn}, onde cada esquema relacional Ri tem aridade ki e tipo (dado,dado,tempo), e K tem aridade m e tipo (dado,dado).

Um conjunto de dados temporais sobre R é um conjunto de relações temporais {k,r1,rn}, onde ri é um conjunto de tuplas (a1,an,) sobre Ri, com I ou N, aj dom (domínio dos dados), e ni + 1 é a aridade de Ri, k é um conjunto de tuplas sobre K.

Uma relação temporal r é fechada se, para toda tupla (a1,ak,) e (a1,ak,) r, tem-se 6=, ou seja, =.

Esto signica que períodos de tempo, com ou sem duração, associados a um mesmo fato são maximais.

Um banco de dados é fechado se suas relações são fechadas.

Nesta dissertação são considerados somente bancos de dados fechados.

Intuitivamente, este pth signica que uma paciente x fumou y cigarros por dia durante o intervalo e e posteriormente, no ponto s, após ter parado de fumar, apresentou Bi-Rads z.

Note que o interesse é em analisar somente o comportamento das pacientes registradas na tabela Paciente.

Por esta razão, K = Paciente(x) é chamado de átomo de referência.

Neste problema de mineração interessa uma classe especíca de pth's, onde o conjunto de átomos temporais T é consistente e completo.

Um conjunto de átomos temporais T é considerado consistente se todas as suas variáveis temporais podem ser instanciadas de modo consistente.

Um conjunto de átomos temporais T é considerado completo se todas as suas variáveis temporais estiverem relacionadas, explicita ou implicitamente, pelos predicados temporais de Ptemp.


Uma instanciação de uma variável temporal intervalar e resp.

Uma variável temporal pontual s é um mapeamento associando um intervalo a e resp.

Um ponto i a s, onde i e j são números naturais mapeados em datas.

Exemplo 31Considere a variável temporal intervalar e e a variável temporal pontual s.

A variável e pode ser mapeada, por exemplo, no intervalo que, de acordo com a linha do tempo, é mapeado nas datas.

A variável s pode ser mapeada, por exemplo, no ponto 5 que é mapeado na data 20/01/2006.

Para esses dois mapeamentos a fórmula before(e,s) é verdadeira, e a fórmula meets(e,s) é falsa, pois e não encontra com s.


Seja T = {A1,An} um conjunto de átomos temporais.

O conjunto T é consistente se existe uma instanciação das variáveis temporais, tal que a fórmula A1 An seja satisfeita, ou seja, para cada átomo Ai(,) T,(,) pertence a interpretação de Ai de acordo com Ttemp.

Considere o conjunto T = {before(e,f),before(f,s),before(s,e)}, e os mapeamentos = e (s) = 07, resultando, de acordo com a linha do tempo.

O conjunto T é inconsistente, pois os dois primeiros átomos implicam que e ocorre antes de s e o terceiro átomo diz que s ocorre antes de e, sendo assim, não existe uma maneira de instanciar as variáveis temporais e,f e s de modo que as três fórmulas temporais sejam simultaneamente verdadeiras.

Entretanto, o conjunto T0 = {before(e,f), before(f,s), before(e,s)}, é consistente, uma vez que nenhum átomo temporal contradiz as informações transmitidas pelos outros.

Seja T um conjunto de átomos temporais.

T é completo se para cada par de variáveis temporais (,) T é possível inferir um relacionamento entre e, ou seja, existe um predicado r Ptemp, tal que, r(,) ou r(,).

Exemplo 316 O conjunto T = {before(e,s),starts(s,g)} é completo porque o relacionamento entre e e g é completamente determinado.

Embora não apareça explicitamente no conjunto a única possibilidade é before(e,g).

Entretanto, o conjunto T = {before(e,s), during(s,g)} não é completo porque o relacionamento entre e e g não é deterministicamente implicado pelos dois relacionamentos before(e,s) e during(s,g), podendo ser before(e,g), meets(e,g), overlaps(e,g), starts(e,g) e during(e,g).

A razão pela qual o conjunto de átomos temporais T deve ser completo e consistente é que nessas condições as variáveis temporais de um pth podem ser ordenadas de modo natural.

O motivo da ordenação das variáveis temporais de um conjunto de átomos temporais T cará claro na proposição 313.

Para que esta ordenação seja possível, primeiramente é necessário generalizar o domínio dos dados temporais.

Como mostrado anteriormente, o domínio I é considerado para as variáveis temporais intervalares e o domínio N é considerado para as variáveis temporais pontuais.

É importante relembrar que um número natural n pode ser visto como um intervalo.

Sendo assim, considere um novo conjunto I = I N constituído por intervalos, com i j, ou seja, constituído por intervalos não nulos (i < j) e por intervalos nulos (i = j) considerados pontos.

Ordem total sobre os intervalos.

Seja dois intervalos pertencentes a I.

É dito que se e somente se uma das seguintes condições forem satisfeitas, É evidente que se e b = d, então a c.

Com isso é possível provar através da reexividade, anti-simetria e transitividade, que é uma ordem total sobre I.

Reexividade, A relação é vericada desde que a condiçãoseja vericada.

Assim, a propriedade da reexividade é garantida.

Anti-simetria, Considerando as relações.

Então, b d e d b.

Logo, b = d.

Partindo da condição, conclui-se que a > c e c > a.

Logo, a = c.

Assim, a condição é vericada e conclui-se.

Portanto, a propriedade da anti-simetria é garantida.

Transitividade, Considerando as relações.

Assim, b d f.

Então b f.

Se b < f, tem-se que.

Se b = f, então b = d = f.

Partindo do fato de que e b = d, conclui-se que a c.

De maneira similar pode-se provar que c e.

Assim, a e.

Desde que b = f e a e, conclui-se que.

Considere dois intervalos.

Se b > d, então.

Se b = d e a < c, então.

Com isso, através das três propriedades anteriores, foi provado que a relação de ordem é total.

Para qualquer o fato que.

Com a denição de ordem total sobre os intervalos bem clara, é possível estabelecer um ordenamento único das variáveis temporais que aparecem em um conjunto de átomos temporais T completo e consistente.

Proposição 311 Seja T = {A1,Ak} um conjunto completo e consistente de átomos temporais e e 0 dois mapeamentos das variáveis temporais de T, tal que cada fórmula Ai de T seja simultaneamente verdadeira, ou seja, (Ttemp,) |= T e (Ttemp,0) |= T.

Seja também e duas variáveis temporais que ocorrem em T.

Assim, Prova, Pelo fato de T ser completo e consistente, é possível armar sem perda de generalidade que para qualquer par de variáveis (,) T existe um predicado temporal r, tal que (Ttemp,) |= r(,) e (Ttemp,0) |= r(,).

Assim, se e somente se r(,) for before(,) ou meets(,) ou overlaps(,) ou starts(,) ou during(,) ou finishes(,) ou =t.

Como (Ttemp,0) |= r(,), então, para todo mapeamento 0 considerado, 0 0.

Proposição 31(Ordenamento único das variáveis temporais).

Seja um conjunto T = {A1,Ak} completo e consistente.

Como por denição não existe repetição entre as variáveis temporais do conjunto T, ou seja, T, 6=, existe um ordenamento <T, onde <T é um novo símbolo que representa um ordenamento sobre as variáveis temporais de T.

Para generalizar essa idéia, considere o conjunto {1,2,n} das variáveis temporais de T.

Assim, existe um ordenamento único 1 <T <T <T n, que satisfaz a fórmula, Proof.

Pelo fato de T = {A1,Ak} ser completo e consistente e de não ocorrer repetições entre entre suas variáveis temporais, existe um mapeamento, tal que (Ttemp,) |= {A1 Ak} e (Ttemp,) |= 6=, para cada, aparecendo em T.

Considerando um conjunto de intervalos { | aparece em T }, é possível ordená-los como<< < (n).

Com isso, é possível ordenar as variáveis temporais como 1 <T <T <T n.

Considerando 0 outro mapeamento, tal que (Ttemp,0) |= (A1 Ak) e (Ttemp,0) |= 6=, concluimos a partir da proprosição 311 que 0(1) < 0 < < 0(n).

Assim, a fórmula anterior é satisfeita por T.

Exemplo 317 Seja o conjunto de átomos temporais T = {before(e,s),starts(s,g)} completo, consistente e sem repetição.

A ordem sobre o conjunto das variáveis temporais {e,s,g} é e <T s <T g.

De fato, se para qualquer mapeamento das variáveis temporais que ocorrem em T, =, tal que os predicados de T sejam simultaneamente verdadeiros, então < (s) < (g).

Proposição 31(Ordenamento único dos átomos de dados).

Seja um pth P = (K,E,T) com T consistente e completo, e o ordenamento único das variáveis temporais de T, denido acima.

Nestas condições é possível ordenar os átomos de dados de P de um modo único.

Proof.

Por denição, cada variável temporal T é associada a um único átomo de dados p(a1,ak,) E.

Assim, é possível ordenar os átomos de E de acordo com a ordem das variáveis temporais de T.

Exemplo 318 Seja P = (K,E,T) um pth, onde, T = {before(e,s), starts(s,g)} é um conjunto completo e consistente de átomos temporais.

A ordem sobre o conjunto das variáveis temporais {e,s,g} é e <T s <T g, como mostrado no exemplo anterior.

Como cada variável temporal é associada a um único átomo de dados, pode-se considerar E = {p1(a1,ak,e),p2(a1,ak,s),p3(a1,ak,g)}.

Portanto, o ordenamento dos átomos de E segue o ordenamento das variáveis temporais de T.

Todo este trabalho de ordenamento das variáveis temporais e, conseqüentemente dos átomos de dados de um pth foi realizado com o objetivo de simplicar sua interpretação, uma vez que um pth possui uma complexa estrutura dividida em três partes, K, E e T, como apresentado na denição 312.

Portanto, deste ponto em diante sempre que um pth P = (K, E, T) for apresentado, o conjunto E pode ser considerado uma seqüência de átomos p1 <T <T pn, ordenados de acordo com a ordem das variáveis temporais de T.

Assim, E é denotado por < p1,pn >.

Isto permite obter padrões mais específicos a partir de padrões mais gerais acrescentando novos átomos de dados no m da seqüência de E, como será mostrado na seção 43do capítulo 4.

Nesta seção será denido o conceito de suporte de um pth P sobre um banco de dados temporal BD.

Além de denir o suporte de um pth, será introduzida também a idéia de pth freqüente.

Suporte de um pth.

Seja BD um banco de dados temporal sobre o esquema R = {K,R1,Rn}, e P = (K(x1,xm), {E1,Es}, {T1,Tl}) um pth.

O suporte de P com respeito ao banco de dados BD denotado por supP/B, é a porcentagem de tuplas em BD que satisfazem P.

SupP/B é denido por, onde, QP é uma consulta relacional (fórmula da LTI associada a P) 1 ny1 yk (E1 EEsT1 TTl), onde, 1 n são variáveis temporais que aparecem em T e y1 yk são variáveis de dados que aparecem em E e não aparecem no átomo de referência K(x1,xm).

A expressão u |= QP signica que u satisfaz a consulta relacional QP quando executada sobre BD.

Um pth P é freqüente com respeito a BD se dado um limiar mínimo de suporte 0 1, supP/B.

Considerando o banco de dados BD apresentado e o pth P = (Paciente(x), {Hormonio(x,y,e),Birads(x,3,s)},{before(e,s)}).

A consulta relacional QP pode ser especicada também no formalismo da álgebra relacional pela expressão NomePac(Paciente / Hormonio / Birads).

A resposta de QP é {Maria,Paul}.

Pois Priscila fez uso do hormônio progesterona e não apresentou nenhuma categoria de Bi-Rads, Carla apresentou Bi-Rads categoria durante, não depois, de ter usado o hormônio noretisterona e Cintia não fez uso de hormônio e não apresentou Bi-rads algum, por isso, não são respostas de QP.

Assim, o suporte do pth P é = 04%.

Se = 02%, então, P é um pth freqüente em BD.

A tarefa de mineração considerada básica para o problema de mineração proposto nesta dissertação será apresentada logo abaixo.

Na seção 4será apresentada a tarefa de mineração principal, incluindo restrições de expressões regulares.

Dado, Um banco de dados temporal BD e um limiar mínimo de suporte.

Encontrar, Todos os pth freqüentes com relação a BD e.

Neste capítulo o problema de mineração de padrões temporais híbridos foi amplamente detalhado.

Inicialmente foi denida a Lógica Temporal de Intervalos de Allen e as adaptações realizadas para ela servir de formalismo para especicar o novo padrão temporal.

A LTI adaptada considera casos onde o tempo é representado em termos de pontos e intervalos, uma vez que a LTI original considera somente tempo intervalar.

Posteriormente foi denido o banco de dados temporal onde os pth's podem ser minerados e em seguida o padrão temporal híbrido.

Um extenso trabalho foi realizado sobre o conjunto de átomos temporais com o objetivo de simplicar a representação e, conseqüentemente, o entendimento dos pth's.

Para isso, foram desenvolvidas técnicas para visualizá-lo como uma seqüência de átomos de dados, permitindo também que ele seja especializado inserindo um novo átomo de dados no m da seqüência.

Após a apresentação formal do pth foram definidos os conceitos de suporte e pth freqüente sobre bancos de dados temporais.

Finalmente, o capítulo foi encerrado com a apresentação da tarefa básica deste problema de mineração.

Neste capítulo serão apresentadas as restrições que foram introduzidas no processo de mineração com o objetivo de otimizar a busca por novos pth's.

A primeira restrição é especicada por expressões regulares similares às utilizadas nos algoritmos da família SPIRIT.

Esse tipo de restrição reduz o espaço de busca dos pth's e permite que o usuário controle do processo de mineração.

Além das restrições de expressões regulares serão apresentadas também restrições especicadas por operadores de especialização.

Esses operadores possuem propriedades especiais para controlar a geração de novos pth's, garantindo a eficiência e ecácia do método.

Os sistemas convencionais de mineração permitem ao usuário apenas denir o suporte mínimo como mecanismo de restringir os padrões a serem minerados.

Com isso, ele é sobrecarregado com uma enorme quantidade de padrões que não o interessam.

Os algoritmos da família SPIRIT, além do suporte mínimo, permitem o uso de expressões regulares como uma ferramenta para incorporar o foco do usuário ao processo de mineração, promovendo assim a redução do espaço de busca dos padrões.

Nesta dissertação são denidas expressões regulares sobre um conjunto de modos chamado alfabeto, e todo pth gerado deve satisfazer uma determinada expressão regular.

Portanto, a expressão regular considerada tem a função de restringir o formato dos pth's.

É importante salientar que os algoritmos da família SPIRIT e SPIRIT-Log mineram padrões seqüenciais.

Portanto, as restrições de expressões regulares são denidas considerando o tempo como pontual.

Neste trabalho está sendo proposto um método de utilizar tais restrições de expressões regulares na mineração de padrões temporais híbridos, onde o tempo é pontual e/ou intervalar.

Um modo sobre um esquema R é uma expressão da forma p(u1,un,#), onde p é um predicado pertencente a R com aridade n + 1, ui Var ou ui é um símbolo $, e # é um novo símbolo.

Um modo caracteriza e identica os atributos das relações de R e serve de certa forma como um molde para a construção de um átomo.

Um átomo A é de acordo com um modo p(u1,un, #) (A foi gerado a partir de p(u1,un, #)) se A = p(x1,xn,) e para cada i = 1,n, temos, Exemplo 411 Considere o esquema R = {Paciente(NomePa, Birads(NomePac, Categoria,Tpt), Fumo(NomePac,Qtde,Tit), Hormonio(NomePac,NomeHorm,Tit)}, onde PacienteNomePa é uma tabela de referência e portanto, NomePac é um atributo de referência.

Assim, um possível alfabeto de modos sobre este esquema poderia ser {Paciente(x), Birads(x, $, #), Fumo(x, $, #), Hormonio(x, $, #)}.

Note que a variá vel x é uma variável de referência, portanto, estes modos informam que o primeiro atributo de cada tabela é de referência e os valores armazenados nestas colunas pertencem a um mesmo domínio, neste caso, nome de pacientes.

Considere agora os átomos Hormonio(x,progesterona,e) e Hormonio(y,progesterona,e).

O primeiro é de acordo com o modo Hormonio(x, $, #).

Em contrapartida, o segundo não é de acordo com o modo, pois, como x é uma variável no modo, ela deve ser mantida no átomo.

Um alfabeto de modos sobre R é denotado pelo símbolo.

São consideradas linguagens especicadas por expressões regulares sobre o alfabeto com o objetivo de reduzir o tamanho do espaço de busca dos pth's.

Relembrando, uma linguagem sobre um alfabeto é um conjunto de símbolos ou strings sobre.

Uma expressão regular R sobre um alfabeto de modos = {p1(u1,un, #),p2(u1,un, #),pk(u1,un, #)} pode ter a forma p1(u1,un, #)* p2(u1,un, #), que neste caso especica uma linguagem, onde, * signica que o predicado p1 pode não ocorrer ou ocorrer uma ou mais vezes, e obrigatoriamente deve terminar com o predicado p2.

Exemplo 41Considere o alfabeto de modos = {Hormonio(x,$,#),Fumo(x,$,#), Birads(x,$,#)}, e a expressão regular R = Hormonio(x,$,#)Fumo(x,$,#)Birads(x, $,#) sobre.

Uma linguagem especicada pela restrição R pode ser Hormonio(x,$,#) Hormonio(x,$,#)Fumo(x,$,#)Birads(x,$,#).

Para facilitar a representação de uma expressão regular cada modo é rotulado com uma letra, por exemplo, wi = pi(u1,un, #), signica que wi representa pi.

Por motivos de simplicação, a mesma notação R é considerada para denotar a expressão regular e a linguagem associada a ela.

Assim, dada uma expressão regular R sobre um alfabeto, um pth (K, E, T) satisfaz R se, E é uma seqüência de átomos de dados < p1,pn > e existe uma string w1,wn R, onde pi é de acordo com wi para cada i = 1,n.

O conjunto de strings que vericam a expressão regular R e denotado por W(R) e o conjunto de prexos de strings em W(R) é denotado por Pref(R), ou seja, Pref(R) = {w | ww0 R para algum w0}.

Essas notações serão importantes a seguir.

espaço de busca. Seja um esquema de banco de dados R = {K,R1,Rn}, um alfabeto de modos sobre R e uma expressão regular R sobre.

O espaço de busca denido por R é um conjunto de pth's (K,E,T), tal que, E = < p1(t1,t1,1),pn(tn,tn,n) > satisfaz as seguintes propriedades, É denotado por W(R) o espaço de busca dos pth's especicado por R, e por Pref(R), o conjunto de pth's definidos de modo similar a W(R), por considerar strings w1 wn P(R) ao invés de W(R) na condição (1).

Os pth's pertencentes a W(R) são chamados de válidos, e os pth's pertencentes a Pref(R) de prexos-válidos ou simplesmente p-válidos.

Como será visto no próximo capítulo, na fase da geração do algoritmo MILPRIT* somente pth's pertencentes a Pref(R) são gerados.

A razão pela qual são gerados pth's p-válidos ao invés de válidos cará clara na seção 51.

Proposição 411 Seja W(R) e Pref(R) dois espaços de busca, onde R é uma expressão regular sobre.

Então W(R) Pref(R).

A prova desta proposição foi dada na denição anterior, ou seja, para computar os pth's que pertencem a W(R) é suciente computar os que pertencem a Pref(R).

Exemplo 41Considere a expressão regular R = Hormonio(x,$,#) Fumo(x,$,#) Birads(x,$,#) e os pth's P1, Pe Pdefinidos por, A principal tarefa de mineração desta dissertação inclui restrições de expressões regulares estipuladas pelo usuário além de um suporte mínimo também estipulado pelo usuário.

Dado, Um banco de dados BD, um suporte mínimo, e uma restrição R.

Encontrar, Todos os pth's freqüentes com relação a BD, e que satisfazem R.

A maioria dos algoritmos de mineração de dados tipicamente computa todas as soluções através do uso de um algoritmo de busca completo.

Quando uma busca completa é executada, o resultado nal pode conter padrões duplicados.

Com isso, um tempo precioso é desperdiçado simplesmente computando algo desnecessário.

No protótipo MILPRIT, a especialização dos padrões é realizada por operadores de especialização (instanciação e extensão) com as mesmas características (completos e optimais) dos operadores de renamento utilizados por Lee e Raedt no SeqLog para controlar a busca por padrões.

Nesta dissertação os formalismos teóricos definidos no MILPRIT para a geração de novos padrões foram estendidos para o problema proposto.

Essa extensão foi realizada com o objetivo de garantir a eficiência e ecácia do método, assim, durante o processo de mineração são gerados todos o padrões possíveis a partir de um dado padrão e nunca são gerados padrões duplicados.

A relação de especialização entre dois padrões é dada por, denição 431 (Relação de especialização) Seja Q um conjunto de pth's e P1 = (K,E1,T1) e P= (K,E2,T2) dois pth's pertencentes a Q.

P1 é mais específico que Pou Pé mais geral que P1, denotado por P1 ¹ P2, se existe uma substituição das variáveis de Pnos termos de P1, tal que, denição 43(Pth's equivalentes) Seja Q um conjunto de pth's e P1 e Pdois pth's pertencentes a Q.

P1 é equivalente a Pdenotado por P1 P2, se P1 é mais específico que P(P1 ¹ P2) e Pé mais específico que P1 (P¹ P1).

Exemplo 43Seja dois pth's, denição 436 (Vetor de renamento) Seja Q um conjunto de pth's e P = (K,E,T) um pth pertencente a Q.

O vetor de renamento associado a P é denido por v(P) = n, onde, n é a cardinalidade do conjunto E e c é o número de constantes em E.

Além disso, o nível de renamento de P é denotado por l(P) = n + c.

Múltiplas ocorrências de uma constante são contadas múltiplas vezes.

Exemplo 43Seja três pth's, Prova, Todo operador de instanciação aplicado sobre um pth P substitui uma única variável de P resultando em um pth P0 imediatamente mais específico que P, ou resulta no próprio P, portanto, (P) ¹ P é não existe nenhum pth P0, tal que, (P) ¹ P0 ¹ P.

Assim, as duas condições da denição 43são satisfeitas, portanto, todo operador de instanciação é um operador de especialização.

Todo operador de extensão aplicado sobre um pth P insere um único átomo em P resultando em um pth P0 imediatamente mais específico que P, ou resulta no próprio P, portanto, (P) ¹ P é não existe nenhum pth P0, tal que, (P) ¹ P0 ¹ P.

Assim, as duas condições da denição 43são satisfeitas, portanto, todo operador de extensão é um operador de especialização.

Para garantir a eficiência e ecácia do método, a classe de todos os operadores de especialização deve ser completa e optimal.

Classe de operadores de especialização completa. Uma classe C de operadores de especialização é completa para um conjunto de pth's Q se P Q existe P0 L0, onde, L0 é o conjunto dos pth's mais gerais de Q, tal que, P é obtido aplicando-se sucessivamente os operadores de C sobre P0.

De acordo com a denição anterior, uma classe de operadores de especialização completa percorre todo o espaço de busca dos pth's e gera todos os pth's possíveis a partir dos pth's mais gerais.

Para evitar que um mesmo pth's seja obtido várias vezes, uma classe de operadores de especialização deve ser optimal.

Classe de operadores de especialização optimal. Uma classe C de operadores de especialização é optimal para um conjunto de pth's Q se P,P1,P Q, em que P pode ser obtido aplicando sucessivamente os operadores de C sobre P1 e P2, tem-se que P1 P2.

Considere o espaço de busca Pref(R).

Para garantir uma especialização eficiente e ecaz para Pref(R), neste trabalho foram consideradas duas classes de operadores de especialização que especializam os pth's pertencentes a Pref(R) nível por nível, ou seja, a cada iteração os operadores de especialização são aplicados sobre os pth's pertencentes a Pref(R) aumentando em um seu nível de renamento.

Classe CE de operadores de extensão. Seja R uma expressão regular, Pref(R) o espaço de busca dos pth's denido por R e um pth P = (K, E, T) Pref(R) com E = {p1,pn}.


A denição anterior diz que os operadores de instanciação só podem ser aplicados a pth's se o modo que gerou o átomo que contém a variável que vai ser instanciada possui o símbolo $ na mesma posição da variável (item 1 da denição).

E não pode existir nenhuma constante a direita da variável que vai ser instanciada no mesmo átomo (item da denição) ou nos próximos átomos (item da denição).

Observe que, se os operadores da classe de operadores de extensão pudessem ser aplicados sobre pth's com constantes, violando o item 1 da denição 439, e se os operadores da classe de operadores de instanciação pudessem instanciar variáveis a esquerda de uma variável que já foi instanciada nos pth's, violando o item ou da denição 4310, poderiam ser gerados pth's a partir de pth's não equivalentes, ou seja, por caminhos diferentes.

A extensão através da seta pontilhada não é permitida, pois viola a optimalidade do método.

Exemplo de dois pth's Pe P6 obtidos a partir de pth's não equivalentes Teorema 431 Seja R uma expressão regular, Pref(R) o espaço de busca dos pth's denido por R, a classe de operadores de extensão CE e a classe de operadores de instanciação CI.

Se existe uma classe C de operadores de especialização definidos por, tal que, C = CE CI, então C é completa e optimal para Pref(R).

Prova, Para provar que C é completa para Pref(R) é necessário mostrar que para todo pth P Pref(R), onde, P = (K, E, T) com E = {p1(y1,yl,1), pi(y1,yj,yi,i),pn(y1,yl,n)}, existe um P0 Pref(R), tal que P é obtido aplicando os operadores de C sobre P0, ou seja, (P0) = P.

Para isso, dois casos devem ser tratados, Neste capítulo foram denidas expressões regulares que são restrições introduzidas no processo de mineração com o objetivo de reduzir o espaço de busca dos padrões.

Além de reduzir o espaço de busca dos padrões este tipo de restrição permite que o usuário dena o tipo dos pth's que deseja minerar, assim, ele não é sobrecarregado com pth's que não o interessam.

Foram definidos também operadores de especialização que quando são aplicados sobre os pth's durante o processo de mineração geram um conjunto de pth's mais específicos a cada nível.

Estes operadores satisfazem algumas propriedades especiais que garantem completude e optimilidade ao método, ou seja, garantem que sejam gerados todos os pth's possíveis a partir de um determinado pth, e que não sejam gerados pth's duplicados.

Neste capítulo será apresentado o algoritmo MILPRIT* (Mining Interval Logic Patterns with Regular expressIons consTraints) desenvolvido para realizar a mineração de padrões temporais híbridos.

O MILPRIT* encontra todos os pth's freqüentes em um banco de dados temporal BD com relação a um suporte mínimo e a uma expressão regular R especicada pelo usuário.

Este algoritmo foi implementado na linguagem C++ sobre o sistema operacional Linux.

É importante ressaltar que o algoritmo MILPRIT* foi desenvolvido a partir do protótipo MILPRIT, que realiza mineração de padrões temporais intervalares, como descrito na seção 244.

O protótipo MILPRIT foi implementado com as idéias básicas da mineração de padrões temporais intervalares e possui alguns problemas.

O primeiro deles é o fato de não realizar gerenciamento de memória, o que limita sua utilização, uma vez que a cada iteração o número de padrões gerados aumenta consideravelmente, ocupando toda a memória principal disponível.

Outro problema do protótipo MILPRIT está na fase de geração dos padrões, onde determinados padrões não são gerados ou são gerados padrões que não são interessantes para o usuário.

Para solucionar os problemas apresentados no parágrafo anterior foi desenvolvido um novo algoritmo, chamado MILPRIT*, que utiliza algumas técnicas para otimizar a ocupação da memória principal e a etapa de geração.

O algoritmo MILPRIT* também estende a técnica de mineração de padrões temporais intervalares visando realizar a mineração de padrões temporais híbridos.

As técnicas utilizadas para otimizar a ocupação da memória e a fase de geração serão apresentadas na seção 514.

A partir deste ponto serão utilizadas as notações Ck e Fk para denotar o conjunto de pth's candidatos e freqüentes, respectivamente.

O MILPRIT* é um algoritmo de mineração de pth's baseado na técnica Apriori, ou seja, a cada iteração k executa as etapas de geração dos candidatos, poda dos candidatos e avaliação, produzindo um conjunto Fk constituído de pth's freqüentes imediatamente mais específicos que os pth's contidos em um conjunto Fk, obtido na iteração anterior.

O MILPRIT* utiliza além da restrição baseada no suporte, restrições especicadas através de expressões regulares R.

Seguindo a idéia introduzida primeiramente nos algoritmos da família SPIRIT e posteriormente nos algoritmos da família SPIRIT-Log, o MILPRIT* incorpora uma restrição R0, que é um relaxamento de R, ou seja, R0 é uma restrição mais fraca que R.

O motivo do uso de R0 ao invés de R será explicado nos próximos parágrafos.

Considere momentaneamente que a restrição original R seja incorporada pelo algoritmo MILPRIT Em uma iteração k, na fase de geração é gerado um conjunto Ck contendo somente pth's candidatos que satisfazem R.

Posteriormente, na fase de poda, de acordo com a propriedade antimonotonica, são podados de Ck todos os pth's que possuem pelo menos um sub-padrão (um pth mais geral) não freqüente.

Entretando, pelo fato da expressão regular R não ser antimonotônica, não podem ser podados pth's que possuem pelo menos um sub-padrão que não satisfaz R, pois fazendo isso, poderiam ser podados pth's interessantes.

Para que um pth P Ck seja podado, deve existir algum pth P0 Â P (P0 mais geral que P) que não seja freqüente.

Sabe-se que um pth P0 6 F = F1 Fk 1 se e somente se,P0 não é freqüente ouP0 não satisfaz a restrição R.

Assim, para ter certeza que P não é freqüente (pode ser podado), basta P0 satisfazer R e P0 6 F.

Com isso, quanto maior for a seletividade de R menor será o número de padrões gerados e menor será o número de padrões podados.

A diminuição do número de padrões podados não é interessante, pois um dos principais objetivos desse tipo de restrição é diminuir o número de pth's que serão levados para a etapa de avaliação.

A relação entre a seletividade de R e a quantidade de pth's gerados e podados é mostrada.

Seletividade de R PTH's Gerados PTH's Gerados Relação entre a restrição R e as etapas de geração e poda Visando um equilíbrio entre a quantidade de pth's gerados e a quantidade de pth's podados, ou seja, visando diminuir a quantidade de pth's gerados e aumentar a quantidade de pth's podados, o MILPRIT* considera uma restrição R0, que é um relaxamento da restrição R.

Desta forma são gerados somente pth's que satisfazem R0, e portanto, é considerado o prexo associado a restrição R.

Assim, somente pth's prexos válidos ou simplesmente p-válidos são gerados.

Seja AR um autômato associado a uma expressão regular R e P = {K,E,T } um pth.

P é p-válido com relação AR se existe um caminho em AR que começa no estado inicial e produz a seqüência de átomos de dados E, não terminando necessariamente em um estado nal de AR.

Resumidamente, o algoritmo MILPRIT* pode ser descrito como segue.

Para cada iteração k, o conjunto Ck de pth's p-válidos é obtido pela especialização dos pth's p-válidos e freqüentes de Fk 1 obtido na iteração anterior.

Após a etapa de geração, é executada a etapa de poda, onde são podados de Ck todos os pth's P que possuem pelo menos um pth P0 Â P, tal que P0 é p-válido (P0 satisfaz R0) e P0 6 F = F1 Fk 1 (P0 não é freqüente).

Na etapa de avaliação, o banco de dados é percorrido para calcular o suporte de todos os pth's que restaram em Ck após a poda.

Enm são inseridos em Fk todos os pth's com suporte maior ou igual a um suporte mínimo estipulado pelo usuário.

Uma visão geral da estrutura do algoritmo MILPRIT* é dada.

O símbolo 1 representa um conjunto de átomos de dados {p1(y1,yl,1),pn(y1,yl,n)} obtido a partir do alfabeto de modos = {p1(u1,u1, #),pn(un,un, #)}.

O parâmetro de entrada representado pelo símbolo é a granularidade escolhida pelo usuário para ser considerada durante o processo de mineração.

Detalhes sobre a granularidade serão apresentados na fase de avaliação na seção 513.

Algoritmo MILPRIT*(BD-banco de dados, suporte mínimo, R-expressão regular, granularidade) Nas próximas seções serão detalhadas as etapas de geração dos candidatos, poda dos candidatos e avaliação do algoritmo MILPRIT A função Gen(Fk,R) gera pth's com nível de renamento k, especializando cada pth i de Fk, cujo nível de renamento é k 1, de tal modo que os pth's gerados sejam p-válidos.

A especialização de um pth é realizada a cada iteração por funções que aplicam os operadores de especialização definidos no capítulo anterior.

Cada pth P de Fk 1 é especializado primeiramente pela função Instantiation(P, R) que aplica o operador de instanciação sobre P gerando um conjunto PI de pth's instanciados.

Posteriormente, se v(P) = (n, 0), ou seja, se P não contêm constantes, então a função Extension(P, R) aplica o operador de extensão sobre P gerando um conjunto PE de pth's estendidos.

Portanto, a especialização de cada pth P de Fk 1 resulta em dois conjuntos, PI e PE, de pth's especializados que são inseridos em um conjunto Ck de pth's candidatos.

No m da etapa de geração, o conjunto Ck é formado por todos os pth's obtidos pela especialização de todos pth's de Fk.

Uma importante função exigida tanto pela função Instantiation quanto pela função Extension é a função Match, que encontra a palavra associada a um determinado pth.

Os passos realizados pela função Match(P, R) para a construção de uma palavra W associada a um pth P são dados por, Insere o modo w no m de W, ou seja, W = W + w (linha 10).

Retorna A palavra W associada ao padrão P linha 1.

A propriedade antimonotônica é empregada na etapa de poda para eliminar os pth's que não são potencialmente freqüentes.

Relembrando, pela propriedade antimonotônica, um padrão freqüente não pode ser mais específico que um padrão não freqüente.

Portanto, em um nível k, são podados de Ck todos os pth's P que possuem pelo menos um P0 Â P que satisfaz R (p-válido) e que não pertence a F = F1 Fk 1 (não freqüente).

Exemplo 516 Considere a expressão regular R = Hormonio(x,$,#) Fumo(x,$,#) Birads(x,$,#), o conjunto Cobtido anteriormente na etapa de geração e o seguinte conjunto F = F1 F F3.

Observe que o pth P que resultou nos pth's de Ctambém faz parte de F.

Hormonio(x,y1,e1), Hormonio(x,y2,e2), Fumo(x,z,f),before(e1,e2), meets(e1,f, during(e2,f)) e (Paciente(x)), {Hormonio(x,estradiol,e1), Hormonio(x,y2,e2)}, {before(e1,e2)}).

Embora o primeiro pth seja freqüente, o segundo não é.

Assim, de acordo com a propriedade antimonotônica, P1 não é potencialmente freqüente e pode ser eliminado.

O pth Ptambém possui dois sub-padrões, (Paciente(x), {Hormonio(x,y1,e1), Hormonio(x,y2,e2), Fumo(x,z,f}, {before(e1,e2), meets(e1,f, during(e2,f}) e (Paciente(x), {Hormonio(x,y,e1), Hormonio(x,estradiol,e2)}, {before(e1,e2)}).

Embora o primeiro pth seja freqüente, o segundo não é.

Assim, de acordo com a propriedade antimonotônica, Pnão é potencialmente freqüente e também pode ser eliminado.

Após a poda o conjunto Cé o seguinte, Na etapa de avaliação de um nível k é calculado o suporte de todos os pth's que restaram em Ck após a poda.

Para isso, o banco de dados é percorrido e cada pth tem um contador incrementado em um cada vez que uma tupla do banco de dados o suportar.

Ao terminar de percorrer o banco de dados, o valor do contador de cada pth será a quantidade de tuplas que o suportou.

Finalmente, este valor é dividido pela quantidade de tuplas da tabela de referência do banco de dados resultando no suporte do pth, como denido na seção 31do capítulo 3.

São considerados freqüentes, e portanto são inseridos em Fk, todos os pth's que possuem suporte superior a um suporte mínimo denido pelo usuário.

Quando uma tupla suporta um pth.

Antes de mais nada, para vericar se uma determinada tupla de um banco de dados temporal suporta um determinado pth, é necessário que as seguintes denições estejam bem claras.

Seqüência do pth. Seja P = (K, E, T) um pth, com E = {p1,pn}.

A seqüência de P denida por SP(P), é uma estrutura da forma < L1,Ln >, onde, n é o número de átomos de dados de P e Li é uma lista de variáveis diferentes das variáveis de referênci ou constantes que aparecem no átomo de dados i.

Exemplo 517 Seja um pth P = (Paciente(x), {Hormonio(x,estradiol,e1), Fumo(x, z,f2), Birads(x,h,s}, {during(e1,f2), before(e1,s, before(f2,s}).

A seqüência de P é SP(P) = < >.

Seqüências da tupla. Seja BD um banco de dados temporal sobre o esquema R = {K,R1,Rk} e U = ((w1,wm), (y1,yl,1)1, (y1,yl,n)n) uma tupla de BD, onde wi é um atributo de referência, yi é um atributo de dado e i é um atributo temporal.

A seqüência de dados de U, denida por ST(U), é uma estrutura da forma < T1,Tn >, onde n é o número de relações que não são de referência e Ti é uma lista de constantes não temporais.

A seqüência temporal de U, denida por St(U), é uma estrutura da forma < t1,tn >, onde tj = j, e j é mapeado em um intervalo, e onde a e b são inteiros mapeados em datas.

Se j representa um intervalo não nulo, então a < b, se j representa um intervalo nulo (ponto), então a = b.

Exemplo 518 Seja um banco de dados temporal BD sobre o esquema R = {Paciente(NomePa, Hormonio(NomePac,NomeHorm,Tit), Fumo(NomePac,Qtde, Tit),Birads(NomePac,Categoria,Tpt)} e a tupla U que é o resultado da junção das tabelas Hormonio, Fumo e Birads.

Tupla do banco de dados BD A seqüência de dados de U é ST(U) = < > e a seqüência temporal de U é St(U) = < >.

Seqüências compatíveis. Seja a seqüência de dados ST(U) = < T1,Tn > de uma tupla U, onde, Ti = e Yj é uma constante.

Seja também a seqüência SP(P) = < L1, Ln > de um pth P, onde Li = e sj é uma variável ou uma constante.

ST(U) é compatível com SP(P) se todos os elementos de ST(U) forem compatíveis com todos os elementos de SP(P) da seguinte forma, Se sj {j = 1,l} é uma variável, então qualquer valor de Yj é compatível com sj.

Se sj {j = 1,l} é uma constante, então Yj é compatível com sj se e somente se sj = Yj.

Exemplo 519 Considere a tupla U com ST(U) = < > do exemplo anterior e o pth P com SP(P) = < > do exemplo 517.

ST(U) é compatível com SP(P).

Entretanto, ST(U) não é compatível com a seqüência SP(P0) = < > de um outro pth P0, porque a condição não é vericada.

Se for vericada compatibilidade entre a seqüência de dados de uma tupla e a seqüência de um pth, o próximo passo para vericar se esta tupla suporta o pth é analisar se a seqüência temporal da tupla satisfaz os átomos temporais do pth.

A seqüência temporal St(U) =< t1,t2,t> de uma tupla U satisfaz os átomos temporais de um pth P = (K, E, T), com, E = {p1(x1,xn,1),p2(x1, xn,2),p3(x1,xn,} e T = {r1(1,2),r2(1,r3(2,} se os valores da seqüência temporal da tupla não contradizem os átomos temporais do pth, ou seja, se para cada ri(j,k) T, existe j = tj e k = tk, tal que, ri é satisfeito.

Exemplo 5110 Considere a tupla U do exemplo 518, cuja seqüência temporal é St(U) = < > e o pth P = (Paciente(x), {Hormonio(x,estradiol,e1), Fumo(x,z,f2), Birads(x,h,s}, {during(e1,f2),before(e1,s,before(f2,s}).

O átomo during(e1,f2) é satisfeito, pois e1 =.

Portanto, e1 ocorre durante f2.

O átomo beforee1,s é satisfeito, pois e1 =, e portanto e1 ocorre antes de s3.

O átomo beforef2,s é satisfeito, pois f=, e portanto focorre antes de s3.

Com isso, St(U) satisfaz P no que diz respeito aos átomos temporais.

Se pelo menos um átomo temporal de P não for satisfeito por St(U), então St(U) não satisfaz os átomos temporais de P.

Como mostrado no exemplo 519, a seqüência de dados ST(U) da tupla U é compatível com a seqüência do pth P, e como mostrado no exemplo anterior, a seqüência temporal St(U) da tupla U satisfaz os átomos temporais de P.

Portanto, a tupla U suporta o pth P.

É importante chamar a atenção para a segunda condição necessária para que uma tupla suporte um pth.

Como foi mostrado no exemplo anterior, esta condição trata dos relacionamentos temporais existentes entre os eventos de um pth e para sua vericação são considerados exatamente o início e o m de cada intervalo.

Por exemplo, o átomo temporal before(e1,e2) é satifeito se existir uma instanciação e1 =, portanto, se a instanciação for e1 = o átomo temporal before(e1,e2) não é mais satisfeito.

Considerando agora átomo temporal meets(e1,e2), ele é satifeito se existir uma instanciação e1 =, portanto, se a instanciação for e1 = o átomo temporal meets(e1,e2) não é mais satisfeito.

Cada predicado temporal interpreta os relacionamentos entre o início e o m dos intervalos de maneira diferente como mostrado na adaptação da estrutura temporal da LTI.

Em muitas aplicações, como por exemplo na medicina, agronomía, agropecuária, etc, se forem considerados exatamente os limites (início e m) dos intervalos para vericar se os átomos temporais de um pth são satisfeitos pela seqüência temporal de uma tupla, padrões bastante expressivos e conclusivos podem não ser minerados pelo simples fato dos eventos terem ocorrido em períodos diferentes, embora um especialista possa considerar esta diferença desprezível.

Por exemplo, considere o pth P = (Paciente(x), {Menopausa(x,sim,s1), Antidepressivo(x,y,e2)}, {before(s1,e2)}) e a tupla U, com St(U) = < >, onde, é mapeado na data 15/10/2005, é mapeado na data 15/11/2005 e 5 é mapeado na data 20/01/2006.

Se forem considerados exatamente os limites dos intervalos, o átomo temporal before(s1,e2) é satisfeito, embora, neste caso um especialista possa considerar os dias irrelevantes, pois, a paciente pode não lembrar exatamente o dia em que entrou na menopausa ou o dia em que iniciou o uso de um determinado antidepressivo.

Assim, para uma análise mais correta o especialista pode utilizar, por exemplo, uma granularidade em meses, bimestres, semestres, etc.

Considerando os mapeamentos anteriores, uma granularidade denida em semestres sobre eles sería = 2005/02, que signica que a paciente entrou na menopausa no segundo semestre de 2005, = 2005/0e 5 = 2006/01, que signica que a paciente usou um determinado antidepressivo do segundo semetre de 2005 até o primeiro semestre de 2006.

Neste caso, o átomo temporal before(s1,e2) do pth P não é mais satisfeito, pois o especialista associou a qualquer data de um mesmo semestre um mesmo valor.

Considerando agora um pth P0 = (Paciente(x), {Menopausa(x,sim,s1), Antidepressivo(x,y,e2)}, {meets(s1,e2)}) e a granularidade em semestres, o átomo temporal meets(s1,e2) é satisfeito pela seqüência temporal da tupla U.

Portanto, para realizar uma mineração bem sucedida, minerando pth's ricos em informações temporais, ou seja, com grande diversidade entre os predicados temporais, e com coerência com a aplicação, é fundamental que o usuário dena de forma adequada uma granularidade.

Para possibilitar que o usuário especique o tipo de granularidade que ele deseja utilizar durante o processo de mineração foi desenvolvida a função Granularity.

Esta função é chamada sempre que o suporte de um pth vai ser calculado e permite que sejam especicados sete tipos de granularidade, ou seja, pode ser dia,semana,quinzena,mes,bimestre,trimestre,semestre ou ano.

O algoritmo anterior tem como entrada um intervalo cujo início e m são datas, e uma granularidade.

Na saída do algoritmo o mesmo intervalo de entrada é retornado, entretanto, mapeado na granularidade escolhida pelo usuário.

Função Granularity(intervalo, granularidade) Por exemplo, se o intervalo de entrada for e a granularidade for denida em meses, o intervalo retornado pelo algoritmo será.

O suporte de um pth é calculado somente após todos os intervalos que fazem parte de seus eventos terem sido mapeados de acordo com a granularidade especicada.

Aumento da Performance da Etapa de Avaliação Como já mencionado nesta dissertação, a etapa de avaliação é uma etapa dos algoritmos de mineração de dados importante e complexa e possui um custo computacional elevado.

Por este motivo o MILPRIT* utiliza algumas técnicas para melhorar o desempenho desta etapa.

Para um bom entendimento destas técnicas, é necessário que algumas denições seja introduzidas.

Matriz característica de um pth. Seja {w1,wn} um alfabeto de modos sobre o esquema R = {K,R1,Rn}.

A matriz característica de um pth P denida por MC(P), contém os modos {w1,wn} de e números {m1,mn}, onde, mi é a freqüência com que cada modo foi utilizado na geração dos átomos de P.

A estrutura de uma matriz característica é mostrada.

Estrutura da matriz característica de um pth Exemplo 5111 Considere o alfabeto de modos = {w1 = Hormonio(x,#), w= Fumo(x,#), w= Birads(x,#)} e o conjunto Cobtido após a etapa de poda, mostrado na seção anterior.

Relembrando, o conjunto Cé constituído pelos pth's P= {Paciente(x), E3, T3}, P0 = {Paciente(x),E0,T } e P5 = {Paciente(x),E5,T5}.

Matriz característica de Pe P4, matriz característica de P5 Os pth's Pe Ppossuem dois átomos gerados pelo modo w1, um átomo gerado do modo we nenhum do átomo gerado pelo modo w3.

Já o pth P5 possui dois átomos gerados pelo modo w1, um átomo gerado pelo modo we um átomo gerado pelo modo w3.

Antes de efetivamente calcular o suporte de todos os pth's que restaram em Ck após a poda, o MILPRIT* particiona o conjunto Ck, ou seja, insere em uma mesma partição pth's com matrizes característica iguais.

O fato de pth's com matrizes característica iguais serem inseridos em uma mesma partição permite que seja associada a cada partição uma única expressão SQL (denida abaixo).

Com isso, para calcular o suporte dos pth's de cada partição é realizada uma única consulta ao banco de dados (disco), agilizando a etapa de avaliação.

Expressão SQL associada a uma partição. Seja o esquema de banco de dados R = {K(at1), R1(at1,at2,Tit), R2(at1,at2,Tit), R3(at1,at2,Tp), Rn}, onde Tit representa dois atributos temporais st e en que representam o início e o m de um intervalo, respectivamente, e Tp representa o atributo temporal pontual p.

Seja também uma partição constituída por uma único pth P = (K(x), {R1(x,y,e1), R2(x,z,f2), R3(x,h,s}, {T }).

A expressão SQL associada a tem a seguinte estrutura, Observe que a expressão SQL é construída com base nos pth's de uma determinada partição, ou seja, a ordem com que as tabelas são selecionadas respeita a seqüência dos átomos de dados dos pth's.

Isto simplica a construção das seqüências das tuplas e evita que sejam consideradas tuplas que certamente não suportarão os pth's.

Exemplo 511Considere os conjunto Cconstituído pelos pth's P3,Pe P5 e o seguinte esquema de banco de dados, R = {Paciente(NomePa,Hormonio(NomePac,NomeHorm,st,en), Fumo(NomePac,Qtde,st,en),Birads(NomePac,Categoria,p)} Como os pth's Pe Ppossuem matrizes característica iguais, eles são inseridos em uma mesma partição (Partição 1) e o pth P5 é inserido em outra partição Partição.

Portanto, a divisão do conjunto C resulta em partições.

Conjunto Capós particionamento.

Após particionar o conjunto Ck, o MILPRIT* ainda insere os pth's de cada partição em uma árvore hash similar a utilizada em.

Com isso, para vericar se os pth's são suportados por uma tupla do banco de dados, não é preciso analisar todos os pth's da partição, mas sim os pth's que são potencialmente suportados pela tupla, ou seja, os que estão em alguns ramos da árvore.

Função hash. A função hash é denida por h(x) = ((x mod (N1)) + 1), onde, x é o elemento da seqüência do pth e N é o número máximo de lhos em cada nó.

Esta função hash possui as seguintes propriedades, se o elemento que está sendo analisado é uma constante, então 0 < h N.

Se o elemento que está sendo analisado é uma variável, então h(v) = 0.

Para inserir um pth na árvore hash, a função hash é aplicada em cada elemento da seqüência do pth para decidir qual caminho seguir na árvore.

Após a aplicação da função hash em todos os elementos da seqüência do pth, ele é inserido em um nó folha.

É importante salientar que todos os pth's de uma determinada partição possuem a mesma quantidade de elementos em suas seqüências.

Portanto, uma árvore hash possui profundidade igual a quantidade de elementos das seqüências dos pth's da partição que está sendo analisada.

Exemplo 511Considere a Partição 1 do conjunto C4, constituída pelos pth's Pe P4, e número máximo de lhos em cada N = 3.

P0 = (Paciente(x),{Hormonio(x,y1,e1),Hormonio(x,y2,e2),Fumo(x,10,f},T2}) P0 = (Paciente(x),{Hormonio(x,y1,e1),Hormonio(x,y2,e2),Fumo(x,20,f},T3}) Para possibilitar a aplicação da função hash sobre os elementos das seqüências dos pth's, considere a substituição das constantes das seqüências pela soma dos códigos ASC de cada caracter.

Assim, Os valores retornados pela função hash aplicada sobre os elementos das seqüências dos pth's Pe Psão, h(9= 2, h(9= 1 e h(y1) = h(y2) = 0.

Para vericar se uma determinada tupla suporta os pth's de uma determinada partição, os quais estão inseridos em uma árvore hash, a função hash é aplicada sobre cada elemento da seqüência de dados da tupla.

Com isso, são alcançados somente nós folhas que possuem pth's com possibilidade de serem suportados pela tupla, evitando analisar pth's que certemente não serão suportados por ela.

Para garantir que sejam recuperados Árvore hash após a inserção dos pth's todos os pth's com possibilidade de serem suportados pela tupla percorre-se o caminho informado pela função hash aplicada sobre cada elemento da seqüência de dados da tupla e o caminho zero.

Assim, são recuperados todos os pth's cujas seqüências de dados possuem constantes e variáveis.

Somente após a construção de uma árvore hash para cada partição de um conjunto Ck é que os pth's têm seu suporte calculado.

No calculo do suporte somente uma árvore hash é analisada de cada vez, ou seja, é analisada uma partição de cada vez, possibilitando a execução de uma única consulta ao banco de dados para calcular o suporte de todos os pth's da partição, diminuindo assim o tempo gasto na etapa de avaliação.

O protótipo MILPRIT possui alguns problemas.

Um deles é o fato de não realizar gerenciamento de memória, fazendo com que os padrões gerados ocupem rapidamente toda a memória principal disponível, o que faz com que o sistema aborte a execução logo nas primeiras iterações.

Este é um problema que deve ser tratado em grande parte dos algoritmos de mineração de dados que utilizam a técnica Apriori, uma vez que, a cada iteração uma quantidade enorme de novos padrões são gerados.

Outro problema do protótipo MILPRIT ocorre na etapa de geração, onde, determinados pth's não são gerados ou são gerados padrões que não são interessantes para o usuário.

A seguir serão descritos os recursos que foram utilizados para solucionar estes problemas.

Otimização da Ocupação da Memória Principal Primeiramente, observa-se como é a relação entre as etapas de geração e poda do protótipo MILPRIT, etapas essas responsáveis diretas pela ocupação e liberação da memória principal.

MILPRIT, Execução das Etapas de Geração e Poda dos Padrões Em uma iteração k são gerados todos os possíveis padrões a partir dos padrões freqüentes do conjunto Fk, obtido na iteração anterior.

Os novos padrões são inseridos diretamente no conjunto Ck.

Somente após a geração de todos os possíveis padrões a partir de Fk1 é que o conjunto Ck é submetido a etapa de poda, onde grande parte dos padrões são eliminados, tendo como conseqüência uma considerável liberação da memória principal.

Ao acompanhar detalhadamente a execução do protótipo MILPRIT, um importante fato foi constatado, a memória principal é completamente ocupada sempre na etapa de geração, não possibilitando sequer que um único padrão seja podado.

O que fazer.

Em vista da constatação anterior surgiram dois caminhos dos quais foi escolhido apenas um para solucionar o problema da ocupação da memória.

O primeiro caminho consiste em denir um limite de memória principal que pode ser ocupada pelos padrões gerados, se esse limite for ultrapassado, os padrões devem ser armazenados em disco.

Após a geração, os padrões gerados devem ser recuperados do disco em quantidade limitada pela memória principal disponível para, ai sim, serem submetidos à etapa da poda.

Este procedimento deve ser realizado até que todos os padrões gerados fossem recuperados do disco.

Esta idéia com certeza soluciona o problema da ocupação da memória principal, más leva a um outro problema, o tempo de execução aumenta, uma vez que o acesso a disco é mais lento que o acesso a memória principal.

Assim, este caminho foi descartado, pois o processo de mineração de pth's exige um tempo considerável e não seria viável considerar a hipótese de aumentar ainda mais este tempo.

Portanto, foi escolhido o segundo caminho, que consiste em intercalar as etapas de geração e poda e continuar trabalhando com todos os pth's na memória principal.

Embora a escolha tenha sido por este caminho, é importante resaltar que ele também possui um problema.

Como todos os pth's são mantidos na memória principal, se o MILPRIT* for executado sobre condições extremas como por exemplo domínios de dados muito grandes, expressões regulares muito pouco seletivas e nível mínimo de suporte muito baixo (próximo de zero), vai chegar um momento em que os pth's vão ocupar toda a memória principal.

Mesmo com este problema em potencial, a escolha por este caminho foi baseada em outro fato importante constatado durante exaustivos testes do protótipo MILPRIT, o número de pth's podados é sempre muito elevado em relação ao número de pth's gerados.

Após implementado, o algoritmo MILPRIT* foi testado em condições extremas e mesmo assim nunca foram atingidos grandes níveis de consumo da memória principal, pois ele gera um certa quantidade de pth's e imediatamente poda grande parte destes pth's, liberando a memória.

O modo como esta técnica foi implementada foi mostrada na visão geral do algoritmo MILPRIT*.

O lação responsável pela intercalação das etapas de geração e poda vai da linha 6 a 11.

Detalhes desta técnica serão descritos a seguir.

MILPRIT*, Execução das Etapas de Geração e Poda dos Padrões Em uma iteração k são gerados, atravéz da função Gen(Fk, R), para cada pth i de Fk, uma quantidade de pth's que depende diretamente do tamanho do domínio dos dados (instanciação) e do tipo da variável temporal do novo átomo de dados (extensão).

Por exemplo, considere um conjunto F1 com 10000 pth's, tal que, P = (Paciente(x), {Hormonio(x,y,e1)}, {}) é o primeiro pth de F1.

Considere também uma expressão regular R = Hormonio(x, $, #)Fumo(x, $, #)Birads(x, $, #) e um domínio de dados com 1000 constantes.

Quando P é submetido a Gen(F1, R) são gerados 1000 pth's P0 pela instanciação de P.

De acordo com R, P pode ser estendido atravéz dos átomos de dados Fumo(x,z,f2) e Birads(x,h,s2).

Para o átomo Fumo(x,z,f2) são gerados 6 pth's P0 pela extensão de P.

Para o átomo Birads(x,w,f2) é gerado 1 pth P0 pela estensão de P.

Portanto, Gen(F1, R) retorna 1007 pth's especializados a partir de P.

Diferentemente do protótipo MILPRIT que especializa os 10000 pth's de F1 para depois submeter os pth's especializados à etapa da poda, no MILPRIT* os 1007 pth's gerados a partir de P são imediatamente submetidos a etapa da poda, onde a maioria deles são eliminados, resultando na liberação da memória principal.

Este procedimento é realizado para cada pth de F1.

Observe que como cada pth de F1 resulta em um conjunto de pth's que é imediatamente reduzido na etapa da poda, o nível de ocupação da memória se mantem sempre baixo durante todo o processo de mineração.

Otimização da Etapa de Geração dos Padrões O motivo pelo qual o protótipo MILPRIT minera determinados padrões que não interessam ao usuário ou não minera determinados padrões está diretamente relacionado a etapa de geração.

Este problema será apresentado por meio de um exemplo.

Considere o pth P = (Paciente(x), { Hormonio(x,var1,e1) }, { }), o domínio dom(2,Hormonio) = {estradiol}, a expressão regular R = Hormonio(x,var1,#) Fumo(x,$,#) e o alfabeto = {w1 = Hormonio(x,$,#), w= Hormonio(x,var1,#), w= Fumo(x,$,#)}.

Para especializar P, o protótipo MILPRIT chama uma função de instanciação que primeiramente encontra as variáveis de P que serão instanciadas.

Relembrando, um padrão só é instanciado se não existe nenhuma variável já instanciada a direita da variável que vai ser instanciada e se a entrada do modo que gerou o átomo ao qual a variável que vai ser instanciada pertence for $ (denição 411).

É justamente neste segundo caso que se encontra um dos problemas da etapa de geração do MILPRIT.

Para encontrar o modo que gerou um determinado átomo, à função de instanciação compara somente o predicado do átomo com o predicado de cada modo do alfabeto de modos, até encontrar o primeiro predicado de um modo que é igual o predicado do átomo que está sendo analisado.

Quando isso acontece, a função encerra a busca e considera que o átomo é de acordo com o modo.

O problema é que, quando o alfabeto tem mais de um modo com mesmo predicado, a função pode gerar um resultado incorreto.

Neste exemplo, a função de instanciação do protótipo MILPRIT considera (incorretamente) que a variável var1 pode ser instanciada, pois o primeiro modo com predicado igual ao do átomo Hormonio(x,var1,e1) encontrado pela função é o Hormonio(x, $, #).

Assim, como o modo tem um símbolo $ na mesma posição de var1, P0 é instanciado resultando no padrão P1 = (Paciente(x),{Hormonio(x,estradiol,e1)},{}).

Observe na expressão regular que o usuário deseja obter padrões onde pacientes zeram o uso de qualquer hormônio, não um hormônio específico como o estradiol.

Portanto, o modo correto que deveria ser retornado pela função de instanciação é o Hormonio(x,var1,#), que faria com que P não fosse instanciado, pois não existe um símbolo $ na mesma posição de y.

Após a instanciação, como P não contém constantes, o protótipo MILPRIT chama a função de extensão, que insere um novo átomo de dados no m da seqüência de dados de P.

Para isso, primeiramente é chamada a função que retorna a palavra associada a P possibilitando descobrir através da expressão regular R qual átomo pode ser inserido em P.

Outro problema da etapa de geração do protótipo MILPRIT está nesta função.

Para encontrar a palavra associada a um determinado padrão, ele compara somente os predicados de cada átomo do padrão com os predicados de cada modo do alfabeto, de maneira similar à função de instanciação.

Assim, uma palavra errada pode ser retornada.

Para o pth P a função retorna (incorretamente) a palavra W = w1 = Hormonio(x, $, #).

Isto faz com que P não seja estendido, pois o modo Hormonio(x, $, #) não é considerado em R.

A palavra correta associada ao padrão P que deveria ser retornada é W = w= Hormonio(x,var1,#).

Assim, de acordo com a expressão regular R, P pode ser estendido pela inclusão dos átomos Hormonio(x,y,e2) e Fumo(x,z,f2) resultando nos seguintes padrões.
No algoritmo MILPRIT, a função de instanciação, chamada Instantiation, e a que encontra a palavra associada a um determinado pth, chamada Match, foram implementadas de modo que sempre que elas forem vericar se um átomo é de acordo com um modo considerem, além dos predicados, todas as entradas.

Assim, o problema da etapa de geração foi solucionado no algoritmo MILPRIT Neste capítulo o algoritmo MILPRIT* foi apresentado.

Foram detalhadas e explicadas com exemplos as principais funçõess utilizadas na etapa de geração dos pth's, como por exemplo as funçõess de especialização por instanciação e por extensão.

Na etapa de avaliação foram apresentadas todas as estruturas e condiçõess necessárias para vericar se uma determinada tupla suporta um determinado pth, condição fundamental para o calculo do suporte.

Ainda na etapa de avaliação, foram apresentadas algumas técnicas, como por exemplo o particionamento de um conjunto Ck de pth's candidatos e a inserção dos pth's de cada partição em uma árvore hash, desenvolvidas e implementadas com o objetivo agilizar o calculo do suporte.

Finalizando o capítulo, foram apresentados os problemas existentes no protótipo MIL-PRIT e que foram solucionados no algoritmo MILPRIT O primeiro deles, a ocupação da memória principal, foi solucionado mantendo sempre com todos os pth's na memória principal, por motivos de performance, mas intercalando as etapas de geração e poda, fazendo com que grande parte da memória ocupada após a especialização de cada pth seja imediatamente liberada.

O problema da etapa de geração foi solucionado criando conceitos para vericar de forma correta se um átomo é de acordo com um modo.

Estes conceitos foram implementados na função de instanciação e na função que encontra a palavra associada a um determinado pth.

Neste capítulo serão apresentados os resultados de vários experimentos realizados com o MILPRIT* em bancos de dados sintéticos, com o intuito de analisar sua performance e escalabilidade.

Serão apresentados também resultados de experimentos realizados em um banco de dados real.

Os experimentos com o algoritmo MILPRIT* foram realizados em um Pentium Core Duo de 2GHz com GB de memória RAM executando o sistema operacional Linux.

Foi desenvolvido um gerador de dados sintéticos que produz bancos de dados temporais, onde pth's que satisfazem expressões regulares R, também produzidas pelo gerador, podem aparecer.

Os bancos de dados e as expressões regulares são produzidas de acordo com alguns parâmetros de entrada que são mostrados na tabela.

Nos testes apresentados neste capítulo, foi usada a seguinte notação para os bancos de dados gerados, -Pp-Mm-Uu-Bb-Nn-V v-Qq, onde, i, p, m, u, n, v e q são os valores definidos para os parâmetros de entrada I,P,M,U,B,N,V e Q, respectivamente.

Os parâmetros de entrada S,D e T, são definidos como, S = U, D =U e T =.

U As expressões regulares R produzidas pelo gerador tem o formato (B1 Bk), onde cada Bi é um bloco com o formato (N1& &Nl) e cada Nj é um termo com o formato (m1| |mh) e mj são modos.

Assim, o gerador produz uma grande variedade de Parâmetros usados pelo Gerador de Dados Sintéticos expressões regulares quando são variados o número de blocos (, o número máximo de termos em cada bloco (n) e o número máximo de modos em cada termo (v).

Por exemplo, uma expressão regular R que poderia ser gerada pelo gerador de dados sintéticos é R = ((Hormonio(x, $, #) | Fumo(x, $, #)) & (Fumo(x, $, #) | Birads(x, $, #)).

Essa expressão regular tem um bloco, dois termos, e cada termo tem dois modos.

A conguração dos bancos de dados utilizados nos testes é mostrada na tabela.

O banco de dados apresentado na primeira linha da IPMUBNV, contém tabelas cujo atributo temporal é intervalar, tabelas cujo atributo temporal é pontual, cada uma das quatro tabelas possui atributos não temporais, 5000 tuplas e foram inseridos 1000 pth's p-válidos.

A expressão regular gerada possui blocos com termos em cada bloco e 1 modo em cada termo.

Na segunda linha da coguração IPMUBb-NV Q1 representa vários bancos de dados, onde apenas o parâmetro número de blocos varia de um banco de dados para outro.

Mostra o tempo de execução do algoritmo MILPRIT* para os quatro primeiros bancos de dados da tabela.

Mostra a performance do algoritmo à medida que o suporte mínimo é incrementado de 05% a 3%.

Como esperado, o tempo de execução do algoritmo diminui, pois poucos candidatos são potencialmente freqüentes para altos valores de suporte mínimo, e portanto, quanto menor for o suporte, mais padrões são encontrados.

Mostram a performance do algoritmo enquanto os parâmetros da expressão regular variam.

Nestes testes o suporte mínimo foi mantido em 2%.

Ilustra o tempo de execução à medida que o número de blocos na expressão regular é incrementado de 1 a 5.

Quando o número de blocos aumenta, a seletividade da restrição diminui, em conseqüência disso, o número de pth's p-válidos aumenta, resultando no aumento do tempo de execução do MILPRIT.

Ilustra o tempo de execução à medida que o número máximo de termos por bloco na expressão regular (n) é incrementado de 1 a 5.

Pode ser observado que o tempo de execução aumenta.

Isto ocorre porque quando a expressão regular tem poucos termos por bloco, os pth's que a satisfaz tem comprimento pequeno.

Conseqüentemente, os pth's são encontrados pelo MILPRIT* em níveis (iteraçõess) baixos, entretanto, quando a expressão regular tem muitos termos por bloco os pth's que a satisfaz tem comprimento grande.

Conseqüentemente, os pth's são encontrados pelo MILPRT* em níveis (iteraçõess) mais elevados, resultando no aumento do tempo de execução.

Mostra a performance do algoritmo à medida que o número máximo de modos por termo na expressão regular (v) é incrementado de 1 a 5.

Neste caso, a análise é simila(variação do número de blocos), pois quando o número máximo de modos por termo aumenta também há uma diminuição da seletividade da restrição.

Ilustra a relação entre a quantidade de pth's gerados e podados durante a execução do MILPRIT* sobre o banco de dados IPMUBNV Q1.

Mostram a quantidade de pth's que foram gerados e podados quando o MILPRIT* foi executado com suporte de 05% e 2%, respectivamente.

Note que nos dois casos a quantidade de pth's podados é muito elevada.

Com isso, uma quantidade pequena de pth's em relação a quantidade de pth's gerados é mantida na memória principal e levada para a etapa de avaliação.

Este comportamento foi observado em todos os testes realizados.

Relação entre a quantidade de pth's gerados e podados.

Os resultados dos testes apresentados foram realizados com o objetivo de mostrar o tempo que o MILPRIT* gasta na execução de cada etapa em cada nível.

Os testes foram realizados sobre o banco de dados IPMUBNV Q1 com suporte de 05% (gura 63 e 2% (gura 63).

O tempo gasto na etapa de avaliação dos dois casos, principalmente nos níveis (iteraçõess)mais elevados, é extremamente alto em relação ao tempo gasto na etapa de geração/poda.

Isso acontece porque nos níveis (iteraçõess) mais elevados é calculado o suporte de uma grande quantidade de padrões extensos (com grande comprimento), resultando na execução de grandes expressões SQL's sobre o banco de dados.

Neste caso ca claro o motivo de tanto esforço para otimizar a etapa de avaliação.

Tempo de execução de cada etapa em cada nível.

Nesta seção serão apresentados os resultados dos principais experimentos realizados para análise da escalabilidade do algoritmo MILPRIT O suporte mínimo utilizado para estes testes foi xado em 2%.

É mostrado como o MILPRIT* se comportou quando foi avaliado sobre o quinto banco de dados da IPMUu-BNV, quando o número de tuplas (u) foi incrementado de 20000 a 100000.

Claramente, quanto maior o número de tuplas nas tabelas do banco de dados maior é o tempo de execução do algoritmo.

Isso ocorre porque a fase de avaliação é a responsável por grande parte do tempo de execução, assim, quanto mais tuplas mais tempo o MILPRIT* gasta no cálculo do suporte dos pth's.

Mostra o tempo de execução quando o MILPRIT* foi executado sobre o sexto banco de dados da IPMUBNV Qq.

Observa-se que conforme a quantidade de pth's freqüentes (q) foi incrementada de 1000 a 4000 no banco de dados, o tempo de execução do algoritmo aumentou.

Mostra como o MILPRIT* se comportou quando foi executado sobre o sétimo banco de dados da IPMm-UBNV e o número de atributos não temporais em cada tabela (m) foi incrementado de a 6.

Quando o número de atributos não temporais aumenta, o número de elementos que fazem parte das seqüências de dados dos pth's também aumenta.

Conseqüentemente o número de atributos escaneados durante a fase de avaliação aumenta, resultando no aumento do tempo de execução.

Note que nos três testes mostrados, o tempo de execução do MILPRIT* aumentou linearmente quando os parâmetros correspondentes (número de tuplas, pth's freqüentes e atributos não temporais) foram incrementados.

Análise de escalabilidade variando alguns parâmetros Em nosso laboratório está em desenvolvimento um projeto, chamado MIMED, que integra um sistema de mineração de padrões temporais, chamado MILPRIT*, e um atlas indexado de mamograas digitais, chamado AMDI1.

Esses sistemas são designados para serem usados por radiologistas e estudantes de radiologia, com o intuído de auxiliá-los na prevensão e no diagnóstico de câncer de mama.

Para a realização dos testes em dados reais foi utilizado um banco de dadoscuja modelagem foi baseada na classicação Bi-Rads, padrão publicado pela ACR Colégio Americano de Radiologi.

A classicação Bi-Rads tem como objetivo padronizar os laudos mamográcos levando em consideração a evolução do diagnóstico e recomendar uma conduta.

Esta padronização evita laudos extensos, sem objetividade, e não conclusivos, além de facilitar a descrição de eventuais lesões.

O banco de dados real é um banco de dados relacional gerenciado pelo Sistema de Gerenciamento de Banco de Dados POTGRESQL e contém informaçõess sobre pacientes do sexo feminino, como mamograas digitais, estilo de vida e hábitos, por exemplo, período de tempo em que fumou, ingeriu bebida alcoólica, etc.

Histórico clínico, por exemplo, período de tempo em que usou medicamentos como hormônios, antidepressivos, anticoncepcionais, data da primeira gravidez, data da menopausa, resultados dos exames mamográcos baseados na classicação Bi-Rads, etc.

A classicação Bi-Rads divide os laudos em sete categorias, quanto maior for a categoria maiores são as chances da paciente ter câncer de mama.

A ostra como as categorias são divididas.

Os dados registrados no banco de dados real foram obtidos junto ao Instituto Victório Valeri de Diagnósticos Médicos de Ribeirão Preto SP.

Esses dados foram coletados durante um período de três meses e totalizam 1365 casos.

O sistema AMDI está disponível.

O banco de dados utilizado neste trabalho está disponível.

Categorias denidas pela classicação Bi-Rads.

O esquema do banco de dados real é o seguinte, Nos testes foi utilizada uma expressão regular que permitiu gerar qualquer conguração de pth's, restringindo o átomo Birad a aparecer somente no nal, após qualquer outro átomo.

Inicialmente foi utilizada a granularidade em dias, o que levou a constatação de que, para esta aplicação, este tipo de granularidade resulta na mineração de pth's pobres em informaçõess temporais.

A maioria dos pth's minerados continham apenas o predicado temporal before.

Com o objetivo de minerar pth's mais conclusivos foram realizados testes considerando também a granularidade em semestres, que resultou na mineração de pth's com uma maior variedade de predicados temporais.

Alguns pth's que foram encontrados no banco de dados real considerando a granularidade em semestres são, O pth P1 foi vericado em 25 pacientes do banco de dados e signica que pacientes começaram a tomar o antidepressivo FLUOXETINA no momento em que entraram na menopausa.

O pth Pfoi vericado em 50 pacientes e signica que pacientes tiveram lhos durante o tempo em que fumavam (ou ainda fumam) 20 cigarros por dia.

O pth Pfoi vericado em 1pacientes e signica que pacientes que fumavam 20 cigarros por dia, apresentaram Bi-Rads categoria no futuro.

O pth Pfoi vericado em 177 pacientes e signica que pacientes que já tiveram lhos apresentaram Bi-Rads categoria após entrarem na menopausa.

Pelo fato do banco de dados real sobre o qual foram realizados os testes ser relativamente pequeno, não foram minerados pth's bastante expressivos e conclusivos.

Apesar do grande trabalho despendido na coleta das informaçõess e na construção do banco de dados real, não foi reunida uma grande variedade de informaçõess, fundamental para que um banco de dados voltado para este tipo de aplicação seja conável e consistente, possibilitando a mineração de pth's com mais informaçõess relevantes.

Futuramente, quando o sistema AMDI estiver concluído, poderão ser realizados novos testes mais elaborados, tendo em vista que este sistema permite que radiologistas e estudantes de radiologia insiram ilimitadamente novos casos em seu banco de dados.

Assim, é esperado que seja obtido um banco de dados maior, mais conável e com uma grande variedade de informaçõess, possibilitando a mineração de pth's mais conclusivos.

A mineração de padrões temporais freqüentes em grandes bancos de dados constitui um problema importante em mineração de dados.

A distinção existente entre os padrões temporais pontuais proposicionais ou de primeira ordem, conhecidos também como padrões seqüenciais proposicionais ou de primeira ordem, e os padrões temporais intervalares proposicionais ou de primeira ordem fazem com que fatos importantes não sejam expressos.

Nesta dissertação foi proposto um novo padrão temporal chamado padrão temporal híbrido (pth) e foi mostrado que ele necessita da expressividade da Lógica Temporal de Primeira Ordem para ser especicado.

Lógica Temporal de Intervalos LTI.

Foi apresentada a LTI criada por Allen, que é uma lógica temporal de primeira ordem, que foi adaptada e utilizada para especicar os pth's.

A base da LTI considera períodos de tempo, relacionamentos entre estados e seus efeitos.

Como os períodos de tempo são representados na LTI original em termos de intervalos (períodos com duração) e pontos não são considerados períodos, a LTI foi adaptada de forma que pontos são considerados períodos sem duração.

Portanto, como intervalos e pontos são considerados períodos, podem ser aplicados relacionamentos entre eles.

O problema de mineração dos pth's com restriçõess de expressões regulares também foi explorado nesta pesquisa.

Mineração de pth's com restriçõess de expressões regulares.

Foram desenvolvidas técnicas para a mineração de pth's freqüentes em um banco de dados BD com relação a um suporte mínimo e a uma expressão regular denida pelo usuário.

O objetivo do uso das restriçõess de expressões regulares é reduzir o número de pth's minerados e fornecer ao usuário um maior controle do processo de mineração, am de que sejam encontrados somente os pth's que o interessam.

Foi proposto então o algoritmo MILPRIT*, que minera pth's que satisfazem uma expressão regular.

As idéias principais do MILPRIT* são relembradas a seguir, MILPRIT* (Mining Interval Logic Patterns with Regular expressIons consTraints).

Este algoritmo realiza a mineração dos pth's nível por nível incorporando restriçõess de expressões regulares (não-antimonotônicas) nas etapas de geração e poda dos pth's candidatos.

Ele intercala as etapas de geração e poda com o objetivo de controlar a ocupação da memória principal.

Na etapa de geração, ele emprega operadores de especialização, garantindo que sejam gerados todos os pth's possíveis e evitando que sejam gerados pth's duplicados.

Na etapa de avaliação, ele utiliza algumas técnicas, como por exemplo a divisão dos pth's em partiçõess e uma árvore hash para torná-la mais eficiente.

Foram realizados vários experimentos em dados sintéticos para avaliar a performance e a escalabilidade do algoritmo MILPRIT Foram realizados também experimentos em dados reais.

Os resultados obtidos nos dados sintéticos conrmam a viabilidade de, além de se usar um suporte mínimo, também incorporar restriçõess de expressões regulares durante o processo de mineração.

Com o objetivo de orientar estudos futuros, algumas possíveis extensões e otimizaçõess deste trabalho podem ser destacadas.

Entre elas, Considerar o predicado temporal equals.

Para simplicar a representação e facilitar a exploração da essência do problema de mineração padrões temporais híbridos, a formulação proposta neste trabalho não inclui padrões temporais onde vários átomos de dados são relacionados a uma mesma variável temporal.

A inclusão do predicado temporal equals permitiria essa nova representação, mas para isso novas teorias devem ser formuladas.

Testes em bancos de dados reais maiores.

Como especialistas armam e os testes em dados reais demonstraram, no caso de bancos de dados mamográcos, para se obter informaçõess conclusivas é necessário uma grande quantidade de casos.

A construção de um grande banco de dados mamográco poderia resultar na descoberta de interessantíssimos pth's pelo algoritmo MILPRIT Comparação entre o armazenamento dos pth's na memória principal e no disco.

Todos os pth's gerados são armazenados na memória principal e as etapas de geração e poda são intercaladas.

Embora o problema da ocupação da memória principal tenha sido suprido por esta abordagem, ela é um problema em potencial.

Testes poderiam ser feitos para vericar a viabilidade de se armazenar os pth's em disco.

Assim, o problema da ocupação da memória principal estaria denitivamente resolvido.

Desenvolvimento de um novo algoritmo para mineração de pth's baseado na técnica do algoritmo PrexSpan.

Existem diversos algoritmos de mineração de padrões temporais e diferentes técnicas nas quais esses algoritmos se baseiam.

Os algoritmos AprioriAll e GSP são exemplos de algoritmos de mineração de padrões seqüenciais baseados na técnica Apriori, assim como o MILPRIT* é um algoritmo de mineração de padrões temporais híbridos também baseado na técnica Apriori.

Como mencionado nesta dissertação, o GSP apresenta melhor performance que o AprioriAll.

Recentemente, foram desenvolvidos outros algoritmos para mineração de padrões seqüenciais que se mostraram mais rápidos que o GSP.

Entre eles, podem ser destacados o algoritmo SPADE.

Testes mostraram que este último tem desempenho melhor, se comparado com o GSP e SPADE.

Diferentemente da técnica Apriori, a técnica empregada no algoritmo PrexSpan procura melhorar a eficiência diminuindo o tamanho do banco de dados a ser percorrido e diminuindo o número de padrões candidatos gerados.

O banco de dados de seqüências é recursivamente projetado em bancos de dados menores e todos os padrões seqüenciais são estendidos levando em conta somente informaçõess contidas nos bancos de dados projetados.

Assim, são gerados somente padrões seqüenciais freqüentes, evitando o tratamento de padrões candidatos gerados aleatoriamente, sem vinculos com o banco de dados, como é o caso dos algoritmos baseados na técnica Apriori.

Um algoritmo que minera os mesmos tipos de padrões que o MILPRIT* poderia ser desenvolvido utilizando a técnica empregada no algoritmo PrexSpan.

Certamente este novo algoritmo será mais rápido que o MILPRIT*, uma vez que neste último a etapa computacionalmente mais cara é a de avaliação (percorrer o banco de dados para calcular o suporte dos pth's e um dos objetivos da técnica empregada no PrexSpan é justamente diminuir o tamanho do banco de dados que será percorrido).